Bottom: ca2b7a951a34d4aa27e8fd129f9ba1e705502dce
Top:    9cb95736016b778ed17f22425f45da2083121886
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-02-09 05:02:38 +0000

Attempt to fix polygon slowness by avoiding full recreation for each operation


---

diff --git a/src/global.h b/src/global.h
index 1fb3420..157e186 100644
--- a/src/global.h
+++ b/src/global.h
@@ -261,12 +261,6 @@ typedef struct			/* holds information about arcs */
     Delta;
 } ArcType, *ArcTypePtr;
 
-typedef struct
-{
-  struct rtree_node *root;
-  int size;			/* number of entries in tree */
-} rtree_t;
-
 typedef struct			/* holds information about one layer */
 {
   char *Name;			/* layer name */
diff --git a/src/polygon1.c b/src/polygon1.c
index d5677e6..25155ab 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -911,6 +911,48 @@ cntrbox_inside (PLINE * c1, PLINE * c2)
 /*****************************************************************/
 /* Routines for making labels */
 
+/* cntr_in_M_PLINE
+returns poly is inside outfst ? TRUE : FALSE */
+static int
+cntr_in_M_PLINE (PLINE * poly, PLINE * outfst, BOOLp test)
+{
+  PLINE *curc;
+  PLINE *outer = outfst;
+  heap_t *heap;
+
+  assert (poly != NULL);
+  assert (outer != NULL);
+
+  heap = heap_create ();
+//  do {
+    if (cntrbox_inside (poly, outer))
+      heap_insert (heap, outer->area, (void *) outer);
+//  /* if checking touching, use only the first polygon */
+//  } while (!test && (outer = outer->f) != outfst);
+
+  /* we need only check the smallest poly container
+   * but we must loop in case the box containter is not
+   * the poly container */
+  while (1) {
+    if (heap_is_empty (heap))
+      break;
+    outer = (PLINE *) heap_remove_smallest (heap);
+    if (poly_ContourInContour (outer, poly)) {
+      for (curc = outer->next; curc != NULL; curc = curc->next)
+        if (poly_ContourInContour (curc, poly)) {
+          /* it's inside a hole in the smallest polygon 
+           * no need to check the other polygons */
+          heap_destroy (&heap);
+          return FALSE;
+        }
+      heap_destroy (&heap);
+      return TRUE;
+    }
+  }
+  heap_destroy (&heap);
+  return FALSE;
+}				/* cntr_in_M_PLINE */
+
 /* cntr_in_M_POLYAREA
 returns poly is inside outfst ? TRUE : FALSE */
 static int
@@ -926,7 +968,9 @@ cntr_in_M_POLYAREA (PLINE * poly, POLYAREA * outfst, BOOLp test)
   heap = heap_create ();
   do
     {
-      if (cntrbox_inside (poly, outer->contours))
+      if (outer->contours == NULL) {
+        printf ("cntr_in_M_POLYAREA: outer->contours was NULL\n");
+      } else if (cntrbox_inside (poly, outer->contours))
 	heap_insert (heap, outer->contours->area, (void *) outer);
     }
   /* if checking touching, use only the first polygon */
@@ -1040,6 +1084,63 @@ label_contour (PLINE * a)
 }				/* label_contour */
 
 static BOOLp
+cntr_label_PLINE (PLINE * poly, PLINE * pl, BOOLp test)
+{
+  assert (ppl != NULL);
+  if (poly->Flags.status == ISECTED) {
+    printf ("cntr_label_PLINE: Labelling intersected contour\n");
+    label_contour (poly);	/* should never get here when BOOLp is true */
+
+  } else {
+ 
+    fprintf (stderr, "*********** SOMETHING ODD GOING ON HERE?\n");
+//    return FALSE;
+
+    if (cntr_in_M_PLINE (poly, pl, test)) {
+
+      if (test)
+        return TRUE;
+      poly->Flags.status = INSIDE;
+
+    } else {
+
+      if (test)
+        return False;
+      if (poly->Flags.status == UNKNWN) {
+        printf ("cntr_label_PLINE: Changing UNKNWN to OUTSIDE\n");
+        poly->Flags.status = OUTSIDE;
+      }
+
+    }
+  }
+  return FALSE;
+}				/* cntr_label_PLINE */
+
+static BOOLp
+cntr_label_POLYAREA_non_isected (PLINE * poly, POLYAREA * ppl, BOOLp test)
+{
+  assert (ppl != NULL && ppl->contours != NULL);
+  if (poly->Flags.status == ISECTED)
+    {
+      printf ("cntr_label_POLYAREA_non_isected: Skipping labelling intersected contour\n");
+      //label_contour (poly);	/* should never get here when BOOLp is true */
+    }
+  else if (cntr_in_M_POLYAREA (poly, ppl, test))
+    {
+      if (test)
+	return TRUE;
+      poly->Flags.status = INSIDE;
+    }
+  else
+    {
+      if (test)
+	return False;
+      poly->Flags.status = OUTSIDE;
+    }
+  return FALSE;
+}				/* cntr_label_POLYAREA */
+
+static BOOLp
 cntr_label_POLYAREA (PLINE * poly, POLYAREA * ppl, BOOLp test)
 {
   assert (ppl != NULL && ppl->contours != NULL);
@@ -1063,6 +1164,61 @@ cntr_label_POLYAREA (PLINE * poly, POLYAREA * ppl, BOOLp test)
 }				/* cntr_label_POLYAREA */
 
 static BOOLp
+M_POLYAREA_label_separated (PLINE * afst, POLYAREA * b, BOOLp touch)
+{
+  PLINE *curc = afst;
+  int i = 0;
+
+  for (curc = afst; curc != NULL; curc = curc->next) {
+    printf ("Testing separated contour %i\n", ++i);
+    if (cntr_label_POLYAREA (curc, b, touch) && touch)
+      return TRUE;
+  }
+  return FALSE;
+}
+
+static BOOLp
+M_POLYAREA_label_isected (POLYAREA * afst, PLINE * b, BOOLp touch)
+{
+  POLYAREA *a = afst;
+  PLINE *curc;
+
+  if (b == NULL) {
+    printf ("M_POLYAREA_label_isected: No PLINE to test against\n");
+    return FALSE;
+  }
+
+  assert (a != NULL);
+  do {
+    for (curc = a->contours; curc != NULL; curc = curc->next)
+      if (cntr_label_PLINE (curc, b, touch) && touch)
+        return TRUE;
+  } while (!touch && (a = a->f) != afst);
+  return FALSE;
+}
+
+
+static BOOLp
+M_POLYAREA_label_non_isected (POLYAREA * afst, POLYAREA * b, BOOLp touch)
+{
+  POLYAREA *a = afst;
+  PLINE *curc;
+
+  assert (a != NULL);
+  do
+    {
+      for (curc = a->contours; curc != NULL; curc = curc->next)
+	if (cntr_label_POLYAREA_non_isected (curc, b, touch))
+	  {
+	    if (touch)
+	      return TRUE;
+	  }
+    }
+  while (!touch && (a = a->f) != afst);
+  return FALSE;
+}
+
+static BOOLp
 M_POLYAREA_label (POLYAREA * afst, POLYAREA * b, BOOLp touch)
 {
   POLYAREA *a = afst;
@@ -1118,8 +1274,8 @@ PutContour (jmp_buf * e, PLINE * cntr, POLYAREA ** contours, PLINE ** holes,
   assert (cntr->Count > 2);
   cntr->next = NULL;
 
-  printf ("PutContour %p, %p, %p, %p, %p, %p\n",
-          cntr, contours, holes, owner, parent, parent_contour);
+//  printf ("PutContour %p, %p, %p, %p, %p, %p\n",
+//          cntr, contours, holes, owner, parent, parent_contour);
 
   if (cntr->Flags.orient == PLF_DIR)
     {
@@ -1127,6 +1283,7 @@ PutContour (jmp_buf * e, PLINE * cntr, POLYAREA ** contours, PLINE ** holes,
         printf ("PATH 1\n");
         r_delete_entry (owner->contour_tree, (BoxType *)cntr);
       }
+//      printf ("Put contour adding a new contour\n");
       InsCntr (e, cntr, contours);
     }
   /* put hole into temporary list */
@@ -1137,6 +1294,7 @@ PutContour (jmp_buf * e, PLINE * cntr, POLYAREA ** contours, PLINE ** holes,
 	{
 	  cntr->next = parent_contour->next;
 	  parent_contour->next = cntr;
+//          printf ("Put Contour adding a hole directly to its parent\n");
           if (owner != parent)
             {
               if (owner != NULL) {
@@ -1150,6 +1308,7 @@ PutContour (jmp_buf * e, PLINE * cntr, POLYAREA ** contours, PLINE ** holes,
 	{
 	  cntr->next = *holes;
 	  *holes = cntr;	/* let cntr be 1st hole in list */
+//          printf ("Put Contour adding a hole\n");
           /* We don't insert the holes into an r-tree,
            * they just form a linked list */
           if (owner != NULL) {
@@ -1182,7 +1341,7 @@ InsertHoles (jmp_buf * e, POLYAREA * dest, PLINE ** src)
   if (*src == NULL)
     return;			/* empty hole list */
   if (dest == NULL) {
-    printf ("dest is null un InsertHoles\n");
+    printf ("dest is null in InsertHoles\n");
     error (err_bad_parm);	/* empty contour list */
   }
 
@@ -1509,7 +1668,7 @@ Collect1 (jmp_buf * e, VNODE *cur, DIRECTION dir, POLYAREA **contours, PLINE **
 	    DEBUGP ("adding contour with %d verticies and direction %c\n",
 		    p->Count, p->Flags.orient ? 'F' : 'B');
 #endif
-            printf ("1: ");
+//            printf ("1: ");
 	    PutContour (e, p, contours, holes, NULL, NULL, NULL);
 	  }
 	else
@@ -1548,8 +1707,8 @@ cntr_Collect (jmp_buf * e, PLINE ** A, POLYAREA ** contours, PLINE ** holes,
 {
   PLINE *tmprev;
 
-  printf ("cntr_Collect %p, %p, %p, %i, %p, %p, %p\n",
-          A, contours, holes, action, owner, parent, parent_contour);
+//  printf ("cntr_Collect %p, %p, %p, %i, %p, %p, %p\n",
+//          A, contours, holes, action, owner, parent, parent_contour);
 
   if ((*A)->Flags.status == ISECTED)
     {
@@ -1571,6 +1730,7 @@ cntr_Collect (jmp_buf * e, PLINE ** A, POLYAREA ** contours, PLINE ** holes,
     }
   else
     {
+      printf ("Got non ISECTED contour in cntr_Collect!\n");
       switch (action)
 	{
 	case PBO_ISECT:
@@ -1580,7 +1740,7 @@ cntr_Collect (jmp_buf * e, PLINE ** A, POLYAREA ** contours, PLINE ** holes,
 	      /* disappear this contour (rtree entry remove int PutContour) */
 	      *A = tmprev->next;
 	      tmprev->next = NULL;
-              printf ("2: ");
+//              printf ("2: ");
 	      PutContour (e, tmprev, contours, holes, owner, NULL, NULL);
 	      return TRUE;
 	    }
@@ -1593,11 +1753,12 @@ cntr_Collect (jmp_buf * e, PLINE ** A, POLYAREA ** contours, PLINE ** holes,
 	      *A = tmprev->next;
 	      tmprev->next = NULL;
 	      poly_InvContour (tmprev);
-              printf ("3: ");
+//              printf ("3: ");
 	      PutContour (e, tmprev, contours, holes, owner, NULL, NULL);
 	      return TRUE;
 	    }
-	  break;
+          /* BUG? Should we put this contour non-inverted if it is outside B? */
+	  /* break; */ /* Fall through */
 	case PBO_UNITE:
 	case PBO_SUB:
 	  if ((*A)->Flags.status == OUTSIDE)
@@ -1606,7 +1767,7 @@ cntr_Collect (jmp_buf * e, PLINE ** A, POLYAREA ** contours, PLINE ** holes,
 	      /* disappear this contour (rtree entry remove int PutContour) */
 	      *A = tmprev->next;
 	      tmprev->next = NULL;
-              printf ("4: ");
+//              printf ("4: ");
 	      PutContour (e, tmprev, contours, holes, owner, parent, parent_contour);
 	      return TRUE;
 	    }
@@ -1616,6 +1777,7 @@ cntr_Collect (jmp_buf * e, PLINE ** A, POLYAREA ** contours, PLINE ** holes,
   return FALSE;
 }				/* cntr_Collect */
 
+
 static void
 M_B_AREA_Collect (jmp_buf * e, POLYAREA * bfst, POLYAREA ** contours,
 		  PLINE ** holes, int action)
@@ -1644,7 +1806,7 @@ M_B_AREA_Collect (jmp_buf * e, POLYAREA * bfst, POLYAREA ** contours,
 		next = cur;
 		tmp->next = NULL;
 		tmp->Flags.status = UNKNWN;
-                printf ("5: ");
+//                printf ("5: ");
 		PutContour (e, tmp, contours, holes, NULL, NULL, NULL); /* b */
 		break;
 	      case PBO_UNITE:
@@ -1661,7 +1823,7 @@ M_B_AREA_Collect (jmp_buf * e, POLYAREA * bfst, POLYAREA ** contours,
 		next = cur;
 		tmp->next = NULL;
 		tmp->Flags.status = UNKNWN;
-                printf ("6: ");
+//                printf ("6: ");
 		PutContour (e, tmp, contours, holes, NULL, NULL, NULL); /* b */
 		break;
 	      case PBO_ISECT:
@@ -1674,6 +1836,211 @@ M_B_AREA_Collect (jmp_buf * e, POLYAREA * bfst, POLYAREA ** contours,
 }
 
 
+static inline int
+contour_is_first (POLYAREA *a, PLINE *cur)
+{
+  return (a->contours == cur);
+}
+
+
+static inline int
+contour_is_last (PLINE *cur)
+{
+  return (cur->next == NULL);
+}
+
+
+static inline void
+remove_polyarea (POLYAREA **list, POLYAREA *piece)
+{
+  /* If this item was the start of the list, advance that pointer */
+  if (*list == piece)
+    *list = (*list)->f;
+
+  /* But reset it to NULL if it wraps around and hits us again */
+  if (*list == piece)
+    *list = NULL;
+
+  piece->b->f = piece->f;
+  piece->f->b = piece->b;
+  piece->f = piece->b = piece;
+}
+
+
+static inline void
+remove_contour (POLYAREA *piece, PLINE *prev_contour, PLINE *contour,
+                int remove_rtree_entry)
+{
+  if (piece->contours == contour)
+    piece->contours = contour->next;
+
+  if (prev_contour != NULL)
+    prev_contour->next = contour->next;
+
+  contour->next = NULL;
+
+  if (remove_rtree_entry)
+    r_delete_entry (piece->contour_tree, (BoxType *)contour);
+}
+
+
+static void
+M_POLYAREA_update_primary (jmp_buf * e, POLYAREA ** pieces,
+                           PLINE ** holes, PLINE ** isected, int action)
+{
+  POLYAREA *a = *pieces;
+  POLYAREA *anext;
+  PLINE *curc, *next, *prev;
+  int inv_inside = 0;
+  int del_inside = 0;
+  int del_outside = 0;
+  int finished;
+
+//  printf ("M_POLYAREA_update_primary %p, %p, %i\n", pieces, holes, action);
+
+  if (a == NULL) {
+    printf ("M_POLYAREA_update_primary: No polygon pieces to play with\n");
+    return;
+  }
+
+  switch (action) {
+    case PBO_ISECT:
+//      printf ("  PBO_ISECT: Delete any contours OUTSIDE b\n");
+      del_outside = 1;
+      break;
+    case PBO_UNITE:
+//      printf ("  PBO_UNITE: Delete any contours INSIDE B (B's contour replaces it)\n");
+      del_inside = 1;
+      break;
+    case PBO_SUB:
+//      printf ("  PBO_SUB: Delete any contours INSIDE B (B's contour deletes it)\n");
+      del_inside = 1;
+      break;
+    case PBO_XOR: /* NOT IMPLEMENTED OR USED */
+//      printf ("  PBO_XOR: Invert any which are INSIDE B  *** NOT IMPLEMENTED ***\n");
+      inv_inside = 1;
+      break;
+  }
+
+  /* now the non-intersect parts are collected in temp/holes */
+  do {
+    int hole_contour = 0;
+
+    anext = a->f;
+    finished = (anext == *pieces);
+
+//    printf ("Inspecting a piece of polygon\n");
+
+    prev = NULL;
+    for (curc = a->contours; curc != NULL; curc = next) {
+      int is_first = contour_is_first (a, curc);
+      int is_last = contour_is_last (curc);
+
+      int del_contour = 0;
+      int inv_contour = 0;
+      int isect_contour = 0;
+
+      next = curc->next;
+
+      switch (curc->Flags.status) {
+        case ISECTED:
+          isect_contour = 1;
+//          printf ("Found intersected contour\n");
+          break;
+        case INSIDE:
+          if (del_inside) del_contour = 1;
+          if (inv_inside) inv_contour = 1;
+          break;
+        case OUTSIDE:
+          if (del_outside) del_contour = 1;
+          break;
+      }
+
+      /* Reset the intersection flags, since we keep these pieces */
+      if (curc->Flags.status != ISECTED)
+        curc->Flags.status = UNKNWN;
+
+      if (del_contour || isect_contour || hole_contour) {
+
+        remove_contour (a, prev, curc, !(is_first && is_last));
+
+        if (del_contour) {
+          /* Delete the contour */
+          poly_DelContour (&curc); /* NB: Sets curc to NULL */
+//          printf ("Deleting contour we don't want in the result\n");
+        } else if (isect_contour) {
+          /* Link into the list of intersected contours */
+          curc->next = *isected;
+          *isected = curc;
+//          printf ("Separating intersected contour.\n");
+        } else if (hole_contour) {
+          /* Link into the list of holes */
+          curc->next = *holes;
+          *holes = curc;
+          if (curc->Flags.orient == PLF_DIR && !is_first)
+            printf ("A:Hmm, got PLF_DIR orientation for a non-first contour\n");
+
+//          printf ("Separating a hole (belonging to a moved contour)\n");
+        } else {
+          assert (0);
+        }
+
+        if (is_first && is_last) {
+//          printf ("M_POLYAREA_update_primary: Deleted / removed the whole polygon piece\n");
+          remove_polyarea (pieces, a);
+          poly_Free (&a); /* NB: Sets a to NULL */
+        }
+
+      } else {
+        /* Note the item we just didn't delete as the next
+           candidate for having its "next" pointer adjusted.
+           Saves walking the contour list when we delete one. */
+        prev = curc;
+
+        if (curc->Flags.orient == PLF_DIR && !is_first)
+          printf ("B:Hmm, got PLF_DIR orientation for a non-first contour\n");
+
+        if (curc->Flags.orient != PLF_DIR && is_first)
+          printf ("B:Hmm, got first contour without PLF_DIR orientation\n");
+
+      }
+
+      /* If we move or delete an outer contour, we need to move any holes
+         we wish to keep within that contour to the holes list. */
+      if (is_first && (del_contour || isect_contour))
+        hole_contour = 1;
+    }
+
+    /* If we deleted all the pieces of the polyarea, *pieces is NULL and
+       we don't want to continue */
+    if (*pieces == NULL) {
+//      printf ("M_POLYAREA_update_primary: Deleted / removed _all_"
+//              "of the existing polygon pieces\n");
+      finished = TRUE;
+    }
+
+  } while ((a = anext), !finished);
+}
+
+
+static void
+M_POLYAREA_Collect_separated (jmp_buf * e, PLINE * afst, POLYAREA ** contours,
+                              PLINE ** holes, int action, BOOLp maybe)
+{
+  PLINE **cur, **next;
+
+//  printf ("M_POLYAREA_Collect_separated %p, %p, %p, %i, %i\n", afst, contours, holes, action, maybe);
+
+  assert (a != NULL);
+
+  for (cur = &afst; *cur != NULL; cur = next) {
+    next = &((*cur)->next);
+    /* if we disappear a contour, don't advance twice */
+    if (cntr_Collect (e, cur, contours, holes, action, NULL, NULL, NULL))
+      next = cur;
+  }
+}
+
 static void
 M_POLYAREA_Collect (jmp_buf * e, POLYAREA * afst, POLYAREA ** contours,
 		    PLINE ** holes, int action, BOOLp maybe)
@@ -1682,8 +2049,7 @@ M_POLYAREA_Collect (jmp_buf * e, POLYAREA * afst, POLYAREA ** contours,
   POLYAREA *parent = NULL; /* Quiet GCC warning */
   PLINE **cur, **next, *parent_contour;
 
-  printf ("M_POLYAREA_Collect %p, %p, %p, %i, %i\n",
-          afst, contours, holes, action, maybe);
+//  printf ("M_POLYAREA_Collect %p, %p, %p, %i, %i\n", afst, contours, holes, action, maybe);
 
   assert (a != NULL);
   while ((a = a->f) != afst);
@@ -1703,7 +2069,7 @@ M_POLYAREA_Collect (jmp_buf * e, POLYAREA * afst, POLYAREA ** contours,
         {
           next = &((*cur)->next);
           /* if we disappear a contour, don't advance twice */
-          printf ("1: ");
+//          printf ("1: ");
           if (cntr_Collect (e, cur, contours, holes, action, a, NULL, NULL))
             {
               parent = *contours;
@@ -1719,7 +2085,7 @@ M_POLYAREA_Collect (jmp_buf * e, POLYAREA * afst, POLYAREA ** contours,
           /* if we disappear a contour, don't advance twice */
           if (*cur == parent_contour)
             printf ("WTF??\n");
-          printf ("2: ");
+//          printf ("2: ");
           if (cntr_Collect (e, cur, contours, holes, action, a, parent,
                             (*cur == parent_contour) ? NULL : parent_contour))
             next = cur;
@@ -1813,6 +2179,7 @@ int
 poly_Boolean_free (POLYAREA * ai, POLYAREA * bi, POLYAREA ** res, int action)
 {
   POLYAREA *a = ai, *b = bi;
+  PLINE *a_isected = NULL;
   PLINE *p, *holes = NULL;
   jmp_buf e;
   int code;
@@ -1844,6 +2211,11 @@ poly_Boolean_free (POLYAREA * ai, POLYAREA * bi, POLYAREA ** res, int action)
 	}
     }
 
+  if (a->contours == NULL) {
+    fprintf (stderr, "A has no contours bye!\n");
+    return -1;
+  }
+
   if ((code = setjmp (e)) == 0)
     {
 #ifdef DEBUG
@@ -1851,16 +2223,42 @@ poly_Boolean_free (POLYAREA * ai, POLYAREA * bi, POLYAREA ** res, int action)
       assert (poly_Valid (b));
 #endif
 
+      /* intersect needs to make a list of the contours in a and b which are intersected */
       M_POLYAREA_intersect (&e, a, b, TRUE);
 
+      /* We could speed things up a lot here if we only processed the relevant contours */
       M_POLYAREA_label (a, b, FALSE);
       M_POLYAREA_label (b, a, FALSE);
+#if 0
+      M_POLYAREA_label_separated (a_isected, b, FALSE);
+      M_POLYAREA_label_isected (b, a_isected, FALSE);
+#endif
+
+/* New faster method */
+#if 1
+      *res = a;
+      M_POLYAREA_update_primary (&e, res, &holes, &a_isected, action);
+      M_POLYAREA_Collect_separated (&e, a_isected, res, &holes, action, FALSE);
+#endif
 
-      printf ("1:");
+/* First attempt at go-faster stripes */
+#if 0
+      /* And speed things up _A LOT_ here by only processing the relevant
+         contours, specifically keeping the source "a" as a starting point
+         for the output polygon */
+      M_POLYAREA_Collect_separated (&e, a_isected, res, &holes, action, FALSE);
+      M_POLYAREA_Collect (&e, a, res, &holes, action, FALSE);
+      poly_Free (&a);
+#endif
+
+/* Old slow way */
+#if 0
       M_POLYAREA_Collect (&e, a, res, &holes, action, b->f == b
 			  && !b->contours->next
 			  && b->contours->Flags.status != ISECTED);
       poly_Free (&a);
+#endif
+
       M_B_AREA_Collect (&e, b, res, &holes, action);
       poly_Free (&b);
 
@@ -1933,7 +2331,7 @@ poly_AndSubtract_free (POLYAREA * ai, POLYAREA * bi,
       M_POLYAREA_label (a, b, FALSE);
       M_POLYAREA_label (b, a, FALSE);
 
-      printf ("3:");
+//      printf ("3:");
       M_POLYAREA_Collect (&e, a, aandb, &holes, PBO_ISECT, FALSE);
       InsertHoles (&e, *aandb, &holes);
       assert (poly_Valid (*aandb));
@@ -1946,7 +2344,7 @@ poly_AndSubtract_free (POLYAREA * ai, POLYAREA * bi,
       holes = NULL;
       clear_marks (a);
       clear_marks (b);
-      printf ("4:");
+//      printf ("4:");
       M_POLYAREA_Collect (&e, a, aminusb, &holes, PBO_SUB, FALSE);
       InsertHoles (&e, *aminusb, &holes);
       poly_Free (&a);

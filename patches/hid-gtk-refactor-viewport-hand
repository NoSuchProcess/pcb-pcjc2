Bottom: a8189389d6640d9f85a227b1e294293f87e0e55c
Top:    ad29d108175fbd684c8c9c02b0fa219f6a58cd38
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-07-24 13:48:26 +0100

hid/gtk: Refactor viewport handling


---

diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index 8394d20..78762c0 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -33,6 +33,7 @@ static int cur_mask = -1;
 static int mask_seq = 0;
 
 typedef struct view_data {
+  double coords_per_px;
   bool flip_x;
   bool flip_y;
 } view_data;
@@ -276,10 +277,10 @@ ghid_draw_bg_image (void)
   if (!ghidgui->bg_pixbuf)
     return;
 
-  w = PCB->MaxWidth / gport->zoom;
-  h = PCB->MaxHeight / gport->zoom;
-  x = gport->view_x0 / gport->zoom;
-  y = gport->view_y0 / gport->zoom;
+  w = PCB->MaxWidth  / priv->view.coords_per_px;
+  h = PCB->MaxHeight / priv->view.coords_per_px;
+  x = gport->view_x0 / priv->view.coords_per_px;
+  y = gport->view_y0 / priv->view.coords_per_px;
 
   if (w_scaled != w || h_scaled != h)
     {
@@ -572,7 +573,7 @@ ghid_draw_line (hidGC gc, int x1, int y1, int x2, int y2)
   dy2 = Vy ((double) y2);
 
   if (!ClipLine (0, 0, gport->width, gport->height,
-		 &dx1, &dy1, &dx2, &dy2, gc->width / gport->zoom))
+		 &dx1, &dy1, &dx2, &dy2, gc->width / priv->view.coords_per_px))
     return;
 
   USE_GC (gc);
@@ -587,8 +588,8 @@ ghid_draw_arc (hidGC gc, int cx, int cy,
   gint w, h, radius;
   render_priv *priv = gport->render_priv;
 
-  w = gport->width * gport->zoom;
-  h = gport->height * gport->zoom;
+  w = gport->width  * priv->view.coords_per_px;
+  h = gport->height * priv->view.coords_per_px;
   radius = (xradius > yradius) ? xradius : yradius;
   if (SIDE_X (cx) < gport->view_x0 - radius
       || SIDE_X (cx) > gport->view_x0 + w + radius
@@ -625,8 +626,8 @@ ghid_draw_rect (hidGC gc, int x1, int y1, int x2, int y2)
   render_priv *priv = gport->render_priv;
 
   lw = gc->width;
-  w = gport->width * gport->zoom;
-  h = gport->height * gport->zoom;
+  w = gport->width  * priv->view.coords_per_px;
+  h = gport->height * priv->view.coords_per_px;
 
   if ((SIDE_X (x1) < gport->view_x0 - lw
        && SIDE_X (x2) < gport->view_x0 - lw)
@@ -668,8 +669,8 @@ ghid_fill_circle (hidGC gc, int cx, int cy, int radius)
   gint w, h, vr;
   render_priv *priv = gport->render_priv;
 
-  w = gport->width * gport->zoom;
-  h = gport->height * gport->zoom;
+  w = gport->width  * priv->view.coords_per_px;
+  h = gport->height * priv->view.coords_per_px;
   if (SIDE_X (cx) < gport->view_x0 - radius
       || SIDE_X (cx) > gport->view_x0 + w + radius
       || SIDE_Y (cy) < gport->view_y0 - radius
@@ -711,8 +712,8 @@ ghid_fill_rect (hidGC gc, int x1, int y1, int x2, int y2)
   render_priv *priv = gport->render_priv;
 
   lw = gc->width;
-  w = gport->width * gport->zoom;
-  h = gport->height * gport->zoom;
+  w = gport->width  * priv->view.coords_per_px;
+  h = gport->height * priv->view.coords_per_px;
 
   if ((SIDE_X (x1) < gport->view_x0 - lw
        && SIDE_X (x2) < gport->view_x0 - lw)
@@ -1200,7 +1201,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   double xz, yz;
   render_priv *priv = gport->render_priv;
 
-  save_zoom = gport->zoom;
+  save_zoom = priv->view.coords_per_px;
   save_width = gport->width;
   save_height = gport->height;
   save_left = gport->view_x0;
@@ -1216,15 +1217,15 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   xz = (double) pinout->x_max / da_w;
   yz = (double) pinout->y_max / da_h;
   if (xz > yz)
-    gport->zoom = xz;
+    priv->view.coords_per_px = xz;
   else
-    gport->zoom = yz;
+    priv->view.coords_per_px = yz;
 
   gport->drawable = widget->window;
   gport->width = da_w;
   gport->height = da_h;
-  gport->view_width = da_w * gport->zoom;
-  gport->view_height = da_h * gport->zoom;
+  gport->view_width = da_w * priv->view.coords_per_px;
+  gport->view_height = da_h * priv->view.coords_per_px;
   gport->view_x0 = (pinout->x_max - gport->view_width) / 2;
   gport->view_y0 = (pinout->y_max - gport->view_height) / 2;
 
@@ -1235,7 +1236,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   hid_expose_callback (&ghid_hid, NULL, &pinout->element);
 
   gport->drawable = save_drawable;
-  gport->zoom = save_zoom;
+  priv->view.coords_per_px = save_zoom;
   gport->width = save_width;
   gport->height = save_height;
   gport->view_x0 = save_left;
@@ -1252,15 +1253,15 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   xz = (double) pinout->x_max / da_w;
   yz = (double) pinout->y_max / da_h;
   if (xz > yz)
-    gport->zoom = xz;
+    priv->view.coords_per_px = xz;
   else
-    gport->zoom = yz;
+    priv->view.coords_per_px = yz;
 
   gport->drawable = widget->window;
   gport->width = da_w;
   gport->height = da_h;
-  gport->view_width = da_w * gport->zoom;
-  gport->view_height = da_h * gport->zoom;
+  gport->view_width = da_w * priv->view.coords_per_px;
+  gport->view_height = da_h * priv->view.coords_per_px;
   gport->view_x0 = (pinout->x_max - gport->view_width) / 2;
   gport->view_y0 = (pinout->y_max - gport->view_height) / 2;
 
@@ -1271,7 +1272,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   hid_expose_callback (&ghid_hid, NULL, &pinout->element);
 
   gport->drawable = save_drawable;
-  gport->zoom = save_zoom;
+  priv->view.coords_per_px = save_zoom;
   gport->width = save_width;
   gport->height = save_height;
   gport->view_x0 = save_left;
@@ -1295,7 +1296,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   render_priv *priv = gport->render_priv;
 
   save_drawable = gport->drawable;
-  save_zoom = gport->zoom;
+  save_zoom = priv->view.coords_per_px;
   save_width = gport->width;
   save_height = gport->height;
   save_left = gport->view_x0;
@@ -1309,11 +1310,11 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
    */
 
   gport->drawable = pixmap;
-  gport->zoom = zoom;
+  priv->view.coords_per_px = zoom;
   gport->width = width;
   gport->height = height;
-  gport->view_width = width * gport->zoom;
-  gport->view_height = height * gport->zoom;
+  gport->view_width =  width  * priv->view.coords_per_px;
+  gport->view_height = height * priv->view.coords_per_px;
   gport->view_x0 = priv->view.flip_x ? PCB->MaxWidth - cx : cx;
   gport->view_x0 -= gport->view_height / 2;
   gport->view_y0 = priv->view.flip_y ? PCB->MaxHeight - cy : cy;
@@ -1330,7 +1331,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   hid_expose_callback (&ghid_hid, &region, NULL);
 
   gport->drawable = save_drawable;
-  gport->zoom = save_zoom;
+  priv->view.coords_per_px = save_zoom;
   gport->width = save_width;
   gport->height = save_height;
   gport->view_x0 = save_left;
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 814a7ea..9a1027d 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -38,14 +38,21 @@ static hidGC current_gc = NULL;
 */
 #define USE_GC(gc) if (!use_gc(gc)) return
 
-#define SIDE_X(x)   ((priv->view.flip_x ? PCB->MaxWidth  - (x) : (x)))
-#define SIDE_Y(y)   ((priv->view.flip_y ? PCB->MaxHeight - (y) : (y)))
+#define SIDE_X(x)         ((priv->view.flip_x ? PCB->MaxWidth  - (x) : (x)))
+#define SIDE_Y(y)         ((priv->view.flip_y ? PCB->MaxHeight - (y) : (y)))
+
+#define EVENT_TO_PCB_X(x) SIDE_X((int)((x) * priv->view.coords_per_px + gport->view_x0))
+#define EVENT_TO_PCB_Y(y) SIDE_Y((int)((y) * priv->view.voords_per_px + gport->view_y0))
 
 static int cur_mask = -1;
 
 typedef struct view_data {
+  double coords_per_px;
+  Coord center_x;
+  Coord center_y;
   bool flip_x;
   bool flip_y;
+  /* TODO: Rotation matrix ? */
 } view_data;
 
 typedef struct render_priv {
@@ -87,16 +94,17 @@ static void draw_lead_user (render_priv *priv);
 static inline int
 Vz (int z)
 {
-  return z / gport->zoom + 0.5;
+  render_priv *priv = gport->render_priv;
+  return z / priv->view.coords_per_px + 0.5;
 }
 
 static inline int
 Px (int x)
 {
   render_priv *priv = gport->render_priv;
-  int rv = x * gport->zoom + gport->view_x0;
+  int rv = x * priv->view.coords_per_px + gport->view_x0;
   if (priv->view.flip_x)
-    rv = PCB->MaxWidth - (x * gport->zoom + gport->view_x0);
+    rv = PCB->MaxWidth - (x * priv->view.coords_per_px + gport->view_x0);
   return  rv;
 }
 
@@ -104,9 +112,9 @@ static inline int
 Py (int y)
 {
   render_priv *priv = gport->render_priv;
-  int rv = y * gport->zoom + gport->view_y0;
+  int rv = y * priv->view.coords_per_px + gport->view_y0;
   if (priv->view.flip_y)
-    rv = PCB->MaxHeight - (y * gport->zoom + gport->view_y0);
+    rv = PCB->MaxHeight - (y * priv->view.coords_per_px + gport->view_y0);
   return  rv;
 }
 
@@ -571,19 +579,21 @@ use_gc (hidGC gc)
 void
 ghid_draw_line (hidGC gc, int x1, int y1, int x2, int y2)
 {
+  render_priv *priv = gport->render_priv;
   USE_GC (gc);
 
-  hidgl_draw_line (gc->cap, gc->width, x1, y1, x2, y2, gport->zoom);
+  hidgl_draw_line (gc->cap, gc->width, x1, y1, x2, y2, priv->view.coords_per_px);
 }
 
 void
 ghid_draw_arc (hidGC gc, int cx, int cy, int xradius, int yradius,
                          int start_angle, int delta_angle)
 {
+  render_priv *priv = gport->render_priv;
   USE_GC (gc);
 
   hidgl_draw_arc (gc->width, cx, cy, xradius, yradius,
-                  start_angle, delta_angle, gport->zoom);
+                  start_angle, delta_angle, priv->view.coords_per_px);
 }
 
 void
@@ -598,9 +608,10 @@ ghid_draw_rect (hidGC gc, int x1, int y1, int x2, int y2)
 void
 ghid_fill_circle (hidGC gc, int cx, int cy, int radius)
 {
+  render_priv *priv = gport->render_priv;
   USE_GC (gc);
 
-  hidgl_fill_circle (cx, cy, radius, gport->zoom);
+  hidgl_fill_circle (cx, cy, radius, priv->view.coords_per_px);
 }
 
 
@@ -615,9 +626,10 @@ ghid_fill_polygon (hidGC gc, int n_coords, int *x, int *y)
 void
 ghid_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
 {
+  render_priv *priv = gport->render_priv;
   USE_GC (gc);
 
-  hidgl_fill_pcb_polygon (poly, clip_box, gport->zoom);
+  hidgl_fill_pcb_polygon (poly, clip_box, priv->view.coords_per_px);
 }
 
 void
@@ -781,8 +793,8 @@ ghid_show_crosshair (gboolean paint_new_location)
   render_priv *priv = gport->render_priv;
   gint x, y, z;
   gboolean draw_markers;
-  int vcw = VCW * gport->zoom;
-  int vcd = VCD * gport->zoom;
+  int vcw = VCW * priv->view.coords_per_px;
+  int vcd = VCD * priv->view.coords_per_px;
   static int done_once = 0;
   static GdkColor cross_color;
 
@@ -961,13 +973,13 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glLoadIdentity ();
   glTranslatef (0.0f, 0.0f, -Z_NEAR);
 
-  glScalef ((priv->view.flip_x ? -1. : 1.) / port->zoom,
-            (priv->view.flip_y ? -1. : 1.) / port->zoom,
-            ((priv->view.flip_x == priv->view.flip_y) ? 1. : -1.) / port->zoom);
+  glScalef ((priv->view.flip_x ? -1. : 1.) / priv->view.coords_per_px,
+            (priv->view.flip_y ? -1. : 1.) / priv->view.coords_per_px,
+            ((priv->view.flip_x == priv->view.flip_y) ? 1. : -1.) / priv->view.coords_per_px);
   glTranslatef (priv->view.flip_x ?  port->view_x0 - PCB->MaxWidth  :
-                               -port->view_x0,
+                                    -port->view_x0,
                 priv->view.flip_y ?  port->view_y0 - PCB->MaxHeight :
-                               -port->view_y0, 0);
+                                    -port->view_y0, 0);
 
   glEnable (GL_STENCIL_TEST);
   glClearColor (port->offlimits_color.red / 65535.,
@@ -1059,7 +1071,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   int save_view_width, save_view_height;
   double xz, yz;
 
-  save_zoom = gport->zoom;
+  save_zoom = priv->view.coords_per_px;
   save_width = gport->width;
   save_height = gport->height;
   save_left = gport->view_x0;
@@ -1073,14 +1085,14 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   xz = (double) pinout->x_max / da_w;
   yz = (double) pinout->y_max / da_h;
   if (xz > yz)
-    gport->zoom = xz;
+    priv->view.coords_per_px = xz;
   else
-    gport->zoom = yz;
+    priv->view.coords_per_px = yz;
 
   gport->width = da_w;
   gport->height = da_h;
-  gport->view_width = da_w * gport->zoom;
-  gport->view_height = da_h * gport->zoom;
+  gport->view_width = da_w  * priv->view.coords_per_px;
+  gport->view_height = da_h * priv->view.coords_per_px;
   gport->view_x0 = (pinout->x_max - gport->view_width) / 2;
   gport->view_y0 = (pinout->y_max - gport->view_height) / 2;
 
@@ -1121,12 +1133,12 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
   glPushMatrix ();
-  glScalef ((priv->view.flip_x ? -1. : 1.) / gport->zoom,
-            (priv->view.flip_y ? -1. : 1.) / gport->zoom, 1);
+  glScalef ((priv->view.flip_x ? -1. : 1.) / priv->view.coords_per_px,
+            (priv->view.flip_y ? -1. : 1.) / priv->view.coords_per_px, 1);
   glTranslatef (priv->view.flip_x ?  gport->view_x0 - PCB->MaxWidth  :
-                               -gport->view_x0,
+                                    -gport->view_x0,
                 priv->view.flip_y ?  gport->view_y0 - PCB->MaxHeight :
-                               -gport->view_y0, 0);
+                                    -gport->view_y0, 0);
   hid_expose_callback (&ghid_hid, NULL, &pinout->element);
   hidgl_flush_triangles (&buffer);
   glPopMatrix ();
@@ -1140,7 +1152,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   gport->render_priv->in_context = false;
   gdk_gl_drawable_gl_end (pGlDrawable);
 
-  gport->zoom = save_zoom;
+  priv->view.coords_per_px = save_zoom;
   gport->width = save_width;
   gport->height = save_height;
   gport->view_x0 = save_left;
@@ -1167,7 +1179,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   int save_view_width, save_view_height;
   BoxType region;
 
-  save_zoom = gport->zoom;
+  save_zoom = priv->view.coords_per_px;
   save_width = gport->width;
   save_height = gport->height;
   save_left = gport->view_x0;
@@ -1189,11 +1201,11 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
 
   /* Setup zoom factor for drawing routines */
 
-  gport->zoom = zoom;
+  priv->view.coords_per_px = zoom;
   gport->width = width;
   gport->height = height;
-  gport->view_width = width * gport->zoom;
-  gport->view_height = height * gport->zoom;
+  gport->view_width = width   * priv->view.coords_per_px;
+  gport->view_height = height * priv->view.coords_per_px;
   gport->view_x0 = priv->view.flip_x ? PCB->MaxWidth - cx : cx;
   gport->view_x0 -= gport->view_height / 2;
   gport->view_y0 = priv->view.flip_y ? PCB->MaxHeight - cy : cy;
@@ -1233,10 +1245,10 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
   glPushMatrix ();
-  glScalef ((priv->view.flip_x ? -1. : 1.) / gport->zoom,
-            (priv->view.flip_y ? -1. : 1.) / gport->zoom, 1);
+  glScalef ((priv->view.flip_x ? -1. : 1.) / priv->view.coords_per_px,
+            (priv->view.flip_y ? -1. : 1.) / priv->view.coords_per_px, 1);
   glTranslatef (priv->view.flip_x ?  gport->view_x0 - PCB->MaxWidth  :
-                               -gport->view_x0,
+                                    -gport->view_x0,
                 priv->view.flip_y ?  gport->view_y0 - PCB->MaxHeight :
                                -gport->view_y0, 0);
   region.X1 = MIN(Px(0), Px(gport->width + 1));
@@ -1258,7 +1270,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   g_object_unref (glconfig);
   g_object_unref (glcontext);
 
-  gport->zoom = save_zoom;
+  priv->view.coords_per_px = save_zoom;
   gport->width = save_width;
   gport->height = save_height;
   gport->view_x0 = save_left;
@@ -1294,13 +1306,13 @@ ghid_request_debug_draw (void)
   glDisable (GL_STENCIL_TEST);
 
   glPushMatrix ();
-  glScalef ((priv->view.flip_x ? -1. : 1.) / port->zoom,
-            (priv->view.flip_y ? -1. : 1.) / port->zoom,
+  glScalef ((priv->view.flip_x ? -1. : 1.) / priv->view.coords_per_px,
+            (priv->view.flip_y ? -1. : 1.) / priv->view.coords_per_px,
             (priv->view.flip_x == priv->view.flip_y) ? 1. : -1.);
   glTranslatef (priv->view.flip_x ?  port->view_x0 - PCB->MaxWidth  :
-                               -port->view_x0,
+                                    -port->view_x0,
                 priv->view.flip_y ?  port->view_y0 - PCB->MaxHeight :
-                               -port->view_y0, 0);
+                                    -port->view_y0, 0);
 
   return &ghid_hid;
 }
@@ -1350,14 +1362,9 @@ ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y)
   return true;
 }
 
-void
-ghid_pan_view_abs (Coord pcb_x, Coord pcb_y, int widget_x, int widget_y)
+static void
+finish_pan (void)
 {
-  render_priv *priv = gport->render_priv;
-
-  gport->view_x0 = MAX (0, SIDE_X (pcb_x) - widget_x * gport->zoom);
-  gport->view_y0 = MAX (0, SIDE_Y (pcb_y) - widget_y * gport->zoom);
-
   /* don't pan so far to the right that we see way past the right edge of the
    * board, or so far down that we see way past the bottom edge of the board.
    */
@@ -1384,8 +1391,30 @@ ghid_pan_view_abs (Coord pcb_x, Coord pcb_y, int widget_x, int widget_y)
   ghid_port_ranges_changed();
 }
 
+void
+ghid_pan_view_abs (Coord pcb_x, Coord pcb_y, int widget_x, int widget_y)
+{
+  render_priv *priv = gport->render_priv;
+
+  gport->view_x0 = MAX (0, SIDE_X (pcb_x) - widget_x * priv->view.coords_per_px);
+  gport->view_y0 = MAX (0, SIDE_Y (pcb_y) - widget_y * priv->view.coords_per_px);
+
+  finish_pan ();
+}
+
+void
+ghid_pan_view_rel_to_visible (double fraction_x, double fraction_y)
+{
+  render_priv *priv = gport->render_priv;
+
+  gport->view_x0 = MAX (0, SIDE_X (pcb_x) - widget_x * priv->view.coords_per_px);
+  gport->view_y0 = MAX (0, SIDE_Y (pcb_y) - widget_y * priv->view.coords_per_px);
+
+  finish_pan ();
+}
+
 
-/* gport->zoom:
+/* priv->view.coords_per_px:
  * zoom value is PCB units per screen pixel.  Larger numbers mean zooming
  * out - the largest value means you are looking at the whole board.
  *
@@ -1408,13 +1437,13 @@ ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
                   PCB->MaxHeight / gport->height);
   new_zoom = MIN (MAX (min_zoom, new_zoom), max_zoom);
 
-  if (gport->zoom == new_zoom)
+  if (priv->view.coords_per_px == new_zoom)
     return;
 
   xtmp = (SIDE_X (center_x) - gport->view_x0) / (double)gport->view_width;
   ytmp = (SIDE_Y (center_y) - gport->view_y0) / (double)gport->view_height;
 
-  gport->zoom = new_zoom;
+  priv->view.coords_per_px = new_zoom;
   pixel_slop = new_zoom;
   ghid_port_ranges_scale (FALSE);
 
@@ -1433,7 +1462,7 @@ ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
 void
 ghid_zoom_view_rel (Coord center_x, Coord center_y, double factor)
 {
-  ghid_zoom_view_abs (center_x, center_y, gport->zoom * factor);
+  ghid_zoom_view_abs (center_x, center_y, priv->view.coords_per_px * factor);
 }
 
 void
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index c106690..0040660 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -1042,8 +1042,9 @@ PCBChanged (int argc, char **argv, int x, int y)
   if (!gport->pixmap)
     return 0;
   RouteStylesChanged (0, NULL, 0, 0);
-  ghid_port_ranges_scale (TRUE);
-  ghid_port_ranges_pan (0, 0, FALSE);
+  ghid_port_ranges_scale ();
+  ghid_port_ranges_changed ();
+  ghid_pan_view_abs (0, 0, 0, 0);
   ghid_zoom_view_fit ();
   ghid_port_ranges_changed ();
   ghid_sync_with_new_layout ();
@@ -1533,13 +1534,13 @@ CursorAction(int argc, char **argv, int x, int y)
 {
   UnitList extra_units_x = {
     { "grid",  PCB->Grid, 0 },
-    { "view",  gport->view_width, UNIT_PERCENT },
+//    { "view",  gport->view_width, UNIT_PERCENT },
     { "board", PCB->MaxWidth, UNIT_PERCENT },
     { "", 0, 0 }
   };
   UnitList extra_units_y = {
     { "grid",  PCB->Grid, 0 },
-    { "view",  gport->view_height, UNIT_PERCENT },
+//    { "view",  gport->view_height, UNIT_PERCENT },
     { "board", PCB->MaxHeight, UNIT_PERCENT },
     { "", 0, 0 }
   };
@@ -1711,8 +1712,9 @@ default is given, div=40.
 static int
 ScrollAction (int argc, char **argv, int x, int y)
 {
-  gdouble dx = 0.0, dy = 0.0;
-  int div = 40;
+  double dx = 0.;
+  double dy = 0.;
+  double fraction = 1. / 40.;
 
   if (!ghidgui)
     return 0;
@@ -1721,24 +1723,25 @@ ScrollAction (int argc, char **argv, int x, int y)
     AFAIL (scroll);
 
   if (argc == 2)
-    div = atoi(argv[1]);
+    fraction = 1. / (double) atoi(argv[1]);
 
   if (strcasecmp (argv[0], "up") == 0)
-    dy = -(ghid_port.height * gport->zoom / div);
-  else if (strcasecmp (argv[0], "down") == 0)
-    dy = ghid_port.height * gport->zoom / div;
+    dy = -fraction;
+  else if (strcasecmp (argv[0], "down")  == 0)
+    dy =  fraction;
   else if (strcasecmp (argv[0], "right") == 0)
-    dx = ghid_port.width * gport->zoom / div;
-  else if (strcasecmp (argv[0], "left") == 0)
-    dx = -(ghid_port.width * gport->zoom / div);
+    dx =  fraction;
+  else if (strcasecmp (argv[0], "left")  == 0)
+    dx = -fraction;
   else
     AFAIL (scroll);
 
-  notify_crosshair_change (false);
-  ghid_port_ranges_pan (dx, dy, TRUE);
+//  notify_crosshair_change (false);
+//  ghid_port_ranges_pan (dx, dy, TRUE);
+  ghid_pan_view_rel_to_visible (dx, dy);
   MoveCrosshairRelative (dx, dy);
-  AdjustAttachedObjects ();
-  notify_crosshair_change (true);
+//  AdjustAttachedObjects ();
+//  notify_crosshair_change (true);
 
   return 0;
 }
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index 7e3891d..55bfc4b 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -52,16 +52,18 @@
 
 #define TOOLTIP_UPDATE_DELAY 200
 
-// static gint x_pan_speed, y_pan_speed;
+static double x_pan_speed, y_pan_speed;
 void
 ghid_port_ranges_changed (void)
 {
+#if 0
   GtkAdjustment *h_adj, *v_adj;
 
   h_adj = gtk_range_get_adjustment (GTK_RANGE (ghidgui->h_range));
   v_adj = gtk_range_get_adjustment (GTK_RANGE (ghidgui->v_range));
   gport->view_x0 = h_adj->value;
   gport->view_y0 = v_adj->value;
+#endif
 
   ghid_invalidate_all ();
 }
@@ -114,37 +116,31 @@ ghid_port_ranges_pan (gdouble x, gdouble y, gboolean relative)
      |  overall PCB board size.
    */
 void
-ghid_port_ranges_scale (gboolean emit_changed)
+ghid_port_ranges_scale (void)
 {
+#if 0
   GtkAdjustment *adj;
 
   /* Update the scrollbars with PCB units.  So Scale the current
      |  drawing area size in pixels to PCB units and that will be
      |  the page size for the Gtk adjustment.
    */
-  gport->view_width = gport->width * gport->zoom;
-  gport->view_height = gport->height * gport->zoom;
-
-  if (gport->view_width >= PCB->MaxWidth)
-    gport->view_width = PCB->MaxWidth;
-  if (gport->view_height >= PCB->MaxHeight)
-    gport->view_height = PCB->MaxHeight;
+  gport->view_width =  MIN (gport->width  * gport->zoom, PCB->MaxWidth);
+  gport->view_height = MIN (gport->height * gport->zoom, PCB->MaxHeight);
 
   adj = gtk_range_get_adjustment (GTK_RANGE (ghidgui->h_range));
+  gtk_range_set_increments (GTK__RANGE (ghidgui->h_range)
   adj->page_size = gport->view_width;
-  adj->page_increment = adj->page_size/10.0;
-  adj->step_increment = adj->page_size/100.0;
+  adj->page_increment = adj->page_size / 10.;
+  adj->step_increment = adj->page_size / 100.;
   adj->upper = PCB->MaxWidth;
-  if (emit_changed)
-    gtk_signal_emit_by_name (GTK_OBJECT (adj), "changed");
 
   adj = gtk_range_get_adjustment (GTK_RANGE (ghidgui->v_range));
   adj->page_size = gport->view_height;
-  adj->page_increment = adj->page_size/10.0;
-  adj->step_increment = adj->page_size/100.0;
+  adj->page_increment = adj->page_size / 10.;
+  adj->step_increment = adj->page_size / 100.;
   adj->upper = PCB->MaxHeight;
-  if (emit_changed)
-    gtk_signal_emit_by_name (GTK_OBJECT (adj), "changed");
+#endif
 }
 
 
@@ -467,7 +463,7 @@ ghid_port_drawing_area_configure_event_cb (GtkWidget * widget,
       ghid_drawing_area_configure_hook (out);
     }
 
-  ghid_port_ranges_scale (FALSE);
+  ghid_port_ranges_scale ();
   ghid_invalidate_all ();
   return 0;
 }
@@ -591,24 +587,20 @@ gint
 ghid_port_window_motion_cb (GtkWidget * widget,
 			    GdkEventMotion * ev, GHidPort * out)
 {
-  gdouble dx, dy;
-  static gint x_prev = -1, y_prev = -1;
-
   gdk_event_request_motions (ev);
 
   if (out->panning)
     {
-      dx = gport->zoom * (x_prev - ev->x);
-      dy = gport->zoom * (y_prev - ev->y);
-      if (x_prev > 0)
-	ghid_port_ranges_pan (dx, dy, TRUE);
-      x_prev = ev->x;
-      y_prev = ev->y;
+      /* gport->pcb_x and gport->pcb_y will correspond to where the user
+       * grabbed the board. Move the board so that location lands where
+       * the mouse pointer now is, as indicated by the event.
+       */
+      ghid_pan_view_abs (gport->pcb_x, gport->pcb_y, ev->x, ev->y);
+
       return FALSE;
     }
-  x_prev = y_prev = -1;
-  ghid_note_event_location ((GdkEventButton *)ev);
 
+  ghid_note_event_location ((GdkEventButton *)ev);
   queue_tooltip_update (out);
 
   return FALSE;
@@ -647,27 +639,22 @@ ghid_port_window_enter_cb (GtkWidget * widget,
   return FALSE;
 }
 
-#if 0
 static gboolean
 ghid_pan_idle_cb (gpointer data)
 {
-  gdouble dx = 0, dy = 0;
-
   if (gport->has_entered)
     return FALSE;
-  dy = gport->zoom * y_pan_speed;
-  dx = gport->zoom * x_pan_speed;
-  return (ghid_port_ranges_pan (dx, dy, TRUE));
+
+  ghid_pan_view_rel_to_visible (x_pan_speed, y_pan_speed);
+
+  return TRUE;
 }
-#endif
 
 gint
 ghid_port_window_leave_cb (GtkWidget * widget, 
                            GdkEventCrossing * ev, GHidPort * out)
 {
-  // gint x0, y0, x, y, dx, dy, w, h;
-  
-  /* printf("leave mode: %d detail: %d\n", ev->mode, ev->detail); */
+//  gint x0, y0, x, y, dx, dy, w, h;
 
   /* Window leave events can also be triggered because of focus grabs. Some
    * X applications occasionally grab the focus and so trigger this function.
@@ -677,11 +664,8 @@ ghid_port_window_leave_cb (GtkWidget * widget,
    */
 
   if(ev->mode != GDK_CROSSING_NORMAL)
-    {
-      return FALSE;
-    }
+    return FALSE;
 
-#if 0
   if(out->has_entered && !ghidgui->in_popup)
     {
       /* if actively drawing, start scrolling */
@@ -691,6 +675,7 @@ ghid_port_window_leave_cb (GtkWidget * widget,
 	  /* GdkEvent coords are set to 0,0 at leave events, so must figure
 	     |  out edge the cursor left.
 	   */
+#if 0
 	  w = ghid_port.width * gport->zoom;
 	  h = ghid_port.height * gport->zoom;
 
@@ -700,16 +685,16 @@ ghid_port_window_leave_cb (GtkWidget * widget,
 	  x -= x0;
 	  y -= y0;
 
-	  if (ghid_flip_x )
-	      x = -x;
-	  if (ghid_flip_y )
-	      y = -y;
+	  if (ghid_flip_x) x = -x;
+	  if (ghid_flip_y) y = -y;
 
 	  dx = w - x;
 	  dy = h - y;
+#endif
 
 	  x_pan_speed = y_pan_speed = 2 * ghidgui->auto_pan_speed;
 
+#if 0
 	  if (x < dx)
 	    {
 	      x_pan_speed = -x_pan_speed;
@@ -734,10 +719,10 @@ ghid_port_window_leave_cb (GtkWidget * widget,
 	      else
 		x_pan_speed = 0;
 	    }
+#endif
 	  g_idle_add (ghid_pan_idle_cb, NULL);
 	}
     }
-#endif
 
   out->has_entered = FALSE;
 
diff --git a/src/hid/gtk/gui-top-window.c b/src/hid/gtk/gui-top-window.c
index b11d32c..cf47cf5 100644
--- a/src/hid/gtk/gui-top-window.c
+++ b/src/hid/gtk/gui-top-window.c
@@ -2382,8 +2382,6 @@ ghid_parse_arguments (int *argc, char ***argv)
   gtk_init (argc, argv);
 
   gport = &ghid_port;
-  gport->zoom = 300.0;
-  pixel_slop = 300;
 
   ghid_init_renderer (argc, argv, gport);
 
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index 53845db..b17dad6 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -61,12 +61,6 @@
 #define	FROM_PCB_UNITS(v)	(Settings.grid_units_mm ? COORD_TO_MM(v) : COORD_TO_MIL(v))
 #define	TO_PCB_UNITS(v)		(Settings.grid_units_mm ? MM_TO_COORD(v) : MIL_TO_COORD(v))
 
-#define	DRAW_X(x)	(gint)((SIDE_X(x) - gport->view_x0) / gport->zoom)
-#define	DRAW_Y(y)	(gint)((SIDE_Y(y) - gport->view_y0) / gport->zoom)
-
-#define	EVENT_TO_PCB_X(x)	SIDE_X((gint)((x) * gport->zoom + gport->view_x0))
-#define	EVENT_TO_PCB_Y(y)	SIDE_Y((gint)((y) * gport->zoom + gport->view_y0))
-
 /*
  * Used to intercept "special" hotkeys that gtk doesn't usually pass
  * on to the menu hotkeys.  We catch them and put them back where we
@@ -167,16 +161,8 @@ typedef struct
   gboolean has_entered;
   gboolean panning;
 
-/* zoom value is PCB units per screen pixel.  Larger numbers mean zooming
-|  out - the largest value means you are looking at the whole board.
-*/
-  gdouble zoom;			/* PCB units per screen pixel.  Larger */
-  /* numbers mean zooming out. */
-  gint view_x0,			/* Viewport in PCB coordinates */
-    view_y0, view_width, view_height;
-  Coord pcb_x, pcb_y;
-
-  gint crosshair_x, crosshair_y;
+  Coord pcb_x, pcb_y;             /* PCB coordinates of the object under the mouse pointer */
+  Coord crosshair_x, crosshair_y; /* PCB coordinates of the crosshair set by PCB's core    */
 }
 GHidPort;
 
@@ -272,8 +258,7 @@ void ghid_get_pointer (gint *, gint *);
 /* gui-output-events.c function prototypes.
 */
 void ghid_port_ranges_changed (void);
-gboolean ghid_port_ranges_pan (gdouble x, gdouble y, gboolean relative);
-void ghid_port_ranges_scale (gboolean emit_changed);
+void ghid_port_ranges_scale (void);
 void ghid_port_ranges_update_ranges (void);
 
 gboolean ghid_note_event_location (GdkEventButton * ev);
@@ -502,6 +487,7 @@ void ghid_finish_debug_draw (void);
 bool ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y);
 bool ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y);
 void ghid_pan_view_abs (Coord pcb_x, Coord pcb_y, int widget_x, int widget_y);
+void ghid_pan_view_rel_to_visible (double fraction_x, double fraction_y);
 void ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom);
 void ghid_zoom_view_rel (Coord center_x, Coord center_y, double factor);
 void ghid_zoom_view_fit (void);

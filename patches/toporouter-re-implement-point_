Bottom: ef12221b9b980010ecf33567429f0b17dee2a194
Top:    251d6c3eddbbecaffe60b46c30a70d7cc633c184
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-10-01 13:18:12 +0100

toporouter: Re-implement point_from_point_to_point() with atan2

Simplifies the code a lot


---

diff --git a/src/toporouter.c b/src/toporouter.c
index e5310b0..61d94d5 100644
--- a/src/toporouter.c
+++ b/src/toporouter.c
@@ -717,53 +717,20 @@ print_trace (void)
   free (strings);
 }
 */
+
 /* fills in x and y with coordinates of point from a towards b of distance d */
-void
-point_from_point_to_point(toporouter_vertex_t *a, toporouter_vertex_t *b, gdouble d, gdouble *x, gdouble *y)
+static void
+point_from_point_to_point (toporouter_vertex_t *a,
+                           toporouter_vertex_t *b,
+                           double d,
+                           double *x, double *y)
 {
-  gdouble dx = vx(b) - vx(a);
-  gdouble dy = vy(b) - vy(a);
-  gdouble theta = atan(fabs(dy/dx));
-
-//#ifdef DEBUG_EXPORT  
-  if(!finite(theta)) {
-//    printf("!finte(theta): a = %f,%f b = %f,%f d = %f\n", vx(a), vy(a), vx(b), vy(b), d);
-//    print_trace();
-    //TODO: this shouldn't happen, fix the hack
-    *x = vx(a);
-    *y = vy(a);
-    return;
-  }
-//#endif
-
-  g_assert(finite(theta));
-
-  *x = vx(a); *y = vy(a);
-
-  if( dx >= 0. ) {
+  double theta = atan2 (vy(b) - vy(a), vx(b) - vx(a));
 
-    if( dy >= 0. ) {
-      *x += d * cos(theta);
-      *y += d * sin(theta);
-    }else{
-      *x += d * cos(theta);
-      *y -= d * sin(theta);
-    }
-
-  }else{
-    
-    if( dy >= 0. ) {
-      *x -= d * cos(theta);
-      *y += d * sin(theta);
-    }else{
-      *x -= d * cos(theta);
-      *y -= d * sin(theta);
-    }
-
-  }
+  *x = vx(a) + d * cos (theta);
+  *y = vy(a) + d * sin (theta);
 }
 
-
 static inline gint
 coord_wind(gdouble ax, gdouble ay, gdouble bx, gdouble by, gdouble cx, gdouble cy) 
 {

Bottom: f22565275260c42d273d71cac7aafe787657b348
Top:    aa1538b9e03d018e9152e089f33da2562741c239
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2008-10-10 10:26:41 +0100

Add support for a "poured" object.

This takes half of the existing polygon functionality, and splits it
such that the user defines a poured region (similar to drawing a polygon
previously), and after clipping, this produces zero or more polygon
objects which are drawn and connectivity checked with the existing
polygon code.

Selecting a "polygon" will cause the parent "pour" to be looked up, and
all child polygons selected. Manipulations will always occur on the
"pour", with "polygons" being updated after clipping.

It remains to be seen whether "pour" will have its own file-format entry,
or if it will take over the meaning of the existing "polygon" entry.



---

diff --git a/src/Makefile.am b/src/Makefile.am
index 6a98d3a..6a482c0 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -104,6 +104,8 @@ PCB_SRCS = \
 	polygon.h \
 	polygon1.c \
 	polyarea.h \
+	pour.c \
+	pour.h \
 	puller.c \
 	print.c \
 	print.h \
diff --git a/src/create.c b/src/create.c
index bbfd52f..d5ea0c9 100644
--- a/src/create.c
+++ b/src/create.c
@@ -605,6 +605,7 @@ CreateNewPolygon (LayerTypePtr Layer, FlagType Flags)
   polygon->Clipped = NULL;
   polygon->NoHoles = NULL;
   polygon->NoHolesValid = 0;
+  polygon->Parent = NULL;
   return (polygon);
 }
 
diff --git a/src/global.h b/src/global.h
index 7763c80..6ad99c6 100644
--- a/src/global.h
+++ b/src/global.h
@@ -198,7 +198,19 @@ typedef struct
   void *Element;
 } TextType, *TextTypePtr;
 
-typedef struct			/* holds information about a polygon */
+typedef struct polygon_st PolygonType, *PolygonTypePtr;
+
+#if 0
+typedef struct			/* holds information about a poured area */
+{
+  ANYOBJECTFIELDS;
+  Cardinal PointN,		/* number of points in pour outline */
+    PointMax;			/* max number from malloc() */
+  PolygonTypePtr polygons;	/* the resulting polygons */
+} PourType, *PourTypePtr;
+#endif
+
+struct polygon_st		/* holds information about a polygon */
 {
   ANYOBJECTFIELDS;
   Cardinal PointN,		/* number of points in polygon */
@@ -207,7 +219,9 @@ typedef struct			/* holds information about a polygon */
   POLYAREA *NoHoles;		/* the polygon broken into hole-less regions */
   int NoHolesValid;		/* Is the NoHoles polygon up to date? */
   PointTypePtr Points;		/* data */
-} PolygonType, *PolygonTypePtr;
+//  PourTypePtr Pour;		/* The pour which resulted in this polygon */
+  PolygonTypePtr *Parent;	/* The parent polygon which defined us */
+};
 
 typedef struct			/* holds information about arcs */
 {
@@ -232,12 +246,14 @@ typedef struct			/* holds information about one layer */
   Cardinal LineN,		/* number of lines */
     TextN,			/* labels */
     PolygonN,			/* polygons */
+    PourN,			/* poured areas */
     ArcN,			/* and arcs */
     LineMax,			/* max number from malloc() */
-    TextMax, PolygonMax, ArcMax;
+    TextMax, PolygonMax, PourMax, ArcMax;
   LineTypePtr Line;		/* pointer to additional structures */
   TextTypePtr Text;
   PolygonTypePtr Polygon;
+  PolygonTypePtr Pour;
   ArcTypePtr Arc;
   rtree_t *line_tree, *text_tree, *polygon_tree, *arc_tree;
   Boolean On;			/* visible flag */
diff --git a/src/macro.h b/src/macro.h
index 819d202..5bae417 100644
--- a/src/macro.h
+++ b/src/macro.h
@@ -391,6 +391,13 @@ extern int mem_any_set (unsigned char *, int);
 	{						\
 		text = &(layer)->Text[n]
 
+#define	POUR_LOOP(layer) do {			\
+	Cardinal		n;			\
+	PolygonTypePtr	pour;			\
+	for (n = (layer)->PourN-1; n != -1; n--)	\
+	{						\
+		pour = &(layer)->Pour[n]
+
 #define	POLYGON_LOOP(layer) do {			\
 	Cardinal		n;			\
 	PolygonTypePtr	polygon;			\
diff --git a/src/mymem.c b/src/mymem.c
index ffa4dad..fba0715 100644
--- a/src/mymem.c
+++ b/src/mymem.c
@@ -399,6 +399,35 @@ GetTextMemory (LayerTypePtr Layer)
 }
 
 /* ---------------------------------------------------------------------------
+ * get next slot for a pour polygon object, allocates memory if necessary
+ */
+PolygonTypePtr
+GetPourMemory (LayerTypePtr Layer)
+{
+  PolygonTypePtr pour = Layer->Pour;
+
+  /* realloc new memory if necessary and clear it */
+  if (Layer->PourN >= Layer->PourMax)
+    {
+      Layer->PourMax += STEP_POUR;
+//      if (Layer->polygon_tree)
+//	r_destroy_tree (&Layer->polygon_tree);
+      pour = MyRealloc (pour, Layer->PourMax * sizeof (PolygonType),
+			   "GetPourMemory()");
+      Layer->Pour = pour;
+      memset (pour + Layer->PourN, 0,
+	      STEP_POUR * sizeof (PolygonType));
+//      Layer->polygon_tree = r_create_tree (NULL, 0, 0);
+//      POLYGON_LOOP (Layer);
+//      {
+//	r_insert_entry (Layer->polygon_tree, (BoxType *) polygon, 0);
+//      }
+//      END_LOOP;
+    }
+  return (pour + Layer->PourN++);
+}
+
+/* ---------------------------------------------------------------------------
  * get next slot for a polygon object, allocates memory if necessary
  */
 PolygonTypePtr
@@ -903,6 +932,12 @@ FreeDataMemory (DataTypePtr Data)
 	  }
 	  END_LOOP;
 	  MYFREE (layer->Polygon);
+	  POUR_LOOP (layer);
+	  {
+	    FreePolygonMemory (pour);
+	  }
+	  END_LOOP;
+	  MYFREE (layer->Pour);
 	  if (layer->line_tree)
 	    r_destroy_tree (&layer->line_tree);
 	  if (layer->arc_tree)
diff --git a/src/mymem.h b/src/mymem.h
index b9d4de1..bbcaec4 100644
--- a/src/mymem.h
+++ b/src/mymem.h
@@ -56,6 +56,7 @@
 #define	STEP_SELECTORENTRY	128
 #define	STEP_REMOVELIST		500
 #define	STEP_UNDOLIST		500
+#define	STEP_POUR		10
 #define	STEP_POLYGON		10
 #define	STEP_POLYGONPOINT	10
 #define	STEP_LIBRARYMENU	10
diff --git a/src/pour.c b/src/pour.c
new file mode 100644
index 0000000..61b5d80
--- /dev/null
+++ b/src/pour.c
@@ -0,0 +1,229 @@
+/* $Id$ */
+
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 1994,1995,1996 Thomas Nau
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Contact addresses for paper mail and Email:
+ *  Thomas Nau, Schlehenweg 15, 88471 Baustetten, Germany
+ *  Thomas.Nau@rz.uni-ulm.de
+ *
+ */
+
+
+/* special polygon editing routines
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <assert.h>
+#include <math.h>
+#include <memory.h>
+#include <setjmp.h>
+
+#include "global.h"
+#include "box.h"
+#include "create.h"
+#include "crosshair.h"
+#include "data.h"
+#include "draw.h"
+#include "error.h"
+#include "find.h"
+#include "misc.h"
+#include "move.h"
+#include "polygon.h"
+#include "pour.h"
+#include "remove.h"
+#include "rtree.h"
+#include "search.h"
+#include "set.h"
+#include "thermal.h"
+#include "undo.h"
+
+#ifdef HAVE_LIBDMALLOC
+#include <dmalloc.h>
+#endif
+
+RCSID ("$Id$");
+
+#define ROUND(x) ((long)(((x) >= 0 ? (x) + 0.5  : (x) - 0.5)))
+
+#define UNSUBTRACT_BLOAT 10
+
+/* ---------------------------------------------------------------------------
+ * local prototypes
+ */
+
+#define CIRC_SEGS 36
+static double circleVerticies[] = {
+  1.0, 0.0,
+  0.98480775301221, 0.17364817766693,
+};
+
+#if 0
+int
+InitClip (DataTypePtr Data, LayerTypePtr layer, PolygonType * p)
+{
+  if (p->Clipped)
+    poly_Free (&p->Clipped);
+  p->Clipped = original_poly (p);
+  if (p->NoHoles)
+    poly_Free (&p->NoHoles);
+  p->NoHoles = NULL;
+  if (!p->Clipped)
+    return 0;
+  assert (poly_Valid (p->Clipped));
+  if (TEST_FLAG (CLEARPOLYFLAG, p))
+    clearPoly (Data, layer, p, NULL, 0);
+  else
+    p->NoHolesValid = 0;
+  return 1;
+}
+#endif
+
+/* --------------------------------------------------------------------------
+ * remove redundant polygon points. Any point that lies on the straight
+ * line between the points on either side of it is redundant.
+ * returns true if any points are removed
+ */
+Boolean
+RemoveExcessPourPoints (LayerTypePtr Layer, PolygonTypePtr Polygon)
+{
+  return RemoveExcessPolygonPoints (Layer, Polygon);
+}
+
+/* ---------------------------------------------------------------------------
+ * returns the index of the polygon point which is the end
+ * point of the segment with the lowest distance to the passed
+ * coordinates
+ */
+Cardinal
+GetLowestDistancePourPoint (PolygonTypePtr Polygon, LocationType X,
+                            LocationType Y)
+{
+  return GetLowestDistancePourPoint (Polygon, X, Y);
+}
+
+/* ---------------------------------------------------------------------------
+ * go back to the  previous point of the polygon
+ */
+void
+GoToPreviousPourPoint (void)
+{
+  switch (Crosshair.AttachedPolygon.PointN)
+    {
+      /* do nothing if mode has just been entered */
+    case 0:
+      break;
+
+      /* reset number of points and 'LINE_MODE' state */
+    case 1:
+      Crosshair.AttachedPolygon.PointN = 0;
+      Crosshair.AttachedLine.State = STATE_FIRST;
+      addedLines = 0;
+      break;
+
+      /* back-up one point */
+    default:
+      {
+        PointTypePtr points = Crosshair.AttachedPolygon.Points;
+        Cardinal n = Crosshair.AttachedPolygon.PointN - 2;
+
+        Crosshair.AttachedPolygon.PointN--;
+        Crosshair.AttachedLine.Point1.X = points[n].X;
+        Crosshair.AttachedLine.Point1.Y = points[n].Y;
+        break;
+      }
+    }
+}
+
+/* ---------------------------------------------------------------------------
+ * close pour if possible
+ */
+void
+ClosePour (void)
+{
+  Cardinal n = Crosshair.AttachedPolygon.PointN;
+
+  /* check number of points */
+  if (n >= 3)
+    {
+      /* if 45 degree lines are what we want do a quick check
+       * if closing the polygon makes sense
+       */
+      if (!TEST_FLAG (ALLDIRECTIONFLAG, PCB))
+        {
+          BDimension dx, dy;
+
+          dx = abs (Crosshair.AttachedPolygon.Points[n - 1].X -
+                    Crosshair.AttachedPolygon.Points[0].X);
+          dy = abs (Crosshair.AttachedPolygon.Points[n - 1].Y -
+                    Crosshair.AttachedPolygon.Points[0].Y);
+          if (!(dx == 0 || dy == 0 || dx == dy))
+            {
+              Message
+                (_
+                 ("Cannot close polygon because 45 degree lines are requested.\n"));
+              return;
+            }
+        }
+      CopyAttachedPolygonToLayer ();
+      Draw ();
+    }
+  else
+    Message (_("A polygon has to have at least 3 points\n"));
+}
+
+/* ---------------------------------------------------------------------------
+ * moves the data of the attached (new) polygon to the current layer
+ */
+void
+CopyAttachedPourToLayer (void)
+{
+  PolygonTypePtr polygon;
+  int saveID;
+
+  /* move data to layer and clear attached struct */
+  polygon = CreateNewPolygon (CURRENT, NoFlags ());
+  saveID = polygon->ID;
+  *polygon = Crosshair.AttachedPolygon;
+  polygon->ID = saveID;
+  SET_FLAG (CLEARPOLYFLAG, polygon);
+  if (TEST_FLAG (NEWFULLPOLYFLAG, PCB))
+    SET_FLAG (FULLPOLYFLAG, polygon);
+  memset (&Crosshair.AttachedPolygon, 0, sizeof (PolygonType));
+  SetPolygonBoundingBox (polygon);
+  if (!CURRENT->polygon_tree)
+    CURRENT->polygon_tree = r_create_tree (NULL, 0, 0);
+  r_insert_entry (CURRENT->polygon_tree, (BoxType *) polygon, 0);
+  InitClip (PCB->Data, CURRENT, polygon);
+  DrawPolygon (CURRENT, polygon, 0);
+  SetChangedFlag (True);
+
+  /* reset state of attached line */
+  Crosshair.AttachedLine.State = STATE_FIRST;
+  addedLines = 0;
+
+  /* add to undo list */
+  AddObjectToCreateUndoList (POLYGON_TYPE, CURRENT, polygon, polygon);
+  IncrementUndoSerialNumber ();
+}
+
diff --git a/src/pour.h b/src/pour.h
new file mode 100644
index 0000000..0ed875e
--- /dev/null
+++ b/src/pour.h
@@ -0,0 +1,43 @@
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 1994,1995,1996 Thomas Nau
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Contact addresses for paper mail and Email:
+ *  Thomas Nau, Schlehenweg 15, 88471 Baustetten, Germany
+ *  Thomas.Nau@rz.uni-ulm.de
+ *
+ *  RCS: $Id$
+ */
+
+/* prototypes for pour editing routines
+ */
+
+#ifndef	__POUR_INCLUDED__
+#define	__POUR_INCLUDED__
+
+#include "global.h"
+
+Cardinal GetLowestDistancePourPoint (PolygonTypePtr,
+					LocationType, LocationType);
+Boolean RemoveExcessPourPoints (LayerTypePtr, PolygonTypePtr);
+void GoToPreviousPourPoint (void);
+void ClosePour (void);
+void CopyAttachedPourToLayer (void);
+//int InitClip(DataType *d, LayerType *l, PolygonType *p);
+#endif

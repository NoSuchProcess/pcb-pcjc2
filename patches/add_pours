Bottom: 14c9888f54ed51a0e8bb37591bf61cd67a8c7c5c
Top:    fae668b99a9acf4cc478a2c5ed12cc0bf6fe5d26
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2008-10-10 13:51:23 +0100

Add support for a "poured" object.

This takes half of the existing polygon functionality, and splits it
such that the user defines a poured region (similar to drawing a polygon
previously), and after clipping, this produces zero or more polygon
objects which are drawn and connectivity checked with the existing
polygon code.

Selecting a "polygon" will cause the parent "pour" to be looked up, and
all child polygons selected. Manipulations will always occur on the
"pour", with "polygons" being updated after clipping.

It remains to be seen whether "pour" will have its own file-format entry,
or if it will take over the meaning of the existing "polygon" entry.




---

diff --git a/globalconst.h b/globalconst.h
index cd6f4f9..4ab3813 100755
--- a/globalconst.h
+++ b/globalconst.h
@@ -118,6 +118,8 @@
 						/* line points */
 #define	MAX_POLYGON_POINT_DISTANCE	0	/* maximum distance when searching */
 						/* polygon points */
+#define	MAX_POUR_POINT_DISTANCE	0	/* maximum distance when searching */
+						/* pour points */
 #define	MAX_ELEMENTNAMES		3	/* number of supported names of */
 						/* an element */
 #define	MAX_LIBRARY_LINE_LENGTH		255	/* maximum line length in the */
diff --git a/src/Makefile.am b/src/Makefile.am
index 6a98d3a..6a482c0 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -104,6 +104,8 @@ PCB_SRCS = \
 	polygon.h \
 	polygon1.c \
 	polyarea.h \
+	pour.c \
+	pour.h \
 	puller.c \
 	print.c \
 	print.h \
diff --git a/src/action.c b/src/action.c
index af7ba6b..6b2dc76 100644
--- a/src/action.c
+++ b/src/action.c
@@ -57,6 +57,7 @@
 #include "misc.h"
 #include "move.h"
 #include "polygon.h"
+#include "pour.h"
 /*#include "print.h"*/
 #include "rats.h"
 #include "remove.h"
@@ -133,7 +134,7 @@ typedef enum
   F_PinByName,
   F_PinOrPadName,
   F_Pinout,
-  F_Polygon,
+  F_Pour,
   F_PreviousPoint,
   F_RatsNest,
   F_Rectangle,
@@ -284,7 +285,7 @@ static PointType InsertedPoint;
 static LayerTypePtr lastLayer;
 static struct
 {
-  PolygonTypePtr poly;
+  PourTypePtr pour;
   LineType line;
 }
 fake;
@@ -363,7 +364,8 @@ static FunctionType Functions[] = {
   {"PinByName", F_PinByName},
   {"PinOrPadName", F_PinOrPadName},
   {"Pinout", F_Pinout},
-  {"Polygon", F_Polygon},
+  {"Pour", F_Pour},
+//  {"Polygon", F_Polygon},
   {"PreviousPoint", F_PreviousPoint},
   {"RatsNest", F_RatsNest},
   {"Rectangle", F_Rectangle},
@@ -824,8 +826,8 @@ AdjustAttachedObjects (void)
       AdjustAttachedBox ();
       break;
 
-      /* polygon creation mode */
-    case POLYGON_MODE:
+      /* pour creation mode */
+    case POUR_MODE:
       AdjustAttachedLine ();
       break;
       /* line creation mode */
@@ -1334,12 +1336,12 @@ NotifyMode (void)
 	  Crosshair.AttachedBox.Point1.X != Crosshair.AttachedBox.Point2.X &&
 	  Crosshair.AttachedBox.Point1.Y != Crosshair.AttachedBox.Point2.Y)
 	{
-	  PolygonTypePtr polygon;
+	  PourTypePtr pour;
 
 	  int flags = CLEARPOLYFLAG;
 	  if (Settings.FullPoly)
 	    flags |= FULLPOLYFLAG;
-	  if ((polygon = CreateNewPolygonFromRectangle (CURRENT,
+	  if ((pour = CreateNewPourFromRectangle (CURRENT,
 							Crosshair.
 							AttachedBox.Point1.X,
 							Crosshair.
@@ -1352,10 +1354,10 @@ NotifyMode (void)
 							(flags))) !=
 	      NULL)
 	    {
-	      AddObjectToCreateUndoList (POLYGON_TYPE, CURRENT,
-					 polygon, polygon);
+	      AddObjectToCreateUndoList (POUR_TYPE, CURRENT,
+					 pour, pour);
 	      IncrementUndoSerialNumber ();
-	      DrawPolygon (CURRENT, polygon, 0);
+	      DrawPour (CURRENT, pour, 0);
 	      Draw ();
 	    }
 
@@ -1395,10 +1397,10 @@ NotifyMode (void)
 	break;
       }
 
-    case POLYGON_MODE:
+    case POUR_MODE:
       {
-	PointTypePtr points = Crosshair.AttachedPolygon.Points;
-	Cardinal n = Crosshair.AttachedPolygon.PointN;
+	PointTypePtr points = Crosshair.AttachedPour.Points;
+	Cardinal n = Crosshair.AttachedPour.PointN;
 
 	/* do update of position; use the 'LINE_MODE' mechanism */
 	NotifyLine ();
@@ -1408,7 +1410,7 @@ NotifyMode (void)
 	    points->X == Crosshair.AttachedLine.Point2.X &&
 	    points->Y == Crosshair.AttachedLine.Point2.Y)
 	  {
-	    CopyAttachedPolygonToLayer ();
+	    CopyAttachedPourToLayer ();
 	    Draw ();
 	    break;
 	  }
@@ -1420,9 +1422,9 @@ NotifyMode (void)
 	    points[n - 1].X != Crosshair.AttachedLine.Point2.X ||
 	    points[n - 1].Y != Crosshair.AttachedLine.Point2.Y)
 	  {
-	    CreateNewPointInPolygon (&Crosshair.AttachedPolygon,
-				     Crosshair.AttachedLine.Point2.X,
-				     Crosshair.AttachedLine.Point2.Y);
+	    CreateNewPointInPour (&Crosshair.AttachedPour,
+				  Crosshair.AttachedLine.Point2.X,
+				  Crosshair.AttachedLine.Point2.Y);
 
 	    /* copy the coordinates */
 	    Crosshair.AttachedLine.Point1.X = Crosshair.AttachedLine.Point2.X;
@@ -1615,15 +1617,13 @@ NotifyMode (void)
 		  /* get starting point of nearest segment */
 		  if (Crosshair.AttachedObject.Type == POLYGON_TYPE)
 		    {
-		      fake.poly =
-			(PolygonTypePtr) Crosshair.AttachedObject.Ptr2;
+		      fake.pour = (PourTypePtr) Crosshair.AttachedObject.Ptr2;
 		      polyIndex =
-			GetLowestDistancePolygonPoint (fake.poly, Note.X,
-						       Note.Y);
-		      fake.line.Point1 = fake.poly->Points[polyIndex];
+			GetLowestDistancePourPoint (fake.pour, Note.X, Note.Y);
+		      fake.line.Point1 = fake.pour->Points[polyIndex];
 		      fake.line.Point2 = (polyIndex) ?
-			fake.poly->Points[polyIndex - 1]
-			: fake.poly->Points[fake.poly->PointN - 1];
+			fake.pour->Points[polyIndex - 1]
+			: fake.pour->Points[fake.pour->PointN - 1];
 		      Crosshair.AttachedObject.Ptr2 = &fake.line;
 
 		    }
@@ -1635,9 +1635,9 @@ NotifyMode (void)
 
 	  /* second notify, insert new point into object */
 	case STATE_SECOND:
-	  if (Crosshair.AttachedObject.Type == POLYGON_TYPE)
-	    InsertPointIntoObject (POLYGON_TYPE,
-				   Crosshair.AttachedObject.Ptr1, fake.poly,
+	  if (Crosshair.AttachedObject.Type == POUR_TYPE)
+	    InsertPointIntoObject (POUR_TYPE,
+				   Crosshair.AttachedObject.Ptr1, fake.pour,
 				   &polyIndex,
 				   InsertedPoint.X, InsertedPoint.Y, False);
 	  else
@@ -2970,13 +2970,13 @@ ActionMode (int argc, char **argv, int x, int y)
 		  }
 		break;
 	  
-	      case POLYGON_MODE:
+	      case POUR_MODE:
 		if (Crosshair.AttachedLine.State == STATE_FIRST)
 		  SetMode (ARROW_MODE);
 		else
 		  {
 		    SetMode (NO_MODE);
-		    SetMode (POLYGON_MODE);
+		    SetMode (POUR_MODE);
 		  }
 		break;
 
@@ -3005,8 +3005,8 @@ ActionMode (int argc, char **argv, int x, int y)
 	case F_PasteBuffer:
 	  SetMode (PASTEBUFFER_MODE);
 	  break;
-	case F_Polygon:
-	  SetMode (POLYGON_MODE);
+	case F_Pour:
+	  SetMode (POUR_MODE);
 	  break;
 #ifndef HAVE_LIBSTROKE
 	case F_Release:
@@ -3050,9 +3050,9 @@ ActionMode (int argc, char **argv, int x, int y)
 	  else if (Settings.Mode == RECTANGLE_MODE
 		   && Crosshair.AttachedBox.State != STATE_FIRST)
 	    SetMode (RECTANGLE_MODE);
-	  else if (Settings.Mode == POLYGON_MODE
+	  else if (Settings.Mode == POUR_MODE
 		   && Crosshair.AttachedLine.State != STATE_FIRST)
-	    SetMode (POLYGON_MODE);
+	    SetMode (POUR_MODE);
 	  else
 	    {
 	      SaveMode ();
@@ -4431,6 +4431,9 @@ off are automatically deleted.
 static int
 ActionMorphPolygon (int argc, char **argv, int x, int y)
 {
+#warning FIXME Later
+  Message ("Morph polygon not implemented. Pours are nice though!\n");
+#if 0
   char *function = ARG (0);
   if (function)
     {
@@ -4466,6 +4469,7 @@ ActionMorphPolygon (int argc, char **argv, int x, int y)
 	}
     }
   return 0;
+#endif
 }
 
 /* --------------------------------------------------------------------------- */
@@ -6033,9 +6037,9 @@ ActionUndo (int argc, char **argv, int x, int y)
       /* undo the last operation */
 
       HideCrosshair (True);
-      if (Settings.Mode == POLYGON_MODE && Crosshair.AttachedPolygon.PointN)
+      if (Settings.Mode == POUR_MODE && Crosshair.AttachedPour.PointN)
 	{
-	  GoToPreviousPoint ();
+	  GoToPreviousPourPoint ();
 	  RestoreCrosshair (True);
 	  return 0;
 	}
@@ -6195,8 +6199,8 @@ three "undone" lines.
 static int
 ActionRedo (int argc, char **argv, int x, int y)
 {
-  if ((Settings.Mode == POLYGON_MODE &&
-       Crosshair.AttachedPolygon.PointN) ||
+  if ((Settings.Mode == POUR_MODE &&
+       Crosshair.AttachedPour.PointN) ||
       Crosshair.AttachedLine.State == STATE_SECOND)
     return 1;
   HideCrosshair (True);
@@ -6246,19 +6250,19 @@ static int
 ActionPolygon (int argc, char **argv, int x, int y)
 {
   char *function = ARG (0);
-  if (function && Settings.Mode == POLYGON_MODE)
+  if (function && Settings.Mode == POUR_MODE)
     {
       HideCrosshair (True);
       switch (GetFunctionID (function))
 	{
-	  /* close open polygon if possible */
+	  /* close open pour if possible */
 	case F_Close:
-	  ClosePolygon ();
+	  ClosePour ();
 	  break;
 
 	  /* go back to the previous point */
 	case F_PreviousPoint:
-	  GoToPreviousPoint ();
+	  GoToPreviousPourPoint ();
 	  break;
 	}
       RestoreCrosshair (True);
diff --git a/src/autoroute.c b/src/autoroute.c
index 61ac386..585c3de 100644
--- a/src/autoroute.c
+++ b/src/autoroute.c
@@ -667,6 +667,8 @@ AddPolygon (PointerListType layergroupboxes[], Cardinal layer,
 			     polygon->BoundingBox.X2,
 			     polygon->BoundingBox.Y2,
 			     layergroup, polygon);
+#warning FIXME LATER
+#if 0
   if (polygon->PointN == 4 &&
       (polygon->Points[0].X == polygon->Points[1].X ||
        polygon->Points[0].Y == polygon->Points[1].Y) &&
@@ -677,6 +679,7 @@ AddPolygon (PointerListType layergroupboxes[], Cardinal layer,
       (polygon->Points[3].X == polygon->Points[0].X ||
        polygon->Points[3].Y == polygon->Points[0].Y))
     is_not_rectangle = 0;
+#endif
   rb->flags.nonstraight = is_not_rectangle;
   rb->layer = layer;
   if (TEST_FLAG (CLEARPOLYFLAG, polygon))
@@ -1066,12 +1069,16 @@ CreateRouteData ()
       }
       END_LOOP;
       /* add all polygons */
-      POLYGON_LOOP (LAYER_PTR (i));
+      POUR_LOOP (LAYER_PTR (i));
       {
-        if (TEST_FLAG (DRCFLAG, polygon))
-          CLEAR_FLAG (DRCFLAG, polygon);
-        else
-          AddPolygon (layergroupboxes, i, polygon);
+        POURPOLYGON_LOOP (pour);
+        {
+          if (TEST_FLAG (DRCFLAG, polygon))
+            CLEAR_FLAG (DRCFLAG, polygon);
+          else
+            AddPolygon (layergroupboxes, i, polygon);
+        }
+        END_LOOP;
       }
       END_LOOP;
       /* add all copper text */
@@ -2971,7 +2978,7 @@ do_via_search (edge_t * search, struct routeone_state *s,
         {
           BoxType cliparea;
           BoxType *area = vector_remove_last (v);
-          assert (box_intersect (area, &region));
+//          assert (box_intersect (area, &region));
           if (!(i == NO_CONFLICT || AutoRouteParameters.with_conflicts))
             {
               free (area);
diff --git a/src/buffer.c b/src/buffer.c
index a88d11f..909bac3 100644
--- a/src/buffer.c
+++ b/src/buffer.c
@@ -50,6 +50,7 @@
 #include "misc.h"
 #include "parse_l.h"
 #include "polygon.h"
+#include "pour.h"
 #include "rats.h"
 #include "rotate.h"
 #include "remove.h"
@@ -72,14 +73,16 @@ static void *AddLineToBuffer (LayerTypePtr, LineTypePtr);
 static void *AddArcToBuffer (LayerTypePtr, ArcTypePtr);
 static void *AddRatToBuffer (RatTypePtr);
 static void *AddTextToBuffer (LayerTypePtr, TextTypePtr);
-static void *AddPolygonToBuffer (LayerTypePtr, PolygonTypePtr);
+//static void *AddPolygonToBuffer (LayerTypePtr, PolygonTypePtr);
+static void *AddPourToBuffer (LayerTypePtr, PourTypePtr);
 static void *AddElementToBuffer (ElementTypePtr);
 static void *MoveViaToBuffer (PinTypePtr);
 static void *MoveLineToBuffer (LayerTypePtr, LineTypePtr);
 static void *MoveArcToBuffer (LayerTypePtr, ArcTypePtr);
 static void *MoveRatToBuffer (RatTypePtr);
 static void *MoveTextToBuffer (LayerTypePtr, TextTypePtr);
-static void *MovePolygonToBuffer (LayerTypePtr, PolygonTypePtr);
+//static void *MovePolygonToBuffer (LayerTypePtr, PolygonTypePtr);
+static void *MovePourToBuffer (LayerTypePtr, PourTypePtr);
 static void *MoveElementToBuffer (ElementTypePtr);
 static void SwapBuffer (BufferTypePtr);
 
@@ -91,7 +94,9 @@ static DataTypePtr Dest, Source;
 static ObjectFunctionType AddBufferFunctions = {
   AddLineToBuffer,
   AddTextToBuffer,
-  AddPolygonToBuffer,
+#warning FIXME Later
+  NULL, //AddPolygonToBuffer,
+  AddPourToBuffer,
   AddViaToBuffer,
   AddElementToBuffer,
   NULL,
@@ -99,6 +104,7 @@ static ObjectFunctionType AddBufferFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   AddArcToBuffer,
   AddRatToBuffer
 }, MoveBufferFunctions =
@@ -106,10 +112,18 @@ static ObjectFunctionType AddBufferFunctions = {
 {
 MoveLineToBuffer,
     MoveTextToBuffer,
-    MovePolygonToBuffer,
+    NULL, // MovePolygonToBuffer,
+    MovePourToBuffer,
     MoveViaToBuffer,
     MoveElementToBuffer,
-    NULL, NULL, NULL, NULL, NULL, MoveArcToBuffer, MoveRatToBuffer};
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    MoveArcToBuffer,
+    MoveRatToBuffer};
 
 static int ExtraFlag = 0;
 
@@ -183,6 +197,8 @@ AddTextToBuffer (LayerTypePtr Layer, TextTypePtr Text)
 			 MaskFlags (Text->Flags, ExtraFlag)));
 }
 
+#warning FIXME Later
+#if 0
 /* ---------------------------------------------------------------------------
  * copies a polygon to buffer
  */
@@ -197,6 +213,22 @@ AddPolygonToBuffer (LayerTypePtr Layer, PolygonTypePtr Polygon)
   CLEAR_FLAG (FOUNDFLAG | ExtraFlag, polygon);
   return (polygon);
 }
+#endif
+
+/* ---------------------------------------------------------------------------
+ * copies a pour to buffer
+ */
+static void *
+AddPourToBuffer (LayerTypePtr Layer, PourTypePtr Pour)
+{
+  LayerTypePtr layer = &Dest->Layer[GetLayerNumber (Source, Layer)];
+  PourTypePtr pour;
+
+  pour = GetPourMemory (layer);
+  CopyPourLowLevel (pour, Pour);
+  CLEAR_FLAG (FOUNDFLAG | ExtraFlag, pour);
+  return (pour);
+}
 
 /* ---------------------------------------------------------------------------
  * copies a element to buffer
@@ -238,7 +270,7 @@ MoveViaToBuffer (PinTypePtr Via)
 {
   PinTypePtr via;
 
-  RestoreToPolygon (Source, VIA_TYPE, Via, Via);
+  RestoreToPours (Source, VIA_TYPE, Via, Via);
   r_delete_entry (Source->via_tree, (BoxType *) Via);
   via = GetViaMemory (Dest);
   *via = *Via;
@@ -250,7 +282,7 @@ MoveViaToBuffer (PinTypePtr Via)
   if (!Dest->via_tree)
     Dest->via_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (Dest->via_tree, (BoxType *) via, 0);
-  ClearFromPolygon (Dest, VIA_TYPE, via, via);
+  ClearFromPours (Dest, VIA_TYPE, via, via);
   return (via);
 }
 
@@ -285,7 +317,7 @@ MoveLineToBuffer (LayerTypePtr Layer, LineTypePtr Line)
   LayerTypePtr lay;
   LineTypePtr line;
 
-  RestoreToPolygon (Source, LINE_TYPE, Layer, Line);
+  RestoreToPours (Source, LINE_TYPE, Layer, Line);
   r_delete_entry (Layer->line_tree, (BoxTypePtr) Line);
   lay = &Dest->Layer[GetLayerNumber (Source, Layer)];
   line = GetLineMemory (lay);
@@ -299,7 +331,7 @@ MoveLineToBuffer (LayerTypePtr Layer, LineTypePtr Line)
   if (!lay->line_tree)
     lay->line_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (lay->line_tree, (BoxTypePtr) line, 0);
-  ClearFromPolygon (Dest, LINE_TYPE, lay, line);
+  ClearFromPours (Dest, LINE_TYPE, lay, line);
   return (line);
 }
 
@@ -312,7 +344,7 @@ MoveArcToBuffer (LayerTypePtr Layer, ArcTypePtr Arc)
   LayerTypePtr lay;
   ArcTypePtr arc;
 
-  RestoreToPolygon (Source, ARC_TYPE, Layer, Arc);
+  RestoreToPours (Source, ARC_TYPE, Layer, Arc);
   r_delete_entry (Layer->arc_tree, (BoxTypePtr) Arc);
   lay = &Dest->Layer[GetLayerNumber (Source, Layer)];
   arc = GetArcMemory (lay);
@@ -326,7 +358,7 @@ MoveArcToBuffer (LayerTypePtr Layer, ArcTypePtr Arc)
   if (!lay->arc_tree)
     lay->arc_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (lay->arc_tree, (BoxTypePtr) arc, 0);
-  ClearFromPolygon (Dest, ARC_TYPE, lay, arc);
+  ClearFromPours (Dest, ARC_TYPE, lay, arc);
   return (arc);
 }
 
@@ -340,7 +372,7 @@ MoveTextToBuffer (LayerTypePtr Layer, TextTypePtr Text)
   LayerTypePtr lay;
 
   r_delete_entry (Layer->text_tree, (BoxTypePtr) Text);
-  RestoreToPolygon (Source, TEXT_TYPE, Layer, Text);
+  RestoreToPours (Source, TEXT_TYPE, Layer, Text);
   lay = &Dest->Layer[GetLayerNumber (Source, Layer)];
   text = GetTextMemory (lay);
   *text = *Text;
@@ -351,10 +383,12 @@ MoveTextToBuffer (LayerTypePtr Layer, TextTypePtr Text)
   if (!lay->text_tree)
     lay->text_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (lay->text_tree, (BoxTypePtr) text, 0);
-  ClearFromPolygon (Dest, TEXT_TYPE, lay, text);
+  ClearFromPours (Dest, TEXT_TYPE, lay, text);
   return (text);
 }
 
+#warning FIXME Later
+#if 0
 /* ---------------------------------------------------------------------------
  * moves a polygon to buffer. Doesn't allocate memory for the points
  */
@@ -364,7 +398,7 @@ MovePolygonToBuffer (LayerTypePtr Layer, PolygonTypePtr Polygon)
   LayerTypePtr lay;
   PolygonTypePtr polygon;
 
-  RestoreToPolygon (Source, POLYGON_TYPE, Layer, Polygon);
+  RestoreToPours (Source, POLYGON_TYPE, Layer, Polygon);
   r_delete_entry (Layer->polygon_tree, (BoxTypePtr) Polygon);
   lay = &Dest->Layer[GetLayerNumber (Source, Layer)];
   polygon = GetPolygonMemory (lay);
@@ -378,9 +412,37 @@ MovePolygonToBuffer (LayerTypePtr Layer, PolygonTypePtr Polygon)
   if (!lay->polygon_tree)
     lay->polygon_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (lay->polygon_tree, (BoxTypePtr) polygon, 0);
-  ClearFromPolygon (Source, POLYGON_TYPE, Layer, Polygon);
+  ClearFromPours (Source, POLYGON_TYPE, Layer, Polygon);
   return (polygon);
 }
+#endif
+
+/* ---------------------------------------------------------------------------
+ * moves a pour to buffer. Doesn't allocate memory for the points
+ */
+static void *
+MovePourToBuffer (LayerTypePtr Layer, PourTypePtr Pour)
+{
+  LayerTypePtr lay;
+  PourTypePtr pour;
+
+  RestoreToPours (Source, POLYGON_TYPE, Layer, Pour);
+  r_delete_entry (Layer->pour_tree, (BoxTypePtr) Pour);
+  lay = &Dest->Layer[GetLayerNumber (Source, Layer)];
+  pour = GetPourMemory (lay);
+  *pour = *Pour;
+  CLEAR_FLAG (FOUNDFLAG, pour);
+  *Pour = Layer->Pour[--Layer->PourN];
+  r_substitute (Layer->pour_tree,
+		(BoxTypePtr) & Layer->Pour[Layer->PourN],
+		(BoxTypePtr) Pour);
+  memset (&Layer->Pour[Layer->PourN], 0, sizeof (PourType));
+  if (!lay->pour_tree)
+    lay->pour_tree = r_create_tree (NULL, 0, 0);
+  r_insert_entry (lay->pour_tree, (BoxTypePtr) pour, 0);
+  ClearFromPours (Source, POLYGON_TYPE, Layer, Pour);
+  return (pour);
+}
 
 /* ---------------------------------------------------------------------------
  * moves a element to buffer without allocating memory for pins/names
@@ -401,14 +463,14 @@ MoveElementToBuffer (ElementTypePtr Element)
   *element = *Element;
   PIN_LOOP (element);
   {
-    RestoreToPolygon(Source, PIN_TYPE, Element, pin);
+    RestoreToPours(Source, PIN_TYPE, Element, pin);
     CLEAR_FLAG (WARNFLAG | FOUNDFLAG, pin);
     pin->Element = element;
   }
   END_LOOP;
   PAD_LOOP (element);
   {
-    RestoreToPolygon(Source, PAD_TYPE, Element, pad);
+    RestoreToPours(Source, PAD_TYPE, Element, pad);
     CLEAR_FLAG (WARNFLAG | FOUNDFLAG, pad);
     pad->Element = element;
   }
@@ -424,12 +486,12 @@ MoveElementToBuffer (ElementTypePtr Element)
    */
   PIN_LOOP (element);
   {
-    ClearFromPolygon (Dest, PIN_TYPE, element, pin);
+    ClearFromPours (Dest, PIN_TYPE, element, pin);
   }
   END_LOOP;
   PAD_LOOP (element);
   {
-    ClearFromPolygon (Dest, PAD_TYPE, element, pad);
+    ClearFromPours (Dest, PAD_TYPE, element, pad);
   }
   END_LOOP;
 
@@ -658,6 +720,8 @@ SmashBufferElement (BufferTypePtr Buffer)
   return (True);
 }
 
+#warning FIXME Later
+#if 0
 /*---------------------------------------------------------------------------
  *
  * see if a polygon is a rectangle.  If so, canonicalize it.
@@ -694,6 +758,7 @@ polygon_is_rectangle (PolygonTypePtr poly)
     return 1;
   return 0;
 }
+#endif
 
 /*---------------------------------------------------------------------------
  *
@@ -760,34 +825,40 @@ ConvertBufferToElement (BufferTypePtr Buffer)
       hasParts = True;
     }
     END_LOOP;
-    POLYGON_LOOP (layer);
+#warning FIXME Later
+#if 0
+    POUR_LOOP (layer);
     {
-      int x1, y1, x2, y2, w, h, t;
-
-      if (! polygon_is_rectangle (polygon))
-        {
-          crooked = True;
-	  continue;
-        }
-
-      w = polygon->Points[2].X - polygon->Points[0].X;
-      h = polygon->Points[1].Y - polygon->Points[0].Y;
-      t = (w < h) ? w : h;
-      x1 = polygon->Points[0].X + t/2;
-      y1 = polygon->Points[0].Y + t/2;
-      x2 = x1 + (w-t);
-      y2 = y1 + (h-t);
-
-      sprintf (num, "%d", pin_n++);
-      CreateNewPad (Element,
-		    x1, y1, x2, y2, t,
-		    2 * Settings.Keepaway,
-		    t + Settings.Keepaway,
-		    NULL, num,
-		    MakeFlags (SQUAREFLAG | (SWAP_IDENT ? ONSOLDERFLAG : NOFLAG)));
-      hasParts = True;
+      POURPOLYGON_LOOP (pour);
+      {
+        int x1, y1, x2, y2, w, h, t;
+
+        if (! polygon_is_rectangle (polygon))
+          {
+            crooked = True;
+            continue;
+          }
+
+        w = polygon->Points[2].X - polygon->Points[0].X;
+        h = polygon->Points[1].Y - polygon->Points[0].Y;
+        t = (w < h) ? w : h;
+        x1 = polygon->Points[0].X + t/2;
+        y1 = polygon->Points[0].Y + t/2;
+        x2 = x1 + (w-t);
+        y2 = y1 + (h-t);
+
+        sprintf (num, "%d", pin_n++);
+        CreateNewPad (Element, x1, y1, x2, y2, t,
+                      2 * Settings.Keepaway,
+                      t + Settings.Keepaway,
+                      NULL, num,
+                      MakeFlags (SQUAREFLAG | (SWAP_IDENT ? ONSOLDERFLAG : NOFLAG)));
+        hasParts = True;
+      }
+      END_LOOP;
     }
     END_LOOP;
+#endif
   }
   END_LOOP;
   /* now get the opposite side pads */
@@ -940,6 +1011,8 @@ RotateBuffer (BufferTypePtr Buffer, BYTE Number)
     r_insert_entry (layer->text_tree, (BoxTypePtr) text, 0);
   }
   ENDALL_LOOP;
+#warning FIXME Later
+#if 0
   ALLPOLYGON_LOOP (Buffer->Data);
   {
     r_delete_entry (layer->polygon_tree, (BoxTypePtr) polygon);
@@ -947,6 +1020,14 @@ RotateBuffer (BufferTypePtr Buffer, BYTE Number)
     r_insert_entry (layer->polygon_tree, (BoxTypePtr) polygon, 0);
   }
   ENDALL_LOOP;
+#endif
+  ALLPOUR_LOOP (Buffer->Data);
+  {
+    r_delete_entry (layer->pour_tree, (BoxTypePtr) pour);
+    RotatePourLowLevel (pour, Buffer->X, Buffer->Y, Number);
+    r_insert_entry (layer->pour_tree, (BoxTypePtr) pour, 0);
+  }
+  ENDALL_LOOP;
 
   /* finally the origin and the bounding box */
   ROTATE (Buffer->X, Buffer->Y, Buffer->X, Buffer->Y, Number);
@@ -998,7 +1079,7 @@ FreeRotateElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
     /* pre-delete the pins from the pin-tree before their coordinates change */
     if (Data)
       r_delete_entry (Data->pin_tree, (BoxType *) pin);
-    RestoreToPolygon (Data, PIN_TYPE, Element, pin);
+    RestoreToPours (Data, PIN_TYPE, Element, pin);
     free_rotate (&pin->X, &pin->Y, X, Y, cosa, sina);
     SetPinBoundingBox (pin);
   }
@@ -1008,7 +1089,7 @@ FreeRotateElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
     /* pre-delete the pads before their coordinates change */
     if (Data)
       r_delete_entry (Data->pad_tree, (BoxType *) pad);
-    RestoreToPolygon (Data, PAD_TYPE, Element, pad);
+    RestoreToPours (Data, PAD_TYPE, Element, pad);
     free_rotate (&pad->Point1.X, &pad->Point1.Y, X, Y, cosa, sina);
     free_rotate (&pad->Point2.X, &pad->Point2.Y, X, Y, cosa, sina);
     SetLineBoundingBox ((LineType *) pad);
@@ -1024,7 +1105,7 @@ FreeRotateElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
 
   free_rotate (&Element->MarkX, &Element->MarkY, X, Y, cosa, sina);
   SetElementBoundingBox (Data, Element, &PCB->Font);
-  ClearFromPolygon (Data, ELEMENT_TYPE, Element, Element);
+  ClearFromPours (Data, ELEMENT_TYPE, Element, Element);
 }
 
 void
@@ -1073,6 +1154,8 @@ FreeRotateBuffer (BufferTypePtr Buffer, double Angle)
   }
   ENDALL_LOOP;
   /* FIXME: rotate text */
+#warning FIXME Later
+#if 0
   ALLPOLYGON_LOOP (Buffer->Data);
   {
     r_delete_entry (layer->polygon_tree, (BoxTypePtr) polygon);
@@ -1085,6 +1168,19 @@ FreeRotateBuffer (BufferTypePtr Buffer, double Angle)
     r_insert_entry (layer->polygon_tree, (BoxTypePtr) polygon, 0);
   }
   ENDALL_LOOP;
+#endif
+  ALLPOUR_LOOP (Buffer->Data);
+  {
+    r_delete_entry (layer->pour_tree, (BoxTypePtr) pour);
+    POURPOINT_LOOP (pour);
+    {
+      free_rotate (&point->X, &point->Y, Buffer->X, Buffer->Y, cosa, sina);
+    }
+    END_LOOP;
+    SetPourBoundingBox (pour);
+    r_insert_entry (layer->pour_tree, (BoxTypePtr) pour, 0);
+  }
+  ENDALL_LOOP;
 
   SetBufferBoundingBox (Buffer);
 }
@@ -1165,6 +1261,8 @@ MirrorBuffer (BufferTypePtr Buffer)
     SetArcBoundingBox (arc);
   }
   ENDALL_LOOP;
+#warning FIXME Later
+#if 0
   ALLPOLYGON_LOOP (Buffer->Data);
   {
     POLYGONPOINT_LOOP (polygon);
@@ -1176,6 +1274,7 @@ MirrorBuffer (BufferTypePtr Buffer)
     SetPolygonBoundingBox (polygon);
   }
   ENDALL_LOOP;
+#endif
   SetBufferBoundingBox (Buffer);
 }
 
@@ -1230,6 +1329,8 @@ SwapBuffer (BufferTypePtr Buffer)
     r_insert_entry (layer->arc_tree, (BoxTypePtr) arc, 0);
   }
   ENDALL_LOOP;
+#warning FIXME Later
+#if 0
   ALLPOLYGON_LOOP (Buffer->Data);
   {
     r_delete_entry (layer->polygon_tree, (BoxTypePtr) polygon);
@@ -1244,6 +1345,7 @@ SwapBuffer (BufferTypePtr Buffer)
     /* hmmm, how to handle clip */
   }
   ENDALL_LOOP;
+#endif
   ALLTEXT_LOOP (Buffer->Data);
   {
     r_delete_entry (layer->text_tree, (BoxTypePtr) text);
diff --git a/src/change.c b/src/change.c
index e0ef99b..17f8693 100644
--- a/src/change.c
+++ b/src/change.c
@@ -50,6 +50,7 @@
 #include "misc.h"
 #include "mirror.h"
 #include "polygon.h"
+#include "pour.h"
 #include "rats.h"
 #include "remove.h"
 #include "rtree.h"
@@ -123,9 +124,13 @@ static void *ChangeTextJoin (LayerTypePtr, TextTypePtr);
 static void *SetTextJoin (LayerTypePtr, TextTypePtr);
 static void *ClrTextJoin (LayerTypePtr, TextTypePtr);
 static void *ChangePolyClear (LayerTypePtr, PolygonTypePtr);
+static void *ChangePourClear (LayerTypePtr, PourTypePtr);
 static void *ChangePolyJoin (LayerTypePtr, PolygonTypePtr);
+static void *ChangePourJoin (LayerTypePtr, PourTypePtr);
 static void *SetPolyJoin (LayerTypePtr, PolygonTypePtr);
+static void *SetPourJoin (LayerTypePtr, PourTypePtr);
 static void *ClrPolyJoin (LayerTypePtr, PolygonTypePtr);
+static void *ClrPourJoin (LayerTypePtr, PourTypePtr);
 
 /* ---------------------------------------------------------------------------
  * some local identifiers
@@ -137,6 +142,7 @@ static ObjectFunctionType ChangeSizeFunctions = {
   ChangeLineSize,
   ChangeTextSize,
   ChangePolyClear,
+  ChangePourClear,
   ChangeViaSize,
   ChangeElementSize,		/* changes silk screen line width */
   ChangeElementNameSize,
@@ -144,6 +150,7 @@ static ObjectFunctionType ChangeSizeFunctions = {
   ChangePadSize,
   NULL,
   NULL,
+  NULL,
   ChangeArcSize,
   NULL
 };
@@ -151,6 +158,7 @@ static ObjectFunctionType Change2ndSizeFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   ChangeVia2ndSize,
   ChangeElement2ndSize,
   NULL,
@@ -159,12 +167,14 @@ static ObjectFunctionType Change2ndSizeFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   NULL
 };
 static ObjectFunctionType ChangeThermalFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   ChangeViaThermal,
   NULL,
   NULL,
@@ -173,12 +183,14 @@ static ObjectFunctionType ChangeThermalFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   NULL
 };
 static ObjectFunctionType ChangeClearSizeFunctions = {
   ChangeLineClearSize,
   NULL,
   NULL,
+  NULL,
   ChangeViaClearSize,
   NULL,
   NULL,
@@ -186,6 +198,7 @@ static ObjectFunctionType ChangeClearSizeFunctions = {
   ChangePadClearSize,
   NULL,
   NULL,
+  NULL,
   ChangeArcClearSize,
   NULL
 };
@@ -193,6 +206,7 @@ static ObjectFunctionType ChangeNameFunctions = {
   ChangeLineName,
   ChangeTextName,
   NULL,
+  NULL,
   ChangeViaName,
   ChangeElementName,
   NULL,
@@ -201,6 +215,7 @@ static ObjectFunctionType ChangeNameFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   NULL
 };
 static ObjectFunctionType ChangeSquareFunctions = {
@@ -208,6 +223,7 @@ static ObjectFunctionType ChangeSquareFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   ChangeElementSquare,
   NULL,
   ChangePinSquare,
@@ -215,12 +231,15 @@ static ObjectFunctionType ChangeSquareFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   NULL
 };
 static ObjectFunctionType ChangeJoinFunctions = {
   ChangeLineJoin,
   ChangeTextJoin,
   ChangePolyJoin,
+  ChangePourJoin,
+  NULL,
   NULL,
   NULL,
   NULL,
@@ -235,6 +254,7 @@ static ObjectFunctionType ChangeOctagonFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   ChangeViaOctagon,
   ChangeElementOctagon,
   NULL,
@@ -243,12 +263,14 @@ static ObjectFunctionType ChangeOctagonFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   NULL
 };
 static ObjectFunctionType ChangeMaskSizeFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   ChangeViaMaskSize,
 #if 0
   ChangeElementMaskSize,
@@ -261,6 +283,7 @@ static ObjectFunctionType ChangeMaskSizeFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   NULL
 };
 static ObjectFunctionType SetSquareFunctions = {
@@ -268,6 +291,7 @@ static ObjectFunctionType SetSquareFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   SetElementSquare,
   NULL,
   SetPinSquare,
@@ -275,12 +299,15 @@ static ObjectFunctionType SetSquareFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   NULL
 };
 static ObjectFunctionType SetJoinFunctions = {
   SetLineJoin,
   SetTextJoin,
   SetPolyJoin,
+  SetPourJoin,
+  NULL,
   NULL,
   NULL,
   NULL,
@@ -295,6 +322,7 @@ static ObjectFunctionType SetOctagonFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   SetViaOctagon,
   SetElementOctagon,
   NULL,
@@ -303,6 +331,7 @@ static ObjectFunctionType SetOctagonFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   NULL
 };
 static ObjectFunctionType ClrSquareFunctions = {
@@ -310,6 +339,7 @@ static ObjectFunctionType ClrSquareFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   ClrElementSquare,
   NULL,
   ClrPinSquare,
@@ -317,12 +347,15 @@ static ObjectFunctionType ClrSquareFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   NULL
 };
 static ObjectFunctionType ClrJoinFunctions = {
   ClrLineJoin,
   ClrTextJoin,
   ClrPolyJoin,
+  ClrPourJoin,
+  NULL,
   NULL,
   NULL,
   NULL,
@@ -337,6 +370,7 @@ static ObjectFunctionType ClrOctagonFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   ClrViaOctagon,
   ClrElementOctagon,
   NULL,
@@ -345,6 +379,7 @@ static ObjectFunctionType ClrOctagonFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   NULL
 };
 
@@ -356,14 +391,14 @@ static void *
 ChangeViaThermal (PinTypePtr Via)
 {
   AddObjectToClearPolyUndoList (VIA_TYPE, Via, Via, Via, False);
-  RestoreToPolygon (PCB->Data, VIA_TYPE, CURRENT, Via);
+  RestoreToPours (PCB->Data, VIA_TYPE, CURRENT, Via);
   AddObjectToFlagUndoList (VIA_TYPE, Via, Via, Via);
   if (!Delta)			/* remove the thermals */
     CLEAR_THERM (INDEXOFCURRENT, Via);
   else
     ASSIGN_THERM (INDEXOFCURRENT, Delta, Via);
   AddObjectToClearPolyUndoList (VIA_TYPE, Via, Via, Via, True);
-  ClearFromPolygon (PCB->Data, VIA_TYPE, CURRENT, Via);
+  ClearFromPours (PCB->Data, VIA_TYPE, CURRENT, Via);
   DrawVia (Via, 0);
   return Via;
 }
@@ -376,14 +411,14 @@ static void *
 ChangePinThermal (ElementTypePtr element, PinTypePtr Pin)
 {
   AddObjectToClearPolyUndoList (PIN_TYPE, element, Pin, Pin, False);
-  RestoreToPolygon (PCB->Data, VIA_TYPE, CURRENT, Pin);
+  RestoreToPours (PCB->Data, VIA_TYPE, CURRENT, Pin);
   AddObjectToFlagUndoList (PIN_TYPE, element, Pin, Pin);
   if (!Delta)			/* remove the thermals */
     CLEAR_THERM (INDEXOFCURRENT, Pin);
   else
     ASSIGN_THERM (INDEXOFCURRENT, Delta, Pin);
   AddObjectToClearPolyUndoList (PIN_TYPE, element, Pin, Pin, True);
-  ClearFromPolygon (PCB->Data, VIA_TYPE, CURRENT, Pin);
+  ClearFromPours (PCB->Data, VIA_TYPE, CURRENT, Pin);
   DrawPin (Pin, 0);
   return Pin;
 }
@@ -407,7 +442,7 @@ ChangeViaSize (PinTypePtr Via)
       AddObjectToSizeUndoList (VIA_TYPE, Via, Via, Via);
       EraseVia (Via);
       r_delete_entry (PCB->Data->via_tree, (BoxType *) Via);
-      RestoreToPolygon (PCB->Data, PIN_TYPE, Via, Via);
+      RestoreToPours (PCB->Data, PIN_TYPE, Via, Via);
       if (Via->Mask)
 	{
 	  AddObjectToMaskSizeUndoList (VIA_TYPE, Via, Via, Via);
@@ -416,7 +451,7 @@ ChangeViaSize (PinTypePtr Via)
       Via->Thickness = value;
       SetPinBoundingBox (Via);
       r_insert_entry (PCB->Data->via_tree, (BoxType *) Via, 0);
-      ClearFromPolygon (PCB->Data, VIA_TYPE, Via, Via);
+      ClearFromPours (PCB->Data, VIA_TYPE, Via, Via);
       DrawVia (Via, 0);
       return (Via);
     }
@@ -445,10 +480,10 @@ ChangeVia2ndSize (PinTypePtr Via)
       Via->DrillingHole = value;
       if (TEST_FLAG (HOLEFLAG, Via))
 	{
-	  RestoreToPolygon (PCB->Data, VIA_TYPE, Via, Via);
+	  RestoreToPours (PCB->Data, VIA_TYPE, Via, Via);
 	  AddObjectToSizeUndoList (VIA_TYPE, Via, Via, Via);
 	  Via->Thickness = value;
-	  ClearFromPolygon (PCB->Data, VIA_TYPE, Via, Via);
+	  ClearFromPours (PCB->Data, VIA_TYPE, Via, Via);
 	}
       DrawVia (Via, 0);
       return (Via);
@@ -477,14 +512,14 @@ ChangeViaClearSize (PinTypePtr Via)
     value = PCB->Bloat * 2 + 2;
   if (Via->Clearance == value)
     return NULL;
-  RestoreToPolygon (PCB->Data, VIA_TYPE, Via, Via);
+  RestoreToPours (PCB->Data, VIA_TYPE, Via, Via);
   AddObjectToClearSizeUndoList (VIA_TYPE, Via, Via, Via);
   EraseVia (Via);
   r_delete_entry (PCB->Data->via_tree, (BoxType *) Via);
   Via->Clearance = value;
   SetPinBoundingBox (Via);
   r_insert_entry (PCB->Data->via_tree, (BoxType *) Via, 0);
-  ClearFromPolygon (PCB->Data, VIA_TYPE, Via, Via);
+  ClearFromPours (PCB->Data, VIA_TYPE, Via, Via);
   DrawVia (Via, 0);
   Via->Element = NULL;
   return (Via);
@@ -511,12 +546,12 @@ ChangePinSize (ElementTypePtr Element, PinTypePtr Pin)
       AddObjectToMaskSizeUndoList (PIN_TYPE, Element, Pin, Pin);
       ErasePin (Pin);
       r_delete_entry (PCB->Data->pin_tree, &Pin->BoundingBox);
-      RestoreToPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+      RestoreToPours (PCB->Data, PIN_TYPE, Element, Pin);
       Pin->Mask += value - Pin->Thickness;
       Pin->Thickness = value;
       /* SetElementBB updates all associated rtrees */
       SetElementBoundingBox (PCB->Data, Element, &PCB->Font);
-      ClearFromPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+      ClearFromPours (PCB->Data, PIN_TYPE, Element, Pin);
       DrawPin (Pin, 0);
       return (Pin);
     }
@@ -537,14 +572,14 @@ ChangePinClearSize (ElementTypePtr Element, PinTypePtr Pin)
   value = MIN (MAX_LINESIZE, MAX (value, PCB->Bloat * 2 + 2));
   if (Pin->Clearance == value)
     return NULL;
-  RestoreToPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+  RestoreToPours (PCB->Data, PIN_TYPE, Element, Pin);
   AddObjectToClearSizeUndoList (PIN_TYPE, Element, Pin, Pin);
   ErasePin (Pin);
   r_delete_entry (PCB->Data->pin_tree, &Pin->BoundingBox);
   Pin->Clearance = value;
   /* SetElementBB updates all associated rtrees */
   SetElementBoundingBox (PCB->Data, Element, &PCB->Font);
-  ClearFromPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+  ClearFromPours (PCB->Data, PIN_TYPE, Element, Pin);
   DrawPin (Pin, 0);
   return (Pin);
 }
@@ -564,14 +599,14 @@ ChangePadSize (ElementTypePtr Element, PadTypePtr Pad)
     {
       AddObjectToSizeUndoList (PAD_TYPE, Element, Pad, Pad);
       AddObjectToMaskSizeUndoList (PAD_TYPE, Element, Pad, Pad);
-      RestoreToPolygon (PCB->Data, PAD_TYPE, Element, Pad);
+      RestoreToPours (PCB->Data, PAD_TYPE, Element, Pad);
       ErasePad (Pad);
       r_delete_entry (PCB->Data->pad_tree, &Pad->BoundingBox);
       Pad->Mask += value - Pad->Thickness;
       Pad->Thickness = value;
       /* SetElementBB updates all associated rtrees */
       SetElementBoundingBox (PCB->Data, Element, &PCB->Font);
-      ClearFromPolygon (PCB->Data, PAD_TYPE, Element, Pad);
+      ClearFromPours (PCB->Data, PAD_TYPE, Element, Pad);
       DrawPad (Pad, 0);
       return (Pad);
     }
@@ -593,13 +628,13 @@ ChangePadClearSize (ElementTypePtr Element, PadTypePtr Pad)
   if (value <= MAX_PADSIZE && value >= MIN_PADSIZE && value != Pad->Clearance)
     {
       AddObjectToClearSizeUndoList (PAD_TYPE, Element, Pad, Pad);
-      RestoreToPolygon (PCB->Data, PAD_TYPE, Element, Pad);
+      RestoreToPours (PCB->Data, PAD_TYPE, Element, Pad);
       ErasePad (Pad);
       r_delete_entry (PCB->Data->pad_tree, &Pad->BoundingBox);
       Pad->Clearance = value;
       /* SetElementBB updates all associated rtrees */
       SetElementBoundingBox (PCB->Data, Element, &PCB->Font);
-      ClearFromPolygon (PCB->Data, PAD_TYPE, Element, Pad);
+      ClearFromPours (PCB->Data, PAD_TYPE, Element, Pad);
       DrawPad (Pad, 0);
       return (Pad);
     }
@@ -635,10 +670,10 @@ ChangeElement2ndSize (ElementTypePtr Element)
 	DrawPin (pin, 0);
 	if (TEST_FLAG (HOLEFLAG, pin))
 	  {
-	    RestoreToPolygon (PCB->Data, PIN_TYPE, Element, pin);
+	    RestoreToPours (PCB->Data, PIN_TYPE, Element, pin);
 	    AddObjectToSizeUndoList (PIN_TYPE, Element, pin, pin);
 	    pin->Thickness = value;
-	    ClearFromPolygon (PCB->Data, PIN_TYPE, Element, pin);
+	    ClearFromPours (PCB->Data, PIN_TYPE, Element, pin);
 	  }
       }
   }
@@ -672,10 +707,10 @@ ChangePin2ndSize (ElementTypePtr Element, PinTypePtr Pin)
       DrawPin (Pin, 0);
       if (TEST_FLAG (HOLEFLAG, Pin))
 	{
-	  RestoreToPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+	  RestoreToPours (PCB->Data, PIN_TYPE, Element, Pin);
 	  AddObjectToSizeUndoList (PIN_TYPE, Element, Pin, Pin);
 	  Pin->Thickness = value;
-	  ClearFromPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+	  ClearFromPours (PCB->Data, PIN_TYPE, Element, Pin);
 	}
       return (Pin);
     }
@@ -699,11 +734,11 @@ ChangeLineSize (LayerTypePtr Layer, LineTypePtr Line)
       AddObjectToSizeUndoList (LINE_TYPE, Layer, Line, Line);
       EraseLine (Line);
       r_delete_entry (Layer->line_tree, (BoxTypePtr) Line);
-      RestoreToPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+      RestoreToPours (PCB->Data, LINE_TYPE, Layer, Line);
       Line->Thickness = value;
       SetLineBoundingBox (Line);
       r_insert_entry (Layer->line_tree, (BoxTypePtr) Line, 0);
-      ClearFromPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+      ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
       DrawLine (Layer, Line, 0);
       return (Line);
     }
@@ -725,7 +760,7 @@ ChangeLineClearSize (LayerTypePtr Layer, LineTypePtr Line)
   if (value != Line->Clearance)
     {
       AddObjectToClearSizeUndoList (LINE_TYPE, Layer, Line, Line);
-      RestoreToPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+      RestoreToPours (PCB->Data, LINE_TYPE, Layer, Line);
       EraseLine (Line);
       r_delete_entry (Layer->line_tree, (BoxTypePtr) Line);
       Line->Clearance = value;
@@ -736,7 +771,7 @@ ChangeLineClearSize (LayerTypePtr Layer, LineTypePtr Line)
 	}
       SetLineBoundingBox (Line);
       r_insert_entry (Layer->line_tree, (BoxTypePtr) Line, 0);
-      ClearFromPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+      ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
       DrawLine (Layer, Line, 0);
       return (Line);
     }
@@ -760,11 +795,11 @@ ChangeArcSize (LayerTypePtr Layer, ArcTypePtr Arc)
       AddObjectToSizeUndoList (ARC_TYPE, Layer, Arc, Arc);
       EraseArc (Arc);
       r_delete_entry (Layer->arc_tree, (BoxTypePtr) Arc);
-      RestoreToPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
+      RestoreToPours (PCB->Data, ARC_TYPE, Layer, Arc);
       Arc->Thickness = value;
       SetArcBoundingBox (Arc);
       r_insert_entry (Layer->arc_tree, (BoxTypePtr) Arc, 0);
-      ClearFromPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
+      ClearFromPours (PCB->Data, ARC_TYPE, Layer, Arc);
       DrawArc (Layer, Arc, 0);
       return (Arc);
     }
@@ -788,7 +823,7 @@ ChangeArcClearSize (LayerTypePtr Layer, ArcTypePtr Arc)
       AddObjectToClearSizeUndoList (ARC_TYPE, Layer, Arc, Arc);
       EraseArc (Arc);
       r_delete_entry (Layer->arc_tree, (BoxTypePtr) Arc);
-      RestoreToPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
+      RestoreToPours (PCB->Data, ARC_TYPE, Layer, Arc);
       Arc->Clearance = value;
       if (Arc->Clearance == 0)
 	{
@@ -797,7 +832,7 @@ ChangeArcClearSize (LayerTypePtr Layer, ArcTypePtr Arc)
 	}
       SetArcBoundingBox (Arc);
       r_insert_entry (Layer->arc_tree, (BoxTypePtr) Arc, 0);
-      ClearFromPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
+      ClearFromPours (PCB->Data, ARC_TYPE, Layer, Arc);
       DrawArc (Layer, Arc, 0);
       return (Arc);
     }
@@ -821,11 +856,11 @@ ChangeTextSize (LayerTypePtr Layer, TextTypePtr Text)
       AddObjectToSizeUndoList (TEXT_TYPE, Layer, Text, Text);
       EraseText (Layer, Text);
       r_delete_entry (Layer->text_tree, (BoxTypePtr) Text);
-      RestoreToPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+      RestoreToPours (PCB->Data, TEXT_TYPE, Layer, Text);
       Text->Scale = value;
       SetTextBoundingBox (&PCB->Font, Text);
       r_insert_entry (Layer->text_tree, (BoxTypePtr) Text, 0);
-      ClearFromPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+      ClearFromPours (PCB->Data, TEXT_TYPE, Layer, Text);
       DrawText (Layer, Text, 0);
       return (Text);
     }
@@ -1026,12 +1061,12 @@ ChangeTextName (LayerTypePtr Layer, TextTypePtr Text)
   if (TEST_FLAG (LOCKFLAG, Text))
     return (NULL);
   EraseText (Layer, Text);
-  RestoreToPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+  RestoreToPours (PCB->Data, TEXT_TYPE, Layer, Text);
   Text->TextString = NewName;
 
   /* calculate size of the bounding box */
   SetTextBoundingBox (&PCB->Font, Text);
-  ClearFromPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+  ClearFromPours (PCB->Data, TEXT_TYPE, Layer, Text);
   DrawText (Layer, Text, 0);
   return (old);
 }
@@ -1086,14 +1121,14 @@ ChangeLineJoin (LayerTypePtr Layer, LineTypePtr Line)
   if (TEST_FLAG(CLEARLINEFLAG, Line))
   {
   AddObjectToClearPolyUndoList (LINE_TYPE, Layer, Line, Line, False);
-  RestoreToPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+  RestoreToPours (PCB->Data, LINE_TYPE, Layer, Line);
   }
   AddObjectToFlagUndoList (LINE_TYPE, Layer, Line, Line);
   TOGGLE_FLAG (CLEARLINEFLAG, Line);
   if (TEST_FLAG(CLEARLINEFLAG, Line))
   {
   AddObjectToClearPolyUndoList (LINE_TYPE, Layer, Line, Line, True);
-  ClearFromPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+  ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
   }
   DrawLine (Layer, Line, 0);
   return (Line);
@@ -1132,14 +1167,14 @@ ChangeArcJoin (LayerTypePtr Layer, ArcTypePtr Arc)
   EraseArc (Arc);
   if (TEST_FLAG (CLEARLINEFLAG, Arc))
   {
-    RestoreToPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
+    RestoreToPours (PCB->Data, ARC_TYPE, Layer, Arc);
     AddObjectToClearPolyUndoList (ARC_TYPE, Layer, Arc, Arc, False);
     }
   AddObjectToFlagUndoList (ARC_TYPE, Layer, Arc, Arc);
   TOGGLE_FLAG (CLEARLINEFLAG, Arc);
   if (TEST_FLAG (CLEARLINEFLAG, Arc))
   {
-    ClearFromPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
+    ClearFromPours (PCB->Data, ARC_TYPE, Layer, Arc);
   AddObjectToClearPolyUndoList (ARC_TYPE, Layer, Arc, Arc, True);
   }
   DrawArc (Layer, Arc, 0);
@@ -1180,14 +1215,14 @@ ChangeTextJoin (LayerTypePtr Layer, TextTypePtr Text)
   if (TEST_FLAG(CLEARLINEFLAG, Text))
   {
   AddObjectToClearPolyUndoList (TEXT_TYPE, Layer, Text, Text, False);
-  RestoreToPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+  RestoreToPours (PCB->Data, TEXT_TYPE, Layer, Text);
   }
   AddObjectToFlagUndoList (LINE_TYPE, Layer, Text, Text);
   TOGGLE_FLAG (CLEARLINEFLAG, Text);
   if (TEST_FLAG(CLEARLINEFLAG, Text))
   {
   AddObjectToClearPolyUndoList (TEXT_TYPE, Layer, Text, Text, True);
-  ClearFromPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+  ClearFromPours (PCB->Data, TEXT_TYPE, Layer, Text);
   }
   DrawText (Layer, Text, 0);
   return (Text);
@@ -1205,20 +1240,45 @@ ChangePolyJoin (LayerTypePtr Layer, PolygonTypePtr poly)
   if (TEST_FLAG(CLEARLINEFLAG, poly))
   {
   AddObjectToClearPolyUndoList (POLYGON_TYPE, Layer, poly, poly, False);
-  RestoreToPolygon (PCB->Data, POLYGON_TYPE, Layer, poly);
+  RestoreToPours (PCB->Data, POLYGON_TYPE, Layer, poly);
   }
   AddObjectToFlagUndoList (LINE_TYPE, Layer, poly, poly);
   TOGGLE_FLAG (CLEARLINEFLAG, poly);
   if (TEST_FLAG(CLEARLINEFLAG, poly))
   {
   AddObjectToClearPolyUndoList (POLYGON_TYPE, Layer, poly, poly, True);
-  ClearFromPolygon (PCB->Data, POLYGON_TYPE, Layer, poly);
+  ClearFromPours (PCB->Data, POLYGON_TYPE, Layer, poly);
   }
   DrawPolygon (Layer, poly, 0);
   return (poly);
 }
 
 /* ---------------------------------------------------------------------------
+ * changes the clearance flag of a pour
+ */
+static void *
+ChangePourJoin (LayerTypePtr Layer, PourTypePtr pour)
+{
+  if (TEST_FLAG (LOCKFLAG, pour))
+    return (NULL);
+  ErasePour (pour);
+  if (TEST_FLAG(CLEARLINEFLAG, pour))
+  {
+  AddObjectToClearPourUndoList (POLYGON_TYPE, Layer, pour, pour, False);
+  RestoreToPours (PCB->Data, POLYGON_TYPE, Layer, pour);
+  }
+  AddObjectToFlagUndoList (LINE_TYPE, Layer, pour, pour);
+  TOGGLE_FLAG (CLEARLINEFLAG, pour);
+  if (TEST_FLAG(CLEARLINEFLAG, pour))
+  {
+  AddObjectToClearPourUndoList (POLYGON_TYPE, Layer, pour, pour, True);
+  ClearFromPours (PCB->Data, POLYGON_TYPE, Layer, pour);
+  }
+  DrawPour (Layer, pour, 0);
+  return (pour);
+}
+
+/* ---------------------------------------------------------------------------
  * sets the clearance flag of a text
  */
 static void *
@@ -1241,6 +1301,17 @@ SetPolyJoin (LayerTypePtr Layer, PolygonTypePtr poly)
 }
 
 /* ---------------------------------------------------------------------------
+ * sets the clearance flag of a pour
+ */
+static void *
+SetPourJoin (LayerTypePtr Layer, PourTypePtr pour)
+{
+  if (TEST_FLAG (LOCKFLAG, pour) || TEST_FLAG (CLEARLINEFLAG, pour))
+    return (NULL);
+  return ChangePourJoin (Layer, pour);
+}
+
+/* ---------------------------------------------------------------------------
  * clears the clearance flag of a text
  */
 static void *
@@ -1263,6 +1334,17 @@ ClrPolyJoin (LayerTypePtr Layer, PolygonTypePtr poly)
 }
 
 /* ---------------------------------------------------------------------------
+ * clears the clearance flag of a pour
+ */
+static void *
+ClrPourJoin (LayerTypePtr Layer, PourTypePtr pour)
+{
+  if (TEST_FLAG (LOCKFLAG, pour) || !TEST_FLAG (CLEARLINEFLAG, pour))
+    return (NULL);
+  return ChangePourJoin (Layer, pour);
+}
+
+/* ---------------------------------------------------------------------------
  * changes the square flag of all pins on an element
  */
 static void *
@@ -1398,11 +1480,11 @@ ChangePadSquare (ElementTypePtr Element, PadTypePtr Pad)
     return (NULL);
   ErasePad (Pad);
   AddObjectToClearPolyUndoList (PAD_TYPE, Element, Pad, Pad, False);
-  RestoreToPolygon (PCB->Data, PAD_TYPE, Element, Pad);
+  RestoreToPours (PCB->Data, PAD_TYPE, Element, Pad);
   AddObjectToFlagUndoList (PAD_TYPE, Element, Pad, Pad);
   TOGGLE_FLAG (SQUAREFLAG, Pad);
   AddObjectToClearPolyUndoList (PAD_TYPE, Element, Pad, Pad, True);
-  ClearFromPolygon (PCB->Data, PAD_TYPE, Element, Pad);
+  ClearFromPours (PCB->Data, PAD_TYPE, Element, Pad);
   DrawPad (Pad, 0);
   return (Pad);
 }
@@ -1445,11 +1527,11 @@ ChangePinSquare (ElementTypePtr Element, PinTypePtr Pin)
     return (NULL);
   ErasePin (Pin);
   AddObjectToClearPolyUndoList (PIN_TYPE, Element, Pin, Pin, False);
-  RestoreToPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+  RestoreToPours (PCB->Data, PIN_TYPE, Element, Pin);
   AddObjectToFlagUndoList (PIN_TYPE, Element, Pin, Pin);
   TOGGLE_FLAG (SQUAREFLAG, Pin);
   AddObjectToClearPolyUndoList (PIN_TYPE, Element, Pin, Pin, True);
-  ClearFromPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+  ClearFromPours (PCB->Data, PIN_TYPE, Element, Pin);
   DrawPin (Pin, 0);
   return (Pin);
 }
@@ -1488,11 +1570,11 @@ ChangeViaOctagon (PinTypePtr Via)
     return (NULL);
   EraseVia (Via);
   AddObjectToClearPolyUndoList (VIA_TYPE, Via, Via, Via, False);
-  RestoreToPolygon (PCB->Data, VIA_TYPE, Via, Via);
+  RestoreToPours (PCB->Data, VIA_TYPE, Via, Via);
   AddObjectToFlagUndoList (VIA_TYPE, Via, Via, Via);
   TOGGLE_FLAG (OCTAGONFLAG, Via);
   AddObjectToClearPolyUndoList (VIA_TYPE, Via, Via, Via, True);
-  ClearFromPolygon (PCB->Data, VIA_TYPE, Via, Via);
+  ClearFromPours (PCB->Data, VIA_TYPE, Via, Via);
   DrawVia (Via, 0);
   return (Via);
 }
@@ -1531,11 +1613,11 @@ ChangePinOctagon (ElementTypePtr Element, PinTypePtr Pin)
     return (NULL);
   ErasePin (Pin);
   AddObjectToClearPolyUndoList (PIN_TYPE, Element, Pin, Pin, False);
-  RestoreToPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+  RestoreToPours (PCB->Data, PIN_TYPE, Element, Pin);
   AddObjectToFlagUndoList (PIN_TYPE, Element, Pin, Pin);
   TOGGLE_FLAG (OCTAGONFLAG, Pin);
   AddObjectToClearPolyUndoList (PIN_TYPE, Element, Pin, Pin, True);
-  ClearFromPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+  ClearFromPours (PCB->Data, PIN_TYPE, Element, Pin);
   DrawPin (Pin, 0);
   return (Pin);
 }
@@ -1577,10 +1659,10 @@ ChangeHole (PinTypePtr Via)
   TOGGLE_FLAG (HOLEFLAG, Via);
   if (TEST_FLAG (HOLEFLAG, Via))
     {
-      RestoreToPolygon (PCB->Data, VIA_TYPE, Via, Via);
+      RestoreToPours (PCB->Data, VIA_TYPE, Via, Via);
       AddObjectToSizeUndoList (VIA_TYPE, Via, Via, Via);
       Via->Thickness = Via->Mask = Via->DrillingHole;
-      ClearFromPolygon (PCB->Data, VIA_TYPE, Via, Via);
+      ClearFromPours (PCB->Data, VIA_TYPE, Via, Via);
     }
   else
     {
@@ -1624,6 +1706,22 @@ ChangePolyClear (LayerTypePtr Layer, PolygonTypePtr Polygon)
   return (Polygon);
 }
 
+/* ---------------------------------------------------------------------------
+ * changes the CLEARPOLY flag of a pour
+ */
+static void *
+ChangePourClear (LayerTypePtr Layer, PourTypePtr Pour)
+{
+  if (TEST_FLAG (LOCKFLAG, Pour))
+    return (NULL);
+  AddObjectToClearPourUndoList (POLYGON_TYPE, Layer, Pour, Pour, True);
+  AddObjectToFlagUndoList (POLYGON_TYPE, Layer, Pour, Pour);
+  TOGGLE_FLAG (CLEARPOLYFLAG, Pour);
+  InitPourClip (PCB->Data, Layer, Pour);
+  DrawPour (Layer, Pour, 0);
+  return (Pour);
+}
+
 /* ----------------------------------------------------------------------
  * changes the side of all selected and visible elements 
  * returns True if anything has changed
diff --git a/src/const.h b/src/const.h
index 3647c3b..c2fa83b 100644
--- a/src/const.h
+++ b/src/const.h
@@ -78,7 +78,8 @@
 #define	VIA_MODE		1	/* draw vias */
 #define	LINE_MODE		2	/* draw lines */
 #define	RECTANGLE_MODE		3	/* create rectangles */
-#define	POLYGON_MODE		4	/* draw filled polygons */
+//#define	POLYGON_MODE		4	/* draw filled polygons */
+#define	POUR_MODE		4	/* draw poured areas */
 #define	PASTEBUFFER_MODE	5	/* paste objects from buffer */
 #define	TEXT_MODE		6	/* create text objects */
 #define	ROTATE_MODE		102	/* rotate objects */
@@ -303,10 +304,13 @@ New polygons are full ones.
 #define ELEMENTARC_TYPE		0x08000
 
 #define LOCKED_TYPE 		0x10000	/* used to tell search to include locked items. */
+#define POUR_TYPE 		0x20000
+#define POURPOINT_TYPE 		0x40000
 
 #define PIN_TYPES     (VIA_TYPE | PIN_TYPE)
-#define LOCK_TYPES    (VIA_TYPE | LINE_TYPE | ARC_TYPE | POLYGON_TYPE | ELEMENT_TYPE \
-                      | TEXT_TYPE | ELEMENTNAME_TYPE | LOCKED_TYPE)
+#define LOCK_TYPES    (VIA_TYPE | LINE_TYPE | ARC_TYPE | POLYGON_TYPE | \
+                       POUR_TYPE | ELEMENT_TYPE | \
+                       TEXT_TYPE | ELEMENTNAME_TYPE | LOCKED_TYPE)
 
 #define	ALL_TYPES		(~0)	/* all bits set */
 
diff --git a/src/copy.c b/src/copy.c
index 5a030c9..f9c2dfa 100644
--- a/src/copy.c
+++ b/src/copy.c
@@ -47,7 +47,7 @@
 #include "mirror.h"
 #include "misc.h"
 #include "move.h"
-#include "polygon.h"
+#include "pour.h"
 #include "rats.h"
 #include "rtree.h"
 #include "select.h"
@@ -66,7 +66,8 @@ static void *CopyVia (PinTypePtr);
 static void *CopyLine (LayerTypePtr, LineTypePtr);
 static void *CopyArc (LayerTypePtr, ArcTypePtr);
 static void *CopyText (LayerTypePtr, TextTypePtr);
-static void *CopyPolygon (LayerTypePtr, PolygonTypePtr);
+//static void *CopyPolygon (LayerTypePtr, PolygonTypePtr);
+static void *CopyPour (LayerTypePtr, PourTypePtr);
 static void *CopyElement (ElementTypePtr);
 
 /* ---------------------------------------------------------------------------
@@ -76,7 +77,9 @@ static LocationType DeltaX, DeltaY;	/* movement vector */
 static ObjectFunctionType CopyFunctions = {
   CopyLine,
   CopyText,
-  CopyPolygon,
+#warning FIXME Later
+  NULL, //CopyPolygon,
+  CopyPour,
   CopyVia,
   CopyElement,
   NULL,
@@ -84,10 +87,13 @@ static ObjectFunctionType CopyFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   CopyArc,
   NULL
 };
 
+#warning FIXME Later
+#if 0
 /* ---------------------------------------------------------------------------
  * copies data from one polygon to another
  * 'Dest' has to exist
@@ -106,6 +112,26 @@ CopyPolygonLowLevel (PolygonTypePtr Dest, PolygonTypePtr Src)
   CLEAR_FLAG (FOUNDFLAG, Dest);
   return (Dest);
 }
+#endif
+
+/* ---------------------------------------------------------------------------
+ * copies data from one pour to another
+ * 'Dest' has to exist
+ */
+PourTypePtr
+CopyPourLowLevel (PourTypePtr Dest, PourTypePtr Src)
+{
+  /* copy all data */
+  POURPOINT_LOOP (Src);
+  {
+    CreateNewPointInPour (Dest, point->X, point->Y);
+  }
+  END_LOOP;
+  SetPourBoundingBox (Dest);
+  Dest->Flags = Src->Flags;
+  CLEAR_FLAG (FOUNDFLAG, Dest);
+  return (Dest);
+}
 
 /* ---------------------------------------------------------------------------
  * copies data from one element to another and creates the destination 
@@ -256,6 +282,8 @@ CopyText (LayerTypePtr Layer, TextTypePtr Text)
   return (text);
 }
 
+#warning FIXME Later
+#if 0
 /* ---------------------------------------------------------------------------
  * copies a polygon 
  */
@@ -275,6 +303,27 @@ CopyPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
   AddObjectToCreateUndoList (POLYGON_TYPE, Layer, polygon, polygon);
   return (polygon);
 }
+#endif
+
+/* ---------------------------------------------------------------------------
+ * copies a pour
+ */
+static void *
+CopyPour (LayerTypePtr Layer, PourTypePtr Pour)
+{
+  PourTypePtr pour;
+
+  pour = CreateNewPour (Layer, NoFlags ());
+  CopyPourLowLevel (pour, Pour);
+  MovePourLowLevel (pour, DeltaX, DeltaY);
+  if (!Layer->pour_tree)
+    Layer->pour_tree = r_create_tree (NULL, 0, 0);
+  r_insert_entry (Layer->pour_tree, (BoxTypePtr) pour, 0);
+  InitPourClip (PCB->Data, Layer, pour);
+  DrawPour (Layer, pour, 0);
+  AddObjectToCreateUndoList (POUR_TYPE, Layer, pour, pour);
+  return (pour);
+}
 
 /* ---------------------------------------------------------------------------
  * copies a element 
@@ -329,7 +378,7 @@ CopyPastebufferToLayout (LocationType X, LocationType Y)
 	  changed = changed ||
 	    (sourcelayer->LineN != 0) ||
 	    (sourcelayer->ArcN != 0) ||
-	    (sourcelayer->PolygonN != 0) || (sourcelayer->TextN != 0);
+	    (sourcelayer->PourN != 0) || (sourcelayer->TextN != 0);
 	  LINE_LOOP (sourcelayer);
 	  {
 	    CopyLine (destlayer, line);
@@ -345,11 +394,19 @@ CopyPastebufferToLayout (LocationType X, LocationType Y)
 	    CopyText (destlayer, text);
 	  }
 	  END_LOOP;
+#warning FIXME Later
+#if 0
 	  POLYGON_LOOP (sourcelayer);
 	  {
 	    CopyPolygon (destlayer, polygon);
 	  }
 	  END_LOOP;
+#endif
+	  POUR_LOOP (sourcelayer);
+	  {
+	    CopyPour (destlayer, pour);
+	  }
+	  END_LOOP;
 	}
     }
 
diff --git a/src/copy.h b/src/copy.h
index 472fc75..9c9fb74 100644
--- a/src/copy.h
+++ b/src/copy.h
@@ -42,6 +42,7 @@
 
 
 PolygonTypePtr CopyPolygonLowLevel (PolygonTypePtr, PolygonTypePtr);
+PourTypePtr CopyPourLowLevel (PourTypePtr, PourTypePtr);
 ElementTypePtr CopyElementLowLevel (DataTypePtr, ElementTypePtr,
 				    ElementTypePtr, Boolean, LocationType, LocationType);
 Boolean CopyPastebufferToLayout (LocationType, LocationType);
diff --git a/src/create.c b/src/create.c
index bbfd52f..e6a0abd 100644
--- a/src/create.c
+++ b/src/create.c
@@ -535,29 +535,28 @@ CreateNewArcOnLayer (LayerTypePtr Layer,
   return (Arc);
 }
 
-
 /* ---------------------------------------------------------------------------
- * creates a new polygon from the old formats rectangle data
+ * creates a new pour from the old formats rectangle data
  */
-PolygonTypePtr
-CreateNewPolygonFromRectangle (LayerTypePtr Layer,
+PourTypePtr
+CreateNewPourFromRectangle (LayerTypePtr Layer,
 			       LocationType X1, LocationType Y1,
 			       LocationType X2, LocationType Y2,
 			       FlagType Flags)
 {
-  PolygonTypePtr polygon = CreateNewPolygon (Layer, Flags);
-  if (!polygon)
-    return (polygon);
-
-  CreateNewPointInPolygon (polygon, X1, Y1);
-  CreateNewPointInPolygon (polygon, X2, Y1);
-  CreateNewPointInPolygon (polygon, X2, Y2);
-  CreateNewPointInPolygon (polygon, X1, Y2);
-  SetPolygonBoundingBox (polygon);
-  if (!Layer->polygon_tree)
-    Layer->polygon_tree = r_create_tree (NULL, 0, 0);
-  r_insert_entry (Layer->polygon_tree, (BoxTypePtr) polygon, 0);
-  return (polygon);
+  PourTypePtr pour = CreateNewPour (Layer, Flags);
+  if (!pour)
+    return (pour);
+
+  CreateNewPointInPour (pour, X1, Y1);
+  CreateNewPointInPour (pour, X2, Y1);
+  CreateNewPointInPour (pour, X2, Y2);
+  CreateNewPointInPour (pour, X1, Y2);
+  SetPourBoundingBox (pour);
+  if (!Layer->pour_tree)
+    Layer->pour_tree = r_create_tree (NULL, 0, 0);
+  r_insert_entry (Layer->pour_tree, (BoxTypePtr) pour, 0);
+  return (pour);
 }
 
 /* ---------------------------------------------------------------------------
@@ -595,9 +594,9 @@ CreateNewText (LayerTypePtr Layer, FontTypePtr PCBFont,
  * creates a new polygon on a layer
  */
 PolygonTypePtr
-CreateNewPolygon (LayerTypePtr Layer, FlagType Flags)
+CreateNewPolygonInPour (PourType *pour, FlagType Flags)
 {
-  PolygonTypePtr polygon = GetPolygonMemory (Layer);
+  PolygonTypePtr polygon = GetPolygonMemoryInPour (pour);
 
   /* copy values */
   polygon->Flags = Flags;
@@ -605,17 +604,40 @@ CreateNewPolygon (LayerTypePtr Layer, FlagType Flags)
   polygon->Clipped = NULL;
   polygon->NoHoles = NULL;
   polygon->NoHolesValid = 0;
+  polygon->ParentPour = pour;
   return (polygon);
 }
 
 /* ---------------------------------------------------------------------------
- * creates a new point in a polygon
+ * creates a new pour on a layer
+ */
+PourTypePtr
+CreateNewPour (LayerTypePtr Layer, FlagType Flags)
+{
+  PourTypePtr pour = GetPourMemory (Layer);
+
+  /* copy values */
+  pour->Flags = Flags;
+  pour->ID = ID++;
+
+  pour->PointN = 0;
+  pour->PointMax = 0;
+  pour->Points = NULL;
+  pour->PolygonN = 0;
+  pour->PolygonMax = 0;
+  pour->Polygons = NULL;
+
+  return (pour);
+}
+
+/* ---------------------------------------------------------------------------
+ * creates a new point in a pour
  */
 PointTypePtr
-CreateNewPointInPolygon (PolygonTypePtr Polygon, LocationType X,
+CreateNewPointInPour (PourTypePtr Pour, LocationType X,
 			 LocationType Y)
 {
-  PointTypePtr point = GetPointMemoryInPolygon (Polygon);
+  PointTypePtr point = GetPointMemoryInPour (Pour);
 
   /* copy values */
   point->X = X;
diff --git a/src/create.h b/src/create.h
index 98bb525..644b53e 100644
--- a/src/create.h
+++ b/src/create.h
@@ -54,13 +54,14 @@ RatTypePtr CreateNewRat (DataTypePtr, LocationType, LocationType,
 ArcTypePtr CreateNewArcOnLayer (LayerTypePtr, LocationType, LocationType,
 				BDimension, BDimension, int, int, BDimension, BDimension,
 				FlagType);
-PolygonTypePtr CreateNewPolygonFromRectangle (LayerTypePtr, LocationType,
+PourTypePtr CreateNewPourFromRectangle (LayerTypePtr, LocationType,
 					      LocationType, LocationType,
 					      LocationType, FlagType);
 TextTypePtr CreateNewText (LayerTypePtr, FontTypePtr, LocationType,
 			   LocationType, BYTE, int, char *, FlagType);
-PolygonTypePtr CreateNewPolygon (LayerTypePtr, FlagType);
-PointTypePtr CreateNewPointInPolygon (PolygonTypePtr,
+PolygonTypePtr CreateNewPolygonInPour (PourType *pour, FlagType);
+PourTypePtr CreateNewPour (LayerTypePtr, FlagType);
+PointTypePtr CreateNewPointInPour (PourTypePtr,
 				      LocationType, LocationType);
 void RefdesMapInit (void);
 ElementTypePtr CreateNewElement (DataTypePtr, ElementTypePtr,
diff --git a/src/crosshair.c b/src/crosshair.c
index 962253d..2cf6824 100644
--- a/src/crosshair.c
+++ b/src/crosshair.c
@@ -76,6 +76,7 @@ static int CrosshairStackLocation = 0;
  * some local prototypes
  */
 static void XORPolygon (PolygonTypePtr, LocationType, LocationType);
+static void XORPour (PourTypePtr, LocationType, LocationType);
 static void XORDrawElement (ElementTypePtr, LocationType, LocationType);
 static void XORDrawBuffer (BufferTypePtr);
 static void XORDrawInsertPointObject (void);
@@ -91,6 +92,8 @@ static void XORDrawAttachedArc (BDimension);
 static void
 XORPolygon (PolygonTypePtr polygon, LocationType dx, LocationType dy)
 {
+#warning FIXME Later
+#if 0
   int i;
   for (i = 0; i < polygon->PointN - 1; i++)
     gui->draw_line (Crosshair.GC,
@@ -101,6 +104,25 @@ XORPolygon (PolygonTypePtr polygon, LocationType dx, LocationType dy)
     gui->draw_line (Crosshair.GC,
 		    polygon->Points[i].X + dx, polygon->Points[i].Y + dy,
 		    polygon->Points[0].X + dx, polygon->Points[0].Y + dy);
+#endif
+}
+
+/* ---------------------------------------------------------------------------
+ * creates a tmp pour with coordinates converted to screen system
+ */
+static void
+XORPour (PourTypePtr pour, LocationType dx, LocationType dy)
+{
+  int i;
+  for (i = 0; i < pour->PointN - 1; i++)
+    gui->draw_line (Crosshair.GC,
+		    pour->Points[i].X + dx, pour->Points[i].Y + dy,
+		    pour->Points[i + 1].X + dx,
+		    pour->Points[i + 1].Y + dy);
+  if (i > 1)
+    gui->draw_line (Crosshair.GC,
+		    pour->Points[i].X + dx, pour->Points[i].Y + dy,
+		    pour->Points[0].X + dx, pour->Points[0].Y + dy);
 }
 
 /*-----------------------------------------------------------
@@ -348,9 +370,11 @@ XORDrawBuffer (BufferTypePtr Buffer)
 	/* the tmp polygon has n+1 points because the first
 	 * and the last one are set to the same coordinates
 	 */
-	POLYGON_LOOP (layer);
+	POUR_LOOP (layer);
 	{
-	  XORPolygon (polygon, x, y);
+	  XORPour (pour, x, y);
+#warning FIXME Later
+//	  XORPolygon (polygon, x, y);
 	}
 	END_LOOP;
       }
@@ -450,6 +474,18 @@ XORDrawMoveOrCopyObject (void)
 	break;
       }
 
+    case POUR_TYPE:
+      {
+	PourTypePtr pour =
+	  (PourTypePtr) Crosshair.AttachedObject.Ptr2;
+
+	/* the tmp pour has n+1 points because the first
+	 * and the last one are set to the same coordinates
+	 */
+	XORPour (pour, dx, dy);
+	break;
+      }
+
     case LINEPOINT_TYPE:
       {
 	LineTypePtr line;
@@ -468,6 +504,8 @@ XORDrawMoveOrCopyObject (void)
 	break;
       }
 
+#warning FIXME Later
+#if 0
     case POLYGONPOINT_TYPE:
       {
 	PolygonTypePtr polygon;
@@ -502,6 +540,42 @@ XORDrawMoveOrCopyObject (void)
 			point->Y + dy, following->X, following->Y);
 	break;
       }
+#endif
+
+    case POURPOINT_TYPE:
+      {
+	PourTypePtr pour;
+	PointTypePtr point, previous, following;
+
+	pour = (PourTypePtr) Crosshair.AttachedObject.Ptr2;
+	point = (PointTypePtr) Crosshair.AttachedObject.Ptr3;
+
+	/* get previous and following point */
+	if (point == pour->Points)
+	  {
+	    previous = &pour->Points[pour->PointN - 1];
+	    following = point + 1;
+	  }
+	else if (point == &pour->Points[pour->PointN - 1])
+	  {
+	    previous = point - 1;
+	    following = &pour->Points[0];
+	  }
+	else
+	  {
+	    previous = point - 1;
+	    following = point + 1;
+	  }
+
+	/* draw the two segments */
+	gui->draw_line (Crosshair.GC,
+			previous->X,
+			previous->Y, point->X + dx, point->Y + dy);
+	gui->draw_line (Crosshair.GC,
+			point->X + dx,
+			point->Y + dy, following->X, following->Y);
+	break;
+      }
 
     case ELEMENTNAME_TYPE:
       {
@@ -596,8 +670,8 @@ DrawAttached (Boolean BlockToo)
 	}
       break;
 
-      /* the attached line is used by both LINEMODE and POLYGON_MODE */
-    case POLYGON_MODE:
+      /* the attached line is used by both LINEMODE and POUR_MODE */
+    case POUR_MODE:
       /* draw only if starting point is set */
       if (Crosshair.AttachedLine.State != STATE_FIRST)
 	gui->draw_line (Crosshair.GC,
@@ -606,10 +680,10 @@ DrawAttached (Boolean BlockToo)
 			Crosshair.AttachedLine.Point2.X,
 			Crosshair.AttachedLine.Point2.Y);
 
-      /* draw attached polygon only if in POLYGON_MODE */
-      if (Crosshair.AttachedPolygon.PointN > 1)
+      /* draw attached pour only if in POUR_MODE */
+      if (Crosshair.AttachedPour.PointN > 1)
 	{
-	  XORPolygon (&Crosshair.AttachedPolygon, 0, 0);
+	  XORPour (&Crosshair.AttachedPour, 0, 0);
 	}
       break;
 
@@ -1111,6 +1185,6 @@ void
 DestroyCrosshair (void)
 {
   CrosshairOff (True);
-  FreePolygonMemory (&Crosshair.AttachedPolygon);
+  FreePourMemory (&Crosshair.AttachedPour);
   gui->destroy_gc (Crosshair.GC);
 }
diff --git a/src/draw.c b/src/draw.c
index 0388f55..c796c29 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -101,6 +101,7 @@ static void DrawPadNameLowLevel (PadTypePtr);
 static void DrawLineLowLevel (LineTypePtr, Boolean);
 static void DrawRegularText (LayerTypePtr, TextTypePtr, int);
 static void DrawPolygonLowLevel (PolygonTypePtr, void *);
+static void DrawPourLowLevel (PourTypePtr, void *);
 static void DrawArcLowLevel (ArcTypePtr);
 static void DrawElementPackageLowLevel (ElementTypePtr Element, int);
 static void DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon);
@@ -683,6 +684,7 @@ clearPin_callback (const BoxType * b, void *cl)
     ClearOnlyPin (pin, True);
   return 1;
 }
+
 static int
 poly_callback (const BoxType * b, void *cl)
 {
@@ -693,6 +695,16 @@ poly_callback (const BoxType * b, void *cl)
 }
 
 static int
+pour_callback (const BoxType * b, void *cl)
+{
+  struct pin_info *i = (struct pin_info *) cl;
+
+//  DrawPlainPour (i->Layer, (PourTypePtr) b);
+  DrawPour (i->Layer, (PourTypePtr)b, 0);
+  return 1;
+}
+
+static int
 clearPad_callback (const BoxType * b, void *cl)
 {
   PadTypePtr pad = (PadTypePtr) b;
@@ -891,6 +903,8 @@ DrawLayer (LayerTypePtr Layer, BoxType * screen)
   clip_box = screen;
   r_search (Layer->polygon_tree, screen, NULL, poly_callback, &info);
 
+  r_search (Layer->pour_tree, screen, NULL, pour_callback, &info);
+
   /* draw all visible lines this layer */
   r_search (Layer->line_tree, screen, NULL, line_callback, Layer);
 
@@ -944,7 +958,7 @@ DrawLayerGroup (int group, const BoxType * screen)
 #endif
 
 	  /* draw all polygons on this layer */
-	  if (Layer->PolygonN)
+	  if (Layer->polygon_tree)
 	    {
 	      info.Layer = Layer;
 	      info.arg = True;
@@ -953,6 +967,15 @@ DrawLayerGroup (int group, const BoxType * screen)
 	      info.arg = False;
 	    }
 
+	  /* draw all pours on this layer */
+	  if (Layer->PourN)
+	    {
+	      info.Layer = Layer;
+	      info.arg = True;
+	      r_search (Layer->pour_tree, screen, NULL, pour_callback, &info);
+	      info.arg = False;
+	    }
+
 	  if (TEST_FLAG (CHECKPLANESFLAG, PCB))
 	    continue;
 
@@ -1771,6 +1794,49 @@ DrawPolygonLowLevel (PolygonTypePtr Polygon, void *data)
 }
 
 /* ---------------------------------------------------------------------------
+ * lowlevel drawing routine for pours
+ */
+static void
+DrawPourLowLevel (PourTypePtr Pour, void *data)
+{
+  int *x, *y, n, i;
+
+  if (Gathering)
+    {
+      AddPart (Pour);
+      return;
+    }
+
+  n = Pour->PointN;
+  x = (int *) malloc (n * sizeof (int));
+  y = (int *) malloc (n * sizeof (int));
+  for (i = 0; i < n; i++)
+    {
+      x[i] = Pour->Points[i].X;
+      y[i] = Pour->Points[i].Y;
+    }
+
+//  if (TEST_FLAG (THINDRAWFLAG, PCB) ||
+//      TEST_FLAG (THINDRAWPOLYFLAG, PCB) ||
+//      TEST_FLAG (CLEARLINEFLAG, Pour))
+  if (1)
+    {
+      gui->set_line_width (Output.fgGC, 2);
+//      gui->set_line_width (Output.fgGC, 1);
+      for (i = 0; i < n - 1; i++)
+	{
+	  gui->draw_line (Output.fgGC, x[i], y[i], x[i + 1], y[i + 1]);
+	  gui->fill_circle (Output.fgGC, x[i], y[i], 30);
+	}
+      gui->draw_line (Output.fgGC, x[n - 1], y[n - 1], x[0], y[0]);
+    }
+  else
+    gui->fill_polygon (Output.fgGC, n, x, y);
+  free (x);
+  free (y);
+}
+
+/* ---------------------------------------------------------------------------
  * lowlevel routine to element arcs
  */
 static void
@@ -2121,6 +2187,37 @@ DrawPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon, int unused)
     }
 }
 
+/* ---------------------------------------------------------------------------
+ * draws a pour on a layer
+ */
+void
+DrawPour (LayerTypePtr Layer, PourTypePtr Pour, int unused)
+{
+  int layernum;
+
+  if (TEST_FLAG (SELECTEDFLAG | FOUNDFLAG, Pour))
+    {
+      if (TEST_FLAG (SELECTEDFLAG, Pour))
+	gui->set_color (Output.fgGC, Layer->SelectedColor);
+      else
+	gui->set_color (Output.fgGC, PCB->ConnectedColor);
+    }
+  else
+    gui->set_color (Output.fgGC, Layer->Color);
+  layernum = GetLayerNumber (PCB->Data, Layer);
+  DrawPourLowLevel (Pour, NULL);
+#warning FIXME Later
+#if 0
+  if (TEST_FLAG (CLEARPOLYFLAG, Pour))
+    {
+      r_search (PCB->Data->pin_tree, &Pour->BoundingBox, NULL,
+		cp_callback, (void *) PIN_TYPE);
+      r_search (PCB->Data->via_tree, &Pour->BoundingBox, NULL,
+		cp_callback, (void *) VIA_TYPE);
+    }
+#endif
+}
+
 int
 thin_callback (PLINE * pl, LayerTypePtr lay, PolygonTypePtr poly)
 {
@@ -2522,6 +2619,18 @@ ErasePolygon (PolygonTypePtr Polygon)
 }
 
 /* ---------------------------------------------------------------------------
+ * erases a pour on a layer
+ */
+void
+ErasePour (PourTypePtr Pour)
+{
+  Erasing++;
+  gui->set_color (Output.fgGC, Settings.BackgroundColor);
+  DrawPourLowLevel (Pour, NULL);
+  Erasing--;
+}
+
+/* ---------------------------------------------------------------------------
  * erases an element
  */
 void
diff --git a/src/draw.h b/src/draw.h
index 47c4c7f..a0f423c 100644
--- a/src/draw.h
+++ b/src/draw.h
@@ -51,6 +51,7 @@ void DrawArc (LayerTypePtr, ArcTypePtr, int);
 void DrawText (LayerTypePtr, TextTypePtr, int);
 void DrawTextLowLevel (TextTypePtr, int);
 void DrawPolygon (LayerTypePtr, PolygonTypePtr, int);
+void DrawPour (LayerTypePtr, PourTypePtr, int);
 void DrawElement (ElementTypePtr, int);
 void DrawElementName (ElementTypePtr, int);
 void DrawElementPackage (ElementTypePtr, int);
@@ -68,6 +69,7 @@ void EraseLine (LineTypePtr);
 void EraseArc (ArcTypePtr);
 void EraseText (LayerTypePtr, TextTypePtr);
 void ErasePolygon (PolygonTypePtr);
+void ErasePour (PourTypePtr);
 void EraseElement (ElementTypePtr);
 void EraseElementPinsAndPads (ElementTypePtr);
 void EraseElementName (ElementTypePtr);
diff --git a/src/file.c b/src/file.c
index 653e1db..57d8b48 100644
--- a/src/file.c
+++ b/src/file.c
@@ -778,7 +778,7 @@ WriteLayerData (FILE * FP, Cardinal Number, LayerTypePtr layer)
 {
   int n;
   /* write information about non empty layers */
-  if (layer->LineN || layer->ArcN || layer->TextN || layer->PolygonN ||
+  if (layer->LineN || layer->ArcN || layer->TextN || layer->PourN ||
       (layer->Name && *layer->Name))
     {
       fprintf (FP, "Layer(%i ", (int) Number + 1);
@@ -812,6 +812,8 @@ WriteLayerData (FILE * FP, Cardinal Number, LayerTypePtr layer)
 	  PrintQuotedString (FP, EMPTY (text->TextString));
 	  fprintf (FP, " %s]\n", F2S (text, TEXT_TYPE));
 	}
+#warning FIXME Later
+#if 0
       for (n = 0; n < layer->PolygonN; n++)
 	{
 	  PolygonTypePtr polygon = &layer->Polygon[n];
@@ -826,6 +828,21 @@ WriteLayerData (FILE * FP, Cardinal Number, LayerTypePtr layer)
 	    }
 	  fputs ("\n\t)\n", FP);
 	}
+#endif
+      for (n = 0; n < layer->PourN; n++)
+	{
+	  PourTypePtr pour = &layer->Pour[n];
+	  int p, i = 0;
+	  fprintf (FP, "\tPolygon(%s)\n\t(", F2S (pour, POUR_TYPE));
+	  for (p = 0; p < pour->PointN; p++)
+	    {
+	      PointTypePtr point = &pour->Points[p];
+	      if (i++ % 5 == 0)
+		fputs ("\n\t\t", FP);
+	      fprintf (FP, "[%i %i] ", (int) point->X, (int) point->Y);
+	    }
+	  fputs ("\n\t)\n", FP);
+	}
       fputs (")\n", FP);
     }
 }
diff --git a/src/find.c b/src/find.c
index edf2f7e..ee40a96 100644
--- a/src/find.c
+++ b/src/find.c
@@ -540,6 +540,7 @@ void
 InitLayoutLookup (void)
 {
   Cardinal i;
+  int polycount;
 
   /* initialize line arc and polygon data */
   for (i = 0; i < max_layer; i++)
@@ -564,12 +565,18 @@ InitLayoutLookup (void)
 
 
       /* allocate memory for polygon list */
-      if (layer->PolygonN)
+      polycount = 0;
+      POUR_LOOP (layer);
+      {
+        polycount += pour->PolygonN;
+      }
+      END_LOOP;
+      if (polycount)
         {
-          PolygonList[i].Data = (void **) MyCalloc (layer->PolygonN,
+          PolygonList[i].Data = (void **) MyCalloc (polycount,
                                                     sizeof (PolygonTypePtr),
                                                     "InitLayoutLookup()");
-          PolygonList[i].Size = layer->PolygonN;
+          PolygonList[i].Size = polycount;
         }
 
       /* clear some struct members */
@@ -1777,15 +1784,13 @@ LookupLOConnectionsToArc (ArcTypePtr Arc, Cardinal LayerGroup)
   /* loop over all layers of the group */
   for (entry = 0; entry < PCB->LayerGroups.Number[LayerGroup]; entry++)
     {
-      Cardinal layer, i;
+      Cardinal layer;
 
       layer = PCB->LayerGroups.Entries[LayerGroup][entry];
 
       /* handle normal layers */
       if (layer < max_layer)
         {
-          PolygonTypePtr polygon;
-
           info.layer = layer;
           /* add arcs */
           if (setjmp (info.env) == 0)
@@ -1801,12 +1806,18 @@ LookupLOConnectionsToArc (ArcTypePtr Arc, Cardinal LayerGroup)
             return True;
 
           /* now check all polygons */
-          i = 0;
-          polygon = PCB->Data->Layer[layer].Polygon;
-          for (; i < PCB->Data->Layer[layer].PolygonN; i++, polygon++)
-            if (!TEST_FLAG (TheFlag, polygon) && IsArcInPolygon (Arc, polygon)
-                && ADD_POLYGON_TO_LIST (layer, polygon))
-              return True;
+          POUR_LOOP (LAYER_PTR (layer));
+          {
+            POURPOLYGON_LOOP (pour);
+            {
+              if (!TEST_FLAG (TheFlag, polygon) &&
+                  IsArcInPolygon (Arc, polygon) &&
+                  ADD_POLYGON_TO_LIST (layer, polygon))
+                return True;
+            }
+            END_LOOP;
+          }
+          END_LOOP;
         }
       else
         {
@@ -1922,8 +1933,6 @@ LookupLOConnectionsToLine (LineTypePtr Line, Cardinal LayerGroup,
       /* handle normal layers */
       if (layer < max_layer)
         {
-          PolygonTypePtr polygon;
-
           info.layer = layer;
           /* add lines */
           if (setjmp (info.env) == 0)
@@ -1940,13 +1949,18 @@ LookupLOConnectionsToLine (LineTypePtr Line, Cardinal LayerGroup,
           /* now check all polygons */
           if (PolysTo)
             {
-              Cardinal i = 0;
-              polygon = PCB->Data->Layer[layer].Polygon;
-              for (; i < PCB->Data->Layer[layer].PolygonN; i++, polygon++)
-                if (!TEST_FLAG
-                    (TheFlag, polygon) && IsLineInPolygon (Line, polygon)
-                    && ADD_POLYGON_TO_LIST (layer, polygon))
-                  return True;
+              POUR_LOOP (LAYER_PTR (layer));
+              {
+                POURPOLYGON_LOOP (pour);
+                {
+                  if (!TEST_FLAG (TheFlag, polygon) &&
+                      IsLineInPolygon (Line, polygon) &&
+                      ADD_POLYGON_TO_LIST (layer, polygon))
+                    return True;
+                }
+                END_LOOP;
+              }
+              END_LOOP;
             }
         }
       else
@@ -2004,7 +2018,6 @@ static Boolean
 LOTouchesLine (LineTypePtr Line, Cardinal LayerGroup)
 {
   Cardinal entry;
-  Cardinal i;
   struct lo_info info;
 
 
@@ -2021,8 +2034,6 @@ LOTouchesLine (LineTypePtr Line, Cardinal LayerGroup)
       /* handle normal layers */
       if (layer < max_layer)
         {
-          PolygonTypePtr polygon;
-
           /* find the first line that touches coordinates */
 
           if (setjmp (info.env) == 0)
@@ -2037,12 +2048,17 @@ LOTouchesLine (LineTypePtr Line, Cardinal LayerGroup)
             return (True);
 
           /* now check all polygons */
-          i = 0;
-          polygon = PCB->Data->Layer[layer].Polygon;
-          for (; i < PCB->Data->Layer[layer].PolygonN; i++, polygon++)
-            if (!TEST_FLAG (TheFlag, polygon)
-                && IsLineInPolygon (Line, polygon))
-              return (True);
+          POUR_LOOP (LAYER_PTR (layer));
+          {
+            POURPOLYGON_LOOP (pour);
+            {
+              if (!TEST_FLAG (TheFlag, polygon) &&
+                  IsLineInPolygon (Line, polygon))
+                return (True);
+            }
+            END_LOOP;
+          }
+          END_LOOP;
         }
       else
         {
@@ -2406,23 +2422,27 @@ LookupLOConnectionsToPolygon (PolygonTypePtr Polygon, Cardinal LayerGroup)
 /* loop over all layers of the group */
   for (entry = 0; entry < PCB->LayerGroups.Number[LayerGroup]; entry++)
     {
-      Cardinal layer, i;
+      Cardinal layer;
 
       layer = PCB->LayerGroups.Entries[LayerGroup][entry];
 
       /* handle normal layers */
       if (layer < max_layer)
         {
-          PolygonTypePtr polygon;
-
           /* check all polygons */
 
-          polygon = PCB->Data->Layer[layer].Polygon;
-          for (i = 0; i < PCB->Data->Layer[layer].PolygonN; i++, polygon++)
-            if (!TEST_FLAG (TheFlag, polygon)
-                && IsPolygonInPolygon (polygon, Polygon)
-                && ADD_POLYGON_TO_LIST (layer, polygon))
-              return True;
+          POUR_LOOP (LAYER_PTR (layer));
+          {
+            POURPOLYGON_LOOP (pour);
+            {
+              if (!TEST_FLAG (TheFlag, polygon) &&
+                  IsPolygonInPolygon (polygon, Polygon) &&
+                  ADD_POLYGON_TO_LIST (layer, polygon))
+                return True;
+            }
+            END_LOOP;
+          }
+          END_LOOP;
 
           info.layer = layer;
           /* check all lines */
@@ -3387,17 +3407,21 @@ ResetFoundLinesAndPolygons (Boolean AndDraw)
       }
   }
   ENDALL_LOOP;
-  COPPERPOLYGON_LOOP (PCB->Data);
+  COPPERPOUR_LOOP (PCB->Data);
   {
-    if (TEST_FLAG (TheFlag, polygon))
-      {
-        if (AndDraw)
-          AddObjectToFlagUndoList (POLYGON_TYPE, layer, polygon, polygon);
-        CLEAR_FLAG (TheFlag, polygon);
-        if (AndDraw)
-          DrawPolygon (layer, polygon, 0);
-        change = True;
-      }
+    POURPOLYGON_LOOP (pour);
+    {
+      if (TEST_FLAG (TheFlag, polygon))
+        {
+          if (AndDraw)
+            AddObjectToFlagUndoList (POLYGON_TYPE, layer, polygon, polygon);
+          CLEAR_FLAG (TheFlag, polygon);
+          if (AndDraw)
+            DrawPolygon (layer, polygon, 0);
+          change = True;
+        }
+    }
+    END_LOOP;
   }
   ENDALL_LOOP;
   if (change)
diff --git a/src/flags.c b/src/flags.c
index d4f8a67..7491a48 100644
--- a/src/flags.c
+++ b/src/flags.c
@@ -135,7 +135,8 @@ HID_Flag flags_flag_list[] = {
   {"lockmode", FlagMode, LOCK_MODE},
   {"movemode", FlagMode, MOVE_MODE},
   {"pastebuffermode", FlagMode, PASTEBUFFER_MODE},
-  {"polygonmode", FlagMode, POLYGON_MODE},
+//  {"polygonmode", FlagMode, POLYGON_MODE},
+  {"pourmode", FlagMode, POUR_MODE},
   {"rectanglemode", FlagMode, RECTANGLE_MODE},
   {"removemode", FlagMode, REMOVE_MODE},
   {"rotatemode", FlagMode, ROTATE_MODE},
diff --git a/src/global.h b/src/global.h
index 7763c80..29e1ae9 100644
--- a/src/global.h
+++ b/src/global.h
@@ -198,16 +198,39 @@ typedef struct
   void *Element;
 } TextType, *TextTypePtr;
 
-typedef struct			/* holds information about a polygon */
+typedef struct polygon_st PolygonType, *PolygonTypePtr;
+
+typedef struct			/* holds information about a poured area */
+{
+  ANYOBJECTFIELDS;
+
+  Cardinal PointN;		/* number of points in pour outline */
+  Cardinal PointMax;		/* max number from malloc() */
+  PointTypePtr Points;		/* pour outline data */
+
+  Cardinal PolygonN;		/* number of polygons this pour has */
+  Cardinal PolygonMax;		/* max number from malloc() */
+  PolygonTypePtr Polygons;	/* pour polygons */
+
+  /* r_tree? */
+
+} PourType, *PourTypePtr;
+
+struct polygon_st		/* holds information about a polygon */
 {
   ANYOBJECTFIELDS;
-  Cardinal PointN,		/* number of points in polygon */
-    PointMax;			/* max number from malloc() */
+
+//  Cardinal PointN,		/* number of points in polygon */
+//  Cardinal PointMax;		/* max number from malloc() */
+//  PointTypePtr Points;		/* data */
+
   POLYAREA *Clipped;		/* the clipped region of this polygon */
-  POLYAREA *NoHoles;		/* the polygon broken into hole-less regions */
+
+  POLYAREA *NoHoles;		/* the clipped polygon broken into hole-less regions */
   int NoHolesValid;		/* Is the NoHoles polygon up to date? */
-  PointTypePtr Points;		/* data */
-} PolygonType, *PolygonTypePtr;
+
+  PourTypePtr ParentPour;	/* The pour which resulted in this polygon */
+};
 
 typedef struct			/* holds information about arcs */
 {
@@ -231,15 +254,20 @@ typedef struct			/* holds information about one layer */
   char *Name;			/* layer name */
   Cardinal LineN,		/* number of lines */
     TextN,			/* labels */
-    PolygonN,			/* polygons */
+//    PolygonN,			/* polygons */
+    PourN,			/* poured areas */
     ArcN,			/* and arcs */
     LineMax,			/* max number from malloc() */
-    TextMax, PolygonMax, ArcMax;
+    TextMax,
+//    PolygonMax,
+    PourMax,
+    ArcMax;
   LineTypePtr Line;		/* pointer to additional structures */
   TextTypePtr Text;
-  PolygonTypePtr Polygon;
+//  PolygonTypePtr Polygon;
+  PourTypePtr Pour;
   ArcTypePtr Arc;
-  rtree_t *line_tree, *text_tree, *polygon_tree, *arc_tree;
+  rtree_t *line_tree, *text_tree, *polygon_tree, *pour_tree, *arc_tree;
   Boolean On;			/* visible flag */
   char *Color,			/* color */
    *SelectedColor;
@@ -515,7 +543,8 @@ typedef struct			/* holds cursor information */
   Boolean On;			/* flag for 'is visible' */
   AttachedLineType AttachedLine;	/* data of new lines... */
   AttachedBoxType AttachedBox;
-  PolygonType AttachedPolygon;
+//  PolygonType AttachedPolygon;
+  PourType AttachedPour;
   AttachedObjectType AttachedObject;	/* data of attached objects */
 } CrosshairType, *CrosshairTypePtr;
 
@@ -629,13 +658,15 @@ typedef struct
   void *(*Line) (LayerTypePtr, LineTypePtr);
   void *(*Text) (LayerTypePtr, TextTypePtr);
   void *(*Polygon) (LayerTypePtr, PolygonTypePtr);
+  void *(*Pour) (LayerTypePtr, PourTypePtr);
   void *(*Via) (PinTypePtr);
   void *(*Element) (ElementTypePtr);
   void *(*ElementName) (ElementTypePtr);
   void *(*Pin) (ElementTypePtr, PinTypePtr);
   void *(*Pad) (ElementTypePtr, PadTypePtr);
   void *(*LinePoint) (LayerTypePtr, LineTypePtr, PointTypePtr);
-  void *(*Point) (LayerTypePtr, PolygonTypePtr, PointTypePtr);
+  void *(*PolygonPoint) (LayerTypePtr, PolygonTypePtr, PointTypePtr);
+  void *(*PourPoint) (LayerTypePtr, PourTypePtr, PointTypePtr);
   void *(*Arc) (LayerTypePtr, ArcTypePtr);
   void *(*Rat) (RatTypePtr);
 } ObjectFunctionType, *ObjectFunctionTypePtr;
diff --git a/src/gpcb-menu.res b/src/gpcb-menu.res
index 93b6073..f28bf79 100644
--- a/src/gpcb-menu.res
+++ b/src/gpcb-menu.res
@@ -490,7 +490,7 @@ PopupMenus =
        {"Arc" checked=arcmode,1 Mode(Arc) a={"F3" "<Key>F3"}}
        {"Text" checked=textmode,1 Mode(Text) a={"F4" "<Key>F4"}}
        {"Rectangle" checked=rectanglemode,1 Mode(Rectangle) a={"F5" "<Key>F5"}}
-       {"Polygon" checked=polygonmode,1 Mode(Polygon) a={"F6" "<Key>F6"}}
+       {"Polygon" checked=pourmode,1 Mode(Pour) a={"F6" "<Key>F6"}}
        {"Buffer" checked=pastebuffermode,1 Mode(PasteBuffer) a={"F7" "<Key>F7"}}
        {"Remove" checked=removemode,1 Mode(Remove) a={"F8" "<Key>F8"}}
        {"Rotate" checked=rotatemode,1 Mode(Rotate) a={"F9" "<Key>F9"}}
diff --git a/src/hid/gerber/gerber.c b/src/hid/gerber/gerber.c
index e506876..54c010f 100644
--- a/src/hid/gerber/gerber.c
+++ b/src/hid/gerber/gerber.c
@@ -362,7 +362,7 @@ gerber_do_export (HID_Attr_Val * options)
   for (i = 0; i < max_layer; i++)
     {
       LayerType *layer = PCB->Data->Layer + i;
-      if (layer->LineN || layer->TextN || layer->ArcN || layer->PolygonN)
+      if (layer->LineN || layer->TextN || layer->ArcN || layer->PourN)
 	print_group[GetLayerGroupNumberByNumber (i)] = 1;
     }
   print_group[GetLayerGroupNumberByNumber (max_layer)] = 1;
diff --git a/src/hid/gtk/gui-icons-mode-buttons.data b/src/hid/gtk/gui-icons-mode-buttons.data
index 1938ee2..e210157 100644
--- a/src/hid/gtk/gui-icons-mode-buttons.data
+++ b/src/hid/gtk/gui-icons-mode-buttons.data
@@ -252,7 +252,7 @@ static char *pan[] = {
 
 #endif
 /* XPM */
-static char *poly[] = {
+static char *pour[] = {
 /* columns rows colors chars-per-pixel */
 "21 21 4 1",
 "  c black",
diff --git a/src/hid/gtk/gui-misc.c b/src/hid/gtk/gui-misc.c
index e8ad916..e1b6290 100644
--- a/src/hid/gtk/gui-misc.c
+++ b/src/hid/gtk/gui-misc.c
@@ -219,7 +219,7 @@ ghid_mode_cursor (int Mode)
       gport_set_cursor (GDK_LEFT_PTR);
       break;
 
-    case POLYGON_MODE:
+    case POUR_MODE:
       gport_set_cursor (GDK_SB_UP_ARROW);
       break;
 
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index f033f0f..0878b0d 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -267,7 +267,7 @@ have_crosshair_attachments (void)
     case VIA_MODE:
       result = TRUE;
       break;
-    case POLYGON_MODE:
+    case POUR_MODE:
       if (Crosshair.AttachedLine.State != STATE_FIRST)
 	result = TRUE;
       break;
@@ -571,7 +571,7 @@ in_draw_state (void)
 	  && Crosshair.AttachedBox.State != STATE_FIRST)
       || (Settings.Mode == RECTANGLE_MODE
 	  && Crosshair.AttachedBox.State != STATE_FIRST)
-      || (Settings.Mode == POLYGON_MODE
+      || (Settings.Mode == POUR_MODE
 	  && Crosshair.AttachedLine.State != STATE_FIRST))
     return TRUE;
   return FALSE;
@@ -633,8 +633,9 @@ ghid_port_button_press_cb (GtkWidget * drawing_area,
 	    hid_actionl ("Mode", "Arc", NULL);
 	  else if (Settings.Mode == RECTANGLE_MODE)
 	    hid_actionl ("Mode", "Rectangle", NULL);
-	  else if (Settings.Mode == POLYGON_MODE)
-	    hid_actionl ("Mode", "Polygon", NULL);
+	  else if (Settings.Mode == POUR_MODE)
+	    hid_actionl ("Mode", "Pour", NULL);
+//	    hid_actionl ("Mode", "Polygon", NULL);
 
 	  hid_actionl ("Mode", "Notify", NULL);
 	  draw_state_reset = TRUE;
diff --git a/src/hid/gtk/gui-top-window.c b/src/hid/gtk/gui-top-window.c
index 8143bc8..214032d 100644
--- a/src/hid/gtk/gui-top-window.c
+++ b/src/hid/gtk/gui-top-window.c
@@ -1981,7 +1981,8 @@ static ModeButton mode_buttons[] = {
   {NULL, NULL, NULL, "arc", ARC_MODE, arc},
   {NULL, NULL, NULL, "text", TEXT_MODE, text},
   {NULL, NULL, NULL, "rectangle", RECTANGLE_MODE, rect},
-  {NULL, NULL, NULL, "polygon", POLYGON_MODE, poly},
+  {NULL, NULL, NULL, "pour", POUR_MODE, pour},
+//  {NULL, NULL, NULL, "polygon", POLYGON_MODE, poly},
   {NULL, NULL, NULL, "buffer", PASTEBUFFER_MODE, buf},
   {NULL, NULL, NULL, "remove", REMOVE_MODE, del},
   {NULL, NULL, NULL, "rotate", ROTATE_MODE, rot},
diff --git a/src/hid/nelma/nelma.c b/src/hid/nelma/nelma.c
index e7d0f9f..1fd0993 100644
--- a/src/hid/nelma/nelma.c
+++ b/src/hid/nelma/nelma.c
@@ -525,7 +525,7 @@ nelma_choose_groups()
 		layer = &PCB->Data->Layer[n];
 
 		if (layer->LineN || layer->TextN || layer->ArcN ||
-		    layer->PolygonN) {
+		    layer->PourN) {
 			/* layer isn't empty */
 
 			/*
diff --git a/src/hid/png/png.c b/src/hid/png/png.c
index 5b924c5..82ba1e7 100644
--- a/src/hid/png/png.c
+++ b/src/hid/png/png.c
@@ -286,7 +286,7 @@ png_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
   for (i = 0; i < max_layer; i++)
     {
       LayerType *layer = PCB->Data->Layer + i;
-      if (layer->LineN || layer->TextN || layer->ArcN || layer->PolygonN)
+      if (layer->LineN || layer->TextN || layer->ArcN || layer->PourN)
 	print_group[GetLayerGroupNumberByNumber (i)] = 1;
     }
   print_group[GetLayerGroupNumberByNumber (max_layer)] = 1;
diff --git a/src/hid/ps/eps.c b/src/hid/ps/eps.c
index 0759a88..a129b3b 100644
--- a/src/hid/ps/eps.c
+++ b/src/hid/ps/eps.c
@@ -149,7 +149,7 @@ eps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
     {
       LayerType *layer = PCB->Data->Layer + i;
       if (layer->On)
-	if (layer->LineN || layer->TextN || layer->ArcN || layer->PolygonN)
+	if (layer->LineN || layer->TextN || layer->ArcN || layer->PourN)
 	  print_group[GetLayerGroupNumberByNumber (i)] = 1;
     }
 
diff --git a/src/hid/ps/ps.c b/src/hid/ps/ps.c
index 5c59bb9..d698af9 100644
--- a/src/hid/ps/ps.c
+++ b/src/hid/ps/ps.c
@@ -362,7 +362,7 @@ ps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
   for (i = 0; i < max_layer; i++)
     {
       LayerType *layer = PCB->Data->Layer + i;
-      if (layer->LineN || layer->TextN || layer->ArcN || layer->PolygonN)
+      if (layer->LineN || layer->TextN || layer->ArcN || layer->PourN)
 	print_group[GetLayerGroupNumberByNumber (i)] = 1;
 
       if (strcmp (layer->Name, "outline") == 0
diff --git a/src/insert.c b/src/insert.c
index 3d4a2f5..6399fac 100644
--- a/src/insert.c
+++ b/src/insert.c
@@ -46,6 +46,7 @@
 #include "misc.h"
 #include "move.h"
 #include "polygon.h"
+#include "pour.h"
 #include "rtree.h"
 #include "search.h"
 #include "select.h"
@@ -65,7 +66,7 @@ RCSID ("$Id$");
  * some local prototypes
  */
 static void *InsertPointIntoLine (LayerTypePtr, LineTypePtr);
-static void *InsertPointIntoPolygon (LayerTypePtr, PolygonTypePtr);
+static void *InsertPointIntoPour (LayerTypePtr, PourTypePtr);
 static void *InsertPointIntoRat (RatTypePtr);
 
 /* ---------------------------------------------------------------------------
@@ -78,7 +79,8 @@ static Boolean Forcible;
 static ObjectFunctionType InsertFunctions = {
   InsertPointIntoLine,
   NULL,
-  InsertPointIntoPolygon,
+  NULL,
+  InsertPointIntoPour,
   NULL,
   NULL,
   NULL,
@@ -159,10 +161,10 @@ InsertPointIntoLine (LayerTypePtr Layer, LineTypePtr Line)
 }
 
 /* ---------------------------------------------------------------------------
- * inserts a point into a polygon
+ * inserts a point into a pour
  */
 static void *
-InsertPointIntoPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
+InsertPointIntoPour (LayerTypePtr Layer, PourTypePtr Pour)
 {
   PointType save;
   Cardinal n;
@@ -175,34 +177,34 @@ InsertPointIntoPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
        */
       line.Thickness = 0;
       if (InsertAt == 0)
-	line.Point1 = Polygon->Points[Polygon->PointN - 1];
+	line.Point1 = Pour->Points[Pour->PointN - 1];
       else
-	line.Point1 = Polygon->Points[InsertAt - 1];
-      line.Point2 = Polygon->Points[InsertAt];
+	line.Point1 = Pour->Points[InsertAt - 1];
+      line.Point2 = Pour->Points[InsertAt];
       if (IsPointOnLine ((float) InsertX, (float) InsertY, 0.0, &line))
 	return (NULL);
     }
   /*
    * second, shift the points up to make room for the new point
    */
-  ErasePolygon (Polygon);
-  r_delete_entry (Layer->polygon_tree, (BoxTypePtr) Polygon);
-  save = *CreateNewPointInPolygon (Polygon, InsertX, InsertY);
-  for (n = Polygon->PointN - 1; n > InsertAt; n--)
-    Polygon->Points[n] = Polygon->Points[n - 1];
-  Polygon->Points[InsertAt] = save;
+  ErasePour (Pour);
+  r_delete_entry (Layer->pour_tree, (BoxTypePtr) Pour);
+  save = *CreateNewPointInPour (Pour, InsertX, InsertY);
+  for (n = Pour->PointN - 1; n > InsertAt; n--)
+    Pour->Points[n] = Pour->Points[n - 1];
+  Pour->Points[InsertAt] = save;
   SetChangedFlag (True);
-  AddObjectToInsertPointUndoList (POLYGONPOINT_TYPE, Layer, Polygon,
-				  &Polygon->Points[InsertAt]);
-  SetPolygonBoundingBox (Polygon);
-  r_insert_entry (Layer->polygon_tree, (BoxType *) Polygon, 0);
-  InitClip (PCB->Data, Layer, Polygon);
-  if (Forcible || !RemoveExcessPolygonPoints (Layer, Polygon))
+  AddObjectToInsertPointUndoList (POURPOINT_TYPE, Layer, Pour,
+				  &Pour->Points[InsertAt]);
+  SetPourBoundingBox (Pour);
+  r_insert_entry (Layer->pour_tree, (BoxType *) Pour, 0);
+  InitPourClip (PCB->Data, Layer, Pour);
+  if (Forcible || !RemoveExcessPourPoints (Layer, Pour))
     {
-      DrawPolygon (Layer, Polygon, 0);
+      DrawPour (Layer, Pour, 0);
       Draw ();
     }
-  return (&Polygon->Points[InsertAt]);
+  return (&Pour->Points[InsertAt]);
 }
 
 /* ---------------------------------------------------------------------------
diff --git a/src/macro.h b/src/macro.h
index 819d202..8b9696b 100644
--- a/src/macro.h
+++ b/src/macro.h
@@ -391,12 +391,14 @@ extern int mem_any_set (unsigned char *, int);
 	{						\
 		text = &(layer)->Text[n]
 
+#if 0
 #define	POLYGON_LOOP(layer) do {			\
 	Cardinal		n;			\
 	PolygonTypePtr	polygon;			\
 	for (n = (layer)->PolygonN-1; n != -1; n--)	\
 	{						\
 		polygon = &(layer)->Polygon[n]
+#endif
 
 #define	POLYGONPOINT_LOOP(polygon) do	{	\
 	Cardinal			n;		\
@@ -405,6 +407,27 @@ extern int mem_any_set (unsigned char *, int);
 	{						\
 		point = &(polygon)->Points[n]
 
+#define	POUR_LOOP(layer) do {			\
+	Cardinal		n;			\
+	PourTypePtr	pour;			\
+	for (n = (layer)->PourN-1; n != -1; n--)	\
+	{						\
+		pour = &(layer)->Pour[n]
+
+#define	POURPOINT_LOOP(pour) do	{	\
+	Cardinal			n;		\
+	PointTypePtr	point;				\
+	for (n = (pour)->PointN-1; n != -1; n--)	\
+	{						\
+		point = &(pour)->Points[n]
+
+#define	POURPOLYGON_LOOP(pour) do	{	\
+	Cardinal			n;		\
+	PolygonTypePtr	polygon;				\
+	for (n = (pour)->PolygonN-1; n != -1; n--)	\
+	{						\
+		polygon = &(pour)->Polygons[n]
+
 #define ENDALL_LOOP }} while (0);  }} while (0)
 
 #define	ALLPIN_LOOP(top)	\
@@ -429,12 +452,21 @@ extern int mem_any_set (unsigned char *, int);
 	{ \
 		ARC_LOOP(layer)
 
+#if 0
 #define	ALLPOLYGON_LOOP(top)	do {		\
 	Cardinal		l;			\
 	LayerTypePtr	layer = (top)->Layer;		\
 	for (l = 0; l < max_layer + 2; l++, layer++)	\
 	{ \
 		POLYGON_LOOP(layer)
+#endif
+
+#define	ALLPOUR_LOOP(top)	do {		\
+	Cardinal		l;			\
+	LayerTypePtr	layer = (top)->Layer;		\
+	for (l = 0; l < max_layer + 2; l++, layer++)	\
+	{ \
+		POUR_LOOP(layer)
 
 #define	COPPERLINE_LOOP(top) do	{		\
 	Cardinal		l;			\
@@ -450,12 +482,21 @@ extern int mem_any_set (unsigned char *, int);
 	{ \
 		ARC_LOOP(layer)
 
+#if 0
 #define	COPPERPOLYGON_LOOP(top) do	{		\
 	Cardinal		l;			\
 	LayerTypePtr	layer = (top)->Layer;		\
 	for (l = 0; l < max_layer; l++, layer++)	\
 	{ \
 		POLYGON_LOOP(layer)
+#endif
+
+#define	COPPERPOUR_LOOP(top) do	{		\
+	Cardinal		l;			\
+	LayerTypePtr	layer = (top)->Layer;		\
+	for (l = 0; l < max_layer; l++, layer++)	\
+	{ \
+		POUR_LOOP(layer)
 
 #define	SILKLINE_LOOP(top) do	{		\
 	Cardinal		l;			\
@@ -473,6 +514,7 @@ extern int mem_any_set (unsigned char *, int);
 	{ \
 		ARC_LOOP(layer)
 
+#if 0
 #define	SILKPOLYGON_LOOP(top) do	{		\
 	Cardinal		l;			\
 	LayerTypePtr	layer = (top)->Layer;		\
@@ -480,6 +522,15 @@ extern int mem_any_set (unsigned char *, int);
 	for (l = 0; l < 2; l++, layer++)		\
 	{ \
 		POLYGON_LOOP(layer)
+#endif
+
+#define	SILKPOUR_LOOP(top) do	{		\
+	Cardinal		l;			\
+	LayerTypePtr	layer = (top)->Layer;		\
+	layer += max_layer;				\
+	for (l = 0; l < 2; l++, layer++)		\
+	{ \
+		POUR_LOOP(layer)
 
 #define	ALLTEXT_LOOP(top)	do {		\
 	Cardinal		l;			\
@@ -512,6 +563,7 @@ extern int mem_any_set (unsigned char *, int);
                 TEXT_LOOP(layer);                                      \
                   if (TEXT_IS_VISIBLE((board), layer, text))
 
+#if 0
 #define	VISIBLEPOLYGON_LOOP(top) do	{	\
 	Cardinal		l;			\
 	LayerTypePtr	layer = (top)->Layer;		\
@@ -519,6 +571,15 @@ extern int mem_any_set (unsigned char *, int);
 	{ \
 		if (layer->On)				\
 			POLYGON_LOOP(layer)
+#endif
+
+#define	VISIBLEPOUR_LOOP(top) do	{	\
+	Cardinal		l;			\
+	LayerTypePtr	layer = (top)->Layer;		\
+	for (l = 0; l < max_layer + 2; l++, layer++)	\
+	{ \
+		if (layer->On)				\
+			POUR_LOOP(layer)
 
 #define POINTER_LOOP(top) do	{	\
 	Cardinal	n;			\
diff --git a/src/mirror.c b/src/mirror.c
index 7ef7d41..1b76e88 100644
--- a/src/mirror.c
+++ b/src/mirror.c
@@ -46,6 +46,7 @@
 #include "mirror.h"
 #include "misc.h"
 #include "polygon.h"
+#include "pour.h"
 #include "search.h"
 #include "select.h"
 #include "set.h"
@@ -78,14 +79,14 @@ MirrorElementCoordinates (DataTypePtr Data, ElementTypePtr Element,
   END_LOOP;
   PIN_LOOP (Element);
   {
-    RestoreToPolygon (Data, PIN_TYPE, Element, pin);
+    RestoreToPours (Data, PIN_TYPE, Element, pin);
     pin->X = SWAP_X (pin->X);
     pin->Y = SWAP_Y (pin->Y) + yoff;
   }
   END_LOOP;
   PAD_LOOP (Element);
   {
-    RestoreToPolygon (Data, PAD_TYPE, Element, pad);
+    RestoreToPours (Data, PAD_TYPE, Element, pad);
     pad->Point1.X = SWAP_X (pad->Point1.X);
     pad->Point1.Y = SWAP_Y (pad->Point1.Y) + yoff;
     pad->Point2.X = SWAP_X (pad->Point2.X);
@@ -115,5 +116,5 @@ MirrorElementCoordinates (DataTypePtr Data, ElementTypePtr Element,
   TOGGLE_FLAG (ONSOLDERFLAG, Element);
   /* this inserts all of the rtree data too */
   SetElementBoundingBox (Data, Element, &PCB->Font);
-  ClearFromPolygon (Data, ELEMENT_TYPE, Element, Element);
+  ClearFromPours (Data, ELEMENT_TYPE, Element, Element);
 }
diff --git a/src/misc.c b/src/misc.c
index df34363..ce44f58 100644
--- a/src/misc.c
+++ b/src/misc.c
@@ -65,6 +65,7 @@
 #include "misc.h"
 #include "move.h"
 #include "polygon.h"
+#include "pour.h"
 #include "remove.h"
 #include "rtree.h"
 #include "rotate.h"
@@ -238,19 +239,32 @@ SetLineBoundingBox (LineTypePtr Line)
 }
 
 /* ---------------------------------------------------------------------------
- * sets the bounding box of a polygons
+ * sets the bounding box of a polygon
  */
 void
 SetPolygonBoundingBox (PolygonTypePtr Polygon)
 {
-  Polygon->BoundingBox.X1 = Polygon->BoundingBox.Y1 = MAX_COORD;
-  Polygon->BoundingBox.X2 = Polygon->BoundingBox.Y2 = 0;
-  POLYGONPOINT_LOOP (Polygon);
+  PLINE *outer = Polygon->Clipped->contours;
+  Polygon->BoundingBox.X1 = outer->xmin;
+  Polygon->BoundingBox.Y1 = outer->ymin;
+  Polygon->BoundingBox.X2 = outer->xmax;
+  Polygon->BoundingBox.Y2 = outer->ymax;
+}
+
+/* ---------------------------------------------------------------------------
+ * sets the bounding box of a pour
+ */
+void
+SetPourBoundingBox (PourTypePtr Pour)
+{
+  Pour->BoundingBox.X1 = Pour->BoundingBox.Y1 = MAX_COORD;
+  Pour->BoundingBox.X2 = Pour->BoundingBox.Y2 = 0;
+  POURPOINT_LOOP (Pour);
   {
-    MAKEMIN (Polygon->BoundingBox.X1, point->X);
-    MAKEMIN (Polygon->BoundingBox.Y1, point->Y);
-    MAKEMAX (Polygon->BoundingBox.X2, point->X);
-    MAKEMAX (Polygon->BoundingBox.Y2, point->Y);
+    MAKEMIN (Pour->BoundingBox.X1, point->X);
+    MAKEMIN (Pour->BoundingBox.Y1, point->Y);
+    MAKEMAX (Pour->BoundingBox.X2, point->X);
+    MAKEMAX (Pour->BoundingBox.Y2, point->Y);
   }
   END_LOOP;
 }
@@ -490,7 +504,9 @@ IsDataEmpty (DataTypePtr Data)
     hasNoObjects = hasNoObjects &&
       Data->Layer[i].LineN == 0 &&
       Data->Layer[i].ArcN == 0 &&
-      Data->Layer[i].TextN == 0 && Data->Layer[i].PolygonN == 0;
+      Data->Layer[i].TextN == 0 &&
+      Data->Layer[i].PourN == 0;
+
   return (hasNoObjects);
 }
 
@@ -569,13 +585,17 @@ GetDataBoundingBox (DataTypePtr Data)
     box.Y2 = MAX (box.Y2, text->BoundingBox.Y2);
   }
   ENDALL_LOOP;
-  ALLPOLYGON_LOOP (Data);
-  {
-    box.X1 = MIN (box.X1, polygon->BoundingBox.X1);
-    box.Y1 = MIN (box.Y1, polygon->BoundingBox.Y1);
-    box.X2 = MAX (box.X2, polygon->BoundingBox.X2);
-    box.Y2 = MAX (box.Y2, polygon->BoundingBox.Y2);
-  }
+  ALLPOUR_LOOP (Data);
+    {
+      POURPOLYGON_LOOP (pour);
+      {
+        box.X1 = MIN (box.X1, polygon->BoundingBox.X1);
+        box.Y1 = MIN (box.Y1, polygon->BoundingBox.Y1);
+        box.X2 = MAX (box.X2, polygon->BoundingBox.X2);
+        box.Y2 = MAX (box.Y2, polygon->BoundingBox.Y2);
+      }
+      END_LOOP;
+    }
   ENDALL_LOOP;
   return (IsDataEmpty (Data) ? NULL : &box);
 }
@@ -1578,14 +1598,14 @@ ChangeArcAngles (LayerTypePtr Layer, ArcTypePtr a,
       new_da = 360;
       new_sa = 0;
     }
-  RestoreToPolygon (PCB->Data, ARC_TYPE, Layer, a);
+  RestoreToPours (PCB->Data, ARC_TYPE, Layer, a);
   r_delete_entry (Layer->arc_tree, (BoxTypePtr) a);
   AddObjectToChangeAnglesUndoList (ARC_TYPE, a, a, a);
   a->StartAngle = new_sa;
   a->Delta = new_da;
   SetArcBoundingBox (a);
   r_insert_entry (Layer->arc_tree, (BoxTypePtr) a, 0);
-  ClearFromPolygon (PCB->Data, ARC_TYPE, Layer, a);
+  ClearFromPours (PCB->Data, ARC_TYPE, Layer, a);
 }
 
 static char *
@@ -1671,8 +1691,13 @@ GetGridLockCoordinates (int type, void *ptr1,
       *y = ((ElementTypePtr) ptr2)->MarkY;
       break;
     case POLYGON_TYPE:
+#warning FIXME Later
+      *x = 1000;
+      *y = 1000;
+#if 0
       *x = ((PolygonTypePtr) ptr2)->Points[0].X;
       *y = ((PolygonTypePtr) ptr2)->Points[0].Y;
+#endif
       break;
 
     case LINEPOINT_TYPE:
diff --git a/src/misc.h b/src/misc.h
index 58e75dc..6d7bc4b 100644
--- a/src/misc.h
+++ b/src/misc.h
@@ -42,6 +42,7 @@ void SetPointBoundingBox (PointTypePtr);
 void SetPinBoundingBox (PinTypePtr);
 void SetPadBoundingBox (PadTypePtr);
 void SetPolygonBoundingBox (PolygonTypePtr);
+void SetPourBoundingBox (PourTypePtr);
 void SetElementBoundingBox (DataTypePtr, ElementTypePtr, FontTypePtr);
 Boolean IsDataEmpty (DataTypePtr);
 BoxTypePtr GetDataBoundingBox (DataTypePtr);
diff --git a/src/move.c b/src/move.c
index aebfc30..b2704ad 100644
--- a/src/move.c
+++ b/src/move.c
@@ -48,6 +48,7 @@
 #include "move.h"
 #include "mymem.h"
 #include "polygon.h"
+#include "pour.h"
 #include "rtree.h"
 #include "search.h"
 #include "select.h"
@@ -72,14 +73,16 @@ static void *MoveVia (PinTypePtr);
 static void *MoveLine (LayerTypePtr, LineTypePtr);
 static void *MoveArc (LayerTypePtr, ArcTypePtr);
 static void *MoveText (LayerTypePtr, TextTypePtr);
-static void *MovePolygon (LayerTypePtr, PolygonTypePtr);
+//static void *MovePolygon (LayerTypePtr, PolygonTypePtr);
+static void *MovePour (LayerTypePtr, PourTypePtr);
 static void *MoveLinePoint (LayerTypePtr, LineTypePtr, PointTypePtr);
-static void *MovePolygonPoint (LayerTypePtr, PolygonTypePtr, PointTypePtr);
+static void *MovePourPoint (LayerTypePtr, PourTypePtr, PointTypePtr);
 static void *MoveLineToLayer (LayerTypePtr, LineTypePtr);
 static void *MoveArcToLayer (LayerTypePtr, ArcTypePtr);
 static void *MoveRatToLayer (RatTypePtr);
 static void *MoveTextToLayer (LayerTypePtr, TextTypePtr);
-static void *MovePolygonToLayer (LayerTypePtr, PolygonTypePtr);
+//static void *MovePolygonToLayer (LayerTypePtr, PolygonTypePtr);
+static void *MovePourToLayer (LayerTypePtr, PourTypePtr);
 
 /* ---------------------------------------------------------------------------
  * some local identifiers
@@ -91,14 +94,16 @@ static Boolean MoreToCome;
 static ObjectFunctionType MoveFunctions = {
   MoveLine,
   MoveText,
-  MovePolygon,
+  NULL, // MovePolygon,
+  MovePour,
   MoveVia,
   MoveElement,
   MoveElementName,
   NULL,
   NULL,
   MoveLinePoint,
-  MovePolygonPoint,
+  NULL,
+  MovePourPoint,
   MoveArc,
   NULL
 }, MoveToLayerFunctions =
@@ -106,8 +111,18 @@ static ObjectFunctionType MoveFunctions = {
 {
 MoveLineToLayer,
     MoveTextToLayer,
-    MovePolygonToLayer,
-    NULL, NULL, NULL, NULL, NULL, NULL, NULL, MoveArcToLayer, MoveRatToLayer};
+    NULL, //MovePolygonToLayer,
+    MovePourToLayer,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    MoveArcToLayer,
+    MoveRatToLayer};
 
 /* ---------------------------------------------------------------------------
  * moves a element by +-X and +-Y
@@ -128,13 +143,13 @@ MoveElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
     if (Data)
       {
 	r_delete_entry (Data->pin_tree, (BoxType *) pin);
-	RestoreToPolygon (Data, PIN_TYPE, Element, pin);
+	RestoreToPours (Data, PIN_TYPE, Element, pin);
       }
     MOVE_PIN_LOWLEVEL (pin, DX, DY);
     if (Data)
       {
 	r_insert_entry (Data->pin_tree, (BoxType *) pin, 0);
-	ClearFromPolygon (Data, PIN_TYPE, Element, pin);
+	ClearFromPours (Data, PIN_TYPE, Element, pin);
       }
   }
   END_LOOP;
@@ -143,13 +158,13 @@ MoveElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
     if (Data)
       {
 	r_delete_entry (Data->pad_tree, (BoxType *) pad);
-	RestoreToPolygon (Data, PAD_TYPE, Element, pad);
+	RestoreToPours (Data, PAD_TYPE, Element, pad);
       }
     MOVE_PAD_LOWLEVEL (pad, DX, DY);
     if (Data)
       {
 	r_insert_entry (Data->pad_tree, (BoxType *) pad, 0);
-	ClearFromPolygon (Data, PAD_TYPE, Element, pad);
+	ClearFromPours (Data, PAD_TYPE, Element, pad);
       }
   }
   END_LOOP;
@@ -249,12 +264,12 @@ static void *
 MoveVia (PinTypePtr Via)
 {
   r_delete_entry (PCB->Data->via_tree, (BoxTypePtr) Via);
-  RestoreToPolygon (PCB->Data, VIA_TYPE, Via, Via);
+  RestoreToPours (PCB->Data, VIA_TYPE, Via, Via);
   MOVE_VIA_LOWLEVEL (Via, DeltaX, DeltaY);
   if (PCB->ViaOn)
     EraseVia (Via);
   r_insert_entry (PCB->Data->via_tree, (BoxTypePtr) Via, 0);
-  ClearFromPolygon (PCB->Data, VIA_TYPE, Via, Via);
+  ClearFromPours (PCB->Data, VIA_TYPE, Via, Via);
   if (PCB->ViaOn)
     {
       DrawVia (Via, 0);
@@ -271,11 +286,11 @@ MoveLine (LayerTypePtr Layer, LineTypePtr Line)
 {
   if (Layer->On)
     EraseLine (Line);
-  RestoreToPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+  RestoreToPours (PCB->Data, LINE_TYPE, Layer, Line);
   r_delete_entry (Layer->line_tree, (BoxTypePtr) Line);
   MOVE_LINE_LOWLEVEL (Line, DeltaX, DeltaY);
   r_insert_entry (Layer->line_tree, (BoxTypePtr) Line, 0);
-  ClearFromPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+  ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
   if (Layer->On)
     {
       DrawLine (Layer, Line, 0);
@@ -290,7 +305,7 @@ MoveLine (LayerTypePtr Layer, LineTypePtr Line)
 static void *
 MoveArc (LayerTypePtr Layer, ArcTypePtr Arc)
 {
-  RestoreToPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
+  RestoreToPours (PCB->Data, ARC_TYPE, Layer, Arc);
   r_delete_entry (Layer->arc_tree, (BoxTypePtr) Arc);
   if (Layer->On)
     {
@@ -304,7 +319,7 @@ MoveArc (LayerTypePtr Layer, ArcTypePtr Arc)
       MOVE_ARC_LOWLEVEL (Arc, DeltaX, DeltaY);
     }
   r_insert_entry (Layer->arc_tree, (BoxTypePtr) Arc, 0);
-  ClearFromPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
+  ClearFromPours (PCB->Data, ARC_TYPE, Layer, Arc);
   return (Arc);
 }
 
@@ -314,7 +329,7 @@ MoveArc (LayerTypePtr Layer, ArcTypePtr Arc)
 static void *
 MoveText (LayerTypePtr Layer, TextTypePtr Text)
 {
-  RestoreToPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+  RestoreToPours (PCB->Data, TEXT_TYPE, Layer, Text);
   r_delete_entry (Layer->text_tree, (BoxTypePtr) Text);
   if (Layer->On)
     {
@@ -326,7 +341,7 @@ MoveText (LayerTypePtr Layer, TextTypePtr Text)
   else
     MOVE_TEXT_LOWLEVEL (Text, DeltaX, DeltaY);
   r_insert_entry (Layer->text_tree, (BoxTypePtr) Text, 0);
-  ClearFromPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+  ClearFromPours (PCB->Data, TEXT_TYPE, Layer, Text);
   return (Text);
 }
 
@@ -337,15 +352,35 @@ void
 MovePolygonLowLevel (PolygonTypePtr Polygon, LocationType DeltaX,
 		     LocationType DeltaY)
 {
+#warning FIXME Later
+#if 0
   POLYGONPOINT_LOOP (Polygon);
   {
     MOVE (point->X, point->Y, DeltaX, DeltaY);
   }
   END_LOOP;
   MOVE_BOX_LOWLEVEL (&Polygon->BoundingBox, DeltaX, DeltaY);
+#endif
 }
 
 /* ---------------------------------------------------------------------------
+ * low level routine to move a pour
+ */
+void
+MovePourLowLevel (PourTypePtr Pour, LocationType DeltaX,
+		     LocationType DeltaY)
+{
+  POURPOINT_LOOP (Pour);
+  {
+    MOVE (point->X, point->Y, DeltaX, DeltaY);
+  }
+  END_LOOP;
+  MOVE_BOX_LOWLEVEL (&Pour->BoundingBox, DeltaX, DeltaY);
+}
+
+#warning FIXME Later
+#if 0
+/* ---------------------------------------------------------------------------
  * moves a polygon
  */
 static void *
@@ -355,12 +390,12 @@ MovePolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
     {
       ErasePolygon (Polygon);
     }
-  RestoreToPolygon (PCB->Data, POLYGON_TYPE, Layer, Polygon);
+  RestoreToPours (PCB->Data, POLYGON_TYPE, Layer, Polygon);
   r_delete_entry (Layer->polygon_tree, (BoxType *) Polygon);
   MovePolygonLowLevel (Polygon, DeltaX, DeltaY);
   r_insert_entry (Layer->polygon_tree, (BoxType *) Polygon, 0);
   InitClip (PCB->Data, Layer, Polygon);
-  ClearFromPolygon (PCB->Data, POLYGON_TYPE, Layer, Polygon);
+  ClearFromPours (PCB->Data, POLYGON_TYPE, Layer, Polygon);
   if (Layer->On)
     {
       DrawPolygon (Layer, Polygon, 0);
@@ -368,6 +403,31 @@ MovePolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
     }
   return (Polygon);
 }
+#endif
+
+/* ---------------------------------------------------------------------------
+ * moves a pour
+ */
+static void *
+MovePour (LayerTypePtr Layer, PourTypePtr Pour)
+{
+  if (Layer->On)
+    {
+      ErasePour (Pour);
+    }
+//  RestoreToPours (PCB->Data, POLYGON_TYPE, Layer, Pour);
+  r_delete_entry (Layer->pour_tree, (BoxType *) Pour);
+  MovePourLowLevel (Pour, DeltaX, DeltaY);
+  r_insert_entry (Layer->pour_tree, (BoxType *) Pour, 0);
+  InitPourClip (PCB->Data, Layer, Pour);
+//  ClearFromPours (PCB->Data, POLYGON_TYPE, Layer, Polygon);
+  if (Layer->On)
+    {
+      DrawPour (Layer, Pour, 0);
+      Draw ();
+    }
+  return (Pour);
+}
 
 /* ---------------------------------------------------------------------------
  * moves one end of a line
@@ -379,12 +439,12 @@ MoveLinePoint (LayerTypePtr Layer, LineTypePtr Line, PointTypePtr Point)
     {
       if (Layer->On)
 	EraseLine (Line);
-      RestoreToPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+      RestoreToPours (PCB->Data, LINE_TYPE, Layer, Line);
       r_delete_entry (Layer->line_tree, &Line->BoundingBox);
       MOVE (Point->X, Point->Y, DeltaX, DeltaY);
       SetLineBoundingBox (Line);
       r_insert_entry (Layer->line_tree, &Line->BoundingBox, 0);
-      ClearFromPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+      ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
       if (Layer->On)
 	{
 	  DrawLine (Layer, Line, 0);
@@ -410,27 +470,26 @@ MoveLinePoint (LayerTypePtr Layer, LineTypePtr Line, PointTypePtr Point)
 }
 
 /* ---------------------------------------------------------------------------
- * moves a polygon-point
+ * moves a pour-point
  */
 static void *
-MovePolygonPoint (LayerTypePtr Layer, PolygonTypePtr Polygon,
-		  PointTypePtr Point)
+MovePourPoint (LayerTypePtr Layer, PourTypePtr Pour, PointTypePtr Point)
 {
   if (Layer->On)
     {
-      ErasePolygon (Polygon);
+      ErasePour (Pour);
     }
-  RestoreToPolygon (PCB->Data, POLYGON_TYPE, Layer, Polygon);
-  r_delete_entry (Layer->polygon_tree, (BoxType *) Polygon);
+//  RestoreToPours (PCB->Data, POLYGON_TYPE, Layer, Polygon);
+  r_delete_entry (Layer->pour_tree, (BoxType *) Pour);
   MOVE (Point->X, Point->Y, DeltaX, DeltaY);
-  SetPolygonBoundingBox (Polygon);
-  r_insert_entry (Layer->polygon_tree, (BoxType *) Polygon, 0);
-  RemoveExcessPolygonPoints (Layer, Polygon);
-  InitClip (PCB->Data, Layer, Polygon);
-  ClearFromPolygon (PCB->Data, POLYGON_TYPE, Layer, Polygon);
+  SetPourBoundingBox (Pour);
+  r_insert_entry (Layer->pour_tree, (BoxType *) Pour, 0);
+  RemoveExcessPourPoints (Layer, Pour);
+  InitPourClip (PCB->Data, Layer, Pour);
+//  ClearFromPours (PCB->Data, POLYGON_TYPE, Layer, Polygon);
   if (Layer->On)
     {
-      DrawPolygon (Layer, Polygon, 0);
+      DrawPour (Layer, Pour, 0);
       Draw ();
     }
   return (Point);
@@ -502,11 +561,11 @@ MoveArcToLayer (LayerTypePtr Layer, ArcTypePtr Arc)
   if (((long int) Dest == -1) || Dest == Layer)
     return (Arc);
   AddObjectToMoveToLayerUndoList (ARC_TYPE, Layer, Arc, Arc);
-  RestoreToPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
+  RestoreToPours (PCB->Data, ARC_TYPE, Layer, Arc);
   if (Layer->On)
     EraseArc (Arc);
   new = MoveArcToLayerLowLevel (Layer, Arc, Dest);
-  ClearFromPolygon (PCB->Data, ARC_TYPE, Dest, Arc);
+  ClearFromPours (PCB->Data, ARC_TYPE, Dest, Arc);
   if (Dest->On)
     DrawArc (Dest, new, 0);
   Draw ();
@@ -596,10 +655,10 @@ MoveLineToLayer (LayerTypePtr Layer, LineTypePtr Line)
   AddObjectToMoveToLayerUndoList (LINE_TYPE, Layer, Line, Line);
   if (Layer->On)
     EraseLine (Line);
-  RestoreToPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+  RestoreToPours (PCB->Data, LINE_TYPE, Layer, Line);
   new = MoveLineToLayerLowLevel (Layer, Line, Dest);
   Line = NULL;
-  ClearFromPolygon (PCB->Data, LINE_TYPE, Dest, new);
+  ClearFromPours (PCB->Data, LINE_TYPE, Dest, new);
   if (Dest->On)
     DrawLine (Dest, new, 0);
   Draw ();
@@ -650,7 +709,7 @@ MoveTextToLayerLowLevel (LayerTypePtr Source, TextTypePtr Text,
 {
   TextTypePtr new = GetTextMemory (Destination);
 
-  RestoreToPolygon (PCB->Data, TEXT_TYPE, Source, Text);
+  RestoreToPours (PCB->Data, TEXT_TYPE, Source, Text);
   r_delete_entry (Source->text_tree, (BoxTypePtr) Text);
   /* copy the data and remove it from the former layer */
   *new = *Text;
@@ -668,7 +727,7 @@ MoveTextToLayerLowLevel (LayerTypePtr Source, TextTypePtr Text,
   if (!Destination->text_tree)
     Destination->text_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (Destination->text_tree, (BoxTypePtr) new, 0);
-  ClearFromPolygon (PCB->Data, TEXT_TYPE, Destination, new);
+  ClearFromPours (PCB->Data, TEXT_TYPE, Destination, new);
   return (new);
 }
 
@@ -700,6 +759,8 @@ MoveTextToLayer (LayerTypePtr Layer, TextTypePtr Text)
   return (Text);
 }
 
+#warning FIXME Later
+#if 0
 /* ---------------------------------------------------------------------------
  * moves a polygon between layers; lowlevel routines
  */
@@ -722,6 +783,30 @@ MovePolygonToLayerLowLevel (LayerTypePtr Source, PolygonTypePtr Polygon,
   r_insert_entry (Destination->polygon_tree, (BoxType *) new, 0);
   return (new);
 }
+#endif
+
+/* ---------------------------------------------------------------------------
+ * moves a pour between layers; lowlevel routines
+ */
+void *
+MovePourToLayerLowLevel (LayerTypePtr Source, PourTypePtr Pour,
+			    LayerTypePtr Destination)
+{
+  PourTypePtr new = GetPourMemory (Destination);
+
+  r_delete_entry (Source->pour_tree, (BoxType *) Pour);
+  /* copy the data and remove it from the former layer */
+  *new = *Pour;
+  *Pour = Source->Pour[--Source->PourN];
+  r_substitute (Source->pour_tree,
+		(BoxType *) & Source->Pour[Source->PourN],
+		(BoxType *) Pour);
+  memset (&Source->Pour[Source->PourN], 0, sizeof (PourType));
+  if (!Destination->pour_tree)
+    Destination->pour_tree = r_create_tree (NULL, 0, 0);
+  r_insert_entry (Destination->pour_tree, (BoxType *) new, 0);
+  return (new);
+}
 
 struct mptlc
 {
@@ -748,6 +833,8 @@ mptl_pin_callback (const BoxType *b, void *cl)
   return 1;
 }
 
+#warning FIXME Later
+#if 0
 /* ---------------------------------------------------------------------------
  * moves a polygon between layers
  */
@@ -784,6 +871,47 @@ MovePolygonToLayer (LayerTypePtr Layer, PolygonTypePtr Polygon)
     }
   return (new);
 }
+#endif
+
+/* ---------------------------------------------------------------------------
+ * moves a pour between layers
+ */
+static void *
+MovePourToLayer (LayerTypePtr Layer, PourTypePtr Pour)
+{
+  PourTypePtr new;
+//  struct mptlc d;
+
+  if (TEST_FLAG (LOCKFLAG, Pour))
+    {
+      Message (_("Sorry, the object is locked\n"));
+      return NULL;
+    }
+  if (((long int) Dest == -1) || (Layer == Dest))
+    return (Pour);
+  AddObjectToMoveToLayerUndoList (POUR_TYPE, Layer, Pour, Pour);
+  if (Layer->On)
+    ErasePour (Pour);
+#define FIXME Later
+#if 0
+  /* Move all of the thermals with the pour */
+  d.snum = GetLayerNumber (PCB->Data, Layer);
+  d.dnum = GetLayerNumber (PCB->Data, Dest);
+  d.pour = Pour;
+  d.type = PIN_TYPE;
+  r_search (PCB->Data->pin_tree, &Pour->BoundingBox, NULL, mptl_pin_callback, &d);
+  d.type = VIA_TYPE;
+  r_search (PCB->Data->via_tree, &Pour->BoundingBox, NULL, mptl_pin_callback, &d);
+#endif
+  new = MovePourToLayerLowLevel (Layer, Pour, Dest);
+  InitPourClip (PCB->Data, Dest, new);
+  if (Dest->On)
+    {
+      DrawPour (Dest, new, 0);
+      Draw ();
+    }
+  return (new);
+}
 
 /* ---------------------------------------------------------------------------
  * moves the object identified by its data pointers and the type
diff --git a/src/move.h b/src/move.h
index f060ff5..5bc9f21 100644
--- a/src/move.h
+++ b/src/move.h
@@ -94,6 +94,7 @@
  * prototypes
  */
 void MovePolygonLowLevel (PolygonTypePtr, LocationType, LocationType);
+void MovePourLowLevel (PourTypePtr, LocationType, LocationType);
 void MoveElementLowLevel (DataTypePtr, ElementTypePtr, LocationType,
 			  LocationType);
 void *MoveObject (int, void *, void *, void *, LocationType, LocationType);
diff --git a/src/mtspace.c b/src/mtspace.c
index ee098de..fe5e374 100644
--- a/src/mtspace.c
+++ b/src/mtspace.c
@@ -380,7 +380,7 @@ mtspace_query_rect (mtspace_t * mtspace, const BoxType * region,
   assert (free_space_vec && vector_is_empty (free_space_vec));
   assert (lo_conflict_space_vec && vector_is_empty (lo_conflict_space_vec));
   assert (hi_conflict_space_vec && vector_is_empty (hi_conflict_space_vec));
-  assert (untested && no_fix && no_hi && hi_candidate);
+//  assert (untested && no_fix && no_hi && hi_candidate);
   /* search out to anything that might matter */
   if (region)
     {
diff --git a/src/mymem.c b/src/mymem.c
index ffa4dad..6c81603 100644
--- a/src/mymem.c
+++ b/src/mymem.c
@@ -399,32 +399,65 @@ GetTextMemory (LayerTypePtr Layer)
 }
 
 /* ---------------------------------------------------------------------------
+ * get next slot for a pour polygon object, allocates memory if necessary
+ */
+PourTypePtr
+GetPourMemory (LayerTypePtr Layer)
+{
+  PourTypePtr pour = Layer->Pour;
+
+  /* realloc new memory if necessary and clear it */
+  if (Layer->PourN >= Layer->PourMax)
+    {
+      Layer->PourMax += STEP_POUR;
+      if (Layer->pour_tree)
+	r_destroy_tree (&Layer->pour_tree);
+      pour = MyRealloc (pour, Layer->PourMax * sizeof (PourType),
+			   "GetPourMemory()");
+      Layer->Pour = pour;
+      memset (pour + Layer->PourN, 0,
+	      STEP_POUR * sizeof (PourType));
+      Layer->pour_tree = r_create_tree (NULL, 0, 0);
+      POUR_LOOP (Layer);
+      {
+	r_insert_entry (Layer->pour_tree, (BoxType *) pour, 0);
+      }
+      END_LOOP;
+    }
+  return (pour + Layer->PourN++);
+}
+
+/* ---------------------------------------------------------------------------
  * get next slot for a polygon object, allocates memory if necessary
  */
 PolygonTypePtr
-GetPolygonMemory (LayerTypePtr Layer)
+GetPolygonMemoryInPour (PourTypePtr Pour)
 {
-  PolygonTypePtr polygon = Layer->Polygon;
+  PolygonTypePtr polygon = Pour->Polygons;
 
   /* realloc new memory if necessary and clear it */
-  if (Layer->PolygonN >= Layer->PolygonMax)
+  if (Pour->PolygonN >= Pour->PolygonMax)
     {
-      Layer->PolygonMax += STEP_POLYGON;
-      if (Layer->polygon_tree)
-	r_destroy_tree (&Layer->polygon_tree);
-      polygon = MyRealloc (polygon, Layer->PolygonMax * sizeof (PolygonType),
-			   "GetPolygonMemory()");
-      Layer->Polygon = polygon;
-      memset (polygon + Layer->PolygonN, 0,
+      Pour->PolygonMax += STEP_POLYGON;
+#warning FIXME Later: r-tree polygons in a pour
+//      if (Pour->polygon_tree)
+//	r_destroy_tree (&Layer->polygon_tree);
+      polygon = MyRealloc (polygon, Pour->PolygonMax * sizeof (PolygonType),
+			   "GetPolygonMemoryInPour()");
+      Pour->Polygons = polygon;
+      memset (polygon + Pour->PolygonN, 0,
 	      STEP_POLYGON * sizeof (PolygonType));
-      Layer->polygon_tree = r_create_tree (NULL, 0, 0);
-      POLYGON_LOOP (Layer);
+#warning FIXME Later: r-tree polygons in a pour
+#if 0
+      Pour->polygon_tree = r_create_tree (NULL, 0, 0);
+      POURPOLYGON_LOOP (Pour);
       {
-	r_insert_entry (Layer->polygon_tree, (BoxType *) polygon, 0);
+	r_insert_entry (Pour->polygon_tree, (BoxType *) polygon, 0);
       }
       END_LOOP;
+#endif
     }
-  return (polygon + Layer->PolygonN++);
+  return (polygon + Pour->PolygonN++);
 }
 
 /* ---------------------------------------------------------------------------
@@ -434,6 +467,9 @@ GetPolygonMemory (LayerTypePtr Layer)
 PointTypePtr
 GetPointMemoryInPolygon (PolygonTypePtr Polygon)
 {
+  return NULL;
+#warning FIXME Later
+#if 0
   PointTypePtr points = Polygon->Points;
 
   /* realloc new memory if necessary and clear it */
@@ -447,6 +483,29 @@ GetPointMemoryInPolygon (PolygonTypePtr Polygon)
 	      STEP_POLYGONPOINT * sizeof (PointType));
     }
   return (points + Polygon->PointN++);
+#endif
+}
+
+/* ---------------------------------------------------------------------------
+ * gets the next slot for a point in a pour struct, allocates memory
+ * if necessary
+ */
+PointTypePtr
+GetPointMemoryInPour (PourTypePtr Pour)
+{
+  PointTypePtr points = Pour->Points;
+
+  /* realloc new memory if necessary and clear it */
+  if (Pour->PointN >= Pour->PointMax)
+    {
+      Pour->PointMax += STEP_POLYGONPOINT;
+      points = MyRealloc (points, Pour->PointMax * sizeof (PointType),
+			  "GetPointMemoryInPour()");
+      Pour->Points = points;
+      memset (points + Pour->PointN, 0,
+	      STEP_POLYGONPOINT * sizeof (PointType));
+    }
+  return (points + Pour->PointN++);
 }
 
 /* ---------------------------------------------------------------------------
@@ -724,13 +783,34 @@ FreePolygonMemory (PolygonTypePtr Polygon)
 {
   if (Polygon)
     {
-      MYFREE (Polygon->Points);
+//      MYFREE (Polygon->Points);
       if (Polygon->Clipped)
 	poly_Free (&Polygon->Clipped);
       if (Polygon->NoHoles)
 	poly_Free (&Polygon->NoHoles);
       memset (Polygon, 0, sizeof (PolygonType));
     }
+#warning FIXME Later: Need to ensure the pour structures are fixed up
+}
+
+/* ---------------------------------------------------------------------------
+ * frees memory used by a pour
+ */
+void
+FreePourMemory (PourTypePtr Pour)
+{
+  if (Pour)
+    {
+      MYFREE (Pour->Points);
+#define FIXME Later
+#if 0
+      if (Pour->Clipped)
+	poly_Free (&Pour->Clipped);
+      if (Pour->NoHoles)
+	poly_Free (&Pour->NoHoles);
+#endif
+      memset (Pour, 0, sizeof (PourType));
+    }
 }
 
 /* ---------------------------------------------------------------------------
@@ -897,12 +977,21 @@ FreeDataMemory (DataTypePtr Data)
 	  MYFREE (layer->Line);
 	  MYFREE (layer->Arc);
 	  MYFREE (layer->Text);
+#warning FIXME Later
+#if 0
 	  POLYGON_LOOP (layer);
 	  {
 	    FreePolygonMemory (polygon);
 	  }
 	  END_LOOP;
-	  MYFREE (layer->Polygon);
+#endif
+//	  MYFREE (layer->Polygon);
+	  POUR_LOOP (layer);
+	  {
+	    FreePourMemory (pour);
+	  }
+	  END_LOOP;
+	  MYFREE (layer->Pour);
 	  if (layer->line_tree)
 	    r_destroy_tree (&layer->line_tree);
 	  if (layer->arc_tree)
@@ -911,6 +1000,8 @@ FreeDataMemory (DataTypePtr Data)
 	    r_destroy_tree (&layer->text_tree);
 	  if (layer->polygon_tree)
 	    r_destroy_tree (&layer->polygon_tree);
+	  if (layer->pour_tree)
+	    r_destroy_tree (&layer->pour_tree);
 	}
 
       if (Data->element_tree)
diff --git a/src/mymem.h b/src/mymem.h
index b9d4de1..2732539 100644
--- a/src/mymem.h
+++ b/src/mymem.h
@@ -56,6 +56,7 @@
 #define	STEP_SELECTORENTRY	128
 #define	STEP_REMOVELIST		500
 #define	STEP_UNDOLIST		500
+#define	STEP_POUR		10
 #define	STEP_POLYGON		10
 #define	STEP_POLYGONPOINT	10
 #define	STEP_LIBRARYMENU	10
@@ -80,8 +81,10 @@ LineTypePtr GetLineMemory (LayerTypePtr);
 ArcTypePtr GetArcMemory (LayerTypePtr);
 RatTypePtr GetRatMemory (DataTypePtr);
 TextTypePtr GetTextMemory (LayerTypePtr);
-PolygonTypePtr GetPolygonMemory (LayerTypePtr);
+PolygonTypePtr GetPolygonMemoryInPour (PourTypePtr);
+PourTypePtr GetPourMemory (LayerTypePtr);
 PointTypePtr GetPointMemoryInPolygon (PolygonTypePtr);
+PointTypePtr GetPointMemoryInPour (PourTypePtr);
 ElementTypePtr GetElementMemory (DataTypePtr);
 BoxTypePtr GetBoxMemory (BoxListTypePtr);
 ConnectionTypePtr GetConnectionMemory (NetTypePtr);
@@ -100,6 +103,7 @@ char *MyStrdup (char *s, const char *);
 /* void MyFree (void **); */
 #define MYFREE(x) do { SaveFree(x); (x)=NULL; } while (0)
 void FreePolygonMemory (PolygonTypePtr);
+void FreePourMemory (PourTypePtr);
 void FreeElementMemory (ElementTypePtr);
 void FreePCBMemory (PCBTypePtr);
 void FreeBoxListMemory (BoxListTypePtr);
diff --git a/src/parse_y.y b/src/parse_y.y
index 480cad5..3881750 100644
--- a/src/parse_y.y
+++ b/src/parse_y.y
@@ -52,6 +52,7 @@
 #include "misc.h"
 #include "parse_l.h"
 #include "polygon.h"
+#include "pour.h"
 #include "remove.h"
 #include "rtree.h"
 #include "strflags.h"
@@ -64,7 +65,7 @@
 RCSID("$Id$");
 
 static	LayerTypePtr	Layer;
-static	PolygonTypePtr	Polygon;
+static	PourTypePtr	Pour;
 static	SymbolTypePtr	Symbol;
 static	int		pin_num;
 static	LibraryMenuTypePtr	Menu;
@@ -188,8 +189,8 @@ parsepcb
 			 */
 			PCB = yyPCB;
 			for (i = 0; i < yyData->LayerN+2; i++)
-			  for (j = 0; j < yyData->Layer[i].PolygonN; j++)
-			      InitClip (yyData, &yyData->Layer[i], &yyData->Layer[i].Polygon[j]);
+			  for (j = 0; j < yyData->Layer[i].PourN; j++)
+			      InitPourClip (yyData, &yyData->Layer[i], &yyData->Layer[i].Pour[j]);
 			PCB = pcb_save;
 			}
 			   
@@ -888,7 +889,7 @@ layerdefinition
 			/* x1, y1, x2, y2, flags */
 		| T_RECTANGLE '(' NUMBER NUMBER NUMBER NUMBER NUMBER ')'
 			{
-				CreateNewPolygonFromRectangle(Layer,
+				CreateNewPourFromRectangle(Layer,
 					$3*100, $4*100, ($3+$5)*100, ($4+$6)*100, OldFlags($7));
 			}
 		| text_hi_format
@@ -897,25 +898,25 @@ layerdefinition
 			/* flags are passed in */
 		| T_POLYGON '(' flags ')' '('
 			{
-				Polygon = CreateNewPolygon(Layer, $3);
+				Pour = CreateNewPour(Layer, $3);
 			}
 		  polygonpoints ')'
 		  	{
 					/* ignore junk */
-				if (Polygon->PointN >= 3)
+				if (Pour->PointN >= 3)
 				  {
-				    SetPolygonBoundingBox (Polygon);
-				    if (!Layer->polygon_tree)
-				      Layer->polygon_tree = r_create_tree (NULL, 0, 0);
-				    r_insert_entry (Layer->polygon_tree, (BoxType *) Polygon, 0);
+				    SetPourBoundingBox (Pour);
+				    if (!Layer->pour_tree)
+				      Layer->pour_tree = r_create_tree (NULL, 0, 0);
+				    r_insert_entry (Layer->pour_tree, (BoxType *) Pour, 0);
 				  }
 				else
 				{
 					Message("WARNING parsing file '%s'\n"
 						"    line:        %i\n"
-						"    description: 'ignored polygon (< 3 points)'\n",
+						"    description: 'ignored polygon pour (< 3 points)'\n",
 						yyfilename, yylineno);
-					DestroyObject(yyData, POLYGON_TYPE, Layer, Polygon, Polygon);
+					DestroyObject(yyData, POLYGON_TYPE, Layer, Pour, Pour);
 				}
 			}
 		;
@@ -1144,11 +1145,11 @@ polygonpoint
 			/* xcoord ycoord */
 		: '(' NUMBER NUMBER ')'
 			{
-				CreateNewPointInPolygon(Polygon, $2*100, $3*100);
+				CreateNewPointInPour(Pour, $2*100, $3*100);
 			}
 		| '[' NUMBER NUMBER ']'
 			{
-				CreateNewPointInPolygon(Polygon, $2, $3);
+				CreateNewPointInPour(Pour, $2, $3);
 			}
 		|
 		;
diff --git a/src/pcb-menu.res b/src/pcb-menu.res
index 1874a78..64a474b 100644
--- a/src/pcb-menu.res
+++ b/src/pcb-menu.res
@@ -166,7 +166,7 @@ MainMenu =
    {"Arc" checked=arcmode,1 Mode(Arc) a={"F3" "<Key>F3"}}
    {"Text" checked=textmode,1 Mode(Text) a={"F4" "<Key>F4"}}
    {"Rectangle" checked=rectanglemode,1 Mode(Rectangle) a={"F5" "<Key>F5"}}
-   {"Polygon" checked=polygonmode,1 Mode(Polygon) a={"F6" "<Key>F6"}}
+   {"Polygon" checked=pourmode,1 Mode(Pour) a={"F6" "<Key>F6"}}
    {"Buffer" checked=pastebuffermode,1 Mode(PasteBuffer) a={"F7" "<Key>F7"}}
    {"Remove" checked=removemode,1 Mode(Remove) a={"F8" "<Key>F8"}}
    {"Rotate" checked=rotatemode,1 Mode(Rotate) a={"F9" "<Key>F9"}}
diff --git a/src/polygon.c b/src/polygon.c
index 5c2d1f9..72ba2f9 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -65,8 +65,6 @@ RCSID ("$Id$");
 
 #define ROUND(x) ((long)(((x) >= 0 ? (x) + 0.5  : (x) - 0.5)))
 
-#define UNSUBTRACT_BLOAT 10
-
 /* ---------------------------------------------------------------------------
  * local prototypes
  */
@@ -120,6 +118,7 @@ ComputeNoHoles (PolygonType *poly)
   poly->NoHolesValid = 1;
 }
 
+#if 0
 static POLYAREA *
 biggest (POLYAREA * p)
 {
@@ -165,12 +164,14 @@ biggest (POLYAREA * p)
   assert (p->b);
   return p;
 }
+#endif
 
 POLYAREA *
 ContourToPoly (PLINE * contour)
 {
   POLYAREA *p;
   poly_PreContour (contour, TRUE);
+  poly_ChkContour (contour);
   assert (contour->Flags.orient == PLF_DIR);
   if (!(p = poly_Create ()))
     return NULL;
@@ -179,14 +180,17 @@ ContourToPoly (PLINE * contour)
   return p;
 }
 
+#warning FIXME Later
+#if 0
 static POLYAREA *
-original_poly (PolygonType * p)
+original_poly (PourType * p)
 {
+  return NULL;
   PLINE *contour = NULL;
   POLYAREA *np = NULL;
   Vector v;
 
-  /* first make initial polygon contour */
+  /* first make initial pour contour */
   POLYGONPOINT_LOOP (p);
   {
     v[0] = point->X;
@@ -223,9 +227,11 @@ original_poly (PolygonType * p)
   assert (poly_Valid (np));
   return biggest (np);
 }
+#endif
 
+#if 0
 static int
-ClipOriginal (PolygonType * poly)
+ClipOriginal (PourType * poly)
 {
   POLYAREA *p, *result;
   int r;
@@ -241,10 +247,12 @@ ClipOriginal (PolygonType * poly)
       poly->NoHoles = NULL;
       return 0;
     }
-  poly->Clipped = biggest (result);
+#warning FIXME Later
+//  poly->Clipped = biggest (result);
   assert (!poly->Clipped || poly_Valid (poly->Clipped));
   return 1;
 }
+#endif
 
 POLYAREA *
 RectPoly (LocationType x1, LocationType x2, LocationType y1, LocationType y2)
@@ -583,6 +591,8 @@ SquarePadPoly (PadType * pad, BDimension clear)
   return np;
 }
 
+#warning FIXME Later
+#if 0
 /* clear np1 from the polygon */
 static int
 Subtract (POLYAREA * np1, PolygonType * p, Boolean fnp)
@@ -616,7 +626,9 @@ Subtract (POLYAREA * np1, PolygonType * p, Boolean fnp)
       p->NoHoles = NULL;
       return -1;
     }
-  p->Clipped = biggest (merged);
+#warning FIXME Later
+//  p->Clipped = biggest (merged);
+  p->Clipped = merged;
   assert (!p->Clipped || poly_Valid (p->Clipped));
   if (!p->Clipped)
     Message ("Polygon cleared out of existence near (%d, %d)\n",
@@ -624,6 +636,7 @@ Subtract (POLYAREA * np1, PolygonType * p, Boolean fnp)
              (p->BoundingBox.Y1 + p->BoundingBox.Y2) / 2);
   return 1;
 }
+#endif
 
 /* create a polygon of the pin clearance */
 POLYAREA *
@@ -655,416 +668,17 @@ BoxPolyBloated (BoxType *box, BDimension bloat)
                    box->Y1 - bloat, box->Y2 + bloat);
 }
 
-/* remove the pin clearance from the polygon */
-static int
-SubtractPin (DataType * d, PinType * pin, LayerType * l, PolygonType * p)
-{
-  POLYAREA *np;
-  Cardinal i;
-
-  if (pin->Clearance == 0)
-    return 0;
-  i = GetLayerNumber (d, l);
-  if (TEST_THERM (i, pin))
-    {
-      np = ThermPoly ((PCBTypePtr) (d->pcb), pin, i);
-      if (!np)
-        return 0;
-    }
-  else
-    {
-      np = PinPoly (pin, pin->Thickness, pin->Clearance);
-      if (!np)
-        return -1;
-    }
-  return Subtract (np, p, TRUE);
-}
-
-static int
-SubtractLine (LineType * line, PolygonType * p)
-{
-  POLYAREA *np;
-
-  if (!TEST_FLAG (CLEARLINEFLAG, line))
-    return 0;
-  if (!(np = LinePoly (line, line->Thickness + line->Clearance)))
-    return -1;
-  return Subtract (np, p, True);
-}
-
-static int
-SubtractArc (ArcType * arc, PolygonType * p)
-{
-  POLYAREA *np;
-
-  if (!TEST_FLAG (CLEARLINEFLAG, arc))
-    return 0;
-  if (!(np = ArcPoly (arc, arc->Thickness + arc->Clearance)))
-    return -1;
-  return Subtract (np, p, True);
-}
-
-static int
-SubtractText (TextType * text, PolygonType * p)
-{
-  POLYAREA *np;
-  const BoxType *b = &text->BoundingBox;
-
-  if (!TEST_FLAG (CLEARLINEFLAG, text))
-    return 0;
-  if (!(np = RoundRect (b->X1 + PCB->Bloat, b->X2 - PCB->Bloat,
-                        b->Y1 + PCB->Bloat, b->Y2 - PCB->Bloat, PCB->Bloat)))
-    return -1;
-  return Subtract (np, p, True);
-}
-
-static int
-SubtractPad (PadType * pad, PolygonType * p)
-{
-  POLYAREA *np = NULL;
-
-  if (TEST_FLAG (SQUAREFLAG, pad))
-    {
-      if (!
-          (np = SquarePadPoly (pad, pad->Thickness + pad->Clearance)))
-        return -1;
-    }
-  else
-    {
-      if (!
-          (np = LinePoly ((LineType *) pad, pad->Thickness + pad->Clearance)))
-        return -1;
-    }
-  return Subtract (np, p, True);
-}
-
-static int
-SubtractPolygon (PolygonType * poly, PolygonType * p)
-{
-  POLYAREA *np;
-
-  /* Don't subtract from ourselves! */
-  if (poly == p || !TEST_FLAG (CLEARLINEFLAG, poly))
-    return 0;
-
-  np = original_poly (poly);
-
-  return Subtract (np, p, True);
-}
-
-struct cpInfo
-{
-  const BoxType *other;
-  DataType *data;
-  LayerType *layer;
-  PolygonType *polygon;
-  Boolean solder;
-  jmp_buf env;
-};
-
-static int
-pin_sub_callback (const BoxType * b, void *cl)
-{
-  PinTypePtr pin = (PinTypePtr) b;
-  struct cpInfo *info = (struct cpInfo *) cl;
-  PolygonTypePtr polygon;
-
-  /* don't subtract the object that was put back! */
-  if (b == info->other)
-    return 0;
-  polygon = info->polygon;
-  if (SubtractPin (info->data, pin, info->layer, polygon) < 0)
-    longjmp (info->env, 1);
-  return 1;
-}
-
-static int
-arc_sub_callback (const BoxType * b, void *cl)
-{
-  ArcTypePtr arc = (ArcTypePtr) b;
-  struct cpInfo *info = (struct cpInfo *) cl;
-  PolygonTypePtr polygon;
-
-  /* don't subtract the object that was put back! */
-  if (b == info->other)
-    return 0;
-  if (!TEST_FLAG (CLEARLINEFLAG, arc))
-    return 0;
-  polygon = info->polygon;
-  if (SubtractArc (arc, polygon) < 0)
-    longjmp (info->env, 1);
-  return 1;
-}
-
-static int
-pad_sub_callback (const BoxType * b, void *cl)
-{
-  PadTypePtr pad = (PadTypePtr) b;
-  struct cpInfo *info = (struct cpInfo *) cl;
-  PolygonTypePtr polygon;
-
-  /* don't subtract the object that was put back! */
-  if (b == info->other)
-    return 0;
-  polygon = info->polygon;
-  if (XOR (TEST_FLAG (ONSOLDERFLAG, pad), !info->solder))
-    {
-      if (SubtractPad (pad, polygon) < 0)
-        longjmp (info->env, 1);
-      return 1;
-    }
-  return 0;
-}
-
-static int
-line_sub_callback (const BoxType * b, void *cl)
-{
-  LineTypePtr line = (LineTypePtr) b;
-  struct cpInfo *info = (struct cpInfo *) cl;
-  PolygonTypePtr polygon;
-
-  /* don't subtract the object that was put back! */
-  if (b == info->other)
-    return 0;
-  if (!TEST_FLAG (CLEARLINEFLAG, line))
-    return 0;
-  polygon = info->polygon;
-  if (SubtractLine (line, polygon) < 0)
-    longjmp (info->env, 1);
-  return 1;
-}
-
-static int
-text_sub_callback (const BoxType * b, void *cl)
-{
-  TextTypePtr text = (TextTypePtr) b;
-  struct cpInfo *info = (struct cpInfo *) cl;
-  PolygonTypePtr polygon;
-
-  /* don't subtract the object that was put back! */
-  if (b == info->other)
-    return 0;
-  if (!TEST_FLAG (CLEARLINEFLAG, text))
-    return 0;
-  polygon = info->polygon;
-  if (SubtractText (text, polygon) < 0)
-    longjmp (info->env, 1);
-  return 1;
-}
-
-static int
-poly_sub_callback (const BoxType * b, void *cl)
-{
-  PolygonTypePtr poly = (PolygonTypePtr) b;
-  struct cpInfo *info = (struct cpInfo *) cl;
-  PolygonTypePtr polygon;
-
-  /* don't subtract the object that was put back! */
-  if (b == info->other)
-    return 0;
-  if (!TEST_FLAG (CLEARLINEFLAG, poly))
-    return 0;
-  polygon = info->polygon;
-  if (SubtractPolygon (poly, polygon) < 0)
-    longjmp (info->env, 1);
-  return 1;
-}
-
-static int
-Group (DataTypePtr Data, Cardinal layer)
-{
-  Cardinal i, j;
-  for (i = 0; i < max_layer; i++)
-    for (j = 0; j < ((PCBType *) (Data->pcb))->LayerGroups.Number[i]; j++)
-      if (layer == ((PCBType *) (Data->pcb))->LayerGroups.Entries[i][j])
-        return i;
-  return i;
-}
-
-static int
-clearPoly (DataTypePtr Data, LayerTypePtr Layer, PolygonType * polygon,
-           const BoxType * here, BDimension expand)
-{
-  int r = 0;
-  BoxType region;
-  struct cpInfo info;
-  Cardinal group;
-
-  if (!TEST_FLAG (CLEARPOLYFLAG, polygon)
-      || GetLayerNumber (Data, Layer) >= max_layer)
-    return 0;
-  group = Group (Data, GetLayerNumber (Data, Layer));
-  info.solder = (group == Group (Data, max_layer + SOLDER_LAYER));
-  info.data = Data;
-  info.other = here;
-  info.layer = Layer;
-  info.polygon = polygon;
-  if (here)
-    region = clip_box (here, &polygon->BoundingBox);
-  else
-    region = polygon->BoundingBox;
-  region = bloat_box (&region, expand);
-
-  if (setjmp (info.env) == 0)
-    {
-      r = r_search (Data->via_tree, &region, NULL, pin_sub_callback, &info);
-      r += r_search (Data->pin_tree, &region, NULL, pin_sub_callback, &info);
-      GROUP_LOOP (Data, group);
-      {
-        r +=
-          r_search (layer->line_tree, &region, NULL, line_sub_callback,
-                    &info);
-        r +=
-          r_search (layer->arc_tree, &region, NULL, arc_sub_callback, &info);
-	r +=
-          r_search (layer->text_tree, &region, NULL, text_sub_callback, &info);
-        r +=
-          r_search (layer->polygon_tree, &region, NULL, poly_sub_callback, &info);
-      }
-      END_LOOP;
-      if (info.solder || group == Group (Data, max_layer + COMPONENT_LAYER))
-	r += r_search (Data->pad_tree, &region, NULL, pad_sub_callback, &info);
-    }
-  polygon->NoHolesValid = 0;
-  return r;
-}
-
-static int
-Unsubtract (POLYAREA * np1, PolygonType * p)
-{
-  POLYAREA *merged = NULL, *np = np1;
-  int x;
-  assert (np);
-  assert (p && p->Clipped);
-  x = poly_Boolean_free (p->Clipped, np, &merged, PBO_UNITE);
-  if (x != err_ok)
-    {
-      fprintf (stderr, "Error while clipping PBO_UNITE: %d\n", x);
-      poly_Free (&merged);
-      p->Clipped = NULL;
-      if (p->NoHoles) printf ("Just leaked in Unsubtract\n");
-      p->NoHoles = NULL;
-      return 0;
-    }
-  p->Clipped = biggest (merged);
-  assert (!p->Clipped || poly_Valid (p->Clipped));
-  return ClipOriginal (p);
-}
-
-static int
-UnsubtractPin (PinType * pin, LayerType * l, PolygonType * p)
-{
-  POLYAREA *np;
-
-  /* overlap a bit to prevent gaps from rounding errors */
-  np = BoxPolyBloated (&pin->BoundingBox, UNSUBTRACT_BLOAT);
-
-  if (!np)
-    return 0;
-  if (!Unsubtract (np, p))
-    return 0;
-  clearPoly (PCB->Data, l, p, (const BoxType *) pin, 2 * UNSUBTRACT_BLOAT);
-  return 1;
-}
-
-static int
-UnsubtractArc (ArcType * arc, LayerType * l, PolygonType * p)
-{
-  POLYAREA *np;
-
-  if (!TEST_FLAG (CLEARLINEFLAG, arc))
-    return 0;
-
-  /* overlap a bit to prevent gaps from rounding errors */
-  np = BoxPolyBloated (&arc->BoundingBox, UNSUBTRACT_BLOAT);
-
-  if (!np)
-    return 0;
-  if (!Unsubtract (np, p))
-    return 0;
-  clearPoly (PCB->Data, l, p, (const BoxType *) arc, 2 * UNSUBTRACT_BLOAT);
-  return 1;
-}
-
-static int
-UnsubtractLine (LineType * line, LayerType * l, PolygonType * p)
-{
-  POLYAREA *np;
-
-  if (!TEST_FLAG (CLEARLINEFLAG, line))
-    return 0;
-
-  /* overlap a bit to prevent notches from rounding errors */
-  np = BoxPolyBloated (&line->BoundingBox, UNSUBTRACT_BLOAT);
-
-  if (!np)
-    return 0;
-  if (!Unsubtract (np, p))
-    return 0;
-  clearPoly (PCB->Data, l, p, (const BoxType *) line, 2 * UNSUBTRACT_BLOAT);
-  return 1;
-}
-
-static int
-UnsubtractText (TextType * text, LayerType * l, PolygonType * p)
-{
-  POLYAREA *np;
-
-  if (!TEST_FLAG (CLEARLINEFLAG, text))
-    return 0;
-
-  /* overlap a bit to prevent notches from rounding errors */
-  np = BoxPolyBloated (&text->BoundingBox, UNSUBTRACT_BLOAT);
-
-  if (!np)
-    return -1;
-  if (!Unsubtract (np, p))
-    return 0;
-  clearPoly (PCB->Data, l, p, (const BoxType *) text, 2 * UNSUBTRACT_BLOAT);
-  return 1;
-}
-
-static int
-UnsubtractPad (PadType * pad, LayerType * l, PolygonType * p)
-{
-  POLYAREA *np;
-
-  /* overlap a bit to prevent notches from rounding errors */
-  np = BoxPolyBloated (&pad->BoundingBox, UNSUBTRACT_BLOAT);
-
-  if (!np)
-    return 0;
-  if (!Unsubtract (np, p))
-    return 0;
-  clearPoly (PCB->Data, l, p, (const BoxType *) pad, 2 * UNSUBTRACT_BLOAT);
-  return 1;
-}
-
-static int
-UnsubtractPolygon (PolygonType * poly, LayerType * l, PolygonType * p)
-{
-  POLYAREA *np;
-
-  /* Don't subtract from ourselves! */
-  if (poly == p || !TEST_FLAG (CLEARLINEFLAG, poly))
-    return 0;
-
-  /* overlap a bit to prevent notches from rounding errors */
-  np = BoxPolyBloated (&poly->BoundingBox, UNSUBTRACT_BLOAT);
-
-  if (!np)
-    return 0;
-  if (!Unsubtract (np, p))
-    return 0;
-  clearPoly (PCB->Data, l, p, (const BoxType *) poly, 2 * UNSUBTRACT_BLOAT);
-  return 1;
-}
-
-static Boolean inhibit = False;
+#warning FIXME Later
+//static Boolean inhibit = False;
 
 int
 InitClip (DataTypePtr Data, LayerTypePtr layer, PolygonType * p)
 {
+  /* NOP */
+  printf ("Someone called InitClip, bad someone.\n");
+  return 0;
+#warning FIXME Later
+#if 0
   if (inhibit)
     return 0;
   if (p->Clipped)
@@ -1081,205 +695,7 @@ InitClip (DataTypePtr Data, LayerTypePtr layer, PolygonType * p)
   else
     p->NoHolesValid = 0;
   return 1;
-}
-
-/* --------------------------------------------------------------------------
- * remove redundant polygon points. Any point that lies on the straight
- * line between the points on either side of it is redundant.
- * returns true if any points are removed
- */
-Boolean
-RemoveExcessPolygonPoints (LayerTypePtr Layer, PolygonTypePtr Polygon)
-{
-  PointTypePtr pt1, pt2, pt3;
-  Cardinal n;
-  LineType line;
-  Boolean changed = False;
-
-  if (Undoing ())
-    return (False);
-  /* there are always at least three points in a polygon */
-  pt1 = &Polygon->Points[Polygon->PointN - 1];
-  pt2 = &Polygon->Points[0];
-  pt3 = &Polygon->Points[1];
-  for (n = 0; n < Polygon->PointN; n++, pt1++, pt2++, pt3++)
-    {
-      /* wrap around polygon */
-      if (n == 1)
-        pt1 = &Polygon->Points[0];
-      if (n == Polygon->PointN - 1)
-        pt3 = &Polygon->Points[0];
-      line.Point1 = *pt1;
-      line.Point2 = *pt3;
-      line.Thickness = 0;
-      if (IsPointOnLine ((float) pt2->X, (float) pt2->Y, 0.0, &line))
-        {
-          RemoveObject (POLYGONPOINT_TYPE, (void *) Layer, (void *) Polygon,
-                        (void *) pt2);
-          changed = True;
-        }
-    }
-  return (changed);
-}
-
-/* ---------------------------------------------------------------------------
- * returns the index of the polygon point which is the end
- * point of the segment with the lowest distance to the passed
- * coordinates
- */
-Cardinal
-GetLowestDistancePolygonPoint (PolygonTypePtr Polygon, LocationType X,
-                               LocationType Y)
-{
-  double mindistance = (double) MAX_COORD * MAX_COORD;
-  PointTypePtr ptr1 = &Polygon->Points[Polygon->PointN - 1],
-    ptr2 = &Polygon->Points[0];
-  Cardinal n, result = 0;
-
-  /* we calculate the distance to each segment and choose the
-   * shortest distance. If the closest approach between the
-   * given point and the projected line (i.e. the segment extended)
-   * is not on the segment, then the distance is the distance
-   * to the segment end point.
-   */
-
-  for (n = 0; n < Polygon->PointN; n++, ptr2++)
-    {
-      register double u, dx, dy;
-      dx = ptr2->X - ptr1->X;
-      dy = ptr2->Y - ptr1->Y;
-      if (dx != 0.0 || dy != 0.0)
-        {
-          /* projected intersection is at P1 + u(P2 - P1) */
-          u = ((X - ptr1->X) * dx + (Y - ptr1->Y) * dy) / (dx * dx + dy * dy);
-
-          if (u < 0.0)
-            {                   /* ptr1 is closest point */
-              u = SQUARE (X - ptr1->X) + SQUARE (Y - ptr1->Y);
-            }
-          else if (u > 1.0)
-            {                   /* ptr2 is closest point */
-              u = SQUARE (X - ptr2->X) + SQUARE (Y - ptr2->Y);
-            }
-          else
-            {                   /* projected intersection is closest point */
-              u = SQUARE (X - ptr1->X * (1.0 - u) - u * ptr2->X) +
-                SQUARE (Y - ptr1->Y * (1.0 - u) - u * ptr2->Y);
-            }
-          if (u < mindistance)
-            {
-              mindistance = u;
-              result = n;
-            }
-        }
-      ptr1 = ptr2;
-    }
-  return (result);
-}
-
-/* ---------------------------------------------------------------------------
- * go back to the  previous point of the polygon
- */
-void
-GoToPreviousPoint (void)
-{
-  switch (Crosshair.AttachedPolygon.PointN)
-    {
-      /* do nothing if mode has just been entered */
-    case 0:
-      break;
-
-      /* reset number of points and 'LINE_MODE' state */
-    case 1:
-      Crosshair.AttachedPolygon.PointN = 0;
-      Crosshair.AttachedLine.State = STATE_FIRST;
-      addedLines = 0;
-      break;
-
-      /* back-up one point */
-    default:
-      {
-        PointTypePtr points = Crosshair.AttachedPolygon.Points;
-        Cardinal n = Crosshair.AttachedPolygon.PointN - 2;
-
-        Crosshair.AttachedPolygon.PointN--;
-        Crosshair.AttachedLine.Point1.X = points[n].X;
-        Crosshair.AttachedLine.Point1.Y = points[n].Y;
-        break;
-      }
-    }
-}
-
-/* ---------------------------------------------------------------------------
- * close polygon if possible
- */
-void
-ClosePolygon (void)
-{
-  Cardinal n = Crosshair.AttachedPolygon.PointN;
-
-  /* check number of points */
-  if (n >= 3)
-    {
-      /* if 45 degree lines are what we want do a quick check
-       * if closing the polygon makes sense
-       */
-      if (!TEST_FLAG (ALLDIRECTIONFLAG, PCB))
-        {
-          BDimension dx, dy;
-
-          dx = abs (Crosshair.AttachedPolygon.Points[n - 1].X -
-                    Crosshair.AttachedPolygon.Points[0].X);
-          dy = abs (Crosshair.AttachedPolygon.Points[n - 1].Y -
-                    Crosshair.AttachedPolygon.Points[0].Y);
-          if (!(dx == 0 || dy == 0 || dx == dy))
-            {
-              Message
-                (_
-                 ("Cannot close polygon because 45 degree lines are requested.\n"));
-              return;
-            }
-        }
-      CopyAttachedPolygonToLayer ();
-      Draw ();
-    }
-  else
-    Message (_("A polygon has to have at least 3 points\n"));
-}
-
-/* ---------------------------------------------------------------------------
- * moves the data of the attached (new) polygon to the current layer
- */
-void
-CopyAttachedPolygonToLayer (void)
-{
-  PolygonTypePtr polygon;
-  int saveID;
-
-  /* move data to layer and clear attached struct */
-  polygon = CreateNewPolygon (CURRENT, NoFlags ());
-  saveID = polygon->ID;
-  *polygon = Crosshair.AttachedPolygon;
-  polygon->ID = saveID;
-  SET_FLAG (CLEARPOLYFLAG, polygon);
-  if (TEST_FLAG (NEWFULLPOLYFLAG, PCB))
-    SET_FLAG (FULLPOLYFLAG, polygon);
-  memset (&Crosshair.AttachedPolygon, 0, sizeof (PolygonType));
-  SetPolygonBoundingBox (polygon);
-  if (!CURRENT->polygon_tree)
-    CURRENT->polygon_tree = r_create_tree (NULL, 0, 0);
-  r_insert_entry (CURRENT->polygon_tree, (BoxType *) polygon, 0);
-  InitClip (PCB->Data, CURRENT, polygon);
-  DrawPolygon (CURRENT, polygon, 0);
-  SetChangedFlag (True);
-
-  /* reset state of attached line */
-  Crosshair.AttachedLine.State = STATE_FIRST;
-  addedLines = 0;
-
-  /* add to undo list */
-  AddObjectToCreateUndoList (POLYGON_TYPE, CURRENT, polygon, polygon);
-  IncrementUndoSerialNumber ();
+#endif
 }
 
 /* find polygon holes in range, then call the callback function for
@@ -1323,72 +739,6 @@ struct plow_info
 };
 
 static int
-subtract_plow (DataTypePtr Data, LayerTypePtr Layer, PolygonTypePtr Polygon,
-               int type, void *ptr1, void *ptr2)
-{
-  if (!Polygon->Clipped)
-    return 0;
-  switch (type)
-    {
-    case PIN_TYPE:
-    case VIA_TYPE:
-      SubtractPin (Data, (PinTypePtr) ptr2, Layer, Polygon);
-      Polygon->NoHolesValid = 0;
-      return 1;
-    case LINE_TYPE:
-      SubtractLine ((LineTypePtr) ptr2, Polygon);
-      Polygon->NoHolesValid = 0;
-      return 1;
-    case ARC_TYPE:
-      SubtractArc ((ArcTypePtr) ptr2, Polygon);
-      Polygon->NoHolesValid = 0;
-      return 1;
-    case PAD_TYPE:
-      SubtractPad ((PadTypePtr) ptr2, Polygon);
-      Polygon->NoHolesValid = 0;
-      return 1;
-    case POLYGON_TYPE:
-      SubtractPolygon ((PolygonTypePtr) ptr2, Polygon);
-      Polygon->NoHolesValid = 0;
-      return 1;
-    case TEXT_TYPE:
-      SubtractText ((TextTypePtr) ptr2, Polygon);
-      Polygon->NoHolesValid = 0;
-      return 1;
-    }
-  return 0;
-}
-
-static int
-add_plow (DataTypePtr Data, LayerTypePtr Layer, PolygonTypePtr Polygon,
-          int type, void *ptr1, void *ptr2)
-{
-  switch (type)
-    {
-    case PIN_TYPE:
-    case VIA_TYPE:
-      UnsubtractPin ((PinTypePtr) ptr2, Layer, Polygon);
-      return 1;
-    case LINE_TYPE:
-      UnsubtractLine ((LineTypePtr) ptr2, Layer, Polygon);
-      return 1;
-    case ARC_TYPE:
-      UnsubtractArc ((ArcTypePtr) ptr2, Layer, Polygon);
-      return 1;
-    case PAD_TYPE:
-      UnsubtractPad ((PadTypePtr) ptr2, Layer, Polygon);
-      return 1;
-    case POLYGON_TYPE:
-      UnsubtractPolygon ((PolygonTypePtr) ptr2, Layer, Polygon);
-      return 1;
-    case TEXT_TYPE:
-      UnsubtractText ((TextTypePtr) ptr2, Layer, Polygon);
-      return 1;
-    }
-  return 0;
-}
-
-static int
 plow_callback (const BoxType * b, void *cl)
 {
   struct plow_info *plow = (struct plow_info *) cl;
@@ -1424,8 +774,7 @@ PlowsPolygon (DataType * Data, int type, void *ptr1, void *ptr2,
           LAYER_LOOP (Data, max_layer);
           {
             info.layer = layer;
-            r +=
-              r_search (layer->polygon_tree, &sb, NULL, plow_callback, &info);
+            r += r_search (layer->polygon_tree, &sb, NULL, plow_callback, &info);
           }
           END_LOOP;
         }
@@ -1435,8 +784,7 @@ PlowsPolygon (DataType * Data, int type, void *ptr1, void *ptr2,
                                                                          ((LayerTypePtr) ptr1))));
           {
             info.layer = layer;
-            r +=
-              r_search (layer->polygon_tree, &sb, NULL, plow_callback, &info);
+            r += r_search (layer->polygon_tree, &sb, NULL, plow_callback, &info);
           }
           END_LOOP;
         }
@@ -1493,21 +841,29 @@ PlowsPolygon (DataType * Data, int type, void *ptr1, void *ptr2,
   return r;
 }
 
+#if 0
 void
 RestoreToPolygon (DataType * Data, int type, void *ptr1, void *ptr2)
 {
   if (type == POLYGON_TYPE)
-    InitClip (PCB->Data, (LayerTypePtr) ptr1, (PolygonTypePtr) ptr2);
-  PlowsPolygon (Data, type, ptr1, ptr2, add_plow);
+    {
+      printf ("Calling InitClip from RestoreToPolygon\n");
+      InitClip (PCB->Data, (LayerTypePtr) ptr1, (PolygonTypePtr) ptr2);
+    }
+//  PlowsPolygon (Data, type, ptr1, ptr2, add_plow);
 }
 
 void
 ClearFromPolygon (DataType * Data, int type, void *ptr1, void *ptr2)
 {
   if (type == POLYGON_TYPE)
-    InitClip (PCB->Data, (LayerTypePtr) ptr1, (PolygonTypePtr) ptr2);
-  PlowsPolygon (Data, type, ptr1, ptr2, subtract_plow);
+    {
+      printf ("Calling InitClip from ClearFromPolygon\n");
+      InitClip (PCB->Data, (LayerTypePtr) ptr1, (PolygonTypePtr) ptr2);
+    }
+//  PlowsPolygon (Data, type, ptr1, ptr2, subtract_plow);
 }
+#endif
 
 Boolean
 isects (POLYAREA * a, PolygonTypePtr p, Boolean fr)
@@ -1572,15 +928,17 @@ r_NoHolesPolygonDicer (PLINE * p, void (*emit) (PolygonTypePtr, void *), void *u
   if (!p->next)                 /* no holes */
     {
       PolygonType poly;
-      PointType pts[4];
+//      PointType pts[4];
 
       poly.BoundingBox.X1 = p->xmin;
       poly.BoundingBox.X2 = p->xmax;
       poly.BoundingBox.Y1 = p->ymin;
       poly.BoundingBox.Y2 = p->ymax;
-      poly.PointN = poly.PointMax = 4;
       poly.Clipped = pa;
       poly.NoHoles = NULL;
+#warning FIXME Later
+#if 0
+      poly.PointN = poly.PointMax = 4;
       poly.Points = pts;
       pts[0].X = pts[0].X2 = p->xmin;
       pts[0].Y = pts[0].Y2 = p->ymin;
@@ -1590,6 +948,7 @@ r_NoHolesPolygonDicer (PLINE * p, void (*emit) (PolygonTypePtr, void *), void *u
       pts[2].Y = pts[2].Y2 = p->ymax;
       pts[3].X = pts[3].X2 = p->xmin;
       pts[3].Y = pts[3].Y2 = p->ymax;
+#endif
       poly.Flags = MakeFlags (CLEARPOLYFLAG);
       emit (&poly, user_data);
       poly_Free (&pa);
@@ -1675,6 +1034,9 @@ NoHolesPolygonDicer (PolygonTypePtr p, void (*emit) (PolygonTypePtr, void *),
 Boolean
 MorphPolygon (LayerTypePtr layer, PolygonTypePtr poly)
 {
+  return 0;
+#warning FIXME Later
+#if 0
   POLYAREA *p, *start;
   Boolean many = False;
   FlagType flags;
@@ -1738,4 +1100,5 @@ MorphPolygon (LayerTypePtr layer, PolygonTypePtr poly)
   inhibit = False;
   IncrementUndoSerialNumber ();
   return many;
+#endif
 }
diff --git a/src/polygon.h b/src/polygon.h
index 8f444fd..e203d07 100644
--- a/src/polygon.h
+++ b/src/polygon.h
@@ -33,26 +33,25 @@
 
 #include "global.h"
 
-Cardinal GetLowestDistancePolygonPoint (PolygonTypePtr,
-					LocationType, LocationType);
-Boolean RemoveExcessPolygonPoints (LayerTypePtr, PolygonTypePtr);
-void GoToPreviousPoint (void);
-void ClosePolygon (void);
-void CopyAttachedPolygonToLayer (void);
 int PolygonHoles (const BoxType * range, LayerTypePtr, PolygonTypePtr,
 		  int (*callback) (PLINE *, LayerTypePtr, PolygonTypePtr));
 int PlowsPolygon (DataType *, int, void *, void *,
 		  int (*callback) (DataTypePtr, LayerTypePtr, PolygonTypePtr, int, void *, void *));
 void ComputeNoHoles (PolygonType *poly);
+
 POLYAREA * ContourToPoly (PLINE *);
 POLYAREA * RectPoly (LocationType x1, LocationType x2, LocationType y1, LocationType y2);
-POLYAREA * CirclePoly(LocationType x, LocationType y, BDimension radius);
 POLYAREA * OctagonPoly(LocationType x, LocationType y, BDimension radius);
-POLYAREA * LinePoly(LineType *l, BDimension thick);
+void frac_circle (PLINE *, LocationType, LocationType, Vector, int);
+POLYAREA * CirclePoly(LocationType x, LocationType y, BDimension radius);
+POLYAREA * RoundRect (LocationType x1, LocationType x2, LocationType y1, LocationType y2, BDimension t);
 POLYAREA * ArcPoly(ArcType *l, BDimension thick);
+POLYAREA * LinePoly(LineType *l, BDimension thick);
+POLYAREA * SquarePadPoly (PadType * pad, BDimension clear);
+
 POLYAREA * PinPoly(PinType *l, BDimension thick, BDimension clear);
 POLYAREA * BoxPolyBloated (BoxType *box, BDimension radius);
-void frac_circle (PLINE *, LocationType, LocationType, Vector, int);
+
 int InitClip(DataType *d, LayerType *l, PolygonType *p);
 void RestoreToPolygon(DataType *, int, void *, void *);
 void ClearFromPolygon(DataType *, int, void *, void *);
diff --git a/src/polygon1.c b/src/polygon1.c
index 32ffb31..606eb9a 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -835,6 +835,45 @@ intersect (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
 }
 
 static void
+M_POLYAREA_intersect2 (jmp_buf * e, POLYAREA * afst, POLYAREA * bfst, int add)
+{
+  POLYAREA *a = afst, *b = bfst;
+  PLINE *curcA, *curcB;
+  CVCList *the_list = NULL;
+
+  if (a == NULL || b == NULL)
+    error (err_bad_parm);
+  do
+    {
+      do
+	{
+	  if (a->contours->xmax >= b->contours->xmin &&
+	      a->contours->ymax >= b->contours->ymin &&
+	      a->contours->xmin <= b->contours->xmax &&
+	      a->contours->ymin <= b->contours->ymax)
+	    {
+	      if (intersect (e, a, b, add))
+		error (err_no_memory);
+	    }
+	}
+      while ((a = a->f) != afst);
+      for (curcB = b->contours; curcB != NULL; curcB = curcB->next)
+	if (curcB->Flags.status == ISECTED)
+	  if (!(the_list = add_descriptors (curcB, 'B', the_list)))
+	    error (err_no_memory);
+    }
+  while ((b = b->f) != bfst);
+  do
+    {
+      for (curcA = a->contours; curcA != NULL; curcA = curcA->next)
+	if (curcA->Flags.status == ISECTED)
+	  if (!(the_list = add_descriptors (curcA, 'A', the_list)))
+	    error (err_no_memory);
+    }
+  while ((a = a->f) != afst);
+}				/* M_POLYAREA_intersect */
+
+static void
 M_POLYAREA_intersect (jmp_buf * e, POLYAREA * afst, POLYAREA * bfst, int add)
 {
   POLYAREA *a = afst, *b = bfst;
@@ -1636,7 +1675,8 @@ Touching (POLYAREA * a, POLYAREA * b)
       if (!poly_Valid (b))
 	return -1;
 #endif
-      M_POLYAREA_intersect (&e, a, b, False);
+//      M_POLYAREA_intersect (&e, a, b, False);
+      M_POLYAREA_intersect2 (&e, a, b, False);
 
       if (M_POLYAREA_label (a, b, TRUE))
 	return TRUE;
@@ -2387,15 +2427,18 @@ inside_sector (VNODE * pn, Vector p2)
 BOOLp
 poly_ChkContour (PLINE * a)
 {
-  VNODE *a1, *a2, *hit1, *hit2;
+#warning FIXME Later: Deliberately disabled this test - seems something strange is going on
+  return FALSE;
+  VNODE *a1, *a2, *a2_start, *hit1, *hit2;
   Vector i1, i2;
   int icnt;
+  double d1,d2;
 
   assert (a != NULL);
   a1 = &a->head;
   do
     {
-      a2 = a1;
+      a2_start = a2 = a1;
       do
 	{
 	  if (!node_neighbours (a1, a2) &&
@@ -2403,21 +2446,36 @@ poly_ChkContour (PLINE * a)
 				    a2->point, a2->next->point, i1, i2)) > 0)
 	    {
 	      if (icnt > 1)
-		return TRUE;
+                {
+                  printf ("Returning true 1\n");
+		  return TRUE;
+                }
 
-	      if (vect_dist2 (i1, a1->point) < EPSILON)
+              d1 = -1; d2 = -1;
+	      if ((d1=vect_dist2 (i1, a1->point)) < EPSILON)
 		hit1 = a1;
-	      else if (vect_dist2 (i1, a1->next->point) < EPSILON)
+	      else if ((d2=vect_dist2 (i1, a1->next->point)) < EPSILON)
 		hit1 = a1->next;
 	      else
-		return TRUE;
+                {
+                  printf ("Returning true 2, %f, %f, %f\n", EPSILON, d1, d2);
+                  printf ("a1->point: (%i,%i)\n", a1->point[0], a1->point[1]);
+                  printf ("a1->next->point: (%i,%i)\n", a1->next->point[0], a1->next->point[1]);
+                  printf ("a2->point: (%i,%i)\n", a2->point[0], a2->point[1]);
+                  printf ("a2->next->point: (%i,%i)\n", a2->next->point[0], a2->next->point[1]);
+                  printf ("Intersection: (%i, %i)\n", i1[0], i1[1]);
+		  return TRUE;
+                }
 
 	      if (vect_dist2 (i1, a2->point) < EPSILON)
 		hit2 = a2;
 	      else if (vect_dist2 (i1, a2->next->point) < EPSILON)
 		hit2 = a2->next;
 	      else
-		return TRUE;
+                {
+                  printf ("Returning true 3\n");
+		  return TRUE;
+                }
 
 #if 1
 	      /* now check if they are inside each other */
@@ -2425,13 +2483,17 @@ poly_ChkContour (PLINE * a)
 		  inside_sector (hit1, hit2->next->point) ||
 		  inside_sector (hit2, hit1->prev->point) ||
 		  inside_sector (hit2, hit1->next->point))
-		return TRUE;
+                {
+                  printf ("Returning true 4\n");
+		  return TRUE;
+                }
 #endif
 	    }
 	}
-      while ((a2 = a2->next) != &a->head);
+      while ((a2 = a2->next) != a2_start);
     }
   while ((a1 = a1->next) != &a->head);
+  printf ("Fell out the bottom, returning false\n");
   return FALSE;
 }
 
@@ -2442,7 +2504,10 @@ poly_Valid (POLYAREA * p)
   PLINE *c;
 
   if ((p == NULL) || (p->contours == NULL))
-    return FALSE;
+    {
+      printf ("Polyarea %p, contours=%p\n", p, p ? p->contours : NULL);
+      return FALSE;
+    }
 
   if (p->contours->Flags.orient == PLF_INV || poly_ChkContour (p->contours))
     {
diff --git a/src/pour.c b/src/pour.c
new file mode 100644
index 0000000..45e6a01
--- /dev/null
+++ b/src/pour.c
@@ -0,0 +1,1218 @@
+/* $Id$ */
+
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 1994,1995,1996 Thomas Nau
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Contact addresses for paper mail and Email:
+ *  Thomas Nau, Schlehenweg 15, 88471 Baustetten, Germany
+ *  Thomas.Nau@rz.uni-ulm.de
+ *
+ */
+
+
+/* special pour editing routines
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <assert.h>
+#include <math.h>
+#include <memory.h>
+#include <setjmp.h>
+
+#include "global.h"
+#include "box.h"
+#include "create.h"
+#include "crosshair.h"
+#include "data.h"
+#include "draw.h"
+#include "error.h"
+#include "find.h"
+#include "misc.h"
+#include "move.h"
+#include "polygon.h"
+#include "pour.h"
+#include "remove.h"
+#include "rtree.h"
+#include "search.h"
+#include "set.h"
+#include "thermal.h"
+#include "undo.h"
+
+#ifdef HAVE_LIBDMALLOC
+#include <dmalloc.h>
+#endif
+
+RCSID ("$Id$");
+
+#define ROUND(x) ((long)(((x) >= 0 ? (x) + 0.5  : (x) - 0.5)))
+
+#define UNSUBTRACT_BLOAT 10
+
+/* ---------------------------------------------------------------------------
+ * local prototypes
+ */
+
+
+/* --------------------------------------------------------------------------
+ * remove redundant polygon points. Any point that lies on the straight
+ * line between the points on either side of it is redundant.
+ * returns true if any points are removed
+ */
+Boolean
+RemoveExcessPourPoints (LayerTypePtr Layer, PourTypePtr Pour)
+{
+  PointTypePtr pt1, pt2, pt3;
+  Cardinal n;
+  LineType line;
+  Boolean changed = False;
+
+  if (Undoing ())
+    return (False);
+  /* there are always at least three points in a pour */
+  pt1 = &Pour->Points[Pour->PointN - 1];
+  pt2 = &Pour->Points[0];
+  pt3 = &Pour->Points[1];
+  for (n = 0; n < Pour->PointN; n++, pt1++, pt2++, pt3++)
+    {
+      /* wrap around pour */
+      if (n == 1)
+        pt1 = &Pour->Points[0];
+      if (n == Pour->PointN - 1)
+        pt3 = &Pour->Points[0];
+      line.Point1 = *pt1;
+      line.Point2 = *pt3;
+      line.Thickness = 0;
+      if (IsPointOnLine ((float) pt2->X, (float) pt2->Y, 0.0, &line))
+        {
+          RemoveObject (POURPOINT_TYPE, (void *) Layer, (void *) Pour,
+                        (void *) pt2);
+          changed = True;
+        }
+    }
+  return (changed);
+}
+
+/* ---------------------------------------------------------------------------
+ * returns the index of the polygon point which is the end
+ * point of the segment with the lowest distance to the passed
+ * coordinates
+ */
+Cardinal
+GetLowestDistancePourPoint (PourTypePtr Pour, LocationType X,
+                            LocationType Y)
+{
+  return GetLowestDistancePourPoint (Pour, X, Y);
+}
+
+/* ---------------------------------------------------------------------------
+ * go back to the  previous point of the polygon
+ */
+void
+GoToPreviousPourPoint (void)
+{
+  switch (Crosshair.AttachedPour.PointN)
+    {
+      /* do nothing if mode has just been entered */
+    case 0:
+      break;
+
+      /* reset number of points and 'LINE_MODE' state */
+    case 1:
+      Crosshair.AttachedPour.PointN = 0;
+      Crosshair.AttachedLine.State = STATE_FIRST;
+      addedLines = 0;
+      break;
+
+      /* back-up one point */
+    default:
+      {
+        PointTypePtr points = Crosshair.AttachedPour.Points;
+        Cardinal n = Crosshair.AttachedPour.PointN - 2;
+
+        Crosshair.AttachedPour.PointN--;
+        Crosshair.AttachedLine.Point1.X = points[n].X;
+        Crosshair.AttachedLine.Point1.Y = points[n].Y;
+        break;
+      }
+    }
+}
+
+/* ---------------------------------------------------------------------------
+ * close pour if possible
+ */
+void
+ClosePour (void)
+{
+  Cardinal n = Crosshair.AttachedPour.PointN;
+
+  /* check number of points */
+  if (n >= 3)
+    {
+      /* if 45 degree lines are what we want do a quick check
+       * if closing the polygon makes sense
+       */
+      if (!TEST_FLAG (ALLDIRECTIONFLAG, PCB))
+        {
+          BDimension dx, dy;
+
+          dx = abs (Crosshair.AttachedPour.Points[n - 1].X -
+                    Crosshair.AttachedPour.Points[0].X);
+          dy = abs (Crosshair.AttachedPour.Points[n - 1].Y -
+                    Crosshair.AttachedPour.Points[0].Y);
+          if (!(dx == 0 || dy == 0 || dx == dy))
+            {
+              Message
+                (_
+                 ("Cannot close polygon because 45 degree lines are requested.\n"));
+              return;
+            }
+        }
+      CopyAttachedPourToLayer ();
+      Draw ();
+    }
+  else
+    Message (_("A polygon has to have at least 3 points\n"));
+}
+
+/* ---------------------------------------------------------------------------
+ * moves the data of the attached (new) polygon to the current layer
+ */
+void
+CopyAttachedPourToLayer (void)
+{
+  PourTypePtr pour;
+  int saveID;
+
+  /* move data to layer and clear attached struct */
+  pour = CreateNewPour (CURRENT, NoFlags ());
+  saveID = pour->ID;
+  *pour = Crosshair.AttachedPour;
+  pour->ID = saveID;
+  SET_FLAG (CLEARPOLYFLAG, pour);
+  if (TEST_FLAG (NEWFULLPOLYFLAG, PCB))
+    SET_FLAG (FULLPOLYFLAG, pour);
+  memset (&Crosshair.AttachedPour, 0, sizeof (PourType));
+  SetPourBoundingBox (pour);
+  if (!CURRENT->pour_tree)
+    CURRENT->pour_tree = r_create_tree (NULL, 0, 0);
+  r_insert_entry (CURRENT->pour_tree, (BoxType *) pour, 0);
+  InitPourClip (PCB->Data, CURRENT, pour);
+//  DrawPolygon (CURRENT, polygon, 0);
+  DrawPour (CURRENT, pour, 0);
+  SetChangedFlag (True);
+
+  /* reset state of attached line */
+  Crosshair.AttachedLine.State = STATE_FIRST;
+  addedLines = 0;
+
+  /* add to undo list */
+  AddObjectToCreateUndoList (POUR_TYPE, CURRENT, pour, pour);
+  IncrementUndoSerialNumber ();
+}
+
+/*---------------------------------------- END OF NICE GENTLE UI DRIVEN PIECES OF THE POUR CODE --------------*/
+
+/*---------------------------------------- THIS CODE BELOW WILL MURDER SMALL ANIMALS THEN LAUGH --------------*/
+
+/* ---------------------------------------------------------------------------
+ * destroys a polygon from a pour
+ */
+static void *
+DestroyPolygonInPour (LayerTypePtr layer, PourTypePtr pour, PolygonTypePtr polygon)
+{
+  r_delete_entry (layer->polygon_tree, (BoxTypePtr) polygon);
+
+  FreePolygonMemory (polygon);
+  *polygon = pour->Polygons[ --pour->PolygonN ];
+  r_substitute (layer->polygon_tree,
+                (BoxType *) & pour->Polygons[ pour->PolygonN ],
+                (BoxType *) polygon);
+  memset (&pour->Polygons[ pour->PolygonN ], 0, sizeof (PolygonType));
+  return (NULL);
+}
+
+static int
+subtract_poly (POLYAREA * np1, POLYAREA **pg)
+{
+  POLYAREA *merged = NULL, *np = np1;
+  int x;
+
+  assert (np);
+  assert (pg);
+  assert (*pg);
+
+  if (pg == NULL)
+    {
+      printf ("Hmm, got pg == NULL in subtract_poly\n");
+      poly_Free (&np);
+      return -1;
+    }
+
+  assert (poly_Valid (*pg));
+  assert (poly_Valid (np));
+  x = poly_Boolean_free (*pg, np, &merged, PBO_SUB);
+  if (x != err_ok)
+    {
+      fprintf (stderr, "Error while clipping PBO_SUB: %d\n", x);
+      poly_Free (&merged);
+      return -1;
+    }
+
+  assert (!merged || poly_Valid (merged));
+
+  *pg = merged;
+  return 1;
+}
+
+  static int
+unite_poly (POLYAREA * np, POLYAREA ** pg)
+{
+  POLYAREA *merged = NULL;
+  int x;
+  assert (np);
+  assert (pg);
+  assert (*pg);
+  x = poly_Boolean_free (*pg, np, &merged, PBO_UNITE);
+  if (x != err_ok)
+    {
+      fprintf (stderr, "Error while clipping PBO_UNITE: %d\n", x);
+      poly_Free (&merged);
+      return 0;
+    }
+  assert (!merged || poly_Valid (merged));
+  *pg = merged;
+  return 1;
+}
+
+static int
+intersect_poly (POLYAREA * np, POLYAREA ** pg)
+{
+  POLYAREA *merged;
+  int x;
+  assert (np);
+  assert (pg);
+  assert (*pg);
+  x = poly_Boolean_free (*pg, np, &merged, PBO_ISECT);
+  if (x != err_ok)
+    {
+      fprintf (stderr, "Error while clipping PBO_ISECT: %d\n", x);
+      poly_Free (&merged);
+      return 0;
+    }
+  assert (!merged || poly_Valid (merged));
+  *pg = merged;
+  return 1;
+}
+
+
+/* remove the pin clearance from the polygon */
+static POLYAREA *
+get_subtract_pin_poly (DataType * d, PinType * pin, LayerType * l, PourType *pour)
+{
+  POLYAREA *np;
+  Cardinal i;
+
+  if (pin->Clearance == 0)
+    return NULL;
+
+  i = GetLayerNumber (d, l);
+  if (TEST_THERM (i, pin))
+    {
+      np = ThermPoly ((PCBTypePtr) (d->pcb), pin, i);
+      if (!np)
+        printf ("Got np=NULL from ThermPoly, is this bad?\n");
+    }
+  else
+    {
+      np = PinPoly (pin, pin->Thickness, pin->Clearance);
+      if (!np)
+        printf ("Got np=NULL from PinPoly, is this bad?\n");
+    }
+
+  return np;
+}
+
+static POLYAREA *
+get_subtract_line_poly (LineType *line, PourType *pour)
+{
+  POLYAREA *np;
+
+  if (!TEST_FLAG (CLEARLINEFLAG, line))
+    return NULL;
+
+  np = LinePoly (line, line->Thickness + line->Clearance);
+  if (np == NULL)
+    printf ("Got np=NULL from LinePoly, is this bad?\n");
+
+  return np;
+}
+
+static POLYAREA *
+get_subtract_arc_poly (ArcType * arc, PourType * pour)
+{
+  POLYAREA *np;
+
+  if (!TEST_FLAG (CLEARLINEFLAG, arc))
+    return NULL;
+
+  np = ArcPoly (arc, arc->Thickness + arc->Clearance);
+  if (np == NULL)
+    printf ("Got np=NULL from ArcPoly, is this bad?\n");
+
+  return np;
+}
+
+static POLYAREA *
+get_subtract_text_poly (TextType * text, PourType * pour)
+{
+  POLYAREA *np;
+  const BoxType *b = &text->BoundingBox;
+
+  if (!TEST_FLAG (CLEARLINEFLAG, text))
+    return NULL;
+
+  np = RoundRect (b->X1 + PCB->Bloat, b->X2 - PCB->Bloat,
+                        b->Y1 + PCB->Bloat, b->Y2 - PCB->Bloat, PCB->Bloat);
+  if (np == NULL)
+    printf ("Got np=NULL from RoundRect, is this bad?\n");
+
+  return np;
+}
+
+static POLYAREA *
+get_subtract_pad_poly (PadType * pad, PourType * pour)
+{
+  POLYAREA *np;
+
+  if (TEST_FLAG (SQUAREFLAG, pad))
+    {
+      np = SquarePadPoly (pad, pad->Thickness + pad->Clearance);
+      if (np == NULL)
+        printf ("Got np==NULL from SquarePadPoly, is this bad?\n");
+    }
+  else
+    {
+      np = LinePoly ((LineType *) pad, pad->Thickness + pad->Clearance);
+      if (np == NULL)
+        printf ("Got np=NULL from LinePoly, is this bad?\n");
+    }
+
+  return np;
+}
+
+static POLYAREA *
+get_subtract_polygon_poly (PolygonType * polygon, PourType * pour)
+{
+  POLYAREA *np;
+
+  /* Don't subtract from ourselves! */
+  if (polygon->ParentPour == pour || !TEST_FLAG (CLEARLINEFLAG, polygon))
+    return NULL;
+
+  poly_Copy0 (&np, polygon->Clipped);
+  if (np == NULL)
+    printf ("Got np=NULL from poly_Copy0, is this bad?\n");
+
+  return np;
+}
+
+struct cpInfo
+{
+  const BoxType *other;
+  DataType *data;
+  LayerType *layer;
+  PourType *pour;
+  Boolean solder;
+  POLYAREA *pg;
+  jmp_buf env;
+};
+
+static int
+pin_sub_callback (const BoxType * b, void *cl)
+{
+  PinTypePtr pin = (PinTypePtr) b;
+  struct cpInfo *info = (struct cpInfo *) cl;
+  POLYAREA *np;
+
+  /* don't subtract the object that was put back! */
+  if (b == info->other)
+    return 0;
+
+  np = get_subtract_pin_poly (info->data, pin, info->layer, info->pour);
+  if (np == NULL)
+    {
+      printf ("Got np=NULL from get_subtract_pin_poly, is this bad?\n");
+//      longjmp (info->env, 1);
+      return 0;
+    }
+  if (subtract_poly (np, &info->pg) < 0)
+    longjmp (info->env, 1);
+  return 1;
+}
+
+static int
+arc_sub_callback (const BoxType * b, void *cl)
+{
+  ArcTypePtr arc = (ArcTypePtr) b;
+  struct cpInfo *info = (struct cpInfo *) cl;
+  POLYAREA *np;
+
+  /* don't subtract the object that was put back! */
+  if (b == info->other)
+    return 0;
+  if (!TEST_FLAG (CLEARLINEFLAG, arc))
+    return 0;
+
+  np = get_subtract_arc_poly (arc, info->pour);
+  if (np == NULL)
+    {
+      printf ("Got np=NULL from get_subtract_arc_poly, is this bad?\n");
+      longjmp (info->env, 1);
+    }
+  if (subtract_poly (np, &info->pg) < 0)
+    longjmp (info->env, 1);
+  return 1;
+}
+
+static int
+pad_sub_callback (const BoxType * b, void *cl)
+{
+  PadTypePtr pad = (PadTypePtr) b;
+  struct cpInfo *info = (struct cpInfo *) cl;
+  POLYAREA *np;
+
+  /* don't subtract the object that was put back! */
+  if (b == info->other)
+    return 0;
+  if (XOR (TEST_FLAG (ONSOLDERFLAG, pad), info->solder))
+    return 0;
+
+  np = get_subtract_pad_poly (pad, info->pour);
+  if (np == NULL)
+    {
+      printf ("Got np=NULL from get_subtract_pad_poly, is this bad?\n");
+      longjmp (info->env, 1);
+    }
+  if (subtract_poly (np, &info->pg) < 0)
+    longjmp (info->env, 1);
+  return 1;
+}
+
+static int
+line_sub_callback (const BoxType * b, void *cl)
+{
+  LineTypePtr line = (LineTypePtr) b;
+  struct cpInfo *info = (struct cpInfo *) cl;
+  POLYAREA *np;
+
+  /* don't subtract the object that was put back! */
+  if (b == info->other)
+    return 0;
+  if (!TEST_FLAG (CLEARLINEFLAG, line))
+    return 0;
+
+  np = get_subtract_line_poly (line, info->pour);
+  if (np == NULL)
+    {
+      printf ("Got np=NULL from get_subtract_line_poly, is this bad?\n");
+      longjmp (info->env, 1);
+    }
+  if (subtract_poly (np, &info->pg) < 0)
+    longjmp (info->env, 1);
+  return 1;
+}
+
+
+static int
+text_sub_callback (const BoxType * b, void *cl)
+{
+  TextTypePtr text = (TextTypePtr) b;
+  struct cpInfo *info = (struct cpInfo *) cl;
+  POLYAREA *np;
+
+  /* don't subtract the object that was put back! */
+  if (b == info->other)
+    return 0;
+  if (!TEST_FLAG (CLEARLINEFLAG, text))
+    return 0;
+
+  np = get_subtract_text_poly (text, info->pour);
+  if (np == NULL)
+    {
+      printf ("Got np=NULL from get_subtract_text_poly, is this bad?\n");
+      longjmp (info->env, 1);
+    }
+  if (subtract_poly (np, &info->pg) < 0)
+    longjmp (info->env, 1);
+  return 1;
+}
+
+static int
+poly_sub_callback (const BoxType * b, void *cl)
+{
+  PolygonTypePtr poly = (PolygonTypePtr) b;
+  struct cpInfo *info = (struct cpInfo *) cl;
+  POLYAREA *np;
+
+  /* don't subtract the object that was put back! */
+  if (b == info->other)
+    return 0;
+  if (!TEST_FLAG (CLEARLINEFLAG, poly))
+    return 0;
+
+  np = get_subtract_polygon_poly (poly, info->pour);
+  if (np == NULL)
+    {
+      printf ("Got np=NULL from LinePoly, is this bad?\n");
+      longjmp (info->env, 1);
+    }
+  if (subtract_poly (np, &info->pg) < 0)
+    longjmp (info->env, 1);
+  return 1;
+}
+
+static int
+Group (DataTypePtr Data, Cardinal layer)
+{
+  Cardinal i, j;
+  for (i = 0; i < max_layer; i++)
+    for (j = 0; j < ((PCBType *) (Data->pcb))->LayerGroups.Number[i]; j++)
+      if (layer == ((PCBType *) (Data->pcb))->LayerGroups.Entries[i][j])
+        return i;
+  return i;
+}
+
+/* NB: For convenience, we're passing the defined POLYAREA in here */
+static int
+ClearPour (DataTypePtr Data, LayerTypePtr Layer, PourType * pour,
+           POLYAREA *clipped, const BoxType * here, BDimension expand)
+{
+  POLYAREA *tmp, *pg;
+  int r = 0;
+  BoxType region;
+  struct cpInfo info;
+  Cardinal group;
+
+  if (!TEST_FLAG (CLEARPOLYFLAG, pour)
+      || GetLayerNumber (Data, Layer) >= max_layer)
+    return 0;
+  group = Group (Data, GetLayerNumber (Data, Layer));
+  info.solder = (group == Group (Data, max_layer + SOLDER_LAYER));
+  info.data = Data;
+  info.other = here;
+  info.layer = Layer;
+  info.pour = pour;
+  info.pg = clipped;
+  if (here)
+    region = clip_box (here, &pour->BoundingBox);
+  else
+    region = pour->BoundingBox;
+  region = bloat_box (&region, expand);
+
+  if (setjmp (info.env) == 0)
+    {
+      r  = r_search (Data->via_tree, &region, NULL, pin_sub_callback, &info);
+      r += r_search (Data->pin_tree, &region, NULL, pin_sub_callback, &info);
+      GROUP_LOOP (Data, group);
+      {
+        r += r_search (layer->line_tree,    &region, NULL, line_sub_callback, &info);
+        r += r_search (layer->arc_tree,     &region, NULL, arc_sub_callback,  &info);
+        r += r_search (layer->text_tree,    &region, NULL, text_sub_callback, &info);
+        r += r_search (layer->polygon_tree, &region, NULL, poly_sub_callback, &info);
+      }
+      END_LOOP;
+      if (info.solder || group == Group (Data, max_layer + COMPONENT_LAYER))
+        r += r_search (Data->pad_tree, &region, NULL, pad_sub_callback, &info);
+    }
+
+  /* TODO: Check r to work of it we need to do this? */
+
+  /* For each piece of the clipped up polygon, create a new child */
+  pg = info.pg;
+  do
+    {
+      PolygonType *poly;
+
+      tmp = pg->f;
+      pg->f = pg;
+      pg->b = pg;
+
+      poly = CreateNewPolygonInPour (pour, pour->Flags);
+      poly->Clipped = pg;
+
+      SetPolygonBoundingBox (poly);
+
+      if (Layer->polygon_tree == NULL)
+        Layer->polygon_tree = r_create_tree (NULL, 0, 0);
+      r_insert_entry (Layer->polygon_tree, (BoxType *) poly, 0);
+      printf ("Inserting one polygon into the layer's tree\n");
+    }
+  while ((pg = tmp) != info.pg);
+
+  return r;
+}
+
+static int
+subtract_plow (DataTypePtr Data, LayerTypePtr Layer, PourTypePtr pour,
+              int type, void *ptr1, void *ptr2)
+{
+  POLYAREA *np = NULL, *pg = NULL, *start_pg, *tmp;
+  PolygonType **delete_children;
+  int number_deleted = 0;
+
+  switch (type)
+    {
+    case PIN_TYPE:
+    case VIA_TYPE:
+      np = get_subtract_pin_poly (Data, (PinTypePtr) ptr2, Layer, pour);
+      break;
+    case LINE_TYPE:
+      np = get_subtract_line_poly ((LineTypePtr) ptr2, pour);
+      break;
+    case ARC_TYPE:
+      np = get_subtract_arc_poly ((ArcTypePtr) ptr2, pour);
+      break;
+    case PAD_TYPE:
+      np = get_subtract_pad_poly ((PadTypePtr) ptr2, pour);
+      break;
+    case POLYGON_TYPE:
+      np = get_subtract_polygon_poly ((PolygonTypePtr) ptr2, pour);
+      break;
+    case TEXT_TYPE:
+      np = get_subtract_text_poly ((TextTypePtr) ptr2, pour);
+      break;
+    }
+
+  if (np == NULL)
+    {
+      printf ("Didn't get a POLYAREA to subtract, so bailing\n");
+      return 0;
+    }
+
+  assert (poly_Valid (np));
+
+  /* Make pg contain the polygons we're going to fiddle with */
+
+  delete_children = calloc (pour->PolygonN, sizeof (PolygonType *));
+  POURPOLYGON_LOOP (pour);
+  {
+    /* Gather up children which are touched by np */
+    if (isects (np, polygon, False))
+      {
+        /* Steal their clipped contours, then delete them */
+        /* Add contour to local list to fiddle about with */
+        delete_children[ number_deleted++ ] = polygon;
+        assert (poly_Valid (polygon->Clipped));
+        if (polygon->Clipped == NULL)
+          {
+            printf ("Got polygon->clipped == NULL!\n");
+            continue;
+          }
+        if (pg == NULL)
+          {
+            pg = polygon->Clipped;
+            polygon->Clipped = NULL;
+          }
+        else
+          {
+            /* Link the _single_ polygon->Clipped into our circular pg list. */
+            polygon->Clipped->f = pg;
+            polygon->Clipped->b = pg->b;
+            pg->b->f = polygon->Clipped;
+            pg->b = polygon->Clipped;
+            polygon->Clipped = NULL;
+          }
+      }
+  }
+  END_LOOP;
+  for (; number_deleted ;)
+    DestroyPolygonInPour (Layer, pour, delete_children[ --number_deleted ]);
+  free (delete_children);
+
+  if (pg == NULL)
+    {
+      printf ("Hmm, got pg == NULL in subtract_plow\n");
+      poly_Free (&np);
+      return -1;
+    }
+
+  assert (poly_Valid (pg));
+
+  /* Perform the subtract operation */
+
+  /* NB: Old *pg is freed inside subtract_poly */
+  subtract_poly (np, &pg);
+
+  if (pg == NULL)
+    {
+      printf ("Poly killed to death by subtracting\n");
+      return -1;
+    }
+
+
+  /* For each piece of the clipped up polygon, create a new child */
+  start_pg = pg;
+  do
+    {
+      PolygonType *poly;
+
+      tmp = pg->f;
+      pg->f = pg;
+      pg->b = pg;
+
+      poly = CreateNewPolygonInPour (pour, pour->Flags);
+      poly->Clipped = pg;
+
+      SetPolygonBoundingBox (poly);
+
+      if (Layer->polygon_tree == NULL)
+        Layer->polygon_tree = r_create_tree (NULL, 0, 0);
+      r_insert_entry (Layer->polygon_tree, (BoxType *) poly, 0);
+      printf ("Inserting one polygon into the layer's tree\n");
+    }
+  while ((pg = tmp) != start_pg);
+
+
+
+  /* TODO: Need to put the modified polygons in pg into children */
+  return 0;
+}
+
+static POLYAREA *
+get_unsubtract_pin_poly (PinType * pin, LayerType * l, PourType * pour)
+{
+  /* overlap a bit to prevent gaps from rounding errors */
+  return BoxPolyBloated (&pin->BoundingBox, UNSUBTRACT_BLOAT);
+}
+
+static POLYAREA *
+get_unsubtract_arc_poly (ArcType * arc, LayerType * l, PourType * pour)
+{
+  if (!TEST_FLAG (CLEARLINEFLAG, arc))
+    return NULL;
+
+  /* overlap a bit to prevent gaps from rounding errors */
+  return BoxPolyBloated (&arc->BoundingBox, UNSUBTRACT_BLOAT);
+}
+
+static POLYAREA *
+get_unsubtract_line_poly (LineType * line, LayerType * l, PourType * pour)
+{
+  if (!TEST_FLAG (CLEARLINEFLAG, line))
+    return NULL;
+
+  /* overlap a bit to prevent notches from rounding errors */
+  return BoxPolyBloated (&line->BoundingBox, UNSUBTRACT_BLOAT);
+}
+
+static POLYAREA *
+get_unsubtract_text_poly (TextType * text, LayerType * l, PourType * pour)
+{
+  if (!TEST_FLAG (CLEARLINEFLAG, text))
+    return NULL;
+
+  /* overlap a bit to prevent notches from rounding errors */
+  return BoxPolyBloated (&text->BoundingBox, UNSUBTRACT_BLOAT);
+}
+
+static POLYAREA *
+get_unsubtract_pad_poly (PadType * pad, LayerType * l, PourType * pour)
+{
+  /* overlap a bit to prevent notches from rounding errors */
+  return BoxPolyBloated (&pad->BoundingBox, UNSUBTRACT_BLOAT);
+}
+
+static POLYAREA *
+get_unsubtract_polygon_poly (PolygonType * poly, LayerType * l, PourType * pour)
+{
+  /* Don't subtract from ourselves, or if CLEARLINEFLAG isn't set */
+  if (poly->ParentPour == pour || !TEST_FLAG (CLEARLINEFLAG, poly))
+    return NULL;
+
+  /* overlap a bit to prevent notches from rounding errors */
+  return BoxPolyBloated (&poly->BoundingBox, UNSUBTRACT_BLOAT);
+}
+
+static POLYAREA *
+original_pour_poly (PourType * p)
+{
+  PLINE *contour = NULL;
+  POLYAREA *np = NULL;
+  Vector v;
+
+  /* first make initial polygon contour */
+  POLYGONPOINT_LOOP (p);
+  {
+    v[0] = point->X;
+    v[1] = point->Y;
+    if (contour == NULL)
+      {
+        if ((contour = poly_NewContour (v)) == NULL)
+          return NULL;
+      }
+    else
+      poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+  }
+  END_LOOP;
+  if (contour == NULL)
+    {
+      printf ("How did that escape - did the loop iterate zero times??\n");
+      POLYGONPOINT_LOOP (p);
+        {
+          printf ("Hello\n");
+        }
+      END_LOOP;
+      return NULL;
+    }
+  poly_PreContour (contour, TRUE);
+  /* make sure it is a positive contour */
+  if ((contour->Flags.orient) != PLF_DIR)
+    poly_InvContour (contour);
+  assert ((contour->Flags.orient) == PLF_DIR);
+  if ((np = poly_Create ()) == NULL)
+    return NULL;
+  poly_InclContour (np, contour);
+  assert (poly_Valid (np));
+  return np;
+}
+
+static int
+add_plow (DataTypePtr Data, LayerTypePtr Layer, PourTypePtr pour,
+          int type, void *ptr1, void *ptr2)
+{
+  POLYAREA *np = NULL, *pg = NULL; //, *start_pg, *tmp;
+  PolygonType **delete_children;
+  int number_deleted = 0;
+
+  switch (type)
+    {
+    case PIN_TYPE:
+    case VIA_TYPE:
+      np = get_unsubtract_pin_poly ((PinTypePtr) ptr2, Layer, pour);
+      break;
+    case LINE_TYPE:
+      np = get_unsubtract_line_poly ((LineTypePtr) ptr2, Layer, pour);
+      break;
+    case ARC_TYPE:
+      np = get_unsubtract_arc_poly ((ArcTypePtr) ptr2, Layer, pour);
+      break;
+    case PAD_TYPE:
+      np = get_unsubtract_pad_poly ((PadTypePtr) ptr2, Layer, pour);
+      break;
+    case POLYGON_TYPE:
+      np = get_unsubtract_polygon_poly ((PolygonTypePtr) ptr2, Layer, pour);
+      break;
+    case TEXT_TYPE:
+      np = get_unsubtract_text_poly ((TextTypePtr) ptr2, Layer, pour);
+      break;
+    }
+
+  if (np == NULL)
+    {
+      printf ("Didn't get a POLYAREA to add, so bailing\n");
+      return 0;
+    }
+
+  assert (poly_Valid (np));
+
+  /* Make pg contain the polygons we're going to fiddle with */
+
+  delete_children = calloc (pour->PolygonN, sizeof (PolygonType *));
+  POURPOLYGON_LOOP (pour);
+  {
+    /* Gather up children which are touched by np */
+    if (isects (np, polygon, False))
+      {
+        /* Steal their clipped contours, then delete them */
+        /* Add contour to local list to fiddle about with */
+        delete_children[ number_deleted++ ] = polygon;
+        assert (poly_Valid (polygon->Clipped));
+        if (polygon->Clipped == NULL)
+          {
+            printf ("Got polygon->clipped == NULL!\n");
+            continue;
+          }
+        if (pg == NULL)
+          {
+            pg = polygon->Clipped;
+            polygon->Clipped = NULL;
+          }
+        else
+          {
+            /* Link the _single_ polygon->Clipped into our circular pg list. */
+            polygon->Clipped->f = pg;
+            polygon->Clipped->b = pg->b;
+            pg->b->f = polygon->Clipped;
+            pg->b = polygon->Clipped;
+            polygon->Clipped = NULL;
+          }
+      }
+  }
+  END_LOOP;
+  for (; number_deleted ;)
+    DestroyPolygonInPour (Layer, pour, delete_children[ --number_deleted ]);
+  free (delete_children);
+
+  if (pg == NULL)
+    {
+      printf ("Hmm, got pg == NULL in subtract_plow\n");
+      poly_Free (&np);
+      return -1;
+    }
+
+  assert (poly_Valid (pg));
+
+  /* Perform the union operation */
+
+  /* NB: np and old *pg are freed inside union_poly() */
+  unite_poly (np, &pg);
+
+  np = original_pour_poly (pour);
+  /* NB: np and old *pg are freed inside intersect_poly() */
+  intersect_poly (np, &pg);
+
+#warning FIXME Later: ClearPour does the adding of Polygon objects for us
+  ClearPour (PCB->Data, Layer, pour, pg, (const BoxType *) ptr2, 2 * UNSUBTRACT_BLOAT);
+
+#if 0
+  if (pg == NULL)
+    {
+      printf ("Poly killed to death somehow\n");
+      return -1;
+    }
+
+
+  /* For each piece of the clipped up polygon, create a new child */
+  start_pg = pg;
+  do
+    {
+      PolygonType *poly;
+
+      tmp = pg->f;
+      pg->f = pg;
+      pg->b = pg;
+
+      poly = CreateNewPolygonInPour (pour, pour->Flags);
+      poly->Clipped = pg;
+
+      SetPolygonBoundingBox (poly);
+
+      if (Layer->polygon_tree == NULL)
+        Layer->polygon_tree = r_create_tree (NULL, 0, 0);
+      r_insert_entry (Layer->polygon_tree, (BoxType *) poly, 0);
+      printf ("Inserting one polygon into the layer's tree\n");
+    }
+  while ((pg = tmp) != start_pg);
+#endif
+
+  return 0;
+}
+
+/* ---------------------------------------------------------------------------------------------------------- */
+
+int
+InitPourClip (DataTypePtr Data, LayerTypePtr layer, PourType * pour)
+{
+  POLYAREA *clipped;
+  PolygonType **delete_children;
+  int number_deleted = 0;
+
+  printf ("InitPourClip\n");
+
+  /* Free any children we might have */
+  if (pour->PolygonN)
+    {
+      printf ("We already had children. Killing them now.\n");
+      delete_children = calloc (pour->PolygonN, sizeof (PolygonType *));
+      POURPOLYGON_LOOP (pour);
+      {
+        delete_children[ number_deleted++ ] = polygon;
+      }
+      END_LOOP;
+      for (; number_deleted ;)
+        DestroyPolygonInPour (layer, pour, delete_children[ --number_deleted ]);
+    }
+
+  clipped = original_pour_poly (pour);
+  if (!clipped)
+    {
+      printf ("Clipping returned NULL - can that be good?\n");
+      return 0;
+    }
+  assert (poly_Valid (clipped));
+  if (TEST_FLAG (CLEARPOLYFLAG, pour))
+    {
+      /* Clip the pour against anything we can find in this layer */
+      /* TODO: Clear up API so the resulting areas are in "clipped" */
+      ClearPour (Data, layer, pour, clipped, NULL, 0);
+    }
+#if 0
+  pg = clipped;
+  do
+    {
+      /* TODO: For each piece of the clipped up polygon, create a new child */
+    }
+  while ((pg = pg->f) != clipped);
+
+  poly_Free (&clipped);
+#endif
+  return 1;
+}
+
+struct plow_info
+{
+  int type;
+  void *ptr1, *ptr2;
+  LayerTypePtr layer;
+  DataTypePtr data;
+  int (*callback) (DataTypePtr, LayerTypePtr,
+                   PourTypePtr, int, void *, void *);
+};
+
+static int
+plow_callback (const BoxType * b, void *cl)
+{
+  struct plow_info *plow = (struct plow_info *) cl;
+  PourTypePtr pour = (PourTypePtr) b;
+
+  if (TEST_FLAG (CLEARPOLYFLAG, pour))
+    return plow->callback (plow->data, plow->layer, pour,
+                           plow->type, plow->ptr1, plow->ptr2);
+  return 0;
+}
+
+int
+PlowPours (DataType * Data, int type, void *ptr1, void *ptr2,
+           int (*call_back) (DataTypePtr data, LayerTypePtr lay,
+                             PourTypePtr poly, int type,
+                             void *ptr1, void *ptr2))
+{
+  BoxType sb = ((PinTypePtr) ptr2)->BoundingBox;
+  int r = 0;
+  struct plow_info info;
+
+  printf ("Hello world, this is PlowPours\n");
+
+  info.type = type;
+  info.ptr1 = ptr1;
+  info.ptr2 = ptr2;
+  info.data = Data;
+  info.callback = call_back;
+  switch (type)
+    {
+    case PIN_TYPE:
+    case VIA_TYPE:
+      if (type == PIN_TYPE || ptr1 == ptr2 || ptr1 == NULL)
+        {
+          LAYER_LOOP (Data, max_layer);
+          {
+            info.layer = layer;
+            r += r_search (layer->pour_tree, &sb, NULL, plow_callback, &info);
+          }
+          END_LOOP;
+        }
+      else
+        {
+          int layer_no = GetLayerNumber (Data, ((LayerTypePtr) ptr1));
+          int group_no = GetLayerGroupNumberByNumber (layer_no);
+          GROUP_LOOP (Data, group_no);
+          {
+            info.layer = layer;
+            r += r_search (layer->pour_tree, &sb, NULL, plow_callback, &info);
+          }
+          END_LOOP;
+        }
+      break;
+    case LINE_TYPE:
+    case ARC_TYPE:
+    case TEXT_TYPE:
+    case POLYGON_TYPE:
+      /* the cast works equally well for lines and arcs */
+      if (!TEST_FLAG (CLEARLINEFLAG, (LineTypePtr) ptr2))
+        return 0;
+      /* silk doesn't plow */
+      if (GetLayerNumber (Data, ptr1) >= max_layer)
+        return 0;
+      GROUP_LOOP (Data, GetLayerGroupNumberByNumber (GetLayerNumber (Data,
+                                                                     ((LayerTypePtr) ptr1))));
+      {
+        info.layer = layer;
+        r += r_search (layer->pour_tree, &sb, NULL, plow_callback, &info);
+      }
+      END_LOOP;
+      break;
+    case PAD_TYPE:
+      {
+        Cardinal group = TEST_FLAG (ONSOLDERFLAG,
+                                    (PadType *) ptr2) ? SOLDER_LAYER :
+          COMPONENT_LAYER;
+        group = GetLayerGroupNumberByNumber (max_layer + group);
+        GROUP_LOOP (Data, group);
+        {
+          info.layer = layer;
+          r += r_search (layer->pour_tree, &sb, NULL, plow_callback, &info);
+        }
+        END_LOOP;
+      }
+      break;
+
+    case ELEMENT_TYPE:
+      {
+        PIN_LOOP ((ElementType *) ptr1);
+        {
+          PlowPours (Data, PIN_TYPE, ptr1, pin, call_back);
+        }
+        END_LOOP;
+        PAD_LOOP ((ElementType *) ptr1);
+        {
+          PlowPours (Data, PAD_TYPE, ptr1, pad, call_back);
+        }
+        END_LOOP;
+      }
+      break;
+    }
+  return r;
+}
+
+void
+RestoreToPours (DataType * Data, int type, void *ptr1, void *ptr2)
+{
+  if (type == POUR_TYPE)
+    {
+      printf ("Calling InitPourClip from RestoreToPour\n");
+      InitPourClip (PCB->Data, (LayerTypePtr) ptr1, (PourTypePtr) ptr2);
+    }
+  PlowPours (Data, type, ptr1, ptr2, add_plow);
+}
+
+void
+ClearFromPours (DataType * Data, int type, void *ptr1, void *ptr2)
+{
+  if (type == POUR_TYPE)
+    {
+      printf ("Calling InitPourClip from ClearFromPour\n");
+      InitPourClip (PCB->Data, (LayerTypePtr) ptr1, (PourTypePtr) ptr2);
+    }
+  PlowPours (Data, type, ptr1, ptr2, subtract_plow);
+}
+
diff --git a/src/pour.h b/src/pour.h
new file mode 100644
index 0000000..f04e342
--- /dev/null
+++ b/src/pour.h
@@ -0,0 +1,47 @@
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 1994,1995,1996 Thomas Nau
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Contact addresses for paper mail and Email:
+ *  Thomas Nau, Schlehenweg 15, 88471 Baustetten, Germany
+ *  Thomas.Nau@rz.uni-ulm.de
+ *
+ *  RCS: $Id$
+ */
+
+/* prototypes for pour editing routines
+ */
+
+#ifndef	__POUR_INCLUDED__
+#define	__POUR_INCLUDED__
+
+#include "global.h"
+
+Cardinal GetLowestDistancePourPoint (PourTypePtr,
+					LocationType, LocationType);
+Boolean RemoveExcessPourPoints (LayerTypePtr, PourTypePtr);
+void GoToPreviousPourPoint (void);
+void ClosePour (void);
+void CopyAttachedPourToLayer (void);
+
+int InitPourClip(DataType *d, LayerType *l, PourType *p);
+void RestoreToPours(DataType *, int, void *, void *);
+void ClearFromPours(DataType *, int, void *, void *);
+
+#endif /* __POUR_INCLUDED__ */
diff --git a/src/puller.c b/src/puller.c
index 848d394..b219df5 100644
--- a/src/puller.c
+++ b/src/puller.c
@@ -1707,10 +1707,13 @@ gp_text_cb (const BoxType *b, void *cb)
 static int
 gp_poly_cb (const BoxType *b, void *cb)
 {
+#warning FIXME Later
+#if 0
   int i;
   const PolygonTypePtr p = (PolygonTypePtr) b;
   for (i=0; i<p->PointN; i++)
     gp_point (p->Points[i].X, p->Points[i].Y, 0, 0);
+#endif
   return 0;
 }
 
diff --git a/src/rats.c b/src/rats.c
index f381c1c..e1f67e6 100644
--- a/src/rats.c
+++ b/src/rats.c
@@ -505,20 +505,24 @@ GatherSubnets (NetListTypePtr Netl, Boolean NoWarn, Boolean AndRats)
       }
       ENDALL_LOOP;
       /* add polygons so the auto-router can see them as targets */
-      ALLPOLYGON_LOOP (PCB->Data);
+      ALLPOUR_LOOP (PCB->Data);
       {
-	if (TEST_FLAG (DRCFLAG, polygon))
-	  {
-	    conn = GetConnectionMemory (a);
-	    /* make point on a vertex */
-	    conn->X = polygon->Clipped->contours->head.point[0];
-	    conn->Y = polygon->Clipped->contours->head.point[1];
-	    conn->type = POLYGON_TYPE;
-	    conn->ptr1 = layer;
-	    conn->ptr2 = polygon;
-	    conn->group = GetLayerGroupNumberByPointer (layer);
-	    conn->menu = NULL;	/* agnostic view of where it belongs */
-	  }
+        POURPOLYGON_LOOP (pour);
+        {
+          if (TEST_FLAG (DRCFLAG, polygon))
+            {
+              conn = GetConnectionMemory (a);
+              /* make point on a vertex */
+              conn->X = polygon->Clipped->contours->head.point[0];
+              conn->Y = polygon->Clipped->contours->head.point[1];
+              conn->type = POLYGON_TYPE;
+              conn->ptr1 = layer;
+              conn->ptr2 = polygon;
+              conn->group = GetLayerGroupNumberByPointer (layer);
+              conn->menu = NULL;	/* agnostic view of where it belongs */
+            }
+        }
+        END_LOOP;
       }
       ENDALL_LOOP;
       VIA_LOOP (PCB->Data);
diff --git a/src/remove.c b/src/remove.c
index de88abe..24b23a8 100644
--- a/src/remove.c
+++ b/src/remove.c
@@ -46,6 +46,7 @@
 #include "move.h"
 #include "mymem.h"
 #include "polygon.h"
+#include "pour.h"
 #include "rats.h"
 #include "remove.h"
 #include "rtree.h"
@@ -69,12 +70,14 @@ static void *DestroyRat (RatTypePtr);
 static void *DestroyLine (LayerTypePtr, LineTypePtr);
 static void *DestroyArc (LayerTypePtr, ArcTypePtr);
 static void *DestroyText (LayerTypePtr, TextTypePtr);
-static void *DestroyPolygon (LayerTypePtr, PolygonTypePtr);
+//static void *DestroyPolygon (LayerTypePtr, PolygonTypePtr);
+static void *DestroyPour (LayerTypePtr, PourTypePtr);
 static void *DestroyElement (ElementTypePtr);
 static void *RemoveVia (PinTypePtr);
 static void *RemoveRat (RatTypePtr);
-static void *DestroyPolygonPoint (LayerTypePtr, PolygonTypePtr, PointTypePtr);
-static void *RemovePolygonPoint (LayerTypePtr, PolygonTypePtr, PointTypePtr);
+//static void *DestroyPolygonPoint (LayerTypePtr, PolygonTypePtr, PointTypePtr);
+static void *DestroyPourPoint (LayerTypePtr, PourTypePtr, PointTypePtr);
+static void *RemovePourPoint (LayerTypePtr, PourTypePtr, PointTypePtr);
 static void *RemoveLinePoint (LayerTypePtr, LineTypePtr, PointTypePtr);
 
 /* ---------------------------------------------------------------------------
@@ -84,27 +87,31 @@ static ObjectFunctionType RemoveFunctions = {
   RemoveLine,
   RemoveText,
   RemovePolygon,
+  RemovePour,
   RemoveVia,
   RemoveElement,
   NULL,
   NULL,
   NULL,
   RemoveLinePoint,
-  RemovePolygonPoint,
+  NULL,
+  RemovePourPoint,
   RemoveArc,
   RemoveRat
 };
 static ObjectFunctionType DestroyFunctions = {
   DestroyLine,
   DestroyText,
-  DestroyPolygon,
+  NULL, //DestroyPolygon,
+  DestroyPour,
   DestroyVia,
   DestroyElement,
   NULL,
   NULL,
   NULL,
   NULL,
-  DestroyPolygonPoint,
+  NULL, //DestroyPolygonPoint,
+  DestroyPourPoint,
   DestroyArc,
   DestroyRat
 };
@@ -169,21 +176,24 @@ DestroyArc (LayerTypePtr Layer, ArcTypePtr Arc)
 }
 
 /* ---------------------------------------------------------------------------
- * destroys a polygon from a layer
+ * destroys a pour from a layer
  */
 static void *
-DestroyPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
+DestroyPour (LayerTypePtr Layer, PourTypePtr Pour)
 {
-  r_delete_entry (Layer->polygon_tree, (BoxTypePtr) Polygon);
-  FreePolygonMemory (Polygon);
-  *Polygon = Layer->Polygon[--Layer->PolygonN];
-  r_substitute (Layer->polygon_tree,
-                (BoxType *) & Layer->Polygon[Layer->PolygonN],
-                (BoxType *) Polygon);
-  memset (&Layer->Polygon[Layer->PolygonN], 0, sizeof (PolygonType));
+#warning FIXME Later
+  r_delete_entry (Layer->pour_tree, (BoxTypePtr) Pour);
+  FreePourMemory (Pour);
+  *Pour = Layer->Pour[--Layer->PourN];
+  r_substitute (Layer->pour_tree,
+                (BoxType *) & Layer->Pour[Layer->PourN],
+                (BoxType *) Pour);
+  memset (&Layer->Pour[Layer->PourN], 0, sizeof (PourType));
   return (NULL);
 }
 
+#warning FIXME Later
+#if 0
 /* ---------------------------------------------------------------------------
  * removes a polygon-point from a polygon and destroys the data
  */
@@ -207,6 +217,30 @@ DestroyPolygonPoint (LayerTypePtr Layer,
   InitClip (PCB->Data, Layer, Polygon);
   return (Polygon);
 }
+#endif
+
+/* ---------------------------------------------------------------------------
+ * removes a polygon-point from a polygon and destroys the data
+ */
+static void *
+DestroyPourPoint (LayerTypePtr Layer, PourTypePtr Pour, PointTypePtr Point)
+{
+  PointTypePtr ptr;
+
+  if (Pour->PointN <= 3)
+    return RemovePour(Layer, Pour);
+  r_delete_entry (Layer->pour_tree, (BoxType *) Pour);
+  for (ptr = Point + 1; ptr != &Pour->Points[Pour->PointN]; ptr++)
+    {
+      *Point = *ptr;
+      Point = ptr;
+    }
+  Pour->PointN--;
+  SetPourBoundingBox (Pour);
+  r_insert_entry (Layer->pour_tree, (BoxType *) Pour, 0);
+  InitPourClip (PCB->Data, Layer, Pour);
+  return (Pour);
+}
 
 /* ---------------------------------------------------------------------------
  * destroys a text from a layer
@@ -461,21 +495,38 @@ RemovePolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
 }
 
 /* ---------------------------------------------------------------------------
- * removes a polygon-point from a polygon
+ * removes a pour from a layer
+ */
+void *
+RemovePour (LayerTypePtr Layer, PourTypePtr Pour)
+{
+  /* erase from screen */
+  if (Layer->On)
+    {
+      ErasePour (Pour);
+      if (!Bulk)
+        Draw ();
+    }
+  MoveObjectToRemoveUndoList (POUR_TYPE, Layer, Pour, Pour);
+  return (NULL);
+}
+
+/* ---------------------------------------------------------------------------
+ * removes a pour-point from a pour
  */
 static void *
-RemovePolygonPoint (LayerTypePtr Layer,
-                    PolygonTypePtr Polygon, PointTypePtr Point)
+RemovePourPoint (LayerTypePtr Layer,
+                    PourTypePtr Pour, PointTypePtr Point)
 {
   PointTypePtr ptr;
   Cardinal index = 0;
 
-  if (Polygon->PointN <= 3)
-    return RemovePolygon(Layer, Polygon);
+  if (Pour->PointN <= 3)
+    return RemovePour(Layer, Pour);
   if (Layer->On)
-    ErasePolygon (Polygon);
-  /* insert the polygon-point into the undo list */
-  POLYGONPOINT_LOOP (Polygon);
+    ErasePour (Pour);
+  /* insert the pour-point into the undo list */
+  POLYGONPOINT_LOOP (Pour);
   {
     if (point == Point)
       {
@@ -485,24 +536,24 @@ RemovePolygonPoint (LayerTypePtr Layer,
   }
   END_LOOP;
 
-  AddObjectToRemovePointUndoList (POLYGONPOINT_TYPE, Layer, Polygon, index);
-  r_delete_entry (Layer->polygon_tree, (BoxType *) Polygon);
+  AddObjectToRemovePointUndoList (POLYGONPOINT_TYPE, Layer, Pour, index);
+  r_delete_entry (Layer->pour_tree, (BoxType *) Pour);
 
   /* remove point from list, keep point order */
-  for (ptr = Point + 1; ptr != &Polygon->Points[Polygon->PointN]; ptr++)
+  for (ptr = Point + 1; ptr != &Pour->Points[Pour->PointN]; ptr++)
     {
       *Point = *ptr;
       Point = ptr;
     }
-  Polygon->PointN--;
-  SetPolygonBoundingBox (Polygon);
-  r_insert_entry (Layer->polygon_tree, (BoxType *) Polygon, 0);
-  RemoveExcessPolygonPoints (Layer, Polygon);
-  InitClip (PCB->Data, Layer, Polygon);
-  /* redraw polygon if necessary */
+  Pour->PointN--;
+  SetPourBoundingBox (Pour);
+  r_insert_entry (Layer->pour_tree, (BoxType *) Pour, 0);
+  RemoveExcessPourPoints (Layer, Pour);
+  InitPourClip (PCB->Data, Layer, Pour);
+  /* redraw pour if necessary */
   if (Layer->On)
     {
-      DrawPolygon (Layer, Polygon, 0);
+      DrawPour (Layer, Pour, 0);
       if (!Bulk)
         Draw ();
     }
diff --git a/src/remove.h b/src/remove.h
index 8b7c166..eb8c5da 100644
--- a/src/remove.h
+++ b/src/remove.h
@@ -43,6 +43,7 @@
 void *RemoveLine (LayerTypePtr, LineTypePtr);
 void *RemoveArc (LayerTypePtr, ArcTypePtr);
 void *RemovePolygon (LayerTypePtr, PolygonTypePtr);
+void *RemovePour (LayerTypePtr, PourTypePtr);
 void *RemoveText (LayerTypePtr, TextTypePtr);
 void *RemoveElement (ElementTypePtr);
 void ClearRemoveList (void);
diff --git a/src/report.c b/src/report.c
index af9e0b3..5a19390 100644
--- a/src/report.c
+++ b/src/report.c
@@ -330,11 +330,42 @@ ReportDialog (int argc, char **argv, int x, int y)
 		 flags_to_string (Polygon->Flags, POLYGON_TYPE),
 		 Polygon->BoundingBox.X1, Polygon->BoundingBox.Y1,
 		 Polygon->BoundingBox.X2, Polygon->BoundingBox.Y2,
+     0, 0,
+#warning FIXME Later
+#if 0
 		 Polygon->PointN, Polygon->PointMax - Polygon->PointN,
+#endif
 		 GetLayerNumber (PCB->Data, (LayerTypePtr) ptr1),
 		 TEST_FLAG (LOCKFLAG, Polygon) ? "It is LOCKED\n" : "");
 	break;
       }
+    case POUR_TYPE:
+      {
+	PourTypePtr Pour;
+#ifndef NDEBUG
+	if (gui->shift_is_pressed ())
+	  {
+	    LayerTypePtr layer = (LayerTypePtr) ptr1;
+	    __r_dump_tree (layer->pour_tree->root, 0);
+	    return;
+	  }
+#endif
+	Pour = (PourTypePtr) ptr2;
+
+	sprintf (&report[0], "POUR ID# %ld   Flags:%s\n"
+		 "Its bounding box is (%d,%d) (%d,%d)\n"
+		 "It has %d points and could store %d more\n"
+		 "without using more memory.\n"
+		 "It resides on layer %d\n"
+		 "%s", Pour->ID,
+		 flags_to_string (Pour->Flags, POUR_TYPE),
+		 Pour->BoundingBox.X1, Pour->BoundingBox.Y1,
+		 Pour->BoundingBox.X2, Pour->BoundingBox.Y2,
+		 Pour->PointN, Pour->PointMax - Pour->PointN,
+		 GetLayerNumber (PCB->Data, (LayerTypePtr) ptr1),
+		 TEST_FLAG (LOCKFLAG, Pour) ? "It is LOCKED\n" : "");
+	break;
+      }
     case PAD_TYPE:
       {
 	int len, dx, dy, mgap;
diff --git a/src/rotate.c b/src/rotate.c
index 247a1a9..5049afa 100644
--- a/src/rotate.c
+++ b/src/rotate.c
@@ -44,6 +44,7 @@
 #include "error.h"
 #include "misc.h"
 #include "polygon.h"
+#include "pour.h"
 #include "rotate.h"
 #include "rtree.h"
 #include "rubberband.h"
@@ -81,12 +82,14 @@ static ObjectFunctionType RotateFunctions = {
   RotateText,
   NULL,
   NULL,
+  NULL,
   RotateElement,
   RotateElementName,
   NULL,
   NULL,
   RotateLinePoint,
   NULL,
+  NULL,
   RotateArc,
   NULL
 };
@@ -164,12 +167,30 @@ void
 RotatePolygonLowLevel (PolygonTypePtr Polygon,
 		       LocationType X, LocationType Y, BYTE Number)
 {
+#warning FIXME Later
+#if 0
   POLYGONPOINT_LOOP (Polygon);
   {
     ROTATE (point->X, point->Y, X, Y, Number);
   }
   END_LOOP;
   RotateBoxLowLevel (&Polygon->BoundingBox, X, Y, Number);
+#endif
+}
+
+/* ---------------------------------------------------------------------------
+ * rotates a pour in 90 degree steps
+ */
+void
+RotatePourLowLevel (PourTypePtr Pour,
+		       LocationType X, LocationType Y, BYTE Number)
+{
+  POURPOINT_LOOP (Pour);
+  {
+    ROTATE (point->X, point->Y, X, Y, Number);
+  }
+  END_LOOP;
+  RotateBoxLowLevel (&Pour->BoundingBox, X, Y, Number);
 }
 
 /* ---------------------------------------------------------------------------
@@ -179,11 +200,11 @@ static void *
 RotateText (LayerTypePtr Layer, TextTypePtr Text)
 {
   EraseText (Layer, Text);
-  RestoreToPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+  RestoreToPours (PCB->Data, TEXT_TYPE, Layer, Text);
   r_delete_entry (Layer->text_tree, (BoxTypePtr) Text);
   RotateTextLowLevel (Text, CenterX, CenterY, Number);
   r_insert_entry (Layer->text_tree, (BoxTypePtr) Text, 0);
-  ClearFromPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+  ClearFromPours (PCB->Data, TEXT_TYPE, Layer, Text);
   DrawText (Layer, Text, 0);
   Draw ();
   return (Text);
@@ -241,7 +262,7 @@ RotateElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
     /* pre-delete the pins from the pin-tree before their coordinates change */
     if (Data)
       r_delete_entry (Data->pin_tree, (BoxType *) pin);
-    RestoreToPolygon (Data, PIN_TYPE, Element, pin);
+    RestoreToPours (Data, PIN_TYPE, Element, pin);
     ROTATE_PIN_LOWLEVEL (pin, X, Y, Number);
   }
   END_LOOP;
@@ -250,7 +271,7 @@ RotateElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
     /* pre-delete the pads before their coordinates change */
     if (Data)
       r_delete_entry (Data->pad_tree, (BoxType *) pad);
-    RestoreToPolygon (Data, PAD_TYPE, Element, pad);
+    RestoreToPours (Data, PAD_TYPE, Element, pad);
     ROTATE_PAD_LOWLEVEL (pad, X, Y, Number);
   }
   END_LOOP;
@@ -262,7 +283,7 @@ RotateElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
   ROTATE (Element->MarkX, Element->MarkY, X, Y, Number);
   /* SetElementBoundingBox reenters the rtree data */
   SetElementBoundingBox (Data, Element, &PCB->Font);
-  ClearFromPolygon (Data, ELEMENT_TYPE, Element, Element);
+  ClearFromPours (Data, ELEMENT_TYPE, Element, Element);
 }
 
 /* ---------------------------------------------------------------------------
@@ -274,7 +295,7 @@ RotateLinePoint (LayerTypePtr Layer, LineTypePtr Line, PointTypePtr Point)
   EraseLine (Line);
   if (Layer)
     {
-      RestoreToPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+      RestoreToPours (PCB->Data, LINE_TYPE, Layer, Line);
       r_delete_entry (Layer->line_tree, (BoxTypePtr) Line);
     }
   else
@@ -284,7 +305,7 @@ RotateLinePoint (LayerTypePtr Layer, LineTypePtr Line, PointTypePtr Point)
   if (Layer)
     {
       r_insert_entry (Layer->line_tree, (BoxTypePtr) Line, 0);
-      ClearFromPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+      ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
       DrawLine (Layer, Line, 0);
     }
   else
@@ -388,7 +409,7 @@ RotateObject (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
       EraseLine (ptr->Line);
       if (ptr->Layer)
 	{
-	  RestoreToPolygon (PCB->Data, LINE_TYPE, ptr->Layer, ptr->Line);
+	  RestoreToPours (PCB->Data, LINE_TYPE, ptr->Layer, ptr->Line);
 	  r_delete_entry (ptr->Layer->line_tree, (BoxType *) ptr->Line);
 	}
       else
@@ -398,7 +419,7 @@ RotateObject (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
       if (ptr->Layer)
 	{
 	  r_insert_entry (ptr->Layer->line_tree, (BoxType *) ptr->Line, 0);
-	  ClearFromPolygon (PCB->Data, LINE_TYPE, ptr->Layer, ptr->Line);
+	  ClearFromPours (PCB->Data, LINE_TYPE, ptr->Layer, ptr->Line);
 	  DrawLine (ptr->Layer, ptr->Line, 0);
 	}
       else
diff --git a/src/rotate.h b/src/rotate.h
index f032fcb..d5fc399 100644
--- a/src/rotate.h
+++ b/src/rotate.h
@@ -65,6 +65,7 @@ void RotateArcLowLevel (ArcTypePtr, LocationType, LocationType, BYTE);
 void RotateBoxLowLevel (BoxTypePtr, LocationType, LocationType, BYTE);
 void RotateTextLowLevel (TextTypePtr, LocationType, LocationType, BYTE);
 void RotatePolygonLowLevel (PolygonTypePtr, LocationType, LocationType, BYTE);
+void RotatePourLowLevel (PourTypePtr, LocationType, LocationType, BYTE);
 void RotateElementLowLevel (DataTypePtr, ElementTypePtr, LocationType,
 			    LocationType, BYTE);
 void *RotateObject (int, void *, void *, void *, LocationType, LocationType,
diff --git a/src/rtree.c b/src/rtree.c
index fec72bc..c2220a3 100644
--- a/src/rtree.c
+++ b/src/rtree.c
@@ -520,7 +520,7 @@ __r_search (struct rtree_node *node, const BoxType * query, r_arg * arg)
   /** assert that starting_region is well formed */
   assert (query->X1 <= query->X2 && query->Y1 <= query->Y2);
   assert (node->box.X1 < query->X2 && node->box.X2 > query->X1 &&
-          node->box.Y1 < query->Y2 && node->box.Y2 > query->X1);
+          node->box.Y1 < query->Y2 && node->box.Y2 > query->Y1);
 #ifdef SLOW_ASSERTS
   /** assert that node is well formed */
   assert (__r_node_is_good (node));
diff --git a/src/search.c b/src/search.c
index 0d75500..56e23c5 100644
--- a/src/search.c
+++ b/src/search.c
@@ -90,7 +90,7 @@ static Boolean SearchElementNameByLocation (int, ElementTypePtr *,
 					    Boolean);
 static Boolean SearchLinePointByLocation (int, LayerTypePtr *, LineTypePtr *,
 					  PointTypePtr *);
-static Boolean SearchPointByLocation (int, LayerTypePtr *, PolygonTypePtr *,
+static Boolean SearchPourPointByLocation (int, LayerTypePtr *, PourTypePtr *,
 				      PointTypePtr *);
 static Boolean SearchElementByLocation (int, ElementTypePtr *,
 					ElementTypePtr *, ElementTypePtr *,
@@ -512,27 +512,27 @@ SearchLinePointByLocation (int locked, LayerTypePtr * Layer,
 }
 
 /* ---------------------------------------------------------------------------
- * searches a polygon-point on all layers that are switched on
+ * searches a pour-point on all layers that are switched on
  * in layerstack order
  */
 static Boolean
-SearchPointByLocation (int locked, LayerTypePtr * Layer,
-		       PolygonTypePtr * Polygon, PointTypePtr * Point)
+SearchPourPointByLocation (int locked, LayerTypePtr * Layer,
+		       PourTypePtr * Pour, PointTypePtr * Point)
 {
   float d, least;
   Boolean found = False;
 
-  least = SQUARE (SearchRadius + MAX_POLYGON_POINT_DISTANCE);
+  least = SQUARE (SearchRadius + MAX_POUR_POINT_DISTANCE);
   *Layer = SearchLayer;
-  POLYGON_LOOP (*Layer);
+  POUR_LOOP (*Layer);
   {
-    POLYGONPOINT_LOOP (polygon);
+    POURPOINT_LOOP (pour);
     {
       d = SQUARE (point->X - PosX) + SQUARE (point->Y - PosY);
       if (d < least)
 	{
 	  least = d;
-	  *Polygon = polygon;
+	  *Pour = pour;
 	  *Point = point;
 	  found = True;
 	}
@@ -1243,11 +1243,11 @@ SearchObjectByLocation (int Type,
       if (SearchLayer->On)
 	{
 	  if ((HigherAvail & (PIN_TYPE | PAD_TYPE)) == 0 &&
-	      Type & POLYGONPOINT_TYPE &&
-	      SearchPointByLocation (locked,
-				     (LayerTypePtr *) Result1,
-				     (PolygonTypePtr *) Result2,
-				     (PointTypePtr *) Result3))
+	      Type & POURPOINT_TYPE &&
+	      SearchPourPointByLocation (locked,
+					 (LayerTypePtr *) Result1,
+					 (PourTypePtr *) Result2,
+					 (PointTypePtr *) Result3))
 	    return (POLYGONPOINT_TYPE);
 
 	  if ((HigherAvail & (PIN_TYPE | PAD_TYPE)) == 0 &&
@@ -1429,7 +1429,8 @@ SearchObjectByID (DataTypePtr Base,
       }
       ENDALL_LOOP;
     }
-
+#warning FIXME Later
+#if 0
   if (type == POLYGON_TYPE || type == POLYGONPOINT_TYPE)
     {
       ALLPOLYGON_LOOP (Base);
@@ -1455,6 +1456,33 @@ SearchObjectByID (DataTypePtr Base,
       }
       ENDALL_LOOP;
     }
+#endif
+  if (type == POUR_TYPE || type == POURPOINT_TYPE)
+    {
+      ALLPOUR_LOOP (Base);
+      {
+	if (pour->ID == ID)
+	  {
+	    *Result1 = (void *) layer;
+	    *Result2 = *Result3 = (void *) pour;
+	    return (POUR_TYPE);
+	  }
+	if (type == POURPOINT_TYPE)
+	  POURPOINT_LOOP (pour);
+	{
+	  if (point->ID == ID)
+	    {
+	      *Result1 = (void *) layer;
+	      *Result2 = (void *) pour;
+	      *Result3 = (void *) point;
+	      return (POURPOINT_TYPE);
+	    }
+	}
+	END_LOOP;
+      }
+      ENDALL_LOOP;
+    }
+
   if (type == VIA_TYPE)
     {
       VIA_LOOP (Base);
diff --git a/src/search.h b/src/search.h
index 3164605..a073f6c 100644
--- a/src/search.h
+++ b/src/search.h
@@ -59,8 +59,13 @@
 #define	TEXT_IN_BOX(t,b)	\
 	(BOX_IN_BOX(&((t)->BoundingBox), (b)))
 
+#if 0 // NOT USED
 #define	POLYGON_IN_BOX(p,b)	\
 	(BOX_IN_BOX(&((p)->BoundingBox), (b)))
+#endif
+
+#define	POUR_IN_BOX(p,b)	\
+	(BOX_IN_BOX(&((p)->BoundingBox), (b)))
 
 #define	ELEMENT_IN_BOX(e,b)	\
 	(BOX_IN_BOX(&((e)->BoundingBox), (b)))
diff --git a/src/select.c b/src/select.c
index 7b96fec..49d7535 100644
--- a/src/select.c
+++ b/src/select.c
@@ -340,8 +340,20 @@ SelectBlock (BoxTypePtr Box, Boolean Flag)
 	}
     }
     END_LOOP;
-    POLYGON_LOOP (layer);
+    POUR_LOOP (layer);
     {
+#warning FIXME Later: Do we want to be able to select the polygon pieces?
+      if (POUR_IN_BOX (pour, Box)
+	  && !TEST_FLAG (LOCKFLAG, pour)
+	  && TEST_FLAG (SELECTEDFLAG, pour) != Flag)
+	{
+	  AddObjectToFlagUndoList (POUR_TYPE, layer, pour, pour);
+	  ASSIGN_FLAG (SELECTEDFLAG, Flag, pour);
+	  if (layer->On)
+	    DrawPour (layer, pour, 0);
+	  changed = True;
+	}
+#if 0
       if (POLYGON_IN_BOX (polygon, Box)
 	  && !TEST_FLAG (LOCKFLAG, polygon)
 	  && TEST_FLAG (SELECTEDFLAG, polygon) != Flag)
@@ -352,6 +364,7 @@ SelectBlock (BoxTypePtr Box, Boolean Flag)
 	    DrawPolygon (layer, polygon, 0);
 	  changed = True;
 	}
+#endif
     }
     END_LOOP;
   }
@@ -513,8 +526,19 @@ ObjectOperation (ObjectFunctionTypePtr F,
       break;
 
     case POLYGONPOINT_TYPE:
-      if (F->Point)
-	return (F->Point ((LayerTypePtr) Ptr1, (PolygonTypePtr) Ptr2,
+      if (F->PolygonPoint)
+	return (F->PolygonPoint ((LayerTypePtr) Ptr1, (PolygonTypePtr) Ptr2,
+			  (PointTypePtr) Ptr3));
+      break;
+
+    case POUR_TYPE:
+      if (F->Pour)
+	return (F->Pour ((LayerTypePtr) Ptr1, (PourTypePtr) Ptr2));
+      break;
+
+    case POURPOINT_TYPE:
+      if (F->PourPoint)
+	return (F->PourPoint ((LayerTypePtr) Ptr1, (PourTypePtr) Ptr2,
 			  (PointTypePtr) Ptr3));
       break;
 
@@ -615,19 +639,40 @@ SelectedOperation (ObjectFunctionTypePtr F, Boolean Reset, int type)
 
   /* check polygons */
   if (type & POLYGON_TYPE && F->Polygon)
-    VISIBLEPOLYGON_LOOP (PCB->Data);
-  {
-    if (TEST_FLAG (SELECTEDFLAG, polygon))
+    VISIBLEPOUR_LOOP (PCB->Data);
+    {
+      POURPOLYGON_LOOP (pour);
       {
-	if (Reset)
-	  {
-	    AddObjectToFlagUndoList (POLYGON_TYPE, layer, polygon, polygon);
-	    CLEAR_FLAG (SELECTEDFLAG, polygon);
-	  }
-	F->Polygon (layer, polygon);
-	changed = True;
+        if (TEST_FLAG (SELECTEDFLAG, polygon))
+          {
+            if (Reset)
+              {
+                AddObjectToFlagUndoList (POLYGON_TYPE, layer, polygon, polygon);
+                CLEAR_FLAG (SELECTEDFLAG, polygon);
+              }
+            F->Polygon (layer, polygon);
+            changed = True;
+          }
       }
-  }
+      END_LOOP;
+    }
+  ENDALL_LOOP;
+
+  /* check pours */
+  if (type & POUR_TYPE && F->Pour)
+    VISIBLEPOUR_LOOP (PCB->Data);
+    {
+      if (TEST_FLAG (SELECTEDFLAG, pour))
+        {
+          if (Reset)
+            {
+              AddObjectToFlagUndoList (POUR_TYPE, layer, pour, pour);
+              CLEAR_FLAG (SELECTEDFLAG, pour);
+            }
+          F->Pour (layer, pour);
+          changed = True;
+        }
+    }
   ENDALL_LOOP;
 
   /* elements silkscreen */
@@ -789,15 +834,19 @@ SelectConnection (Boolean Flag)
       }
   }
   ENDALL_LOOP;
-  VISIBLEPOLYGON_LOOP (PCB->Data);
+  VISIBLEPOUR_LOOP (PCB->Data);
   {
-    if (TEST_FLAG (FOUNDFLAG, polygon) && !TEST_FLAG (LOCKFLAG, polygon))
-      {
-	AddObjectToFlagUndoList (POLYGON_TYPE, layer, polygon, polygon);
-	ASSIGN_FLAG (SELECTEDFLAG, Flag, polygon);
-	DrawPolygon (layer, polygon, 0);
-	changed = True;
-      }
+    POURPOLYGON_LOOP (pour);
+    {
+      if (TEST_FLAG (FOUNDFLAG, polygon) && !TEST_FLAG (LOCKFLAG, polygon))
+        {
+          AddObjectToFlagUndoList (POLYGON_TYPE, layer, polygon, polygon);
+          ASSIGN_FLAG (SELECTEDFLAG, Flag, polygon);
+          DrawPolygon (layer, polygon, 0);
+          changed = True;
+        }
+    }
+    END_LOOP;
   }
   ENDALL_LOOP;
 
diff --git a/src/select.h b/src/select.h
index 7a48dae..373510e 100644
--- a/src/select.h
+++ b/src/select.h
@@ -33,8 +33,9 @@
 
 #include "global.h"
 
+#warning FIXME Later: Do we want pours / polygons selectable?
 #define SELECT_TYPES	\
-	(VIA_TYPE | LINE_TYPE | TEXT_TYPE | POLYGON_TYPE | ELEMENT_TYPE |	\
+	(VIA_TYPE | LINE_TYPE | TEXT_TYPE | POLYGON_TYPE | POUR_TYPE | ELEMENT_TYPE |	\
 	 PIN_TYPE | PAD_TYPE | ELEMENTNAME_TYPE | RATLINE_TYPE | ARC_TYPE)
 
 void SelectPin (LibraryEntryTypePtr entry, Boolean toggle);
diff --git a/src/set.c b/src/set.c
index 912db04..e9ced1d 100644
--- a/src/set.c
+++ b/src/set.c
@@ -248,11 +248,11 @@ SetMode (int Mode)
   addedLines = 0;
   Crosshair.AttachedObject.Type = NO_TYPE;
   Crosshair.AttachedObject.State = STATE_FIRST;
-  Crosshair.AttachedPolygon.PointN = 0;
+  Crosshair.AttachedPour.PointN = 0;
   if (PCB->RatDraw)
     {
       if (Mode == ARC_MODE || Mode == RECTANGLE_MODE ||
-	  Mode == VIA_MODE || Mode == POLYGON_MODE ||
+	  Mode == VIA_MODE || Mode == POUR_MODE ||
 	  Mode == TEXT_MODE || Mode == INSERTPOINT_MODE ||
 	  Mode == THERMAL_MODE)
 	{
diff --git a/src/undo.c b/src/undo.c
index 998fc2c..1d28386 100644
--- a/src/undo.c
+++ b/src/undo.c
@@ -62,6 +62,7 @@
 #include "move.h"
 #include "mymem.h"
 #include "polygon.h"
+#include "pour.h"
 #include "remove.h"
 #include "rotate.h"
 #include "rtree.h"
@@ -320,9 +321,9 @@ UndoClearPoly (UndoListTypePtr Entry)
   if (type != NO_TYPE)
     {
       if (Entry->Data.ClearPoly.Clear)
-	RestoreToPolygon (PCB->Data, type, Entry->Data.ClearPoly.Layer, ptr3);
+	RestoreToPours (PCB->Data, type, Entry->Data.ClearPoly.Layer, ptr3);
       else
-	ClearFromPolygon (PCB->Data, type, Entry->Data.ClearPoly.Layer, ptr3);
+	ClearFromPours (PCB->Data, type, Entry->Data.ClearPoly.Layer, ptr3);
       Entry->Data.ClearPoly.Clear = !Entry->Data.ClearPoly.Clear;
       return True;
     }
@@ -436,11 +437,11 @@ UndoChangeClearSize (UndoListTypePtr Entry)
       if (TEST_FLAG (LOCKFLAG, (LineTypePtr) ptr2))
 	return (False);
       swap = ((PinTypePtr) ptr2)->Clearance;
-      RestoreToPolygon (PCB->Data, type, ptr1, ptr2);
+      RestoreToPours (PCB->Data, type, ptr1, ptr2);
       if (andDraw)
 	EraseObject (type, ptr1, ptr2);
       ((PinTypePtr) ptr2)->Clearance = Entry->Data.Size;
-      ClearFromPolygon (PCB->Data, type, ptr1, ptr2);
+      ClearFromPours (PCB->Data, type, ptr1, ptr2);
       Entry->Data.Size = swap;
       if (andDraw)
 	DrawObject (type, ptr1, ptr2, 0);
@@ -504,12 +505,12 @@ UndoChangeSize (UndoListTypePtr Entry)
       /* Wow! can any object be treated as a pin type for size change?? */
       /* pins, vias, lines, and arcs can. Text can't but it has it's own mechanism */
       swap = ((PinTypePtr) ptr2)->Thickness;
-      RestoreToPolygon (PCB->Data, type, ptr1, ptr2);
+      RestoreToPours (PCB->Data, type, ptr1, ptr2);
       if (andDraw)
 	EraseObject (type, ptr1, ptr2);
       ((PinTypePtr) ptr2)->Thickness = Entry->Data.Size;
       Entry->Data.Size = swap;
-      ClearFromPolygon (PCB->Data, type, ptr1, ptr2);
+      ClearFromPours (PCB->Data, type, ptr1, ptr2);
       if (andDraw)
 	DrawObject (type, ptr1, ptr2, 0);
       return (True);
@@ -710,35 +711,35 @@ static Boolean
 UndoRemovePoint (UndoListTypePtr Entry)
 {
   LayerTypePtr layer;
-  PolygonTypePtr polygon;
+  PourTypePtr pour;
   void *ptr3;
   int type;
 
   /* lookup entry (polygon not point was saved) by it's ID */
-  assert (Entry->Kind == POLYGON_TYPE);
+  assert (Entry->Kind == POUR_TYPE);
   type =
-    SearchObjectByID (PCB->Data, (void *) &layer, (void *) &polygon, &ptr3,
+    SearchObjectByID (PCB->Data, (void *) &layer, (void *) &pour, &ptr3,
 		      Entry->ID, Entry->Kind);
   switch (type)
     {
-    case POLYGON_TYPE:		/* restore the removed point */
+    case POUR_TYPE:		/* restore the removed point */
       {
-	if (TEST_FLAG (LOCKFLAG, polygon))
+	if (TEST_FLAG (LOCKFLAG, pour))
 	  return (False);
 	/* recover the point */
 	if (andDraw && layer->On)
-	  ErasePolygon (polygon);
-	InsertPointIntoObject (POLYGON_TYPE, layer, polygon,
+	  ErasePour (pour);
+	InsertPointIntoObject (POUR_TYPE, layer, pour,
 			       &Entry->Data.RemovedPoint.Index,
 			       Entry->Data.RemovedPoint.X,
 			       Entry->Data.RemovedPoint.Y, True);
-	polygon->Points[Entry->Data.RemovedPoint.Index].ID =
+	pour->Points[Entry->Data.RemovedPoint.Index].ID =
 	  Entry->Data.RemovedPoint.ID;
 	if (andDraw && layer->On)
-	  DrawPolygon (layer, polygon, 0);
+	  DrawPour (layer, pour, 0);
 	Entry->Type = UNDO_INSERT_POINT;
 	Entry->ID = Entry->Data.RemovedPoint.ID;
-	Entry->Kind = POLYGONPOINT_TYPE;
+	Entry->Kind = POURPOINT_TYPE;
 	return (True);
       }
 
@@ -748,37 +749,37 @@ UndoRemovePoint (UndoListTypePtr Entry)
 }
 
 /* ---------------------------------------------------------------------------
- * recovers an inserted polygon point
+ * recovers an inserted pour point
  * returns true on success
  */
 static Boolean
 UndoInsertPoint (UndoListTypePtr Entry)
 {
   LayerTypePtr layer;
-  PolygonTypePtr polygon;
+  PourTypePtr pour;
   PointTypePtr pnt;
   int type;
 
-  assert (Entry->Kind == POLYGONPOINT_TYPE);
+  assert (Entry->Kind == POURPOINT_TYPE);
   /* lookup entry by it's ID */
   type =
-    SearchObjectByID (PCB->Data, (void *) &layer, (void *) &polygon,
+    SearchObjectByID (PCB->Data, (void *) &layer, (void *) &pour,
 		      (void *) &pnt, Entry->ID, Entry->Kind);
   switch (type)
     {
-    case POLYGONPOINT_TYPE:	/* removes an inserted polygon point */
+    case POURPOINT_TYPE:	/* removes an inserted pour point */
       {
-	if (TEST_FLAG (LOCKFLAG, polygon))
+	if (TEST_FLAG (LOCKFLAG, pour))
 	  return (False);
 	if (andDraw && layer->On)
-	  ErasePolygon (polygon);
+	  ErasePour (pour);
 	Entry->Data.RemovedPoint.X = pnt->X;
 	Entry->Data.RemovedPoint.Y = pnt->Y;
 	Entry->Data.RemovedPoint.ID = pnt->ID;
-	Entry->ID = polygon->ID;
-	Entry->Kind = POLYGON_TYPE;
+	Entry->ID = pour->ID;
+	Entry->Kind = POUR_TYPE;
 	Entry->Type = UNDO_REMOVE_POINT;
-	POLYGONPOINT_LOOP (polygon);
+	POURPOINT_LOOP (pour);
 	{
 	  if (pnt == point)
 	    {
@@ -787,9 +788,9 @@ UndoInsertPoint (UndoListTypePtr Entry)
 	    }
 	}
 	END_LOOP;
-	DestroyObject (PCB->Data, POLYGONPOINT_TYPE, layer, polygon, pnt);
+	DestroyObject (PCB->Data, POURPOINT_TYPE, layer, pour, pnt);
 	if (andDraw && layer->On)
-	  DrawPolygon (layer, polygon, 0);
+	  DrawPour (layer, pour, 0);
 	return (True);
       }
 
@@ -1161,6 +1162,16 @@ AddObjectToClearPolyUndoList (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
 }
 
 /* ---------------------------------------------------------------------------
+ * adds an object to the list of clearpoly objects
+ */
+void
+AddObjectToClearPourUndoList (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
+			      Boolean clear)
+{
+  printf ("FIXME Later\n");
+}
+
+/* ---------------------------------------------------------------------------
  * adds an object to the list of mirrored objects
  */
 void
@@ -1222,23 +1233,23 @@ AddObjectToRemovePointUndoList (int Type,
 				void *Ptr1, void *Ptr2, Cardinal index)
 {
   UndoListTypePtr undo;
-  PolygonTypePtr polygon = (PolygonTypePtr) Ptr2;
+  PourTypePtr pour = (PourTypePtr) Ptr2;
 
   if (!Locked)
     {
       switch (Type)
 	{
-	case POLYGONPOINT_TYPE:
+	case POURPOINT_TYPE:
 	  {
 	    /* save the ID of the parent object; else it will be
 	     * impossible to recover the point
 	     */
 	    undo =
-	      GetUndoSlot (UNDO_REMOVE_POINT, OBJECT_ID (polygon),
-			   POLYGON_TYPE);
-	    undo->Data.RemovedPoint.X = polygon->Points[index].X;
-	    undo->Data.RemovedPoint.Y = polygon->Points[index].Y;
-	    undo->Data.RemovedPoint.ID = polygon->Points[index].ID;
+	      GetUndoSlot (UNDO_REMOVE_POINT, OBJECT_ID (pour),
+			   POUR_TYPE);
+	    undo->Data.RemovedPoint.X = pour->Points[index].X;
+	    undo->Data.RemovedPoint.Y = pour->Points[index].Y;
+	    undo->Data.RemovedPoint.ID = pour->Points[index].ID;
 	    undo->Data.RemovedPoint.Index = index;
 	  }
 	  break;
@@ -1317,7 +1328,7 @@ AddObjectToCreateUndoList (int Type, void *Ptr1, void *Ptr2, void *Ptr3)
 
   if (!Locked)
     undo = GetUndoSlot (UNDO_CREATE, OBJECT_ID (Ptr3), Type);
-  ClearFromPolygon (PCB->Data, Type, Ptr1, Ptr2);
+  ClearFromPours (PCB->Data, Type, Ptr1, Ptr2);
 }
 
 /* ---------------------------------------------------------------------------
diff --git a/src/undo.h b/src/undo.h
index a138927..1ff1ca7 100644
--- a/src/undo.h
+++ b/src/undo.h
@@ -62,6 +62,7 @@ void AddObjectToClearSizeUndoList (int, void *, void *, void *);
 void AddObjectToMaskSizeUndoList (int, void *, void *, void *);
 void AddObjectToChangeAnglesUndoList (int, void *, void *, void *);
 void AddObjectToClearPolyUndoList (int, void *, void *, void *, Boolean);
+void AddObjectToClearPourUndoList (int, void *, void *, void *, Boolean);
 void AddLayerChangeToUndoList (int, int);
 void AddNetlistLibToUndoList (LibraryTypePtr);
 void LockUndo (void);

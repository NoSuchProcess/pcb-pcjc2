Bottom: 7374e1a63877d1d7366c1d652245d608b5c6f253
Top:    c474f54bb07d596e1cdc879ee172db4605529a8e
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2008-10-22 00:28:57 +0100

Make rats to polygons work for arbitrary clipped shapes





---

diff --git a/src/polygon.c b/src/polygon.c
index 3086be6..64f0e2b 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -1411,6 +1411,16 @@ IsPointInPolygon (LocationType X, LocationType Y, BDimension r,
   return isects (c, p, True);
 }
 
+
+Boolean
+IsPointInPolygonIgnoreHoles (LocationType X, LocationType Y, PolygonTypePtr p)
+{
+  Vector v;
+  v[0] = X;
+  v[1] = Y;
+  return poly_InsideContour (p->Clipped->contours, v);
+}
+
 Boolean
 IsRectangleInPolygon (LocationType X1, LocationType Y1, LocationType X2,
                       LocationType Y2, PolygonTypePtr p)
diff --git a/src/polygon.h b/src/polygon.h
index 721ba95..c9672e2 100644
--- a/src/polygon.h
+++ b/src/polygon.h
@@ -57,6 +57,7 @@ void RestoreToPolygon(DataType *, int, void *, void *);
 void ClearFromPolygon(DataType *, int, void *, void *);
 
 Boolean IsPointInPolygon (LocationType, LocationType, BDimension, PolygonTypePtr);
+Boolean IsPointInPolygonIgnoreHoles (LocationType, LocationType, PolygonTypePtr);
 Boolean IsRectangleInPolygon (LocationType, LocationType, LocationType,
 			      LocationType, PolygonTypePtr);
 Boolean isects (POLYAREA *, PolygonTypePtr, Boolean);
diff --git a/src/rats.c b/src/rats.c
index cb3b1d0..6e8d369 100644
--- a/src/rats.c
+++ b/src/rats.c
@@ -512,24 +512,11 @@ GatherSubnets (NetListTypePtr Netl, Boolean NoWarn, Boolean AndRats)
 	  }
       }
       ENDALL_LOOP;
-      /* add rectangular polygons so the auto-router can see them as targets */
-      /* NB: code in DrawShortestRats below relies on only rectangular polys */
+      /* add polygons so the auto-router can see them as targets */
       ALLPOLYGON_LOOP (PCB->Data);
       {
-	if (TEST_FLAG (DRCFLAG, polygon) && polygon->PointN == 4)
+	if (TEST_FLAG (DRCFLAG, polygon))
 	  {
-	    if (polygon->Points[0].X != polygon->Points[1].X &&
-		polygon->Points[0].Y != polygon->Points[1].Y)
-	      continue;
-	    if (polygon->Points[1].X != polygon->Points[2].X &&
-		polygon->Points[1].Y != polygon->Points[2].Y)
-	      continue;
-	    if (polygon->Points[2].X != polygon->Points[3].X &&
-		polygon->Points[2].Y != polygon->Points[3].Y)
-	      continue;
-	    if (polygon->Points[0].X != polygon->Points[3].X &&
-		polygon->Points[0].Y != polygon->Points[3].Y)
-	      continue;
 	    conn = GetConnectionMemory (a);
 	    /* make point on a vertex */
 	    conn->X = polygon->Clipped->contours->head.point[0];
@@ -611,10 +598,9 @@ DrawShortestRats (NetListTypePtr Netl, void (*funcp) ())
 		   */
 		  if (conn1->type == POLYGON_TYPE &&
 		      (polygon = (PolygonTypePtr)conn1->ptr2) &&
-		      IsPointInBox (conn2->X, conn2->Y, (BoxTypePtr)polygon, 0)
-		      && !(distance == 0 &&
-			   firstpoint && firstpoint->type == VIA_TYPE))
-		      // IsPointInPolygon (conn2->X, conn2->Y, 0, polygon))
+		      !(distance == 0 &&
+		        firstpoint && firstpoint->type == VIA_TYPE) &&
+		      IsPointInPolygonIgnoreHoles (conn2->X, conn2->Y, polygon))
 		    {
 		      distance = 0;
 		      firstpoint = conn2;
@@ -623,10 +609,9 @@ DrawShortestRats (NetListTypePtr Netl, void (*funcp) ())
 		    }
 		  else if (conn2->type == POLYGON_TYPE &&
 		      (polygon = (PolygonTypePtr)conn2->ptr2) &&
-		      IsPointInBox (conn1->X, conn1->Y, (BoxTypePtr)polygon, 0)
-		      && !(distance == 0 &&
-			   firstpoint && firstpoint->type == VIA_TYPE))
-		      // IsPointInPolygon (conn1->X, conn1->Y, 0, polygon))
+		      !(distance == 0 &&
+		        firstpoint && firstpoint->type == VIA_TYPE) &&
+		      IsPointInPolygonIgnoreHoles (conn1->X, conn1->Y, polygon))
 		    {
 		      distance = 0;
 		      firstpoint = conn1;

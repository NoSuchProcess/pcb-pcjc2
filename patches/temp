Bottom: 94b22a164077e4efdbc63f20fffbaafe9bbef89b
Top:    a9cf0346d1c4c6bf610f0126c3e90a141fd2927d
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-10-21 23:35:58 +0100

TEMP


---

diff --git a/src/hid/common/draw_helpers.c b/src/hid/common/draw_helpers.c
index ded1bc8..577a09b 100644
--- a/src/hid/common/draw_helpers.c
+++ b/src/hid/common/draw_helpers.c
@@ -79,7 +79,7 @@ void common_fill_pcb_polygon (hidGC gc, PolygonType *poly,
       PLINE *pl;
 
       for (pl = poly->NoHoles; pl != NULL; pl = pl->next)
-        fill_contour (gc, pl);
+        thindraw_contour (gc, pl);
     }
 
   /* Draw other parts of the polygon if fullpoly flag is set */
diff --git a/src/polygon.c b/src/polygon.c
index 07abfb7..f5e6b79 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -1541,13 +1541,14 @@ IsRectangleInPolygon (LocationType X1, LocationType Y1, LocationType X2,
   return isects (s, p, True);
 }
 
+/* NB: This function will free the passed POLYAREA.
+ *     It must only be passed a single POLYAREA (pa->f == pa->b == pa)
+ */
 static void
 r_NoHolesPolygonDicer (POLYAREA * pa,
                        void (*emit) (PLINE *, void *), void *user_data)
 {
   PLINE *p = pa->contours;
-#warning DO WE NEED TO SAVE THIS POINTER?
-  pa->b = pa->f = pa;
 
   if (!pa->contours->next)                 /* no holes */
     {
@@ -1561,9 +1562,8 @@ r_NoHolesPolygonDicer (POLYAREA * pa,
       POLYAREA *poly2, *left, *right;
 
       /* make a rectangle of the left region slicing through the middle of the first hole */
-      poly2 =
-        RectPoly (p->xmin, (p->next->xmin + p->next->xmax) / 2, p->ymin,
-                  p->ymax);
+      poly2 = RectPoly (p->xmin, (p->next->xmin + p->next->xmax) / 2,
+                        p->ymin, p->ymax);
       poly_AndSubtract_free (pa, poly2, &left, &right);
       if (left)
         {
@@ -1572,14 +1572,11 @@ r_NoHolesPolygonDicer (POLYAREA * pa,
           do
             {
               next = cur->f;
-//              PLINE *pl = x->contours;
+              cur->f = cur->b = cur; /* Detach this polygon piece */
               r_NoHolesPolygonDicer (cur, emit, user_data);
-//              y = x->f;
-              /* the pline was already freed by its use int he recursive dicer */
-//              free (x);
+              /* NB: The POLYAREA was freed by its use in the recursive dicer */
             }
           while ((cur = next) != left);
-//          while ((x = y) != left);
         }
       if (right)
         {
@@ -1588,10 +1585,9 @@ r_NoHolesPolygonDicer (POLYAREA * pa,
           do
             {
               next = cur->f;
-//              PLINE *pl = x->contours;
+              cur->f = cur->b = cur; /* Detach this polygon piece */
               r_NoHolesPolygonDicer (cur, emit, user_data);
-//              y = x->f;
-//              free (x);
+              /* NB: The POLYAREA was freed by its use in the recursive dicer */
             }
           while ((cur = next) != right);
         }
@@ -1622,19 +1618,7 @@ NoHolesPolygonDicer (PolygonTypePtr p, const BoxType * clip,
   if (!save)
     return;
   /* now dice it up */
-  do
-    {
-      POLYAREA *next;
-      next = save->f;
-
-      r_NoHolesPolygonDicer (save, emit, user_data);
-      /* go to next poly (could be one because of clip) */
-
-      save = next;
-      /* free the previouse POLYAREA. Note the contour was consumed in the dicer */
-//      free (prev);
-    }
-  while (save != ans);
+  r_NoHolesPolygonDicer (save, emit, user_data);
 }
 
 /* make a polygon split into multiple parts into multiple polygons */

Bottom: 1f958a5461ada681823fbb35277b323f5b5328e7
Top:    6abafd82f0696750436d4cbeecb610aa837f9016
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-11-05 18:47:30 +0000

Remove unused cairo bits


---

diff --git a/src/Makefile.am b/src/Makefile.am
index 1d90779..b69be51 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -38,32 +38,18 @@ PCB_SRCS = \
 	buffer.c \
 	buffer.h \
 	cairo/cairo.h \
-	cairo/cairoint.h \
-	cairo/cairo-atomic-private.h \
+	cairo/cairoint-minimal.h \
 	cairo/cairo-bentley-ottmann.c \
-	cairo/cairo-cache-private.h \
-	cairo/cairo-clip-private.h \
 	cairo/cairo-combsort-private.h \
 	cairo/cairo-compiler-private.h \
 	cairo/cairo-fixed-private.h \
 	cairo/cairo-fixed-type-private.h \
 	cairo/cairo-freelist.c \
 	cairo/cairo-freelist-private.h \
-	cairo/cairo-hash-private.h \
 	cairo/cairo-list-private.h \
 	cairo/cairo-malloc-private.h \
-	cairo/cairo-mutex-impl-private.h \
-	cairo/cairo-mutex-list-private.h \
-	cairo/cairo-mutex-private.h \
-	cairo/cairo-mutex-type-private.h \
-	cairo/cairo-path-fixed-private.h \
-	cairo/cairo-reference-count-private.h \
-	cairo/cairo-region-private.h \
-	cairo/cairo-scaled-font-private.h \
-	cairo/cairo-slope-private.h \
-	cairo/cairo-spans-private.h \
-	cairo/cairo-surface-private.h \
 	cairo/cairo-traps.c \
+	cairo/cairo-traps-private.h \
 	cairo/cairo-types-private.h \
 	cairo/cairo-wideint.c \
 	cairo/cairo-wideint-private.h \
diff --git a/src/cairo/cairo-atomic-private.h b/src/cairo/cairo-atomic-private.h
deleted file mode 100644
index 8532f62..0000000
--- a/src/cairo/cairo-atomic-private.h
+++ /dev/null
@@ -1,160 +0,0 @@
-/* cairo - a vector graphics library with display and print output
- *
- * Copyright © 2007 Chris Wilson
- *
- * This library is free software; you can redistribute it and/or
- * modify it either under the terms of the GNU Lesser General Public
- * License version 2.1 as published by the Free Software Foundation
- * (the "LGPL") or, at your option, under the terms of the Mozilla
- * Public License Version 1.1 (the "MPL"). If you do not alter this
- * notice, a recipient may use your version of this file under either
- * the MPL or the LGPL.
- *
- * You should have received a copy of the LGPL along with this library
- * in the file COPYING-LGPL-2.1; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- * You should have received a copy of the MPL along with this library
- * in the file COPYING-MPL-1.1
- *
- * The contents of this file are subject to the Mozilla Public License
- * Version 1.1 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
- * OF ANY KIND, either express or implied. See the LGPL or the MPL for
- * the specific language governing rights and limitations.
- *
- * The Original Code is the cairo graphics library.
- *
- * The Initial Developer of the Original Code is University of Southern
- * California.
- *
- * Contributor(s):
- *	Chris Wilson <chris@chris-wilson.co.uk>
- */
-
-#ifndef CAIRO_ATOMIC_PRIVATE_H
-#define CAIRO_ATOMIC_PRIVATE_H
-
-# include "cairo-compiler-private.h"
-
-#if HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-/* The autoconf on OpenBSD 4.5 produces the malformed constant name
- * SIZEOF_VOID__ rather than SIZEOF_VOID_P.  Work around that here. */
-#if !defined(SIZEOF_VOID_P) && defined(SIZEOF_VOID__)
-# define SIZEOF_VOID_P SIZEOF_VOID__
-#endif
-
-CAIRO_BEGIN_DECLS
-
-#if HAVE_INTEL_ATOMIC_PRIMITIVES
-
-#define HAS_ATOMIC_OPS 1
-
-typedef int cairo_atomic_int_t;
-
-# define _cairo_atomic_int_get(x) (*x)
-# define _cairo_atomic_int_set(x, value) ((*x) = value)
-
-# define _cairo_atomic_int_inc(x) ((void) __sync_fetch_and_add(x, 1))
-# define _cairo_atomic_int_dec_and_test(x) (__sync_fetch_and_add(x, -1) == 1)
-# define _cairo_atomic_int_cmpxchg(x, oldv, newv) __sync_val_compare_and_swap (x, oldv, newv)
-
-#if SIZEOF_VOID_P==SIZEOF_INT
-typedef int cairo_atomic_intptr_t;
-#elif SIZEOF_VOID_P==SIZEOF_LONG
-typedef long cairo_atomic_intptr_t;
-#elif SIZEOF_VOID_P==SIZEOF_LONG_LONG
-typedef long long cairo_atomic_intptr_t;
-#else
-#error No matching integer pointer type
-#endif
-
-# define _cairo_atomic_ptr_cmpxchg(x, oldv, newv) \
-    (void*)__sync_val_compare_and_swap ((cairo_atomic_intptr_t*)x, (cairo_atomic_intptr_t)oldv, (cairo_atomic_intptr_t)newv)
-
-#endif
-
-#if HAVE_LIB_ATOMIC_OPS
-#include <atomic_ops.h>
-
-#define HAS_ATOMIC_OPS 1
-
-typedef  AO_t cairo_atomic_int_t;
-
-# define _cairo_atomic_int_get(x) (AO_load_full (x))
-# define _cairo_atomic_int_set(x, value) (AO_store_full (x))
-
-# define _cairo_atomic_int_inc(x) ((void) AO_fetch_and_add1_full(x))
-# define _cairo_atomic_int_dec_and_test(x) (AO_fetch_and_sub1_full(x) == 1)
-# define _cairo_atomic_int_cmpxchg(x, oldv, newv) ((cairo_atomic_int_t) AO_compare_and_swap_full(x, oldv, newv) ? oldv : *x)
-
-#if SIZEOF_VOID_P==SIZEOF_INT
-typedef unsigned int cairo_atomic_intptr_t;
-#elif SIZEOF_VOID_P==SIZEOF_LONG
-typedef unsigned long cairo_atomic_intptr_t;
-#elif SIZEOF_VOID_P==SIZEOF_LONG_LONG
-typedef unsigned long long cairo_atomic_intptr_t;
-#else
-#error No matching integer pointer type
-#endif
-
-# define _cairo_atomic_ptr_cmpxchg(x, oldv, newv) \
-    (void*) (cairo_atomic_intptr_t) _cairo_atomic_int_cmpxchg ((cairo_atomic_intptr_t*)(x), (cairo_atomic_intptr_t)oldv, (cairo_atomic_intptr_t)newv)
-
-#endif
-
-
-#ifndef HAS_ATOMIC_OPS
-
-typedef int cairo_atomic_int_t;
-
-cairo_private void
-_cairo_atomic_int_inc (int *x);
-
-cairo_private cairo_bool_t
-_cairo_atomic_int_dec_and_test (int *x);
-
-cairo_private int
-_cairo_atomic_int_cmpxchg (int *x, int oldv, int newv);
-
-cairo_private void *
-_cairo_atomic_ptr_cmpxchg (void **x, void *oldv, void *newv);
-
-#ifdef ATOMIC_OP_NEEDS_MEMORY_BARRIER
-
-# include "cairo-compiler-private.h"
-
-cairo_private int
-_cairo_atomic_int_get (int *x);
-
-cairo_private void
-_cairo_atomic_int_set (int *x, int value);
-
-#else
-
-# define _cairo_atomic_int_get(x) (*x)
-# define _cairo_atomic_int_set(x, value) ((*x) = value)
-
-#endif
-
-#endif
-
-#define _cairo_atomic_uint_get(x) _cairo_atomic_int_get(x)
-#define _cairo_atomic_uint_cmpxchg(x, oldv, newv) \
-    _cairo_atomic_int_cmpxchg((cairo_atomic_int_t *)x, oldv, newv)
-
-#define _cairo_status_set_error(status, err) do { \
-    /* hide compiler warnings about cairo_status_t != int (gcc treats its as \
-     * an unsigned integer instead, and about ignoring the return value. */  \
-    int ret__ = _cairo_atomic_int_cmpxchg ((cairo_atomic_int_t *) status, CAIRO_STATUS_SUCCESS, err); \
-    (void) ret__; \
-} while (0)
-
-CAIRO_END_DECLS
-
-#endif
diff --git a/src/cairo/cairo-bentley-ottmann.c b/src/cairo/cairo-bentley-ottmann.c
index 057f4aa..22fa43c 100644
--- a/src/cairo/cairo-bentley-ottmann.c
+++ b/src/cairo/cairo-bentley-ottmann.c
@@ -38,8 +38,10 @@
  */
 
 /* Provide definitions for standalone compilation */
-#include "cairoint.h"
-
+#include "cairoint-minimal.h"
+#include "cairo-malloc-private.h"
+#include "cairo-traps-private.h"
+#include "cairo-fixed-private.h"
 #include "cairo-freelist-private.h"
 #include "cairo-combsort-private.h"
 
diff --git a/src/cairo/cairo-cache-private.h b/src/cairo/cairo-cache-private.h
deleted file mode 100644
index 49ff69c..0000000
--- a/src/cairo/cairo-cache-private.h
+++ /dev/null
@@ -1,145 +0,0 @@
-/* cairo - a vector graphics library with display and print output
- *
- * Copyright © 2004 Red Hat, Inc.
- * Copyright © 2005 Red Hat, Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it either under the terms of the GNU Lesser General Public
- * License version 2.1 as published by the Free Software Foundation
- * (the "LGPL") or, at your option, under the terms of the Mozilla
- * Public License Version 1.1 (the "MPL"). If you do not alter this
- * notice, a recipient may use your version of this file under either
- * the MPL or the LGPL.
- *
- * You should have received a copy of the LGPL along with this library
- * in the file COPYING-LGPL-2.1; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- * You should have received a copy of the MPL along with this library
- * in the file COPYING-MPL-1.1
- *
- * The contents of this file are subject to the Mozilla Public License
- * Version 1.1 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
- * OF ANY KIND, either express or implied. See the LGPL or the MPL for
- * the specific language governing rights and limitations.
- *
- * The Original Code is the cairo graphics library.
- *
- * The Initial Developer of the Original Code is Red Hat, Inc.
- *
- * Contributor(s):
- *      Keith Packard <keithp@keithp.com>
- *	Graydon Hoare <graydon@redhat.com>
- *	Carl Worth <cworth@cworth.org>
- */
-
-#ifndef CAIRO_CACHE_PRIVATE_H
-#define CAIRO_CACHE_PRIVATE_H
-
-#include "cairo-compiler-private.h"
-#include "cairo-types-private.h"
-
-/**
- * cairo_cache_entry_t:
- *
- * A #cairo_cache_entry_t contains both a key and a value for
- * #cairo_cache_t. User-derived types for #cairo_cache_entry_t must
- * have a #cairo_cache_entry_t as their first field. For example:
- *
- * 	typedef _my_entry {
- *	    cairo_cache_entry_t base;
- *	    ... Remainder of key and value fields here ..
- *	} my_entry_t;
- *
- * which then allows a pointer to my_entry_t to be passed to any of
- * the #cairo_cache_t functions as follows without requiring a cast:
- *
- *	_cairo_cache_insert (cache, &my_entry->base, size);
- *
- * IMPORTANT: The caller is responsible for initializing
- * my_entry->base.hash with a hash code derived from the key.  The
- * essential property of the hash code is that keys_equal must never
- * return %TRUE for two keys that have different hashes. The best hash
- * code will reduce the frequency of two keys with the same code for
- * which keys_equal returns %FALSE.
- *
- * The user must also initialize my_entry->base.size to indicate
- * the size of the current entry. What units to use for size is
- * entirely up to the caller, (though the same units must be used for
- * the max_size parameter passed to _cairo_cache_create()). If all
- * entries are close to the same size, the simplest thing to do is to
- * just use units of "entries", (eg. set size==1 in all entries and
- * set max_size to the number of entries which you want to be saved
- * in the cache).
- *
- * Which parts of the entry make up the "key" and which part make up
- * the value are entirely up to the caller, (as determined by the
- * computation going into base.hash as well as the keys_equal
- * function). A few of the #cairo_cache_t functions accept an entry which
- * will be used exclusively as a "key", (indicated by a parameter name
- * of key). In these cases, the value-related fields of the entry need
- * not be initialized if so desired.
- **/
-typedef struct _cairo_cache_entry {
-    unsigned long hash;
-    unsigned long size;
-} cairo_cache_entry_t;
-
-typedef cairo_bool_t (*cairo_cache_predicate_func_t) (const void *entry);
-
-struct _cairo_cache {
-    cairo_hash_table_t *hash_table;
-
-    cairo_cache_predicate_func_t predicate;
-    cairo_destroy_func_t entry_destroy;
-
-    unsigned long max_size;
-    unsigned long size;
-
-    int freeze_count;
-};
-
-typedef cairo_bool_t
-(*cairo_cache_keys_equal_func_t) (const void *key_a, const void *key_b);
-
-typedef void
-(*cairo_cache_callback_func_t) (void *entry,
-				void *closure);
-
-cairo_private cairo_status_t
-_cairo_cache_init (cairo_cache_t *cache,
-	           cairo_cache_keys_equal_func_t keys_equal,
-		   cairo_cache_predicate_func_t  predicate,
-		   cairo_destroy_func_t	   entry_destroy,
-		   unsigned long		   max_size);
-
-cairo_private void
-_cairo_cache_fini (cairo_cache_t *cache);
-
-cairo_private void
-_cairo_cache_freeze (cairo_cache_t *cache);
-
-cairo_private void
-_cairo_cache_thaw (cairo_cache_t *cache);
-
-cairo_private void *
-_cairo_cache_lookup (cairo_cache_t	  *cache,
-		     cairo_cache_entry_t  *key);
-
-cairo_private cairo_status_t
-_cairo_cache_insert (cairo_cache_t	 *cache,
-		     cairo_cache_entry_t *entry);
-
-cairo_private void
-_cairo_cache_remove (cairo_cache_t	 *cache,
-		     cairo_cache_entry_t *entry);
-
-cairo_private void
-_cairo_cache_foreach (cairo_cache_t		 *cache,
-		      cairo_cache_callback_func_t cache_callback,
-		      void			 *closure);
-
-#endif
diff --git a/src/cairo/cairo-clip-private.h b/src/cairo/cairo-clip-private.h
deleted file mode 100644
index 6128243..0000000
--- a/src/cairo/cairo-clip-private.h
+++ /dev/null
@@ -1,137 +0,0 @@
-/* cairo - a vector graphics library with display and print output
- *
- * Copyright © 2005 Red Hat, Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it either under the terms of the GNU Lesser General Public
- * License version 2.1 as published by the Free Software Foundation
- * (the "LGPL") or, at your option, under the terms of the Mozilla
- * Public License Version 1.1 (the "MPL"). If you do not alter this
- * notice, a recipient may use your version of this file under either
- * the MPL or the LGPL.
- *
- * You should have received a copy of the LGPL along with this library
- * in the file COPYING-LGPL-2.1; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- * You should have received a copy of the MPL along with this library
- * in the file COPYING-MPL-1.1
- *
- * The contents of this file are subject to the Mozilla Public License
- * Version 1.1 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
- * OF ANY KIND, either express or implied. See the LGPL or the MPL for
- * the specific language governing rights and limitations.
- *
- * The Original Code is the cairo graphics library.
- *
- * The Initial Developer of the Original Code is Red Hat, Inc.
- *
- * Contributor(s):
- *	Kristian Høgsberg <krh@redhat.com>
- */
-
-#ifndef CAIRO_CLIP_PRIVATE_H
-#define CAIRO_CLIP_PRIVATE_H
-
-#include "cairo-types-private.h"
-#include "cairo-compiler-private.h"
-#include "cairo-path-fixed-private.h"
-#include "cairo-reference-count-private.h"
-
-extern const cairo_private cairo_rectangle_list_t _cairo_rectangles_nil;
-
-enum {
-    CAIRO_CLIP_PATH_HAS_REGION = 0x1,
-    CAIRO_CLIP_PATH_REGION_IS_UNSUPPORTED = 0x2,
-    CAIRO_CLIP_PATH_IS_BOX = 0x4
-};
-
-struct _cairo_clip_path {
-    cairo_reference_count_t	 ref_count;
-    cairo_path_fixed_t		 path;
-    cairo_fill_rule_t		 fill_rule;
-    double			 tolerance;
-    cairo_antialias_t		 antialias;
-    cairo_clip_path_t		*prev;
-
-    cairo_rectangle_int_t extents;
-
-    /* partial caches */
-    unsigned int flags;
-    cairo_region_t *region;
-    cairo_surface_t *surface;
-};
-
-struct _cairo_clip {
-    /* can be used as a cairo_hash_entry_t for live clips */
-    cairo_clip_path_t *path;
-
-    cairo_bool_t all_clipped;
-
-};
-
-cairo_private void
-_cairo_clip_init (cairo_clip_t *clip);
-
-cairo_private cairo_status_t
-_cairo_clip_init_rectangle (cairo_clip_t *clip,
-			    const cairo_rectangle_int_t *rect);
-
-cairo_private_no_warn cairo_clip_t *
-_cairo_clip_init_copy (cairo_clip_t *clip, cairo_clip_t *other);
-
-cairo_private cairo_status_t
-_cairo_clip_init_copy_transformed (cairo_clip_t    *clip,
-				   cairo_clip_t    *other,
-				   const cairo_matrix_t *matrix);
-
-cairo_private void
-_cairo_clip_reset (cairo_clip_t *clip);
-
-#define _cairo_clip_fini(clip) _cairo_clip_reset (clip)
-
-cairo_private cairo_status_t
-_cairo_clip_rectangle (cairo_clip_t       *clip,
-		       const cairo_rectangle_int_t *rectangle);
-
-cairo_private cairo_status_t
-_cairo_clip_clip (cairo_clip_t       *clip,
-		  const cairo_path_fixed_t *path,
-		  cairo_fill_rule_t   fill_rule,
-		  double              tolerance,
-		  cairo_antialias_t   antialias);
-
-cairo_private cairo_status_t
-_cairo_clip_apply_clip (cairo_clip_t *clip,
-			const cairo_clip_t *other);
-
-cairo_private const cairo_rectangle_int_t *
-_cairo_clip_get_extents (const cairo_clip_t *clip);
-
-cairo_private cairo_surface_t *
-_cairo_clip_get_surface (cairo_clip_t *clip, cairo_surface_t *dst);
-
-cairo_private cairo_status_t
-_cairo_clip_combine_with_surface (cairo_clip_t *clip,
-				  cairo_surface_t *dst,
-				  const cairo_rectangle_int_t *extents);
-
-cairo_private cairo_int_status_t
-_cairo_clip_get_region (cairo_clip_t *clip,
-			cairo_region_t **region);
-
-cairo_private cairo_int_status_t
-_cairo_clip_get_boxes (cairo_clip_t *clip,
-		       cairo_box_t **boxes,
-		       int *count);
-
-cairo_private void
-_cairo_clip_drop_cache (cairo_clip_t  *clip);
-
-cairo_private cairo_rectangle_list_t*
-_cairo_clip_copy_rectangle_list (cairo_clip_t *clip, cairo_gstate_t *gstate);
-
-#endif /* CAIRO_CLIP_PRIVATE_H */
diff --git a/src/cairo/cairo-compiler-private.h b/src/cairo/cairo-compiler-private.h
index 403c3f7..9fe8e9b 100644
--- a/src/cairo/cairo-compiler-private.h
+++ b/src/cairo/cairo-compiler-private.h
@@ -38,8 +38,6 @@
 #ifndef CAIRO_COMPILER_PRIVATE_H
 #define CAIRO_COMPILER_PRIVATE_H
 
-#include "cairo.h"
-
 #if HAVE_CONFIG_H
 #include "config.h"
 #endif
diff --git a/src/cairo/cairo-freelist.c b/src/cairo/cairo-freelist.c
index 08514cd..6ea5c17 100644
--- a/src/cairo/cairo-freelist.c
+++ b/src/cairo/cairo-freelist.c
@@ -20,7 +20,8 @@
  * OF THIS SOFTWARE.
  */
 
-#include "cairoint.h"
+#include <stdlib.h>
+#include <string.h>
 
 #include "cairo-freelist-private.h"
 
diff --git a/src/cairo/cairo-hash-private.h b/src/cairo/cairo-hash-private.h
deleted file mode 100644
index 32078bd..0000000
--- a/src/cairo/cairo-hash-private.h
+++ /dev/null
@@ -1,87 +0,0 @@
-/* cairo - a vector graphics library with display and print output
- *
- * Copyright © 2004 Red Hat, Inc.
- * Copyright © 2005 Red Hat, Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it either under the terms of the GNU Lesser General Public
- * License version 2.1 as published by the Free Software Foundation
- * (the "LGPL") or, at your option, under the terms of the Mozilla
- * Public License Version 1.1 (the "MPL"). If you do not alter this
- * notice, a recipient may use your version of this file under either
- * the MPL or the LGPL.
- *
- * You should have received a copy of the LGPL along with this library
- * in the file COPYING-LGPL-2.1; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- * You should have received a copy of the MPL along with this library
- * in the file COPYING-MPL-1.1
- *
- * The contents of this file are subject to the Mozilla Public License
- * Version 1.1 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
- * OF ANY KIND, either express or implied. See the LGPL or the MPL for
- * the specific language governing rights and limitations.
- *
- * The Original Code is the cairo graphics library.
- *
- * The Initial Developer of the Original Code is Red Hat, Inc.
- *
- * Contributor(s):
- *      Keith Packard <keithp@keithp.com>
- *	Graydon Hoare <graydon@redhat.com>
- *	Carl Worth <cworth@cworth.org>
- */
-
-#ifndef CAIRO_HASH_PRIVATE_H
-#define CAIRO_HASH_PRIVATE_H
-
-#include "cairo-compiler-private.h"
-#include "cairo-types-private.h"
-
-/* XXX: I'd like this file to be self-contained in terms of
- * includeability, but that's not really possible with the current
- * monolithic cairoint.h. So, for now, just include cairoint.h instead
- * if you want to include this file. */
-
-typedef cairo_bool_t
-(*cairo_hash_keys_equal_func_t) (const void *key_a, const void *key_b);
-
-typedef cairo_bool_t
-(*cairo_hash_predicate_func_t) (const void *entry);
-
-typedef void
-(*cairo_hash_callback_func_t) (void *entry,
-			       void *closure);
-
-cairo_private cairo_hash_table_t *
-_cairo_hash_table_create (cairo_hash_keys_equal_func_t keys_equal);
-
-cairo_private void
-_cairo_hash_table_destroy (cairo_hash_table_t *hash_table);
-
-cairo_private void *
-_cairo_hash_table_lookup (cairo_hash_table_t  *hash_table,
-			  cairo_hash_entry_t  *key);
-
-cairo_private void *
-_cairo_hash_table_random_entry (cairo_hash_table_t	   *hash_table,
-				cairo_hash_predicate_func_t predicate);
-
-cairo_private cairo_status_t
-_cairo_hash_table_insert (cairo_hash_table_t *hash_table,
-			  cairo_hash_entry_t *entry);
-
-cairo_private void
-_cairo_hash_table_remove (cairo_hash_table_t *hash_table,
-			  cairo_hash_entry_t *key);
-
-cairo_private void
-_cairo_hash_table_foreach (cairo_hash_table_t	      *hash_table,
-			   cairo_hash_callback_func_t  hash_callback,
-			   void			      *closure);
-
-#endif
diff --git a/src/cairo/cairo-mutex-impl-private.h b/src/cairo/cairo-mutex-impl-private.h
deleted file mode 100644
index 06938b5..0000000
--- a/src/cairo/cairo-mutex-impl-private.h
+++ /dev/null
@@ -1,250 +0,0 @@
-/* cairo - a vector graphics library with display and print output
- *
- * Copyright © 2002 University of Southern California
- * Copyright © 2005,2007 Red Hat, Inc.
- * Copyright © 2007 Mathias Hasselmann
- *
- * This library is free software; you can redistribute it and/or
- * modify it either under the terms of the GNU Lesser General Public
- * License version 2.1 as published by the Free Software Foundation
- * (the "LGPL") or, at your option, under the terms of the Mozilla
- * Public License Version 1.1 (the "MPL"). If you do not alter this
- * notice, a recipient may use your version of this file under either
- * the MPL or the LGPL.
- *
- * You should have received a copy of the LGPL along with this library
- * in the file COPYING-LGPL-2.1; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- * You should have received a copy of the MPL along with this library
- * in the file COPYING-MPL-1.1
- *
- * The contents of this file are subject to the Mozilla Public License
- * Version 1.1 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
- * OF ANY KIND, either express or implied. See the LGPL or the MPL for
- * the specific language governing rights and limitations.
- *
- * The Original Code is the cairo graphics library.
- *
- * The Initial Developer of the Original Code is University of Southern
- * California.
- *
- * Contributor(s):
- *	Carl D. Worth <cworth@cworth.org>
- *	Mathias Hasselmann <mathias.hasselmann@gmx.de>
- *	Behdad Esfahbod <behdad@behdad.org>
- */
-
-#ifndef CAIRO_MUTEX_IMPL_PRIVATE_H
-#define CAIRO_MUTEX_IMPL_PRIVATE_H
-
-#include "cairo.h"
-
-#if HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#if HAVE_LOCKDEP
-#include <lockdep.h>
-#endif
-
-/* A fully qualified no-operation statement */
-#define CAIRO_MUTEX_IMPL_NOOP	do {/*no-op*/} while (0)
-/* And one that evaluates its argument once */
-#define CAIRO_MUTEX_IMPL_NOOP1(expr)        do { (void)(expr); } while (0)
-/* Note: 'if (expr) {}' is an alternative to '(void)(expr);' that will 'use' the
- * result of __attribute__((warn_used_result)) functions. */
-
-/* Cairo mutex implementation:
- *
- * Any new mutex implementation needs to do the following:
- *
- * - Condition on the right header or feature.  Headers are
- *   preferred as eg. you still can use win32 mutex implementation
- *   on a win32 system even if you do not compile the win32
- *   surface/backend.
- *
- * - typedef #cairo_mutex_impl_t to the proper mutex type on your target
- *   system.  Note that you may or may not need to use a pointer,
- *   depending on what kinds of initialization your mutex
- *   implementation supports.  No trailing semicolon needed.
- *   You should be able to compile the following snippet (don't try
- *   running it):
- *
- *   <programlisting>
- *	cairo_mutex_impl_t _cairo_some_mutex;
- *   </programlisting>
- *
- * - #define %CAIRO_MUTEX_IMPL_<NAME> 1 with suitable name for your platform.  You
- *   can later use this symbol in cairo-system.c.
- *
- * - #define CAIRO_MUTEX_IMPL_LOCK(mutex) and CAIRO_MUTEX_IMPL_UNLOCK(mutex) to
- *   proper statement to lock/unlock the mutex object passed in.
- *   You can (and should) assume that the mutex is already
- *   initialized, and is-not-already-locked/is-locked,
- *   respectively.  Use the "do { ... } while (0)" idiom if necessary.
- *   No trailing semicolons are needed (in any macro you define here).
- *   You should be able to compile the following snippet:
- *
- *   <programlisting>
- *	cairo_mutex_impl_t _cairo_some_mutex;
- *
- *      if (1)
- *          CAIRO_MUTEX_IMPL_LOCK (_cairo_some_mutex);
- *      else
- *          CAIRO_MUTEX_IMPL_UNLOCK (_cairo_some_mutex);
- *   </programlisting>
- *
- * - #define %CAIRO_MUTEX_IMPL_NIL_INITIALIZER to something that can
- *   initialize the #cairo_mutex_impl_t type you defined.  Most of the
- *   time one of 0, %NULL, or {} works.  At this point
- *   you should be able to compile the following snippet:
- *
- *   <programlisting>
- *	cairo_mutex_impl_t _cairo_some_mutex = CAIRO_MUTEX_IMPL_NIL_INITIALIZER;
- *
- *      if (1)
- *          CAIRO_MUTEX_IMPL_LOCK (_cairo_some_mutex);
- *      else
- *          CAIRO_MUTEX_IMPL_UNLOCK (_cairo_some_mutex);
- *   </programlisting>
- *
- * - If the above code is not enough to initialize a mutex on
- *   your platform, #define CAIRO_MUTEX_IMPL_INIT(mutex) to statement
- *   to initialize the mutex (allocate resources, etc).  Such that
- *   you should be able to compile AND RUN the following snippet:
- *
- *   <programlisting>
- *	cairo_mutex_impl_t _cairo_some_mutex = CAIRO_MUTEX_IMPL_NIL_INITIALIZER;
- *
- *      CAIRO_MUTEX_IMPL_INIT (_cairo_some_mutex);
- *
- *      if (1)
- *          CAIRO_MUTEX_IMPL_LOCK (_cairo_some_mutex);
- *      else
- *          CAIRO_MUTEX_IMPL_UNLOCK (_cairo_some_mutex);
- *   </programlisting>
- *
- * - If you define CAIRO_MUTEX_IMPL_INIT(mutex), cairo will use it to
- *   initialize all static mutex'es.  If for any reason that should
- *   not happen (eg. %CAIRO_MUTEX_IMPL_INIT is just a faster way than
- *   what cairo does using %CAIRO_MUTEX_IMPL_NIL_INITIALIZER), then
- *   <programlisting>
- *      #define CAIRO_MUTEX_IMPL_INITIALIZE() CAIRO_MUTEX_IMPL_NOOP
- *   </programlisting>
- *
- * - If your system supports freeing a mutex object (deallocating
- *   resources, etc), then #define CAIRO_MUTEX_IMPL_FINI(mutex) to do
- *   that.
- *
- * - If you define CAIRO_MUTEX_IMPL_FINI(mutex), cairo will use it to
- *   define a finalizer function to finalize all static mutex'es.
- *   However, it's up to you to call CAIRO_MUTEX_IMPL_FINALIZE() at
- *   proper places, eg. when the system is unloading the cairo library.
- *   So, if for any reason finalizing static mutex'es is not needed
- *   (eg. you never call CAIRO_MUTEX_IMPL_FINALIZE()), then
- *   <programlisting>
- *      #define CAIRO_MUTEX_IMPL_FINALIZE() CAIRO_MUTEX_IMPL_NOOP
- *   </programlisting>
- *
- * - That is all.  If for any reason you think the above API is
- *   not enough to implement #cairo_mutex_impl_t on your system, please
- *   stop and write to the cairo mailing list about it.  DO NOT
- *   poke around cairo-mutex-private.h for possible solutions.
- */
-
-#if CAIRO_NO_MUTEX
-
-/* No mutexes */
-
-  typedef int cairo_mutex_impl_t;
-
-# define CAIRO_MUTEX_IMPL_NO 1
-# define CAIRO_MUTEX_IMPL_INITIALIZE() CAIRO_MUTEX_IMPL_NOOP
-# define CAIRO_MUTEX_IMPL_LOCK(mutex) CAIRO_MUTEX_IMPL_NOOP1(mutex)
-# define CAIRO_MUTEX_IMPL_UNLOCK(mutex) CAIRO_MUTEX_IMPL_NOOP1(mutex)
-# define CAIRO_MUTEX_IMPL_NIL_INITIALIZER 0
-
-#elif defined(_WIN32) /******************************************************/
-
-#define WIN32_LEAN_AND_MEAN
-/* We require Windows 2000 features such as ETO_PDY */
-#if !defined(WINVER) || (WINVER < 0x0500)
-# define WINVER 0x0500
-#endif
-#if !defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500)
-# define _WIN32_WINNT 0x0500
-#endif
-
-# include <windows.h>
-
-  typedef CRITICAL_SECTION cairo_mutex_impl_t;
-
-# define CAIRO_MUTEX_IMPL_WIN32 1
-# define CAIRO_MUTEX_IMPL_LOCK(mutex) EnterCriticalSection (&(mutex))
-# define CAIRO_MUTEX_IMPL_UNLOCK(mutex) LeaveCriticalSection (&(mutex))
-# define CAIRO_MUTEX_IMPL_INIT(mutex) InitializeCriticalSection (&(mutex))
-# define CAIRO_MUTEX_IMPL_FINI(mutex) DeleteCriticalSection (&(mutex))
-# define CAIRO_MUTEX_IMPL_NIL_INITIALIZER { NULL, 0, 0, NULL, NULL, 0 }
-
-#elif defined __OS2__ /******************************************************/
-
-# define INCL_BASE
-# define INCL_PM
-# include <os2.h>
-
-  typedef HMTX cairo_mutex_impl_t;
-
-# define CAIRO_MUTEX_IMPL_OS2 1
-# define CAIRO_MUTEX_IMPL_LOCK(mutex) DosRequestMutexSem(mutex, SEM_INDEFINITE_WAIT)
-# define CAIRO_MUTEX_IMPL_UNLOCK(mutex) DosReleaseMutexSem(mutex)
-# define CAIRO_MUTEX_IMPL_INIT(mutex) DosCreateMutexSem (NULL, &(mutex), 0L, FALSE)
-# define CAIRO_MUTEX_IMPL_FINI(mutex) DosCloseMutexSem (mutex)
-# define CAIRO_MUTEX_IMPL_NIL_INITIALIZER 0
-
-#elif CAIRO_HAS_BEOS_SURFACE /***********************************************/
-
-  typedef BLocker* cairo_mutex_impl_t;
-
-# define CAIRO_MUTEX_IMPL_BEOS 1
-# define CAIRO_MUTEX_IMPL_LOCK(mutex) (mutex)->Lock()
-# define CAIRO_MUTEX_IMPL_UNLOCK(mutex) (mutex)->Unlock()
-# define CAIRO_MUTEX_IMPL_INIT(mutex) (mutex) = new BLocker()
-# define CAIRO_MUTEX_IMPL_FINI(mutex) delete (mutex)
-# define CAIRO_MUTEX_IMPL_NIL_INITIALIZER NULL
-
-#elif CAIRO_HAS_PTHREAD /* and finally if there are no native mutexes ********/
-
-# include <pthread.h>
-
-  typedef pthread_mutex_t cairo_mutex_impl_t;
-
-# define CAIRO_MUTEX_IMPL_PTHREAD 1
-#if HAVE_LOCKDEP
-/* expose all mutexes to the validator */
-# define CAIRO_MUTEX_IMPL_INIT(mutex) pthread_mutex_init (&(mutex), NULL)
-#endif
-# define CAIRO_MUTEX_IMPL_LOCK(mutex) pthread_mutex_lock (&(mutex))
-# define CAIRO_MUTEX_IMPL_UNLOCK(mutex) pthread_mutex_unlock (&(mutex))
-#if HAVE_LOCKDEP
-# define CAIRO_MUTEX_IS_LOCKED(mutex) LOCKDEP_IS_LOCKED (&(mutex))
-# define CAIRO_MUTEX_IS_UNLOCKED(mutex) LOCKDEP_IS_UNLOCKED (&(mutex))
-#endif
-# define CAIRO_MUTEX_IMPL_FINI(mutex) pthread_mutex_destroy (&(mutex))
-#if ! HAVE_LOCKDEP
-# define CAIRO_MUTEX_IMPL_FINALIZE() CAIRO_MUTEX_IMPL_NOOP
-#endif
-# define CAIRO_MUTEX_IMPL_NIL_INITIALIZER PTHREAD_MUTEX_INITIALIZER
-
-
-#else /**********************************************************************/
-
-# error "XXX: No mutex implementation found.  Cairo will not work with multiple threads.  Define CAIRO_NO_MUTEX to 1 to acknowledge and accept this limitation and compile cairo without thread-safety support."
-
-
-#endif
-
-#endif
diff --git a/src/cairo/cairo-mutex-list-private.h b/src/cairo/cairo-mutex-list-private.h
deleted file mode 100644
index 2f48316..0000000
--- a/src/cairo/cairo-mutex-list-private.h
+++ /dev/null
@@ -1,67 +0,0 @@
-/* cairo - a vector graphics library with display and print output
- *
- * Copyright © 2007 Mathias Hasselmann
- *
- * This library is free software; you can redistribute it and/or
- * modify it either under the terms of the GNU Lesser General Public
- * License version 2.1 as published by the Free Software Foundation
- * (the "LGPL") or, at your option, under the terms of the Mozilla
- * Public License Version 1.1 (the "MPL"). If you do not alter this
- * notice, a recipient may use your version of this file under either
- * the MPL or the LGPL.
- *
- * You should have received a copy of the LGPL along with this library
- * in the file COPYING-LGPL-2.1; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- * You should have received a copy of the MPL along with this library
- * in the file COPYING-MPL-1.1
- *
- * The contents of this file are subject to the Mozilla Public License
- * Version 1.1 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
- * OF ANY KIND, either express or implied. See the LGPL or the MPL for
- * the specific language governing rights and limitations.
- *
- * The Original Code is the cairo graphics library.
- *
- * Contributor(s):
- *	Mathias Hasselmann <mathias.hasselmann@gmx.de>
- */
-
-#ifndef CAIRO_FEATURES_H
-/* This block is to just make this header file standalone */
-#define CAIRO_MUTEX_DECLARE(mutex)
-#endif
-
-CAIRO_MUTEX_DECLARE (_cairo_pattern_solid_surface_cache_lock)
-
-CAIRO_MUTEX_DECLARE (_cairo_toy_font_face_mutex)
-CAIRO_MUTEX_DECLARE (_cairo_intern_string_mutex)
-CAIRO_MUTEX_DECLARE (_cairo_scaled_font_map_mutex)
-CAIRO_MUTEX_DECLARE (_cairo_scaled_glyph_page_cache_mutex)
-CAIRO_MUTEX_DECLARE (_cairo_scaled_font_error_mutex)
-
-#if CAIRO_HAS_FT_FONT
-CAIRO_MUTEX_DECLARE (_cairo_ft_unscaled_font_map_mutex)
-#endif
-
-#if CAIRO_HAS_XLIB_SURFACE
-CAIRO_MUTEX_DECLARE (_cairo_xlib_display_mutex)
-#endif
-
-#if CAIRO_HAS_GL_SURFACE
-CAIRO_MUTEX_DECLARE (_cairo_gl_context_mutex)
-#endif
-
-#if !defined (HAS_ATOMIC_OPS) || defined (ATOMIC_OP_NEEDS_MEMORY_BARRIER)
-CAIRO_MUTEX_DECLARE (_cairo_atomic_mutex)
-#endif
-
-#if CAIRO_HAS_DRM_SURFACE
-CAIRO_MUTEX_DECLARE (_cairo_drm_device_mutex)
-#endif
-/* Undefine, to err on unintended inclusion */
-#undef   CAIRO_MUTEX_DECLARE
diff --git a/src/cairo/cairo-mutex-private.h b/src/cairo/cairo-mutex-private.h
deleted file mode 100644
index a3a7271..0000000
--- a/src/cairo/cairo-mutex-private.h
+++ /dev/null
@@ -1,67 +0,0 @@
-/* cairo - a vector graphics library with display and print output
- *
- * Copyright © 2002 University of Southern California
- * Copyright © 2005,2007 Red Hat, Inc.
- * Copyright © 2007 Mathias Hasselmann
- *
- * This library is free software; you can redistribute it and/or
- * modify it either under the terms of the GNU Lesser General Public
- * License version 2.1 as published by the Free Software Foundation
- * (the "LGPL") or, at your option, under the terms of the Mozilla
- * Public License Version 1.1 (the "MPL"). If you do not alter this
- * notice, a recipient may use your version of this file under either
- * the MPL or the LGPL.
- *
- * You should have received a copy of the LGPL along with this library
- * in the file COPYING-LGPL-2.1; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- * You should have received a copy of the MPL along with this library
- * in the file COPYING-MPL-1.1
- *
- * The contents of this file are subject to the Mozilla Public License
- * Version 1.1 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
- * OF ANY KIND, either express or implied. See the LGPL or the MPL for
- * the specific language governing rights and limitations.
- *
- * The Original Code is the cairo graphics library.
- *
- * The Initial Developer of the Original Code is University of Southern
- * California.
- *
- * Contributor(s):
- *	Carl D. Worth <cworth@cworth.org>
- *	Mathias Hasselmann <mathias.hasselmann@gmx.de>
- *	Behdad Esfahbod <behdad@behdad.org>
- */
-
-#ifndef CAIRO_MUTEX_PRIVATE_H
-#define CAIRO_MUTEX_PRIVATE_H
-
-#include "cairo-mutex-type-private.h"
-
-CAIRO_BEGIN_DECLS
-
-#if _CAIRO_MUTEX_IMPL_USE_STATIC_INITIALIZER
-cairo_private void _cairo_mutex_initialize (void);
-#endif
-#if _CAIRO_MUTEX_IMPL_USE_STATIC_FINALIZER
-cairo_private void _cairo_mutex_finalize (void);
-#endif
-/* only if using static initializer and/or finalizer define the boolean */
-#if _CAIRO_MUTEX_IMPL_USE_STATIC_INITIALIZER || _CAIRO_MUTEX_IMPL_USE_STATIC_FINALIZER
-  cairo_private extern cairo_bool_t _cairo_mutex_initialized;
-#endif
-
-/* Finally, extern the static mutexes and undef */
-
-#define CAIRO_MUTEX_DECLARE(mutex) cairo_private extern cairo_mutex_t mutex;
-#include "cairo-mutex-list-private.h"
-#undef CAIRO_MUTEX_DECLARE
-
-CAIRO_END_DECLS
-
-#endif
diff --git a/src/cairo/cairo-mutex-type-private.h b/src/cairo/cairo-mutex-type-private.h
deleted file mode 100644
index 342e4f3..0000000
--- a/src/cairo/cairo-mutex-type-private.h
+++ /dev/null
@@ -1,189 +0,0 @@
-/* cairo - a vector graphics library with display and print output
- *
- * Copyright © 2002 University of Southern California
- * Copyright © 2005,2007 Red Hat, Inc.
- * Copyright © 2007 Mathias Hasselmann
- *
- * This library is free software; you can redistribute it and/or
- * modify it either under the terms of the GNU Lesser General Public
- * License version 2.1 as published by the Free Software Foundation
- * (the "LGPL") or, at your option, under the terms of the Mozilla
- * Public License Version 1.1 (the "MPL"). If you do not alter this
- * notice, a recipient may use your version of this file under either
- * the MPL or the LGPL.
- *
- * You should have received a copy of the LGPL along with this library
- * in the file COPYING-LGPL-2.1; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- * You should have received a copy of the MPL along with this library
- * in the file COPYING-MPL-1.1
- *
- * The contents of this file are subject to the Mozilla Public License
- * Version 1.1 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
- * OF ANY KIND, either express or implied. See the LGPL or the MPL for
- * the specific language governing rights and limitations.
- *
- * The Original Code is the cairo graphics library.
- *
- * The Initial Developer of the Original Code is University of Southern
- * California.
- *
- * Contributor(s):
- *	Carl D. Worth <cworth@cworth.org>
- *	Mathias Hasselmann <mathias.hasselmann@gmx.de>
- *	Behdad Esfahbod <behdad@behdad.org>
- */
-
-#ifndef CAIRO_MUTEX_TYPE_PRIVATE_H
-#define CAIRO_MUTEX_TYPE_PRIVATE_H
-
-#define CAIRO_NO_MUTEX 1
-
-#include "cairo-compiler-private.h"
-#include "cairo-mutex-impl-private.h"
-
-/* Only the following three are mandatory at this point */
-#ifndef CAIRO_MUTEX_IMPL_LOCK
-# error "CAIRO_MUTEX_IMPL_LOCK not defined.  Check cairo-mutex-impl-private.h."
-#endif
-#ifndef CAIRO_MUTEX_IMPL_UNLOCK
-# error "CAIRO_MUTEX_IMPL_UNLOCK not defined.  Check cairo-mutex-impl-private.h."
-#endif
-#ifndef CAIRO_MUTEX_IMPL_NIL_INITIALIZER
-# error "CAIRO_MUTEX_IMPL_NIL_INITIALIZER not defined.  Check cairo-mutex-impl-private.h."
-#endif
-
-
-/* make sure implementations don't fool us: we decide these ourself */
-#undef _CAIRO_MUTEX_IMPL_USE_STATIC_INITIALIZER
-#undef _CAIRO_MUTEX_IMPL_USE_STATIC_FINALIZER
-
-
-#ifdef CAIRO_MUTEX_IMPL_INIT
-
-/* If %CAIRO_MUTEX_IMPL_INIT is defined, we may need to initialize all
- * static mutex'es. */
-# ifndef CAIRO_MUTEX_IMPL_INITIALIZE
-#  define CAIRO_MUTEX_IMPL_INITIALIZE() do {	\
-       if (!_cairo_mutex_initialized)	\
-           _cairo_mutex_initialize ();	\
-    } while(0)
-
-/* and make sure we implement the above */
-#  define _CAIRO_MUTEX_IMPL_USE_STATIC_INITIALIZER 1
-# endif /* CAIRO_MUTEX_IMPL_INITIALIZE */
-
-#else /* no CAIRO_MUTEX_IMPL_INIT */
-
-/* Otherwise we probably don't need to initialize static mutex'es, */
-# ifndef CAIRO_MUTEX_IMPL_INITIALIZE
-#  define CAIRO_MUTEX_IMPL_INITIALIZE() CAIRO_MUTEX_IMPL_NOOP
-# endif /* CAIRO_MUTEX_IMPL_INITIALIZE */
-
-/* and dynamic ones can be initialized using the static initializer. */
-# define CAIRO_MUTEX_IMPL_INIT(mutex) do {				\
-      cairo_mutex_t _tmp_mutex = CAIRO_MUTEX_IMPL_NIL_INITIALIZER;	\
-      memcpy (&(mutex), &_tmp_mutex, sizeof (_tmp_mutex));	\
-  } while (0)
-
-#endif /* CAIRO_MUTEX_IMPL_INIT */
-
-#ifdef CAIRO_MUTEX_IMPL_FINI
-
-/* If %CAIRO_MUTEX_IMPL_FINI is defined, we may need to finalize all
- * static mutex'es. */
-# ifndef CAIRO_MUTEX_IMPL_FINALIZE
-#  define CAIRO_MUTEX_IMPL_FINALIZE() do {	\
-       if (_cairo_mutex_initialized)	\
-           _cairo_mutex_finalize ();	\
-    } while(0)
-
-/* and make sure we implement the above */
-#  define _CAIRO_MUTEX_IMPL_USE_STATIC_FINALIZER 1
-# endif /* CAIRO_MUTEX_IMPL_FINALIZE */
-
-#else /* no CAIRO_MUTEX_IMPL_FINI */
-
-/* Otherwise we probably don't need to finalize static mutex'es, */
-# ifndef CAIRO_MUTEX_IMPL_FINALIZE
-#  define CAIRO_MUTEX_IMPL_FINALIZE() CAIRO_MUTEX_IMPL_NOOP
-# endif /* CAIRO_MUTEX_IMPL_FINALIZE */
-
-/* neither do the dynamic ones. */
-# define CAIRO_MUTEX_IMPL_FINI(mutex)	CAIRO_MUTEX_IMPL_NOOP1(mutex)
-
-#endif /* CAIRO_MUTEX_IMPL_FINI */
-
-
-#ifndef _CAIRO_MUTEX_IMPL_USE_STATIC_INITIALIZER
-#define _CAIRO_MUTEX_IMPL_USE_STATIC_INITIALIZER 0
-#endif
-#ifndef _CAIRO_MUTEX_IMPL_USE_STATIC_FINALIZER
-#define _CAIRO_MUTEX_IMPL_USE_STATIC_FINALIZER 0
-#endif
-
-
-/* Make sure everything we want is defined */
-#ifndef CAIRO_MUTEX_IMPL_INITIALIZE
-# error "CAIRO_MUTEX_IMPL_INITIALIZE not defined"
-#endif
-#ifndef CAIRO_MUTEX_IMPL_FINALIZE
-# error "CAIRO_MUTEX_IMPL_FINALIZE not defined"
-#endif
-#ifndef CAIRO_MUTEX_IMPL_LOCK
-# error "CAIRO_MUTEX_IMPL_LOCK not defined"
-#endif
-#ifndef CAIRO_MUTEX_IMPL_UNLOCK
-# error "CAIRO_MUTEX_IMPL_UNLOCK not defined"
-#endif
-#ifndef CAIRO_MUTEX_IMPL_INIT
-# error "CAIRO_MUTEX_IMPL_INIT not defined"
-#endif
-#ifndef CAIRO_MUTEX_IMPL_FINI
-# error "CAIRO_MUTEX_IMPL_FINI not defined"
-#endif
-#ifndef CAIRO_MUTEX_IMPL_NIL_INITIALIZER
-# error "CAIRO_MUTEX_IMPL_NIL_INITIALIZER not defined"
-#endif
-
-
-/* Public interface. */
-
-/* By default it simply uses the implementation provided.
- * But we can provide for debugging features by overriding them */
-
-#ifndef CAIRO_MUTEX_DEBUG
-typedef cairo_mutex_impl_t cairo_mutex_t;
-#else
-# define cairo_mutex_t			cairo_mutex_impl_t
-#endif
-
-#define CAIRO_MUTEX_INITIALIZE		CAIRO_MUTEX_IMPL_INITIALIZE
-#define CAIRO_MUTEX_FINALIZE		CAIRO_MUTEX_IMPL_FINALIZE
-#define CAIRO_MUTEX_LOCK		CAIRO_MUTEX_IMPL_LOCK
-#define CAIRO_MUTEX_UNLOCK		CAIRO_MUTEX_IMPL_UNLOCK
-#define CAIRO_MUTEX_INIT		CAIRO_MUTEX_IMPL_INIT
-#define CAIRO_MUTEX_FINI		CAIRO_MUTEX_IMPL_FINI
-#define CAIRO_MUTEX_NIL_INITIALIZER	CAIRO_MUTEX_IMPL_NIL_INITIALIZER
-
-#ifndef CAIRO_MUTEX_IS_LOCKED
-# define CAIRO_MUTEX_IS_LOCKED(name) 1
-#endif
-#ifndef CAIRO_MUTEX_IS_UNLOCKED
-# define CAIRO_MUTEX_IS_UNLOCKED(name) 1
-#endif
-
-
-/* Debugging support */
-
-#ifdef CAIRO_MUTEX_DEBUG
-
-/* TODO add mutex debugging facilities here (eg deadlock detection) */
-
-#endif /* CAIRO_MUTEX_DEBUG */
-
-#endif
diff --git a/src/cairo/cairo-path-fixed-private.h b/src/cairo/cairo-path-fixed-private.h
deleted file mode 100644
index 08b7a06..0000000
--- a/src/cairo/cairo-path-fixed-private.h
+++ /dev/null
@@ -1,162 +0,0 @@
-/* cairo - a vector graphics library with display and print output
- *
- * Copyright © 2005 Red Hat, Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it either under the terms of the GNU Lesser General Public
- * License version 2.1 as published by the Free Software Foundation
- * (the "LGPL") or, at your option, under the terms of the Mozilla
- * Public License Version 1.1 (the "MPL"). If you do not alter this
- * notice, a recipient may use your version of this file under either
- * the MPL or the LGPL.
- *
- * You should have received a copy of the LGPL along with this library
- * in the file COPYING-LGPL-2.1; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- * You should have received a copy of the MPL along with this library
- * in the file COPYING-MPL-1.1
- *
- * The contents of this file are subject to the Mozilla Public License
- * Version 1.1 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
- * OF ANY KIND, either express or implied. See the LGPL or the MPL for
- * the specific language governing rights and limitations.
- *
- * The Original Code is the cairo graphics library.
- *
- * The Initial Developer of the Original Code is Red Hat, Inc.
- *
- * Contributor(s):
- *	Carl D. Worth <cworth@redhat.com>
- */
-
-#ifndef CAIRO_PATH_FIXED_PRIVATE_H
-#define CAIRO_PATH_FIXED_PRIVATE_H
-
-#include "cairo-types-private.h"
-#include "cairo-compiler-private.h"
-#include "cairo-list-private.h"
-
-#define WATCH_PATH 0
-#if WATCH_PATH
-#include <stdio.h>
-#endif
-
-enum cairo_path_op {
-    CAIRO_PATH_OP_MOVE_TO = 0,
-    CAIRO_PATH_OP_LINE_TO = 1,
-    CAIRO_PATH_OP_CURVE_TO = 2,
-    CAIRO_PATH_OP_CLOSE_PATH = 3
-};
-
-/* we want to make sure a single byte is used for the enum */
-typedef char cairo_path_op_t;
-
-/* make _cairo_path_fixed fit into ~512 bytes -- about 50 items */
-#define CAIRO_PATH_BUF_SIZE ((512 - sizeof (cairo_path_buf_t)) \
-			   / (2 * sizeof (cairo_point_t) + sizeof (cairo_path_op_t)))
-
-typedef struct _cairo_path_buf {
-    cairo_list_t link;
-    unsigned int buf_size;
-    unsigned int num_ops;
-    unsigned int num_points;
-
-    cairo_path_op_t *op;
-    cairo_point_t *points;
-} cairo_path_buf_t;
-
-typedef struct _cairo_path_buf_fixed {
-    cairo_path_buf_t base;
-
-    cairo_path_op_t op[CAIRO_PATH_BUF_SIZE];
-    cairo_point_t points[2 * CAIRO_PATH_BUF_SIZE];
-} cairo_path_buf_fixed_t;
-
-struct _cairo_path_fixed {
-    cairo_point_t last_move_point;
-    cairo_point_t current_point;
-    unsigned int has_current_point	: 1;
-    unsigned int has_curve_to		: 1;
-    unsigned int is_rectilinear		: 1;
-    unsigned int maybe_fill_region	: 1;
-    unsigned int is_empty_fill		: 1;
-
-    cairo_path_buf_fixed_t  buf;
-};
-
-
-cairo_private void
-_cairo_path_fixed_translate (cairo_path_fixed_t *path,
-			     cairo_fixed_t offx,
-			     cairo_fixed_t offy);
-
-cairo_private cairo_status_t
-_cairo_path_fixed_append (cairo_path_fixed_t		    *path,
-			  const cairo_path_fixed_t	    *other,
-			  cairo_direction_t		     dir,
-			  cairo_fixed_t			     tx,
-			  cairo_fixed_t			     ty);
-
-cairo_private unsigned long
-_cairo_path_fixed_hash (const cairo_path_fixed_t *path);
-
-cairo_private unsigned long
-_cairo_path_fixed_size (const cairo_path_fixed_t *path);
-
-cairo_private cairo_bool_t
-_cairo_path_fixed_equal (const cairo_path_fixed_t *a,
-			 const cairo_path_fixed_t *b);
-
-typedef struct _cairo_path_fixed_iter {
-    const cairo_path_buf_t *first;
-    const cairo_path_buf_t *buf;
-    unsigned int n_op;
-    unsigned int n_point;
-} cairo_path_fixed_iter_t;
-
-cairo_private void
-_cairo_path_fixed_iter_init (cairo_path_fixed_iter_t *iter,
-			     const cairo_path_fixed_t *path);
-
-cairo_private cairo_bool_t
-_cairo_path_fixed_iter_is_fill_box (cairo_path_fixed_iter_t *_iter,
-				    cairo_box_t *box);
-
-cairo_private cairo_bool_t
-_cairo_path_fixed_iter_at_end (const cairo_path_fixed_iter_t *iter);
-
-static inline cairo_bool_t
-_cairo_path_fixed_fill_is_empty (const cairo_path_fixed_t *path)
-{
-    return path->is_empty_fill;
-}
-
-static inline cairo_bool_t
-_cairo_path_fixed_is_rectilinear_fill (const cairo_path_fixed_t *path)
-{
-    if (! path->is_rectilinear)
-	return 0;
-
-    if (! path->has_current_point)
-	return 1;
-
-    /* check whether the implicit close preserves the rectilinear property */
-    return path->current_point.x == path->last_move_point.x ||
-	   path->current_point.y == path->last_move_point.y;
-}
-
-static inline cairo_bool_t
-_cairo_path_fixed_maybe_fill_region (const cairo_path_fixed_t *path)
-{
-#if WATCH_PATH
-    fprintf (stderr, "_cairo_path_fixed_maybe_fill_region () = %s\n",
-	     path->maybe_fill_region ? "true" : "false");
-#endif
-    return path->maybe_fill_region;
-}
-
-#endif /* CAIRO_PATH_FIXED_PRIVATE_H */
diff --git a/src/cairo/cairo-polygon.c b/src/cairo/cairo-polygon.c
deleted file mode 100644
index 9cb76e5..0000000
--- a/src/cairo/cairo-polygon.c
+++ /dev/null
@@ -1,494 +0,0 @@
-/* cairo - a vector graphics library with display and print output
- *
- * Copyright © 2002 University of Southern California
- *
- * This library is free software; you can redistribute it and/or
- * modify it either under the terms of the GNU Lesser General Public
- * License version 2.1 as published by the Free Software Foundation
- * (the "LGPL") or, at your option, under the terms of the Mozilla
- * Public License Version 1.1 (the "MPL"). If you do not alter this
- * notice, a recipient may use your version of this file under either
- * the MPL or the LGPL.
- *
- * You should have received a copy of the LGPL along with this library
- * in the file COPYING-LGPL-2.1; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- * You should have received a copy of the MPL along with this library
- * in the file COPYING-MPL-1.1
- *
- * The contents of this file are subject to the Mozilla Public License
- * Version 1.1 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
- * OF ANY KIND, either express or implied. See the LGPL or the MPL for
- * the specific language governing rights and limitations.
- *
- * The Original Code is the cairo graphics library.
- *
- * The Initial Developer of the Original Code is University of Southern
- * California.
- *
- * Contributor(s):
- *	Carl D. Worth <cworth@cworth.org>
- */
-
-#include "cairoint.h"
-
-#include "cairo-slope-private.h"
-
-void
-_cairo_polygon_init (cairo_polygon_t *polygon)
-{
-    VG (VALGRIND_MAKE_MEM_UNDEFINED (polygon, sizeof (cairo_polygon_t)));
-
-    polygon->status = CAIRO_STATUS_SUCCESS;
-
-    polygon->num_edges = 0;
-
-    polygon->edges = polygon->edges_embedded;
-    polygon->edges_size = ARRAY_LENGTH (polygon->edges_embedded);
-
-    polygon->has_current_point = FALSE;
-    polygon->has_current_edge = FALSE;
-    polygon->num_limits = 0;
-
-    polygon->extents.p1.x = polygon->extents.p1.y = INT32_MAX;
-    polygon->extents.p2.x = polygon->extents.p2.y = INT32_MIN;
-}
-
-void
-_cairo_polygon_limit (cairo_polygon_t	*polygon,
-		      const cairo_box_t *limits,
-		      int num_limits)
-{
-    int n;
-
-    polygon->limits = limits;
-    polygon->num_limits = num_limits;
-
-    if (polygon->num_limits) {
-	polygon->limit = limits[0];
-	for (n = 1; n < num_limits; n++) {
-	    if (limits[n].p1.x < polygon->limit.p1.x)
-		polygon->limit.p1.x = limits[n].p1.x;
-
-	    if (limits[n].p1.y < polygon->limit.p1.y)
-		polygon->limit.p1.y = limits[n].p1.y;
-
-	    if (limits[n].p2.x > polygon->limit.p2.x)
-		polygon->limit.p2.x = limits[n].p2.x;
-
-	    if (limits[n].p2.y > polygon->limit.p2.y)
-		polygon->limit.p2.y = limits[n].p2.y;
-	}
-    }
-}
-
-void
-_cairo_polygon_fini (cairo_polygon_t *polygon)
-{
-    if (polygon->edges != polygon->edges_embedded)
-	free (polygon->edges);
-
-    VG (VALGRIND_MAKE_MEM_NOACCESS (polygon, sizeof (cairo_polygon_t)));
-}
-
-/* make room for at least one more edge */
-static cairo_bool_t
-_cairo_polygon_grow (cairo_polygon_t *polygon)
-{
-    cairo_edge_t *new_edges;
-    int old_size = polygon->edges_size;
-    int new_size = 4 * old_size;
-
-    if (CAIRO_INJECT_FAULT ()) {
-	polygon->status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
-	return FALSE;
-    }
-
-    if (polygon->edges == polygon->edges_embedded) {
-	new_edges = _cairo_malloc_ab (new_size, sizeof (cairo_edge_t));
-	if (new_edges != NULL)
-	    memcpy (new_edges, polygon->edges, old_size * sizeof (cairo_edge_t));
-    } else {
-	new_edges = _cairo_realloc_ab (polygon->edges,
-		                       new_size, sizeof (cairo_edge_t));
-    }
-
-    if (unlikely (new_edges == NULL)) {
-	polygon->status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
-	return FALSE;
-    }
-
-    polygon->edges = new_edges;
-    polygon->edges_size = new_size;
-
-    return TRUE;
-}
-
-static void
-_add_edge (cairo_polygon_t *polygon,
-	   const cairo_point_t *p1,
-	   const cairo_point_t *p2,
-	   int top, int bottom,
-	   int dir)
-{
-    cairo_edge_t *edge;
-
-    assert (top < bottom);
-
-    if (polygon->num_edges == polygon->edges_size) {
-	if (! _cairo_polygon_grow (polygon))
-	    return;
-    }
-
-    edge = &polygon->edges[polygon->num_edges++];
-    edge->line.p1 = *p1;
-    edge->line.p2 = *p2;
-    edge->top = top;
-    edge->bottom = bottom;
-    edge->dir = dir;
-
-    if (top < polygon->extents.p1.y)
-	polygon->extents.p1.y = top;
-    if (bottom > polygon->extents.p2.y)
-	polygon->extents.p2.y = bottom;
-
-    if (p1->x < polygon->extents.p1.x || p1->x > polygon->extents.p2.x) {
-	cairo_fixed_t x = p1->x;
-	if (top != p1->y)
-	    x = _cairo_edge_compute_intersection_x_for_y (p1, p2, top);
-	if (x < polygon->extents.p1.x)
-	    polygon->extents.p1.x = x;
-	if (x > polygon->extents.p2.x)
-	    polygon->extents.p2.x = x;
-    }
-
-    if (p2->x < polygon->extents.p1.x || p2->x > polygon->extents.p2.x) {
-	cairo_fixed_t x = p2->x;
-	if (bottom != p2->y)
-	    x = _cairo_edge_compute_intersection_x_for_y (p1, p2, bottom);
-	if (x < polygon->extents.p1.x)
-	    polygon->extents.p1.x = x;
-	if (x > polygon->extents.p2.x)
-	    polygon->extents.p2.x = x;
-    }
-}
-
-static void
-_add_clipped_edge (cairo_polygon_t *polygon,
-		   const cairo_point_t *p1,
-		   const cairo_point_t *p2,
-		   const int top, const int bottom,
-		   const int dir)
-{
-    cairo_point_t p[2];
-    int top_y, bot_y;
-    int n;
-
-    for (n = 0; n < polygon->num_limits; n++) {
-	const cairo_box_t *limits = &polygon->limits[n];
-
-	if (top >= limits->p2.y)
-	    continue;
-	if (bottom <= limits->p1.y)
-	    continue;
-
-	if (p1->x <= limits->p1.x && p2->x <= limits->p1.x)
-	{
-	    p[0].x = limits->p1.x;
-	    p[0].y = limits->p1.y;
-	    top_y = top;
-	    if (top_y < p[0].y)
-		top_y = p[0].y;
-
-	    p[1].x = limits->p1.x;
-	    p[1].y = limits->p2.y;
-	    bot_y = bottom;
-	    if (bot_y > p[1].y)
-		bot_y = p[1].y;
-
-	    _add_edge (polygon, &p[0], &p[1], top_y, bot_y, dir);
-	}
-	else if (p1->x >= limits->p2.x && p2->x >= limits->p2.x)
-	{
-	    p[0].x = limits->p2.x;
-	    p[0].y = limits->p1.y;
-	    top_y = top;
-	    if (top_y < p[0].y)
-		top_y = p[0].y;
-
-	    p[1].x = limits->p2.x;
-	    p[1].y = limits->p2.y;
-	    bot_y = bottom;
-	    if (bot_y > p[1].y)
-		bot_y = p[1].y;
-
-	    _add_edge (polygon, &p[0], &p[1], top_y, bot_y, dir);
-	}
-	else if (p1->x >= limits->p1.x && p2->x >= limits->p1.x &&
-		 p1->x <= limits->p2.x && p2->x <= limits->p2.x)
-	{
-	    top_y = top;
-	    if (top_y < limits->p1.y)
-		top_y = limits->p1.y;
-
-	    bot_y = bottom;
-	    if (bot_y > limits->p2.y)
-		bot_y = limits->p2.y;
-
-	    _add_edge (polygon, p1, p2, top_y, bot_y, dir);
-	}
-	else
-	{
-	    int left_y, right_y;
-	    int p1_y, p2_y;
-
-	    left_y = _cairo_edge_compute_intersection_y_for_x (p1, p2,
-							       limits->p1.x);
-	    right_y = _cairo_edge_compute_intersection_y_for_x (p1, p2,
-								limits->p2.x);
-
-	    if (left_y == right_y) /* horizontal within bounds */
-		continue;
-
-	    p1_y = top;
-	    p2_y = bottom;
-
-	    if (left_y < right_y) {
-		if (p1->x < limits->p1.x && left_y > limits->p1.y) {
-		    p[0].x = limits->p1.x;
-		    p[0].y = limits->p1.y;
-		    top_y = p1_y;
-		    if (top_y < p[0].y)
-			top_y = p[0].y;
-
-		    p[1].x = limits->p1.x;
-		    p[1].y = limits->p2.y;
-		    bot_y = left_y;
-		    if (bot_y > p[1].y)
-			bot_y = p[1].y;
-
-		    if (bot_y > top_y)
-			_add_edge (polygon, &p[0], &p[1], top_y, bot_y, dir);
-		    p1_y = bot_y;
-		}
-
-		if (p2->x > limits->p2.x && right_y < limits->p2.y) {
-		    p[0].x = limits->p2.x;
-		    p[0].y = limits->p1.y;
-		    top_y = right_y;
-		    if (top_y < p[0].y)
-			top_y = p[0].y;
-
-		    p[1].x = limits->p2.x;
-		    p[1].y = limits->p2.y;
-		    bot_y = p2_y;
-		    if (bot_y > p[1].y)
-			bot_y = p[1].y;
-
-		    if (bot_y > top_y)
-			_add_edge (polygon, &p[0], &p[1], top_y, bot_y, dir);
-		    p2_y = top_y;
-		}
-	    } else {
-		if (p1->x > limits->p2.x && right_y > limits->p1.y) {
-		    p[0].x = limits->p2.x;
-		    p[0].y = limits->p1.y;
-		    top_y = p1_y;
-		    if (top_y < p[0].y)
-			top_y = p[0].y;
-
-		    p[1].x = limits->p2.x;
-		    p[1].y = limits->p2.y;
-		    bot_y = right_y;
-		    if (bot_y > p[1].y)
-			bot_y = p[1].y;
-
-		    if (bot_y > top_y)
-			_add_edge (polygon, &p[0], &p[1], top_y, bot_y, dir);
-		    p1_y = bot_y;
-		}
-
-		if (p2->x < limits->p1.x && left_y < limits->p2.y) {
-		    p[0].x = limits->p1.x;
-		    p[0].y = limits->p1.y;
-		    top_y = left_y;
-		    if (top_y < p[0].y)
-			top_y = p[0].y;
-
-		    p[1].x = limits->p1.x;
-		    p[1].y = limits->p2.y;
-		    bot_y = p2_y;
-		    if (bot_y > p[1].y)
-			bot_y = p[1].y;
-
-		    if (bot_y > top_y)
-			_add_edge (polygon, &p[0], &p[1], top_y, bot_y, dir);
-		    p2_y = top_y;
-		}
-	    }
-
-	    if (p1_y < limits->p1.y)
-		p1_y = limits->p1.y;
-	    if (p2_y > limits->p2.y)
-		p2_y = limits->p2.y;
-	    if (p2_y > p1_y)
-		_add_edge (polygon, p1, p2, p1_y, p2_y, dir);
-	}
-    }
-}
-
-static void
-_cairo_polygon_add_edge (cairo_polygon_t *polygon,
-			 const cairo_point_t *p1,
-			 const cairo_point_t *p2)
-{
-    int dir;
-
-    /* drop horizontal edges */
-    if (p1->y == p2->y)
-	return;
-
-    if (p1->y < p2->y) {
-	dir = 1;
-    } else {
-	const cairo_point_t *t;
-	t = p1, p1 = p2, p2 = t;
-	dir = -1;
-    }
-
-    if (polygon->num_limits) {
-	if (p2->y <= polygon->limit.p1.y)
-	    return;
-
-	if (p1->y >= polygon->limit.p2.y)
-	    return;
-
-	_add_clipped_edge (polygon, p1, p2, p1->y, p2->y, dir);
-    } else
-	_add_edge (polygon, p1, p2, p1->y, p2->y, dir);
-}
-
-cairo_status_t
-_cairo_polygon_add_external_edge (void *polygon,
-				  const cairo_point_t *p1,
-				  const cairo_point_t *p2)
-{
-    _cairo_polygon_add_edge (polygon, p1, p2);
-    return _cairo_polygon_status (polygon);
-}
-
-cairo_status_t
-_cairo_polygon_add_line (cairo_polygon_t *polygon,
-			 const cairo_line_t *line,
-			 int top, int bottom,
-			 int dir)
-{
-    /* drop horizontal edges */
-    if (line->p1.y == line->p2.y)
-	return CAIRO_STATUS_SUCCESS;
-
-    if (bottom <= top)
-	return CAIRO_STATUS_SUCCESS;
-
-    if (polygon->num_limits) {
-	if (line->p2.y <= polygon->limit.p1.y)
-	    return CAIRO_STATUS_SUCCESS;
-
-	if (line->p1.y >= polygon->limit.p2.y)
-	    return CAIRO_STATUS_SUCCESS;
-
-	_add_clipped_edge (polygon, &line->p1, &line->p2, top, bottom, dir);
-    } else
-	_add_edge (polygon, &line->p1, &line->p2, top, bottom, dir);
-
-    return polygon->status;
-}
-
-/* flattened path operations */
-
-cairo_status_t
-_cairo_polygon_move_to (cairo_polygon_t *polygon,
-			const cairo_point_t *point)
-{
-    if (polygon->has_current_edge) {
-	_cairo_polygon_add_edge (polygon,
-				 &polygon->last_point,
-				 &polygon->current_point);
-	polygon->has_current_edge = FALSE;
-    }
-
-    if (! polygon->has_current_point) {
-	polygon->first_point = *point;
-	polygon->has_current_point = TRUE;
-    }
-
-    polygon->current_point = *point;
-    return polygon->status;
-}
-
-cairo_status_t
-_cairo_polygon_line_to (cairo_polygon_t *polygon,
-			const cairo_point_t *point)
-{
-    /* squash collinear edges */
-    if (polygon->has_current_edge) {
-	if (polygon->current_point.x != point->x ||
-	    polygon->current_point.y != point->y)
-	{
-	    cairo_slope_t this;
-
-	    _cairo_slope_init (&this, &polygon->current_point, point);
-	    if (_cairo_slope_equal (&polygon->current_edge, &this)) {
-		polygon->current_point = *point;
-		return CAIRO_STATUS_SUCCESS;
-	    }
-
-	    _cairo_polygon_add_edge (polygon,
-				     &polygon->last_point,
-				     &polygon->current_point);
-
-	    polygon->last_point = polygon->current_point;
-	    polygon->current_edge = this;
-	}
-    } else if (polygon->has_current_point) {
-	if (polygon->current_point.x != point->x ||
-	    polygon->current_point.y != point->y)
-	{
-	    polygon->last_point = polygon->current_point;
-	    _cairo_slope_init (&polygon->current_edge,
-			       &polygon->last_point,
-			       point);
-	    polygon->has_current_edge = TRUE;
-	}
-    } else {
-	polygon->first_point = *point;
-	polygon->has_current_point = TRUE;
-    }
-
-    polygon->current_point = *point;
-    return polygon->status;
-}
-
-cairo_status_t
-_cairo_polygon_close (cairo_polygon_t *polygon)
-{
-    cairo_status_t status;
-
-    if (polygon->has_current_point) {
-	status = _cairo_polygon_line_to (polygon, &polygon->first_point);
-	polygon->has_current_point = FALSE;
-    }
-
-    if (polygon->has_current_edge) {
-	_cairo_polygon_add_edge (polygon,
-				 &polygon->last_point,
-				 &polygon->current_point);
-	polygon->has_current_edge = FALSE;
-    }
-
-    return polygon->status;
-}
diff --git a/src/cairo/cairo-reference-count-private.h b/src/cairo/cairo-reference-count-private.h
deleted file mode 100644
index d6adaad..0000000
--- a/src/cairo/cairo-reference-count-private.h
+++ /dev/null
@@ -1,62 +0,0 @@
-/* cairo - a vector graphics library with display and print output
- *
- * Copyright © 2007 Chris Wilson
- *
- * This library is free software; you can redistribute it and/or
- * modify it either under the terms of the GNU Lesser General Public
- * License version 2.1 as published by the Free Software Foundation
- * (the "LGPL") or, at your option, under the terms of the Mozilla
- * Public License Version 1.1 (the "MPL"). If you do not alter this
- * notice, a recipient may use your version of this file under either
- * the MPL or the LGPL.
- *
- * You should have received a copy of the LGPL along with this library
- * in the file COPYING-LGPL-2.1; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- * You should have received a copy of the MPL along with this library
- * in the file COPYING-MPL-1.1
- *
- * The contents of this file are subject to the Mozilla Public License
- * Version 1.1 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
- * OF ANY KIND, either express or implied. See the LGPL or the MPL for
- * the specific language governing rights and limitations.
- *
- * The Original Code is the cairo graphics library.
- *
- * The Initial Developer of the Original Code is University of Southern
- * California.
- *
- * Contributor(s):
- *	Chris Wilson <chris@chris-wilson.co.uk>
- */
-
-#ifndef CAIRO_REFRENCE_COUNT_PRIVATE_H
-#define CAIRO_REFRENCE_COUNT_PRIVATE_H
-
-#include "cairo-atomic-private.h"
-
-/* Encapsulate operations on the object's reference count */
-typedef struct {
-    cairo_atomic_int_t ref_count;
-} cairo_reference_count_t;
-
-#define _cairo_reference_count_inc(RC) _cairo_atomic_int_inc (&(RC)->ref_count)
-#define _cairo_reference_count_dec_and_test(RC) _cairo_atomic_int_dec_and_test (&(RC)->ref_count)
-
-#define CAIRO_REFERENCE_COUNT_INIT(RC, VALUE) ((RC)->ref_count = (VALUE))
-
-#define CAIRO_REFERENCE_COUNT_GET_VALUE(RC) _cairo_atomic_int_get (&(RC)->ref_count)
-#define CAIRO_REFERENCE_COUNT_SET_VALUE(RC, VALUE) _cairo_atomic_int_set (&(RC)->ref_count, (VALUE))
-
-#define CAIRO_REFERENCE_COUNT_INVALID_VALUE ((cairo_atomic_int_t) -1)
-#define CAIRO_REFERENCE_COUNT_INVALID {CAIRO_REFERENCE_COUNT_INVALID_VALUE}
-
-#define CAIRO_REFERENCE_COUNT_IS_INVALID(RC) (CAIRO_REFERENCE_COUNT_GET_VALUE (RC) == CAIRO_REFERENCE_COUNT_INVALID_VALUE)
-
-#define CAIRO_REFERENCE_COUNT_HAS_REFERENCE(RC) (CAIRO_REFERENCE_COUNT_GET_VALUE (RC) > 0)
-
-#endif
diff --git a/src/cairo/cairo-region-private.h b/src/cairo/cairo-region-private.h
deleted file mode 100644
index 507f72e..0000000
--- a/src/cairo/cairo-region-private.h
+++ /dev/null
@@ -1,68 +0,0 @@
-/* -*- Mode: c; tab-width: 8; c-basic-offset: 4; indent-tabs-mode: t; -*- */
-/* cairo - a vector graphics library with display and print output
- *
- * Copyright © 2005 Red Hat, Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it either under the terms of the GNU Lesser General Public
- * License version 2.1 as published by the Free Software Foundation
- * (the "LGPL") or, at your option, under the terms of the Mozilla
- * Public License Version 1.1 (the "MPL"). If you do not alter this
- * notice, a recipient may use your version of this file under either
- * the MPL or the LGPL.
- *
- * You should have received a copy of the LGPL along with this library
- * in the file COPYING-LGPL-2.1; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- * You should have received a copy of the MPL along with this library
- * in the file COPYING-MPL-1.1
- *
- * The contents of this file are subject to the Mozilla Public License
- * Version 1.1 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
- * OF ANY KIND, either express or implied. See the LGPL or the MPL for
- * the specific language governing rights and limitations.
- *
- * The Original Code is the cairo graphics library.
- *
- * The Initial Developer of the Original Code is Red Hat, Inc.
- *
- * Contributor(s):
- *	Owen Taylor <otaylor@redhat.com>
- *      Vladimir Vukicevic <vladimir@pobox.com>
- *      Søren Sandmann <sandmann@daimi.au.dk>
- */
-
-#ifndef CAIRO_REGION_PRIVATE_H
-#define CAIRO_REGION_PRIVATE_H
-
-#include "cairo-types-private.h"
-#include "cairo-reference-count-private.h"
-
-#include <pixman.h>
-
-CAIRO_BEGIN_DECLS
-
-struct _cairo_region {
-    cairo_reference_count_t ref_count;
-    cairo_status_t status;
-
-    pixman_region32_t rgn;
-};
-
-cairo_private void
-_cairo_region_init (cairo_region_t *region);
-
-cairo_private void
-_cairo_region_init_rectangle (cairo_region_t *region,
-			      const cairo_rectangle_int_t *rectangle);
-
-cairo_private void
-_cairo_region_fini (cairo_region_t *region);
-
-CAIRO_END_DECLS
-
-#endif /* CAIRO_REGION_PRIVATE_H */
diff --git a/src/cairo/cairo-scaled-font-private.h b/src/cairo/cairo-scaled-font-private.h
deleted file mode 100644
index cdc3c73..0000000
--- a/src/cairo/cairo-scaled-font-private.h
+++ /dev/null
@@ -1,129 +0,0 @@
-/* cairo - a vector graphics library with display and print output
- *
- * Copyright © 2002 University of Southern California
- * Copyright © 2005 Red Hat, Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it either under the terms of the GNU Lesser General Public
- * License version 2.1 as published by the Free Software Foundation
- * (the "LGPL") or, at your option, under the terms of the Mozilla
- * Public License Version 1.1 (the "MPL"). If you do not alter this
- * notice, a recipient may use your version of this file under either
- * the MPL or the LGPL.
- *
- * You should have received a copy of the LGPL along with this library
- * in the file COPYING-LGPL-2.1; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- * You should have received a copy of the MPL along with this library
- * in the file COPYING-MPL-1.1
- *
- * The contents of this file are subject to the Mozilla Public License
- * Version 1.1 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
- * OF ANY KIND, either express or implied. See the LGPL or the MPL for
- * the specific language governing rights and limitations.
- *
- * The Original Code is the cairo graphics library.
- *
- * The Initial Developer of the Original Code is University of Southern
- * California.
- *
- * Contributor(s):
- *	Carl D. Worth <cworth@cworth.org>
- */
-
-#ifndef CAIRO_SCALED_FONT_PRIVATE_H
-#define CAIRO_SCALED_FONT_PRIVATE_H
-
-#include "cairo.h"
-
-#include "cairo-types-private.h"
-#include "cairo-mutex-type-private.h"
-#include "cairo-reference-count-private.h"
-
-typedef struct _cairo_scaled_glyph_page cairo_scaled_glyph_page_t;
-
-struct _cairo_scaled_font {
-    /* For most cairo objects, the rule for multiple threads is that
-     * the user is responsible for any locking if the same object is
-     * manipulated from multiple threads simultaneously.
-     *
-     * However, with the caching that cairo does for scaled fonts, a
-     * user can easily end up with the same cairo_scaled_font object
-     * being manipulated from multiple threads without the user ever
-     * being aware of this, (and in fact, unable to control it).
-     *
-     * So, as a special exception, the cairo implementation takes care
-     * of all locking needed for cairo_scaled_font_t. Most of what is
-     * in the scaled font is immutable, (which is what allows for the
-     * sharing in the first place). The things that are modified and
-     * the locks protecting them are as follows:
-     *
-     * 1. The reference count (scaled_font->ref_count)
-     *
-     *    Modifications to the reference count are protected by the
-     *    _cairo_scaled_font_map_mutex. This is because the reference
-     *    count of a scaled font is intimately related with the font
-     *    map itself, (and the magic holdovers array).
-     *
-     * 2. The cache of glyphs (scaled_font->glyphs)
-     * 3. The backend private data (scaled_font->surface_backend,
-     *				    scaled_font->surface_private)
-     *
-     *    Modifications to these fields are protected with locks on
-     *    scaled_font->mutex in the generic scaled_font code.
-     */
-
-    cairo_hash_entry_t hash_entry;
-
-    /* useful bits for _cairo_scaled_font_nil */
-    cairo_status_t status;
-    cairo_reference_count_t ref_count;
-    cairo_user_data_array_t user_data;
-
-    cairo_font_face_t *original_font_face; /* may be NULL */
-
-    /* hash key members */
-    cairo_font_face_t *font_face; /* may be NULL */
-    cairo_matrix_t font_matrix;	  /* font space => user space */
-    cairo_matrix_t ctm;	          /* user space => device space */
-    cairo_font_options_t options;
-
-    unsigned int placeholder : 1; /*  protected by fontmap mutex */
-    unsigned int holdover : 1;
-    unsigned int finished : 1;
-
-    /* "live" scaled_font members */
-    cairo_matrix_t scale;	     /* font space => device space */
-    cairo_matrix_t scale_inverse;    /* device space => font space */
-    double max_scale;		     /* maximum x/y expansion of scale */
-    cairo_font_extents_t extents;    /* user space */
-    cairo_font_extents_t fs_extents; /* font space */
-
-    /* The mutex protects modification to all subsequent fields. */
-    cairo_mutex_t mutex;
-
-    cairo_hash_table_t *glyphs;
-    cairo_scaled_glyph_page_t *glyph_pages;
-    cairo_bool_t cache_frozen;
-    cairo_bool_t global_cache_frozen;
-
-    /*
-     * One surface backend may store data in each glyph.
-     * Whichever surface manages to store its pointer here
-     * first gets to store data in each glyph
-     */
-    const cairo_surface_backend_t *surface_backend;
-    void *surface_private;
-
-    /* font backend managing this scaled font */
-    const cairo_scaled_font_backend_t *backend;
-};
-
-cairo_private void
-_cairo_scaled_font_revoke_ownership (cairo_scaled_font_t *scaled_font);
-
-#endif /* CAIRO_SCALED_FONT_PRIVATE_H */
diff --git a/src/cairo/cairo-slope-private.h b/src/cairo/cairo-slope-private.h
deleted file mode 100644
index 4148c68..0000000
--- a/src/cairo/cairo-slope-private.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/* cairo - a vector graphics library with display and print output
- *
- * Copyright © 2002 University of Southern California
- * Copyright © 2005 Red Hat, Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it either under the terms of the GNU Lesser General Public
- * License version 2.1 as published by the Free Software Foundation
- * (the "LGPL") or, at your option, under the terms of the Mozilla
- * Public License Version 1.1 (the "MPL"). If you do not alter this
- * notice, a recipient may use your version of this file under either
- * the MPL or the LGPL.
- *
- * You should have received a copy of the LGPL along with this library
- * in the file COPYING-LGPL-2.1; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- * You should have received a copy of the MPL along with this library
- * in the file COPYING-MPL-1.1
- *
- * The contents of this file are subject to the Mozilla Public License
- * Version 1.1 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
- * OF ANY KIND, either express or implied. See the LGPL or the MPL for
- * the specific language governing rights and limitations.
- *
- * The Original Code is the cairo graphics library.
- *
- * The Initial Developer of the Original Code is University of Southern
- * California.
- *
- * Contributor(s):
- *	Carl D. Worth <cworth@cworth.org>
- */
-
-#ifndef _CAIRO_SLOPE_PRIVATE_H
-#define _CAIRO_SLOPE_PRIVATE_H
-
-#include "cairo-types-private.h"
-#include "cairo-fixed-private.h"
-
-static inline void
-_cairo_slope_init (cairo_slope_t *slope,
-		   const cairo_point_t *a,
-		   const cairo_point_t *b)
-{
-    slope->dx = b->x - a->x;
-    slope->dy = b->y - a->y;
-}
-
-static inline cairo_bool_t
-_cairo_slope_equal (const cairo_slope_t *a, const cairo_slope_t *b)
-{
-    return _cairo_int64_eq (_cairo_int32x32_64_mul (a->dy, b->dx),
-			    _cairo_int32x32_64_mul (b->dy, a->dx));
-}
-
-cairo_private int
-_cairo_slope_compare (const cairo_slope_t *a,
-	              const cairo_slope_t *b) cairo_pure;
-
-
-#endif /* _CAIRO_SLOPE_PRIVATE_H */
diff --git a/src/cairo/cairo-spans-private.h b/src/cairo/cairo-spans-private.h
deleted file mode 100644
index e29a567..0000000
--- a/src/cairo/cairo-spans-private.h
+++ /dev/null
@@ -1,155 +0,0 @@
-/* -*- Mode: c; tab-width: 8; c-basic-offset: 4; indent-tabs-mode: t; -*- */
-/* cairo - a vector graphics library with display and print output
- *
- * Copyright (c) 2008  M Joonas Pihlaja
- *
- * Permission is hereby granted, free of charge, to any person
- * obtaining a copy of this software and associated documentation
- * files (the "Software"), to deal in the Software without
- * restriction, including without limitation the rights to use,
- * copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following
- * conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- */
-#ifndef CAIRO_SPANS_PRIVATE_H
-#define CAIRO_SPANS_PRIVATE_H
-#include "cairo-types-private.h"
-#include "cairo-compiler-private.h"
-
-/* Number of bits of precision used for alpha. */
-#define CAIRO_SPANS_UNIT_COVERAGE_BITS 8
-#define CAIRO_SPANS_UNIT_COVERAGE ((1 << CAIRO_SPANS_UNIT_COVERAGE_BITS)-1)
-
-/* A structure representing an open-ended horizontal span of constant
- * pixel coverage. */
-typedef struct _cairo_half_open_span {
-    /* The inclusive x-coordinate of the start of the span. */
-    int x;
-
-    /* The pixel coverage for the pixels to the right. */
-    int coverage;
-} cairo_half_open_span_t;
-
-/* Span renderer interface. Instances of renderers are provided by
- * surfaces if they want to composite spans instead of trapezoids. */
-typedef struct _cairo_span_renderer cairo_span_renderer_t;
-struct _cairo_span_renderer {
-    /* Called to destroy the renderer. */
-    cairo_destroy_func_t	destroy;
-
-    /* Render the spans on row y of the source by whatever compositing
-     * method is required.  The function should ignore spans outside
-     * the bounding box set by the init() function. */
-    cairo_status_t (*render_row)(
-	void				*abstract_renderer,
-	int				 y,
-	const cairo_half_open_span_t	*coverages,
-	unsigned			 num_coverages);
-
-    /* Called after all rows have been rendered to perform whatever
-     * final rendering step is required.  This function is called just
-     * once before the renderer is destroyed. */
-    cairo_status_t (*finish)(
-	void		      *abstract_renderer);
-
-    /* Private status variable. */
-    cairo_status_t status;
-};
-
-/* Scan converter interface. */
-typedef struct _cairo_scan_converter cairo_scan_converter_t;
-struct _cairo_scan_converter {
-    /* Destroy this scan converter. */
-    cairo_destroy_func_t	destroy;
-
-    /* Add a single edge to the converter. */
-    cairo_status_t (*add_edge) (void		    *abstract_converter,
-				const cairo_point_t *p1,
-				const cairo_point_t *p2,
-				int top, int bottom,
-				int dir);
-
-    /* Add a polygon (set of edges) to the converter. */
-    cairo_status_t (*add_polygon) (void		    *abstract_converter,
-				   const cairo_polygon_t  *polygon);
-
-    /* Generates coverage spans for rows for the added edges and calls
-     * the renderer function for each row. After generating spans the
-     * only valid thing to do with the converter is to destroy it. */
-    cairo_status_t (*generate) (void			*abstract_converter,
-				cairo_span_renderer_t	*renderer);
-
-    /* Private status. Read with _cairo_scan_converter_status(). */
-    cairo_status_t status;
-};
-
-/* Scan converter constructors. */
-
-cairo_private cairo_scan_converter_t *
-_cairo_tor_scan_converter_create (int			xmin,
-				  int			ymin,
-				  int			xmax,
-				  int			ymax,
-				  cairo_fill_rule_t	fill_rule);
-
-/* cairo-spans.c: */
-
-cairo_private cairo_scan_converter_t *
-_cairo_scan_converter_create_in_error (cairo_status_t error);
-
-cairo_private cairo_status_t
-_cairo_scan_converter_status (void *abstract_converter);
-
-cairo_private cairo_status_t
-_cairo_scan_converter_set_error (void *abstract_converter,
-				 cairo_status_t error);
-
-cairo_private cairo_span_renderer_t *
-_cairo_span_renderer_create_in_error (cairo_status_t error);
-
-cairo_private cairo_status_t
-_cairo_span_renderer_status (void *abstract_renderer);
-
-/* Set the renderer into an error state.  This sets all the method
- * pointers except ->destroy() of the renderer to no-op
- * implementations that just return the error status. */
-cairo_private cairo_status_t
-_cairo_span_renderer_set_error (void *abstract_renderer,
-				cairo_status_t error);
-
-cairo_private cairo_status_t
-_cairo_surface_composite_polygon (cairo_surface_t	*surface,
-				  cairo_operator_t	 op,
-				  const cairo_pattern_t	*pattern,
-				  cairo_fill_rule_t	fill_rule,
-				  cairo_antialias_t	antialias,
-				  const cairo_composite_rectangles_t *rects,
-				  cairo_polygon_t	*polygon,
-				  cairo_region_t	*clip_region);
-
-cairo_private cairo_status_t
-_cairo_surface_composite_trapezoids_as_polygon (cairo_surface_t	*surface,
-						cairo_operator_t	 op,
-						const cairo_pattern_t	*pattern,
-						cairo_antialias_t	antialias,
-						int src_x, int src_y,
-						int dst_x, int dst_y,
-						int width, int height,
-						cairo_trapezoid_t	*traps,
-						int num_traps,
-						cairo_region_t	*clip_region);
-
-#endif /* CAIRO_SPANS_PRIVATE_H */
diff --git a/src/cairo/cairo-surface-private.h b/src/cairo/cairo-surface-private.h
deleted file mode 100644
index 994df0e..0000000
--- a/src/cairo/cairo-surface-private.h
+++ /dev/null
@@ -1,98 +0,0 @@
-/* cairo - a vector graphics library with display and print output
- *
- * Copyright © 2002 University of Southern California
- * Copyright © 2005 Red Hat, Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it either under the terms of the GNU Lesser General Public
- * License version 2.1 as published by the Free Software Foundation
- * (the "LGPL") or, at your option, under the terms of the Mozilla
- * Public License Version 1.1 (the "MPL"). If you do not alter this
- * notice, a recipient may use your version of this file under either
- * the MPL or the LGPL.
- *
- * You should have received a copy of the LGPL along with this library
- * in the file COPYING-LGPL-2.1; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- * You should have received a copy of the MPL along with this library
- * in the file COPYING-MPL-1.1
- *
- * The contents of this file are subject to the Mozilla Public License
- * Version 1.1 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
- * OF ANY KIND, either express or implied. See the LGPL or the MPL for
- * the specific language governing rights and limitations.
- *
- * The Original Code is the cairo graphics library.
- *
- * The Initial Developer of the Original Code is University of Southern
- * California.
- *
- * Contributor(s):
- *	Carl D. Worth <cworth@cworth.org>
- */
-
-#ifndef CAIRO_SURFACE_PRIVATE_H
-#define CAIRO_SURFACE_PRIVATE_H
-
-#include "cairo.h"
-
-#include "cairo-types-private.h"
-#include "cairo-reference-count-private.h"
-#include "cairo-clip-private.h"
-
-typedef void (*cairo_surface_func_t) (cairo_surface_t *);
-
-struct _cairo_surface {
-    const cairo_surface_backend_t *backend;
-
-    /* We allow surfaces to override the backend->type by shoving something
-     * else into surface->type. This is for "wrapper" surfaces that want to
-     * hide their internal type from the user-level API. */
-    cairo_surface_type_t type;
-
-    cairo_content_t content;
-
-    cairo_reference_count_t ref_count;
-    cairo_status_t status;
-    unsigned int unique_id;
-
-    unsigned finished : 1;
-    unsigned is_clear : 1;
-    unsigned has_font_options : 1;
-
-    cairo_user_data_array_t user_data;
-    cairo_user_data_array_t mime_data;
-
-    cairo_matrix_t device_transform;
-    cairo_matrix_t device_transform_inverse;
-
-    /* The actual resolution of the device, in dots per inch. */
-    double x_resolution;
-    double y_resolution;
-
-    /* The resolution that should be used when generating image-based
-     * fallback; generally only used by the analysis/paginated
-     * surfaces
-     */
-    double x_fallback_resolution;
-    double y_fallback_resolution;
-
-    /* A "snapshot" surface is immutable. See _cairo_surface_snapshot. */
-    cairo_surface_t *snapshot_of;
-    cairo_surface_func_t snapshot_detach;
-    /* current snapshots of this surface */
-    cairo_array_t snapshots;
-
-    /*
-     * Surface font options, falling back to backend's default options,
-     * and set using _cairo_surface_set_font_options(), and propagated by
-     * cairo_surface_create_similar().
-     */
-    cairo_font_options_t font_options;
-};
-
-#endif /* CAIRO_SURFACE_PRIVATE_H */
diff --git a/src/cairo/cairo-traps.c b/src/cairo/cairo-traps.c
index a15216f..089f3c6 100644
--- a/src/cairo/cairo-traps.c
+++ b/src/cairo/cairo-traps.c
@@ -37,10 +37,10 @@
  * 2002-07-15: Converted from XRenderCompositeDoublePoly to #cairo_trap_t. Carl D. Worth
  */
 
-#include "cairoint.h"
-
-#include "cairo-region-private.h"
-#include "cairo-slope-private.h"
+#include "cairoint-minimal.h"
+#include "cairo-malloc-private.h"
+#include "cairo-traps-private.h"
+#include "cairo-fixed-private.h"
 
 #define _cairo_error(x) (x)
 
@@ -104,11 +104,6 @@ _cairo_traps_grow (cairo_traps_t *traps)
     cairo_trapezoid_t *new_traps;
     int new_size = 4 * traps->traps_size;
 
-    if (CAIRO_INJECT_FAULT ()) {
-	traps->status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
-	return FALSE;
-    }
-
     if (traps->traps == traps->traps_embedded) {
 	new_traps = _cairo_malloc_ab (new_size, sizeof (cairo_trapezoid_t));
 	if (new_traps != NULL)
@@ -368,53 +363,6 @@ _cairo_trapezoid_array_translate_and_scale (cairo_trapezoid_t *offset_traps,
     }
 }
 
-#if 0
-static cairo_bool_t
-_cairo_trap_contains (cairo_trapezoid_t *t, cairo_point_t *pt)
-{
-    cairo_slope_t slope_left, slope_pt, slope_right;
-
-    if (t->top > pt->y)
-	return FALSE;
-    if (t->bottom < pt->y)
-	return FALSE;
-
-    _cairo_slope_init (&slope_left, &t->left.p1, &t->left.p2);
-    _cairo_slope_init (&slope_pt, &t->left.p1, pt);
-
-    if (_cairo_slope_compare (&slope_left, &slope_pt) < 0)
-	return FALSE;
-
-    _cairo_slope_init (&slope_right, &t->right.p1, &t->right.p2);
-    _cairo_slope_init (&slope_pt, &t->right.p1, pt);
-
-    if (_cairo_slope_compare (&slope_pt, &slope_right) < 0)
-	return FALSE;
-
-    return TRUE;
-}
-#endif
-
-#if 0
-cairo_bool_t
-_cairo_traps_contain (const cairo_traps_t *traps,
-		      double x, double y)
-{
-    int i;
-    cairo_point_t point;
-
-    point.x = _cairo_fixed_from_double (x);
-    point.y = _cairo_fixed_from_double (y);
-
-    for (i = 0; i < traps->num_traps; i++) {
-	if (_cairo_trap_contains (&traps->traps[i], &point))
-	    return TRUE;
-    }
-
-    return FALSE;
-}
-#endif
-
 static cairo_fixed_t
 _line_compute_intersection_x_for_y (const cairo_line_t *line,
 				    cairo_fixed_t y)
@@ -488,128 +436,3 @@ _cairo_traps_extents (const cairo_traps_t *traps,
 	}
     }
 }
-
-
-#if 0
-/**
- * _cairo_traps_extract_region:
- * @traps: a #cairo_traps_t
- * @region: a #cairo_region_t
- *
- * Determines if a set of trapezoids are exactly representable as a
- * cairo region.  If so, the passed-in region is initialized to
- * the area representing the given traps.  It should be finalized
- * with cairo_region_fini().  If not, %CAIRO_INT_STATUS_UNSUPPORTED
- * is returned.
- *
- * Return value: %CAIRO_STATUS_SUCCESS, %CAIRO_INT_STATUS_UNSUPPORTED
- * or %CAIRO_STATUS_NO_MEMORY
- **/
-cairo_int_status_t
-_cairo_traps_extract_region (cairo_traps_t   *traps,
-			     cairo_region_t **region)
-{
-    cairo_rectangle_int_t stack_rects[CAIRO_STACK_ARRAY_LENGTH (cairo_rectangle_int_t)];
-    cairo_rectangle_int_t *rects = stack_rects;
-    cairo_int_status_t status;
-    int i, rect_count;
-
-    /* we only treat this a hint... */
-    if (! traps->maybe_region)
-	return CAIRO_INT_STATUS_UNSUPPORTED;
-
-    for (i = 0; i < traps->num_traps; i++) {
-	if (traps->traps[i].left.p1.x != traps->traps[i].left.p2.x   ||
-	    traps->traps[i].right.p1.x != traps->traps[i].right.p2.x ||
-	    ! _cairo_fixed_is_integer (traps->traps[i].top)          ||
-	    ! _cairo_fixed_is_integer (traps->traps[i].bottom)       ||
-	    ! _cairo_fixed_is_integer (traps->traps[i].left.p1.x)    ||
-	    ! _cairo_fixed_is_integer (traps->traps[i].right.p1.x))
-	{
-	    traps->maybe_region = FALSE;
-	    return CAIRO_INT_STATUS_UNSUPPORTED;
-	}
-    }
-
-    if (traps->num_traps > ARRAY_LENGTH (stack_rects)) {
-	rects = _cairo_malloc_ab (traps->num_traps, sizeof (cairo_rectangle_int_t));
-
-	if (unlikely (rects == NULL))
-	    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
-    }
-
-    rect_count = 0;
-    for (i = 0; i < traps->num_traps; i++) {
-	int x1 = _cairo_fixed_integer_part (traps->traps[i].left.p1.x);
-	int y1 = _cairo_fixed_integer_part (traps->traps[i].top);
-	int x2 = _cairo_fixed_integer_part (traps->traps[i].right.p1.x);
-	int y2 = _cairo_fixed_integer_part (traps->traps[i].bottom);
-
-	rects[rect_count].x = x1;
-	rects[rect_count].y = y1;
-	rects[rect_count].width = x2 - x1;
-	rects[rect_count].height = y2 - y1;
-
-	rect_count++;
-    }
-
-    *region = cairo_region_create_rectangles (rects, rect_count);
-    status = (*region)->status;
-
-    if (rects != stack_rects)
-	free (rects);
-
-    return status;
-}
-#endif
-
-#if 0
-/* moves trap points such that they become the actual corners of the trapezoid */
-static void
-_sanitize_trap (cairo_trapezoid_t *t)
-{
-    cairo_trapezoid_t s = *t;
-
-#define FIX(lr, tb, p) \
-    if (t->lr.p.y != t->tb) { \
-        t->lr.p.x = s.lr.p2.x + _cairo_fixed_mul_div_floor (s.lr.p1.x - s.lr.p2.x, s.tb - s.lr.p2.y, s.lr.p1.y - s.lr.p2.y); \
-        t->lr.p.y = s.tb; \
-    }
-    FIX (left,  top,    p1);
-    FIX (left,  bottom, p2);
-    FIX (right, top,    p1);
-    FIX (right, bottom, p2);
-}
-#endif
-
-#if 0
-cairo_private cairo_status_t
-_cairo_traps_path (const cairo_traps_t *traps,
-		   cairo_path_fixed_t  *path)
-{
-    int i;
-
-    for (i = 0; i < traps->num_traps; i++) {
-	cairo_status_t status;
-	cairo_trapezoid_t trap = traps->traps[i];
-
-	if (trap.top == trap.bottom)
-	    continue;
-
-	_sanitize_trap (&trap);
-
-	status = _cairo_path_fixed_move_to (path, trap.left.p1.x, trap.top);
-	if (unlikely (status)) return status;
-	status = _cairo_path_fixed_line_to (path, trap.right.p1.x, trap.top);
-	if (unlikely (status)) return status;
-	status = _cairo_path_fixed_line_to (path, trap.right.p2.x, trap.bottom);
-	if (unlikely (status)) return status;
-	status = _cairo_path_fixed_line_to (path, trap.left.p2.x, trap.bottom);
-	if (unlikely (status)) return status;
-	status = _cairo_path_fixed_close_path (path);
-	if (unlikely (status)) return status;
-    }
-
-    return CAIRO_STATUS_SUCCESS;
-}
-#endif
diff --git a/src/cairo/cairo-types-private.h b/src/cairo/cairo-types-private.h
index 3a3b849..5e024f9 100644
--- a/src/cairo/cairo-types-private.h
+++ b/src/cairo/cairo-types-private.h
@@ -42,31 +42,16 @@
 #include "cairo.h"
 #include "cairo-fixed-type-private.h"
 #include "cairo-list-private.h"
-#include "cairo-reference-count-private.h"
 
 typedef struct _cairo_array cairo_array_t;
 typedef struct _cairo_backend cairo_backend_t;
 typedef struct _cairo_cache cairo_cache_t;
 typedef struct _cairo_clip cairo_clip_t;
 typedef struct _cairo_clip_path cairo_clip_path_t;
-typedef struct _cairo_color cairo_color_t;
-typedef struct _cairo_font_face_backend     cairo_font_face_backend_t;
 typedef struct _cairo_gstate cairo_gstate_t;
 typedef struct _cairo_hash_entry cairo_hash_entry_t;
 typedef struct _cairo_hash_table cairo_hash_table_t;
-typedef struct _cairo_image_surface cairo_image_surface_t;
-typedef struct _cairo_mime_data cairo_mime_data_t;
-typedef struct _cairo_output_stream cairo_output_stream_t;
-typedef struct _cairo_paginated_surface_backend cairo_paginated_surface_backend_t;
 typedef struct _cairo_path_fixed cairo_path_fixed_t;
-typedef struct _cairo_rectangle_int16 cairo_glyph_size_t;
-typedef struct _cairo_scaled_font_backend   cairo_scaled_font_backend_t;
-typedef struct _cairo_scaled_font_subsets cairo_scaled_font_subsets_t;
-typedef struct _cairo_solid_pattern cairo_solid_pattern_t;
-typedef struct _cairo_surface_backend cairo_surface_backend_t;
-typedef struct _cairo_surface_wrapper cairo_surface_wrapper_t;
-typedef struct _cairo_unscaled_font_backend cairo_unscaled_font_backend_t;
-typedef struct _cairo_xlib_screen_info cairo_xlib_screen_info_t;
 
 typedef cairo_array_t cairo_user_data_array_t;
 
@@ -117,37 +102,6 @@ struct _cairo_array {
     cairo_bool_t is_snapshot;
 };
 
-struct _cairo_font_options {
-    cairo_antialias_t antialias;
-    cairo_subpixel_order_t subpixel_order;
-    cairo_hint_style_t hint_style;
-    cairo_hint_metrics_t hint_metrics;
-};
-
-/* XXX: Right now, the _cairo_color structure puts unpremultiplied
-   color in the doubles and premultiplied color in the shorts. Yes,
-   this is crazy insane, (but at least we don't export this
-   madness). I'm still working on a cleaner API, but in the meantime,
-   at least this does prevent precision loss in color when changing
-   alpha. */
-struct _cairo_color {
-    double red;
-    double green;
-    double blue;
-    double alpha;
-
-    unsigned short red_short;
-    unsigned short green_short;
-    unsigned short blue_short;
-    unsigned short alpha_short;
-};
-
-typedef enum _cairo_paginated_mode {
-    CAIRO_PAGINATED_MODE_ANALYZE,	/* analyze page regions */
-    CAIRO_PAGINATED_MODE_RENDER,	/* render page contents */
-    CAIRO_PAGINATED_MODE_FALLBACK 	/* paint fallback images */
-} cairo_paginated_mode_t;
-
 /* Sure wish C had a real enum type so that this would be distinct
  * from #cairo_status_t. Oh well, without that, I'll use this bogus 100
  * offset.  We want to keep it fit in int8_t as the compiler may choose
@@ -163,20 +117,6 @@ typedef enum _cairo_int_status {
     CAIRO_INT_STATUS_LAST_STATUS
 } cairo_int_status_t;
 
-typedef enum _cairo_internal_surface_type {
-    CAIRO_INTERNAL_SURFACE_TYPE_PAGINATED = 0x1000,
-    CAIRO_INTERNAL_SURFACE_TYPE_ANALYSIS,
-    CAIRO_INTERNAL_SURFACE_TYPE_TEST_FALLBACK,
-    CAIRO_INTERNAL_SURFACE_TYPE_TEST_PAGINATED,
-    CAIRO_INTERNAL_SURFACE_TYPE_TEST_WRAPPING,
-    CAIRO_INTERNAL_SURFACE_TYPE_NULL,
-    CAIRO_INTERNAL_SURFACE_TYPE_TYPE3_GLYPH
-} cairo_internal_surface_type_t;
-
-#define CAIRO_HAS_TEST_PAGINATED_SURFACE 1
-#define CAIRO_HAS_TEST_NULL_SURFACE 1
-#define CAIRO_HAS_TEST_WRAPPING_SURFACE 1
-
 typedef struct _cairo_slope {
     cairo_fixed_t dx;
     cairo_fixed_t dy;
@@ -232,11 +172,6 @@ typedef struct _cairo_composite_rectangles {
         int height;
 } cairo_composite_rectangles_t;
 
-typedef enum _cairo_direction {
-    CAIRO_DIRECTION_FORWARD,
-    CAIRO_DIRECTION_REVERSE
-} cairo_direction_t;
-
 typedef struct _cairo_edge {
     cairo_line_t line;
     int top, bottom;
@@ -268,147 +203,4 @@ typedef cairo_warn cairo_status_t
 (*cairo_spline_add_point_func_t) (void *closure,
 				  const cairo_point_t *point);
 
-typedef struct _cairo_spline_knots {
-    cairo_point_t a, b, c, d;
-} cairo_spline_knots_t;
-
-typedef struct _cairo_spline {
-    cairo_spline_add_point_func_t add_point_func;
-    void *closure;
-
-    cairo_spline_knots_t knots;
-
-    cairo_slope_t initial_slope;
-    cairo_slope_t final_slope;
-
-    cairo_bool_t has_point;
-    cairo_point_t last_point;
-} cairo_spline_t;
-
-typedef struct _cairo_pen_vertex {
-    cairo_point_t point;
-
-    cairo_slope_t slope_ccw;
-    cairo_slope_t slope_cw;
-} cairo_pen_vertex_t;
-
-typedef struct _cairo_pen {
-    double radius;
-    double tolerance;
-
-    int num_vertices;
-    cairo_pen_vertex_t *vertices;
-    cairo_pen_vertex_t  vertices_embedded[32];
-} cairo_pen_t;
-
-typedef struct _cairo_stroke_style {
-    double		 line_width;
-    cairo_line_cap_t	 line_cap;
-    cairo_line_join_t	 line_join;
-    double		 miter_limit;
-    double		*dash;
-    unsigned int	 num_dashes;
-    double		 dash_offset;
-} cairo_stroke_style_t;
-
-typedef struct _cairo_format_masks {
-    int bpp;
-    unsigned long alpha_mask;
-    unsigned long red_mask;
-    unsigned long green_mask;
-    unsigned long blue_mask;
-} cairo_format_masks_t;
-
-typedef enum {
-    CAIRO_STOCK_WHITE,
-    CAIRO_STOCK_BLACK,
-    CAIRO_STOCK_TRANSPARENT
-} cairo_stock_t;
-
-typedef enum _cairo_image_transparency {
-    CAIRO_IMAGE_IS_OPAQUE,
-    CAIRO_IMAGE_HAS_BILEVEL_ALPHA,
-    CAIRO_IMAGE_HAS_ALPHA,
-    CAIRO_IMAGE_UNKNOWN
-} cairo_image_transparency_t;
-
-struct _cairo_mime_data {
-    cairo_reference_count_t ref_count;
-    unsigned char *data;
-    unsigned int length;
-    cairo_destroy_func_t destroy;
-    void *closure;
-};
-
-struct _cairo_pattern {
-    cairo_pattern_type_t	type;
-    cairo_reference_count_t	ref_count;
-    cairo_status_t		status;
-    cairo_user_data_array_t	user_data;
-
-    cairo_matrix_t		matrix;
-    cairo_filter_t		filter;
-    cairo_extend_t		extend;
-
-    cairo_bool_t		has_component_alpha;
-};
-
-struct _cairo_solid_pattern {
-    cairo_pattern_t base;
-    cairo_color_t color;
-    cairo_content_t content;
-};
-
-typedef struct _cairo_surface_pattern {
-    cairo_pattern_t base;
-
-    cairo_surface_t *surface;
-} cairo_surface_pattern_t;
-
-typedef struct _cairo_gradient_stop {
-    double offset;
-    cairo_color_t color;
-} cairo_gradient_stop_t;
-
-typedef struct _cairo_gradient_pattern {
-    cairo_pattern_t base;
-
-    unsigned int	    n_stops;
-    unsigned int	    stops_size;
-    cairo_gradient_stop_t  *stops;
-    cairo_gradient_stop_t   stops_embedded[2];
-} cairo_gradient_pattern_t;
-
-typedef struct _cairo_linear_pattern {
-    cairo_gradient_pattern_t base;
-
-    cairo_point_t p1;
-    cairo_point_t p2;
-} cairo_linear_pattern_t;
-
-typedef struct _cairo_radial_pattern {
-    cairo_gradient_pattern_t base;
-
-    cairo_point_t c1;
-    cairo_fixed_t r1;
-    cairo_point_t c2;
-    cairo_fixed_t r2;
-} cairo_radial_pattern_t;
-
-typedef union {
-    cairo_gradient_pattern_t base;
-
-    cairo_linear_pattern_t linear;
-    cairo_radial_pattern_t radial;
-} cairo_gradient_pattern_union_t;
-
-typedef union {
-    cairo_pattern_type_t	    type;
-    cairo_pattern_t		    base;
-
-    cairo_solid_pattern_t	    solid;
-    cairo_surface_pattern_t	    surface;
-    cairo_gradient_pattern_union_t  gradient;
-} cairo_pattern_union_t;
-
 #endif /* CAIRO_TYPES_PRIVATE_H */
diff --git a/src/cairo/cairo-wideint-type-private.h b/src/cairo/cairo-wideint-type-private.h
index c7363c0..e18f48e 100644
--- a/src/cairo/cairo-wideint-type-private.h
+++ b/src/cairo/cairo-wideint-type-private.h
@@ -37,8 +37,6 @@
 #ifndef CAIRO_WIDEINT_TYPE_H
 #define CAIRO_WIDEINT_TYPE_H
 
-#include "cairo.h"
-
 #if HAVE_CONFIG_H
 #include "config.h"
 #endif
diff --git a/src/cairo/cairo-wideint.c b/src/cairo/cairo-wideint.c
index 2c70d86..823ebca 100644
--- a/src/cairo/cairo-wideint.c
+++ b/src/cairo/cairo-wideint.c
@@ -33,7 +33,7 @@
  *	Keith R. Packard <keithp@keithp.com>
  */
 
-#include "cairoint.h"
+#include "cairo-wideint-private.h"
 
 #if HAVE_UINT64_T
 
diff --git a/src/cairo/cairo.h b/src/cairo/cairo.h
index 8be8043..6c43402 100644
--- a/src/cairo/cairo.h
+++ b/src/cairo/cairo.h
@@ -38,9 +38,7 @@
 #ifndef CAIRO_H
 #define CAIRO_H
 
-#include "cairo-version.h"
 #include "cairo-features.h"
-#include "cairo-deprecated.h"
 
 #ifdef  __cplusplus
 # define CAIRO_BEGIN_DECLS  extern "C" {
@@ -51,11 +49,7 @@
 #endif
 
 #ifndef cairo_public
-# if defined (_MSC_VER) && ! defined (CAIRO_WIN32_STATIC_BUILD)
-#  define cairo_public __declspec(dllimport)
-# else
-#  define cairo_public
-# endif
+# define cairo_public
 #endif
 
 CAIRO_BEGIN_DECLS
@@ -81,13 +75,10 @@ CAIRO_BEGIN_DECLS
 	CAIRO_VERSION_MINOR,				\
 	CAIRO_VERSION_MICRO)
 
-
-cairo_public int
-cairo_version (void);
-
+#if 0
 cairo_public const char*
 cairo_version_string (void);
-
+#endif
 /**
  * cairo_bool_t:
  *
diff --git a/src/cairo/cairoint-minimal.h b/src/cairo/cairoint-minimal.h
new file mode 100644
index 0000000..4bde38d
--- /dev/null
+++ b/src/cairo/cairoint-minimal.h
@@ -0,0 +1,147 @@
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2002 University of Southern California
+ * Copyright © 2005 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is University of Southern
+ * California.
+ *
+ * Contributor(s):
+ *	Carl D. Worth <cworth@cworth.org>
+ */
+
+/*
+ * These definitions are solely for use by the implementation of cairo
+ * and constitute no kind of standard.  If you need any of these
+ * functions, please drop me a note.  Either the library needs new
+ * functionality, or there's a way to do what you need using the
+ * existing published interfaces. cworth@cworth.org
+ */
+
+#ifndef _CAIROINT_H_
+#define _CAIROINT_H_
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#ifdef _MSC_VER
+#define cairo_public __declspec(dllexport)
+#endif
+
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdarg.h>
+#include <stddef.h>
+
+#ifdef _MSC_VER
+#define _USE_MATH_DEFINES
+#endif
+#include <math.h>
+#include <limits.h>
+#include <stdio.h>
+
+#include "cairo.h"
+#include <pixman.h>
+
+#include "cairo-compiler-private.h"
+
+CAIRO_BEGIN_DECLS
+
+#if _WIN32 && !_WIN32_WCE /* Permissions on WinCE? No worries! */
+cairo_private FILE *
+_cairo_win32_tmpfile (void);
+#define tmpfile() _cairo_win32_tmpfile()
+#endif
+
+#undef MIN
+#define MIN(a, b) ((a) < (b) ? (a) : (b))
+
+#undef MAX
+#define MAX(a, b) ((a) > (b) ? (a) : (b))
+
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+
+#ifndef M_PI
+#define M_PI 3.14159265358979323846
+#endif
+
+#ifndef M_SQRT2
+#define M_SQRT2 1.41421356237309504880
+#endif
+
+#ifndef M_SQRT1_2
+#define M_SQRT1_2 0.707106781186547524400844362104849039
+#endif
+
+#undef  ARRAY_LENGTH
+#define ARRAY_LENGTH(__array) ((int) (sizeof (__array) / sizeof (__array[0])))
+
+#undef STRINGIFY
+#undef STRINGIFY_ARG
+#define STRINGIFY(macro_or_string)    STRINGIFY_ARG (macro_or_string)
+#define STRINGIFY_ARG(contents)       #contents
+
+#if defined (__GNUC__)
+#define cairo_container_of(ptr, type, member) ({ \
+    const __typeof__ (((type *) 0)->member) *mptr__ = (ptr); \
+    (type *) ((char *) mptr__ - offsetof (type, member)); \
+})
+#else
+#define cairo_container_of(ptr, type, member) \
+    (type *)((char *) (ptr) - (char *) &((type *)0)->member)
+#endif
+
+
+/* Size in bytes of buffer to use off the stack per functions.
+ * Mostly used by text functions.  For larger allocations, they'll
+ * malloc(). */
+#ifndef CAIRO_STACK_BUFFER_SIZE
+#define CAIRO_STACK_BUFFER_SIZE (512 * sizeof (int))
+#endif
+
+#define CAIRO_STACK_ARRAY_LENGTH(T) (CAIRO_STACK_BUFFER_SIZE / sizeof(T))
+
+
+#include "cairo-types-private.h"
+
+#if HAVE_VALGRIND
+# include <memcheck.h>
+# define VG(x) x
+#else
+# define VG(x)
+#endif
+
+#endif
diff --git a/src/cairo/cairoint.h b/src/cairo/cairoint.h
deleted file mode 100644
index a9207a1..0000000
--- a/src/cairo/cairoint.h
+++ /dev/null
@@ -1,2774 +0,0 @@
-/* cairo - a vector graphics library with display and print output
- *
- * Copyright © 2002 University of Southern California
- * Copyright © 2005 Red Hat, Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it either under the terms of the GNU Lesser General Public
- * License version 2.1 as published by the Free Software Foundation
- * (the "LGPL") or, at your option, under the terms of the Mozilla
- * Public License Version 1.1 (the "MPL"). If you do not alter this
- * notice, a recipient may use your version of this file under either
- * the MPL or the LGPL.
- *
- * You should have received a copy of the LGPL along with this library
- * in the file COPYING-LGPL-2.1; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- * You should have received a copy of the MPL along with this library
- * in the file COPYING-MPL-1.1
- *
- * The contents of this file are subject to the Mozilla Public License
- * Version 1.1 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
- * OF ANY KIND, either express or implied. See the LGPL or the MPL for
- * the specific language governing rights and limitations.
- *
- * The Original Code is the cairo graphics library.
- *
- * The Initial Developer of the Original Code is University of Southern
- * California.
- *
- * Contributor(s):
- *	Carl D. Worth <cworth@cworth.org>
- */
-
-/*
- * These definitions are solely for use by the implementation of cairo
- * and constitute no kind of standard.  If you need any of these
- * functions, please drop me a note.  Either the library needs new
- * functionality, or there's a way to do what you need using the
- * existing published interfaces. cworth@cworth.org
- */
-
-#ifndef _CAIROINT_H_
-#define _CAIROINT_H_
-
-#if HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#ifdef _MSC_VER
-#define cairo_public __declspec(dllexport)
-#endif
-
-#include <assert.h>
-#include <stdlib.h>
-#include <string.h>
-#include <stdarg.h>
-#include <stddef.h>
-
-#ifdef _MSC_VER
-#define _USE_MATH_DEFINES
-#endif
-#include <math.h>
-#include <limits.h>
-#include <stdio.h>
-
-#include "cairo.h"
-#include <pixman.h>
-
-#include "cairo-compiler-private.h"
-
-#if CAIRO_HAS_PS_SURFACE  || \
-    CAIRO_HAS_PDF_SURFACE || \
-    CAIRO_HAS_SVG_SURFACE || \
-    CAIRO_HAS_WIN32_SURFACE
-#define CAIRO_HAS_FONT_SUBSET 1
-#endif
-
-#if CAIRO_HAS_PS_SURFACE || CAIRO_HAS_PDF_SURFACE || CAIRO_HAS_FONT_SUBSET
-#define CAIRO_HAS_PDF_OPERATORS 1
-#endif
-
-CAIRO_BEGIN_DECLS
-
-#if _WIN32 && !_WIN32_WCE /* Permissions on WinCE? No worries! */
-cairo_private FILE *
-_cairo_win32_tmpfile (void);
-#define tmpfile() _cairo_win32_tmpfile()
-#endif
-
-#undef MIN
-#define MIN(a, b) ((a) < (b) ? (a) : (b))
-
-#undef MAX
-#define MAX(a, b) ((a) > (b) ? (a) : (b))
-
-#ifndef FALSE
-#define FALSE 0
-#endif
-
-#ifndef TRUE
-#define TRUE 1
-#endif
-
-#ifndef M_PI
-#define M_PI 3.14159265358979323846
-#endif
-
-#ifndef M_SQRT2
-#define M_SQRT2 1.41421356237309504880
-#endif
-
-#ifndef M_SQRT1_2
-#define M_SQRT1_2 0.707106781186547524400844362104849039
-#endif
-
-#undef  ARRAY_LENGTH
-#define ARRAY_LENGTH(__array) ((int) (sizeof (__array) / sizeof (__array[0])))
-
-#undef STRINGIFY
-#undef STRINGIFY_ARG
-#define STRINGIFY(macro_or_string)    STRINGIFY_ARG (macro_or_string)
-#define STRINGIFY_ARG(contents)       #contents
-
-#if defined (__GNUC__)
-#define cairo_container_of(ptr, type, member) ({ \
-    const __typeof__ (((type *) 0)->member) *mptr__ = (ptr); \
-    (type *) ((char *) mptr__ - offsetof (type, member)); \
-})
-#else
-#define cairo_container_of(ptr, type, member) \
-    (type *)((char *) (ptr) - (char *) &((type *)0)->member)
-#endif
-
-
-/* Size in bytes of buffer to use off the stack per functions.
- * Mostly used by text functions.  For larger allocations, they'll
- * malloc(). */
-#ifndef CAIRO_STACK_BUFFER_SIZE
-#define CAIRO_STACK_BUFFER_SIZE (512 * sizeof (int))
-#endif
-
-#define CAIRO_STACK_ARRAY_LENGTH(T) (CAIRO_STACK_BUFFER_SIZE / sizeof(T))
-
-#define ASSERT_NOT_REACHED		\
-do {					\
-    static const int NOT_REACHED = 0;	\
-    assert (NOT_REACHED);		\
-} while (0)
-#define COMPILE_TIME_ASSERT1(condition, line)		\
-    typedef int compile_time_assertion_at_line_##line##_failed [(condition)?1:-1]
-#define COMPILE_TIME_ASSERT0(condition, line)	COMPILE_TIME_ASSERT1(condition, line)
-#define COMPILE_TIME_ASSERT(condition)		COMPILE_TIME_ASSERT0(condition, __LINE__)
-
-#define CAIRO_ALPHA_IS_OPAQUE(alpha) ((alpha) >= ((double)0xff00 / (double)0xffff))
-#define CAIRO_ALPHA_SHORT_IS_OPAQUE(alpha) ((alpha) >= 0xff00)
-#define CAIRO_ALPHA_IS_ZERO(alpha) ((alpha) <= 0.0)
-
-#define CAIRO_COLOR_IS_OPAQUE(color) CAIRO_ALPHA_SHORT_IS_OPAQUE ((color)->alpha_short)
-
-/* Reverse the bits in a byte with 7 operations (no 64-bit):
- * Devised by Sean Anderson, July 13, 2001.
- * Source: http://graphics.stanford.edu/~seander/bithacks.html#ReverseByteWith32Bits
- */
-#define CAIRO_BITSWAP8(c) ((((c) * 0x0802LU & 0x22110LU) | ((c) * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16)
-
-/* Return the number of 1 bits in mask.
- *
- * GCC 3.4 supports a "population count" builtin, which on many targets is
- * implemented with a single instruction. There is a fallback definition
- * in libgcc in case a target does not have one, which should be just as
- * good as the open-coded solution below, (which is "HACKMEM 169").
- */
-static inline int cairo_const
-_cairo_popcount (uint32_t mask)
-{
-#if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
-    return __builtin_popcount (mask);
-#else
-    register int y;
-
-    y = (mask >> 1) &033333333333;
-    y = mask - y - ((y >>1) & 033333333333);
-    return (((y + (y >> 3)) & 030707070707) % 077);
-#endif
-}
-
-#ifdef WORDS_BIGENDIAN
-#define CAIRO_BITSWAP8_IF_LITTLE_ENDIAN(c) (c)
-#else
-#define CAIRO_BITSWAP8_IF_LITTLE_ENDIAN(c) CAIRO_BITSWAP8(c)
-#endif
-
-#ifdef WORDS_BIGENDIAN
-
-#define cpu_to_be16(v) (v)
-#define be16_to_cpu(v) (v)
-#define cpu_to_be32(v) (v)
-#define be32_to_cpu(v) (v)
-
-#else
-
-static inline uint16_t cairo_const
-cpu_to_be16(uint16_t v)
-{
-    return (v << 8) | (v >> 8);
-}
-
-static inline uint16_t cairo_const
-be16_to_cpu(uint16_t v)
-{
-    return cpu_to_be16 (v);
-}
-
-static inline uint32_t cairo_const
-cpu_to_be32(uint32_t v)
-{
-    return (cpu_to_be16 (v) << 16) | cpu_to_be16 (v >> 16);
-}
-
-static inline uint32_t cairo_const
-be32_to_cpu(uint32_t v)
-{
-    return cpu_to_be32 (v);
-}
-
-#endif
-
-#include "cairo-types-private.h"
-#include "cairo-cache-private.h"
-#include "cairo-reference-count-private.h"
-#include "cairo-spans-private.h"
-
-cairo_private void
-_cairo_box_from_doubles (cairo_box_t *box,
-			 double *x1, double *y1,
-			 double *x2, double *y2);
-
-cairo_private void
-_cairo_box_to_doubles (const cairo_box_t *box,
-		       double *x1, double *y1,
-		       double *x2, double *y2);
-
-cairo_private void
-_cairo_box_from_rectangle (cairo_box_t                 *box,
-			   const cairo_rectangle_int_t *rectangle);
-
-cairo_private void
-_cairo_box_round_to_rectangle (const cairo_box_t     *box,
-			       cairo_rectangle_int_t *rectangle);
-
-cairo_private void
-_cairo_boxes_get_extents (const cairo_box_t *boxes,
-			  int num_boxes,
-			  cairo_box_t *extents);
-
-static inline void
-_cairo_unbounded_rectangle_init (cairo_rectangle_int_t *rect)
-{
-    rect->x = CAIRO_RECT_INT_MIN;
-    rect->y = CAIRO_RECT_INT_MIN;
-    rect->width = CAIRO_RECT_INT_MAX - CAIRO_RECT_INT_MIN;
-    rect->height = CAIRO_RECT_INT_MAX - CAIRO_RECT_INT_MIN;
-}
-
-cairo_private cairo_bool_t
-_cairo_rectangle_intersect (cairo_rectangle_int_t *dst,
-			    const cairo_rectangle_int_t *src);
-
-cairo_private cairo_bool_t
-_cairo_box_intersects_line_segment (cairo_box_t *box,
-	                            cairo_line_t *line) cairo_pure;
-
-cairo_private cairo_bool_t
-_cairo_box_contains_point (cairo_box_t *box,
-	                   const cairo_point_t *point) cairo_pure;
-
-cairo_private void
-_cairo_composite_rectangles_init (cairo_composite_rectangles_t	*rects,
-                                  int				 all_x,
-                                  int				 all_y,
-                                  int				 width,
-                                  int				 height);
-
-/* cairo-array.c structures and functions */
-
-cairo_private void
-_cairo_array_init (cairo_array_t *array, int element_size);
-
-cairo_private void
-_cairo_array_init_snapshot (cairo_array_t	*array,
-			    const cairo_array_t *other);
-
-cairo_private void
-_cairo_array_fini (cairo_array_t *array);
-
-cairo_private cairo_status_t
-_cairo_array_grow_by (cairo_array_t *array, unsigned int additional);
-
-cairo_private void
-_cairo_array_truncate (cairo_array_t *array, unsigned int num_elements);
-
-cairo_private cairo_status_t
-_cairo_array_append (cairo_array_t *array, const void *element);
-
-cairo_private cairo_status_t
-_cairo_array_append_multiple (cairo_array_t	*array,
-			      const void	*elements,
-			      int		 num_elements);
-
-cairo_private cairo_status_t
-_cairo_array_allocate (cairo_array_t	 *array,
-		       unsigned int	  num_elements,
-		       void		**elements);
-
-cairo_private void *
-_cairo_array_index (cairo_array_t *array, unsigned int index);
-
-cairo_private void
-_cairo_array_copy_element (cairo_array_t *array, int index, void *dst);
-
-cairo_private int
-_cairo_array_num_elements (cairo_array_t *array);
-
-cairo_private int
-_cairo_array_size (cairo_array_t *array);
-
-typedef struct {
-    const cairo_user_data_key_t *key;
-    void *user_data;
-    cairo_destroy_func_t destroy;
-} cairo_user_data_slot_t;
-
-cairo_private void
-_cairo_user_data_array_init (cairo_user_data_array_t *array);
-
-cairo_private void
-_cairo_user_data_array_fini (cairo_user_data_array_t *array);
-
-cairo_private void *
-_cairo_user_data_array_get_data (cairo_user_data_array_t     *array,
-				 const cairo_user_data_key_t *key);
-
-cairo_private cairo_status_t
-_cairo_user_data_array_set_data (cairo_user_data_array_t     *array,
-				 const cairo_user_data_key_t *key,
-				 void			     *user_data,
-				 cairo_destroy_func_t	      destroy);
-
-cairo_private cairo_status_t
-_cairo_user_data_array_copy (cairo_user_data_array_t	*dst,
-			     cairo_user_data_array_t	*src);
-
-cairo_private void
-_cairo_user_data_array_foreach (cairo_user_data_array_t     *array,
-				void (*func) (const void *key,
-					      void *elt,
-					      void *closure),
-				void *closure);
-
-#define _CAIRO_HASH_INIT_VALUE 5381
-
-cairo_private unsigned long
-_cairo_hash_string (const char *c);
-
-cairo_private unsigned long
-_cairo_hash_bytes (unsigned long hash,
-		   const void *bytes,
-		   unsigned int length);
-
-/*
- * A #cairo_unscaled_font_t is just an opaque handle we use in the
- * glyph cache.
- */
-typedef struct _cairo_unscaled_font {
-    cairo_hash_entry_t			 hash_entry;
-    cairo_reference_count_t		 ref_count;
-    const cairo_unscaled_font_backend_t	*backend;
-} cairo_unscaled_font_t;
-
-typedef struct _cairo_scaled_glyph {
-    cairo_hash_entry_t hash_entry;
-
-    cairo_text_extents_t    metrics;		/* user-space metrics */
-    cairo_text_extents_t    fs_metrics;		/* font-space metrics */
-    cairo_box_t		    bbox;		/* device-space bounds */
-    int16_t                 x_advance;		/* device-space rounded X advance */
-    int16_t                 y_advance;		/* device-space rounded Y advance */
-
-    cairo_image_surface_t   *surface;		/* device-space image */
-    cairo_path_fixed_t	    *path;		/* device-space outline */
-    cairo_surface_t         *recording_surface;	/* device-space recording-surface */
-
-    void		    *surface_private;	/* for the surface backend */
-} cairo_scaled_glyph_t;
-
-#define _cairo_scaled_glyph_index(g) ((g)->hash_entry.hash)
-#define _cairo_scaled_glyph_set_index(g, i)  ((g)->hash_entry.hash = (i))
-
-#include "cairo-scaled-font-private.h"
-
-struct _cairo_font_face {
-    /* hash_entry must be first */
-    cairo_hash_entry_t hash_entry;
-    cairo_status_t status;
-    cairo_reference_count_t ref_count;
-    cairo_user_data_array_t user_data;
-    const cairo_font_face_backend_t *backend;
-};
-
-cairo_private void
-_cairo_toy_font_face_reset_static_data (void);
-
-cairo_private void
-_cairo_ft_font_reset_static_data (void);
-
-/* the font backend interface */
-
-struct _cairo_unscaled_font_backend {
-    void (*destroy)     	    (void		             *unscaled_font);
-};
-
-/* #cairo_toy_font_face_t - simple family/slant/weight font faces used for
- * the built-in font API
- */
-
-typedef struct _cairo_toy_font_face {
-    cairo_font_face_t base;
-    const char *family;
-    cairo_bool_t owns_family;
-    cairo_font_slant_t slant;
-    cairo_font_weight_t weight;
-
-    cairo_font_face_t *impl_face; /* The non-toy font face this actually uses */
-} cairo_toy_font_face_t;
-
-typedef enum _cairo_scaled_glyph_info {
-    CAIRO_SCALED_GLYPH_INFO_METRICS	 = (1 << 0),
-    CAIRO_SCALED_GLYPH_INFO_SURFACE	 = (1 << 1),
-    CAIRO_SCALED_GLYPH_INFO_PATH	 = (1 << 2),
-    CAIRO_SCALED_GLYPH_INFO_RECORDING_SURFACE = (1 << 3)
-} cairo_scaled_glyph_info_t;
-
-typedef struct _cairo_scaled_font_subset {
-    cairo_scaled_font_t *scaled_font;
-    unsigned int font_id;
-    unsigned int subset_id;
-
-    /* Index of glyphs array is subset_glyph_index.
-     * Value of glyphs array is scaled_font_glyph_index.
-     */
-    unsigned long *glyphs;
-    unsigned long *to_unicode;
-    char          **utf8;
-    char          **glyph_names;
-    unsigned int num_glyphs;
-    cairo_bool_t is_composite;
-    cairo_bool_t is_scaled;
-} cairo_scaled_font_subset_t;
-
-struct _cairo_scaled_font_backend {
-    cairo_font_type_t type;
-
-    void
-    (*fini)		(void			*scaled_font);
-
-    cairo_warn cairo_int_status_t
-    (*scaled_glyph_init)	(void			     *scaled_font,
-				 cairo_scaled_glyph_t	     *scaled_glyph,
-				 cairo_scaled_glyph_info_t    info);
-
-    /* A backend only needs to implement this or ucs4_to_index(), not
-     * both. This allows the backend to do something more sophisticated
-     * then just converting characters one by one.
-     */
-    cairo_warn cairo_int_status_t
-    (*text_to_glyphs) (void                       *scaled_font,
-		       double		           x,
-		       double		           y,
-		       const char	          *utf8,
-		       int		           utf8_len,
-		       cairo_glyph_t	         **glyphs,
-		       int		          *num_glyphs,
-		       cairo_text_cluster_t      **clusters,
-		       int		          *num_clusters,
-		       cairo_text_cluster_flags_t *cluster_flags);
-
-    unsigned long
-    (*ucs4_to_index)		(void			     *scaled_font,
-				 uint32_t		      ucs4);
-    cairo_warn cairo_int_status_t
-    (*show_glyphs)	(void			*scaled_font,
-			 cairo_operator_t	 op,
-			 const cairo_pattern_t	*pattern,
-			 cairo_surface_t	*surface,
-			 int			 source_x,
-			 int			 source_y,
-			 int			 dest_x,
-			 int			 dest_y,
-			 unsigned int		 width,
-			 unsigned int		 height,
-			 cairo_glyph_t		*glyphs,
-			 int			 num_glyphs,
-			 cairo_region_t		*clip_region,
-			 int			*remaining_glyphs);
-
-    cairo_warn cairo_int_status_t
-    (*load_truetype_table)(void		        *scaled_font,
-                           unsigned long         tag,
-                           long                  offset,
-                           unsigned char        *buffer,
-                           unsigned long        *length);
-
-    /* ucs4 is set to -1 if the unicode character could not be found
-     * for the glyph */
-    cairo_warn cairo_int_status_t
-    (*index_to_ucs4)(void                       *scaled_font,
-		     unsigned long               index,
-                     uint32_t                   *ucs4);
-};
-
-struct _cairo_font_face_backend {
-    cairo_font_type_t	type;
-
-    cairo_warn cairo_status_t
-    (*create_for_toy)  (cairo_toy_font_face_t	*toy_face,
-			cairo_font_face_t      **font_face);
-
-    /* The destroy() function is allowed to resurrect the font face
-     * by re-referencing. This is needed for the FreeType backend.
-     */
-    void
-    (*destroy)     (void			*font_face);
-
-    cairo_warn cairo_status_t
-    (*scaled_font_create) (void				*font_face,
-			   const cairo_matrix_t		*font_matrix,
-			   const cairo_matrix_t		*ctm,
-			   const cairo_font_options_t	*options,
-			   cairo_scaled_font_t	       **scaled_font);
-
-    cairo_font_face_t *
-    (*get_implementation) (void				*font_face,
-			   const cairo_matrix_t		*font_matrix,
-			   const cairo_matrix_t		*ctm,
-			   const cairo_font_options_t	*options);
-};
-
-extern const cairo_private struct _cairo_font_face_backend _cairo_user_font_face_backend;
-
-/* concrete font backends */
-#if CAIRO_HAS_FT_FONT
-
-extern const cairo_private struct _cairo_font_face_backend _cairo_ft_font_face_backend;
-
-#endif
-
-#if CAIRO_HAS_WIN32_FONT
-
-extern const cairo_private struct _cairo_font_face_backend _cairo_win32_font_face_backend;
-
-#endif
-
-#if CAIRO_HAS_QUARTZ_FONT
-
-extern const cairo_private struct _cairo_font_face_backend _cairo_quartz_font_face_backend;
-
-#endif
-
-struct _cairo_surface_backend {
-    cairo_surface_type_t type;
-
-    cairo_surface_t *
-    (*create_similar)		(void			*surface,
-				 cairo_content_t	 content,
-				 int			 width,
-				 int			 height);
-
-    cairo_warn cairo_status_t
-    (*finish)			(void			*surface);
-
-    cairo_warn cairo_status_t
-    (*acquire_source_image)	(void                    *abstract_surface,
-				 cairo_image_surface_t  **image_out,
-				 void                   **image_extra);
-
-    void
-    (*release_source_image)	(void                   *abstract_surface,
-				 cairo_image_surface_t  *image,
-				 void                   *image_extra);
-
-    cairo_warn cairo_status_t
-    (*acquire_dest_image)       (void                    *abstract_surface,
-				 cairo_rectangle_int_t   *interest_rect,
-				 cairo_image_surface_t  **image_out,
-				 cairo_rectangle_int_t   *image_rect,
-				 void                   **image_extra);
-
-    void
-    (*release_dest_image)       (void                    *abstract_surface,
-				 cairo_rectangle_int_t   *interest_rect,
-				 cairo_image_surface_t   *image,
-				 cairo_rectangle_int_t   *image_rect,
-				 void                    *image_extra);
-
-    /* Create a new surface (@clone_out) with the following
-     * characteristics:
-     *
-     * 1. It is as compatible as possible with @surface (in terms of
-     *    efficiency)
-     *
-     * 2. It has the same contents as @src within the given rectangle.
-     *
-     * 3. The offset of the similar surface with respect to the original
-     *    surface is returned in the clone_offset vector.
-     *    - if you clone the entire surface, this vector is zero.
-     *    - if you clone (src_x, src_y)x(w, h) the vector is (src_x, src_y);
-     */
-    cairo_warn cairo_status_t
-    (*clone_similar)            (void                   *surface,
-				 cairo_surface_t        *src,
-				 int                     src_x,
-				 int                     src_y,
-				 int                     width,
-				 int                     height,
-				 int                    *clone_offset_x,
-				 int                    *clone_offset_y,
-				 cairo_surface_t       **clone_out);
-
-    /* XXX remove to a separate cairo_surface_compositor_t */
-    /* XXX: dst should be the first argument for consistency */
-    cairo_warn cairo_int_status_t
-    (*composite)		(cairo_operator_t	 op,
-				 const cairo_pattern_t	*src,
-				 const cairo_pattern_t	*mask,
-				 void			*dst,
-				 int			 src_x,
-				 int			 src_y,
-				 int			 mask_x,
-				 int			 mask_y,
-				 int			 dst_x,
-				 int			 dst_y,
-				 unsigned int		 width,
-				 unsigned int		 height,
-				 cairo_region_t		*clip_region);
-
-    cairo_warn cairo_int_status_t
-    (*fill_rectangles)		(void			 *surface,
-				 cairo_operator_t	  op,
-				 const cairo_color_t     *color,
-				 cairo_rectangle_int_t   *rects,
-				 int			  num_rects);
-
-    /* XXX: dst should be the first argument for consistency */
-    cairo_warn cairo_int_status_t
-    (*composite_trapezoids)	(cairo_operator_t	 op,
-				 const cairo_pattern_t	*pattern,
-				 void			*dst,
-				 cairo_antialias_t	 antialias,
-				 int			 src_x,
-				 int			 src_y,
-				 int			 dst_x,
-				 int			 dst_y,
-				 unsigned int		 width,
-				 unsigned int		 height,
-				 cairo_trapezoid_t	*traps,
-				 int			 num_traps,
-				 cairo_region_t		*region);
-
-    cairo_warn cairo_span_renderer_t *
-    (*create_span_renderer)	(cairo_operator_t			 op,
-				 const cairo_pattern_t			*pattern,
-                                 void					*dst,
-                                 cairo_antialias_t			 antialias,
-                                 const cairo_composite_rectangles_t *rects,
-				 cairo_region_t *clip_region);
-
-    cairo_warn cairo_bool_t
-    (*check_span_renderer)	(cairo_operator_t			 op,
-				 const cairo_pattern_t			*pattern,
-                                 void					*dst,
-                                 cairo_antialias_t			 antialias);
-
-    cairo_warn cairo_int_status_t
-    (*copy_page)		(void			*surface);
-
-    cairo_warn cairo_int_status_t
-    (*show_page)		(void			*surface);
-
-    /* Get the extents of the current surface. For many surface types
-     * this will be as simple as { x=0, y=0, width=surface->width,
-     * height=surface->height}.
-     *
-     * If this function is not implemented, or if it returns
-     * FALSE the surface is considered to be
-     * boundless and infinite bounds are used for it.
-     */
-    cairo_warn cairo_bool_t
-    (*get_extents)		(void			 *surface,
-				 cairo_rectangle_int_t   *extents);
-
-    /*
-     * This is an optional entry to let the surface manage its own glyph
-     * resources. If null, render against this surface, using image
-     * surfaces as glyphs.
-     */
-    cairo_warn cairo_int_status_t
-    (*old_show_glyphs)		(cairo_scaled_font_t	        *font,
-				 cairo_operator_t		 op,
-				 const cairo_pattern_t		*pattern,
-				 void				*surface,
-				 int				 source_x,
-				 int				 source_y,
-				 int				 dest_x,
-				 int				 dest_y,
-				 unsigned int			 width,
-				 unsigned int			 height,
-				 cairo_glyph_t			*glyphs,
-				 int				 num_glyphs,
-				 cairo_region_t			*clip_region);
-
-    void
-    (*get_font_options)         (void                  *surface,
-				 cairo_font_options_t  *options);
-
-    cairo_warn cairo_status_t
-    (*flush)                    (void                  *surface);
-
-    cairo_warn cairo_status_t
-    (*mark_dirty_rectangle)     (void                  *surface,
-				 int                    x,
-				 int                    y,
-				 int                    width,
-				 int                    height);
-
-    void
-    (*scaled_font_fini)		(cairo_scaled_font_t   *scaled_font);
-
-    void
-    (*scaled_glyph_fini)	(cairo_scaled_glyph_t	*scaled_glyph,
-				 cairo_scaled_font_t	*scaled_font);
-
-    /* OK, I'm starting over somewhat by defining the 5 top-level
-     * drawing operators for the surface backend here with consistent
-     * naming and argument-order conventions. */
-    cairo_warn cairo_int_status_t
-    (*paint)			(void			*surface,
-				 cairo_operator_t	 op,
-				 const cairo_pattern_t	*source,
-				 cairo_clip_t		*clip);
-
-    cairo_warn cairo_int_status_t
-    (*mask)			(void			*surface,
-				 cairo_operator_t	 op,
-				 const cairo_pattern_t	*source,
-				 const cairo_pattern_t	*mask,
-				 cairo_clip_t		*clip);
-
-    cairo_warn cairo_int_status_t
-    (*stroke)			(void			*surface,
-				 cairo_operator_t	 op,
-				 const cairo_pattern_t	*source,
-				 cairo_path_fixed_t	*path,
-				 cairo_stroke_style_t	*style,
-				 cairo_matrix_t		*ctm,
-				 cairo_matrix_t		*ctm_inverse,
-				 double			 tolerance,
-				 cairo_antialias_t	 antialias,
-				 cairo_clip_t		*clip);
-
-    cairo_warn cairo_int_status_t
-    (*fill)			(void			*surface,
-				 cairo_operator_t	 op,
-				 const cairo_pattern_t	*source,
-				 cairo_path_fixed_t	*path,
-				 cairo_fill_rule_t	 fill_rule,
-				 double			 tolerance,
-				 cairo_antialias_t	 antialias,
-				 cairo_clip_t           *clip);
-
-    cairo_warn cairo_int_status_t
-    (*show_glyphs)		(void			*surface,
-				 cairo_operator_t	 op,
-				 const cairo_pattern_t	*source,
-				 cairo_glyph_t		*glyphs,
-				 int			 num_glyphs,
-				 cairo_scaled_font_t	*scaled_font,
-				 cairo_clip_t           *clip,
-				 int			*remaining_glyphs);
-
-    cairo_surface_t *
-    (*snapshot)			(void			*surface);
-
-    cairo_bool_t
-    (*is_similar)		(void			*surface_a,
-	                         void			*surface_b,
-				 cairo_content_t         content);
-
-    cairo_warn cairo_int_status_t
-    (*fill_stroke)		(void			*surface,
-				 cairo_operator_t	 fill_op,
-				 const cairo_pattern_t	*fill_source,
-				 cairo_fill_rule_t	 fill_rule,
-				 double			 fill_tolerance,
-				 cairo_antialias_t	 fill_antialias,
-				 cairo_path_fixed_t	*path,
-				 cairo_operator_t	 stroke_op,
-				 const cairo_pattern_t	*stroke_source,
-				 cairo_stroke_style_t	*stroke_style,
-				 cairo_matrix_t		*stroke_ctm,
-				 cairo_matrix_t		*stroke_ctm_inverse,
-				 double			 stroke_tolerance,
-				 cairo_antialias_t	 stroke_antialias,
-				 cairo_clip_t		*clip);
-
-    cairo_surface_t *
-    (*create_solid_pattern_surface)
-			        (void			      *surface,
-				 const cairo_solid_pattern_t  *solid_pattern);
-
-    cairo_bool_t
-    (*can_repaint_solid_pattern_surface)
-			        (void			      *surface,
-				 const cairo_solid_pattern_t  *solid_pattern);
-
-    cairo_bool_t
-    (*has_show_text_glyphs)	(void			    *surface);
-
-    cairo_warn cairo_int_status_t
-    (*show_text_glyphs)		(void			    *surface,
-				 cairo_operator_t	     op,
-				 const cairo_pattern_t	    *source,
-				 const char		    *utf8,
-				 int			     utf8_len,
-				 cairo_glyph_t		    *glyphs,
-				 int			     num_glyphs,
-				 const cairo_text_cluster_t *clusters,
-				 int			     num_clusters,
-				 cairo_text_cluster_flags_t  cluster_flags,
-				 cairo_scaled_font_t	    *scaled_font,
-				 cairo_clip_t               *clip);
-};
-
-#include "cairo-surface-private.h"
-
-struct _cairo_image_surface {
-    cairo_surface_t base;
-
-    pixman_format_code_t pixman_format;
-    cairo_format_t format;
-    unsigned char *data;
-
-    int width;
-    int height;
-    int stride;
-    int depth;
-
-    pixman_image_t *pixman_image;
-    cairo_region_t *clip_region;
-
-    unsigned owns_data : 1;
-    unsigned transparency : 2;
-};
-
-extern const cairo_private cairo_surface_backend_t _cairo_image_surface_backend;
-
-#define CAIRO_EXTEND_SURFACE_DEFAULT CAIRO_EXTEND_NONE
-#define CAIRO_EXTEND_GRADIENT_DEFAULT CAIRO_EXTEND_PAD
-#define CAIRO_FILTER_DEFAULT CAIRO_FILTER_GOOD
-
-extern const cairo_private cairo_solid_pattern_t _cairo_pattern_black;
-
-
-typedef struct _cairo_surface_attributes {
-    cairo_matrix_t matrix;
-    cairo_extend_t extend;
-    cairo_filter_t filter;
-    cairo_bool_t has_component_alpha;
-    int		   x_offset;
-    int		   y_offset;
-    void	   *extra;
-} cairo_surface_attributes_t;
-
-typedef struct _cairo_traps {
-    cairo_status_t status;
-
-    const cairo_box_t *limits;
-    int num_limits;
-
-    unsigned int maybe_region : 1; /* hint: 0 implies that it cannot be */
-    unsigned int has_intersections : 1;
-    unsigned int is_rectilinear : 1;
-    unsigned int is_rectangular : 1;
-
-    int num_traps;
-    int traps_size;
-    cairo_trapezoid_t *traps;
-    cairo_trapezoid_t  traps_embedded[16];
-} cairo_traps_t;
-
-#define CAIRO_FONT_SLANT_DEFAULT   CAIRO_FONT_SLANT_NORMAL
-#define CAIRO_FONT_WEIGHT_DEFAULT  CAIRO_FONT_WEIGHT_NORMAL
-
-#define CAIRO_WIN32_FONT_FAMILY_DEFAULT "Arial"
-#define CAIRO_QUARTZ_FONT_FAMILY_DEFAULT  "Helvetica"
-#define CAIRO_FT_FONT_FAMILY_DEFAULT     ""
-#define CAIRO_USER_FONT_FAMILY_DEFAULT     "@cairo:"
-
-#if   CAIRO_HAS_WIN32_FONT
-
-#define CAIRO_FONT_FAMILY_DEFAULT CAIRO_WIN32_FONT_FAMILY_DEFAULT
-#define CAIRO_FONT_FACE_BACKEND_DEFAULT &_cairo_win32_font_face_backend
-
-#elif CAIRO_HAS_QUARTZ_FONT
-
-#define CAIRO_FONT_FAMILY_DEFAULT CAIRO_QUARTZ_FONT_FAMILY_DEFAULT
-#define CAIRO_FONT_FACE_BACKEND_DEFAULT &_cairo_quartz_font_face_backend
-
-#elif CAIRO_HAS_FT_FONT
-
-#define CAIRO_FONT_FAMILY_DEFAULT CAIRO_FT_FONT_FAMILY_DEFAULT
-#define CAIRO_FONT_FACE_BACKEND_DEFAULT &_cairo_ft_font_face_backend
-
-#else
-
-#define CAIRO_FONT_FAMILY_DEFAULT CAIRO_FT_FONT_FAMILY_DEFAULT
-#define CAIRO_FONT_FACE_BACKEND_DEFAULT &_cairo_user_font_face_backend
-
-#endif
-
-#define CAIRO_GSTATE_OPERATOR_DEFAULT	CAIRO_OPERATOR_OVER
-#define CAIRO_GSTATE_TOLERANCE_DEFAULT	0.1
-#define CAIRO_GSTATE_FILL_RULE_DEFAULT	CAIRO_FILL_RULE_WINDING
-#define CAIRO_GSTATE_LINE_WIDTH_DEFAULT	2.0
-#define CAIRO_GSTATE_LINE_CAP_DEFAULT	CAIRO_LINE_CAP_BUTT
-#define CAIRO_GSTATE_LINE_JOIN_DEFAULT	CAIRO_LINE_JOIN_MITER
-#define CAIRO_GSTATE_MITER_LIMIT_DEFAULT	10.0
-#define CAIRO_GSTATE_DEFAULT_FONT_SIZE  10.0
-
-#define CAIRO_SURFACE_RESOLUTION_DEFAULT 72.0
-#define CAIRO_SURFACE_FALLBACK_RESOLUTION_DEFAULT 300.0
-
-typedef struct _cairo_stroke_face {
-    cairo_point_t ccw;
-    cairo_point_t point;
-    cairo_point_t cw;
-    cairo_slope_t dev_vector;
-    cairo_point_double_t usr_vector;
-} cairo_stroke_face_t;
-
-/* cairo.c */
-
-static inline double cairo_const
-_cairo_restrict_value (double value, double min, double max)
-{
-    if (value < min)
-	return min;
-    else if (value > max)
-	return max;
-    else
-	return value;
-}
-
-/* C99 round() rounds to the nearest integral value with halfway cases rounded
- * away from 0. _cairo_round rounds halfway cases toward negative infinity.
- * This matches the rounding behaviour of _cairo_lround. */
-static inline double cairo_const
-_cairo_round (double r)
-{
-    return floor (r + .5);
-}
-
-cairo_private int
-_cairo_lround (double d) cairo_const;
-
-/* cairo-gstate.c */
-cairo_private cairo_status_t
-_cairo_gstate_init (cairo_gstate_t  *gstate,
-		    cairo_surface_t *target);
-
-cairo_private void
-_cairo_gstate_fini (cairo_gstate_t *gstate);
-
-cairo_private cairo_status_t
-_cairo_gstate_save (cairo_gstate_t **gstate, cairo_gstate_t **freelist);
-
-cairo_private cairo_status_t
-_cairo_gstate_restore (cairo_gstate_t **gstate, cairo_gstate_t **freelist);
-
-cairo_private cairo_bool_t
-_cairo_gstate_is_redirected (cairo_gstate_t *gstate);
-
-cairo_private cairo_status_t
-_cairo_gstate_redirect_target (cairo_gstate_t *gstate, cairo_surface_t *child);
-
-cairo_private cairo_surface_t *
-_cairo_gstate_get_target (cairo_gstate_t *gstate);
-
-cairo_private cairo_surface_t *
-_cairo_gstate_get_parent_target (cairo_gstate_t *gstate);
-
-cairo_private cairo_surface_t *
-_cairo_gstate_get_original_target (cairo_gstate_t *gstate);
-
-cairo_private cairo_clip_t *
-_cairo_gstate_get_clip (cairo_gstate_t *gstate);
-
-cairo_private cairo_status_t
-_cairo_gstate_set_source (cairo_gstate_t *gstate, cairo_pattern_t *source);
-
-cairo_private cairo_pattern_t *
-_cairo_gstate_get_source (cairo_gstate_t *gstate);
-
-cairo_private cairo_status_t
-_cairo_gstate_set_operator (cairo_gstate_t *gstate, cairo_operator_t op);
-
-cairo_private cairo_operator_t
-_cairo_gstate_get_operator (cairo_gstate_t *gstate);
-
-cairo_private cairo_status_t
-_cairo_gstate_set_tolerance (cairo_gstate_t *gstate, double tolerance);
-
-cairo_private double
-_cairo_gstate_get_tolerance (cairo_gstate_t *gstate);
-
-cairo_private cairo_status_t
-_cairo_gstate_set_fill_rule (cairo_gstate_t *gstate, cairo_fill_rule_t fill_rule);
-
-cairo_private cairo_fill_rule_t
-_cairo_gstate_get_fill_rule (cairo_gstate_t *gstate);
-
-cairo_private cairo_status_t
-_cairo_gstate_set_line_width (cairo_gstate_t *gstate, double width);
-
-cairo_private double
-_cairo_gstate_get_line_width (cairo_gstate_t *gstate);
-
-cairo_private cairo_status_t
-_cairo_gstate_set_line_cap (cairo_gstate_t *gstate, cairo_line_cap_t line_cap);
-
-cairo_private cairo_line_cap_t
-_cairo_gstate_get_line_cap (cairo_gstate_t *gstate);
-
-cairo_private cairo_status_t
-_cairo_gstate_set_line_join (cairo_gstate_t *gstate, cairo_line_join_t line_join);
-
-cairo_private cairo_line_join_t
-_cairo_gstate_get_line_join (cairo_gstate_t *gstate);
-
-cairo_private cairo_status_t
-_cairo_gstate_set_dash (cairo_gstate_t *gstate, const double *dash, int num_dashes, double offset);
-
-cairo_private void
-_cairo_gstate_get_dash (cairo_gstate_t *gstate, double *dash, int *num_dashes, double *offset);
-
-cairo_private cairo_status_t
-_cairo_gstate_set_miter_limit (cairo_gstate_t *gstate, double limit);
-
-cairo_private double
-_cairo_gstate_get_miter_limit (cairo_gstate_t *gstate);
-
-cairo_private void
-_cairo_gstate_get_matrix (cairo_gstate_t *gstate, cairo_matrix_t *matrix);
-
-cairo_private cairo_status_t
-_cairo_gstate_translate (cairo_gstate_t *gstate, double tx, double ty);
-
-cairo_private cairo_status_t
-_cairo_gstate_scale (cairo_gstate_t *gstate, double sx, double sy);
-
-cairo_private cairo_status_t
-_cairo_gstate_rotate (cairo_gstate_t *gstate, double angle);
-
-cairo_private cairo_status_t
-_cairo_gstate_transform (cairo_gstate_t	      *gstate,
-			 const cairo_matrix_t *matrix);
-
-cairo_private cairo_status_t
-_cairo_gstate_set_matrix (cairo_gstate_t       *gstate,
-			  const cairo_matrix_t *matrix);
-
-cairo_private void
-_cairo_gstate_identity_matrix (cairo_gstate_t *gstate);
-
-cairo_private void
-_cairo_gstate_user_to_device (cairo_gstate_t *gstate, double *x, double *y);
-
-cairo_private void
-_cairo_gstate_user_to_device_distance (cairo_gstate_t *gstate, double *dx, double *dy);
-
-cairo_private void
-_cairo_gstate_device_to_user (cairo_gstate_t *gstate, double *x, double *y);
-
-cairo_private void
-_cairo_gstate_device_to_user_distance (cairo_gstate_t *gstate, double *dx, double *dy);
-
-cairo_private void
-_cairo_gstate_user_to_backend (cairo_gstate_t *gstate, double *x, double *y);
-
-cairo_private void
-_cairo_gstate_backend_to_user (cairo_gstate_t *gstate, double *x, double *y);
-
-cairo_private void
-_cairo_gstate_backend_to_user_rectangle (cairo_gstate_t *gstate,
-                                         double *x1, double *y1,
-                                         double *x2, double *y2,
-                                         cairo_bool_t *is_tight);
-
-cairo_private void
-_cairo_gstate_path_extents (cairo_gstate_t     *gstate,
-			    cairo_path_fixed_t *path,
-			    double *x1, double *y1,
-			    double *x2, double *y2);
-
-cairo_private cairo_status_t
-_cairo_gstate_paint (cairo_gstate_t *gstate);
-
-cairo_private cairo_status_t
-_cairo_gstate_mask (cairo_gstate_t  *gstate,
-		    cairo_pattern_t *mask);
-
-cairo_private cairo_status_t
-_cairo_gstate_stroke (cairo_gstate_t *gstate, cairo_path_fixed_t *path);
-
-cairo_private cairo_status_t
-_cairo_gstate_fill (cairo_gstate_t *gstate, cairo_path_fixed_t *path);
-
-cairo_private cairo_status_t
-_cairo_gstate_copy_page (cairo_gstate_t *gstate);
-
-cairo_private cairo_status_t
-_cairo_gstate_show_page (cairo_gstate_t *gstate);
-
-cairo_private cairo_status_t
-_cairo_gstate_stroke_extents (cairo_gstate_t	 *gstate,
-			      cairo_path_fixed_t *path,
-                              double *x1, double *y1,
-			      double *x2, double *y2);
-
-cairo_private cairo_status_t
-_cairo_gstate_fill_extents (cairo_gstate_t     *gstate,
-			    cairo_path_fixed_t *path,
-                            double *x1, double *y1,
-			    double *x2, double *y2);
-
-cairo_private cairo_status_t
-_cairo_gstate_in_stroke (cairo_gstate_t	    *gstate,
-			 cairo_path_fixed_t *path,
-			 double		     x,
-			 double		     y,
-			 cairo_bool_t	    *inside_ret);
-
-cairo_private cairo_bool_t
-_cairo_gstate_in_fill (cairo_gstate_t	  *gstate,
-		       cairo_path_fixed_t *path,
-		       double		   x,
-		       double		   y);
-
-cairo_private cairo_bool_t
-_cairo_gstate_in_clip (cairo_gstate_t	  *gstate,
-		       double		   x,
-		       double		   y);
-
-cairo_private cairo_status_t
-_cairo_gstate_clip (cairo_gstate_t *gstate, cairo_path_fixed_t *path);
-
-cairo_private cairo_status_t
-_cairo_gstate_reset_clip (cairo_gstate_t *gstate);
-
-cairo_private cairo_bool_t
-_cairo_gstate_clip_extents (cairo_gstate_t *gstate,
-		            double         *x1,
-		            double         *y1,
-			    double         *x2,
-			    double         *y2);
-
-cairo_private cairo_rectangle_list_t*
-_cairo_gstate_copy_clip_rectangle_list (cairo_gstate_t *gstate);
-
-cairo_private cairo_status_t
-_cairo_gstate_show_surface (cairo_gstate_t	*gstate,
-			    cairo_surface_t	*surface,
-			    double		 x,
-			    double		 y,
-			    double		width,
-			    double		height);
-
-cairo_private cairo_status_t
-_cairo_gstate_select_font_face (cairo_gstate_t *gstate,
-				const char *family,
-				cairo_font_slant_t slant,
-				cairo_font_weight_t weight);
-
-cairo_private cairo_status_t
-_cairo_gstate_set_font_size (cairo_gstate_t *gstate,
-			     double          size);
-
-cairo_private void
-_cairo_gstate_get_font_matrix (cairo_gstate_t *gstate,
-			       cairo_matrix_t *matrix);
-
-cairo_private cairo_status_t
-_cairo_gstate_set_font_matrix (cairo_gstate_t	    *gstate,
-			       const cairo_matrix_t *matrix);
-
-cairo_private void
-_cairo_gstate_get_font_options (cairo_gstate_t       *gstate,
-				cairo_font_options_t *options);
-
-cairo_private void
-_cairo_gstate_set_font_options (cairo_gstate_t	           *gstate,
-				const cairo_font_options_t *options);
-
-cairo_private cairo_status_t
-_cairo_gstate_get_font_face (cairo_gstate_t     *gstate,
-			     cairo_font_face_t **font_face);
-
-cairo_private cairo_status_t
-_cairo_gstate_get_scaled_font (cairo_gstate_t       *gstate,
-			       cairo_scaled_font_t **scaled_font);
-
-cairo_private cairo_status_t
-_cairo_gstate_get_font_extents (cairo_gstate_t *gstate,
-				cairo_font_extents_t *extents);
-
-cairo_private cairo_status_t
-_cairo_gstate_set_font_face (cairo_gstate_t    *gstate,
-			     cairo_font_face_t *font_face);
-
-cairo_private cairo_status_t
-_cairo_gstate_text_to_glyphs (cairo_gstate_t	         *gstate,
-			      double		          x,
-			      double		          y,
-			      const char	         *utf8,
-			      int		          utf8_len,
-			      cairo_glyph_t	        **glyphs,
-			      int		         *num_glyphs,
-			      cairo_text_cluster_t      **clusters,
-			      int		         *num_clusters,
-			      cairo_text_cluster_flags_t *cluster_flags);
-
-cairo_private cairo_status_t
-_cairo_gstate_glyph_extents (cairo_gstate_t *gstate,
-			     const cairo_glyph_t *glyphs,
-			     int num_glyphs,
-			     cairo_text_extents_t *extents);
-
-cairo_private cairo_status_t
-_cairo_gstate_show_text_glyphs (cairo_gstate_t		   *gstate,
-				const char		   *utf8,
-				int			    utf8_len,
-				const cairo_glyph_t	   *glyphs,
-				int			    num_glyphs,
-				const cairo_text_cluster_t *clusters,
-				int			    num_clusters,
-			        cairo_text_cluster_flags_t  cluster_flags);
-
-cairo_private cairo_status_t
-_cairo_gstate_glyph_path (cairo_gstate_t      *gstate,
-			  const cairo_glyph_t *glyphs,
-			  int		       num_glyphs,
-			  cairo_path_fixed_t  *path);
-
-cairo_private cairo_status_t
-_cairo_gstate_set_antialias (cairo_gstate_t *gstate,
-			     cairo_antialias_t antialias);
-
-cairo_private cairo_antialias_t
-_cairo_gstate_get_antialias (cairo_gstate_t *gstate);
-
-cairo_private cairo_bool_t
-_cairo_operator_bounded_by_mask (cairo_operator_t op) cairo_const;
-
-cairo_private cairo_bool_t
-_cairo_operator_bounded_by_source (cairo_operator_t op) cairo_const;
-
-/* cairo-color.c */
-cairo_private const cairo_color_t *
-_cairo_stock_color (cairo_stock_t stock) cairo_pure;
-
-#define CAIRO_COLOR_WHITE       _cairo_stock_color (CAIRO_STOCK_WHITE)
-#define CAIRO_COLOR_BLACK       _cairo_stock_color (CAIRO_STOCK_BLACK)
-#define CAIRO_COLOR_TRANSPARENT _cairo_stock_color (CAIRO_STOCK_TRANSPARENT)
-
-cairo_private uint16_t
-_cairo_color_double_to_short (double d) cairo_const;
-
-cairo_private void
-_cairo_color_init (cairo_color_t *color);
-
-cairo_private void
-_cairo_color_init_rgb (cairo_color_t *color,
-		       double red, double green, double blue);
-
-cairo_private void
-_cairo_color_init_rgba (cairo_color_t *color,
-			double red, double green, double blue,
-			double alpha);
-
-cairo_private void
-_cairo_color_multiply_alpha (cairo_color_t *color,
-			     double	    alpha);
-
-cairo_private void
-_cairo_color_get_rgba (cairo_color_t *color,
-		       double	     *red,
-		       double	     *green,
-		       double	     *blue,
-		       double	     *alpha);
-
-cairo_private void
-_cairo_color_get_rgba_premultiplied (cairo_color_t *color,
-				     double	   *red,
-				     double	   *green,
-				     double	   *blue,
-				     double	   *alpha);
-
-cairo_private cairo_bool_t
-_cairo_color_equal (const cairo_color_t *color_a,
-                    const cairo_color_t *color_b) cairo_pure;
-
-/* cairo-font-face.c */
-
-extern const cairo_private cairo_font_face_t _cairo_font_face_nil;
-
-cairo_private void
-_cairo_font_face_init (cairo_font_face_t               *font_face,
-		       const cairo_font_face_backend_t *backend);
-
-cairo_private cairo_status_t
-_cairo_font_face_set_error (cairo_font_face_t *font_face,
-	                    cairo_status_t     status);
-
-cairo_private void
-_cairo_unscaled_font_init (cairo_unscaled_font_t               *font,
-			   const cairo_unscaled_font_backend_t *backend);
-
-cairo_private_no_warn cairo_unscaled_font_t *
-_cairo_unscaled_font_reference (cairo_unscaled_font_t *font);
-
-cairo_private void
-_cairo_unscaled_font_destroy (cairo_unscaled_font_t *font);
-
-/* cairo-font-face-twin.c */
-
-cairo_private cairo_font_face_t *
-_cairo_font_face_twin_create_fallback (void);
-
-cairo_private cairo_status_t
-_cairo_font_face_twin_create_for_toy (cairo_toy_font_face_t   *toy_face,
-				      cairo_font_face_t      **font_face);
-
-/* cairo-font-face-twin-data.c */
-
-extern const cairo_private int8_t _cairo_twin_outlines[];
-extern const cairo_private uint16_t _cairo_twin_charmap[128];
-
-/* cairo-font-options.c */
-
-cairo_private void
-_cairo_font_options_init_default (cairo_font_options_t *options);
-
-cairo_private void
-_cairo_font_options_init_copy (cairo_font_options_t		*options,
-			       const cairo_font_options_t	*other);
-
-/* cairo-hull.c */
-cairo_private cairo_status_t
-_cairo_hull_compute (cairo_pen_vertex_t *vertices, int *num_vertices);
-
-/* cairo-lzw.c */
-cairo_private unsigned char *
-_cairo_lzw_compress (unsigned char *data, unsigned long *size_in_out);
-
-/* cairo-misc.c */
-cairo_private cairo_status_t
-_cairo_validate_text_clusters (const char		   *utf8,
-			       int			    utf8_len,
-			       const cairo_glyph_t	   *glyphs,
-			       int			    num_glyphs,
-			       const cairo_text_cluster_t  *clusters,
-			       int			    num_clusters,
-			       cairo_text_cluster_flags_t   cluster_flags);
-
-cairo_private cairo_status_t
-_cairo_intern_string (const char **str_inout, int len);
-
-cairo_private void
-_cairo_intern_string_reset_static_data (void);
-
-/* cairo-path-fixed.c */
-cairo_private cairo_path_fixed_t *
-_cairo_path_fixed_create (void);
-
-cairo_private void
-_cairo_path_fixed_init (cairo_path_fixed_t *path);
-
-cairo_private cairo_status_t
-_cairo_path_fixed_init_copy (cairo_path_fixed_t *path,
-			     const cairo_path_fixed_t *other);
-
-cairo_private cairo_bool_t
-_cairo_path_fixed_is_equal (const cairo_path_fixed_t *path,
-			    const cairo_path_fixed_t *other);
-
-cairo_private void
-_cairo_path_fixed_fini (cairo_path_fixed_t *path);
-
-cairo_private void
-_cairo_path_fixed_destroy (cairo_path_fixed_t *path);
-
-cairo_private cairo_status_t
-_cairo_path_fixed_move_to (cairo_path_fixed_t  *path,
-			   cairo_fixed_t	x,
-			   cairo_fixed_t	y);
-
-cairo_private void
-_cairo_path_fixed_new_sub_path (cairo_path_fixed_t *path);
-
-cairo_private cairo_status_t
-_cairo_path_fixed_rel_move_to (cairo_path_fixed_t *path,
-			       cairo_fixed_t	   dx,
-			       cairo_fixed_t	   dy);
-
-cairo_private cairo_status_t
-_cairo_path_fixed_line_to (cairo_path_fixed_t *path,
-			   cairo_fixed_t	x,
-			   cairo_fixed_t	y);
-
-cairo_private cairo_status_t
-_cairo_path_fixed_rel_line_to (cairo_path_fixed_t *path,
-			       cairo_fixed_t	   dx,
-			       cairo_fixed_t	   dy);
-
-cairo_private cairo_status_t
-_cairo_path_fixed_curve_to (cairo_path_fixed_t	*path,
-			    cairo_fixed_t x0, cairo_fixed_t y0,
-			    cairo_fixed_t x1, cairo_fixed_t y1,
-			    cairo_fixed_t x2, cairo_fixed_t y2);
-
-cairo_private cairo_status_t
-_cairo_path_fixed_rel_curve_to (cairo_path_fixed_t *path,
-				cairo_fixed_t dx0, cairo_fixed_t dy0,
-				cairo_fixed_t dx1, cairo_fixed_t dy1,
-				cairo_fixed_t dx2, cairo_fixed_t dy2);
-
-cairo_private cairo_status_t
-_cairo_path_fixed_close_path (cairo_path_fixed_t *path);
-
-cairo_private cairo_bool_t
-_cairo_path_fixed_get_current_point (cairo_path_fixed_t *path,
-				     cairo_fixed_t	*x,
-				     cairo_fixed_t	*y);
-
-typedef cairo_status_t
-(cairo_path_fixed_move_to_func_t) (void		 *closure,
-				   const cairo_point_t *point);
-
-typedef cairo_status_t
-(cairo_path_fixed_line_to_func_t) (void		 *closure,
-				   const cairo_point_t *point);
-
-typedef cairo_status_t
-(cairo_path_fixed_curve_to_func_t) (void	  *closure,
-				    const cairo_point_t *p0,
-				    const cairo_point_t *p1,
-				    const cairo_point_t *p2);
-
-typedef cairo_status_t
-(cairo_path_fixed_close_path_func_t) (void *closure);
-
-cairo_private cairo_status_t
-_cairo_path_fixed_interpret (const cairo_path_fixed_t	  *path,
-		       cairo_direction_t		   dir,
-		       cairo_path_fixed_move_to_func_t	  *move_to,
-		       cairo_path_fixed_line_to_func_t	  *line_to,
-		       cairo_path_fixed_curve_to_func_t	  *curve_to,
-		       cairo_path_fixed_close_path_func_t *close_path,
-		       void				  *closure);
-
-cairo_private cairo_status_t
-_cairo_path_fixed_interpret_flat (const cairo_path_fixed_t *path,
-		       cairo_direction_t		   dir,
-		       cairo_path_fixed_move_to_func_t	  *move_to,
-		       cairo_path_fixed_line_to_func_t	  *line_to,
-		       cairo_path_fixed_close_path_func_t *close_path,
-		       void				  *closure,
-		       double				  tolerance);
-
-cairo_private void
-_cairo_path_fixed_approximate_clip_extents (const cairo_path_fixed_t	*path,
-					    cairo_rectangle_int_t *extents);
-
-cairo_private void
-_cairo_path_fixed_approximate_fill_extents (const cairo_path_fixed_t *path,
-					    cairo_rectangle_int_t *extents);
-
-cairo_private void
-_cairo_path_fixed_fill_extents (const cairo_path_fixed_t	*path,
-				cairo_fill_rule_t	 fill_rule,
-				double			 tolerance,
-				cairo_rectangle_int_t	*extents);
-
-cairo_private void
-_cairo_path_fixed_approximate_stroke_extents (const cairo_path_fixed_t *path,
-					      cairo_stroke_style_t *style,
-					      const cairo_matrix_t *ctm,
-					      cairo_rectangle_int_t *extents);
-
-cairo_private cairo_status_t
-_cairo_path_fixed_stroke_extents (const cairo_path_fixed_t *path,
-				  cairo_stroke_style_t *style,
-				  const cairo_matrix_t *ctm,
-				  const cairo_matrix_t *ctm_inverse,
-				  double tolerance,
-				  cairo_rectangle_int_t *extents);
-
-cairo_private void
-_cairo_path_fixed_bounds (const cairo_path_fixed_t *path,
-			  double *x1, double *y1,
-			  double *x2, double *y2);
-
-cairo_private void
-_cairo_path_fixed_transform (cairo_path_fixed_t	*path,
-			     const cairo_matrix_t	*matrix);
-
-cairo_private cairo_bool_t
-_cairo_path_fixed_is_box (const cairo_path_fixed_t *path,
-                          cairo_box_t *box);
-
-cairo_private cairo_bool_t
-_cairo_path_fixed_is_rectangle (const cairo_path_fixed_t *path,
-				cairo_box_t        *box);
-
-/* cairo-path-in-fill.c */
-cairo_private cairo_bool_t
-_cairo_path_fixed_in_fill (const cairo_path_fixed_t	*path,
-			   cairo_fill_rule_t	 fill_rule,
-			   double		 tolerance,
-			   double		 x,
-			   double		 y);
-
-/* cairo-path-fill.c */
-cairo_private cairo_status_t
-_cairo_path_fixed_fill_to_polygon (const cairo_path_fixed_t *path,
-				   double              tolerance,
-				   cairo_polygon_t      *polygon);
-
-cairo_private cairo_int_status_t
-_cairo_path_fixed_fill_rectilinear_to_traps (const cairo_path_fixed_t *path,
-					     cairo_fill_rule_t fill_rule,
-					     cairo_traps_t *traps);
-
-cairo_private cairo_region_t *
-_cairo_path_fixed_fill_rectilinear_to_region (const cairo_path_fixed_t	*path,
-					      cairo_fill_rule_t	 fill_rule,
-					      const cairo_rectangle_int_t *extents);
-
-cairo_private cairo_status_t
-_cairo_path_fixed_fill_to_traps (const cairo_path_fixed_t   *path,
-				 cairo_fill_rule_t	     fill_rule,
-				 double			     tolerance,
-				 cairo_traps_t		    *traps);
-
-/* cairo-path-stroke.c */
-cairo_private cairo_status_t
-_cairo_path_fixed_stroke_to_polygon (const cairo_path_fixed_t	*path,
-				     cairo_stroke_style_t	*stroke_style,
-				     const cairo_matrix_t	*ctm,
-				     const cairo_matrix_t	*ctm_inverse,
-				     double		 tolerance,
-				     cairo_polygon_t	*polygon);
-
-cairo_private cairo_int_status_t
-_cairo_path_fixed_stroke_rectilinear_to_traps (const cairo_path_fixed_t	*path,
-					       cairo_stroke_style_t	*stroke_style,
-					       const cairo_matrix_t	*ctm,
-					       cairo_traps_t		*traps);
-cairo_private cairo_status_t
-_cairo_path_fixed_stroke_to_traps (const cairo_path_fixed_t	*path,
-				   cairo_stroke_style_t	*stroke_style,
-				   const cairo_matrix_t	*ctm,
-				   const cairo_matrix_t	*ctm_inverse,
-				   double		 tolerance,
-				   cairo_traps_t	*traps);
-
-cairo_private cairo_status_t
-_cairo_path_fixed_stroke_to_shaper (cairo_path_fixed_t	*path,
-				   cairo_stroke_style_t	*stroke_style,
-				   cairo_matrix_t	*ctm,
-				   cairo_matrix_t	*ctm_inverse,
-				   double		 tolerance,
-				   cairo_status_t (*add_triangle) (void *closure,
-								   const cairo_point_t triangle[3]),
-				   cairo_status_t (*add_triangle_fan) (void *closure,
-								       const cairo_point_t *midpt,
-								       const cairo_point_t *points,
-								       int npoints),
-				   cairo_status_t (*add_quad) (void *closure,
-							       const cairo_point_t quad[4]),
-				   void *closure);
-
-/* cairo-scaled-font.c */
-
-cairo_private void
-_cairo_scaled_font_freeze_cache (cairo_scaled_font_t *scaled_font);
-
-cairo_private void
-_cairo_scaled_font_thaw_cache (cairo_scaled_font_t *scaled_font);
-
-cairo_private void
-_cairo_scaled_font_reset_cache (cairo_scaled_font_t *scaled_font);
-
-cairo_private cairo_status_t
-_cairo_scaled_font_set_error (cairo_scaled_font_t *scaled_font,
-			      cairo_status_t status);
-
-cairo_private cairo_scaled_font_t *
-_cairo_scaled_font_create_in_error (cairo_status_t status);
-
-cairo_private void
-_cairo_scaled_font_reset_static_data (void);
-
-cairo_private cairo_status_t
-_cairo_scaled_font_register_placeholder_and_unlock_font_map (cairo_scaled_font_t *scaled_font);
-
-cairo_private void
-_cairo_scaled_font_unregister_placeholder_and_lock_font_map (cairo_scaled_font_t *scaled_font);
-
-cairo_private cairo_status_t
-_cairo_scaled_font_init (cairo_scaled_font_t               *scaled_font,
-			 cairo_font_face_t		   *font_face,
-			 const cairo_matrix_t              *font_matrix,
-			 const cairo_matrix_t              *ctm,
-			 const cairo_font_options_t	   *options,
-			 const cairo_scaled_font_backend_t *backend);
-
-cairo_private cairo_status_t
-_cairo_scaled_font_set_metrics (cairo_scaled_font_t	    *scaled_font,
-				cairo_font_extents_t	    *fs_metrics);
-
-/* This should only be called on an error path by a scaled_font constructor */
-cairo_private void
-_cairo_scaled_font_fini (cairo_scaled_font_t *scaled_font);
-
-cairo_private cairo_status_t
-_cairo_scaled_font_font_extents (cairo_scaled_font_t  *scaled_font,
-				 cairo_font_extents_t *extents);
-
-cairo_private cairo_status_t
-_cairo_scaled_font_glyph_device_extents (cairo_scaled_font_t	 *scaled_font,
-					 const cairo_glyph_t	 *glyphs,
-					 int                      num_glyphs,
-					 cairo_rectangle_int_t   *extents,
-					 cairo_bool_t		 *overlap);
-
-cairo_private void
-_cairo_scaled_font_glyph_approximate_extents (cairo_scaled_font_t	 *scaled_font,
-					      const cairo_glyph_t	 *glyphs,
-					      int                      num_glyphs,
-					      cairo_rectangle_int_t   *extents);
-
-cairo_private cairo_status_t
-_cairo_scaled_font_show_glyphs (cairo_scaled_font_t *scaled_font,
-				cairo_operator_t     op,
-				const cairo_pattern_t *source,
-				cairo_surface_t	    *surface,
-				int		     source_x,
-				int		     source_y,
-				int		     dest_x,
-				int		     dest_y,
-				unsigned int	     width,
-				unsigned int	     height,
-				cairo_glyph_t	    *glyphs,
-				int		     num_glyphs,
-				cairo_region_t	    *clip_region);
-
-cairo_private cairo_status_t
-_cairo_scaled_font_glyph_path (cairo_scaled_font_t *scaled_font,
-			       const cairo_glyph_t *glyphs,
-			       int                  num_glyphs,
-			       cairo_path_fixed_t  *path);
-
-cairo_private void
-_cairo_scaled_glyph_set_metrics (cairo_scaled_glyph_t *scaled_glyph,
-				 cairo_scaled_font_t *scaled_font,
-				 cairo_text_extents_t *fs_metrics);
-
-cairo_private void
-_cairo_scaled_glyph_set_surface (cairo_scaled_glyph_t *scaled_glyph,
-				 cairo_scaled_font_t *scaled_font,
-				 cairo_image_surface_t *surface);
-
-cairo_private void
-_cairo_scaled_glyph_set_path (cairo_scaled_glyph_t *scaled_glyph,
-			      cairo_scaled_font_t *scaled_font,
-			      cairo_path_fixed_t *path);
-
-cairo_private void
-_cairo_scaled_glyph_set_recording_surface (cairo_scaled_glyph_t *scaled_glyph,
-                                           cairo_scaled_font_t *scaled_font,
-                                           cairo_surface_t *recording_surface);
-
-cairo_private cairo_int_status_t
-_cairo_scaled_glyph_lookup (cairo_scaled_font_t *scaled_font,
-			    unsigned long index,
-			    cairo_scaled_glyph_info_t info,
-			    cairo_scaled_glyph_t **scaled_glyph_ret);
-
-cairo_private double
-_cairo_scaled_font_get_max_scale (cairo_scaled_font_t *scaled_font);
-
-cairo_private void
-_cairo_scaled_font_map_destroy (void);
-
-/* cairo-stroke-style.c */
-
-cairo_private void
-_cairo_stroke_style_init (cairo_stroke_style_t *style);
-
-cairo_private cairo_status_t
-_cairo_stroke_style_init_copy (cairo_stroke_style_t *style,
-			       cairo_stroke_style_t *other);
-
-cairo_private void
-_cairo_stroke_style_fini (cairo_stroke_style_t *style);
-
-cairo_private void
-_cairo_stroke_style_max_distance_from_path (const cairo_stroke_style_t *style,
-                                            const cairo_matrix_t *ctm,
-                                            double *dx, double *dy);
-
-/* cairo-surface.c */
-
-cairo_private cairo_surface_t *
-_cairo_surface_create_in_error (cairo_status_t status);
-
-cairo_private cairo_status_t
-_cairo_surface_copy_mime_data (cairo_surface_t *dst,
-			       cairo_surface_t *src);
-
-cairo_private cairo_status_t
-_cairo_surface_set_error (cairo_surface_t	*surface,
-			  cairo_status_t	 status);
-
-cairo_private void
-_cairo_surface_set_resolution (cairo_surface_t *surface,
-                               double x_res,
-                               double y_res);
-
-cairo_private cairo_surface_t *
-_cairo_surface_create_similar_scratch (cairo_surface_t *other,
-				       cairo_content_t	content,
-				       int		width,
-				       int		height);
-
-cairo_private cairo_surface_t *
-_cairo_surface_create_similar_solid (cairo_surface_t	    *other,
-				     cairo_content_t	     content,
-				     int		     width,
-				     int		     height,
-				     const cairo_color_t    *color,
-				     cairo_bool_t	     allow_fallback);
-
-cairo_private cairo_surface_t *
-_cairo_surface_create_solid_pattern_surface (cairo_surface_t	   *other,
-					     const cairo_solid_pattern_t *solid_pattern);
-
-cairo_private cairo_int_status_t
-_cairo_surface_repaint_solid_pattern_surface (cairo_surface_t	    *other,
-					      cairo_surface_t       *solid_surface,
-					      const cairo_solid_pattern_t *solid_pattern);
-
-cairo_private void
-_cairo_surface_init (cairo_surface_t			*surface,
-		     const cairo_surface_backend_t	*backend,
-		     cairo_content_t			 content);
-
-cairo_private void
-_cairo_surface_set_font_options (cairo_surface_t       *surface,
-				 cairo_font_options_t  *options);
-
-cairo_private cairo_status_t
-_cairo_surface_composite (cairo_operator_t	op,
-			  const cairo_pattern_t	*src,
-			  const cairo_pattern_t	*mask,
-			  cairo_surface_t	*dst,
-			  int			 src_x,
-			  int			 src_y,
-			  int			 mask_x,
-			  int			 mask_y,
-			  int			 dst_x,
-			  int			 dst_y,
-			  unsigned int		 width,
-			  unsigned int		 height,
-			  cairo_region_t	*clip_region);
-
-cairo_private cairo_status_t
-_cairo_surface_fill_rectangle (cairo_surface_t	   *surface,
-			       cairo_operator_t	    op,
-			       const cairo_color_t *color,
-			       int		    x,
-			       int		    y,
-			       int		    width,
-			       int		    height);
-
-cairo_private cairo_status_t
-_cairo_surface_fill_region (cairo_surface_t	   *surface,
-			    cairo_operator_t	    op,
-			    const cairo_color_t    *color,
-			    cairo_region_t         *region);
-
-cairo_private cairo_status_t
-_cairo_surface_fill_rectangles (cairo_surface_t		*surface,
-				cairo_operator_t         op,
-				const cairo_color_t	*color,
-				cairo_rectangle_int_t	*rects,
-				int			 num_rects);
-
-cairo_private cairo_status_t
-_cairo_surface_paint (cairo_surface_t	*surface,
-		      cairo_operator_t	 op,
-		      const cairo_pattern_t *source,
-		      cairo_clip_t	    *clip);
-
-cairo_private cairo_status_t
-_cairo_surface_mask (cairo_surface_t	*surface,
-		     cairo_operator_t	 op,
-		     const cairo_pattern_t	*source,
-		     const cairo_pattern_t	*mask,
-		     cairo_clip_t		*clip);
-
-cairo_private cairo_status_t
-_cairo_surface_fill_stroke (cairo_surface_t	    *surface,
-			    cairo_operator_t	     fill_op,
-			    const cairo_pattern_t   *fill_source,
-			    cairo_fill_rule_t	     fill_rule,
-			    double		     fill_tolerance,
-			    cairo_antialias_t	     fill_antialias,
-			    cairo_path_fixed_t	    *path,
-			    cairo_operator_t	     stroke_op,
-			    const cairo_pattern_t   *stroke_source,
-			    cairo_stroke_style_t    *stroke_style,
-			    cairo_matrix_t	    *stroke_ctm,
-			    cairo_matrix_t	    *stroke_ctm_inverse,
-			    double		     stroke_tolerance,
-			    cairo_antialias_t	     stroke_antialias,
-			    cairo_clip_t	    *clip);
-
-cairo_private cairo_status_t
-_cairo_surface_stroke (cairo_surface_t		*surface,
-		       cairo_operator_t		 op,
-		       const cairo_pattern_t	*source,
-		       cairo_path_fixed_t	*path,
-		       cairo_stroke_style_t	*style,
-		       cairo_matrix_t		*ctm,
-		       cairo_matrix_t		*ctm_inverse,
-		       double			 tolerance,
-		       cairo_antialias_t	 antialias,
-		       cairo_clip_t		*clip);
-
-cairo_private cairo_status_t
-_cairo_surface_fill (cairo_surface_t	*surface,
-		     cairo_operator_t	 op,
-		     const cairo_pattern_t *source,
-		     cairo_path_fixed_t	*path,
-		     cairo_fill_rule_t	 fill_rule,
-		     double		 tolerance,
-		     cairo_antialias_t	 antialias,
-		     cairo_clip_t	*clip);
-
-cairo_private cairo_status_t
-_cairo_surface_show_text_glyphs (cairo_surface_t	    *surface,
-				 cairo_operator_t	     op,
-				 const cairo_pattern_t	    *source,
-				 const char		    *utf8,
-				 int			     utf8_len,
-				 cairo_glyph_t		    *glyphs,
-				 int			     num_glyphs,
-				 const cairo_text_cluster_t *clusters,
-				 int			     num_clusters,
-				 cairo_text_cluster_flags_t  cluster_flags,
-				 cairo_scaled_font_t	    *scaled_font,
-				 cairo_clip_t		    *clip);
-
-cairo_private cairo_status_t
-_cairo_surface_paint_extents (cairo_surface_t *surface,
-			      cairo_operator_t		op,
-			      const cairo_pattern_t	*source,
-			      cairo_clip_t		*clip,
-			      cairo_rectangle_int_t	*extents);
-
-cairo_private cairo_status_t
-_cairo_surface_mask_extents (cairo_surface_t *surface,
-			     cairo_operator_t		 op,
-			     const cairo_pattern_t	*source,
-			     const cairo_pattern_t	*mask,
-			     cairo_clip_t		*clip,
-			     cairo_rectangle_int_t	*extents);
-
-cairo_private cairo_status_t
-_cairo_surface_stroke_extents (cairo_surface_t *surface,
-			       cairo_operator_t op,
-			       const cairo_pattern_t *source,
-			       cairo_path_fixed_t	*path,
-			       cairo_stroke_style_t *style,
-			       const cairo_matrix_t *ctm,
-			       const cairo_matrix_t *ctm_inverse,
-			       double tolerance,
-			       cairo_antialias_t	 antialias,
-			       cairo_clip_t *clip,
-			       cairo_rectangle_int_t *extents);
-
-cairo_private cairo_status_t
-_cairo_surface_fill_extents (cairo_surface_t		*surface,
-			     cairo_operator_t		 op,
-			     const cairo_pattern_t	*source,
-			     cairo_path_fixed_t		*path,
-			     cairo_fill_rule_t		 fill_rule,
-			     double			 tolerance,
-			     cairo_antialias_t		 antialias,
-			     cairo_clip_t		*clip,
-			     cairo_rectangle_int_t	*extents);
-
-cairo_private cairo_status_t
-_cairo_surface_glyphs_extents (cairo_surface_t *surface,
-			       cairo_operator_t	   op,
-			       const cairo_pattern_t *source,
-			       cairo_glyph_t	  *glyphs,
-			       int		   num_glyphs,
-			       cairo_scaled_font_t  *scaled_font,
-			       cairo_clip_t         *clip,
-			       cairo_rectangle_int_t *extents);
-
-cairo_private cairo_status_t
-_cairo_surface_composite_trapezoids (cairo_operator_t	op,
-				     const cairo_pattern_t *pattern,
-				     cairo_surface_t	*dst,
-				     cairo_antialias_t	antialias,
-				     int		src_x,
-				     int		src_y,
-				     int		dst_x,
-				     int		dst_y,
-				     unsigned int	width,
-				     unsigned int	height,
-				     cairo_trapezoid_t	*traps,
-				     int		ntraps,
-				     cairo_region_t	*clip_region);
-
-cairo_private cairo_status_t
-_cairo_surface_composite_trapezoids_as_polygon (cairo_surface_t	*surface,
-						cairo_operator_t	 op,
-						const cairo_pattern_t	*pattern,
-						cairo_antialias_t	antialias,
-						int src_x, int src_y,
-						int dst_x, int dst_y,
-						int width, int height,
-						cairo_trapezoid_t	*traps,
-						int num_traps,
-						cairo_region_t	*clip_region);
-
-cairo_private cairo_span_renderer_t *
-_cairo_surface_create_span_renderer (cairo_operator_t			 op,
-				     const cairo_pattern_t		*pattern,
-				     cairo_surface_t			*dst,
-				     cairo_antialias_t			 antialias,
-				     const cairo_composite_rectangles_t *rects,
-				     cairo_region_t			*clip_region);
-
-cairo_private cairo_bool_t
-_cairo_surface_check_span_renderer (cairo_operator_t			 op,
-				    const cairo_pattern_t		*pattern,
-				    cairo_surface_t			*dst,
-				    cairo_antialias_t			 antialias);
-
-cairo_private cairo_status_t
-_cairo_surface_acquire_source_image (cairo_surface_t         *surface,
-				     cairo_image_surface_t  **image_out,
-				     void                   **image_extra);
-
-cairo_private void
-_cairo_surface_release_source_image (cairo_surface_t        *surface,
-				     cairo_image_surface_t  *image,
-				     void                   *image_extra);
-
-cairo_private cairo_status_t
-_cairo_surface_acquire_dest_image (cairo_surface_t         *surface,
-				   cairo_rectangle_int_t   *interest_rect,
-				   cairo_image_surface_t  **image_out,
-				   cairo_rectangle_int_t   *image_rect,
-				   void                   **image_extra);
-
-cairo_private void
-_cairo_surface_release_dest_image (cairo_surface_t        *surface,
-				   cairo_rectangle_int_t  *interest_rect,
-				   cairo_image_surface_t  *image,
-				   cairo_rectangle_int_t  *image_rect,
-				   void                   *image_extra);
-
-cairo_private cairo_status_t
-_cairo_surface_clone_similar (cairo_surface_t  *surface,
-			      cairo_surface_t  *src,
-			      int               src_x,
-			      int               src_y,
-			      int               width,
-			      int               height,
-			      int              *clone_offset_x,
-			      int              *clone_offset_y,
-			      cairo_surface_t **clone_out);
-
-cairo_private cairo_surface_t *
-_cairo_surface_snapshot (cairo_surface_t *surface);
-
-cairo_private cairo_status_t
-_cairo_surface_attach_snapshot (cairo_surface_t *surface,
-				cairo_surface_t *snapshot,
-				cairo_surface_func_t detach_func);
-
-cairo_private cairo_surface_t *
-_cairo_surface_has_snapshot (cairo_surface_t *surface,
-			     const cairo_surface_backend_t *backend,
-			     cairo_content_t content);
-
-cairo_private void
-_cairo_surface_detach_snapshot (cairo_surface_t *snapshot);
-
-cairo_private cairo_bool_t
-_cairo_surface_is_similar (cairo_surface_t *surface_a,
-	                   cairo_surface_t *surface_b,
-			   cairo_content_t  content);
-
-cairo_private cairo_bool_t
-_cairo_surface_get_extents (cairo_surface_t         *surface,
-			    cairo_rectangle_int_t   *extents);
-
-cairo_private cairo_status_t
-_cairo_surface_old_show_glyphs (cairo_scaled_font_t	*scaled_font,
-				cairo_operator_t	 op,
-				const cairo_pattern_t	*pattern,
-				cairo_surface_t		*surface,
-				int			 source_x,
-				int			 source_y,
-				int			 dest_x,
-				int			 dest_y,
-				unsigned int		 width,
-				unsigned int		 height,
-				cairo_glyph_t		*glyphs,
-				int			 num_glyphs,
-				cairo_region_t		*clip_region);
-
-cairo_private cairo_status_t
-_cairo_surface_composite_fixup_unbounded (cairo_surface_t            *dst,
-					  cairo_surface_attributes_t *src_attr,
-					  int                         src_width,
-					  int                         src_height,
-					  cairo_surface_attributes_t *mask_attr,
-					  int                         mask_width,
-					  int                         mask_height,
-					  int			      src_x,
-					  int			      src_y,
-					  int			      mask_x,
-					  int			      mask_y,
-					  int			      dst_x,
-					  int			      dst_y,
-					  unsigned int		      width,
-					  unsigned int		      height,
-					  cairo_region_t	    *clip_region);
-
-cairo_private cairo_status_t
-_cairo_surface_composite_shape_fixup_unbounded (cairo_surface_t            *dst,
-						cairo_surface_attributes_t *src_attr,
-						int                         src_width,
-						int                         src_height,
-						int                         mask_width,
-						int                         mask_height,
-						int			    src_x,
-						int			    src_y,
-						int			    mask_x,
-						int			    mask_y,
-						int			    dst_x,
-						int			    dst_y,
-						unsigned int		    width,
-						unsigned int		    height,
-						cairo_region_t		    *clip_region);
-
-cairo_private cairo_bool_t
-_cairo_surface_is_opaque (const cairo_surface_t *surface);
-
-cairo_private void
-_cairo_surface_set_device_scale (cairo_surface_t *surface,
-				 double		  sx,
-				 double		  sy);
-
-cairo_private cairo_bool_t
-_cairo_surface_has_device_transform (cairo_surface_t *surface) cairo_pure;
-
-/* cairo-image-surface.c */
-
-/* XXX: In cairo 1.2.0 we added a new %CAIRO_FORMAT_RGB16_565 but
- * neglected to adjust this macro. The net effect is that it's
- * impossible to externally create an image surface with this
- * format. This is perhaps a good thing since we also neglected to fix
- * up things like cairo_surface_write_to_png() for the new format
- * (-Wswitch-enum will tell you where). Is it obvious that format was
- * added in haste?
- *
- * The reason for the new format was to allow the xlib backend to be
- * used on X servers with a 565 visual. So the new format did its job
- * for that, even without being considered "valid" for the sake of
- * things like cairo_image_surface_create().
- *
- * Since 1.2.0 we ran into the same situtation with X servers with BGR
- * visuals. This time we invented #cairo_internal_format_t instead,
- * (see it for more discussion).
- *
- * The punchline is that %CAIRO_FORMAT_VALID must not conside any
- * internal format to be valid. Also we need to decide if the
- * RGB16_565 should be moved to instead be an internal format. If so,
- * this macro need not change for it. (We probably will need to leave
- * an RGB16_565 value in the header files for the sake of code that
- * might have that value in it.)
- *
- * If we do decide to start fully supporting RGB16_565 as an external
- * format, then %CAIRO_FORMAT_VALID needs to be adjusted to include
- * it. But that should not happen before all necessary code is fixed
- * to support it (at least cairo_surface_write_to_png() and a few spots
- * in cairo-xlib-surface.c--again see -Wswitch-enum).
- */
-#define CAIRO_FORMAT_INVALID ((unsigned int) -1)
-#define CAIRO_FORMAT_VALID(format) ((format) <= CAIRO_FORMAT_A1)
-
-/* pixman-required stride alignment in bytes. */
-#define CAIRO_STRIDE_ALIGNMENT (sizeof (uint32_t))
-#define CAIRO_STRIDE_FOR_WIDTH_BPP(w,bpp) \
-   ((((bpp)*(w)+7)/8 + CAIRO_STRIDE_ALIGNMENT-1) & -CAIRO_STRIDE_ALIGNMENT)
-
-#define CAIRO_CONTENT_VALID(content) ((content) && 			         \
-				      (((content) & ~(CAIRO_CONTENT_COLOR |      \
-						      CAIRO_CONTENT_ALPHA |      \
-						      CAIRO_CONTENT_COLOR_ALPHA))\
-				       == 0))
-
-cairo_private int
-_cairo_format_bits_per_pixel (cairo_format_t format) cairo_const;
-
-cairo_private cairo_format_t
-_cairo_format_from_content (cairo_content_t content) cairo_const;
-
-cairo_private cairo_content_t
-_cairo_content_from_format (cairo_format_t format) cairo_const;
-
-cairo_private cairo_surface_t *
-_cairo_image_surface_create_for_pixman_image (pixman_image_t		*pixman_image,
-					      pixman_format_code_t	 pixman_format);
-
-cairo_private cairo_bool_t
-_pixman_format_from_masks (cairo_format_masks_t *masks,
-			   pixman_format_code_t *format_ret);
-
-cairo_private cairo_bool_t
-_pixman_format_to_masks (pixman_format_code_t	 pixman_format,
-			 cairo_format_masks_t	*masks);
-
-cairo_private cairo_surface_t *
-_cairo_image_surface_create_with_pixman_format (unsigned char		*data,
-						pixman_format_code_t	 pixman_format,
-						int			 width,
-						int			 height,
-						int			 stride);
-
-cairo_private cairo_surface_t *
-_cairo_image_surface_create_with_masks (unsigned char	       *data,
-					cairo_format_masks_t   *format,
-					int			width,
-					int			height,
-					int			stride);
-
-cairo_private cairo_surface_t *
-_cairo_image_surface_create_with_content (cairo_content_t	content,
-					  int			width,
-					  int			height);
-
-cairo_private cairo_surface_t *
-_cairo_image_surface_create_for_data_with_content (unsigned char	*data,
-						   cairo_content_t	 content,
-						   int			 width,
-						   int			 height,
-						   int			 stride);
-
-cairo_private void
-_cairo_image_surface_assume_ownership_of_data (cairo_image_surface_t *surface);
-
-cairo_private cairo_image_surface_t *
-_cairo_image_surface_coerce (cairo_image_surface_t	*surface,
-			     cairo_format_t		 format);
-cairo_private void
-_cairo_image_surface_span_render_row (int				 y,
-				      const cairo_half_open_span_t	 *spans,
-				      unsigned				 num_spans,
-				      cairo_image_surface_t              *mask,
-				      const cairo_composite_rectangles_t *rects);
-
-cairo_private cairo_image_transparency_t
-_cairo_image_analyze_transparency (cairo_image_surface_t      *image);
-
-cairo_private cairo_bool_t
-_cairo_surface_is_image (const cairo_surface_t *surface) cairo_pure;
-
-cairo_private cairo_bool_t
-_cairo_surface_is_recording (const cairo_surface_t *surface) cairo_pure;
-
-/* cairo-pen.c */
-cairo_private cairo_status_t
-_cairo_pen_init (cairo_pen_t	*pen,
-		 double		 radius,
-		 double		 tolerance,
-		 const cairo_matrix_t	*ctm);
-
-cairo_private void
-_cairo_pen_init_empty (cairo_pen_t *pen);
-
-cairo_private cairo_status_t
-_cairo_pen_init_copy (cairo_pen_t *pen, const cairo_pen_t *other);
-
-cairo_private void
-_cairo_pen_fini (cairo_pen_t *pen);
-
-cairo_private cairo_status_t
-_cairo_pen_add_points (cairo_pen_t *pen, cairo_point_t *point, int num_points);
-
-cairo_private cairo_status_t
-_cairo_pen_add_points_for_slopes (cairo_pen_t *pen,
-				  cairo_point_t *a,
-				  cairo_point_t *b,
-				  cairo_point_t *c,
-				  cairo_point_t *d);
-
-cairo_private int
-_cairo_pen_find_active_cw_vertex_index (const cairo_pen_t *pen,
-					const cairo_slope_t *slope);
-
-cairo_private int
-_cairo_pen_find_active_ccw_vertex_index (const cairo_pen_t *pen,
-					 const cairo_slope_t *slope);
-
-/* cairo-polygon.c */
-cairo_private void
-_cairo_polygon_init (cairo_polygon_t *polygon);
-
-cairo_private void
-_cairo_polygon_limit (cairo_polygon_t	*polygon,
-		      const cairo_box_t *boxes,
-		      int		 num_boxes);
-
-cairo_private void
-_cairo_polygon_fini (cairo_polygon_t *polygon);
-
-cairo_private cairo_status_t
-_cairo_polygon_add_line (cairo_polygon_t *polygon,
-			 const cairo_line_t *line,
-			 int top, int bottom,
-			 int dir);
-
-cairo_private cairo_status_t
-_cairo_polygon_add_external_edge (void *polygon,
-				  const cairo_point_t *p1,
-				  const cairo_point_t *p2);
-
-cairo_private cairo_status_t
-_cairo_polygon_move_to (cairo_polygon_t *polygon,
-			const cairo_point_t *point);
-
-cairo_private cairo_status_t
-_cairo_polygon_line_to (cairo_polygon_t *polygon,
-			const cairo_point_t *point);
-
-cairo_private cairo_status_t
-_cairo_polygon_close (cairo_polygon_t *polygon);
-
-#define _cairo_polygon_status(P) ((cairo_polygon_t *) (P))->status
-
-/* cairo-spline.c */
-cairo_private cairo_bool_t
-_cairo_spline_init (cairo_spline_t *spline,
-		    cairo_spline_add_point_func_t add_point_func,
-		    void *closure,
-		    const cairo_point_t *a, const cairo_point_t *b,
-		    const cairo_point_t *c, const cairo_point_t *d);
-
-cairo_private cairo_status_t
-_cairo_spline_decompose (cairo_spline_t *spline, double tolerance);
-
-cairo_private cairo_status_t
-_cairo_spline_bound (cairo_spline_add_point_func_t add_point_func,
-		     void *closure,
-		     const cairo_point_t *p0, const cairo_point_t *p1,
-		     const cairo_point_t *p2, const cairo_point_t *p3);
-
-/* cairo-matrix.c */
-cairo_private void
-_cairo_matrix_get_affine (const cairo_matrix_t *matrix,
-			  double *xx, double *yx,
-			  double *xy, double *yy,
-			  double *x0, double *y0);
-
-cairo_private void
-_cairo_matrix_transform_bounding_box (const cairo_matrix_t *matrix,
-				      double *x1, double *y1,
-				      double *x2, double *y2,
-				      cairo_bool_t *is_tight);
-
-cairo_private void
-_cairo_matrix_transform_bounding_box_fixed (const cairo_matrix_t *matrix,
-					    cairo_box_t          *bbox,
-					    cairo_bool_t         *is_tight);
-
-cairo_private cairo_bool_t
-_cairo_matrix_is_invertible (const cairo_matrix_t *matrix) cairo_pure;
-
-cairo_private double
-_cairo_matrix_compute_determinant (const cairo_matrix_t *matrix) cairo_pure;
-
-cairo_private cairo_status_t
-_cairo_matrix_compute_basis_scale_factors (const cairo_matrix_t *matrix,
-					   double *sx, double *sy, int x_major);
-
-cairo_private cairo_bool_t
-_cairo_matrix_is_identity (const cairo_matrix_t *matrix) cairo_pure;
-
-cairo_private cairo_bool_t
-_cairo_matrix_is_translation (const cairo_matrix_t *matrix) cairo_pure;
-
-cairo_private cairo_bool_t
-_cairo_matrix_is_integer_translation(const cairo_matrix_t *matrix,
-				     int *itx, int *ity);
-
-cairo_private cairo_bool_t
-_cairo_matrix_has_unity_scale (const cairo_matrix_t *matrix);
-
-cairo_private cairo_bool_t
-_cairo_matrix_is_pixel_exact (const cairo_matrix_t *matrix) cairo_pure;
-
-cairo_private double
-_cairo_matrix_transformed_circle_major_axis (const cairo_matrix_t *matrix,
-					     double radius) cairo_pure;
-
-cairo_private void
-_cairo_matrix_to_pixman_matrix (const cairo_matrix_t	*matrix,
-				pixman_transform_t	*pixman_transform,
-				double                   xc,
-				double                   yc);
-
-/* cairo-traps.c */
-cairo_private void
-_cairo_traps_init (cairo_traps_t *traps);
-
-cairo_private void
-_cairo_traps_limit (cairo_traps_t	*traps,
-		    const cairo_box_t	*boxes,
-		    int			 num_boxes);
-
-cairo_private cairo_status_t
-_cairo_traps_init_boxes (cairo_traps_t	    *traps,
-			 const cairo_box_t    *boxes,
-			 int		     num_boxes);
-
-cairo_private void
-_cairo_traps_clear (cairo_traps_t *traps);
-
-cairo_private void
-_cairo_traps_fini (cairo_traps_t *traps);
-
-#define _cairo_traps_status(T) (T)->status
-
-cairo_private void
-_cairo_traps_translate (cairo_traps_t *traps, int x, int y);
-
-cairo_private cairo_status_t
-_cairo_traps_tessellate_rectangle (cairo_traps_t *traps,
-				   const cairo_point_t *top_left,
-				   const cairo_point_t *bottom_right);
-
-cairo_private void
-_cairo_traps_add_trap (cairo_traps_t *traps,
-		       cairo_fixed_t top, cairo_fixed_t bottom,
-		       cairo_line_t *left, cairo_line_t *right);
-
-cairo_private cairo_status_t
-_cairo_bentley_ottmann_tessellate_rectilinear_polygon (cairo_traps_t	 *traps,
-						       const cairo_polygon_t *polygon,
-						       cairo_fill_rule_t	  fill_rule);
-
-cairo_private cairo_status_t
-_cairo_bentley_ottmann_tessellate_polygon (cairo_traps_t         *traps,
-					   const cairo_polygon_t *polygon);
-
-cairo_private cairo_status_t
-_cairo_bentley_ottmann_tessellate_traps (cairo_traps_t *traps,
-					 cairo_fill_rule_t fill_rule);
-
-cairo_private cairo_status_t
-_cairo_bentley_ottmann_tessellate_rectangular_traps (cairo_traps_t *traps,
-						     cairo_fill_rule_t fill_rule);
-
-cairo_private cairo_status_t
-_cairo_bentley_ottmann_tessellate_rectilinear_traps (cairo_traps_t *traps,
-						     cairo_fill_rule_t fill_rule);
-
-cairo_private int
-_cairo_traps_contain (const cairo_traps_t *traps,
-		      double x, double y);
-
-cairo_private void
-_cairo_traps_extents (const cairo_traps_t *traps,
-		      cairo_box_t         *extents);
-
-cairo_private cairo_int_status_t
-_cairo_traps_extract_region (cairo_traps_t  *traps,
-			     cairo_region_t **region);
-
-cairo_private cairo_status_t
-_cairo_traps_path (const cairo_traps_t *traps,
-		   cairo_path_fixed_t  *path);
-
-cairo_private void
-_cairo_trapezoid_array_translate_and_scale (cairo_trapezoid_t *offset_traps,
-					    cairo_trapezoid_t *src_traps,
-					    int num_traps,
-					    double tx, double ty,
-					    double sx, double sy);
-
-/* cairo-pattern.c */
-
-cairo_private cairo_pattern_t *
-_cairo_pattern_create_in_error (cairo_status_t status);
-
-cairo_private cairo_status_t
-_cairo_pattern_create_copy (cairo_pattern_t	  **pattern,
-			    const cairo_pattern_t  *other);
-
-cairo_private cairo_status_t
-_cairo_pattern_init_copy (cairo_pattern_t	*pattern,
-			  const cairo_pattern_t *other);
-
-cairo_private void
-_cairo_pattern_init_static_copy (cairo_pattern_t	*pattern,
-				 const cairo_pattern_t *other);
-
-cairo_private cairo_status_t
-_cairo_pattern_init_snapshot (cairo_pattern_t       *pattern,
-			      const cairo_pattern_t *other);
-
-cairo_private void
-_cairo_pattern_init_solid (cairo_solid_pattern_t	*pattern,
-			   const cairo_color_t		*color,
-			   cairo_content_t		 content);
-
-cairo_private void
-_cairo_pattern_init_for_surface (cairo_surface_pattern_t *pattern,
-				 cairo_surface_t *surface);
-
-cairo_private void
-_cairo_pattern_init_linear (cairo_linear_pattern_t *pattern,
-			    double x0, double y0, double x1, double y1);
-
-cairo_private void
-_cairo_pattern_init_radial (cairo_radial_pattern_t *pattern,
-			    double cx0, double cy0, double radius0,
-			    double cx1, double cy1, double radius1);
-
-cairo_private void
-_cairo_pattern_fini (cairo_pattern_t *pattern);
-
-cairo_private void
-_cairo_pattern_fini_snapshot (cairo_pattern_t *pattern);
-
-cairo_private cairo_pattern_t *
-_cairo_pattern_create_solid (const cairo_color_t	*color,
-			     cairo_content_t		 content);
-
-cairo_private void
-_cairo_pattern_transform (cairo_pattern_t      *pattern,
-			  const cairo_matrix_t *ctm_inverse);
-
-cairo_private cairo_bool_t
-_cairo_pattern_is_opaque_solid (const cairo_pattern_t *pattern);
-
-cairo_private cairo_bool_t
-_cairo_pattern_is_opaque (const cairo_pattern_t *abstract_pattern);
-
-enum {
-    CAIRO_PATTERN_ACQUIRE_NONE = 0x0,
-    CAIRO_PATTERN_ACQUIRE_NO_REFLECT = 0x1,
-};
-cairo_private cairo_int_status_t
-_cairo_pattern_acquire_surface (const cairo_pattern_t	   *pattern,
-				cairo_surface_t		   *dst,
-				int			   x,
-				int			   y,
-				unsigned int		   width,
-				unsigned int		   height,
-				unsigned int		   flags,
-				cairo_surface_t		   **surface_out,
-				cairo_surface_attributes_t *attributes);
-
-cairo_private void
-_cairo_pattern_release_surface (const cairo_pattern_t	   *pattern,
-				cairo_surface_t		   *surface,
-				cairo_surface_attributes_t *attributes);
-
-cairo_private cairo_int_status_t
-_cairo_pattern_acquire_surfaces (const cairo_pattern_t	    *src,
-				 const cairo_pattern_t	    *mask,
-				 cairo_surface_t	    *dst,
-				 int			    src_x,
-				 int			    src_y,
-				 int			    mask_x,
-				 int			    mask_y,
-				 unsigned int		    width,
-				 unsigned int		    height,
-				 unsigned int		    flags,
-				 cairo_surface_t	    **src_out,
-				 cairo_surface_t	    **mask_out,
-				 cairo_surface_attributes_t *src_attributes,
-				 cairo_surface_attributes_t *mask_attributes);
-
-cairo_private void
-_cairo_pattern_get_extents (const cairo_pattern_t	    *pattern,
-			    cairo_rectangle_int_t           *extents);
-
-cairo_private unsigned long
-_cairo_pattern_hash (const cairo_pattern_t *pattern);
-
-cairo_private unsigned long
-_cairo_pattern_size (const cairo_pattern_t *pattern);
-
-cairo_private cairo_bool_t
-_cairo_pattern_equal (const cairo_pattern_t *a,
-		      const cairo_pattern_t *b);
-
-cairo_private void
-_cairo_pattern_reset_static_data (void);
-
-#if CAIRO_HAS_DRM_SURFACE
-
-cairo_private void
-_cairo_drm_device_reset_static_data (void);
-
-#endif
-
-cairo_private void
-_cairo_clip_reset_static_data (void);
-
-/* cairo-unicode.c */
-
-cairo_private int
-_cairo_utf8_get_char_validated (const char *p,
-				uint32_t   *unicode);
-
-cairo_private cairo_status_t
-_cairo_utf8_to_ucs4 (const char *str,
-		     int	 len,
-		     uint32_t  **result,
-		     int	*items_written);
-
-cairo_private int
-_cairo_ucs4_to_utf8 (uint32_t    unicode,
-		     char       *utf8);
-
-#if CAIRO_HAS_WIN32_FONT || CAIRO_HAS_QUARTZ_FONT || CAIRO_HAS_PDF_OPERATORS
-# define CAIRO_HAS_UTF8_TO_UTF16 1
-#endif
-#if CAIRO_HAS_UTF8_TO_UTF16
-cairo_private cairo_status_t
-_cairo_utf8_to_utf16 (const char *str,
-		      int	  len,
-		      uint16_t  **result,
-		      int	 *items_written);
-#endif
-
-#define _cairo_status_is_error(status) \
-    (status != CAIRO_STATUS_SUCCESS && status <= CAIRO_STATUS_LAST_STATUS)
-
-cairo_private cairo_status_t
-_cairo_error (cairo_status_t status);
-
-/* hide compiler warnings when discarding the return value */
-#define _cairo_error_throw(status) do { \
-    cairo_status_t status__ = _cairo_error (status); \
-    (void) status__; \
-} while (0)
-
-/* Avoid unnecessary PLT entries.  */
-slim_hidden_proto (cairo_clip_preserve);
-slim_hidden_proto (cairo_close_path);
-slim_hidden_proto (cairo_create);
-slim_hidden_proto (cairo_curve_to);
-slim_hidden_proto (cairo_destroy);
-slim_hidden_proto (cairo_fill_preserve);
-slim_hidden_proto (cairo_font_face_destroy);
-slim_hidden_proto (cairo_font_face_get_user_data);
-slim_hidden_proto_no_warn (cairo_font_face_reference);
-slim_hidden_proto (cairo_font_face_set_user_data);
-slim_hidden_proto (cairo_font_options_equal);
-slim_hidden_proto (cairo_font_options_hash);
-slim_hidden_proto (cairo_font_options_merge);
-slim_hidden_proto (cairo_font_options_set_antialias);
-slim_hidden_proto (cairo_font_options_set_hint_metrics);
-slim_hidden_proto (cairo_font_options_set_hint_style);
-slim_hidden_proto (cairo_font_options_set_subpixel_order);
-slim_hidden_proto (cairo_font_options_status);
-slim_hidden_proto (cairo_format_stride_for_width);
-slim_hidden_proto (cairo_get_current_point);
-slim_hidden_proto (cairo_get_line_width);
-slim_hidden_proto (cairo_get_matrix);
-slim_hidden_proto (cairo_get_target);
-slim_hidden_proto (cairo_get_tolerance);
-slim_hidden_proto (cairo_glyph_allocate);
-slim_hidden_proto (cairo_glyph_free);
-slim_hidden_proto (cairo_image_surface_create);
-slim_hidden_proto (cairo_image_surface_create_for_data);
-slim_hidden_proto (cairo_image_surface_get_data);
-slim_hidden_proto (cairo_image_surface_get_format);
-slim_hidden_proto (cairo_image_surface_get_height);
-slim_hidden_proto (cairo_image_surface_get_stride);
-slim_hidden_proto (cairo_image_surface_get_width);
-slim_hidden_proto (cairo_line_to);
-slim_hidden_proto (cairo_mask);
-slim_hidden_proto (cairo_matrix_init);
-slim_hidden_proto (cairo_matrix_init_identity);
-slim_hidden_proto (cairo_matrix_init_rotate);
-slim_hidden_proto (cairo_matrix_init_scale);
-slim_hidden_proto (cairo_matrix_init_translate);
-slim_hidden_proto (cairo_matrix_invert);
-slim_hidden_proto (cairo_matrix_multiply);
-slim_hidden_proto (cairo_matrix_scale);
-slim_hidden_proto (cairo_matrix_transform_distance);
-slim_hidden_proto (cairo_matrix_transform_point);
-slim_hidden_proto (cairo_matrix_translate);
-slim_hidden_proto (cairo_move_to);
-slim_hidden_proto (cairo_new_path);
-slim_hidden_proto (cairo_paint);
-slim_hidden_proto (cairo_pattern_create_for_surface);
-slim_hidden_proto (cairo_pattern_create_rgb);
-slim_hidden_proto (cairo_pattern_create_rgba);
-slim_hidden_proto (cairo_pattern_destroy);
-slim_hidden_proto (cairo_pattern_get_extend);
-slim_hidden_proto_no_warn (cairo_pattern_reference);
-slim_hidden_proto (cairo_pattern_set_matrix);
-slim_hidden_proto (cairo_pop_group);
-slim_hidden_proto (cairo_push_group_with_content);
-slim_hidden_proto (cairo_rel_line_to);
-slim_hidden_proto (cairo_restore);
-slim_hidden_proto (cairo_save);
-slim_hidden_proto (cairo_scale);
-slim_hidden_proto (cairo_scaled_font_create);
-slim_hidden_proto (cairo_scaled_font_destroy);
-slim_hidden_proto (cairo_scaled_font_extents);
-slim_hidden_proto (cairo_scaled_font_get_ctm);
-slim_hidden_proto (cairo_scaled_font_get_font_face);
-slim_hidden_proto (cairo_scaled_font_get_font_matrix);
-slim_hidden_proto (cairo_scaled_font_get_font_options);
-slim_hidden_proto (cairo_scaled_font_glyph_extents);
-slim_hidden_proto_no_warn (cairo_scaled_font_reference);
-slim_hidden_proto (cairo_scaled_font_status);
-slim_hidden_proto (cairo_scaled_font_get_user_data);
-slim_hidden_proto (cairo_scaled_font_set_user_data);
-slim_hidden_proto (cairo_scaled_font_text_to_glyphs);
-slim_hidden_proto (cairo_set_font_options);
-slim_hidden_proto (cairo_set_font_size);
-slim_hidden_proto (cairo_set_line_cap);
-slim_hidden_proto (cairo_set_line_join);
-slim_hidden_proto (cairo_set_line_width);
-slim_hidden_proto (cairo_set_matrix);
-slim_hidden_proto (cairo_set_operator);
-slim_hidden_proto (cairo_set_source);
-slim_hidden_proto (cairo_set_source_rgb);
-slim_hidden_proto (cairo_set_source_surface);
-slim_hidden_proto (cairo_set_tolerance);
-slim_hidden_proto (cairo_status);
-slim_hidden_proto (cairo_stroke);
-slim_hidden_proto (cairo_stroke_preserve);
-slim_hidden_proto (cairo_surface_copy_page);
-slim_hidden_proto (cairo_surface_destroy);
-slim_hidden_proto (cairo_surface_finish);
-slim_hidden_proto (cairo_surface_flush);
-slim_hidden_proto (cairo_surface_get_content);
-slim_hidden_proto (cairo_surface_get_device_offset);
-slim_hidden_proto (cairo_surface_get_font_options);
-slim_hidden_proto (cairo_surface_get_mime_data);
-slim_hidden_proto (cairo_surface_get_type);
-slim_hidden_proto (cairo_surface_has_show_text_glyphs);
-slim_hidden_proto (cairo_surface_mark_dirty_rectangle);
-slim_hidden_proto_no_warn (cairo_surface_reference);
-slim_hidden_proto (cairo_surface_set_device_offset);
-slim_hidden_proto (cairo_surface_set_fallback_resolution);
-slim_hidden_proto (cairo_surface_set_mime_data);
-slim_hidden_proto (cairo_surface_show_page);
-slim_hidden_proto (cairo_surface_status);
-slim_hidden_proto (cairo_text_cluster_allocate);
-slim_hidden_proto (cairo_text_cluster_free);
-slim_hidden_proto (cairo_toy_font_face_create);
-slim_hidden_proto (cairo_toy_font_face_get_slant);
-slim_hidden_proto (cairo_toy_font_face_get_weight);
-slim_hidden_proto (cairo_translate);
-slim_hidden_proto (cairo_transform);
-slim_hidden_proto (cairo_user_font_face_create);
-slim_hidden_proto (cairo_user_font_face_set_init_func);
-slim_hidden_proto (cairo_user_font_face_set_render_glyph_func);
-slim_hidden_proto (cairo_user_font_face_set_unicode_to_glyph_func);
-slim_hidden_proto (cairo_user_to_device);
-slim_hidden_proto (cairo_user_to_device_distance);
-slim_hidden_proto (cairo_version_string);
-slim_hidden_proto (cairo_region_create);
-slim_hidden_proto (cairo_region_create_rectangle);
-slim_hidden_proto (cairo_region_create_rectangles);
-slim_hidden_proto (cairo_region_copy);
-slim_hidden_proto (cairo_region_reference);
-slim_hidden_proto (cairo_region_destroy);
-slim_hidden_proto (cairo_region_equal);
-slim_hidden_proto (cairo_region_status);
-slim_hidden_proto (cairo_region_get_extents);
-slim_hidden_proto (cairo_region_num_rectangles);
-slim_hidden_proto (cairo_region_get_rectangle);
-slim_hidden_proto (cairo_region_is_empty);
-slim_hidden_proto (cairo_region_contains_rectangle);
-slim_hidden_proto (cairo_region_contains_point);
-slim_hidden_proto (cairo_region_translate);
-slim_hidden_proto (cairo_region_subtract);
-slim_hidden_proto (cairo_region_subtract_rectangle);
-slim_hidden_proto (cairo_region_intersect);
-slim_hidden_proto (cairo_region_intersect_rectangle);
-slim_hidden_proto (cairo_region_union);
-slim_hidden_proto (cairo_region_union_rectangle);
-
-#if CAIRO_HAS_PNG_FUNCTIONS
-
-slim_hidden_proto (cairo_surface_write_to_png_stream);
-
-#endif
-
-CAIRO_END_DECLS
-
-#include "cairo-mutex-private.h"
-#include "cairo-fixed-private.h"
-#include "cairo-wideint-private.h"
-#include "cairo-malloc-private.h"
-#include "cairo-hash-private.h"
-
-#if HAVE_VALGRIND
-#include <memcheck.h>
-
-#define VG(x) x
-
-cairo_private void
-_cairo_debug_check_image_surface_is_defined (const cairo_surface_t *surface);
-
-#else
-
-#define VG(x)
-#define _cairo_debug_check_image_surface_is_defined(X)
-
-#endif
-
-cairo_private void
-_cairo_debug_print_path (FILE *stream, cairo_path_fixed_t *path);
-
-cairo_private void
-_cairo_debug_print_clip (FILE *stream, cairo_clip_t *clip);
-
-#endif
diff --git a/src/sweep.h b/src/sweep.h
index 005adf5..2d084ed 100644
--- a/src/sweep.h
+++ b/src/sweep.h
@@ -1,3 +1,3 @@
-#include "cairo/cairoint.h"
+#include "cairo/cairo-traps-private.h"
 
 cairo_status_t bo_poly_to_traps (POLYAREA *poly, cairo_traps_t *traps);

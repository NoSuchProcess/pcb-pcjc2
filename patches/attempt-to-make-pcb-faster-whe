Bottom: 8ab77fc6d0f9c46453f250baff3d0953b57e4741
Top:    47e31672902fb1a2b2abc567d5f0303e33fad30c
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2008-09-30 23:55:56 +0100

Attempt to make PCB faster when working with polygons.

Currently, moving / altering objects can take far longer than the
time taken to clear _all_ polygons at startup. Incremental updates
seem to get bogged down. Can we instead:

Re-clear polygons from scratch for certain updates?
Use any more efficient algorithms for update?





---

diff --git a/src/create.c b/src/create.c
index 70715bc..d8aaca6 100644
--- a/src/create.c
+++ b/src/create.c
@@ -601,6 +601,7 @@ CreateNewPolygon (LayerTypePtr Layer, FlagType Flags)
   polygon->ID = ID++;
   polygon->Clipped = NULL;
   polygon->NoHoles = NULL;
+  polygon->NoHolesValid = 0;
   return (polygon);
 }
 
diff --git a/src/draw.c b/src/draw.c
index 2403c62..d5396e8 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -2123,15 +2123,22 @@ DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
       if (!Gathering)
 	PolygonHoles (clip_box, Layer, Polygon, thin_callback);
     }
-  else if (Polygon->NoHoles)//(Polygon->Clipped)
-    {
-      PolygonType poly;
-      poly.Clipped = Polygon->NoHoles;
-      do {
-        DrawPolygonLowLevel (&poly);
-//        printf ("Drawing no-holes portion of polygon\n");
-        poly.Clipped = poly.Clipped->f;
-      } while (poly.Clipped != Polygon->NoHoles);
+  else //if (Polygon->NoHoles)//(Polygon->Clipped)
+    {
+      if (!Polygon->NoHolesValid)
+        {
+          ComputeNoHoles (Polygon);
+        }
+
+      if (Polygon->NoHoles)
+        {
+          PolygonType poly;
+          poly.Clipped = Polygon->NoHoles;
+          do {
+            DrawPolygonLowLevel (&poly);
+            poly.Clipped = poly.Clipped->f;
+          } while (poly.Clipped != Polygon->NoHoles);
+        }
 #if 0
       NoHolesPolygonDicer (Polygon, DrawPolygonLowLevel, clip_box);
       /* draw other parts of the polygon if fullpoly flag is set */
diff --git a/src/global.h b/src/global.h
index 9438dd9..7763c80 100644
--- a/src/global.h
+++ b/src/global.h
@@ -205,6 +205,7 @@ typedef struct			/* holds information about a polygon */
     PointMax;			/* max number from malloc() */
   POLYAREA *Clipped;		/* the clipped region of this polygon */
   POLYAREA *NoHoles;		/* the polygon broken into hole-less regions */
+  int NoHolesValid;		/* Is the NoHoles polygon up to date? */
   PointTypePtr Points;		/* data */
 } PolygonType, *PolygonTypePtr;
 
diff --git a/src/polygon.c b/src/polygon.c
index f27faed..ecf11f4 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -77,6 +77,53 @@ static double circleVerticies[] = {
   0.98480775301221, 0.17364817766693,
 };
 
+static void
+add_noholes_polyarea (PolygonType *noholes_poly, void *user_data)
+{
+  PolygonType *poly = user_data;
+  PLINE *pline;//, last;
+  POLYAREA *new_area;
+
+  new_area = malloc (sizeof (POLYAREA) * 1);
+
+  /* Allocate a new PLINE, COPY the PLINE from the passed polygon */
+  poly_CopyContour (&pline, noholes_poly->Clipped->contours);
+  new_area->contours = pline;
+
+  /* Link the new POLYAREA into the NoHoles circularaly linked list */
+
+  if (poly->NoHoles)
+    {
+      new_area->f = poly->NoHoles;
+      new_area->b = poly->NoHoles->b;
+      poly->NoHoles->b->f = new_area;
+      poly->NoHoles->b = new_area;
+    }
+  else
+    {
+      new_area->f = new_area;
+      new_area->b = new_area;
+    }
+
+  poly->NoHoles = new_area;
+
+}
+
+void
+ComputeNoHoles (PolygonType *poly)
+{
+  /* TODO: IS THIS RIGHT? */
+  if (poly->NoHoles)
+    {
+      poly_Free (&poly->NoHoles);
+    }
+  poly->NoHoles = NULL;
+  if (poly->Clipped)
+    NoHolesPolygonDicer (poly, add_noholes_polyarea, poly, NULL);
+  else
+    printf ("Compute_noholes caught poly->Clipped = NULL\n");
+  poly->NoHolesValid = 1;
+}
 
 static POLYAREA *
 biggest (POLYAREA * p)
@@ -172,53 +219,6 @@ original_poly (PolygonType * p)
   return biggest (np);
 }
 
-static void
-add_noholes_polyarea (PolygonType *noholes_poly, void *user_data)
-{
-  PolygonType *poly = user_data;
-  PLINE *pline;
-  POLYAREA *new_area;
-
-  new_area = malloc (sizeof (POLYAREA) * 1);
-
-  /* Allocate a new PLINE, COPY the PLINE from the passed polygon */
-  poly_CopyContour (&pline, noholes_poly->Clipped->contours);
-  new_area->contours = pline;
-
-  /* Link the new POLYAREA into the NoHoles circularaly linked list */
-
-  if (poly->NoHoles)
-    {
-      new_area->f = poly->NoHoles;
-      new_area->b = poly->NoHoles->b;
-      poly->NoHoles->b->f = new_area;
-      poly->NoHoles->b = new_area;
-    }
-  else
-    {
-      new_area->f = new_area;
-      new_area->b = new_area;
-    }
-
-  poly->NoHoles = new_area;
-
-}
-
-static void
-compute_noholes (PolygonType *poly)
-{
-  /* TODO: IS THIS RIGHT? */
-  if (poly->NoHoles)
-    {
-      poly_Free (&poly->NoHoles);
-    }
-  poly->NoHoles = NULL;
-  if (poly->Clipped)
-    NoHolesPolygonDicer (poly, add_noholes_polyarea, poly, NULL);
-  else
-    printf ("Compute_noholes caught poly->Clipped = NULL\n");
-}
-
 static int
 ClipOriginal (PolygonType * poly)
 {
@@ -886,7 +886,7 @@ clearPoly (DataTypePtr Data, LayerTypePtr Layer, PolygonType * polygon,
       if (info.solder || group == Group (Data, max_layer + COMPONENT_LAYER))
 	r += r_search (Data->pad_tree, &region, NULL, pad_sub_callback, &info);
     }
-  compute_noholes (polygon);
+  polygon->NoHolesValid = 0;
   return r;
 }
 
@@ -1022,7 +1022,7 @@ InitClip (DataTypePtr Data, LayerTypePtr layer, PolygonType * p)
   if (TEST_FLAG (CLEARPOLYFLAG, p))
     clearPoly (Data, layer, p, NULL, 0);
   else
-    compute_noholes (p);
+    p->NoHolesValid = 0;
   return 1;
 }
 
@@ -1276,23 +1276,23 @@ subtract_plow (DataTypePtr Data, LayerTypePtr Layer, PolygonTypePtr Polygon,
     case PIN_TYPE:
     case VIA_TYPE:
       SubtractPin (Data, (PinTypePtr) ptr2, Layer, Polygon);
-      compute_noholes (Polygon);
+      Polygon->NoHolesValid = 0;
       return 1;
     case LINE_TYPE:
       SubtractLine ((LineTypePtr) ptr2, Polygon);
-      compute_noholes (Polygon);
+      Polygon->NoHolesValid = 0;
       return 1;
     case ARC_TYPE:
       SubtractArc ((ArcTypePtr) ptr2, Polygon);
-      compute_noholes (Polygon);
+      Polygon->NoHolesValid = 0;
       return 1;
     case PAD_TYPE:
       SubtractPad ((PadTypePtr) ptr2, Polygon);
-      compute_noholes (Polygon);
+      Polygon->NoHolesValid = 0;
       return 1;
     case TEXT_TYPE:
       SubtractText ((TextTypePtr) ptr2, Polygon);
-      compute_noholes (Polygon);
+      Polygon->NoHolesValid = 0;
       return 1;
     }
   return 0;
diff --git a/src/polygon.h b/src/polygon.h
index bccc7b0..2c78e94 100644
--- a/src/polygon.h
+++ b/src/polygon.h
@@ -43,6 +43,7 @@ int PolygonHoles (const BoxType * range, LayerTypePtr, PolygonTypePtr,
 		  int (*callback) (PLINE *, LayerTypePtr, PolygonTypePtr));
 int PlowsPolygon (DataType *, int, void *, void *,
 		  int (*callback) (DataTypePtr, LayerTypePtr, PolygonTypePtr, int, void *, void *));
+void ComputeNoHoles (PolygonType *poly);
 POLYAREA * ContourToPoly (PLINE *);
 POLYAREA * RectPoly (LocationType x1, LocationType x2, LocationType y1, LocationType y2);
 POLYAREA * CirclePoly(LocationType x, LocationType y, BDimension radius);

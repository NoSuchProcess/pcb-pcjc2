Bottom: 1622a70dcb0ee968dd8c0302d5f9516c76b7f27c
Top:    de5d2e0df191516abe415cc21ecadb4e33f20cbf
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2012-11-19 21:49:35 +0000

Split out drawing routines into vfunc table for possible replacement

The aim here is to indirect calls to the various drawing routines such
that a GUI or renderer implementation may swap out different parts of
the rendering operation at will without having to re-implement the
entire drawing stack from scratch.

Each drawing API call will now be passed the drawing API structure as
its first parameter, so we don't rely on this being a global.

As a further clean-up, the graphics context being used by the rendering
routines is now a member of the vfunc table structure. We currently
retain the old Output.*gc members, but only use them (where necessary)
to update the ->gc member of the drawing API structure as rendering
progresses.


---

diff --git a/src/autoroute.c b/src/autoroute.c
index a2a64c6..3a6876a 100644
--- a/src/autoroute.c
+++ b/src/autoroute.c
@@ -137,8 +137,8 @@ return dir;
 }
 
 #ifdef ROUTE_DEBUG
-HID *ddraw = NULL;
-static hidGC ar_gc = 0;
+HID_DRAW_API *ddraw = NULL;
+static hidGC ar_gc = NULL;
 #endif
 
 #define EXPENSIVE 3e28
@@ -1469,14 +1469,14 @@ showbox (BoxType b, Dimension thickness, int group)
 
   if (ddraw != NULL)
     {
-      ddraw->graphics->set_line_width (ar_gc, thickness);
-      ddraw->graphics->set_line_cap (ar_gc, Trace_Cap);
-      ddraw->graphics->set_color (ar_gc, SLayer->Color);
-
-      ddraw->graphics->draw_line (ar_gc, b.X1, b.Y1, b.X2, b.Y1);
-      ddraw->graphics->draw_line (ar_gc, b.X1, b.Y2, b.X2, b.Y2);
-      ddraw->graphics->draw_line (ar_gc, b.X1, b.Y1, b.X1, b.Y2);
-      ddraw->graphics->draw_line (ar_gc, b.X2, b.Y1, b.X2, b.Y2);
+      pcb_draw_set_line_width (ddraw, thickness);
+      pcb_draw_set_line_cap (ddraw, Trace_Cap);
+      pcb_draw_set_color (ddraw, SLayer->Color);
+
+      pcb_draw_line (ddraw, b.X1, b.Y1, b.X2, b.Y1);
+      pcb_draw_line (ddraw, b.X1, b.Y2, b.X2, b.Y2);
+      pcb_draw_line (ddraw, b.X1, b.Y1, b.X1, b.Y2);
+      pcb_draw_line (ddraw, b.X2, b.Y1, b.X2, b.Y2);
     }
 
 #if 1
@@ -1525,23 +1525,23 @@ showedge (edge_t * e)
   if (ddraw == NULL)
     return;
 
-  ddraw->graphics->set_line_cap (ar_gc, Trace_Cap);
-  ddraw->graphics->set_line_width (ar_gc, 1);
-  ddraw->graphics->set_color (ar_gc, Settings.MaskColor);
+  ddraw->set_line_cap (ddraw, Trace_Cap);
+  ddraw->set_line_width (ddraw, 1);
+  ddraw->set_color (ddraw, Settings.MaskColor);
 
   switch (e->expand_dir)
     {
     case NORTH:
-      ddraw->graphics->draw_line (ar_gc, b->X1, b->Y1, b->X2, b->Y1);
+      ddraw->draw_line (ddraw, b->X1, b->Y1, b->X2, b->Y1);
       break;
-    case SOUTH:
-      ddraw->graphics->draw_line (ar_gc, b->X1, b->Y2, b->X2, b->Y2);
+    case SOUTH
+      ddraw->draw_line (ddraw, b->X1, b->Y2, b->X2, b->Y2);
       break;
     case WEST:
-      ddraw->graphics->draw_line (ar_gc, b->X1, b->Y1, b->X1, b->Y2);
+      ddraw->draw_line (ddraw, b->X1, b->Y1, b->X1, b->Y2);
       break;
     case EAST:
-      ddraw->graphics->draw_line (ar_gc, b->X2, b->Y1, b->X2, b->Y2);
+      ddraw->draw_line (ddraw, b->X2, b->Y1, b->X2, b->Y2);
       break;
     default:
       break;
@@ -5166,8 +5166,9 @@ AutoRoute (bool selected)
   ddraw = gui->request_debug_draw ();
   if (ddraw != NULL)
     {
-      ar_gc = ddraw->graphics->make_gc ();
-      ddraw->graphics->set_line_cap (ar_gc, Round_Cap);
+      ar_gc = ddraw->make_gc ();
+      ddraw->use_gc (ar_gc);
+      ddraw->set_line_cap (ddraw, Round_Cap);
     }
 #endif
 
@@ -5333,7 +5334,11 @@ donerouting:
     }
 #ifdef ROUTE_DEBUG
   if (ddraw != NULL)
-    ddraw->finish_debug_draw ();
+    {
+      ddraw->use_gc (NULL);
+      ddraw->destroy_gc (ar_gc);
+      ddraw->finish_debug_draw ();
+    }
 #endif
 
   if (changed)
diff --git a/src/draw.c b/src/draw.c
index 9b45887..07c2221 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -447,19 +447,6 @@ DrawHoles (bool draw_plated, bool draw_unplated, const BoxType *drawn_area)
 }
 
 static void
-_draw_line (hidGC gc, LineType *line)
-{
-  gui->graphics->set_line_cap (gc, Trace_Cap);
-  if (TEST_FLAG (THINDRAWFLAG, PCB))
-    gui->graphics->set_line_width (gc, 0);
-  else
-    gui->graphics->set_line_width (gc, line->Thickness);
-
-  gui->graphics->draw_line (gc, line->Point1.X, line->Point1.Y,
-                                line->Point2.X, line->Point2.Y);
-}
-
-static void
 draw_line (LayerType *layer, LineType *line)
 {
   if (TEST_FLAG (SELECTEDFLAG | FOUNDFLAG, line))
@@ -471,7 +458,7 @@ draw_line (LayerType *layer, LineType *line)
     }
   else
     gui->graphics->set_color (Output.fgGC, layer->Color);
-  _draw_line (Output.fgGC, line);
+  gui->draw_pcb_line (Output.fgGC, line);
 }
 
 static int
@@ -511,7 +498,7 @@ rat_callback (const BoxType * b, void *cl)
                                w * 2, w * 2, 0, 360);
     }
   else
-    _draw_line (Output.fgGC, (LineType *) rat);
+    gui->draw_pcb_line (Output.fgGC, (LineType *) rat);
   return 1;
 }
 
@@ -570,7 +557,7 @@ draw_element_package (ElementType *element)
   /* draw lines, arcs, text and pins */
   ELEMENTLINE_LOOP (element);
   {
-    _draw_line (Output.fgGC, line);
+    gui->draw_pcb_line (Output.fgGC, line);
   }
   END_LOOP;
   ARC_LOOP (element);
@@ -1191,89 +1178,6 @@ GatherPadName (PadType *Pad)
 }
 
 /* ---------------------------------------------------------------------------
- * lowlevel drawing routine for text objects
- */
-void
-DrawTextLowLevel (hidGC gc, TextType *Text, Coord min_line_width)
-{
-  Coord x = 0;
-  unsigned char *string = (unsigned char *) Text->TextString;
-  Cardinal n;
-  FontType *font = &PCB->Font;
-
-  while (string && *string)
-    {
-      /* draw lines if symbol is valid and data is present */
-      if (*string <= MAX_FONTPOSITION && font->Symbol[*string].Valid)
-	{
-	  LineType *line = font->Symbol[*string].Line;
-	  LineType newline;
-
-	  for (n = font->Symbol[*string].LineN; n; n--, line++)
-	    {
-	      /* create one line, scale, move, rotate and swap it */
-	      newline = *line;
-	      newline.Point1.X = SCALE_TEXT (newline.Point1.X + x, Text->Scale);
-	      newline.Point1.Y = SCALE_TEXT (newline.Point1.Y, Text->Scale);
-	      newline.Point2.X = SCALE_TEXT (newline.Point2.X + x, Text->Scale);
-	      newline.Point2.Y = SCALE_TEXT (newline.Point2.Y, Text->Scale);
-	      newline.Thickness = SCALE_TEXT (newline.Thickness, Text->Scale / 2);
-	      if (newline.Thickness < min_line_width)
-		newline.Thickness = min_line_width;
-
-	      RotateLineLowLevel (&newline, 0, 0, Text->Direction);
-
-	      /* the labels of SMD objects on the bottom
-	       * side haven't been swapped yet, only their offset
-	       */
-	      if (TEST_FLAG (ONSOLDERFLAG, Text))
-		{
-		  newline.Point1.X = SWAP_SIGN_X (newline.Point1.X);
-		  newline.Point1.Y = SWAP_SIGN_Y (newline.Point1.Y);
-		  newline.Point2.X = SWAP_SIGN_X (newline.Point2.X);
-		  newline.Point2.Y = SWAP_SIGN_Y (newline.Point2.Y);
-		}
-	      /* add offset and draw line */
-	      newline.Point1.X += Text->X;
-	      newline.Point1.Y += Text->Y;
-	      newline.Point2.X += Text->X;
-	      newline.Point2.Y += Text->Y;
-	      _draw_line (gc, &newline);
-	    }
-
-	  /* move on to next cursor position */
-	  x += (font->Symbol[*string].Width + font->Symbol[*string].Delta);
-	}
-      else
-	{
-	  /* the default symbol is a filled box */
-	  BoxType defaultsymbol = PCB->Font.DefaultSymbol;
-	  Coord size = (defaultsymbol.X2 - defaultsymbol.X1) * 6 / 5;
-
-	  defaultsymbol.X1 = SCALE_TEXT (defaultsymbol.X1 + x, Text->Scale);
-	  defaultsymbol.Y1 = SCALE_TEXT (defaultsymbol.Y1, Text->Scale);
-	  defaultsymbol.X2 = SCALE_TEXT (defaultsymbol.X2 + x, Text->Scale);
-	  defaultsymbol.Y2 = SCALE_TEXT (defaultsymbol.Y2, Text->Scale);
-
-	  RotateBoxLowLevel (&defaultsymbol, 0, 0, Text->Direction);
-
-	  /* add offset and draw box */
-	  defaultsymbol.X1 += Text->X;
-	  defaultsymbol.Y1 += Text->Y;
-	  defaultsymbol.X2 += Text->X;
-	  defaultsymbol.Y2 += Text->Y;
-	  gui->graphics->fill_rect (gc,
-	                            defaultsymbol.X1, defaultsymbol.Y1,
-	                            defaultsymbol.X2, defaultsymbol.Y2);
-
-	  /* move on to next cursor position */
-	  x += size;
-	}
-      string++;
-    }
-}
-
-/* ---------------------------------------------------------------------------
  * draw a via object
  */
 void
diff --git a/src/hid.h b/src/hid.h
index d7974e5..d829aa0 100644
--- a/src/hid.h
+++ b/src/hid.h
@@ -240,7 +240,9 @@ typedef enum
   };
 
 /* Low level drawing API */
-  typedef struct
+  typedef struct HID_DRAW_API HID_DRAW_API;
+
+  struct HID_DRAW_API
   {
     /* Drawing Functions.  Coordinates and distances are ALWAYS in PCB's
        default coordinates (1 nm at the time this comment was written).
@@ -250,6 +252,7 @@ typedef enum
     /* Make an empty graphics context.  */
     hidGC (*make_gc) (void);
     void (*destroy_gc) (hidGC gc_);
+    void (*use_gc) (HID_DRAW_API *dapi, hidGC gc);
     void (*use_mask) (enum mask_mode mode);
 
     /* Set a color.  Names can be like "red" or "#rrggbb" or special
@@ -282,7 +285,8 @@ typedef enum
     void (*fill_polygon) (hidGC gc, int n_coords_, Coord *x, Coord *y);
     void (*fill_rect)    (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2);
 
-  } HID_DRAW_API;
+
+  };
 
 
   typedef struct hid_st HID;
@@ -640,4 +644,16 @@ typedef enum
 }
 #endif
 
+static void
+pr_set_line_width (HID_DRAW_API *pr, Coord width)
+{
+  pr->set_line_width (pr, width);
+}
+
+static void
+pr_set_line_cap (HID_DRAW_API *pr, EndCapStyle style)
+{
+  pr->set_line_cap (pr, style);
+}
+
 #endif
diff --git a/src/hid/common/draw_helpers.c b/src/hid/common/draw_helpers.c
index 0d0851d..7cf1838 100644
--- a/src/hid/common/draw_helpers.c
+++ b/src/hid/common/draw_helpers.c
@@ -2,6 +2,104 @@
 #include "hid.h"
 #include "polygon.h"
 
+
+static void
+draw_pcb_line (hidGC gc, LineType *line)
+{
+  gui->graphics->set_line_cap (gc, Trace_Cap);
+  if (TEST_FLAG (THINDRAWFLAG, PCB))
+    gui->graphics->set_line_width (gc, 0);
+  else
+    gui->graphics->set_line_width (gc, line->Thickness);
+
+  gui->graphics->draw_line (gc,
+                            line->Point1.X, line->Point1.Y,
+                            line->Point2.X, line->Point2.Y);
+}
+
+/* ---------------------------------------------------------------------------
+ * drawing routine for text objects
+ */
+static void
+draw_pcb_text (hidGC gc, TextType *Text, Coord min_line_width)
+{
+  Coord x = 0;
+  unsigned char *string = (unsigned char *) Text->TextString;
+  Cardinal n;
+  FontType *font = &PCB->Font;
+
+  while (string && *string)
+    {
+      /* draw lines if symbol is valid and data is present */
+      if (*string <= MAX_FONTPOSITION && font->Symbol[*string].Valid)
+        {
+          LineType *line = font->Symbol[*string].Line;
+          LineType newline;
+
+          for (n = font->Symbol[*string].LineN; n; n--, line++)
+            {
+              /* create one line, scale, move, rotate and swap it */
+              newline = *line;
+              newline.Point1.X = SCALE_TEXT (newline.Point1.X + x, Text->Scale);
+              newline.Point1.Y = SCALE_TEXT (newline.Point1.Y, Text->Scale);
+              newline.Point2.X = SCALE_TEXT (newline.Point2.X + x, Text->Scale);
+              newline.Point2.Y = SCALE_TEXT (newline.Point2.Y, Text->Scale);
+              newline.Thickness = SCALE_TEXT (newline.Thickness, Text->Scale / 2);
+              if (newline.Thickness < min_line_width)
+                newline.Thickness = min_line_width;
+
+              RotateLineLowLevel (&newline, 0, 0, Text->Direction);
+
+              /* the labels of SMD objects on the bottom
+               * side haven't been swapped yet, only their offset
+               */
+              if (TEST_FLAG (ONSOLDERFLAG, Text))
+                {
+                  newline.Point1.X = SWAP_SIGN_X (newline.Point1.X);
+                  newline.Point1.Y = SWAP_SIGN_Y (newline.Point1.Y);
+                  newline.Point2.X = SWAP_SIGN_X (newline.Point2.X);
+                  newline.Point2.Y = SWAP_SIGN_Y (newline.Point2.Y);
+                }
+              /* add offset and draw line */
+              newline.Point1.X += Text->X;
+              newline.Point1.Y += Text->Y;
+              newline.Point2.X += Text->X;
+              newline.Point2.Y += Text->Y;
+              _draw_line (&newline);
+            }
+
+          /* move on to next cursor position */
+          x += (font->Symbol[*string].Width + font->Symbol[*string].Delta);
+        }
+      else
+        {
+          /* the default symbol is a filled box */
+          BoxType defaultsymbol = PCB->Font.DefaultSymbol;
+          Coord size = (defaultsymbol.X2 - defaultsymbol.X1) * 6 / 5;
+
+          defaultsymbol.X1 = SCALE_TEXT (defaultsymbol.X1 + x, Text->Scale);
+          defaultsymbol.Y1 = SCALE_TEXT (defaultsymbol.Y1, Text->Scale);
+          defaultsymbol.X2 = SCALE_TEXT (defaultsymbol.X2 + x, Text->Scale);
+          defaultsymbol.Y2 = SCALE_TEXT (defaultsymbol.Y2, Text->Scale);
+
+          RotateBoxLowLevel (&defaultsymbol, 0, 0, Text->Direction);
+
+          /* add offset and draw box */
+          defaultsymbol.X1 += Text->X;
+          defaultsymbol.Y1 += Text->Y;
+          defaultsymbol.X2 += Text->X;
+          defaultsymbol.Y2 += Text->Y;
+          gui->graphics->fill_rect (Output.fgGC,
+                                    defaultsymbol.X1, defaultsymbol.Y1,
+                                    defaultsymbol.X2, defaultsymbol.Y2);
+
+          /* move on to next cursor position */
+          x += size;
+        }
+      string++;
+    }
+}
+
 static void
 fill_contour (hidGC gc, PLINE *pl)
 {

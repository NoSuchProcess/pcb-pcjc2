Bottom: e65b1735c8b77d515ec29478985323ecf74db060
Top:    6dc47b167350bde0b71f1207a47fb701465925ea
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2012-11-19 21:49:35 +0000

Split out drawing routines into vfunc table for possible replacement

The aim here is to indirect calls to the various drawing routines such
that a GUI or renderer implementation may swap out different parts of
the rendering operation at will without having to re-implement the
entire drawing stack from scratch.

Each drawing API call will now be passed the drawing API structure as
its first parameter, so we don't rely on this being a global.

As a further clean-up, the graphics context being used by the rendering
routines is now a member of the vfunc table structure. We currently
retain the old Output.*gc members, but only use them (where necessary)
to update the ->gc member of the drawing API structure as rendering
progresses.


---

diff --git a/src/draw.c b/src/draw.c
index 32aacd5..4283810 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -200,7 +200,7 @@ _draw_pv_name (PinType *pv)
 
   if (gui->gui)
     doing_pinout++;
-  DrawTextLowLevel (Output.fgGC, &text, 0);
+  gui->graphics->draw_pcb_text (Output.fgGC, &text, 0);
   if (gui->gui)
     doing_pinout--;
 }
@@ -284,7 +284,7 @@ draw_pad_name (PadType *pad)
   text.Y = box.Y1;
   text.Direction = vert ? 1 : 0;
 
-  DrawTextLowLevel (Output.fgGC, &text, 0);
+  gui->graphics->draw_pcb_text (Output.fgGC, &text, 0);
 }
 
 static void
@@ -350,7 +350,7 @@ draw_element_name (ElementType *element)
     gui->graphics->set_color (Output.fgGC, PCB->ElementColor);
   else
     gui->graphics->set_color (Output.fgGC, PCB->InvisibleObjectsColor);
-  DrawTextLowLevel (Output.fgGC, &ELEMENT_TEXT (PCB, element), PCB->minSlk);
+  gui->graphics->draw_pcb_text (Output.fgGC, &ELEMENT_TEXT (PCB, element), PCB->minSlk);
 }
 
 static int
@@ -448,19 +448,6 @@ DrawHoles (bool draw_plated, bool draw_unplated, const BoxType *drawn_area)
 }
 
 static void
-_draw_line (hidGC gc, LineType *line)
-{
-  gui->graphics->set_line_cap (gc, Trace_Cap);
-  if (TEST_FLAG (THINDRAWFLAG, PCB))
-    gui->graphics->set_line_width (gc, 0);
-  else
-    gui->graphics->set_line_width (gc, line->Thickness);
-
-  gui->graphics->draw_line (gc, line->Point1.X, line->Point1.Y,
-                                line->Point2.X, line->Point2.Y);
-}
-
-static void
 draw_line (LayerType *layer, LineType *line)
 {
   if (TEST_FLAG (SELECTEDFLAG | FOUNDFLAG, line))
@@ -472,7 +459,7 @@ draw_line (LayerType *layer, LineType *line)
     }
   else
     gui->graphics->set_color (Output.fgGC, layer->Color);
-  _draw_line (Output.fgGC, line);
+  gui->graphics->draw_pcb_line (Output.fgGC, line);
 }
 
 static int
@@ -512,7 +499,7 @@ rat_callback (const BoxType * b, void *cl)
                                w * 2, w * 2, 0, 360);
     }
   else
-    _draw_line (Output.fgGC, (LineType *) rat);
+    gui->graphics->draw_pcb_line (Output.fgGC, (LineType *) rat);
   return 1;
 }
 
@@ -571,7 +558,7 @@ draw_element_package (ElementType *element)
   /* draw lines, arcs, text and pins */
   ELEMENTLINE_LOOP (element);
   {
-    _draw_line (Output.fgGC, line);
+    gui->graphics->draw_pcb_line (Output.fgGC, line);
   }
   END_LOOP;
   ARC_LOOP (element);
@@ -1060,7 +1047,7 @@ text_callback (const BoxType * b, void *cl)
     min_silk_line = PCB->minSlk;
   else
     min_silk_line = PCB->minWid;
-  DrawTextLowLevel (Output.fgGC, text, min_silk_line);
+  gui->graphics->draw_pcb_text (Output.fgGC, text, min_silk_line);
   return 1;
 }
 
@@ -1192,89 +1179,6 @@ GatherPadName (PadType *Pad)
 }
 
 /* ---------------------------------------------------------------------------
- * lowlevel drawing routine for text objects
- */
-void
-DrawTextLowLevel (hidGC gc, TextType *Text, Coord min_line_width)
-{
-  Coord x = 0;
-  unsigned char *string = (unsigned char *) Text->TextString;
-  Cardinal n;
-  FontType *font = &PCB->Font;
-
-  while (string && *string)
-    {
-      /* draw lines if symbol is valid and data is present */
-      if (*string <= MAX_FONTPOSITION && font->Symbol[*string].Valid)
-	{
-	  LineType *line = font->Symbol[*string].Line;
-	  LineType newline;
-
-	  for (n = font->Symbol[*string].LineN; n; n--, line++)
-	    {
-	      /* create one line, scale, move, rotate and swap it */
-	      newline = *line;
-	      newline.Point1.X = SCALE_TEXT (newline.Point1.X + x, Text->Scale);
-	      newline.Point1.Y = SCALE_TEXT (newline.Point1.Y, Text->Scale);
-	      newline.Point2.X = SCALE_TEXT (newline.Point2.X + x, Text->Scale);
-	      newline.Point2.Y = SCALE_TEXT (newline.Point2.Y, Text->Scale);
-	      newline.Thickness = SCALE_TEXT (newline.Thickness, Text->Scale / 2);
-	      if (newline.Thickness < min_line_width)
-		newline.Thickness = min_line_width;
-
-	      RotateLineLowLevel (&newline, 0, 0, Text->Direction);
-
-	      /* the labels of SMD objects on the bottom
-	       * side haven't been swapped yet, only their offset
-	       */
-	      if (TEST_FLAG (ONSOLDERFLAG, Text))
-		{
-		  newline.Point1.X = SWAP_SIGN_X (newline.Point1.X);
-		  newline.Point1.Y = SWAP_SIGN_Y (newline.Point1.Y);
-		  newline.Point2.X = SWAP_SIGN_X (newline.Point2.X);
-		  newline.Point2.Y = SWAP_SIGN_Y (newline.Point2.Y);
-		}
-	      /* add offset and draw line */
-	      newline.Point1.X += Text->X;
-	      newline.Point1.Y += Text->Y;
-	      newline.Point2.X += Text->X;
-	      newline.Point2.Y += Text->Y;
-	      _draw_line (gc, &newline);
-	    }
-
-	  /* move on to next cursor position */
-	  x += (font->Symbol[*string].Width + font->Symbol[*string].Delta);
-	}
-      else
-	{
-	  /* the default symbol is a filled box */
-	  BoxType defaultsymbol = PCB->Font.DefaultSymbol;
-	  Coord size = (defaultsymbol.X2 - defaultsymbol.X1) * 6 / 5;
-
-	  defaultsymbol.X1 = SCALE_TEXT (defaultsymbol.X1 + x, Text->Scale);
-	  defaultsymbol.Y1 = SCALE_TEXT (defaultsymbol.Y1, Text->Scale);
-	  defaultsymbol.X2 = SCALE_TEXT (defaultsymbol.X2 + x, Text->Scale);
-	  defaultsymbol.Y2 = SCALE_TEXT (defaultsymbol.Y2, Text->Scale);
-
-	  RotateBoxLowLevel (&defaultsymbol, 0, 0, Text->Direction);
-
-	  /* add offset and draw box */
-	  defaultsymbol.X1 += Text->X;
-	  defaultsymbol.Y1 += Text->Y;
-	  defaultsymbol.X2 += Text->X;
-	  defaultsymbol.Y2 += Text->Y;
-	  gui->graphics->fill_rect (gc,
-	                            defaultsymbol.X1, defaultsymbol.Y1,
-	                            defaultsymbol.X2, defaultsymbol.Y2);
-
-	  /* move on to next cursor position */
-	  x += size;
-	}
-      string++;
-    }
-}
-
-/* ---------------------------------------------------------------------------
  * draw a via object
  */
 void
diff --git a/src/draw.h b/src/draw.h
index 88e2349..b58e5cb 100644
--- a/src/draw.h
+++ b/src/draw.h
@@ -44,7 +44,6 @@ void DrawPadName (PadType *);
 void DrawLine (LayerType *, LineType *);
 void DrawArc (LayerType *, ArcType *);
 void DrawText (LayerType *, TextType *);
-void DrawTextLowLevel (hidGC gc, TextType *, Coord);
 void DrawPolygon (LayerType *, PolygonType *);
 void DrawElement (ElementType *);
 void DrawElementName (ElementType *);
diff --git a/src/hid/common/draw_helpers.c b/src/hid/common/draw_helpers.c
index c1de57b..2e09e1e 100644
--- a/src/hid/common/draw_helpers.c
+++ b/src/hid/common/draw_helpers.c
@@ -1,8 +1,108 @@
 #include "global.h"
 #include "hid.h"
 #include "hid_draw.h"
+#include "data.h" /* For nasty global "PCB" variable */
+#include "rotate.h" /* For RotateLineLowLevel() */
 #include "polygon.h"
 
+
+static void
+common_draw_pcb_line (hidGC gc, LineType *line)
+{
+  gui->graphics->set_line_cap (gc, Trace_Cap);
+  if (TEST_FLAG (THINDRAWFLAG, PCB))
+    gui->graphics->set_line_width (gc, 0);
+  else
+    gui->graphics->set_line_width (gc, line->Thickness);
+
+  gui->graphics->draw_line (gc,
+                            line->Point1.X, line->Point1.Y,
+                            line->Point2.X, line->Point2.Y);
+}
+
+/* ---------------------------------------------------------------------------
+ * drawing routine for text objects
+ */
+static void
+common_draw_pcb_text (hidGC gc, TextType *Text, Coord min_line_width)
+{
+  Coord x = 0;
+  unsigned char *string = (unsigned char *) Text->TextString;
+  Cardinal n;
+  FontType *font = &PCB->Font;
+
+  while (string && *string)
+    {
+      /* draw lines if symbol is valid and data is present */
+      if (*string <= MAX_FONTPOSITION && font->Symbol[*string].Valid)
+        {
+          LineType *line = font->Symbol[*string].Line;
+          LineType newline;
+
+          for (n = font->Symbol[*string].LineN; n; n--, line++)
+            {
+              /* create one line, scale, move, rotate and swap it */
+              newline = *line;
+              newline.Point1.X = SCALE_TEXT (newline.Point1.X + x, Text->Scale);
+              newline.Point1.Y = SCALE_TEXT (newline.Point1.Y, Text->Scale);
+              newline.Point2.X = SCALE_TEXT (newline.Point2.X + x, Text->Scale);
+              newline.Point2.Y = SCALE_TEXT (newline.Point2.Y, Text->Scale);
+              newline.Thickness = SCALE_TEXT (newline.Thickness, Text->Scale / 2);
+              if (newline.Thickness < min_line_width)
+                newline.Thickness = min_line_width;
+
+              RotateLineLowLevel (&newline, 0, 0, Text->Direction);
+
+              /* the labels of SMD objects on the bottom
+               * side haven't been swapped yet, only their offset
+               */
+              if (TEST_FLAG (ONSOLDERFLAG, Text))
+                {
+                  newline.Point1.X = SWAP_SIGN_X (newline.Point1.X);
+                  newline.Point1.Y = SWAP_SIGN_Y (newline.Point1.Y);
+                  newline.Point2.X = SWAP_SIGN_X (newline.Point2.X);
+                  newline.Point2.Y = SWAP_SIGN_Y (newline.Point2.Y);
+                }
+              /* add offset and draw line */
+              newline.Point1.X += Text->X;
+              newline.Point1.Y += Text->Y;
+              newline.Point2.X += Text->X;
+              newline.Point2.Y += Text->Y;
+              gui->graphics->draw_pcb_line (gc, &newline);
+            }
+
+          /* move on to next cursor position */
+          x += (font->Symbol[*string].Width + font->Symbol[*string].Delta);
+        }
+      else
+        {
+          /* the default symbol is a filled box */
+          BoxType defaultsymbol = PCB->Font.DefaultSymbol;
+          Coord size = (defaultsymbol.X2 - defaultsymbol.X1) * 6 / 5;
+
+          defaultsymbol.X1 = SCALE_TEXT (defaultsymbol.X1 + x, Text->Scale);
+          defaultsymbol.Y1 = SCALE_TEXT (defaultsymbol.Y1, Text->Scale);
+          defaultsymbol.X2 = SCALE_TEXT (defaultsymbol.X2 + x, Text->Scale);
+          defaultsymbol.Y2 = SCALE_TEXT (defaultsymbol.Y2, Text->Scale);
+
+          RotateBoxLowLevel (&defaultsymbol, 0, 0, Text->Direction);
+
+          /* add offset and draw box */
+          defaultsymbol.X1 += Text->X;
+          defaultsymbol.Y1 += Text->Y;
+          defaultsymbol.X2 += Text->X;
+          defaultsymbol.Y2 += Text->Y;
+          gui->graphics->fill_rect (gc,
+                                    defaultsymbol.X1, defaultsymbol.Y1,
+                                    defaultsymbol.X2, defaultsymbol.Y2);
+
+          /* move on to next cursor position */
+          x += size;
+        }
+      string++;
+    }
+}
+
 static void
 fill_contour (hidGC gc, PLINE *pl)
 {
@@ -470,6 +570,9 @@ common_thindraw_pcb_pv (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bo
 void
 common_draw_helpers_init (HID_DRAW *graphics)
 {
+  graphics->draw_pcb_line        = common_draw_pcb_line;
+  graphics->draw_pcb_text        = common_draw_pcb_text;
+
   graphics->fill_pcb_polygon     = common_fill_pcb_polygon;
   graphics->thindraw_pcb_polygon = common_thindraw_pcb_polygon;
   graphics->fill_pcb_pad         = common_fill_pcb_pad;
diff --git a/src/hid_draw.h b/src/hid_draw.h
index 28fc50f..5b1f7e9 100644
--- a/src/hid_draw.h
+++ b/src/hid_draw.h
@@ -51,6 +51,9 @@ struct hid_draw_st
 
   /* The following APIs render using PCB data-structures, not immediate parameters */
 
+  void (*draw_pcb_line) (hidGC gc, LineType *line);
+  void (*draw_pcb_text) (hidGC gc, TextType *, Coord);
+
   void (*fill_pcb_polygon) (hidGC gc, PolygonType *poly, const BoxType *clip_box);
   void (*thindraw_pcb_polygon) (hidGC gc, PolygonType *poly, const BoxType *clip_box);
   void (*fill_pcb_pad) (hidGC gc, PadType *pad, bool clip, bool mask);
diff --git a/src/print.c b/src/print.c
index fc6f9ff..69328e7 100644
--- a/src/print.c
+++ b/src/print.c
@@ -112,7 +112,7 @@ text_at (hidGC gc, int x, int y, int align, char *fmt, ...)
   t.X -= w * (align & 3) / 2;
   if (t.X < 0)
     t.X = 0;
-  DrawTextLowLevel (gc, &t, 0);
+  gui->graphics->draw_pcb_text (gc, &t, 0);
   if (align & 8)
     fab_line (gc, t.X,
               t.Y + SCALE_TEXT (font->MaxHeight, t.Scale) + MIL_TO_COORD(10),
@@ -347,7 +347,7 @@ PrintFab (hidGC gc)
       END_LOOP;
       TEXT_LOOP (layer);
       {
-	DrawTextLowLevel (gc, text, 0);
+	gui->graphics->draw_pcb_text (gc, text, 0);
       }
       END_LOOP;
       gui->graphics->set_line_width (gc, FAB_LINE_W);

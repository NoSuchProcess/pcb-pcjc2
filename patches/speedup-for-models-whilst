Bottom: a9c620f7d084210eae091c39fb19e0eae4dd660e
Top:    e1de0895b0c8495951207a5a1b2ed96185411320
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2015-04-12 17:08:54 +0100

Speedup for models whilst debugging


---

diff --git a/src/hid/step/assembly.cpp b/src/hid/step/assembly.cpp
index dbbbdaf..27d4766 100644
--- a/src/hid/step/assembly.cpp
+++ b/src/hid/step/assembly.cpp
@@ -844,7 +844,12 @@ append_model_from_file (Registry *registry,
 //  int file_increment = ( int )( ( ceil( ( max_existing_file_id + 99.0 ) / 1000.0 ) + 1.0 ) * 1000.0 ); /* XXX: RELYING ON SCL NOT CHANGING */
 //  std::cout << "INFO: Expecting a to add " << file_increment << " to entity names" << std::endl;
 
+#if 1
   STEPfile sfile = STEPfile (*registry, *instance_list, "", false);
+#else
+  STEPfile *sfilep = new STEPfile (*registry, *instance_list, "", false);
+  STEPfile &sfile = *sfilep; /* Let us deliberately leak STEPfile for a performance test */
+#endif
 
   sfile.AppendExchangeFile (filename);
 
diff --git a/src/hid/step/step.c b/src/hid/step/step.c
index 5d4c67e..bbd625e 100644
--- a/src/hid/step/step.c
+++ b/src/hid/step/step.c
@@ -867,6 +867,8 @@ step_do_export (HID_Attr_Val * options)
         double ax, ay, az;
         double rx, ry, rz;
         double rotation;
+        double cos_rot;
+        double sin_rot;
         GList *model_iter;
 
         /* Skip if the component doesn't have a STEP-AP214 3d_model */
@@ -938,16 +940,31 @@ step_do_export (HID_Attr_Val * options)
             models = g_list_append (models, model);
           }
 
+        cos_rot = cos (rotation * M_PI / 180.);
+        sin_rot = sin (rotation * M_PI / 180.);
+
+        // Rotation of part on board
+        // (NB: Y flipped from normal right handed convention)
+        //[cos -sin   0] [x] = [xcos - ysin]
+        //[sin  cos   0] [y]   [xsin + ycos]
+        //[  0    0   1] [z]   [z          ]
+
+        // Flip of part to backside of board
+        // [  1   0   0] [x] = [ x]
+        // [  0  -1   0] [y] = [-y]
+        // [  0   0  -1] [z] = [-z]
+
         instance = g_new0 (struct assembly_model_instance, 1);
         instance->name = NAMEONPCB_NAME (element);
-        instance->ox = COORD_TO_MM (element->MarkX) + ox,
-        instance->oy = COORD_TO_MM (element->MarkY) + oy,
-        instance->oz = on_solder_negate * -COORD_TO_MM (HACK_BOARD_THICKNESS) / 2.0 + oz; /* XXX: THINK ABOUT HOW WE FLIP FOR NON-TRIVIAL STARING TRANSFORMS */
-        instance->ax = on_solder_negate * ax,                       /* XXX: THINK ABOUT HOW WE FLIP TO THE BACKSIDE FOR NON-TRIVIAL STARING TRANSFORMS */
-        instance->ay = on_solder_negate * ay,                       /* XXX: ALSO THINK ABOUT HOW WE ROTATE THE COMPONENT BY ANGLE "rotation"           */
+        instance->ox = COORD_TO_MM (element->MarkX) +                    ( ox * cos_rot + oy * sin_rot),
+        instance->oy = COORD_TO_MM (element->MarkY) + on_solder_negate * (-ox * sin_rot + oy * cos_rot),
+        instance->oz = on_solder_negate * -COORD_TO_MM (HACK_BOARD_THICKNESS) / 2.0 + on_solder_negate * oz;
+        instance->ax =                    ( ax * cos_rot + ay * sin_rot),
+        instance->ay = on_solder_negate * (-ax * sin_rot + ay * cos_rot),
         instance->az = on_solder_negate * az;
-        instance->rx = rx, instance->ry = ry,  instance->rz = rz; /* XXX: THINK ABOUT HOW WE FLIP TO THE BACKSIDE FOR NON-TRIVIAL STARING TRANSFORMS */
-                                                                   /* XXX: ALSO THINK ABOUT HOW WE ROTATE THE COMPONENT BY ANGLE "rotation"           */
+        instance->rx =                    ( rx * cos_rot + ry * sin_rot), /* XXX: SHOULD THIS FACTOR IN on_solder_negate? */
+        instance->ry = on_solder_negate * (-rx * sin_rot + ry * cos_rot), /* XXX: SHOULD THIS FACTOR IN ol_solder_negaet? */
+        instance->rz = on_solder_negate * rz;
         model->instances = g_list_append (model->instances, instance);
 
       }
diff --git a/src/polygon.c b/src/polygon.c
index 8834733..fa3a714 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -2110,6 +2110,8 @@ pv_outline_callback (const BoxType * b, void *cl)
     }
   else
     {
+      /* NOT FROM ELEMENT, DROP HOLE */
+      return 1;
       feature_name = STRDUP(pv->Name);
     }
 
diff --git a/src/polygon.h b/src/polygon.h
index 3737f35..767c919 100644
--- a/src/polygon.h
+++ b/src/polygon.h
@@ -34,7 +34,8 @@
 
 /* Implementation constants */
 
-#define POLY_CIRC_SEGS 40
+#define POLY_CIRC_SEGS 8
+//#define POLY_CIRC_SEGS 40
 #define POLY_CIRC_SEGS_F ((float)POLY_CIRC_SEGS)
 
 /* adjustment to make the segments outline the circle rather than connect
diff --git a/src/polygon1.c b/src/polygon1.c
index 04518c3..76e989d 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -1564,7 +1564,7 @@ SubJ_Rule (char p, VNODE * v, DIRECTION * cdir)
   // XXX: FIXME: NO cdir set for this case, e.g. possible no initialisation
   if (*cdir == UNINITIALISED)
     {
-      printf ("UNINITIALISED directin in SubJ_Rule\n");
+//      printf ("UNINITIALISED directin in SubJ_Rule\n");
       if (p == 'A')
 	*cdir = FORW;
       else

Bottom: f22565275260c42d273d71cac7aafe787657b348
Top:    8505488243f1095f2a5ca8377c021f9e85e4c44b
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2008-10-10 11:17:57 +0100

Make pieces of a clipped polygon a distinct object type


---

diff --git a/src/create.c b/src/create.c
index bbfd52f..53f38f1 100644
--- a/src/create.c
+++ b/src/create.c
@@ -602,7 +602,10 @@ CreateNewPolygon (LayerTypePtr Layer, FlagType Flags)
   /* copy values */
   polygon->Flags = Flags;
   polygon->ID = ID++;
-  polygon->Clipped = NULL;
+  polygon->Pieces = NULL;
+  polygon->PiecesN = 0;
+  polygon->PiecesMax = 0;
+//  polygon->Clipped = NULL;
   polygon->NoHoles = NULL;
   polygon->NoHolesValid = 0;
   return (polygon);
diff --git a/src/global.h b/src/global.h
index 7763c80..5e6b6c8 100644
--- a/src/global.h
+++ b/src/global.h
@@ -198,12 +198,25 @@ typedef struct
   void *Element;
 } TextType, *TextTypePtr;
 
+typedef struct			/* holds information about a polygon piece */
+{
+  ANYOBJECTFIELDS;
+  PLINE *contours;
+//  POLYAREA *NoHoles;
+//  POlyAREA *NoHolesValid;
+} PolygonPieceType, *PolygonPieceTypePtr;
+
+
 typedef struct			/* holds information about a polygon */
 {
   ANYOBJECTFIELDS;
   Cardinal PointN,		/* number of points in polygon */
     PointMax;			/* max number from malloc() */
-  POLYAREA *Clipped;		/* the clipped region of this polygon */
+  PolygonPieceTypePtr Pieces;
+//  rtree_t *pieces_tree;		/* r_tree for pieces */
+  Cardinal PiecesN;		/* number of pieces */
+  Cardinal PiecesMax;		/* max number from malloc() */
+//  POLYAREA *Clipped;		/* the clipped region of this polygon */
   POLYAREA *NoHoles;		/* the polygon broken into hole-less regions */
   int NoHolesValid;		/* Is the NoHoles polygon up to date? */
   PointTypePtr Points;		/* data */
diff --git a/src/mymem.c b/src/mymem.c
index ffa4dad..2b0a415 100644
--- a/src/mymem.c
+++ b/src/mymem.c
@@ -450,6 +450,28 @@ GetPointMemoryInPolygon (PolygonTypePtr Polygon)
 }
 
 /* ---------------------------------------------------------------------------
+ * gets the next slot for a piece in a polygon struct, allocates memory
+ * if necessary
+ */
+PointTypePtr
+GetPolygonPieceMemoryInPolygon (PolygonTypePtr Polygon)
+{
+  PolygonPieceTypePtr pieces = Polygon->Pieces;
+
+  /* realloc new memory if necessary and clear it */
+  if (Polygon->PiecesN >= Polygon->PiecesMax)
+    {
+      Polygon->PiecesMax += STEP_POLYGONPIECES;
+      pieces = MyRealloc (pieces, Polygon->PiecesMax * sizeof (PolygonPiecesType),
+			  "GetPolygonPiecesMemoryInPolygon()");
+      Polygon->Pieces = pieces;
+      memset (pieces + Polygon->PiecesN, 0,
+	      STEP_POLYGONPIECES * sizeof (PiecesType));
+    }
+  return (pieces + Polygon->PiecesN++);
+}
+
+/* ---------------------------------------------------------------------------
  * get next slot for an element, allocates memory if necessary
  */
 ElementTypePtr
diff --git a/src/mymem.h b/src/mymem.h
index b9d4de1..6fe104d 100644
--- a/src/mymem.h
+++ b/src/mymem.h
@@ -58,6 +58,7 @@
 #define	STEP_UNDOLIST		500
 #define	STEP_POLYGON		10
 #define	STEP_POLYGONPOINT	10
+#define	STEP_POLYGONPIECES	10
 #define	STEP_LIBRARYMENU	10
 #define	STEP_LIBRARYENTRY	20
 #define	STEP_RUBBERBAND		100
@@ -82,6 +83,7 @@ RatTypePtr GetRatMemory (DataTypePtr);
 TextTypePtr GetTextMemory (LayerTypePtr);
 PolygonTypePtr GetPolygonMemory (LayerTypePtr);
 PointTypePtr GetPointMemoryInPolygon (PolygonTypePtr);
+PolygonPieceTypePtr GetPolygonPieceMemoryInPolygon (PolygonTypePtr);
 ElementTypePtr GetElementMemory (DataTypePtr);
 BoxTypePtr GetBoxMemory (BoxListTypePtr);
 ConnectionTypePtr GetConnectionMemory (NetTypePtr);
diff --git a/src/rats.c b/src/rats.c
index 27ff95b..f381c1c 100644
--- a/src/rats.c
+++ b/src/rats.c
@@ -507,7 +507,7 @@ GatherSubnets (NetListTypePtr Netl, Boolean NoWarn, Boolean AndRats)
       /* add polygons so the auto-router can see them as targets */
       ALLPOLYGON_LOOP (PCB->Data);
       {
-	if (TEST_FLAG (DRCFLAG, polygon) && polygon->PointN == 4)
+	if (TEST_FLAG (DRCFLAG, polygon))
 	  {
 	    conn = GetConnectionMemory (a);
 	    /* make point on a vertex */

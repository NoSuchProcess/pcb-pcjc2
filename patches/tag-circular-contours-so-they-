Bottom: 15d2d855c4256391cc652e50261cc3dff44dbb0e
Top:    91e0748f6a40f1f295a0e74ad65dfcdc8448126b
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-11-14 02:12:30 +0000

polygons: Tag circular contours so they can be special-cased when drawing.

Tagging circular contours allows GUIs (if they wish) to draw circular
holes in polygons more accurately, and potentially faster - depending
on whether they use mask based rendering or rely on the dicer.

When zoomed far out (and using a mask based scheme), the drawing routine
can use a lower vertex count approximation to the contour - leading to
rendering speed improvements. This is used to reasonable effect in the
experimental OpenGL branch.

Modify hid/common/draw_helpers.c to use these tags when thin-drawing
polygon contours with common_thindraw_pcb_polygon(). This allows the
GUI to change the level of detail rendered with zoom, and serves to
test this feature.

DRC checking and output are still done using the fixed resolution
approximation present in the polygon contour, so in this respect -
it makes rendering somewhat unfaithful to the final output.


---

diff --git a/src/hid/common/draw_helpers.c b/src/hid/common/draw_helpers.c
index e975f3b..d9ded42 100644
--- a/src/hid/common/draw_helpers.c
+++ b/src/hid/common/draw_helpers.c
@@ -29,13 +29,20 @@ static void thindraw_contour (hidGC gc, PLINE *pl)
   int last_x, last_y;
   int this_x, this_y;
 
+  gui->set_line_width (gc, 0);
+  gui->set_line_cap (gc, Round_Cap);
+
+  /* If the contour is round, use an arc drawing routine. */
+  if (pl->is_round)
+    {
+      gui->draw_arc (gc, pl->cx, pl->cy, pl->radius, pl->radius, 0, 360);
+      return;
+    }
+
   /* Need at least two points in the contour */
   if (pl->head.next == NULL)
     return;
 
-  gui->set_line_width (gc, 0);
-  gui->set_line_cap (gc, Round_Cap);
-
   last_x = pl->head.point[0];
   last_y = pl->head.point[1];
   v = pl->head.next;
@@ -176,6 +183,7 @@ void common_fill_pcb_polygon (hidGC gc, PolygonType *poly,
 static int thindraw_hole_cb (PLINE *pl, void *user_data)
 {
   hidGC gc = user_data;
+
   thindraw_contour (gc, pl);
   return 0;
 }
diff --git a/src/polyarea.h b/src/polyarea.h
index 6652fce..958498b 100644
--- a/src/polyarea.h
+++ b/src/polyarea.h
@@ -99,6 +99,10 @@ struct PLINE
     unsigned int Count;
     double area;
     rtree_t *tree;
+    int is_round;
+    int cx;
+    int cy;
+    int radius;
     struct {
       unsigned int status:3;
       unsigned int orient:1;
diff --git a/src/polygon.c b/src/polygon.c
index 71cfd60..365539a 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -336,6 +336,10 @@ CirclePoly (LocationType x, LocationType y, BDimension radius)
   if ((contour = poly_NewContour (v)) == NULL)
     return NULL;
   frac_circle (contour, x, y, v, 1);
+  contour->is_round = TRUE;
+  contour->cx = x;
+  contour->cy = y;
+  contour->radius = radius;
   return ContourToPoly (contour);
 }
 
diff --git a/src/polygon1.c b/src/polygon1.c
index eb4819d..2ffd7cb 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -1829,6 +1829,10 @@ poly_IniContour (PLINE * c)
   c->head.next = c->head.prev = &c->head;
   c->xmin = c->ymin = 0x7fffffff;
   c->xmax = c->ymax = 0x80000000;
+  c->is_round = FALSE;
+  c->cx = 0;
+  c->cy = 0;
+  c->radius = 0;
 }
 
 PLINE *

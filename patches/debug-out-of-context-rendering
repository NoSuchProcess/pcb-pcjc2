Bottom: 8622881e6243c67b96ac922162aaddf03daa2098
Top:    ee34388733898c31f005bd4bcf09d162c1e5f85c
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-05-03 01:15:13 +0100

Debug out of context rendering


---

diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index 3178ee7..e74bbae 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -48,6 +48,25 @@ RCSID ("$Id: $");
 triangle_buffer buffer;
 float global_depth = 0;
 
+static bool in_context = false;
+
+#define CHECK_IS_IN_CONTEXT(retcode) \
+  do { \
+    if (!in_context) { \
+      fprintf (stderr, "hidgl: Drawing called out of context in function %s\n", \
+             __FUNCTION__); \
+      return retcode; \
+    } \
+  } while (0)
+
+void
+hidgl_in_context (bool is_in_context)
+{
+  if (in_context == is_in_context)
+    fprintf (stderr, "hidgl: hidgl_in_context called with nested value!\n");
+  in_context = is_in_context;
+}
+
 #if 0
 triangle_array *
 hidgl_new_triangle_array (void)
@@ -59,6 +78,7 @@ hidgl_new_triangle_array (void)
 void
 hidgl_init_triangle_array (triangle_buffer *buffer)
 {
+  CHECK_IS_IN_CONTEXT ();
   glEnableClientState (GL_VERTEX_ARRAY);
   glVertexPointer (3, GL_FLOAT, 0, buffer->triangle_array);
   buffer->triangle_count = 0;
@@ -68,6 +88,7 @@ hidgl_init_triangle_array (triangle_buffer *buffer)
 void
 hidgl_flush_triangles (triangle_buffer *buffer)
 {
+  CHECK_IS_IN_CONTEXT ();
   if (buffer->triangle_count == 0)
     return;
 
@@ -79,6 +100,7 @@ hidgl_flush_triangles (triangle_buffer *buffer)
 void
 hidgl_ensure_triangle_space (triangle_buffer *buffer, int count)
 {
+  CHECK_IS_IN_CONTEXT ();
   if (count > TRIANGLE_ARRAY_SIZE)
     {
       fprintf (stderr, "Not enough space in vertex buffer\n");
@@ -179,6 +201,7 @@ static void draw_cap (double width, int x, int y, double angle, double scale)
   int slices = calc_slices (radius / scale, M_PI);
   int i;
 
+  CHECK_IS_IN_CONTEXT ();
   if (slices < MIN_TRIANGLES_PER_CAP)
     slices = MIN_TRIANGLES_PER_CAP;
 
@@ -207,6 +230,7 @@ hidgl_draw_line (int cap, double width, int x1, int y1, int x2, int y2, double s
   int circular_caps = 0;
   int hairline = 0;
 
+  CHECK_IS_IN_CONTEXT ();
   if (width == 0.0)
     hairline = 1;
 
@@ -290,6 +314,7 @@ hidgl_draw_arc (double width, int x, int y, int rx, int ry,
   int i;
   int hairline = 0;
 
+  CHECK_IS_IN_CONTEXT ();
   if (width == 0.0)
     hairline = 1;
 
@@ -353,6 +378,7 @@ hidgl_draw_arc (double width, int x, int y, int rx, int ry,
 void
 hidgl_draw_rect (int x1, int y1, int x2, int y2)
 {
+  CHECK_IS_IN_CONTEXT ();
   glBegin (GL_LINE_LOOP);
   glVertex3f (x1, y1, global_depth);
   glVertex3f (x1, y2, global_depth);
@@ -372,6 +398,7 @@ hidgl_fill_circle (int vx, int vy, int vr, double scale)
   int slices;
   int i;
 
+  CHECK_IS_IN_CONTEXT ();
   slices = calc_slices (vr / scale, 2 * M_PI);
 
   if (slices < MIN_TRIANGLES_PER_CIRCLE)
@@ -518,6 +545,7 @@ hidgl_fill_polygon (int n_coords, int *x, int *y)
   GLUtesselator *tobj;
   GLdouble *vertices;
 
+  CHECK_IS_IN_CONTEXT ();
 //  return;
 
   assert (n_coords > 0);
@@ -601,6 +629,7 @@ hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale
   struct do_hole_info info;
   int stencil_bit;
 
+  CHECK_IS_IN_CONTEXT ();
   info.scale = scale;
   global_scale = scale;
 
@@ -668,6 +697,7 @@ hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale
 void
 hidgl_fill_rect (int x1, int y1, int x2, int y2)
 {
+  CHECK_IS_IN_CONTEXT ();
   hidgl_ensure_triangle_space (&buffer, 2);
   hidgl_add_triangle (&buffer, x1, y1, x1, y2, x2, y2);
   hidgl_add_triangle (&buffer, x2, y1, x2, y2, x1, y1);
@@ -676,6 +706,7 @@ hidgl_fill_rect (int x1, int y1, int x2, int y2)
 void
 hidgl_init (void)
 {
+  CHECK_IS_IN_CONTEXT ();
   glGetIntegerv (GL_STENCIL_BITS, &stencil_bits);
 
   if (stencil_bits == 0)
@@ -701,6 +732,7 @@ hidgl_stencil_bits (void)
 static void
 hidgl_clean_unassigned_stencil (void)
 {
+  CHECK_IS_IN_CONTEXT ();
   glPushAttrib (GL_STENCIL_BUFFER_BIT);
   glStencilMask (~assigned_bits);
   glClearStencil (0);
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index 43d8aa2..030a550 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -33,6 +33,7 @@ typedef struct {
 extern triangle_buffer buffer;
 extern float global_depth;
 
+void hidgl_in_context (bool is_in_context);
 void hidgl_init_triangle_array (triangle_buffer *buffer);
 void hidgl_flush_triangles (triangle_buffer *buffer);
 void hidgl_ensure_triangle_space (triangle_buffer *buffer, int count);
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 1c88900..eaa31ba 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -1894,6 +1894,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   ghid_start_drawing (port);
 
+  hidgl_in_context (true);
   hidgl_init ();
   check_gl_drawing_ok_hack = true;
 
@@ -2073,6 +2074,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   hidgl_flush_triangles (&buffer);
 
   check_gl_drawing_ok_hack = false;
+  hidgl_in_context (false);
   ghid_end_drawing (port);
 
   g_timer_start (priv->time_since_expose);
@@ -2144,6 +2146,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   gport->render_priv->in_context = true;
 
   check_gl_drawing_ok_hack = true;
+  hidgl_in_context (true);
 
   glEnable (GL_BLEND);
   glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
@@ -2192,6 +2195,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
     glFlush ();
 
   check_gl_drawing_ok_hack = false;
+  hidgl_in_context (false);
 
   /* end drawing to current GL-context */
   gport->render_priv->in_context = false;
@@ -2265,6 +2269,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
 
   save_check_gl_drawing_ok_hack = check_gl_drawing_ok_hack;
   check_gl_drawing_ok_hack = true;
+  hidgl_in_context (true);
 
   glEnable (GL_BLEND);
   glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
@@ -2311,6 +2316,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   glFlush ();
 
   check_gl_drawing_ok_hack = save_check_gl_drawing_ok_hack;
+  hidgl_in_context (false);
 
   /* end drawing to current GL-context */
   gport->render_priv->in_context = false;

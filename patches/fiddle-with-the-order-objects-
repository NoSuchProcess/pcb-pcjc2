Bottom: c65c11a3924d7c5384b83c0cf8ad47e6003d95f9
Top:    da0a4fa320547a947d6a1668a1dd3d8a12ca42e8
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2008-10-12 23:15:16 +0100

Fiddle with the order objects are clipped from pours

Seems to save a little bit of time clipping polygons at startup. It seems
that clipping simpler, but common objects first, such as lines, means
those clips go faster. We then clip the more complex items which introduce
more complexity to the polygons.



---

diff --git a/src/pour.c b/src/pour.c
index 03c3911..491c44c 100644
--- a/src/pour.c
+++ b/src/pour.c
@@ -637,16 +637,17 @@ ClearPour (DataTypePtr Data, LayerTypePtr Layer, PourType * pour,
 
   if (setjmp (info.env) == 0)
     {
-      r  = r_search (Data->via_tree, &region, NULL, pin_sub_callback, &info);
-      r += r_search (Data->pin_tree, &region, NULL, pin_sub_callback, &info);
+      r = 0;
       GROUP_LOOP (Data, group);
       {
+        r += r_search (layer->pour_tree, &region, NULL, pour_sub_callback, &info);
         r += r_search (layer->line_tree, &region, NULL, line_sub_callback, &info);
         r += r_search (layer->arc_tree,  &region, NULL, arc_sub_callback,  &info);
         r += r_search (layer->text_tree, &region, NULL, text_sub_callback, &info);
-        r += r_search (layer->pour_tree, &region, NULL, pour_sub_callback, &info);
       }
       END_LOOP;
+      r += r_search (Data->via_tree, &region, NULL, pin_sub_callback, &info);
+      r += r_search (Data->pin_tree, &region, NULL, pin_sub_callback, &info);
       if (info.solder || group == Group (Data, max_layer + COMPONENT_LAYER))
         r += r_search (Data->pad_tree, &region, NULL, pad_sub_callback, &info);
     }
diff --git a/src/rtree.c b/src/rtree.c
index 36333d0..c444e61 100644
--- a/src/rtree.c
+++ b/src/rtree.c
@@ -983,31 +983,6 @@ __r_insert_node (struct rtree_node *node, const BoxType * query,
             }
         }
 
-      /* Ok, so we're still here - look for the best child to push it into */
-      assert (node->u.kids[0]);
-      if ((best_score = penalty (node->u.kids[0], query)) == 0)
-        {
-          __r_insert_node (node->u.kids[0], query, manage, False);
-          sort_node (node);
-          return;
-        }
-      best_node = node->u.kids[0];
-      for (i = 1; i < M_SIZE; i++)
-        {
-          if (!node->u.kids[i])
-            break;
-          if ((score = penalty (node->u.kids[i], query)) == 0)
-            {
-              __r_insert_node (node->u.kids[i], query, manage, False);
-              sort_node (node);
-              return;
-            }
-          else if (score < best_score)
-            {
-              best_score = score;
-              best_node = node->u.kids[i];
-            }
-        }
       /* see if there is room for a new leaf node */
       if (node->u.kids[0]->flags.is_leaf && i < M_SIZE)
         {
@@ -1025,7 +1000,20 @@ __r_insert_node (struct rtree_node *node, const BoxType * query,
           return;
         }
 
-      /* didn't find an enclosure, so use the best one */
+      /* Ok, so we're still here - look for the best child to push it into */
+      best_score = penalty (node->u.kids[0], query);
+      best_node = node->u.kids[0];
+      for (i = 1; i < M_SIZE; i++)
+        {
+          if (!node->u.kids[i])
+            break;
+          score = penalty (node->u.kids[i], query);
+          if (score < best_score)
+            {
+              best_score = score;
+              best_node = node->u.kids[i];
+            }
+        }
       __r_insert_node (best_node, query, manage, True);
       sort_node (node);
       return;

Bottom: aabb7014ad38f47e53fe09832e18b9d42d833cf8
Top:    428551838061a9764d9bd7c9fd7c83fc1215787f
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-10-14 13:05:12 +0100

Shiny 3D eye-candy

Experiments in progress - don't expect this to work yet!


---

diff --git a/src/draw.c b/src/draw.c
index cfec799..10ba3f2 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -308,6 +308,10 @@ hole_callback (const BoxType * b, void *cl)
 {
   PinTypePtr pin = (PinTypePtr) b;
   int plated = cl ? *(int *) cl : -1;
+
+  if (!TEST_FLAG (SQUAREFLAG,pin))
+    return;
+
   switch (plated)
     {
     case -1:
@@ -382,6 +386,31 @@ PrintAssembly (const BoxType * drawn_area, int side_group, int swap_ident)
   SWAP_IDENT = save_swap;
 }
 
+static int
+via_callback (const BoxType * b, void *cl)
+{
+  PinTypePtr via = (PinTypePtr) b;
+//  if (via->Mask)
+    DrawPlainVia (via, False);
+  return 1;
+}
+
+static int
+pin_callback (const BoxType * b, void *cl)
+{
+  DrawPlainPin ((PinTypePtr) b, False);
+  return 1;
+}
+
+static int
+pad_callback (const BoxType * b, void *cl)
+{
+  PadTypePtr pad = (PadTypePtr) b;
+  if (FRONT (pad))
+    DrawPad (pad, 0);
+  return 1;
+}
+
 /* ---------------------------------------------------------------------------
  * initializes some identifiers for a new zoom factor and redraws whole screen
  */
@@ -470,6 +499,20 @@ DrawEverything (BoxTypePtr drawn_area)
 		}
 	    }
 	  gui->set_layer (NULL, SL (FINISHED, 0), 0);
+	  if (gui->gui) {
+            /* draw element pins */
+            if (PCB->PinOn || doing_assy)
+              {
+                r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_callback, NULL);
+//                r_search (PCB->Data->pin_tree, drawn_area, NULL, hole_callback, NULL);
+              }
+            /* draw vias */
+            if (PCB->ViaOn || doing_assy)
+              {
+                r_search (PCB->Data->via_tree, drawn_area, NULL, via_callback, NULL);
+//                r_search (PCB->Data->via_tree, drawn_area, NULL, hole_callback, NULL);
+              }
+          }
 	}
     }
   if (TEST_FLAG (CHECKPLANESFLAG, PCB) && gui->gui)
@@ -479,7 +522,14 @@ DrawEverything (BoxTypePtr drawn_area)
     r_search (PCB->Data->via_tree, drawn_area, NULL, lowvia_callback, NULL);
   /* Draw pins, pads, vias below silk */
   if (gui->gui)
-    DrawTop (drawn_area);
+    {
+      if (!Settings.ShowSolderSide)
+        gui->set_layer ("topsilk", SL (SILK, TOP), 0);
+      else
+        gui->set_layer ("bottomsilk", SL (SILK, BOTTOM), 0);
+      gui->set_layer (NULL, SL (FINISHED, 0), 0);
+      DrawTop (drawn_area);
+    }
   else
     {
       HoleCountStruct hcs;
@@ -638,31 +688,6 @@ DrawEMark (ElementTypePtr e, LocationType X, LocationType Y,
   
 }
 
-static int
-via_callback (const BoxType * b, void *cl)
-{
-  PinTypePtr via = (PinTypePtr) b;
-//  if (via->Mask)
-    DrawPlainVia (via, False);
-  return 1;
-}
-
-static int
-pin_callback (const BoxType * b, void *cl)
-{
-  DrawPlainPin ((PinTypePtr) b, False);
-  return 1;
-}
-
-static int
-pad_callback (const BoxType * b, void *cl)
-{
-  PadTypePtr pad = (PadTypePtr) b;
-  if (FRONT (pad))
-    DrawPad (pad, 0);
-  return 1;
-}
-
 /* ---------------------------------------------------------------------------
  * draws pins pads and vias
  */
@@ -680,10 +705,10 @@ DrawTop (const BoxType * screen)
   if (PCB->ViaOn || doing_assy)
     {
       r_search (PCB->Data->via_tree, screen, NULL, via_callback, NULL);
-      r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
+//      r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
     }
   if (PCB->PinOn || doing_assy)
-    r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
+      r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
 }
 
 struct pin_info
@@ -1139,7 +1164,12 @@ DrawPinOrViaLowLevel (PinTypePtr Ptr, Boolean drawHole)
 	}
       else
 	{
-	  gui->fill_circle (Output.fgGC, Ptr->X, Ptr->Y, Ptr->Thickness / 2);
+	  gui->set_line_cap (Output.fgGC, Round_Cap);
+	  gui->set_line_width (Output.fgGC, (Ptr->Thickness - Ptr->DrillingHole) / 2);
+	  gui->draw_arc (Output.fgGC, Ptr->X, Ptr->Y,
+			 (Ptr->Thickness + Ptr->DrillingHole) / 4,
+                         (Ptr->Thickness + Ptr->DrillingHole) / 4, 0, 360);
+//          gui->fill_circle (Output.fgGC, Ptr->X, Ptr->Y, Ptr->Thickness / 2);
 	}
     }
 
diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index 9389885..48c84ee 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -48,6 +48,7 @@
 RCSID ("$Id: $");
 
 triangle_buffer buffer;
+float global_depth = 0;
 
 #if 0
 triangle_array *
@@ -61,7 +62,7 @@ void
 hidgl_init_triangle_array (triangle_buffer *buffer)
 {
   glEnableClientState (GL_VERTEX_ARRAY);
-  glVertexPointer (2, GL_FLOAT, 0, buffer->triangle_array);
+  glVertexPointer (3, GL_FLOAT, 0, buffer->triangle_array);
   buffer->triangle_count = 0;
   buffer->coord_comp_count = 0;
 }
@@ -787,6 +788,12 @@ hidgl_reset_stencil_usage (void)
   dirty_bits = 0;
 }
 
+void
+hidgl_set_depth (float depth)
+{
+  global_depth = depth;
+}
+
 
 /* ---------------------------------------------------------------------- */
 
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index 4e86e27..e28b586 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -25,16 +25,17 @@
 
 //#define TRIANGLE_ARRAY_SIZE 5000
 #define TRIANGLE_ARRAY_SIZE 5461
-/* Assumes GLFloat is 4 bytes, and we have X,Y coords x3 for each triangle:
+/* Assumes GLFloat is 4 bytes, and we have X,Y(,Z) coords x3 for each triangle:
    4 * 5461 * 2 * 3 = 109464 */
-#define TRIANGLE_ARRAY_BYTES 131072
+//#define TRIANGLE_ARRAY_BYTES 131072
 typedef struct {
-  GLfloat triangle_array [2 * 3 * TRIANGLE_ARRAY_SIZE];
+  GLfloat triangle_array [3 * 3 * TRIANGLE_ARRAY_SIZE];
   unsigned int triangle_count;
   unsigned int coord_comp_count;
 } triangle_buffer;
 
 extern triangle_buffer buffer;
+extern float global_depth;
 
 void hidgl_init_triangle_array (triangle_buffer *buffer);
 void hidgl_flush_triangles (triangle_buffer *buffer);
@@ -46,12 +47,19 @@ hidgl_add_triangle (triangle_buffer *buffer,
                     GLfloat x2, GLfloat y2,
                     GLfloat x3, GLfloat y3)
 {
+  if (buffer->triangle_count == TRIANGLE_ARRAY_SIZE) {
+    printf ("OH CRAP\n");
+    *(char *)0 = 0;
+  }
   buffer->triangle_array [buffer->coord_comp_count++] = x1;
   buffer->triangle_array [buffer->coord_comp_count++] = y1;
+  buffer->triangle_array [buffer->coord_comp_count++] = global_depth;
   buffer->triangle_array [buffer->coord_comp_count++] = x2;
   buffer->triangle_array [buffer->coord_comp_count++] = y2;
+  buffer->triangle_array [buffer->coord_comp_count++] = global_depth;
   buffer->triangle_array [buffer->coord_comp_count++] = x3;
   buffer->triangle_array [buffer->coord_comp_count++] = y3;
+  buffer->triangle_array [buffer->coord_comp_count++] = global_depth;
   buffer->triangle_count++;
 }
 
@@ -69,5 +77,6 @@ int hidgl_stencil_bits (void);
 int hidgl_assign_clear_stencil_bit (void);
 void hidgl_return_stencil_bit (int bit);
 void hidgl_reset_stencil_usage (void);
+void hidgl_set_depth (float depth);
 
 #endif /* __HIDGL_INCLUDED__  */
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 1b28e71..41ebe19 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -531,6 +531,18 @@ ghid_set_layer (const char *name, int group, int empty)
   /* Flush out any existing geoemtry to be rendered */
   hidgl_flush_triangles (&buffer);
 
+  if (group >= 0 && group < max_layer) {
+    hidgl_set_depth ((max_layer - group) * 10);
+  } else {
+    if (SL_TYPE (idx) == SL_SILK) {
+      if (SL_SIDE (idx) == SL_TOP_SIDE && !Settings.ShowSolderSide) {
+        hidgl_set_depth (max_layer * 10 + 3);
+      } else {
+        hidgl_set_depth (10 - 3);
+      }
+    }
+  }
+
   glEnable (GL_STENCIL_TEST);                // Enable Stencil test
   glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value (with 1)
   /* Reset stencil buffer so we can paint anywhere */
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index 302fa2a..3bfd354 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -793,6 +793,32 @@ ghid_screen_update (void)
 void DrawAttached (Boolean);
 void draw_grid ();
 
+static float view_matrix[4][4] = {{1.0, 0.0, 0.0, 0.0},
+                                  {0.0, 1.0, 0.0, 0.0},
+                                  {0.0, 0.0, 1.0, 0.0},
+                                  {0.0, 0.0, 0.0, 1.0}};
+
+void
+ghid_port_rotate (void *ball, float *quarternion, gpointer userdata)
+{
+  int row, column;
+  build_rotmatrix (view_matrix, quarternion);
+
+#ifdef DEBUG_ROTATE
+  for (row = 0; row < 4; row++) {
+    printf ("[ %f", view_matrix[row][0]);
+    for (column = 1; column < 4; column++) {
+      printf (",\t%f", view_matrix[row][column]);
+    }
+    printf ("\t]\n");
+  }
+  printf ("\n");
+#endif
+
+  ghid_invalidate_all ();
+}
+
+
 #define Z_NEAR 3.0
 gboolean
 ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
@@ -825,99 +851,73 @@ ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
   glEnable (GL_BLEND);
   glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
 
+//  glEnable (GL_DEPTH_TEST);
+
 //  glEnable(GL_POLYGON_SMOOTH);
 //  glHint(GL_POLYGON_SMOOTH_HINT, [GL_FASTEST, GL_NICEST, or GL_DONT_CARE]);
 
-  glViewport (ev->area.x,
-              widget->allocation.height - ev->area.height - ev->area.y,
-              ev->area.width, ev->area.height);
+  glViewport (widget->allocation.x,     widget->allocation.y,
+              widget->allocation.width, widget->allocation.height);
 
+#if 0
   glEnable (GL_SCISSOR_TEST);
   glScissor (ev->area.x,
              widget->allocation.height - ev->area.height - ev->area.y,
              ev->area.width, ev->area.height);
+#endif
 
   glMatrixMode (GL_PROJECTION);
   glLoadIdentity ();
-  glOrtho (ev->area.x, ev->area.x + ev->area.width, ev->area.y + ev->area.height, ev->area.y, 0, 100);
+  glOrtho (0, widget->allocation.width, widget->allocation.height, 0, -100000, 100000);
   glMatrixMode (GL_MODELVIEW);
   glLoadIdentity ();
-  glTranslatef (0.0f, 0.0f, -Z_NEAR);
 
-  glEnable (GL_STENCIL_TEST);
-  glClearColor (gport->bg_color.red / 65535.,
-                gport->bg_color.green / 65535.,
-                gport->bg_color.blue / 65535.,
+  glTranslatef (widget->allocation.width / 2., widget->allocation.height / 2., 0);
+  glMultMatrixf (view_matrix);
+  glTranslatef (-widget->allocation.width / 2., -widget->allocation.height / 2., 0);
+
+//  glEnable (GL_STENCIL_TEST);
+  glClearColor (gport->offlimits_color.red / 65535.,
+                gport->offlimits_color.green / 65535.,
+                gport->offlimits_color.blue / 65535.,
                 1.);
 
-  glDepthMask (0);
+//  glClearDepth (1000);
+
   glClearStencil (0);
-  glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
+  glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
   hidgl_reset_stencil_usage ();
 
+#if 0
+  glClearColor (gport->bg_color.red / 65535.,
+                gport->bg_color.green / 65535.,
+                gport->bg_color.blue / 65535.,
+                1.);
+#endif
+
+#if 1
   region.X1 = MIN (Px (ev->area.x), Px (ev->area.x + ev->area.width + 1));
   region.X2 = MAX (Px (ev->area.x), Px (ev->area.x + ev->area.width + 1));
   region.Y1 = MIN (Py (ev->area.y), Py (ev->area.y + ev->area.height + 1));
   region.Y2 = MAX (Py (ev->area.y), Py (ev->area.y + ev->area.height + 1));
 
-  eleft = Vx (0);
-  eright = Vx (PCB->MaxWidth);
-  etop = Vy (0);
-  ebottom = Vy (PCB->MaxHeight);
-  if (eleft > eright)
-    {
-      int tmp = eleft;
-      eleft = eright;
-      eright = tmp;
-    }
-  if (etop > ebottom)
-    {
-      int tmp = etop;
-      etop = ebottom;
-      ebottom = tmp;
-    }
+  eleft = Vx (0); eright  = Vx (PCB->MaxWidth);
+  etop  = Vy (0); ebottom = Vy (PCB->MaxHeight);
 
-  glColor3f (gport->offlimits_color.red / 65535.,
-             gport->offlimits_color.green / 65535.,
-             gport->offlimits_color.blue / 65535.);
+  glColor3f (gport->bg_color.red / 65535.,
+             gport->bg_color.green / 65535.,
+             gport->bg_color.blue / 65535.);
 
   glBegin (GL_QUADS);
-  if (eleft > 0)
-    {
-      glVertex2i (0, 0);
-      glVertex2i (eleft, 0);
-      glVertex2i (eleft, gport->height);
-      glVertex2i (0, gport->height);
-    }
-  else
-    eleft = 0;
-  if (eright < gport->width)
-    {
-      glVertex2i (eright, 0);
-      glVertex2i (gport->width, 0);
-      glVertex2i (gport->width, gport->height);
-      glVertex2i (eright, gport->height);
-    }
-  else
-    eright = gport->width;
-  if (etop > 0)
-    {
-      glVertex2i (eleft, 0);
-      glVertex2i (eright, 0);
-      glVertex2i (eright, etop);
-      glVertex2i (eleft, etop);
-    }
-  if (ebottom < gport->height)
-    {
-      glVertex2i (eleft, ebottom);
-      glVertex2i (eright + 1, ebottom);
-      glVertex2i (eright + 1, gport->height);
-      glVertex2i (eleft, gport->height);
-    }
+  glVertex3i (eleft,  etop,    -50);
+  glVertex3i (eright, etop,    -50);
+  glVertex3i (eright, ebottom, -50);
+  glVertex3i (eleft,  ebottom, -50);
   glEnd ();
 
   /* TODO: Background image */
 
+#if 1
   hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
 
@@ -934,7 +934,8 @@ ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
                              -gport->view_x0,
                 ghid_flip_y ? gport->view_y0 - PCB->MaxHeight :
                              -gport->view_y0, 0);
-  hid_expose_callback (&ghid_hid, &region, 0);
+//  hid_expose_callback (&ghid_hid, &region, 0);
+  hid_expose_callback (&ghid_hid, NULL, 0);
   hidgl_flush_triangles (&buffer);
   glPopMatrix ();
 
@@ -954,10 +955,14 @@ ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
   hidgl_flush_triangles (&buffer);
   glPopMatrix ();
 
+#endif
+
   ghid_show_crosshair (TRUE);
 
   hidgl_flush_triangles (&buffer);
 
+#endif
+
   if (gdk_gl_drawable_is_double_buffered (pGlDrawable))
     gdk_gl_drawable_swap_buffers (pGlDrawable);
   else
diff --git a/src/hid/gtk/gui-top-window.c b/src/hid/gtk/gui-top-window.c
index 253542b..be82e4e 100644
--- a/src/hid/gtk/gui-top-window.c
+++ b/src/hid/gtk/gui-top-window.c
@@ -123,6 +123,7 @@ a zoom in/out.
 #include "gui-icons-mode-buttons.data"
 #include "gui-icons-misc.data"
 #include "snavi.h"
+#include "gui-trackball.h"
 
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
@@ -2156,6 +2157,7 @@ ghid_build_pcb_top_window (void)
   GtkWidget *vbox_main, *vbox_left, *hbox_middle, *hbox = NULL;
   GtkWidget *viewport, *ebox, *vbox, *frame;
   GtkWidget *label;
+  GtkWidget *trackball;
   GHidPort *port = &ghid_port;
   gchar *s;
   GtkWidget *scrolled;
@@ -2264,6 +2266,11 @@ ghid_build_pcb_top_window (void)
       GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
   make_layer_buttons(vbox, port);
 
+  trackball = ghid_trackball_new ();
+  g_signal_connect (trackball, "rotation-changed",
+                    G_CALLBACK (ghid_port_rotate), NULL);
+  gtk_box_pack_start (GTK_BOX (vbox_left), trackball, FALSE, FALSE, 0);
+
   vbox = gtk_vbox_new(FALSE, 0);
   gtk_box_pack_start(GTK_BOX(vbox_left), vbox, FALSE, FALSE, 0);
   ghidgui->mode_buttons0_frame_vbox = vbox;
@@ -2667,6 +2674,7 @@ ghid_parse_arguments (int *argc, char ***argv)
   gtk_gl_init(argc, argv);
 
   gport = &ghid_port;
+  fprintf (stderr, "gport set at %p\n", gport);
   gport->zoom = 300.0;
   pixel_slop = 300;
 
@@ -2674,7 +2682,7 @@ ghid_parse_arguments (int *argc, char ***argv)
   /* setup GL-context */
   gport->glconfig = gdk_gl_config_new_by_mode (GDK_GL_MODE_RGBA    |
                                                GDK_GL_MODE_STENCIL |
-//                                               GDK_GL_MODE_DEPTH   |
+                                               GDK_GL_MODE_DEPTH   |
                                                GDK_GL_MODE_DOUBLE);
   if (!gport->glconfig) {
     printf("Could not setup GL-context!\n");
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index 2e73111..f7149b0 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -366,6 +366,8 @@ gint ghid_port_window_motion_cb (GtkWidget * widget,
 gint ghid_port_window_mouse_scroll_cb (GtkWidget * widget,
 				       GdkEventScroll * ev, GHidPort * out);
 
+void
+ghid_port_rotate (void *ball, float *quarternion, gpointer userdata);
 
 gint ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
 					     GdkEventExpose * ev,

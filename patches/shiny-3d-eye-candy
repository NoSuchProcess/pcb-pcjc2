Bottom: f8599132923531e6bba57975fe21b734d9ed776b
Top:    793b843eeca39b7aeb80aa899881640651f0c970
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-10-21 20:46:23 +0100

Shiny 3D eye-candy

Experiments in progress - don't expect this to work yet!


---

diff --git a/src/draw.c b/src/draw.c
index 4359225..5efb010 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -308,6 +308,10 @@ hole_callback (const BoxType * b, void *cl)
 {
   PinTypePtr pin = (PinTypePtr) b;
   int plated = cl ? *(int *) cl : -1;
+
+  if (!TEST_FLAG (SQUAREFLAG,pin))
+    return;
+
   switch (plated)
     {
     case -1:
@@ -372,6 +376,30 @@ PrintAssembly (const BoxType * drawn_area, int side_group, int swap_ident)
   SWAP_IDENT = save_swap;
 }
 
+static int
+via_callback (const BoxType * b, void *cl)
+{
+  PinTypePtr via = (PinTypePtr) b;
+  DrawPlainVia (via, False);
+  return 1;
+}
+
+static int
+pin_callback (const BoxType * b, void *cl)
+{
+  DrawPlainPin ((PinTypePtr) b, False);
+  return 1;
+}
+
+static int
+pad_callback (const BoxType * b, void *cl)
+{
+  PadTypePtr pad = (PadTypePtr) b;
+  if (FRONT (pad))
+    DrawPad (pad, 0);
+  return 1;
+}
+
 /* ---------------------------------------------------------------------------
  * initializes some identifiers for a new zoom factor and redraws whole screen
  */
@@ -460,6 +488,20 @@ DrawEverything (BoxTypePtr drawn_area)
 		}
 	    }
 	  gui->set_layer (NULL, SL (FINISHED, 0), 0);
+	  if (gui->gui) {
+            /* draw element pins */
+            if (PCB->PinOn || doing_assy)
+              {
+                r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_callback, NULL);
+//                r_search (PCB->Data->pin_tree, drawn_area, NULL, hole_callback, NULL);
+              }
+            /* draw vias */
+            if (PCB->ViaOn || doing_assy)
+              {
+                r_search (PCB->Data->via_tree, drawn_area, NULL, via_callback, NULL);
+//                r_search (PCB->Data->via_tree, drawn_area, NULL, hole_callback, NULL);
+              }
+          }
 	}
     }
   if (TEST_FLAG (CHECKPLANESFLAG, PCB) && gui->gui)
@@ -467,7 +509,14 @@ DrawEverything (BoxTypePtr drawn_area)
 
   /* Draw pins, pads, vias below silk */
   if (gui->gui)
-    DrawTop (drawn_area);
+    {
+      if (!Settings.ShowSolderSide)
+        gui->set_layer ("topsilk", SL (SILK, TOP), 0);
+      else
+        gui->set_layer ("bottomsilk", SL (SILK, BOTTOM), 0);
+      gui->set_layer (NULL, SL (FINISHED, 0), 0);
+      DrawTop (drawn_area);
+    }
   else
     {
       HoleCountStruct hcs;
@@ -626,30 +675,6 @@ DrawEMark (ElementTypePtr e, LocationType X, LocationType Y,
   
 }
 
-static int
-via_callback (const BoxType * b, void *cl)
-{
-  PinTypePtr via = (PinTypePtr) b;
-  DrawPlainVia (via, False);
-  return 1;
-}
-
-static int
-pin_callback (const BoxType * b, void *cl)
-{
-  DrawPlainPin ((PinTypePtr) b, False);
-  return 1;
-}
-
-static int
-pad_callback (const BoxType * b, void *cl)
-{
-  PadTypePtr pad = (PadTypePtr) b;
-  if (FRONT (pad))
-    DrawPad (pad, 0);
-  return 1;
-}
-
 /* ---------------------------------------------------------------------------
  * draws pins pads and vias
  */
@@ -667,10 +692,10 @@ DrawTop (const BoxType * screen)
   if (PCB->ViaOn || doing_assy)
     {
       r_search (PCB->Data->via_tree, screen, NULL, via_callback, NULL);
-      r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
+//      r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
     }
   if (PCB->PinOn || doing_assy)
-    r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
+      r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
 }
 
 struct pin_info
@@ -1077,7 +1102,12 @@ DrawPinOrViaLowLevel (PinTypePtr Ptr, Boolean drawHole)
 	}
       else
 	{
-	  gui->fill_circle (Output.fgGC, Ptr->X, Ptr->Y, Ptr->Thickness / 2);
+	  gui->set_line_cap (Output.fgGC, Round_Cap);
+	  gui->set_line_width (Output.fgGC, (Ptr->Thickness - Ptr->DrillingHole) / 2);
+	  gui->draw_arc (Output.fgGC, Ptr->X, Ptr->Y,
+			 (Ptr->Thickness + Ptr->DrillingHole) / 4,
+                         (Ptr->Thickness + Ptr->DrillingHole) / 4, 0, 360);
+//          gui->fill_circle (Output.fgGC, Ptr->X, Ptr->Y, Ptr->Thickness / 2);
 	}
     }
 
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 5d3e091..1725cc5 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -344,6 +344,7 @@ draw_grid ()
   static int npoints = 0;
   int x1, y1, x2, y2, n, i;
   double x, y;
+  extern float global_depth;
 
   if (!Settings.DrawGrid)
     return;
@@ -395,23 +396,24 @@ draw_grid ()
     {
       npoints = n + 10;
       points =
-	MyRealloc (points, npoints * 2 * sizeof (GLfloat), "gtk_draw_grid");
+	MyRealloc (points, npoints * 3 * sizeof (GLfloat), "gtk_draw_grid");
     }
 
   glEnableClientState (GL_VERTEX_ARRAY);
-  glVertexPointer (2, GL_FLOAT, 0, points);
+  glVertexPointer (3, GL_FLOAT, 0, points);
 
   n = 0;
   for (x = x1; x <= x2; x += PCB->Grid)
     {
-      points[2 * n] = Vx (x);
+      points[3 * n] = Vx (x);
+      points[3 * n + 2] = global_depth;
       n++;
     }
   for (y = y1; y <= y2; y += PCB->Grid)
     {
       int vy = Vy (y);
       for (i = 0; i < n; i++)
-	points[2 * i + 1] = vy;
+	points[3 * i + 1] = vy;
       glDrawArrays (GL_POINTS, 0, n);
     }
 
@@ -531,6 +533,18 @@ ghid_set_layer (const char *name, int group, int empty)
   /* Flush out any existing geoemtry to be rendered */
   hidgl_flush_triangles (&buffer);
 
+  if (group >= 0 && group < max_layer) {
+    hidgl_set_depth ((max_layer - group) * 10);
+  } else {
+    if (SL_TYPE (idx) == SL_SILK) {
+      if (SL_SIDE (idx) == SL_TOP_SIDE && !Settings.ShowSolderSide) {
+        hidgl_set_depth (max_layer * 10 + 3);
+      } else {
+        hidgl_set_depth (10 - 3);
+      }
+    }
+  }
+
   glEnable (GL_STENCIL_TEST);                // Enable Stencil test
   glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value (with 1)
   /* Reset stencil buffer so we can paint anywhere */
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index 7210f32..e5957c2 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -479,16 +479,16 @@ have_crosshair_attachments (void)
 #define VCD		8
 
 static void
-draw_right_cross (gint x, gint y)
+draw_right_cross (gint x, gint y, gint z)
 {
-  glVertex2i (x, 0);
-  glVertex2i (x, gport->height);
-  glVertex2i (0, y);
-  glVertex2i (gport->width, y);
+  glVertex3i (x, 0, z);
+  glVertex3i (x, gport->height, z);
+  glVertex3i (0, y, z);
+  glVertex3i (gport->width, y, z);
 }
 
 static void
-draw_slanted_cross (gint x, gint y)
+draw_slanted_cross (gint x, gint y, gint z)
 {
   gint x0, y0, x1, y1;
 
@@ -500,8 +500,8 @@ draw_slanted_cross (gint x, gint y)
   y0 = MAX(0, MIN (y0, gport->height));
   y1 = y - x;
   y1 = MAX(0, MIN (y1, gport->height));
-  glVertex2i (x0, y0);
-  glVertex2i (x1, y1);
+  glVertex3i (x0, y0, z);
+  glVertex3i (x1, y1, z);
 
   x0 = x - (gport->height - y);
   x0 = MAX(0, MIN (x0, gport->width));
@@ -511,12 +511,12 @@ draw_slanted_cross (gint x, gint y)
   y0 = MAX(0, MIN (y0, gport->height));
   y1 = y - (gport->width - x);
   y1 = MAX(0, MIN (y1, gport->height));
-  glVertex2i (x0, y0);
-  glVertex2i (x1, y1);
+  glVertex3i (x0, y0, z);
+  glVertex3i (x1, y1, z);
 }
 
 static void
-draw_dozen_cross (gint x, gint y)
+draw_dozen_cross (gint x, gint y, gint z)
 {
   gint x0, y0, x1, y1;
   gdouble tan60 = sqrt (3);
@@ -529,8 +529,8 @@ draw_dozen_cross (gint x, gint y)
   y0 = MAX(0, MIN (y0, gport->height));
   y1 = y - x * tan60;
   y1 = MAX(0, MIN (y1, gport->height));
-  glVertex2i (x0, y0);
-  glVertex2i (x1, y1);
+  glVertex3i (x0, y0, z);
+  glVertex3i (x1, y1, z);
 
   x0 = x + (gport->height - y) * tan60;
   x0 = MAX(0, MIN (x0, gport->width));
@@ -540,8 +540,8 @@ draw_dozen_cross (gint x, gint y)
   y0 = MAX(0, MIN (y0, gport->height));
   y1 = y - x / tan60;
   y1 = MAX(0, MIN (y1, gport->height));
-  glVertex2i (x0, y0);
-  glVertex2i (x1, y1);
+  glVertex3i (x0, y0, z);
+  glVertex3i (x1, y1, z);
 
   x0 = x - (gport->height - y) / tan60;
   x0 = MAX(0, MIN (x0, gport->width));
@@ -551,8 +551,8 @@ draw_dozen_cross (gint x, gint y)
   y0 = MAX(0, MIN (y0, gport->height));
   y1 = y - (gport->width - x) * tan60;
   y1 = MAX(0, MIN (y1, gport->height));
-  glVertex2i (x0, y0);
-  glVertex2i (x1, y1);
+  glVertex3i (x0, y0, z);
+  glVertex3i (x1, y1, z);
 
   x0 = x - (gport->height - y) * tan60;
   x0 = MAX(0, MIN (x0, gport->width));
@@ -562,30 +562,31 @@ draw_dozen_cross (gint x, gint y)
   y0 = MAX(0, MIN (y0, gport->height));
   y1 = y - (gport->width - x) / tan60;
   y1 = MAX(0, MIN (y1, gport->height));
-  glVertex2i (x0, y0);
-  glVertex2i (x1, y1);
+  glVertex3i (x0, y0, z);
+  glVertex3i (x1, y1, z);
 }
 
 static void
-draw_crosshair (gint x, gint y)
+draw_crosshair (gint x, gint y, gint z)
 {
   static enum crosshair_shape prev = Basic_Crosshair_Shape;
 
-  draw_right_cross (x, y);
+  draw_right_cross (x, y, z);
   if (prev == Union_Jack_Crosshair_Shape)
-    draw_slanted_cross (x, y);
+    draw_slanted_cross (x, y, z);
   if (prev == Dozen_Crosshair_Shape)
-    draw_dozen_cross (x, y);
+    draw_dozen_cross (x, y, z);
   prev = Crosshair.shape;
 }
 
 void
 ghid_show_crosshair (gboolean show)
 {
-  gint x, y;
-  static gint x_prev = -1, y_prev = -1;
+  gint x, y, z;
+  static gint x_prev = -1, y_prev = -1, z_prev = -1;
   static int done_once = 0;
   static GdkColor cross_color;
+  extern float global_depth;
 
   if (gport->x_crosshair < 0 || ghidgui->creating) {// || !gport->has_entered) {
     printf ("Returning\n");
@@ -600,6 +601,7 @@ ghid_show_crosshair (gboolean show)
     }
   x = DRAW_X (gport->x_crosshair);
   y = DRAW_Y (gport->y_crosshair);
+  z = global_depth;
 
   glEnable (GL_COLOR_LOGIC_OP);
   glLogicOp (GL_XOR);
@@ -615,13 +617,13 @@ ghid_show_crosshair (gboolean show)
 #if 1
   if (x_prev >= 0)
     {
-      draw_crosshair (x_prev, y_prev);
+      draw_crosshair (x_prev, y_prev, z_prev);
     }
 #endif
 
   if (x >= 0 && show)
     {
-      draw_crosshair (x, y);
+      draw_crosshair (x, y, z);
     }
 
   glEnd ();
@@ -633,43 +635,43 @@ ghid_show_crosshair (gboolean show)
 #if 1
       if (x_prev >= 0)
         {
-          glVertex2i (0,                  y_prev - VCD);
-          glVertex2i (0,                  y_prev - VCD + VCW);
-          glVertex2i (VCD,                y_prev - VCD + VCW);
-          glVertex2i (VCD,                y_prev - VCD);
-          glVertex2i (gport->width,       y_prev - VCD);
-          glVertex2i (gport->width,       y_prev - VCD + VCW);
-          glVertex2i (gport->width - VCD, y_prev - VCD + VCW);
-          glVertex2i (gport->width - VCD, y_prev - VCD);
-          glVertex2i (x_prev - VCD,       0);
-          glVertex2i (x_prev - VCD,       VCD);
-          glVertex2i (x_prev - VCD + VCW, VCD);
-          glVertex2i (x_prev - VCD + VCW, 0);
-          glVertex2i (x_prev - VCD,       gport->height - VCD);
-          glVertex2i (x_prev - VCD,       gport->height);
-          glVertex2i (x_prev - VCD + VCW, gport->height);
-          glVertex2i (x_prev - VCD + VCW, gport->height - VCD);
+          glVertex3i (0,                  y_prev - VCD,        z_prev);
+          glVertex3i (0,                  y_prev - VCD + VCW,  z_prev);
+          glVertex3i (VCD,                y_prev - VCD + VCW,  z_prev);
+          glVertex3i (VCD,                y_prev - VCD,        z_prev);
+          glVertex3i (gport->width,       y_prev - VCD,        z_prev);
+          glVertex3i (gport->width,       y_prev - VCD + VCW,  z_prev);
+          glVertex3i (gport->width - VCD, y_prev - VCD + VCW,  z_prev);
+          glVertex3i (gport->width - VCD, y_prev - VCD,        z_prev);
+          glVertex3i (x_prev - VCD,       0,                   z_prev);
+          glVertex3i (x_prev - VCD,       VCD,                 z_prev);
+          glVertex3i (x_prev - VCD + VCW, VCD,                 z_prev);
+          glVertex3i (x_prev - VCD + VCW, 0,                   z_prev);
+          glVertex3i (x_prev - VCD,       gport->height - VCD, z_prev);
+          glVertex3i (x_prev - VCD,       gport->height,       z_prev);
+          glVertex3i (x_prev - VCD + VCW, gport->height,       z_prev);
+          glVertex3i (x_prev - VCD + VCW, gport->height - VCD, z_prev);
         }
 #endif
 
       if (x >= 0 && show)
         {
-          glVertex2i (0,                  y - VCD);
-          glVertex2i (0,                  y - VCD + VCW);
-          glVertex2i (VCD,                y - VCD + VCW);
-          glVertex2i (VCD,                y - VCD);
-          glVertex2i (gport->width,       y - VCD);
-          glVertex2i (gport->width,       y - VCD + VCW);
-          glVertex2i (gport->width - VCD, y - VCD + VCW);
-          glVertex2i (gport->width - VCD, y - VCD);
-          glVertex2i (x - VCD,            0);
-          glVertex2i (x - VCD,            VCD);
-          glVertex2i (x - VCD + VCW,      VCD);
-          glVertex2i (x - VCD + VCW,      0);
-          glVertex2i (x - VCD,            gport->height - VCD);
-          glVertex2i (x - VCD,            gport->height);
-          glVertex2i (x - VCD + VCW,      gport->height);
-          glVertex2i (x - VCD + VCW,      gport->height - VCD);
+          glVertex3i (0,                  y - VCD,             z);
+          glVertex3i (0,                  y - VCD + VCW,       z);
+          glVertex3i (VCD,                y - VCD + VCW,       z);
+          glVertex3i (VCD,                y - VCD,             z);
+          glVertex3i (gport->width,       y - VCD,             z);
+          glVertex3i (gport->width,       y - VCD + VCW,       z);
+          glVertex3i (gport->width - VCD, y - VCD + VCW,       z);
+          glVertex3i (gport->width - VCD, y - VCD,             z);
+          glVertex3i (x - VCD,            0,                   z);
+          glVertex3i (x - VCD,            VCD,                 z);
+          glVertex3i (x - VCD + VCW,      VCD,                 z);
+          glVertex3i (x - VCD + VCW,      0,                   z);
+          glVertex3i (x - VCD,            gport->height - VCD, z);
+          glVertex3i (x - VCD,            gport->height,       z);
+          glVertex3i (x - VCD + VCW,      gport->height,       z);
+          glVertex3i (x - VCD + VCW,      gport->height - VCD, z);
         }
 
       glEnd ();
@@ -679,9 +681,10 @@ ghid_show_crosshair (gboolean show)
     {
       x_prev = x;
       y_prev = y;
+      z_prev = z;
     }
   else
-    x_prev = y_prev = -1;
+    x_prev = y_prev = z_prev = -1;
 
   glDisable (GL_COLOR_LOGIC_OP);
 }
@@ -956,7 +959,7 @@ ghid_screen_update (void)
 }
 
 void DrawAttached (Boolean);
-void draw_grid ();
+void draw_grid (void);
 
 void
 ghid_view_2d (void *ball, gboolean view_2d, gpointer userdata)
@@ -1163,6 +1166,11 @@ ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
   hidgl_flush_triangles (&buffer);
   glPopMatrix ();
 
+  /* Just prod the drawing code so the current depth gets set to
+     the right value for the layer we are editing */
+  gui->set_layer (NULL, INDEXOFCURRENT, 0);
+  gui->set_layer (NULL, SL_FINISHED, 0);
+
   draw_grid ();
 
   hidgl_init_triangle_array (&buffer);

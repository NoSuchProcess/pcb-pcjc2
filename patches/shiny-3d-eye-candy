Bottom: bffde32a804e7f78b64bc35ea1724d6867122602
Top:    b74bdf3a8a204e928d5d7319f9df1cd4f99bef2d
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-05-02 14:49:26 +0100

Shiny 3D eye-candy

Experiments in progress - don't expect this to work yet!

Squashed:
  Fix grid extents in 3D view


---

diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index 3e08fec..d1979ff 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -96,41 +96,25 @@ hidgl_set_depth (float depth)
   global_depth = depth;
 }
 
-/* ------------------------------------------------------------ */
-#if 0
-/*static*/ void
-draw_grid ()
+void
+hidgl_draw_grid (BoxType *drawn_area)
 {
   static GLfloat *points = 0;
   static int npoints = 0;
   int x1, y1, x2, y2, n, i;
   double x, y;
+  extern float global_depth;
 
   if (!Settings.DrawGrid)
     return;
+
   if (Vz (PCB->Grid) < MIN_GRID_DISTANCE)
     return;
 
-  if (gdk_color_parse (Settings.GridColor, &gport->grid_color))
-    {
-      gport->grid_color.red ^= gport->bg_color.red;
-      gport->grid_color.green ^= gport->bg_color.green;
-      gport->grid_color.blue ^= gport->bg_color.blue;
-    }
-
-  hidgl_flush_triangles ();
-
-  glEnable (GL_COLOR_LOGIC_OP);
-  glLogicOp (GL_XOR);
-
-  glColor3f (gport->grid_color.red / 65535.,
-             gport->grid_color.green / 65535.,
-             gport->grid_color.blue / 65535.);
-
-  x1 = GRIDFIT_X (SIDE_X (gport->view_x0), PCB->Grid);
-  y1 = GRIDFIT_Y (SIDE_Y (gport->view_y0), PCB->Grid);
-  x2 = GRIDFIT_X (SIDE_X (gport->view_x0 + gport->view_width - 1), PCB->Grid);
-  y2 = GRIDFIT_Y (SIDE_Y (gport->view_y0 + gport->view_height - 1), PCB->Grid);
+  x1 = GRIDFIT_X (MAX (0, drawn_area->X1), PCB->Grid);
+  y1 = GRIDFIT_Y (MAX (0, drawn_area->Y1), PCB->Grid);
+  x2 = GRIDFIT_X (MIN (PCB->MaxWidth, drawn_area->X2), PCB->Grid);
+  y2 = GRIDFIT_Y (MIN (PCB->MaxHeight, drawn_area->Y2), PCB->Grid);
   if (x1 > x2)
     {
       int tmp = x1;
@@ -155,31 +139,30 @@ draw_grid ()
   if (n > npoints)
     {
       npoints = n + 10;
-      points = realloc (points, npoints * 2 * sizeof (GLfloat));
+      points = realloc (points, npoints * 3 * sizeof (GLfloat));
     }
 
   glEnableClientState (GL_VERTEX_ARRAY);
-  glVertexPointer (2, GL_FLOAT, 0, points);
+  glVertexPointer (3, GL_FLOAT, 0, points);
 
   n = 0;
   for (x = x1; x <= x2; x += PCB->Grid)
     {
-      points[2 * n] = Vx (x);
+      points[3 * n] = Vx (x);
+      points[3 * n + 2] = global_depth;
       n++;
     }
   for (y = y1; y <= y2; y += PCB->Grid)
     {
       int vy = Vy (y);
       for (i = 0; i < n; i++)
-        points[2 * i + 1] = vy;
+        points[3 * i + 1] = vy;
       glDrawArrays (GL_POINTS, 0, n);
     }
 
   glDisableClientState (GL_VERTEX_ARRAY);
-  glDisable (GL_COLOR_LOGIC_OP);
 }
 
-#endif
 /* ------------------------------------------------------------ */
 
 #define MAX_PIXELS_ARC_TO_CHORD 0.5
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index 9dd76e3..43d8aa2 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -66,7 +66,7 @@ hidgl_add_triangle (triangle_buffer *buffer,
                                  x3, y3, global_depth);
 }
 
-// void draw_grid ()
+void hidgl_draw_grid (BoxType *drawn_area);
 void hidgl_set_depth (float depth);
 void hidgl_draw_line (int cap, double width, int x1, int y1, int x2, int y2, double scale);
 void hidgl_draw_arc (double width, int vx, int vy, int vrx, int vry, int start_angle, int delta_angle, double scale);
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index fa156e2..0f37d79 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -96,6 +96,18 @@ ghid_set_layer (const char *name, int group, int empty)
   /* Flush out any existing geoemtry to be rendered */
   hidgl_flush_triangles (&buffer);
 
+  if (group >= 0 && group < max_group) {
+    hidgl_set_depth ((max_group - group) * 10);
+  } else {
+    if (SL_TYPE (idx) == SL_SILK) {
+      if (SL_SIDE (idx) == SL_TOP_SIDE && !Settings.ShowSolderSide) {
+        hidgl_set_depth (max_group * 10 + 3);
+      } else {
+        hidgl_set_depth (10 - 3);
+      }
+    }
+  }
+
   glEnable (GL_STENCIL_TEST);                // Enable Stencil test
   glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value (with 1)
   /* Reset stencil buffer so we can paint anywhere */
@@ -168,18 +180,8 @@ ghid_make_gc (void)
 }
 
 static void
-ghid_draw_grid ()
+ghid_draw_grid (BoxTypePtr drawn_area)
 {
-  static GLfloat *points = 0;
-  static int npoints = 0;
-  int x1, y1, x2, y2, n, i;
-  double x, y;
-
-  if (!Settings.DrawGrid)
-    return;
-  if (Vz (PCB->Grid) < MIN_GRID_DISTANCE)
-    return;
-
   if (gdk_color_parse (Settings.GridColor, &gport->grid_color))
     {
       gport->grid_color.red ^= gport->bg_color.red;
@@ -196,55 +198,8 @@ ghid_draw_grid ()
              gport->grid_color.green / 65535.,
              gport->grid_color.blue / 65535.);
 
-  x1 = GRIDFIT_X (SIDE_X (gport->view_x0), PCB->Grid);
-  y1 = GRIDFIT_Y (SIDE_Y (gport->view_y0), PCB->Grid);
-  x2 = GRIDFIT_X (SIDE_X (gport->view_x0 + gport->view_width - 1), PCB->Grid);
-  y2 = GRIDFIT_Y (SIDE_Y (gport->view_y0 + gport->view_height - 1), PCB->Grid);
-  if (x1 > x2)
-    {
-      int tmp = x1;
-      x1 = x2;
-      x2 = tmp;
-    }
-  if (y1 > y2)
-    {
-      int tmp = y1;
-      y1 = y2;
-      y2 = tmp;
-    }
-  if (Vx (x1) < 0)
-    x1 += PCB->Grid;
-  if (Vy (y1) < 0)
-    y1 += PCB->Grid;
-  if (Vx (x2) >= gport->width)
-    x2 -= PCB->Grid;
-  if (Vy (y2) >= gport->height)
-    y2 -= PCB->Grid;
-  n = (int) ((x2 - x1) / PCB->Grid + 0.5) + 1;
-  if (n > npoints)
-    {
-      npoints = n + 10;
-      points = realloc (points, npoints * 2 * sizeof (GLfloat));
-    }
-
-  glEnableClientState (GL_VERTEX_ARRAY);
-  glVertexPointer (2, GL_FLOAT, 0, points);
-
-  n = 0;
-  for (x = x1; x <= x2; x += PCB->Grid)
-    {
-      points[2 * n] = Vx (x);
-      n++;
-    }
-  for (y = y1; y <= y2; y += PCB->Grid)
-    {
-      int vy = Vy (y);
-      for (i = 0; i < n; i++)
-	points[2 * i + 1] = vy;
-      glDrawArrays (GL_POINTS, 0, n);
-    }
+  hidgl_draw_grid (drawn_area);
 
-  glDisableClientState (GL_VERTEX_ARRAY);
   glDisable (GL_COLOR_LOGIC_OP);
 }
 
@@ -704,16 +659,16 @@ ghid_notify_mark_change (bool changes_complete)
 }
 
 static void
-draw_right_cross (gint x, gint y)
+draw_right_cross (gint x, gint y, gint z)
 {
-  glVertex2i (x, 0);
-  glVertex2i (x, gport->height);
-  glVertex2i (0, y);
-  glVertex2i (gport->width, y);
+  glVertex3i (x, 0, z);
+  glVertex3i (x, gport->height, z);
+  glVertex3i (0, y, z);
+  glVertex3i (gport->width, y, z);
 }
 
 static void
-draw_slanted_cross (gint x, gint y)
+draw_slanted_cross (gint x, gint y, gint z)
 {
   gint x0, y0, x1, y1;
 
@@ -725,8 +680,8 @@ draw_slanted_cross (gint x, gint y)
   y0 = MAX(0, MIN (y0, gport->height));
   y1 = y - x;
   y1 = MAX(0, MIN (y1, gport->height));
-  glVertex2i (x0, y0);
-  glVertex2i (x1, y1);
+  glVertex3i (x0, y0, z);
+  glVertex3i (x1, y1, z);
 
   x0 = x - (gport->height - y);
   x0 = MAX(0, MIN (x0, gport->width));
@@ -736,12 +691,12 @@ draw_slanted_cross (gint x, gint y)
   y0 = MAX(0, MIN (y0, gport->height));
   y1 = y - (gport->width - x);
   y1 = MAX(0, MIN (y1, gport->height));
-  glVertex2i (x0, y0);
-  glVertex2i (x1, y1);
+  glVertex3i (x0, y0, z);
+  glVertex3i (x1, y1, z);
 }
 
 static void
-draw_dozen_cross (gint x, gint y)
+draw_dozen_cross (gint x, gint y, gint z)
 {
   gint x0, y0, x1, y1;
   gdouble tan60 = sqrt (3);
@@ -754,8 +709,8 @@ draw_dozen_cross (gint x, gint y)
   y0 = MAX(0, MIN (y0, gport->height));
   y1 = y - x * tan60;
   y1 = MAX(0, MIN (y1, gport->height));
-  glVertex2i (x0, y0);
-  glVertex2i (x1, y1);
+  glVertex3i (x0, y0, z);
+  glVertex3i (x1, y1, z);
 
   x0 = x + (gport->height - y) * tan60;
   x0 = MAX(0, MIN (x0, gport->width));
@@ -765,8 +720,8 @@ draw_dozen_cross (gint x, gint y)
   y0 = MAX(0, MIN (y0, gport->height));
   y1 = y - x / tan60;
   y1 = MAX(0, MIN (y1, gport->height));
-  glVertex2i (x0, y0);
-  glVertex2i (x1, y1);
+  glVertex3i (x0, y0, z);
+  glVertex3i (x1, y1, z);
 
   x0 = x - (gport->height - y) / tan60;
   x0 = MAX(0, MIN (x0, gport->width));
@@ -776,8 +731,8 @@ draw_dozen_cross (gint x, gint y)
   y0 = MAX(0, MIN (y0, gport->height));
   y1 = y - (gport->width - x) * tan60;
   y1 = MAX(0, MIN (y1, gport->height));
-  glVertex2i (x0, y0);
-  glVertex2i (x1, y1);
+  glVertex3i (x0, y0, z);
+  glVertex3i (x1, y1, z);
 
   x0 = x - (gport->height - y) * tan60;
   x0 = MAX(0, MIN (x0, gport->width));
@@ -787,20 +742,20 @@ draw_dozen_cross (gint x, gint y)
   y0 = MAX(0, MIN (y0, gport->height));
   y1 = y - (gport->width - x) / tan60;
   y1 = MAX(0, MIN (y1, gport->height));
-  glVertex2i (x0, y0);
-  glVertex2i (x1, y1);
+  glVertex3i (x0, y0, z);
+  glVertex3i (x1, y1, z);
 }
 
 static void
-draw_crosshair (gint x, gint y)
+draw_crosshair (gint x, gint y, gint z)
 {
   static enum crosshair_shape prev = Basic_Crosshair_Shape;
 
-  draw_right_cross (x, y);
+  draw_right_cross (x, y, z);
   if (prev == Union_Jack_Crosshair_Shape)
-    draw_slanted_cross (x, y);
+    draw_slanted_cross (x, y, z);
   if (prev == Dozen_Crosshair_Shape)
-    draw_dozen_cross (x, y);
+    draw_dozen_cross (x, y, z);
   prev = Crosshair.shape;
 }
 
@@ -810,10 +765,11 @@ draw_crosshair (gint x, gint y)
 void
 ghid_show_crosshair (gboolean paint_new_location)
 {
-  gint x, y;
+  gint x, y, z;
   gboolean draw_markers;
   static int done_once = 0;
   static GdkColor cross_color;
+  extern float global_depth;
 
   if (!paint_new_location)
     return;
@@ -826,6 +782,7 @@ ghid_show_crosshair (gboolean paint_new_location)
     }
   x = DRAW_X (gport->x_crosshair);
   y = DRAW_Y (gport->y_crosshair);
+  z = global_depth;
 
   glEnable (GL_COLOR_LOGIC_OP);
   glLogicOp (GL_XOR);
@@ -839,7 +796,7 @@ ghid_show_crosshair (gboolean paint_new_location)
   if (x >= 0 && paint_new_location)
     {
       glBegin (GL_LINES);
-      draw_crosshair (x, y);
+      draw_crosshair (x, y, z);
       glEnd ();
     }
 
@@ -847,22 +804,22 @@ ghid_show_crosshair (gboolean paint_new_location)
   if (x >= 0 && paint_new_location && draw_markers)
     {
       glBegin (GL_QUADS);
-      glVertex2i (0,                  y - VCD);
-      glVertex2i (0,                  y - VCD + VCW);
-      glVertex2i (VCD,                y - VCD + VCW);
-      glVertex2i (VCD,                y - VCD);
-      glVertex2i (gport->width,       y - VCD);
-      glVertex2i (gport->width,       y - VCD + VCW);
-      glVertex2i (gport->width - VCD, y - VCD + VCW);
-      glVertex2i (gport->width - VCD, y - VCD);
-      glVertex2i (x - VCD,            0);
-      glVertex2i (x - VCD,            VCD);
-      glVertex2i (x - VCD + VCW,      VCD);
-      glVertex2i (x - VCD + VCW,      0);
-      glVertex2i (x - VCD,            gport->height - VCD);
-      glVertex2i (x - VCD,            gport->height);
-      glVertex2i (x - VCD + VCW,      gport->height);
-      glVertex2i (x - VCD + VCW,      gport->height - VCD);
+      glVertex3i (0,                  y - VCD,             z);
+      glVertex3i (0,                  y - VCD + VCW,       z);
+      glVertex3i (VCD,                y - VCD + VCW,       z);
+      glVertex3i (VCD,                y - VCD,             z);
+      glVertex3i (gport->width,       y - VCD,             z);
+      glVertex3i (gport->width,       y - VCD + VCW,       z);
+      glVertex3i (gport->width - VCD, y - VCD + VCW,       z);
+      glVertex3i (gport->width - VCD, y - VCD,             z);
+      glVertex3i (x - VCD,            0,                   z);
+      glVertex3i (x - VCD,            VCD,                 z);
+      glVertex3i (x - VCD + VCW,      VCD,                 z);
+      glVertex3i (x - VCD + VCW,      0,                   z);
+      glVertex3i (x - VCD,            gport->height - VCD, z);
+      glVertex3i (x - VCD,            gport->height,       z);
+      glVertex3i (x - VCD + VCW,      gport->height,       z);
+      glVertex3i (x - VCD + VCW,      gport->height - VCD, z);
       glEnd ();
     }
 
@@ -1109,7 +1066,12 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   hidgl_flush_triangles (&buffer);
   glPopMatrix ();
 
-  ghid_draw_grid ();
+  /* Just prod the drawing code so the current depth gets set to
+     the right value for the layer we are editing */
+  gui->set_layer (NULL, GetLayerGroupNumberByNumber (INDEXOFCURRENT), 0);
+  gui->set_layer (NULL, SL_FINISHED, 0);
+
+  ghid_draw_grid (&region);
 
   hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index ce24a6a..7df2067 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -213,6 +213,10 @@ ghid_note_event_location (GdkEventButton * ev)
 {
   gint event_x, event_y;
   gboolean moved;
+  /* FIXME: IFDEF HACK */
+#ifdef ENABLE_GL
+  extern float global_depth; /* FIXME: REMOVE THIS HACK! */
+#endif
 
   if (!ev)
     {
@@ -228,7 +232,7 @@ ghid_note_event_location (GdkEventButton * ev)
   /* FIXME: IFDEF HACK */
 #ifdef ENABLE_GL
   /* Unproject event_x and event_y to world coordinates of the plane we are on */
-  ghid_unproject_to_z_plane (event_x, event_y, 0,
+  ghid_unproject_to_z_plane (event_x, event_y, global_depth,
                              &event_x, &event_y);
 #endif

Bottom: d4bee023557090d4db7b227340b2b4cc48835183
Top:    24d71741d1b1a5f7864b76d2a1114ce850c85250
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-08-27 17:22:36 +0100

hid/gtk: Move viewport view data into renderer specific code.

As the different renderers may do different things with the board view,
it is not possible to save the flip state in the PCB settings any more.

---

diff --git a/src/gpcb-menu.res.in b/src/gpcb-menu.res.in
index a715ffd..9e48d73 100644
--- a/src/gpcb-menu.res.in
+++ b/src/gpcb-menu.res.in
@@ -168,8 +168,8 @@ MainMenu =
     {"Zoom to 10mil/px" Zoom(=10mil)}
     {"Zoom In 20% and center" Zoom(-1.2) Center() m=Z }
     {"Zoom Out 20% and center" Zoom(+1.2) Center() m=O }
-    {"Flip up/down" checked=flip_y SwapSides(V) a={"Tab" "<Key>Tab"}}
-    {"Flip left/right" checked=flip_x SwapSides(H) a={"Shift-Tab" "Shift<Key>Tab"}}
+    {"Flip up/down" SwapSides(V) a={"Tab" "<Key>Tab"}}
+    {"Flip left/right" SwapSides(H) a={"Shift-Tab" "Shift<Key>Tab"}}
     {"Spin 180 degrees" SwapSides(R) a={"Ctrl-Tab" "Ctrl<Key>Tab"}}
     {"Swap Sides" SwapSides() a={"Ctrl-Shift-Tab" "Ctrl Shift<Key>Tab"}}
     {"Center cursor" Center() a={"C" "<Key>c"}}
diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index a78b0d4..6de5cdb 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -26,9 +26,18 @@ extern HID ghid_hid;
 */
 #define USE_GC(gc) if (!use_gc(gc)) return
 
+#define SIDE_X(x)   ((priv->view.flip_x ? PCB->MaxWidth  - (x) : (x)))
+#define SIDE_Y(y)   ((priv->view.flip_y ? PCB->MaxHeight - (y) : (y)))
+
 static int cur_mask = -1;
 static int mask_seq = 0;
 
+typedef struct view_data {
+  double coord_per_px;
+  bool flip_x;
+  bool flip_y;
+} view_data;
+
 typedef struct render_priv {
   GdkGC *bg_gc;
   GdkGC *offlimits_gc;
@@ -39,6 +48,7 @@ typedef struct render_priv {
   GdkRectangle clip_rect;
   int attached_invalidate_depth;
   int mark_invalidate_depth;
+  view_data view;
 
   /* Feature for leading the user to a particular location */
   guint lead_user_timeout;
@@ -64,6 +74,52 @@ typedef struct hid_gc_struct
 }
 hid_gc_struct;
 
+/* Px converts view->pcb, Vx converts pcb->view */
+static inline int
+Vx (Coord x)
+{
+  render_priv *priv = gport->render_priv;
+  if (priv->view.flip_x)
+    return (PCB->MaxWidth - x - priv->view_x0) / gport->zoom + 0.5;
+  else
+    return (x - priv->view_x0) / gport->zoom + 0.5;
+}
+
+static inline int
+Vy (Coord y)
+{
+  render_priv *priv = gport->render_priv;
+  if (priv->view.flip_y)
+    return (PCB->MaxHeight - y - priv->view_y0) / gport->zoom + 0.5;
+  else
+    return (y - priv->view_y0) / gport->zoom + 0.5;
+}
+
+static inline int
+Vz (Coord z)
+{
+  return z / gport->zoom + 0.5;
+}
+
+static inline Coord
+Px (int x)
+{
+  render_priv *priv = gport->render_priv;
+  Coord rv = x * gport->zoom + priv->view_x0;
+  if (priv->view.flip_x)
+    rv = PCB->MaxWidth - (x * gport->zoom + priv->view_x0);
+  return  rv;
+}
+
+static inline Coord
+Py (int y)
+{
+  render_priv *priv = gport->render_priv;
+  Coord rv = y * gport->zoom + priv->view_y0;
+  if (priv->view.flip_y)
+    rv = PCB->MaxHeight - (y * gport->zoom + priv->view_y0);
+  return  rv;
+}
 
 static void draw_lead_user (render_priv *priv);
 
@@ -172,11 +228,11 @@ ghid_draw_grid (void)
       gdk_gc_set_clip_origin (priv->grid_gc, 0, 0);
       set_clip (priv, priv->grid_gc);
     }
-  x1 = GridFit (SIDE_X (gport->view.x0), PCB->Grid, PCB->GridOffsetX);
-  y1 = GridFit (SIDE_Y (gport->view.y0), PCB->Grid, PCB->GridOffsetY);
-  x2 = GridFit (SIDE_X (gport->view.x0 + gport->view.width - 1),
+  x1 = GridFit (SIDE_X (priv->view.x0), PCB->Grid, PCB->GridOffsetX);
+  y1 = GridFit (SIDE_Y (priv->view.y0), PCB->Grid, PCB->GridOffsetY);
+  x2 = GridFit (SIDE_X (priv->view.x0 + priv->view.width - 1),
                 PCB->Grid, PCB->GridOffsetX);
-  y2 = GridFit (SIDE_Y (gport->view.y0 + gport->view.height - 1),
+  y2 = GridFit (SIDE_Y (priv->view.y0 + priv->view.height - 1),
                 PCB->Grid, PCB->GridOffsetY);
   if (x1 > x2)
     {
@@ -233,10 +289,10 @@ ghid_draw_bg_image (void)
   if (!ghidgui->bg_pixbuf)
     return;
 
-  w = PCB->MaxWidth / gport->view.coord_per_px;
-  h = PCB->MaxHeight / gport->view.coord_per_px;
-  x = gport->view.x0 / gport->view.coord_per_px;
-  y = gport->view.y0 / gport->view.coord_per_px;
+  w = PCB->MaxWidth / priv->view.coord_per_px;
+  h = PCB->MaxHeight / priv->view.coord_per_px;
+  x = priv->view.x0 / priv->view.coord_per_px;
+  y = priv->view.y0 / priv->view.coord_per_px;
 
   if (w_scaled != w || h_scaled != h)
     {
@@ -529,7 +585,7 @@ ghid_draw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
   dy2 = Vy ((double) y2);
 
   if (!ClipLine (0, 0, gport->width, gport->height,
-		 &dx1, &dy1, &dx2, &dy2, gc->width / gport->view.coord_per_px))
+		 &dx1, &dy1, &dx2, &dy2, gc->width / priv->view.coord_per_px))
     return;
 
   USE_GC (gc);
@@ -544,25 +600,25 @@ ghid_draw_arc (hidGC gc, Coord cx, Coord cy,
   gint w, h, radius;
   render_priv *priv = gport->render_priv;
 
-  w = gport->width * gport->view.coord_per_px;
-  h = gport->height * gport->view.coord_per_px;
+  w = gport->width * priv->view.coord_per_px;
+  h = gport->height * priv->view.coord_per_px;
   radius = (xradius > yradius) ? xradius : yradius;
-  if (SIDE_X (cx) < gport->view.x0 - radius
-      || SIDE_X (cx) > gport->view.x0 + w + radius
-      || SIDE_Y (cy) < gport->view.y0 - radius
-      || SIDE_Y (cy) > gport->view.y0 + h + radius)
+  if (SIDE_X (cx) < priv->view.x0 - radius
+      || SIDE_X (cx) > priv->view.x0 + w + radius
+      || SIDE_Y (cy) < priv->view.y0 - radius
+      || SIDE_Y (cy) > priv->view.y0 + h + radius)
     return;
 
   USE_GC (gc);
   vrx = Vz (xradius);
   vry = Vz (yradius);
 
-  if (gport->view.flip_x)
+  if (priv->view.flip_x)
     {
       start_angle = 180 - start_angle;
       delta_angle = -delta_angle;
     }
-  if (gport->view.flip_y)
+  if (priv->view.flip_y)
     {
       start_angle = -start_angle;
       delta_angle = -delta_angle;
@@ -583,17 +639,17 @@ ghid_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
   render_priv *priv = gport->render_priv;
 
   lw = gc->width;
-  w = gport->width * gport->view.coord_per_px;
-  h = gport->height * gport->view.coord_per_px;
-
-  if ((SIDE_X (x1) < gport->view.x0 - lw
-       && SIDE_X (x2) < gport->view.x0 - lw)
-      || (SIDE_X (x1) > gport->view.x0 + w + lw
-	  && SIDE_X (x2) > gport->view.x0 + w + lw)
-      || (SIDE_Y (y1) < gport->view.y0 - lw
-	  && SIDE_Y (y2) < gport->view.y0 - lw)
-      || (SIDE_Y (y1) > gport->view.y0 + h + lw
-	  && SIDE_Y (y2) > gport->view.y0 + h + lw))
+  w = gport->width * priv->view.coord_per_px;
+  h = gport->height * priv->view.coord_per_px;
+
+  if ((SIDE_X (x1) < priv->view.x0 - lw
+       && SIDE_X (x2) < priv->view.x0 - lw)
+      || (SIDE_X (x1) > priv->view.x0 + w + lw
+	  && SIDE_X (x2) > priv->view.x0 + w + lw)
+      || (SIDE_Y (y1) < priv->view.y0 - lw
+	  && SIDE_Y (y2) < priv->view.y0 - lw)
+      || (SIDE_Y (y1) > priv->view.y0 + h + lw
+	  && SIDE_Y (y2) > priv->view.y0 + h + lw))
     return;
 
   x1 = Vx (x1);
@@ -626,12 +682,12 @@ ghid_fill_circle (hidGC gc, Coord cx, Coord cy, Coord radius)
   gint w, h, vr;
   render_priv *priv = gport->render_priv;
 
-  w = gport->width * gport->view.coord_per_px;
-  h = gport->height * gport->view.coord_per_px;
-  if (SIDE_X (cx) < gport->view.x0 - radius
-      || SIDE_X (cx) > gport->view.x0 + w + radius
-      || SIDE_Y (cy) < gport->view.y0 - radius
-      || SIDE_Y (cy) > gport->view.y0 + h + radius)
+  w = gport->width * priv->view.coord_per_px;
+  h = gport->height * priv->view.coord_per_px;
+  if (SIDE_X (cx) < priv->view.x0 - radius
+      || SIDE_X (cx) > priv->view.x0 + w + radius
+      || SIDE_Y (cy) < priv->view.y0 - radius
+      || SIDE_Y (cy) > priv->view.y0 + h + radius)
     return;
 
   USE_GC (gc);
@@ -669,17 +725,17 @@ ghid_fill_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
   render_priv *priv = gport->render_priv;
 
   lw = gc->width;
-  w = gport->width * gport->view.coord_per_px;
-  h = gport->height * gport->view.coord_per_px;
-
-  if ((SIDE_X (x1) < gport->view.x0 - lw
-       && SIDE_X (x2) < gport->view.x0 - lw)
-      || (SIDE_X (x1) > gport->view.x0 + w + lw
-	  && SIDE_X (x2) > gport->view.x0 + w + lw)
-      || (SIDE_Y (y1) < gport->view.y0 - lw
-	  && SIDE_Y (y2) < gport->view.y0 - lw)
-      || (SIDE_Y (y1) > gport->view.y0 + h + lw
-	  && SIDE_Y (y2) > gport->view.y0 + h + lw))
+  w = gport->width * priv->view.coord_per_px;
+  h = gport->height * priv->view.coord_per_px;
+
+  if ((SIDE_X (x1) < priv->view.x0 - lw
+       && SIDE_X (x2) < priv->view.x0 - lw)
+      || (SIDE_X (x1) > priv->view.x0 + w + lw
+	  && SIDE_X (x2) > priv->view.x0 + w + lw)
+      || (SIDE_Y (y1) < priv->view.y0 - lw
+	  && SIDE_Y (y2) < priv->view.y0 - lw)
+      || (SIDE_Y (y1) > priv->view.y0 + h + lw
+	  && SIDE_Y (y2) > priv->view.y0 + h + lw))
     return;
 
   x1 = Vx (x1);
@@ -1165,41 +1221,31 @@ ghid_pinout_preview_expose (GtkWidget *widget,
 {
   GhidPinoutPreview *pinout = GHID_PINOUT_PREVIEW (widget);
   GdkDrawable *save_drawable;
-  double save_zoom;
+  view_data save_view;
   int da_w, da_h;
-  int save_left, save_top;
-  int save_width, save_height;
-  int save_view_width, save_view_height;
   double xz, yz;
   render_priv *priv = gport->render_priv;
 
-  save_zoom = gport->view.coord_per_px;
-  save_width = gport->width;
-  save_height = gport->height;
-  save_left = gport->view.x0;
-  save_top = gport->view.y0;
-  save_view_width = gport->view.width;
-  save_view_height = gport->view.height;
-
   /* Setup drawable and zoom factor for drawing routines
    */
   save_drawable = gport->drawable;
+  save_view = priv->view;
 
   gdk_window_get_geometry (widget->window, 0, 0, &da_w, &da_h, 0);
   xz = (double) pinout->x_max / da_w;
   yz = (double) pinout->y_max / da_h;
   if (xz > yz)
-    gport->view.coord_per_px = xz;
+    priv->view.coord_per_px = xz;
   else
-    gport->view.coord_per_px = yz;
+    priv->view.coord_per_px = yz;
 
   gport->drawable = widget->window;
   gport->width = da_w;
   gport->height = da_h;
-  gport->view.width = da_w * gport->view.coord_per_px;
-  gport->view.height = da_h * gport->view.coord_per_px;
-  gport->view.x0 = (pinout->x_max - gport->view.width) / 2;
-  gport->view.y0 = (pinout->y_max - gport->view.height) / 2;
+  priv->view.width = da_w * priv->view.coord_per_px;
+  priv->view.height = da_h * priv->view.coord_per_px;
+  priv->view.x0 = (pinout->x_max - priv->view.width) / 2;
+  priv->view.y0 = (pinout->y_max - priv->view.height) / 2;
 
   /* clear background */
   gdk_draw_rectangle (widget->window, priv->bg_gc, TRUE, 0, 0, da_w, da_h);
@@ -1208,13 +1254,9 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   hid_expose_callback (&ghid_hid, NULL, &pinout->element);
 
   gport->drawable = save_drawable;
-  gport->view.coord_per_px = save_zoom;
   gport->width = save_width;
   gport->height = save_height;
-  gport->view.x0 = save_left;
-  gport->view.y0 = save_top;
-  gport->view.width = save_view_width;
-  gport->view.height = save_view_height;
+  priv->view = save_view;
 
   return FALSE;
 }
@@ -1224,21 +1266,14 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
 {
   GdkPixmap *pixmap;
   GdkDrawable *save_drawable;
-  double save_zoom;
-  int save_left, save_top;
-  int save_width, save_height;
-  int save_view_width, save_view_height;
+  view_data save_view;
   BoxType region;
   render_priv *priv = gport->render_priv;
 
   save_drawable = gport->drawable;
-  save_zoom = gport->view.coord_per_px;
   save_width = gport->width;
   save_height = gport->height;
-  save_left = gport->view.x0;
-  save_top = gport->view.y0;
-  save_view_width = gport->view.width;
-  save_view_height = gport->view.height;
+  save_view = priv->view;
 
   pixmap = gdk_pixmap_new (NULL, width, height, depth);
 
@@ -1246,15 +1281,15 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
    */
 
   gport->drawable = pixmap;
-  gport->view.coord_per_px = zoom;
+  priv->view.coord_per_px = zoom;
   gport->width = width;
   gport->height = height;
-  gport->view.width = width * gport->view.coord_per_px;
-  gport->view.height = height * gport->view.coord_per_px;
-  gport->view.x0 = gport->view.flip_x ? PCB->MaxWidth - cx : cx;
-  gport->view.x0 -= gport->view.height / 2;
-  gport->view.y0 = gport->view.flip_y ? PCB->MaxHeight - cy : cy;
-  gport->view.y0 -= gport->view.width  / 2;
+  priv->view.width = width * priv->view.coord_per_px;
+  priv->view.height = height * priv->view.coord_per_px;
+  priv->view.x0 = priv->view.flip_x ? PCB->MaxWidth - cx : cx;
+  priv->view.x0 -= priv->view.height / 2;
+  priv->view.y0 = priv->view.flip_y ? PCB->MaxHeight - cy : cy;
+  priv->view.y0 -= priv->view.width  / 2;
 
   /* clear background */
   gdk_draw_rectangle (pixmap, priv->bg_gc, TRUE, 0, 0, width, height);
@@ -1273,13 +1308,10 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   hid_expose_callback (&ghid_hid, &region, NULL);
 
   gport->drawable = save_drawable;
-  gport->view.coord_per_px = save_zoom;
+  priv->view.coord_per_px = save_zoom;
   gport->width = save_width;
   gport->height = save_height;
-  gport->view.x0 = save_left;
-  gport->view.y0 = save_top;
-  gport->view.width = save_view_width;
-  gport->view.height = save_view_height;
+  priv->view = save_view;
 
   return pixmap;
 }
@@ -1310,6 +1342,8 @@ ghid_finish_debug_draw (void)
 bool
 ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y)
 {
+  render_priv *priv = gport->render_priv;
+
   *pcb_x = EVENT_TO_PCB_X (event_x);
   *pcb_y = EVENT_TO_PCB_Y (event_y);
 
@@ -1319,6 +1353,8 @@ ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y)
 bool
 ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y)
 {
+  render_priv *priv = gport->render_priv;
+
   *event_x = DRAW_X (pcb_x);
   *event_y = DRAW_Y (pcb_y);
 
@@ -1328,6 +1364,7 @@ ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y)
 static void
 pan_common (GHidPort *port)
 {
+  render_priv *priv = gport->render_priv;
   int event_x, event_y;
 
   /* We need to fix up the PCB coordinates corresponding to the last
@@ -1335,10 +1372,10 @@ pan_common (GHidPort *port)
   ghid_pcb_to_event_coords (gport->pcb_x, gport->pcb_y, &event_x, &event_y);
 
   /* Don't pan so far the board is completely off the screen */
-  port->view.x0 = MAX (-port->view.width,  port->view.x0);
-  port->view.y0 = MAX (-port->view.height, port->view.y0);
-  port->view.x0 = MIN ( port->view.x0, PCB->MaxWidth);
-  port->view.y0 = MIN ( port->view.y0, PCB->MaxHeight);
+  priv->view.x0 = MAX (-priv->view.width,  priv->view.x0);
+  priv->view.y0 = MAX (-priv->view.height, priv->view.y0);
+  priv->view.x0 = MIN ( priv->view.x0, PCB->MaxWidth);
+  priv->view.y0 = MIN ( priv->view.y0, PCB->MaxHeight);
 
   /* Fix up noted event coordinates to match where we clamped. Alternatively
    * we could call ghid_note_event_location (NULL); to get a new pointer
@@ -1347,8 +1384,8 @@ pan_common (GHidPort *port)
   ghid_event_to_pcb_coords (event_x, event_y, &gport->pcb_x, &gport->pcb_y);
 
   ghidgui->adjustment_changed_holdoff = TRUE;
-  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view.x0);
-  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view.y0);
+  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), priv->view.x0);
+  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), priv->view.y0);
   ghidgui->adjustment_changed_holdoff = FALSE;
 
   ghid_port_ranges_changed();
@@ -1357,8 +1394,8 @@ pan_common (GHidPort *port)
 void
 ghid_pan_view_abs (Coord pcb_x, Coord pcb_y, int widget_x, int widget_y)
 {
-  gport->view.x0 = SIDE_X (pcb_x) - widget_x * gport->view.coord_per_px;
-  gport->view.y0 = SIDE_Y (pcb_y) - widget_y * gport->view.coord_per_px;
+  priv->view.x0 = SIDE_X (pcb_x) - widget_x * priv->view.coord_per_px;
+  priv->view.y0 = SIDE_Y (pcb_y) - widget_y * priv->view.coord_per_px;
 
   pan_common (gport);
 }
@@ -1366,24 +1403,25 @@ ghid_pan_view_abs (Coord pcb_x, Coord pcb_y, int widget_x, int widget_y)
 void
 ghid_pan_view_rel (Coord dx, Coord dy)
 {
-  gport->view.x0 += dx;
-  gport->view.y0 += dy;
+  priv->view.x0 += dx;
+  priv->view.y0 += dy;
 
   pan_common (gport);
 }
 
 
-/* gport->view.coord_per_px:
+/* priv->view.coord_per_px:
  * zoom value is PCB units per screen pixel.  Larger numbers mean zooming
  * out - the largest value means you are looking at the whole board.
  *
- * gport->view_width and gport->view_height are in PCB coordinates
+ * priv->view_width and priv->view_height are in PCB coordinates
  */
 
 #define ALLOW_ZOOM_OUT_BY 10 /* Arbitrary, and same as the lesstif HID */
 void
 ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
 {
+  render_priv *priv = gport->render_priv;
   double min_zoom, max_zoom;
   double xtmp, ytmp;
 
@@ -1396,18 +1434,18 @@ ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
                   PCB->MaxHeight / gport->height) * ALLOW_ZOOM_OUT_BY;
   new_zoom = MIN (MAX (min_zoom, new_zoom), max_zoom);
 
-  if (gport->view.coord_per_px == new_zoom)
+  if (priv->view.coord_per_px == new_zoom)
     return;
 
-  xtmp = (SIDE_X (center_x) - gport->view.x0) / (double)gport->view.width;
-  ytmp = (SIDE_Y (center_y) - gport->view.y0) / (double)gport->view.height;
+  xtmp = (SIDE_X (center_x) - priv->view.x0) / (double)priv->view.width;
+  ytmp = (SIDE_Y (center_y) - priv->view.y0) / (double)priv->view.height;
 
-  gport->view.coord_per_px = new_zoom;
+  priv->view.coord_per_px = new_zoom;
   pixel_slop = new_zoom;
   ghid_port_ranges_scale ();
 
-  gport->view.x0 = SIDE_X (center_x) - xtmp * gport->view.width;
-  gport->view.y0 = SIDE_Y (center_y) - ytmp * gport->view.height;
+  priv->view.x0 = SIDE_X (center_x) - xtmp * priv->view.width;
+  priv->view.y0 = SIDE_Y (center_y) - ytmp * priv->view.height;
 
   pan_common (gport);
 
@@ -1417,7 +1455,7 @@ ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
 void
 ghid_zoom_view_rel (Coord center_x, Coord center_y, double factor)
 {
-  ghid_zoom_view_abs (center_x, center_y, gport->view.coord_per_px * factor);
+  ghid_zoom_view_abs (center_x, center_y, priv->view.coord_per_px * factor);
 }
 
 void
@@ -1431,13 +1469,14 @@ ghid_zoom_view_fit (void)
 void
 ghid_flip_view (Coord center_x, Coord center_y, bool flip_x, bool flip_y)
 {
+  render_priv *priv = gport->render_priv;
   int widget_x, widget_y;
 
   /* Work out where on the screen the flip point is */
   ghid_pcb_to_event_coords (center_x, center_y, &widget_x, &widget_y);
 
-  gport->view.flip_x = gport->view.flip_x != flip_x;
-  gport->view.flip_y = gport->view.flip_y != flip_y;
+  priv->view.flip_x = priv->view.flip_x != flip_x;
+  priv->view.flip_y = priv->view.flip_y != flip_y;
 
   /* Pan the board so the center location remains in the same place */
   ghid_pan_view_abs (center_x, center_y, widget_x, widget_y);
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index d42a2de..8101e93 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -38,8 +38,36 @@ static hidGC current_gc = NULL;
 */
 #define USE_GC(gc) if (!use_gc(gc)) return
 
+#define FLIP_X(x)         ((priv->view.flip_x ? -(x) : (x)))
+#define FLIP_Y(y)         ((priv->view.flip_y ? -(y) : (y)))
+
+#define SIDE_X(x)         ((priv->view.flip_x ? PCB->MaxWidth  - (x) : (x)))
+#define SIDE_Y(y)         ((priv->view.flip_y ? PCB->MaxHeight - (y) : (y)))
+
+#define DRAW_X(x)         (int)((SIDE_X(x) - priv->view.x0) / priv->view.coord_per_px)
+#define DRAW_Y(y)         (int)((SIDE_Y(y) - priv->view.y0) / priv->view.coord_per_px)
+
+#define EVENT_TO_PCB_X(x) SIDE_X((int)((x) * priv->view.coord_per_px + priv->view.x0))
+#define EVENT_TO_PCB_Y(y) SIDE_Y((int)((y) * priv->view.coord_per_px + priv->view.y0))
+
+
 static int cur_mask = -1;
 
+typedef struct view_data {
+  double coord_per_px;
+  Coord center_x;
+  Coord center_y;
+
+  Coord x0; /* XXX */
+  Coord y0; /* XXX */
+  Coord width;  /* XXX */
+  Coord height; /* XXX */
+
+  bool flip_x;
+  bool flip_y;
+  /* TODO: Rotation matrix ? */
+} view_data;
+
 typedef struct render_priv {
   GdkGLConfig *glconfig;
   bool trans_lines;
@@ -48,6 +76,8 @@ typedef struct render_priv {
   char *current_colorname;
   double current_alpha_mult;
 
+  view_data view;
+
   /* Feature for leading the user to a particular location */
   guint lead_user_timeout;
   GTimer *lead_user_timer;
@@ -74,6 +104,36 @@ hid_gc_struct;
 
 static void draw_lead_user (render_priv *priv);
 
+/* Px converts view->pcb, Vx converts pcb->view */
+static inline int
+Vz (Coord z)
+{
+  render_priv *priv = gport->render_priv;
+
+  return z / priv->view.coord_per_px + 0.5;
+}
+
+static inline Coord
+Px (int x)
+{
+  render_priv *priv = gport->render_priv;
+  Coord rv = x * priv->view.coord_per_px + priv->view.x0;
+
+  if (priv->view.flip_x)
+    rv = PCB->MaxWidth - (x * priv->view.coord_per_px + priv->view.x0);
+  return  rv;
+}
+
+static inline Coord
+Py (int y)
+{
+  render_priv *priv = gport->render_priv;
+  Coord rv = y * priv->view.coord_per_px + priv->view.y0;
+
+  if (priv->view.flip_y)
+    rv = PCB->MaxHeight - (y * priv->view.coord_per_px + priv->view.y0);
+  return  rv;
+}
 
 static void
 start_subcomposite (void)
@@ -536,19 +596,21 @@ use_gc (hidGC gc)
 void
 ghid_draw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
+  render_priv *priv = gport->render_priv;
   USE_GC (gc);
 
-  hidgl_draw_line (gc->cap, gc->width, x1, y1, x2, y2, gport->view.coord_per_px);
+  hidgl_draw_line (gc->cap, gc->width, x1, y1, x2, y2, priv->view.coord_per_px);
 }
 
 void
 ghid_draw_arc (hidGC gc, Coord cx, Coord cy, Coord xradius, Coord yradius,
                          Angle start_angle, Angle delta_angle)
 {
+  render_priv *priv = gport->render_priv;
   USE_GC (gc);
 
   hidgl_draw_arc (gc->width, cx, cy, xradius, yradius,
-                  start_angle, delta_angle, gport->view.coord_per_px);
+                  start_angle, delta_angle, priv->view.coord_per_px);
 }
 
 void
@@ -563,9 +625,10 @@ ghid_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 void
 ghid_fill_circle (hidGC gc, Coord cx, Coord cy, Coord radius)
 {
+  render_priv *priv = gport->render_priv;
   USE_GC (gc);
 
-  hidgl_fill_circle (cx, cy, radius, gport->view.coord_per_px);
+  hidgl_fill_circle (cx, cy, radius, priv->view.coord_per_px);
 }
 
 
@@ -580,9 +643,10 @@ ghid_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
 void
 ghid_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
 {
+  render_priv *priv = gport->render_priv;
   USE_GC (gc);
 
-  hidgl_fill_pcb_polygon (poly, clip_box, gport->view.coord_per_px);
+  hidgl_fill_pcb_polygon (poly, clip_box, priv->view.coord_per_px);
 }
 
 void
@@ -743,10 +807,11 @@ draw_crosshair (gint x, gint y, gint z)
 void
 ghid_show_crosshair (gboolean paint_new_location)
 {
+  render_priv *priv = gport->render_priv;
   gint x, y, z;
   gboolean draw_markers;
-  int vcw = VCW * gport->view.coord_per_px;
-  int vcd = VCD * gport->view.coord_per_px;
+  int vcw = VCW * priv->view.coord_per_px;
+  int vcd = VCD * priv->view.coord_per_px;
   static int done_once = 0;
   static GdkColor cross_color;
 
@@ -783,25 +848,25 @@ ghid_show_crosshair (gboolean paint_new_location)
   if (x >= 0 && paint_new_location && draw_markers)
     {
       glBegin (GL_QUADS);
-      glVertex3i (SIDE_X (gport->view.x0),                            y - vcd,       z);
-      glVertex3i (SIDE_X (gport->view.x0),                            y - vcd + vcw, z);
-      glVertex3i (SIDE_X (gport->view.x0 + vcd),                      y - vcd + vcw, z);
-      glVertex3i (SIDE_X (gport->view.x0 + vcd),                      y - vcd,       z);
-
-      glVertex3i (SIDE_X (gport->view.x0 + gport->view.width),        y - vcd,       z);
-      glVertex3i (SIDE_X (gport->view.x0 + gport->view.width),        y - vcd + vcw, z);
-      glVertex3i (SIDE_X (gport->view.x0 + gport->view.width - vcd),  y - vcd + vcw, z);
-      glVertex3i (SIDE_X (gport->view.x0 + gport->view.width - vcd),  y - vcd,       z);
-
-      glVertex3i (x - vcd,       SIDE_Y (gport->view.y0),                            z);
-      glVertex3i (x - vcd,       SIDE_Y (gport->view.y0 + vcd),                      z);
-      glVertex3i (x - vcd + vcw, SIDE_Y (gport->view.y0 + vcd),                      z);
-      glVertex3i (x - vcd + vcw, SIDE_Y (gport->view.y0),                            z);
-
-      glVertex3i (x - vcd,       SIDE_Y (gport->view.y0 + gport->view.height - vcd), z);
-      glVertex3i (x - vcd,       SIDE_Y (gport->view.y0 + gport->view.height),       z);
-      glVertex3i (x - vcd + vcw, SIDE_Y (gport->view.y0 + gport->view.height),       z);
-      glVertex3i (x - vcd + vcw, SIDE_Y (gport->view.y0 + gport->view.height - vcd), z);
+      glVertex3i (SIDE_X (priv->view.x0),                            y - vcd,       z);
+      glVertex3i (SIDE_X (priv->view.x0),                            y - vcd + vcw, z);
+      glVertex3i (SIDE_X (priv->view.x0 + vcd),                      y - vcd + vcw, z);
+      glVertex3i (SIDE_X (priv->view.x0 + vcd),                      y - vcd,       z);
+
+      glVertex3i (SIDE_X (priv->view.x0 + priv->view.width),        y - vcd,       z);
+      glVertex3i (SIDE_X (priv->view.x0 + priv->view.width),        y - vcd + vcw, z);
+      glVertex3i (SIDE_X (priv->view.x0 + priv->view.width - vcd),  y - vcd + vcw, z);
+      glVertex3i (SIDE_X (priv->view.x0 + priv->view.width - vcd),  y - vcd,       z);
+
+      glVertex3i (x - vcd,       SIDE_Y (priv->view.y0),                            z);
+      glVertex3i (x - vcd,       SIDE_Y (priv->view.y0 + vcd),                      z);
+      glVertex3i (x - vcd + vcw, SIDE_Y (priv->view.y0 + vcd),                      z);
+      glVertex3i (x - vcd + vcw, SIDE_Y (priv->view.y0),                            z);
+
+      glVertex3i (x - vcd,       SIDE_Y (priv->view.y0 + priv->view.height - vcd), z);
+      glVertex3i (x - vcd,       SIDE_Y (priv->view.y0 + priv->view.height),       z);
+      glVertex3i (x - vcd + vcw, SIDE_Y (priv->view.y0 + priv->view.height),       z);
+      glVertex3i (x - vcd + vcw, SIDE_Y (priv->view.y0 + priv->view.height - vcd), z);
 
       glEnd ();
     }
@@ -857,6 +922,11 @@ ghid_init_drawing_widget (GtkWidget *widget, GHidPort *port)
 void
 ghid_drawing_area_configure_hook (GHidPort *port)
 {
+  render_priv *priv = port->render_priv;
+  GtkWidget *widget = port->drawing_area;
+
+  priv->view.width =  widget->allocation.width  * priv->view.coord_per_px;
+  priv->view.height = widget->allocation.height * priv->view.coord_per_px;
 }
 
 gboolean
@@ -933,13 +1003,13 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glLoadIdentity ();
   glTranslatef (0.0f, 0.0f, -Z_NEAR);
 
-  glScalef ((port->view.flip_x ? -1. : 1.) / port->view.coord_per_px,
-            (port->view.flip_y ? -1. : 1.) / port->view.coord_per_px,
-            ((port->view.flip_x == port->view.flip_y) ? 1. : -1.) / port->view.coord_per_px);
-  glTranslatef (port->view.flip_x ? port->view.x0 - PCB->MaxWidth  :
-                             -port->view.x0,
-                port->view.flip_y ? port->view.y0 - PCB->MaxHeight :
-                             -port->view.y0, 0);
+  glScalef ((priv->view.flip_x ? -1. : 1.) / priv->view.coord_per_px,
+            (priv->view.flip_y ? -1. : 1.) / priv->view.coord_per_px,
+            ((priv->view.flip_x == priv->view.flip_y) ? 1. : -1.) / priv->view.coord_per_px);
+  glTranslatef (priv->view.flip_x ? priv->view.x0 - PCB->MaxWidth  :
+                             -priv->view.x0,
+                priv->view.flip_y ? priv->view.y0 - PCB->MaxHeight :
+                             -priv->view.y0, 0);
 
   glEnable (GL_STENCIL_TEST);
   glClearColor (port->offlimits_color.red / 65535.,
@@ -1025,23 +1095,15 @@ gboolean
 ghid_pinout_preview_expose (GtkWidget *widget,
                             GdkEventExpose *ev)
 {
+  render_priv *priv = gport->render_priv;
   GdkGLContext* pGlContext = gtk_widget_get_gl_context (widget);
   GdkGLDrawable* pGlDrawable = gtk_widget_get_gl_drawable (widget);
   GhidPinoutPreview *pinout = GHID_PINOUT_PREVIEW (widget);
-  double save_zoom;
+  view_data save_view;
   int da_w, da_h;
-  int save_left, save_top;
-  int save_width, save_height;
-  int save_view_width, save_view_height;
   double xz, yz;
 
-  save_zoom = gport->view.coord_per_px;
-  save_width = gport->width;
-  save_height = gport->height;
-  save_left = gport->view.x0;
-  save_top = gport->view.y0;
-  save_view_width = gport->view.width;
-  save_view_height = gport->view.height;
+  save_view = priv->view;
 
   /* Setup zoom factor for drawing routines */
 
@@ -1049,16 +1111,14 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   xz = (double) pinout->x_max / da_w;
   yz = (double) pinout->y_max / da_h;
   if (xz > yz)
-    gport->view.coord_per_px = xz;
+    priv->view.coord_per_px = xz;
   else
-    gport->view.coord_per_px = yz;
+    priv->view.coord_per_px = yz;
 
-  gport->width = da_w;
-  gport->height = da_h;
-  gport->view.width = da_w * gport->view.coord_per_px;
-  gport->view.height = da_h * gport->view.coord_per_px;
-  gport->view.x0 = (pinout->x_max - gport->view.width) / 2;
-  gport->view.y0 = (pinout->y_max - gport->view.height) / 2;
+  priv->view.width = da_w  * priv->view.coord_per_px;
+  priv->view.height = da_h * priv->view.coord_per_px;
+  priv->view.x0 = (pinout->x_max - priv->view.width) / 2;
+  priv->view.y0 = (pinout->y_max - priv->view.height) / 2;
 
   /* make GL-context "current" */
   if (!gdk_gl_drawable_gl_begin (pGlDrawable, pGlContext)) {
@@ -1097,12 +1157,12 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
   glPushMatrix ();
-  glScalef ((gport->view.flip_x ? -1. : 1.) / gport->view.coord_per_px,
-            (gport->view.flip_y ? -1. : 1.) / gport->view.coord_per_px, 1);
-  glTranslatef (gport->view.flip_x ? gport->view.x0 - PCB->MaxWidth  :
-                                    -gport->view.x0,
-                gport->view.flip_y ? gport->view.y0 - PCB->MaxHeight :
-                                    -gport->view.y0, 0);
+  glScalef ((priv->view.flip_x ? -1. : 1.) / priv->view.coord_per_px,
+            (priv->view.flip_y ? -1. : 1.) / priv->view.coord_per_px, 1);
+  glTranslatef (priv->view.flip_x ? priv->view.x0 - PCB->MaxWidth  :
+                                   -priv->view.x0,
+                priv->view.flip_y ? priv->view.y0 - PCB->MaxHeight :
+                                   -priv->view.y0, 0);
   hid_expose_callback (&ghid_hid, NULL, &pinout->element);
   hidgl_flush_triangles (&buffer);
   glPopMatrix ();
@@ -1116,13 +1176,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   gport->render_priv->in_context = false;
   gdk_gl_drawable_gl_end (pGlDrawable);
 
-  gport->view.coord_per_px = save_zoom;
-  gport->width = save_width;
-  gport->height = save_height;
-  gport->view.x0 = save_left;
-  gport->view.y0 = save_top;
-  gport->view.width = save_view_width;
-  gport->view.height = save_view_height;
+  priv->view = save_view;
 
   return FALSE;
 }
@@ -1131,24 +1185,16 @@ ghid_pinout_preview_expose (GtkWidget *widget,
 GdkPixmap *
 ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int depth)
 {
+  render_priv *priv = gport->render_priv;
   GdkGLConfig *glconfig;
   GdkPixmap *pixmap;
   GdkGLPixmap *glpixmap;
   GdkGLContext* glcontext;
   GdkGLDrawable* gldrawable;
-  double save_zoom;
-  int save_left, save_top;
-  int save_width, save_height;
-  int save_view_width, save_view_height;
+  view_data save_view;
   BoxType region;
 
-  save_zoom = gport->view.coord_per_px;
-  save_width = gport->width;
-  save_height = gport->height;
-  save_left = gport->view.x0;
-  save_top = gport->view.y0;
-  save_view_width = gport->view.width;
-  save_view_height = gport->view.height;
+  save_view = priv->view;
 
   /* Setup rendering context for drawing routines
    */
@@ -1164,15 +1210,13 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
 
   /* Setup zoom factor for drawing routines */
 
-  gport->view.coord_per_px = zoom;
-  gport->width = width;
-  gport->height = height;
-  gport->view.width = width * gport->view.coord_per_px;
-  gport->view.height = height * gport->view.coord_per_px;
-  gport->view.x0 = gport->view.flip_x ? PCB->MaxWidth - cx : cx;
-  gport->view.x0 -= gport->view.height / 2;
-  gport->view.y0 = gport->view.flip_y ? PCB->MaxHeight - cy : cy;
-  gport->view.y0 -= gport->view.width / 2;
+  priv->view.coord_per_px = zoom;
+  priv->view.width = width   * priv->view.coord_per_px;
+  priv->view.height = height * priv->view.coord_per_px;
+  priv->view.x0 = priv->view.flip_x ? PCB->MaxWidth - cx : cx;
+  priv->view.x0 -= priv->view.height / 2;
+  priv->view.y0 = priv->view.flip_y ? PCB->MaxHeight - cy : cy;
+  priv->view.y0 -= priv->view.width  / 2;
 
   /* make GL-context "current" */
   if (!gdk_gl_drawable_gl_begin (gldrawable, glcontext)) {
@@ -1208,17 +1252,17 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
   glPushMatrix ();
-  glScalef ((gport->view.flip_x ? -1. : 1.) / gport->view.coord_per_px,
-            (gport->view.flip_y ? -1. : 1.) / gport->view.coord_per_px, 1);
-  glTranslatef (gport->view.flip_x ? gport->view.x0 - PCB->MaxWidth  :
-                                    -gport->view.x0,
-                gport->view.flip_y ? gport->view.y0 - PCB->MaxHeight :
-                                    -gport->view.y0, 0);
-
-  region.X1 = MIN(Px(0), Px(gport->width + 1));
-  region.Y1 = MIN(Py(0), Py(gport->height + 1));
-  region.X2 = MAX(Px(0), Px(gport->width + 1));
-  region.Y2 = MAX(Py(0), Py(gport->height + 1));
+  glScalef ((priv->view.flip_x ? -1. : 1.) / priv->view.coord_per_px,
+            (priv->view.flip_y ? -1. : 1.) / priv->view.coord_per_px, 1);
+  glTranslatef (priv->view.flip_x ? priv->view.x0 - PCB->MaxWidth  :
+                                   -priv->view.x0,
+                priv->view.flip_y ? priv->view.y0 - PCB->MaxHeight :
+                                   -priv->view.y0, 0);
+
+  region.X1 = MIN(Px(0), Px(width + 1));
+  region.Y1 = MIN(Py(0), Py(height + 1));
+  region.X2 = MAX(Px(0), Px(width + 1));
+  region.Y2 = MAX(Py(0), Py(height + 1));
 
   region.X1 = MAX (0, MIN (PCB->MaxWidth,  region.X1));
   region.X2 = MAX (0, MIN (PCB->MaxWidth,  region.X2));
@@ -1240,13 +1284,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   g_object_unref (glconfig);
   g_object_unref (glcontext);
 
-  gport->view.coord_per_px = save_zoom;
-  gport->width = save_width;
-  gport->height = save_height;
-  gport->view.x0 = save_left;
-  gport->view.y0 = save_top;
-  gport->view.width = save_view_width;
-  gport->view.height = save_view_height;
+  priv->view = save_view;
 
   return pixmap;
 }
@@ -1255,6 +1293,7 @@ HID *
 ghid_request_debug_draw (void)
 {
   GHidPort *port = gport;
+  render_priv *priv = port->render_priv;
   GtkWidget *widget = port->drawing_area;
 
   ghid_start_drawing (port);
@@ -1275,13 +1314,13 @@ ghid_request_debug_draw (void)
   glDisable (GL_STENCIL_TEST);
 
   glPushMatrix ();
-  glScalef ((port->view.flip_x ? -1. : 1.) / port->view.coord_per_px,
-            (port->view.flip_y ? -1. : 1.) / port->view.coord_per_px,
-            (port->view.flip_x == port->view.flip_y) ? 1. : -1.);
-  glTranslatef (port->view.flip_x ? port->view.x0 - PCB->MaxWidth  :
-                             -port->view.x0,
-                port->view.flip_y ? port->view.y0 - PCB->MaxHeight :
-                             -port->view.y0, 0);
+  glScalef ((priv->view.flip_x ? -1. : 1.) / priv->view.coord_per_px,
+            (priv->view.flip_y ? -1. : 1.) / priv->view.coord_per_px,
+            (priv->view.flip_x == priv->view.flip_y) ? 1. : -1.);
+  glTranslatef (priv->view.flip_x ? priv->view.x0 - PCB->MaxWidth  :
+                             -priv->view.x0,
+                priv->view.flip_y ? priv->view.y0 - PCB->MaxHeight :
+                             -priv->view.y0, 0);
 
   return &ghid_hid;
 }
@@ -1312,6 +1351,8 @@ ghid_finish_debug_draw (void)
 bool
 ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y)
 {
+  render_priv *priv = gport->render_priv;
+
   *pcb_x = EVENT_TO_PCB_X (event_x);
   *pcb_y = EVENT_TO_PCB_Y (event_y);
 
@@ -1321,6 +1362,8 @@ ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y)
 bool
 ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y)
 {
+  render_priv *priv = gport->render_priv;
+
   *event_x = DRAW_X (pcb_x);
   *event_y = DRAW_Y (pcb_y);
 
@@ -1328,7 +1371,7 @@ ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y)
 }
 
 static void
-pan_common (GHidPort *port)
+pan_common (render_priv *priv)
 {
   int event_x, event_y;
 
@@ -1337,10 +1380,10 @@ pan_common (GHidPort *port)
   ghid_pcb_to_event_coords (gport->pcb_x, gport->pcb_y, &event_x, &event_y);
 
   /* Don't pan so far the board is completely off the screen */
-  port->view.x0 = MAX (-port->view.width,  port->view.x0);
-  port->view.y0 = MAX (-port->view.height, port->view.y0);
-  port->view.x0 = MIN ( port->view.x0, PCB->MaxWidth);
-  port->view.y0 = MIN ( port->view.y0, PCB->MaxHeight);
+  priv->view.x0 = MAX (-priv->view.width,  priv->view.x0);
+  priv->view.y0 = MAX (-priv->view.height, priv->view.y0);
+  priv->view.x0 = MIN ( priv->view.x0, PCB->MaxWidth);
+  priv->view.y0 = MIN ( priv->view.y0, PCB->MaxHeight);
 
   /* Fix up noted event coordinates to match where we clamped. Alternatively
    * we could call ghid_note_event_location (NULL); to get a new pointer
@@ -1349,8 +1392,8 @@ pan_common (GHidPort *port)
   ghid_event_to_pcb_coords (event_x, event_y, &gport->pcb_x, &gport->pcb_y);
 
   ghidgui->adjustment_changed_holdoff = TRUE;
-  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view.x0);
-  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view.y0);
+  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), priv->view.x0);
+  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), priv->view.y0);
   ghidgui->adjustment_changed_holdoff = FALSE;
 
   ghid_port_ranges_changed();
@@ -1359,33 +1402,49 @@ pan_common (GHidPort *port)
 void
 ghid_pan_view_abs (Coord pcb_x, Coord pcb_y, int widget_x, int widget_y)
 {
-  gport->view.x0 = SIDE_X (pcb_x) - widget_x * gport->view.coord_per_px;
-  gport->view.y0 = SIDE_Y (pcb_y) - widget_y * gport->view.coord_per_px;
+  render_priv *priv = gport->render_priv;
+
+  priv->view.x0 = SIDE_X (pcb_x) - widget_x * priv->view.coord_per_px;
+  priv->view.y0 = SIDE_Y (pcb_y) - widget_y * priv->view.coord_per_px;
 
-  pan_common (gport);
+  pan_common (priv);
 }
 
 void
 ghid_pan_view_rel (Coord dx, Coord dy)
 {
-  gport->view.x0 += dx;
-  gport->view.y0 += dy;
+  render_priv *priv = gport->render_priv;
 
-  pan_common (gport);
+  priv->view.x0 += dx;
+  priv->view.y0 += dy;
+
+  pan_common (priv);
 }
 
+void
+ghid_pan_view_rel_to_visible (double fraction_x, double fraction_y)
+{
+  render_priv *priv = gport->render_priv;
+
+  priv->view.x0 = MAX (0, priv->view.x0 + FLIP_X (priv->view.width)  * fraction_x);
+  priv->view.y0 = MAX (0, priv->view.y0 + FLIP_Y (priv->view.height) * fraction_y);
+
+  pan_common (priv);
+}
 
-/* gport->view.coord_per_px:
+
+/* priv->view.coord_per_px:
  * zoom value is PCB units per screen pixel.  Larger numbers mean zooming
  * out - the largest value means you are looking at the whole board.
  *
- * gport->view_width and gport->view_height are in PCB coordinates
+ * priv->view.width and priv->view.height are in PCB coordinates
  */
 
 #define ALLOW_ZOOM_OUT_BY 10 /* Arbitrary, and same as the lesstif HID */
 void
 ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
 {
+  render_priv *priv = gport->render_priv;
   double min_zoom, max_zoom;
   double xtmp, ytmp;
 
@@ -1394,24 +1453,24 @@ ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
    * the entire board just fits inside the viewport
    */
   min_zoom = 1;
-  max_zoom = MAX (PCB->MaxWidth  / gport->width,
-                  PCB->MaxHeight / gport->height) * ALLOW_ZOOM_OUT_BY;
+  max_zoom = MAX (PCB->MaxWidth  / gport->drawing_area->allocation.width,
+                  PCB->MaxHeight / gport->drawing_area->allocation.height) * ALLOW_ZOOM_OUT_BY;
   new_zoom = MIN (MAX (min_zoom, new_zoom), max_zoom);
 
-  if (gport->view.coord_per_px == new_zoom)
+  if (priv->view.coord_per_px == new_zoom)
     return;
 
-  xtmp = (SIDE_X (center_x) - gport->view.x0) / (double)gport->view.width;
-  ytmp = (SIDE_Y (center_y) - gport->view.y0) / (double)gport->view.height;
+  xtmp = (SIDE_X (center_x) - priv->view.x0) / (double)priv->view.width;
+  ytmp = (SIDE_Y (center_y) - priv->view.y0) / (double)priv->view.height;
 
-  gport->view.coord_per_px = new_zoom;
+  priv->view.coord_per_px = new_zoom;
   pixel_slop = new_zoom;
   ghid_port_ranges_scale ();
 
-  gport->view.x0 = SIDE_X (center_x) - xtmp * gport->view.width;
-  gport->view.y0 = SIDE_Y (center_y) - ytmp * gport->view.height;
+  priv->view.x0 = SIDE_X (center_x) - xtmp * priv->view.width;
+  priv->view.y0 = SIDE_Y (center_y) - ytmp * priv->view.height;
 
-  pan_common (gport);
+  pan_common (priv);
 
   ghid_set_status_line_label ();
 }
@@ -1419,27 +1478,31 @@ ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
 void
 ghid_zoom_view_rel (Coord center_x, Coord center_y, double factor)
 {
-  ghid_zoom_view_abs (center_x, center_y, gport->view.coord_per_px * factor);
+  render_priv *priv = gport->render_priv;
+
+  ghid_zoom_view_abs (center_x, center_y, priv->view.coord_per_px * factor);
 }
 
 void
 ghid_zoom_view_fit (void)
 {
+
   ghid_pan_view_abs (0, 0, 0, 0);
-  ghid_zoom_view_abs (0, 0, MAX (PCB->MaxWidth  / gport->width,
-                                 PCB->MaxHeight / gport->height));
+  ghid_zoom_view_abs (0, 0, MAX (PCB->MaxWidth  / gport->drawing_area->allocation.width,
+                                 PCB->MaxHeight / gport->drawing_area->allocation.height));
 }
 
 void
 ghid_flip_view (Coord center_x, Coord center_y, bool flip_x, bool flip_y)
 {
+  render_priv *priv = gport->render_priv;
   int widget_x, widget_y;
 
   /* Work out where on the screen the flip point is */
   ghid_pcb_to_event_coords (center_x, center_y, &widget_x, &widget_y);
 
-  gport->view.flip_x = gport->view.flip_x != flip_x;
-  gport->view.flip_y = gport->view.flip_y != flip_y;
+  priv->view.flip_x = priv->view.flip_x != flip_x;
+  priv->view.flip_y = priv->view.flip_y != flip_y;
 
   /* Pan the board so the center location remains in the same place */
   ghid_pan_view_abs (center_x, center_y, widget_x, widget_y);
@@ -1484,7 +1547,7 @@ draw_lead_user (render_priv *priv)
 
       /* Draw an arc at radius */
       hidgl_draw_arc (width, priv->lead_user_x, priv->lead_user_y,
-                      radius, radius, 0, 360, gport->view.coord_per_px);
+                      radius, radius, 0, 360, priv->view.coord_per_px);
     }
 
   hidgl_flush_triangles (&buffer);
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index b7fa8ad..7028805 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -1460,8 +1460,8 @@ Center(int argc, char **argv, Coord pcb_x, Coord pcb_y)
     AFAIL (center);
 
   /* Aim to put the given x, y PCB coordinates in the center of the widget */
-  widget_x = gport->width / 2;
-  widget_y = gport->height / 2;
+  widget_x = gport->drawing_area->allocation.width / 2;
+  widget_y = gport->drawing_area->allocation.height / 2;
 
   ghid_pan_view_abs (pcb_x, pcb_y, widget_x, widget_y);
 
@@ -1531,13 +1531,13 @@ CursorAction(int argc, char **argv, Coord x, Coord y)
 {
   UnitList extra_units_x = {
     { "grid",  PCB->Grid, 0 },
-    { "view",  gport->view.width, UNIT_PERCENT },
+//    { "view",  gport->view_width, UNIT_PERCENT },
     { "board", PCB->MaxWidth, UNIT_PERCENT },
     { "", 0, 0 }
   };
   UnitList extra_units_y = {
     { "grid",  PCB->Grid, 0 },
-    { "view",  gport->view.height, UNIT_PERCENT },
+//    { "view",  gport->view_height, UNIT_PERCENT },
     { "board", PCB->MaxHeight, UNIT_PERCENT },
     { "", 0, 0 }
   };
@@ -1555,11 +1555,12 @@ CursorAction(int argc, char **argv, Coord x, Coord y)
     AFAIL (cursor);
 
   dx = GetValueEx (argv[1], argv[3], NULL, extra_units_x, "");
-  if (gport->view.flip_x)
-    dx = -dx;
   dy = GetValueEx (argv[2], argv[3], NULL, extra_units_y, "");
-  if (!gport->view.flip_y)
-    dy = -dy;
+
+#if 0 /* We cannot know this sensibly from the renderer, so we have to remove it */
+  if (gport->view.flip_x) dx = -dx;
+  if (gport->view.flip_x) dy = -dy;
+#endif
 
   EventMoveCrosshair (Crosshair.X + dx, Crosshair.Y + dy);
   gui->set_crosshair (Crosshair.X, Crosshair.Y, pan_warp);
@@ -1713,8 +1714,9 @@ default is given, div=40.
 static int
 ScrollAction (int argc, char **argv, Coord x, Coord y)
 {
-  gdouble dx = 0.0, dy = 0.0;
-  int div = 40;
+  double dx = 0.;
+  double dy = 0.;
+  double fraction = 1. / 40.;
 
   if (!ghidgui)
     return 0;
@@ -1723,20 +1725,20 @@ ScrollAction (int argc, char **argv, Coord x, Coord y)
     AFAIL (scroll);
 
   if (argc == 2)
-    div = atoi(argv[1]);
+    fraction = 1. / (double) atoi(argv[1]);
 
   if (strcasecmp (argv[0], "up") == 0)
-    dy = -gport->view.height / div;
-  else if (strcasecmp (argv[0], "down") == 0)
-    dy = gport->view.height / div;
+    dy = -fraction;
+  else if (strcasecmp (argv[0], "down")  == 0)
+    dy =  fraction;
   else if (strcasecmp (argv[0], "right") == 0)
-    dx = gport->view.width / div;
-  else if (strcasecmp (argv[0], "left") == 0)
-    dx = -gport->view.width / div;
+    dx =  fraction;
+  else if (strcasecmp (argv[0], "left")  == 0)
+    dx = -fraction;
   else
     AFAIL (scroll);
 
-  ghid_pan_view_rel (dx, dy);
+  ghid_pan_view_rel_to_visible (dx, dy);
 
   return 0;
 }
@@ -1940,25 +1942,6 @@ HID_Action ghid_main_action_list[] = {
 REGISTER_ACTIONS (ghid_main_action_list)
 
 
-static int
-flag_flipx (int x)
-{
-  return gport->view.flip_x;
-}
-
-static int
-flag_flipy (int x)
-{
-  return gport->view.flip_y;
-}
-
-HID_Flag ghid_main_flag_list[] = {
-  {"flip_x", flag_flipx, 0},
-  {"flip_y", flag_flipy, 0}
-};
-
-REGISTER_FLAGS (ghid_main_flag_list)
-
 #include "dolists.h"
 
 /*
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index 5929a37..b2f092a 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -52,16 +52,18 @@
 
 #define TOOLTIP_UPDATE_DELAY 200
 
-static gint x_pan_speed, y_pan_speed;
+static double x_pan_speed, y_pan_speed;
 void
 ghid_port_ranges_changed (void)
 {
+#if 0
   GtkAdjustment *h_adj, *v_adj;
 
   h_adj = gtk_range_get_adjustment (GTK_RANGE (ghidgui->h_range));
   v_adj = gtk_range_get_adjustment (GTK_RANGE (ghidgui->v_range));
   gport->view.x0 = h_adj->value;
   gport->view.y0 = v_adj->value;
+#endif
 
   ghid_invalidate_all ();
 }
@@ -72,6 +74,7 @@ ghid_port_ranges_changed (void)
 void
 ghid_port_ranges_scale (void)
 {
+#if 0
   GtkAdjustment *adj;
 
   /* Update the scrollbars with PCB units.  So Scale the current
@@ -94,6 +97,7 @@ ghid_port_ranges_scale (void)
   adj->step_increment = adj->page_size / 100.0;
   adj->lower = -gport->view.height;
   adj->upper = PCB->MaxHeight + adj->page_size;
+#endif
 }
 
 
@@ -385,14 +389,11 @@ ghid_port_drawing_area_configure_event_cb (GtkWidget * widget,
 {
   static gboolean first_time_done;
 
-  gport->width = ev->width;
-  gport->height = ev->height;
-
   if (gport->pixmap)
     gdk_pixmap_unref (gport->pixmap);
 
   gport->pixmap = gdk_pixmap_new (widget->window,
-				  gport->width, gport->height, -1);
+				  ev->width, ev->height, -1);
   gport->drawable = gport->pixmap;
 
   if (!first_time_done)
@@ -540,24 +541,20 @@ gint
 ghid_port_window_motion_cb (GtkWidget * widget,
 			    GdkEventMotion * ev, GHidPort * out)
 {
-  gdouble dx, dy;
-  static gint x_prev = -1, y_prev = -1;
-
   gdk_event_request_motions (ev);
 
   if (out->panning)
     {
-      dx = gport->view.coord_per_px * (x_prev - ev->x);
-      dy = gport->view.coord_per_px * (y_prev - ev->y);
-      if (x_prev > 0)
-        ghid_pan_view_rel (dx, dy);
-      x_prev = ev->x;
-      y_prev = ev->y;
+      /* gport->pcb_x and gport->pcb_y will correspond to where the user
+       * grabbed the board. Move the board so that location lands where
+       * the mouse pointer now is, as indicated by the event.
+       */
+      ghid_pan_view_abs (gport->pcb_x, gport->pcb_y, ev->x, ev->y);
+
       return FALSE;
     }
-  x_prev = y_prev = -1;
-  ghid_note_event_location ((GdkEventButton *)ev);
 
+  ghid_note_event_location ((GdkEventButton *)ev);
   queue_tooltip_update (out);
 
   return FALSE;
@@ -599,14 +596,11 @@ ghid_port_window_enter_cb (GtkWidget * widget,
 static gboolean
 ghid_pan_idle_cb (gpointer data)
 {
-  gdouble dx = 0, dy = 0;
-
   if (gport->has_entered)
     return FALSE;
 
-  dy = gport->view.coord_per_px * y_pan_speed;
-  dx = gport->view.coord_per_px * x_pan_speed;
-  ghid_pan_view_rel (dx, dy);
+  ghid_pan_view_rel_to_visible (x_pan_speed, y_pan_speed);
+
   return TRUE;
 }
 
@@ -614,9 +608,7 @@ gint
 ghid_port_window_leave_cb (GtkWidget * widget, 
                            GdkEventCrossing * ev, GHidPort * out)
 {
-  Coord x0, y0, x, y, dx, dy, w, h;
-  
-  /* printf("leave mode: %d detail: %d\n", ev->mode, ev->detail); */
+//  Coord x0, y0, x, y, dx, dy, w, h;
 
   /* Window leave events can also be triggered because of focus grabs. Some
    * X applications occasionally grab the focus and so trigger this function.
@@ -626,9 +618,7 @@ ghid_port_window_leave_cb (GtkWidget * widget,
    */
 
   if(ev->mode != GDK_CROSSING_NORMAL)
-    {
-      return FALSE;
-    }
+    return FALSE;
 
   if(out->has_entered && !ghidgui->in_popup)
     {
@@ -639,6 +629,7 @@ ghid_port_window_leave_cb (GtkWidget * widget,
 	  /* GdkEvent coords are set to 0,0 at leave events, so must figure
 	     |  out edge the cursor left.
 	   */
+#if 0
 	  w = ghid_port.width * out->view.coord_per_px;
 	  h = ghid_port.height * out->view.coord_per_px;
 
@@ -648,16 +639,16 @@ ghid_port_window_leave_cb (GtkWidget * widget,
 	  x -= x0;
 	  y -= y0;
 
-	  if (gport->view.flip_x)
-	      x = -x;
-	  if (gport->view.flip_y)
-	      y = -y;
+	  if (gport->view.flip_x) x = -x;
+	  if (gport->view.flip_y) y = -y;
 
 	  dx = w - x;
 	  dy = h - y;
+#endif
 
 	  x_pan_speed = y_pan_speed = 2 * ghidgui->auto_pan_speed;
 
+#if 0
 	  if (x < dx)
 	    {
 	      x_pan_speed = -x_pan_speed;
@@ -682,6 +673,7 @@ ghid_port_window_leave_cb (GtkWidget * widget,
 	      else
 		x_pan_speed = 0;
 	    }
+#endif
 	  g_idle_add (ghid_pan_idle_cb, NULL);
 	}
     }
diff --git a/src/hid/gtk/gui-top-window.c b/src/hid/gtk/gui-top-window.c
index e2beb3c..51e8454 100644
--- a/src/hid/gtk/gui-top-window.c
+++ b/src/hid/gtk/gui-top-window.c
@@ -1986,7 +1986,6 @@ ghid_parse_arguments (int *argc, char ***argv)
   gtk_init (argc, argv);
 
   gport = &ghid_port;
-  gport->view.coord_per_px = 300.0;
   pixel_slop = 300;
 
   ghid_init_renderer (argc, argv, gport);
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index b1cc5f5..067277e 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -62,15 +62,6 @@
 #define	FROM_PCB_UNITS(v)	coord_to_unit (Settings.grid_unit, v)
 #define	TO_PCB_UNITS(v)		unit_to_coord (Settings.grid_unit, v)
 
-#define SIDE_X(x)         ((gport->view.flip_x ? PCB->MaxWidth - (x) : (x)))
-#define SIDE_Y(y)         ((gport->view.flip_y ? PCB->MaxHeight - (y) : (y)))
-
-#define	DRAW_X(x)         (gint)((SIDE_X(x) - gport->view.x0) / gport->view.coord_per_px)
-#define	DRAW_Y(y)         (gint)((SIDE_Y(y) - gport->view.y0) / gport->view.coord_per_px)
-
-#define	EVENT_TO_PCB_X(x) SIDE_X((gint)((x) * gport->view.coord_per_px + gport->view.x0))
-#define	EVENT_TO_PCB_Y(y) SIDE_Y((gint)((y) * gport->view.coord_per_px + gport->view.y0))
-
 /*
  * Used to intercept "special" hotkeys that gtk doesn't usually pass
  * on to the menu hotkeys.  We catch them and put them back where we
@@ -144,20 +135,6 @@ GhidGui;
 
 extern GhidGui _ghidgui, *ghidgui;
 
-typedef struct
-{
-  double coord_per_px; /* Zoom level described as PCB units per screen pixel */
-
-  Coord x0;
-  Coord y0;
-  Coord width;
-  Coord height;
-
-  bool flip_x;
-  bool flip_y;
-
-} view_data;
-
   /* The output viewport
    */
 typedef struct
@@ -166,7 +143,6 @@ typedef struct
    *drawing_area;		/* and its drawing area */
   GdkPixmap *pixmap, *mask;
   GdkDrawable *drawable;	/* Current drawable for drawing routines */
-  gint width, height;
 
   struct render_priv *render_priv;
 
@@ -180,7 +156,6 @@ typedef struct
   gboolean has_entered;
   gboolean panning;
 
-  view_data view;
   Coord pcb_x, pcb_y;             /* PCB coordinates of the mouse pointer */
   Coord crosshair_x, crosshair_y; /* PCB coordinates of the crosshair     */
 }
@@ -504,6 +479,7 @@ void ghid_finish_debug_draw (void);
 bool ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y);
 bool ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y);
 void ghid_pan_view_abs (Coord pcb_x, Coord pcb_y, int widget_x, int widget_y);
+void ghid_pan_view_rel_to_visible (double fraction_x, double fraction_y);
 void ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom);
 void ghid_zoom_view_rel (Coord center_x, Coord center_y, double factor);
 void ghid_zoom_view_fit (void);
@@ -525,58 +501,4 @@ extern GdkPixmap *XC_lock_source, *XC_lock_mask;
 extern GdkPixmap *XC_clock_source, *XC_clock_mask;
 
 
-/* Coordinate conversions */
-/* Px converts view->pcb, Vx converts pcb->view */
-static inline int
-Vx (Coord x)
-{
-  int rv;
-  if (gport->view.flip_x)
-    rv = (PCB->MaxWidth - x - gport->view.x0) / gport->view.coord_per_px + 0.5;
-  else
-    rv = (x - gport->view.x0) / gport->view.coord_per_px + 0.5;
-  return rv;
-}
-
-static inline int
-Vy (Coord y)
-{
-  int rv;
-  if (gport->view.flip_y)
-    rv = (PCB->MaxHeight - y - gport->view.y0) / gport->view.coord_per_px + 0.5;
-  else
-    rv = (y - gport->view.y0) / gport->view.coord_per_px + 0.5;
-  return rv;
-}
-
-static inline int
-Vz (Coord z)
-{
-  return z / gport->view.coord_per_px + 0.5;
-}
-
-static inline Coord
-Px (int x)
-{
-  Coord rv = x * gport->view.coord_per_px + gport->view.x0;
-  if (gport->view.flip_x)
-    rv = PCB->MaxWidth - (x * gport->view.coord_per_px + gport->view.x0);
-  return  rv;
-}
-
-static inline Coord
-Py (int y)
-{
-  Coord rv = y * gport->view.coord_per_px + gport->view.y0;
-  if (gport->view.flip_y)
-    rv = PCB->MaxHeight - (y * gport->view.coord_per_px + gport->view.y0);
-  return  rv;
-}
-
-static inline Coord
-Pz (int z)
-{
-  return (z * gport->view.coord_per_px);
-}
-
 #endif /* PCB_HID_GTK_GHID_H */

Bottom: 299a3edee6777df067c58ea99d2fa1da6cc284b1
Top:    fe0375d245c3eb6bfd28450fb7ad44554554988a
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-07-24 23:11:19 +0100

hid/gtk: Implement an API to draw the user into a particular location

This is renderer-specific, but the general idea is to help the user find
a particular location on the board.


---

diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index ed34ea1..2a7c145 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -47,6 +47,15 @@ typedef struct render_priv {
   int subcomposite_stencil_bit;
   char *current_colorname;
   double current_alpha_mult;
+
+  /* Feature for leading the user to a particular location */
+  guint lead_user_timeout;
+  GTimer *lead_user_timer;
+  bool lead_user;
+  float lead_user_radius;
+  Coord lead_user_x;
+  Coord lead_user_y;
+
 } render_priv;
 
 
@@ -62,6 +71,10 @@ typedef struct hid_gc_struct
 }
 hid_gc_struct;
 
+
+static void draw_lead_user (render_priv *priv);
+
+
 static void
 start_subcomposite (void)
 {
@@ -882,6 +895,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
                              GdkEventExpose *ev,
                              GHidPort *port)
 {
+  render_priv *priv = port->render_priv;
   BoxType region;
 
   ghid_start_drawing (port);
@@ -969,6 +983,8 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   hidgl_flush_triangles (&buffer);
 
+  draw_lead_user (priv);
+
   ghid_end_drawing (port);
 
   return FALSE;
@@ -1281,3 +1297,100 @@ ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y)
 
   return true;
 }
+
+#define LEAD_USER_WIDTH           0.2          /* millimeters */
+#define LEAD_USER_PERIOD          (1000 / 20)  /* 20fps (in ms) */
+#define LEAD_USER_VELOCITY        3.           /* millimeters per second */
+#define LEAD_USER_ARC_COUNT       3
+#define LEAD_USER_ARC_SEPARATION  3.           /* millimeters */
+#define LEAD_USER_INITIAL_RADIUS  10.          /* millimetres */
+#define LEAD_USER_COLOR_R         1.
+#define LEAD_USER_COLOR_G         1.
+#define LEAD_USER_COLOR_B         0.
+
+static void
+draw_lead_user (render_priv *priv)
+{
+  int i;
+  double radius = priv->lead_user_radius;
+  double width = MM_TO_COORD (LEAD_USER_WIDTH);
+  double separation = MM_TO_COORD (LEAD_USER_ARC_SEPARATION);
+
+  if (!priv->lead_user)
+    return;
+
+  glPushAttrib (GL_CURRENT_BIT | GL_COLOR_BUFFER_BIT);
+  glEnable (GL_COLOR_LOGIC_OP);
+  glLogicOp (GL_XOR);
+  glColor3f (LEAD_USER_COLOR_R, LEAD_USER_COLOR_G,LEAD_USER_COLOR_B);
+
+
+  /* arcs at the approrpriate radii */
+
+  for (i = 0; i < LEAD_USER_ARC_COUNT; i++, radius -= separation)
+    {
+      if (radius < width)
+        radius += MM_TO_COORD (LEAD_USER_INITIAL_RADIUS);
+
+      /* Draw an arc at radius */
+      hidgl_draw_arc (width, priv->lead_user_x, priv->lead_user_y,
+                      radius, radius, 0, 360, gport->zoom);
+    }
+
+  hidgl_flush_triangles (&buffer);
+  glPopAttrib ();
+}
+
+gboolean
+lead_user_cb (gpointer data)
+{
+  render_priv *priv = data;
+  double step;
+  double elapsed_time;
+
+  /* Queue a redraw */
+  ghid_invalidate_all ();
+
+  /* Update radius */
+  elapsed_time = g_timer_elapsed (priv->lead_user_timer, NULL);
+  g_timer_start (priv->lead_user_timer);
+
+  step = MM_TO_COORD (LEAD_USER_VELOCITY) * elapsed_time;
+  if (priv->lead_user_radius > step)
+    priv->lead_user_radius -= step;
+  else
+    priv->lead_user_radius = MM_TO_COORD (LEAD_USER_INITIAL_RADIUS);
+
+  return TRUE;
+}
+
+void
+ghid_lead_user_to_location (Coord x, Coord y)
+{
+  render_priv *priv = gport->render_priv;
+
+  ghid_cancel_lead_user ();
+
+  priv->lead_user = true;
+  priv->lead_user_x = x;
+  priv->lead_user_y = y;
+  priv->lead_user_radius = MM_TO_COORD (LEAD_USER_INITIAL_RADIUS);
+  priv->lead_user_timeout = g_timeout_add (LEAD_USER_PERIOD, lead_user_cb, priv);
+  priv->lead_user_timer = g_timer_new ();
+}
+
+void
+ghid_cancel_lead_user (void)
+{
+  render_priv *priv = gport->render_priv;
+
+  if (priv->lead_user_timeout)
+    g_source_remove (priv->lead_user_timeout);
+
+  if (priv->lead_user_timer)
+    g_timer_destroy (priv->lead_user_timer);
+
+  priv->lead_user_timeout = 0;
+  priv->lead_user_timer = NULL;
+  priv->lead_user = false;
+}
diff --git a/src/hid/gtk/gui-netlist-window.c b/src/hid/gtk/gui-netlist-window.c
index 26b97bb..b8ca134 100644
--- a/src/hid/gtk/gui-netlist-window.c
+++ b/src/hid/gtk/gui-netlist-window.c
@@ -220,8 +220,9 @@ node_selection_changed_cb (GtkTreeSelection * selection, gpointer data)
   GtkTreeModel *model;
   LibraryMenuType *node_net;
   LibraryEntryType *node;
+  ConnectionType conn;
+  Coord x, y;
   static gchar *node_name;
-	gint		x0, y0, margin;
 
   if (selection_holdoff)	/* PCB is highlighting, user is not selecting */
     return;
@@ -237,7 +238,10 @@ node_selection_changed_cb (GtkTreeSelection * selection, gpointer data)
       |  if off here will get our on/off toggling out of sync.
       */
       if (node_net == node_selected_net)
-	SelectPin (node, TRUE);
+        {
+          SelectPin (node, true);
+          ghid_cancel_lead_user ();
+        }
       g_free (node_name);
       node_name = NULL;
     }
@@ -260,26 +264,33 @@ node_selection_changed_cb (GtkTreeSelection * selection, gpointer data)
   dup_string (&node_name, node->ListEntry);
   node_selected_net = selected_net;
 
-  /* Now just toggle a select of the node on the layout and pan.
+  /* Now just toggle a select of the node on the layout
    */
-  SelectPin (node, TRUE);
+  SelectPin (node, true);
   IncrementUndoSerialNumber ();
-	margin = gport->view_width / 20;
-	if (   Crosshair.X < gport->view_x0 + margin
-	    || Crosshair.X > gport->view_x0 + gport->view_width - margin
-	    || Crosshair.Y < gport->view_y0 + margin
-	    || Crosshair.Y > gport->view_y0 + gport->view_height - margin
-	   )
-	  {
-
-	    x0 = SIDE_X (Crosshair.X) - gport->view_width / 2;
-	    y0 = SIDE_Y (Crosshair.Y) - gport->view_height / 2;
-	    gport->view_x0 = x0;
-	    gport->view_y0 = y0;
-	    ghid_pan_fixup ();
-	    gui->set_crosshair (Crosshair.X, Crosshair.Y, HID_SC_WARP_POINTER);
-	  }
-	ghid_screen_update();
+
+  /* And lead the user to the location */
+  if (SeekPad (node, &conn, false))
+    switch (conn.type) {
+      case PIN_TYPE:
+        {
+          PinTypePtr pin = (PinTypePtr) conn.ptr2;
+          x = pin->X;
+          y = pin->Y;
+          gui->set_crosshair (x, y, 0);
+          ghid_lead_user_to_location (x, y);
+          break;
+        }
+      case PAD_TYPE:
+        {
+          PadTypePtr pad = (PadTypePtr) conn.ptr2;
+          x = pad->Point1.X + (pad->Point2.X - pad->Point1.X) / 2;
+          y = pad->Point1.Y + (pad->Point2.Y - pad->Point2.Y) / 2;
+          gui->set_crosshair (x, y, 0);
+          ghid_lead_user_to_location (x, y);
+          break;
+        }
+    }
 }
 
 
@@ -626,8 +637,10 @@ node_get_node_from_name (gchar * node_name, LibraryMenuType ** node_net)
   if (!netlist_window)
     ghid_netlist_window_create (gport);
 
+#if 0 /* This is a REALLY bad idea */
   while (gtk_events_pending ())	/* Make sure everything gets built */
     gtk_main_iteration ();
+#endif
 
   /* Now walk through node entries of each net in the net model looking for
      |  the node_name.
@@ -662,6 +675,9 @@ netlist_close_cb (GtkWidget * widget, gpointer data)
   gtk_widget_destroy (netlist_window);
   selected_net = NULL;
   netlist_window = NULL;
+
+  /* For now, we are the only consumer of this API, so we can just do this */
+  ghid_cancel_lead_user ();
 }
 
 
@@ -888,8 +904,10 @@ ghid_get_net_from_node_name (gchar * node_name, gboolean enabled_only)
   if (!netlist_window)
     ghid_netlist_window_create (gport);
 
+#if 0 /* This is a REALLY bad idea */
   while (gtk_events_pending ())	/* Make sure everything gets built */
     gtk_main_iteration ();
+#endif
 
   /* If no netlist is loaded the window doesn't appear. */
   if (netlist_window == NULL)
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index 930df19..cd86aed 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -505,6 +505,9 @@ void ghid_flush_debug_draw (void);
 void ghid_finish_debug_draw (void);
 bool ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y);
 
+void ghid_lead_user_to_location (Coord x, Coord y);
+void ghid_cancel_lead_user (void);
+
 /* gtkhid-main.c */
 void ghid_pan_fixup (void);
 void ghid_get_coords (const char *msg, int *x, int *y);
diff --git a/src/select.c b/src/select.c
index e42d4bb..1aa5cb6 100644
--- a/src/select.c
+++ b/src/select.c
@@ -85,10 +85,7 @@ SelectPin (LibraryEntryTypePtr entry, bool toggle)
 	    AddObjectToFlagUndoList (PIN_TYPE, conn.ptr1, conn.ptr2,
 				     conn.ptr2);
 	    if (toggle)
-	      {
-		TOGGLE_FLAG (SELECTEDFLAG, pin);
-		CenterDisplay (pin->X, pin->Y, false);
-	      }
+	      TOGGLE_FLAG (SELECTEDFLAG, pin);
 	    else
 	      SET_FLAG (SELECTEDFLAG, pin);
 	    DrawPin (pin);
@@ -101,10 +98,7 @@ SelectPin (LibraryEntryTypePtr entry, bool toggle)
 	    AddObjectToFlagUndoList (PAD_TYPE, conn.ptr1, conn.ptr2,
 				     conn.ptr2);
 	    if (toggle)
-	      {
-		TOGGLE_FLAG (SELECTEDFLAG, pad);
-		CenterDisplay (pad->Point1.X, pad->Point1.Y, false);
-	      }
+	      TOGGLE_FLAG (SELECTEDFLAG, pad);
 	    else
 	      SET_FLAG (SELECTEDFLAG, pad);
 	    DrawPad (pad);

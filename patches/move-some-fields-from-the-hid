Bottom: 5e84ba4ae234e08810f6e04608af4b87d3b2993b
Top:    951915eb7454627df6bfcbc1cfc048e5775a96ad
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2015-01-11 17:26:15 +0000

Move some fields from the HID* structure to HID_DRAW* and HID_DRAW_CLASS*

The parameters gui, poly_before, poly_after only effect rendering, so
belong in either the HID_DRAW_CLASS or HID_DRAW instance structure.

The set_layer() and end_layer() APIs also belong in the HID_DRAW_CLASS

We leave a copy of the "gui" flag in the HID structure, as main.c uses
this to count up each type of exporter.


---

diff --git a/src/draw.c b/src/draw.c
index 3083038..5eaa3fc 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -176,10 +176,10 @@ _draw_pv_name (PinType *pv)
   text.Y = box.Y1;
   text.Direction = vert ? 1 : 0;
 
-  if (gui->gui)
+  if (gui->graphics->klass->gui)
     doing_pinout++;
   hid_draw_pcb_text (Output.fgGC, &text, 0);
-  if (gui->gui)
+  if (gui->graphics->klass->gui)
     doing_pinout--;
 }
 
@@ -320,7 +320,7 @@ pad_callback (const BoxType * b, void *cl)
 static void
 draw_element_name (ElementType *element)
 {
-  if ((TEST_FLAG (HIDENAMESFLAG, PCB) && gui->gui) ||
+  if ((TEST_FLAG (HIDENAMESFLAG, PCB) && gui->graphics->klass->gui) ||
       TEST_FLAG (HIDENAMEFLAG, element))
     return;
   if (doing_pinout || doing_assy)
@@ -566,7 +566,7 @@ DrawEverything (const BoxType *drawn_area)
    * first draw all 'invisible' stuff
    */
   if (!TEST_FLAG (CHECKPLANESFLAG, PCB)
-      && gui->set_layer ("invisible", SL (INVISIBLE, 0), 0))
+      && gui->graphics->set_layer ("invisible", SL (INVISIBLE, 0), 0))
     {
       side = SWAP_IDENT ? TOP_SIDE : BOTTOM_SIDE;
       if (PCB->ElementOn)
@@ -576,7 +576,7 @@ DrawEverything (const BoxType *drawn_area)
 	  DrawLayer (&(PCB->Data->Layer[max_copper_layer + side]), drawn_area);
 	}
       r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, &side);
-      gui->end_layer ();
+      gui->graphics->end_layer ();
     }
 
   /* draw all layers in layerstack order */
@@ -584,105 +584,105 @@ DrawEverything (const BoxType *drawn_area)
     {
       int group = drawn_groups[i];
 
-      if (gui->set_layer (0, group, 0))
+      if (gui->graphics->set_layer (0, group, 0))
         {
           DrawLayerGroup (group, drawn_area);
-          gui->end_layer ();
+          gui->graphics->end_layer ();
         }
     }
 
-  if (TEST_FLAG (CHECKPLANESFLAG, PCB) && gui->gui)
+  if (TEST_FLAG (CHECKPLANESFLAG, PCB) && gui->graphics->klass->gui)
     return;
 
   /* Draw pins, pads, vias below silk */
-  if (gui->gui)
+  if (gui->graphics->klass->gui)
     DrawPPV (SWAP_IDENT ? bottom_group : top_group, drawn_area);
   else
     {
       CountHoles (&plated, &unplated, drawn_area);
 
-      if (plated && gui->set_layer ("plated-drill", SL (PDRILL, 0), 0))
+      if (plated && gui->graphics->set_layer ("plated-drill", SL (PDRILL, 0), 0))
         {
           DrawHoles (true, false, drawn_area);
-          gui->end_layer ();
+          gui->graphics->end_layer ();
         }
 
-      if (unplated && gui->set_layer ("unplated-drill", SL (UDRILL, 0), 0))
+      if (unplated && gui->graphics->set_layer ("unplated-drill", SL (UDRILL, 0), 0))
         {
           DrawHoles (false, true, drawn_area);
-          gui->end_layer ();
+          gui->graphics->end_layer ();
         }
     }
 
   /* Draw the solder mask if turned on */
-  if (gui->set_layer ("componentmask", SL (MASK, TOP), 0))
+  if (gui->graphics->set_layer ("componentmask", SL (MASK, TOP), 0))
     {
       DrawMask (TOP_SIDE, drawn_area);
-      gui->end_layer ();
+      gui->graphics->end_layer ();
     }
 
-  if (gui->set_layer ("soldermask", SL (MASK, BOTTOM), 0))
+  if (gui->graphics->set_layer ("soldermask", SL (MASK, BOTTOM), 0))
     {
       DrawMask (BOTTOM_SIDE, drawn_area);
-      gui->end_layer ();
+      gui->graphics->end_layer ();
     }
 
-  if (gui->set_layer ("topsilk", SL (SILK, TOP), 0))
+  if (gui->graphics->set_layer ("topsilk", SL (SILK, TOP), 0))
     {
       DrawSilk (TOP_SIDE, drawn_area);
-      gui->end_layer ();
+      gui->graphics->end_layer ();
     }
 
-  if (gui->set_layer ("bottomsilk", SL (SILK, BOTTOM), 0))
+  if (gui->graphics->set_layer ("bottomsilk", SL (SILK, BOTTOM), 0))
     {
       DrawSilk (BOTTOM_SIDE, drawn_area);
-      gui->end_layer ();
+      gui->graphics->end_layer ();
     }
 
-  if (gui->gui)
+  if (gui->graphics->klass->gui)
     {
       /* Draw element Marks */
       if (PCB->PinOn)
 	r_search (PCB->Data->element_tree, drawn_area, NULL, EMark_callback,
 		  NULL);
       /* Draw rat lines on top */
-      if (gui->set_layer ("rats", SL (RATS, 0), 0))
+      if (gui->graphics->set_layer ("rats", SL (RATS, 0), 0))
         {
           DrawRats(drawn_area);
-          gui->end_layer ();
+          gui->graphics->end_layer ();
         }
     }
 
   paste_empty = IsPasteEmpty (TOP_SIDE);
-  if (gui->set_layer ("toppaste", SL (PASTE, TOP), paste_empty))
+  if (gui->graphics->set_layer ("toppaste", SL (PASTE, TOP), paste_empty))
     {
       DrawPaste (TOP_SIDE, drawn_area);
-      gui->end_layer ();
+      gui->graphics->end_layer ();
     }
 
   paste_empty = IsPasteEmpty (BOTTOM_SIDE);
-  if (gui->set_layer ("bottompaste", SL (PASTE, BOTTOM), paste_empty))
+  if (gui->graphics->set_layer ("bottompaste", SL (PASTE, BOTTOM), paste_empty))
     {
       DrawPaste (BOTTOM_SIDE, drawn_area);
-      gui->end_layer ();
+      gui->graphics->end_layer ();
     }
 
-  if (gui->set_layer ("topassembly", SL (ASSY, TOP), 0))
+  if (gui->graphics->set_layer ("topassembly", SL (ASSY, TOP), 0))
     {
       PrintAssembly (TOP_SIDE, drawn_area);
-      gui->end_layer ();
+      gui->graphics->end_layer ();
     }
 
-  if (gui->set_layer ("bottomassembly", SL (ASSY, BOTTOM), 0))
+  if (gui->graphics->set_layer ("bottomassembly", SL (ASSY, BOTTOM), 0))
     {
       PrintAssembly (BOTTOM_SIDE, drawn_area);
-      gui->end_layer ();
+      gui->graphics->end_layer ();
     }
 
-  if (gui->set_layer ("fab", SL (FAB, 0), 0))
+  if (gui->graphics->set_layer ("fab", SL (FAB, 0), 0))
     {
       PrintFab (Output.fgGC);
-      gui->end_layer ();
+      gui->graphics->end_layer ();
     }
 }
 
@@ -740,7 +740,7 @@ DrawPPV (int group, const BoxType *drawn_area)
   int bottom_group = GetLayerGroupNumberBySide (BOTTOM_SIDE);
   int side;
 
-  if (PCB->PinOn || !gui->gui)
+  if (PCB->PinOn || !gui->graphics->klass->gui)
     {
       /* draw element pins */
       r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_callback, NULL);
@@ -760,7 +760,7 @@ DrawPPV (int group, const BoxType *drawn_area)
     }
 
   /* draw vias */
-  if (PCB->ViaOn || !gui->gui)
+  if (PCB->ViaOn || !gui->graphics->klass->gui)
     {
       r_search (PCB->Data->via_tree, drawn_area, NULL, via_callback, NULL);
       r_search (PCB->Data->via_tree, drawn_area, NULL, hole_callback, NULL);
@@ -822,7 +822,7 @@ DrawSilk (int side, const BoxType * drawn_area)
 #endif
 
 #if 0
-  if (gui->poly_before)
+  if (gui->graphics->poly_before)
     {
       hid_draw_use_mask (gui->graphics, HID_MASK_BEFORE);
 #endif
@@ -838,7 +838,7 @@ DrawSilk (int side, const BoxType * drawn_area)
   r_search (PCB->Data->via_tree, drawn_area, NULL, clearPin_callback, NULL);
   r_search (PCB->Data->pad_tree, drawn_area, NULL, clearPad_callback, &side);
 
-  if (gui->poly_after)
+  if (gui->graphics->poly_after)
     {
       hid_draw_use_mask (gui->graphics, HID_MASK_AFTER);
       DrawLayer (LAYER_PTR (max_copper_layer + layer), drawn_area);
@@ -855,8 +855,8 @@ static void
 DrawMaskBoardArea (int mask_type, const BoxType *drawn_area)
 {
   /* Skip the mask drawing if the GUI doesn't want this type */
-  if ((mask_type == HID_MASK_BEFORE && !gui->poly_before) ||
-      (mask_type == HID_MASK_AFTER  && !gui->poly_after))
+  if ((mask_type == HID_MASK_BEFORE && !gui->graphics->poly_before) ||
+      (mask_type == HID_MASK_AFTER  && !gui->graphics->poly_after))
     return;
 
   hid_draw_use_mask (gui->graphics, mask_type);
@@ -974,7 +974,7 @@ DrawLayer (LayerType *Layer, const BoxType *screen)
   /* draw the layer text on screen */
   r_search (Layer->text_tree, screen, NULL, text_callback, Layer);
 
-  /* We should check for gui->gui here, but it's kinda cool seeing the
+  /* We should check for gui->graphics->klass->gui here, but it's kinda cool seeing the
      auto-outline magically disappear when you first add something to
      the "outline" layer.  */
   if (IsLayerEmpty (Layer)
@@ -1013,7 +1013,7 @@ DrawLayerGroup (int group, const BoxType *drawn_area)
   if (n_entries > 1)
     rv = 1;
 
-  if (rv && !gui->gui)
+  if (rv && !gui->graphics->klass->gui)
     DrawPPV (group, drawn_area);
 }
 
diff --git a/src/hid.h b/src/hid.h
index ef6edb2..7d5bdc2 100644
--- a/src/hid.h
+++ b/src/hid.h
@@ -269,15 +269,6 @@ typedef enum
        and EPS exporters.  */
     char exporter:1;
 
-    /* If set, the redraw code will draw polygons before erasing the
-       clearances.  */
-    char poly_before:1;
-
-    /* If set, the redraw code will draw polygons after erasing the
-       clearances.  Note that HIDs may set both of these, in which case
-       polygons will be drawn twice.  */
-    char poly_after:1;
-
     /* Returns a set of resources describing options the export or print
        HID supports.  In GUI mode, the print/export dialogs use this to
        set up the selectable options.  In command line mode, these are
@@ -303,23 +294,6 @@ typedef enum
     void (*notify_crosshair_change) (bool changes_complete);
     void (*notify_mark_change) (bool changes_complete);
 
-    /* During redraw or print/export cycles, this is called once per
-       layer (or layer group, for copper layers).  If it returns false
-       (zero), the HID does not want that layer, and none of the drawing
-       functions should be called.  If it returns true (nonzero), the
-       items in that layer [group] should be drawn using the various
-       drawing functions.  In addition to the MAX_GROUP copper layer
-       groups, you may select layers indicated by the macros SL_*
-       defined above, or any others with an index of -1.  For copper
-       layer groups, you may pass NULL for name to have a name fetched
-       from the PCB struct.  The EMPTY argument is a hint - if set, the
-       layer is empty, if zero it may be non-empty.  */
-    int (*set_layer) (const char *name_, int group_, int _empty);
-
-    /* Tell the GUI the layer last selected has been finished with */
-    void (*end_layer) (void);
-
-
     HID_DRAW *graphics;
 
     /* This is for the printer.  If you call this for the GUI, xval and
diff --git a/src/hid/common/extents.c b/src/hid/common/extents.c
index cf2de59..dd53f94 100644
--- a/src/hid/common/extents.c
+++ b/src/hid/common/extents.c
@@ -181,7 +181,6 @@ hid_extents_init (void)
   extents_hid.struct_size         = sizeof (HID);
   extents_hid.name                = "extents-extents";
   extents_hid.description         = "used to calculate extents";
-  extents_hid.poly_before         = 1;
 
   extents_hid.set_layer           = extents_set_layer;
 
@@ -204,6 +203,7 @@ hid_extents_init (void)
   extents_graphics_class.fill_rect      = extents_fill_rect;
 
   extents_graphics.klass = &extents_graphics_class;
+  extents_graphics.poly_before = true;
   common_draw_helpers_init (&extents_graphics);
 
   initialised = true;
diff --git a/src/hid/gcode/gcode.c b/src/hid/gcode/gcode.c
index 654b5e0..1daadfd 100644
--- a/src/hid/gcode/gcode.c
+++ b/src/hid/gcode/gcode.c
@@ -1613,7 +1613,6 @@ hid_gcode_init ()
   gcode_hid.name                = "gcode";
   gcode_hid.description         = "G-CODE export";
   gcode_hid.exporter            = 1;
-  gcode_hid.poly_before         = 1;
 
   gcode_hid.get_export_options  = gcode_get_export_options;
   gcode_hid.do_export           = gcode_do_export;
@@ -1642,6 +1641,7 @@ hid_gcode_init ()
   gcode_graphics_class.fill_rect      = gcode_fill_rect;
 
   gcode_graphics.klass = &gcode_graphics_class;
+  gcode_graphics.poly_before = true;
   common_draw_helpers_init (&gcode_graphics);
 
   hid_register_hid (&gcode_hid);
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 56564fd..7870f6d 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -2137,7 +2137,6 @@ hid_gtk_init ()
   ghid_hid.name                     = "gtk";
   ghid_hid.description              = "Gtk - The Gimp Toolkit";
   ghid_hid.gui                      = 1;
-  ghid_hid.poly_after               = 1;
 
   ghid_hid.get_export_options       = ghid_get_export_options;
   ghid_hid.do_export                = ghid_do_export;
@@ -2202,7 +2201,10 @@ hid_gtk_init ()
 
   ghid_graphics_class.draw_pcb_polygon = common_gui_draw_pcb_polygon;
 
+  ghid_graphics_class.gui = true;
+
   ghid_graphics.klass = &ghid_graphics_class;
+  ghid_graphics.poly_after = true;
   common_draw_helpers_init (&ghid_graphics);
 
   hid_register_hid (&ghid_hid);
diff --git a/src/hid/lesstif/main.c b/src/hid/lesstif/main.c
index 00c439c..1682ead 100644
--- a/src/hid/lesstif/main.c
+++ b/src/hid/lesstif/main.c
@@ -4072,7 +4072,6 @@ hid_lesstif_init ()
   lesstif_hid.name                    = "lesstif";
   lesstif_hid.description             = "LessTif - a Motif clone for X/Unix";
   lesstif_hid.gui                     = 1;
-  lesstif_hid.poly_before             = 1;
 
   lesstif_hid.get_export_options      = lesstif_get_export_options;
   lesstif_hid.do_export               = lesstif_do_export;
@@ -4134,6 +4133,7 @@ hid_lesstif_init ()
   lesstif_graphics.draw_pcb_polygon    = common_gui_draw_pcb_polygon;
 
   lesstif_graphics.klass = &lesstif_graphics_class;
+  lesstif_graphics.poly_before = true;
   common_draw_helpers_init (&lesstif_graphics);
 
   hid_register_hid (&lesstif_hid);
diff --git a/src/hid/lpr/lpr.c b/src/hid/lpr/lpr.c
index 05d5863..da9e20f 100644
--- a/src/hid/lpr/lpr.c
+++ b/src/hid/lpr/lpr.c
@@ -136,7 +136,6 @@ hid_lpr_init ()
   lpr_hid.name                = "lpr";
   lpr_hid.description         = N_("Postscript print");
   lpr_hid.printer             = 1;
-  lpr_hid.poly_before         = 1;
 
   lpr_hid.get_export_options  = lpr_get_export_options;
   lpr_hid.do_export           = lpr_do_export;
diff --git a/src/hid/nelma/nelma.c b/src/hid/nelma/nelma.c
index cb28849..481d7c2 100644
--- a/src/hid/nelma/nelma.c
+++ b/src/hid/nelma/nelma.c
@@ -1070,7 +1070,6 @@ hid_nelma_init()
   nelma_hid.name                = "nelma";
   nelma_hid.description         = "Numerical analysis package export";
   nelma_hid.exporter            = 1;
-  nelma_hid.poly_before         = 1;
 
   nelma_hid.get_export_options  = nelma_get_export_options;
   nelma_hid.do_export           = nelma_do_export;
@@ -1099,6 +1098,7 @@ hid_nelma_init()
   nelma_graphics_class.fill_rect      = nelma_fill_rect;
 
   nelma_graphics.klass = &nelma_graphics_class;
+  nelma_graphics.poly_before = true;
   common_draw_helpers_init (&nelma_graphics);
 
   hid_register_hid (&nelma_hid);
diff --git a/src/hid/png/png.c b/src/hid/png/png.c
index 0c189d3..8e649c8 100644
--- a/src/hid/png/png.c
+++ b/src/hid/png/png.c
@@ -1845,7 +1845,6 @@ hid_png_init ()
   png_hid.name        = "png";
   png_hid.description = "GIF/JPEG/PNG export";
   png_hid.exporter    = 1;
-  png_hid.poly_before = 1;
 
   png_hid.get_export_options  = png_get_export_options;
   png_hid.do_export           = png_do_export;
@@ -1873,6 +1872,7 @@ hid_png_init ()
   png_graphics_class.fill_rect      = png_fill_rect;
 
   png_graphics.klass = &png_graphics_class;
+  png_graphics.poly_before = true;
   common_draw_helpers_init (&png_graphics);
 
 #ifdef HAVE_SOME_FORMAT
diff --git a/src/hid/ps/eps.c b/src/hid/ps/eps.c
index 5890e4c..2420092 100644
--- a/src/hid/ps/eps.c
+++ b/src/hid/ps/eps.c
@@ -240,11 +240,11 @@ eps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
       print_layer[i] = 1;
 
   if (fast_erase) {
-    eps_hid.poly_before = 1;
-    eps_hid.poly_after = 0;
+    eps_graphics.poly_before = true;
+    eps_graphics.poly_after = false;
   } else {
-    eps_hid.poly_before = 0;
-    eps_hid.poly_after = 1;
+    eps_graphics.poly_before = false;
+    eps_graphics.poly_after = true;
   }
 
   memcpy (saved_layer_stack, LayerStack, sizeof (LayerStack));
@@ -686,7 +686,6 @@ hid_eps_init ()
   eps_hid.name                = "eps";
   eps_hid.description         = "Encapsulated Postscript";
   eps_hid.exporter            = 1;
-  eps_hid.poly_after          = 1;
 
   eps_hid.get_export_options  = eps_get_export_options;
   eps_hid.do_export           = eps_do_export;
@@ -714,6 +713,7 @@ hid_eps_init ()
   eps_graphics_class.fill_rect      = eps_fill_rect;
 
   eps_graphics.klass = &eps_graphics_class;
+  eps_graphics.poly_after = true;
   common_draw_helpers_init (&eps_graphics);
 
   hid_register_hid (&eps_hid);
diff --git a/src/hid/ps/ps.c b/src/hid/ps/ps.c
index a52bf76..5ceb757 100644
--- a/src/hid/ps/ps.c
+++ b/src/hid/ps/ps.c
@@ -1570,7 +1570,6 @@ hid_ps_init ()
   ps_hid.name               = "ps";
   ps_hid.description        = N_("Postscript export");
   ps_hid.exporter           = 1;
-  ps_hid.poly_before        = 1;
 
   ps_hid.graphics           = &ps_graphics;
 
@@ -1578,6 +1577,7 @@ hid_ps_init ()
   ps_ps_graphics_class_init (&ps_graphics_class);
 
   ps_graphics.klass = &ps_graphics_class;
+  ps_graphics.poly_before = true;
   common_draw_helpers_init (&ps_graphics);
   ps_ps_graphics_init (&ps_graphics);
 
diff --git a/src/hid_draw.h b/src/hid_draw.h
index ea288c7..30de626 100644
--- a/src/hid_draw.h
+++ b/src/hid_draw.h
@@ -9,6 +9,22 @@ enum mask_mode {
 
 typedef struct hid_draw_class_st
 {
+  /* During redraw or print/export cycles, this is called once per
+     layer (or layer group, for copper layers).  If it returns false
+     (zero), the HID does not want that layer, and none of the drawing
+     functions should be called.  If it returns true (nonzero), the
+     items in that layer [group] should be drawn using the various
+     drawing functions.  In addition to the MAX_GROUP copper layer
+     groups, you may select layers indicated by the macros SL_*
+     defined above, or any others with an index of -1.  For copper
+     layer groups, you may pass NULL for name to have a name fetched
+     from the PCB struct.  The EMPTY argument is a hint - if set, the
+     layer is empty, if zero it may be non-empty.  */
+  int (*set_layer) (const char *name_, int group_, int _empty);
+
+  /* Tell the GUI the layer last selected has been finished with */
+  void (*end_layer) (void);
+
   /* Drawing Functions.  Coordinates and distances are ALWAYS in PCB's
      default coordinates (1 nm at the time this comment was written).
      Angles are always in degrees, with 0 being "right" (positive X)
@@ -63,12 +79,19 @@ typedef struct hid_draw_class_st
   void (*fill_pcb_pv) (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool mask);
   void (*thindraw_pcb_pv) (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool mask);
 
+  /* draw.c currently uses this to shortcut and special-case certain rendering when displaying on-screen */
+  bool gui;
+
 } HID_DRAW_CLASS;
 
 /* Base HID_DRAW elements visible to any module */
 struct hid_draw_st
 {
   HID_DRAW_CLASS *klass;
+
+  /* Note that both of these may be set, in which case polygons will be drawn twice: */
+  bool poly_before; /* If set, the redraw code will draw polygons before erasing the clearances. */
+  bool poly_after;  /* If set, the redraw code will draw polygons after  erasing the clearances. */
 };
 
 /* Base hidGC elements visible to any module */
@@ -80,6 +103,18 @@ struct hid_gc_struct {
 /* Calling wrappers to access the vfunc table */
 
 inline hidGC
+hid_draw_set_layer (HID_DRAW *hid_draw, const char *name, int group, int empty)
+{
+  hid_draw->klass->set_layer (name, group, empty);
+}
+
+inline hidGC
+hid_draw_end_layer (HID_DRAW *hid_draw)
+{
+  hid_draw->klass->end_layer ();
+}
+
+inline hidGC
 hid_draw_make_gc (HID_DRAW *hid_draw)
 {
   return hid_draw->klass->make_gc ();

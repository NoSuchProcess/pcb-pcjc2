Bottom: 25602210845d22db8ec754ae51e2f348e5966894
Top:    70c8f90031718e67b481158f9e035ff326ba2b22
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-10-22 04:53:59 +0100

Add configure checks for GtkGLEext, add to CFLAGS and LIBS

*** TODO: Need separate tests for libgl and libglut etc.. ***















---

diff --git a/configure.ac b/configure.ac
index 0efe7da..31eec7d 100644
--- a/configure.ac
+++ b/configure.ac
@@ -342,6 +342,45 @@ $DBUS_PKG_ERRORS])]
 
 fi
 
+
+AC_MSG_CHECKING([for whether to use GL drawing])
+AC_ARG_ENABLE([gl],
+[  --enable-gl           Enable GL drawing (with GTK HID)],
+[],[enable_gl=no])
+
+AC_MSG_RESULT([$enable_gl])
+AM_CONDITIONAL(USE_GL, test x$enable_gl = xyes)
+
+if test "x$enable_gl" = "xyes"; then
+	case " $with_gui " in
+		*\ gtk\ *) ;;
+		* ) AC_MSG_ERROR([GL drawing enabled but only works with the GTK HID.
+Either do not use --enable-gl or enable the gtk HID.])
+	;;
+	esac
+
+# FIXME... what do we need to check for determining we have GL? Is it headers, API ?
+
+	AC_CHECK_HEADERS(GL/gl.h)
+	case $ac_cv_header_GL_gl_h in
+	  no )
+	    AC_MSG_ERROR([You don't seem to have the GL library headers installed.])
+	    ;;
+	  * ) ;;
+	esac
+
+	AC_CHECK_HEADERS(GL/glu.h)
+	case $ac_cv_header_GL_glu_h in
+	  no )
+	    AC_MSG_ERROR([You don't seem to have the GL glu library headers installed.])
+	    ;;
+	  * ) ;;
+	esac
+
+	AC_DEFINE([ENABLE_GL], 1,
+		[Define to 1 if GL support is to be compiled in])
+fi
+
 AC_MSG_CHECKING([for which printer to use])
 AC_ARG_WITH([printer],
 [  --with-printer= 	  Specify the printer: lpr [[default=lpr]]],
@@ -680,6 +719,17 @@ $GTK_PKG_ERRORS])]
 	fi
 
 	GLIB_VERSION=`$PKG_CONFIG glib-2.0 --modversion`
+
+	if test "x$enable_gl" = "xyes"; then
+		# Check for GtkGLExt
+		PKG_CHECK_MODULES(GTKGLEXT, gtkglext-1.0 >= 1.0.0, , [AC_MSG_ERROR([
+*** Required version of gtkglext is not installed - please install first ***
+Please review the following errors:
+$GTKGLEXT_PKG_ERRORS])]
+		)
+	GTKGLEXT_VER=`$PKG_CONFIG gtkglext-1.0 --modversion`
+	fi
+
 	;;
 
       nelma|png )
@@ -927,8 +977,8 @@ AM_CONDITIONAL(DEBUG_BUILD, test x$enable_debug = xyes)
 
 # ------------- Complete set of CFLAGS and LIBS -------------------
 
-CFLAGS="$CFLAGS $X_CFLAGS $DBUS_CFLAGS $GLIB_CFLAGS $GTK_CFLAGS $CAIRO_CFLAGS"
-LIBS="$LIBS $XM_LIBS $DBUS_LIBS $X_LIBS $GLIB_LIBS $GTK_LIBS $DMALLOC_LIBS $GD_LIBS $INTLLIBS $CAIRO_LIBS"
+CFLAGS="$CFLAGS $X_CFLAGS $DBUS_CFLAGS $GLIB_CFLAGS $GTK_CFLAGS $CAIRO_CFLAGS $GTKGLEXT_CFLAGS"
+LIBS="$LIBS $XM_LIBS $DBUS_LIBS $X_LIBS $GLIB_LIBS $GTK_LIBS $DMALLOC_LIBS $GD_LIBS $INTLLIBS $CAIRO_LIBS $GTKGLEXT_LIBS"
 
 
 # if we have gcc then add -Wall
diff --git a/src/polygon1.c b/src/polygon1.c
index 1c6096b..4bc33b2 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -2080,6 +2080,117 @@ M_POLYAREA_update_primary (jmp_buf * e, POLYAREA ** pieces,
   } while ((a = anext), *pieces != NULL && !finished);
 }
 
+#if 0
+static void
+M_POLYAREA_update_primary_old (jmp_buf * e, POLYAREA ** pieces,
+                           PLINE ** holes, PLINE ** isected, int action)
+{
+  POLYAREA *a = *pieces;
+  POLYAREA *anext;
+  PLINE *curc, *next, *prev;
+  int inv_inside = 0;
+  int del_inside = 0;
+  int del_outside = 0;
+  int finished;
+
+  if (a == NULL)
+    return;
+
+  switch (action) {
+    case PBO_ISECT:
+      del_outside = 1;
+      break;
+    case PBO_UNITE:
+      del_inside = 1;
+      break;
+    case PBO_SUB:
+      del_inside = 1;
+      break;
+    case PBO_XOR: /* NOT IMPLEMENTED OR USED */
+      inv_inside = 1;
+      break;
+  }
+
+  /* now the non-intersect parts are collected in temp/holes */
+  do {
+    int hole_contour = 0;
+    int is_outline = 1;
+
+    anext = a->f;
+    finished = (anext == *pieces);
+
+    prev = NULL;
+    for (curc = a->contours; curc != NULL; curc = next, is_outline = 0) {
+      int is_first = contour_is_first (a, curc);
+      int is_last = contour_is_last (curc);
+
+      int del_contour = 0;
+      int inv_contour = 0;
+      int isect_contour = 0;
+
+      next = curc->next;
+
+      switch (curc->Flags.status) {
+        case ISECTED:
+          isect_contour = 1;
+          break;
+        case INSIDE:
+          if (del_inside) del_contour = 1;
+          if (inv_inside) inv_contour = 1;
+          break;
+        case OUTSIDE:
+          if (del_outside) del_contour = 1;
+          break;
+      }
+
+      /* Reset the intersection flags, since we keep these pieces */
+      if (curc->Flags.status != ISECTED)
+        curc->Flags.status = UNKNWN;
+
+      if (del_contour || isect_contour || hole_contour) {
+
+        remove_contour (a, prev, curc, !(is_first && is_last));
+
+        if (del_contour) {
+          /* Delete the contour */
+          poly_DelContour (&curc); /* NB: Sets curc to NULL */
+        } else if (isect_contour) {
+          /* Link into the list of intersected contours */
+          curc->next = *isected;
+          *isected = curc;
+        } else if (hole_contour) {
+          /* Link into the list of holes */
+          curc->next = *holes;
+          *holes = curc;
+        } else {
+          assert (0);
+        }
+
+        if (is_first && is_last) {
+          remove_polyarea (pieces, a);
+          poly_Free (&a); /* NB: Sets a to NULL */
+        }
+
+      } else {
+        /* Note the item we just didn't delete as the next
+           candidate for having its "next" pointer adjusted.
+           Saves walking the contour list when we delete one. */
+        prev = curc;
+      }
+
+      /* If we move or delete an outer contour, we need to move any holes
+         we wish to keep within that contour to the holes list. */
+      if (is_outline && (del_contour || isect_contour))
+        hole_contour = 1;
+
+    }
+
+    /* If we deleted all the pieces of the polyarea, *pieces is NULL */
+  } while ((a = anext), *pieces != NULL && !finished);
+}
+#endif
+
+
 static void
 M_POLYAREA_Collect_separated (jmp_buf * e, PLINE * afst, POLYAREA ** contours,
                               PLINE ** holes, int action, BOOLp maybe)
@@ -2233,15 +2344,60 @@ poly_Boolean_free (POLYAREA * ai, POLYAREA * bi, POLYAREA ** res, int action)
       assert (poly_Valid (b));
 #endif
 
+#if 0
+/* SANITY CHECK */
+  {
+    POLYAREA *apa;
+    PLINE *curc;
+
+    apa = a;
+    do {
+      for (curc = apa->contours; curc != NULL; curc = curc->next) {
+        if (curc->Flags.status != UNKNWN) {
+          curc->Flags.status = UNKNWN;
+          printf ("SOMETHING DIDN'T CLEAR THE FLAGS\n");
+        }
+      }
+      /* If we deleted all the pieces of the polyarea, *pieces is NULL */
+    } while ((apa = apa->f) != a);
+  }
+  {
+    POLYAREA *apa = a;
+    PLINE *curc;
+    do {
+      int count = 0;
+      for (curc = apa->contours; curc != NULL; curc = curc->next)
+        count ++;
+      if (apa->contour_tree->size != count)
+        printf ("A: Contour rtree has %i elements, counted %i\n",
+                apa->contour_tree->size, count);
+    } while ((apa = apa->f) != a);
+  }
+  {
+    POLYAREA *bpa = b;
+    PLINE *curc;
+    do {
+      int count = 0;
+      for (curc = bpa->contours; curc != NULL; curc = curc->next)
+        count ++;
+      if (bpa->contour_tree->size != count)
+        printf ("B: Contour rtree has %i elements, counted %i\n",
+                bpa->contour_tree->size, count);
+    } while ((bpa = bpa->f) != b);
+  }
+/* END SANITY CHECK */
+#endif
+
       /* intersect needs to make a list of the contours in a and b which are intersected */
       M_POLYAREA_intersect (&e, a, b, TRUE);
 
       /* We could speed things up a lot here if we only processed the relevant contours */
-      /* NB: Relevant parts of a are labeled below */
+//      M_POLYAREA_label (a, b, FALSE);
       M_POLYAREA_label (b, a, FALSE);
 
       *res = a;
       M_POLYAREA_update_primary (&e, res, &holes, action, b);
+//      M_POLYAREA_update_primary_old (&e, res, &holes, &a_isected, action);
       M_POLYAREA_separate_isected (&e, res, &holes, &a_isected);
       M_POLYAREA_label_separated (a_isected, b, FALSE);
       M_POLYAREA_Collect_separated (&e, a_isected, res, &holes, action, FALSE);

Bottom: adf4fe9f8d72f3a70ed51226fe4981dcd26b2ddf
Top:    30a107b94ea55c46d75d409c745ff85f851c156e
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-10-22 03:01:52 +0100

Use heap structure to insert holes quicker in InsertHoles()


---

diff --git a/src/polygon1.c b/src/polygon1.c
index 06fe903..284a1e1 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -1191,21 +1191,14 @@ remove_contour (POLYAREA *piece, PLINE *prev_contour, PLINE *contour,
     r_delete_entry (piece->contour_tree, (BoxType *)contour);
 }
 
-struct polyarea_info
-{
-  BoxType BoundingBox;
-  POLYAREA *pa;
-};
-
 static int
 heap_it (const BoxType * b, void *cl)
 {
   heap_t *heap = (heap_t *) cl;
-  struct polyarea_info *pa_info = (struct polyarea_info *)b;
-  PLINE *p = pa_info->pa->contours;
+  PLINE *p = (PLINE *) b;
   if (p->Count == 0)
     return 0;  /* how did this happen? */
-  heap_insert (heap, p->area, pa_info);
+  heap_insert (heap, p->area, (void *) p);
   return 1;
 }
 
@@ -1236,44 +1229,23 @@ static void
 InsertHoles (jmp_buf * e, POLYAREA * dest, PLINE ** src)
 {
   POLYAREA *curc;
-  PLINE *curh, *container;
+  PLINE *curh, *container, *tmp;
   heap_t *heap;
   rtree_t *tree;
-  int i;
-  int num_polyareas = 0;
-  struct polyarea_info *all_pa_info, *pa_info;
 
   if (*src == NULL)
     return;			/* empty hole list */
   if (dest == NULL)
     error (err_bad_parm);	/* empty contour list */
 
-  /* Count dest polyareas */
-  curc = dest;
-  do
-    {
-      num_polyareas ++;
-    }
-  while ((curc = curc->f) != dest);
-
-  /* make a polyarea info table */
-  /* make an rtree of polyarea info table */
-  all_pa_info = malloc (sizeof (struct polyarea_info) * num_polyareas);
+  /* make an rtree of outer contours */
   tree = r_create_tree (NULL, 0, 0);
-  i = 0;
   curc = dest;
   do
     {
-      all_pa_info[i].BoundingBox.X1 = curc->contours->xmin;
-      all_pa_info[i].BoundingBox.Y1 = curc->contours->ymin;
-      all_pa_info[i].BoundingBox.X2 = curc->contours->xmax;
-      all_pa_info[i].BoundingBox.Y2 = curc->contours->ymax;
-      all_pa_info[i].pa = curc;
-      r_insert_entry (tree, (const BoxType *) &all_pa_info[i], 0);
-      i++;
+      r_insert_entry (tree, (const BoxType *) curc->contours, 0);
     }
   while ((curc = curc->f) != dest);
-
   /* loop through the holes and put them where they belong */
   while ((curh = *src) != NULL)
     {
@@ -1297,25 +1269,24 @@ InsertHoles (jmp_buf * e, POLYAREA * dest, PLINE ** src)
        * in the heap, assume it is the container without the expense of
        * proving it.
        */
-      pa_info = heap_remove_smallest (heap);
+      tmp = (PLINE *) heap_remove_smallest (heap);
       if (heap_is_empty (heap))
 	{			/* only one possibility it must be the right one */
-          if (!poly_ContourInContour (pa_info->pa->contours, curh))
-            assert (0);
-	  container = pa_info->pa->contours;
+	  assert (poly_ContourInContour (tmp, curh));
+	  container = tmp;
 	}
       else
 	{
 	  do
 	    {
-	      if (poly_ContourInContour (pa_info->pa->contours, curh))
+	      if (poly_ContourInContour (tmp, curh))
 		{
-		  container = pa_info->pa->contours;
+		  container = tmp;
 		  break;
 		}
 	      if (heap_is_empty (heap))
 		break;
-	      pa_info = heap_remove_smallest (heap);
+	      tmp = (PLINE *) heap_remove_smallest (heap);
 	    }
 	  while (1);
 	}
@@ -1334,6 +1305,16 @@ InsertHoles (jmp_buf * e, POLYAREA * dest, PLINE ** src)
 	}
       else
 	{
+          /* Search for which POLYAREA the containing contour belongs to */
+          /* FIXME: Perhaps store this information in the heap structure? */
+          curc = dest;
+          do
+            {
+              if (curc->contours == container)
+                break;
+            }
+          while ((curc = curc->f) != dest);
+
           /* Need to check if this new hole means we need to kick out any old ones for reprocessing */
           while (1) {
             struct find_inside_info info;
@@ -1348,7 +1329,7 @@ InsertHoles (jmp_buf * e, POLYAREA * dest, PLINE ** src)
               info.result = NULL;
               /* Rtree search, calling back a routine to longjmp back with data about any hole inside the added one */
               /*   Be sure not to bother jumping back to report the main contour! */
-              r_search (pa_info->pa->contour_tree, (BoxType *)curh, NULL, find_inside, &info);
+              r_search (curc->contour_tree, (BoxType *)curh, NULL, find_inside, &info);
 
               /* Nothing found? */
               break;
@@ -1361,7 +1342,7 @@ InsertHoles (jmp_buf * e, POLYAREA * dest, PLINE ** src)
             }
 
             /* Remove hole from the contour */
-            remove_contour (pa_info->pa, prev, info.result, TRUE);
+            remove_contour (curc, prev, info.result, TRUE);
 
             /* Add hole as the next on the list to be processed in this very function */
             info.result->next = *src;
@@ -1372,12 +1353,10 @@ InsertHoles (jmp_buf * e, POLYAREA * dest, PLINE ** src)
 	  /* link at front of hole list */
 	  curh->next = container->next;
 	  container->next = curh;
-	  r_insert_entry (pa_info->pa->contour_tree, (BoxTypePtr) curh, 0);
-
+	  r_insert_entry (curc->contour_tree, (BoxTypePtr) curh, 0);
 	}
     }
   r_destroy_tree (&tree);
-  free (all_pa_info);
 }				/* InsertHoles */

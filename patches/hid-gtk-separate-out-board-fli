Bottom: 161dc446dcd0fb438e6c94cbf05a757fa995534d
Top:    2c005eb6ab2f3e3523ba495590a3c94c46657852
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-07-24 19:43:51 +0100

hid/gtk: Separate out board flipping operations into render specific code

As the different renderers may do different things with the board view,
it is not possible to save the flip state in the PCB settings any more.


---

diff --git a/src/gpcb-menu.res b/src/gpcb-menu.res
index e9469e9..15eceb9 100644
--- a/src/gpcb-menu.res
+++ b/src/gpcb-menu.res
@@ -168,8 +168,8 @@ MainMenu =
     {"Zoom to 10mil/px" Zoom(=1000)}
     {"Zoom In 20% and center" Zoom(-1.2) Center() m=Z }
     {"Zoom Out 20% and center" Zoom(+1.2) Center() m=O }
-    {"Flip up/down" checked=flip_y SwapSides(V) a={"Tab" "<Key>Tab"}}
-    {"Flip left/right" checked=flip_x SwapSides(H) a={"Shift-Tab" "Shift<Key>Tab"}}
+    {"Flip up/down" SwapSides(V) a={"Tab" "<Key>Tab"}}
+    {"Flip left/right" SwapSides(H) a={"Shift-Tab" "Shift<Key>Tab"}}
     {"Spin 180 degrees" SwapSides(R) a={"Ctrl-Tab" "Ctrl<Key>Tab"}}
     {"Swap Sides" SwapSides() a={"Ctrl-Shift-Tab" "Ctrl Shift<Key>Tab"}}
     {"Center cursor" Center() a={"C" "<Key>c"}}
diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index 5118612..fb7d0e1 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -26,9 +26,17 @@ extern HID ghid_hid;
 */
 #define USE_GC(gc) if (!use_gc(gc)) return
 
+#define SIDE_X(x)   ((priv->view.flip_x ? PCB->MaxWidth  - (x) : (x)))
+#define SIDE_Y(y)   ((priv->view.flip_y ? PCB->MaxHeight - (y) : (y)))
+
 static int cur_mask = -1;
 static int mask_seq = 0;
 
+typedef struct view_data {
+  bool flip_x;
+  bool flip_y;
+} view_data;
+
 typedef struct render_priv {
   GdkGC *bg_gc;
   GdkGC *offlimits_gc;
@@ -39,6 +47,7 @@ typedef struct render_priv {
   GdkRectangle clip_rect;
   int attached_invalidate_depth;
   int mark_invalidate_depth;
+  view_data view;
 
   /* Feature for leading the user to a particular location */
   guint lead_user_timeout;
@@ -64,6 +73,52 @@ typedef struct hid_gc_struct
 }
 hid_gc_struct;
 
+/* Px converts view->pcb, Vx converts pcb->view */
+static inline int
+Vx (int x)
+{
+  render_priv *priv = gport->render_priv;
+  if (priv->view.flip_x)
+    return (PCB->MaxWidth - x - gport->view_x0) / gport->zoom + 0.5;
+  else
+    return (x - gport->view_x0) / gport->zoom + 0.5;
+}
+
+static inline int
+Vy (int y)
+{
+  render_priv *priv = gport->render_priv;
+  if (priv->view.flip_y)
+    return (PCB->MaxHeight - y - gport->view_y0) / gport->zoom + 0.5;
+  else
+    return (y - gport->view_y0) / gport->zoom + 0.5;
+}
+
+static inline int
+Vz (int z)
+{
+  return z / gport->zoom + 0.5;
+}
+
+static inline int
+Px (int x)
+{
+  render_priv *priv = gport->render_priv;
+  int rv = x * gport->zoom + gport->view_x0;
+  if (priv->view.flip_x)
+    rv = PCB->MaxWidth - (x * gport->zoom + gport->view_x0);
+  return  rv;
+}
+
+static inline int
+Py (int y)
+{
+  render_priv *priv = gport->render_priv;
+  int rv = y * gport->zoom + gport->view_y0;
+  if (priv->view.flip_y)
+    rv = PCB->MaxHeight - (y * gport->zoom + gport->view_y0);
+  return  rv;
+}
 
 static void draw_lead_user (render_priv *priv);
 
@@ -557,12 +612,12 @@ ghid_draw_arc (hidGC gc, int cx, int cy,
   vrx = Vz (xradius);
   vry = Vz (yradius);
 
-  if (ghid_flip_x)
+  if (priv->view.flip_x)
     {
       start_angle = 180 - start_angle;
       delta_angle = -delta_angle;
     }
-  if (ghid_flip_y)
+  if (priv->view.flip_y)
     {
       start_angle = -start_angle;
       delta_angle = -delta_angle;
@@ -1281,9 +1336,9 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   gport->height = height;
   gport->view_width = width * gport->zoom;
   gport->view_height = height * gport->zoom;
-  gport->view_x0 = ghid_flip_x ? PCB->MaxWidth - cx : cx;
+  gport->view_x0 = priv->view.flip_x ? PCB->MaxWidth - cx : cx;
   gport->view_x0 -= gport->view_height / 2;
-  gport->view_y0 = ghid_flip_y ? PCB->MaxHeight - cy : cy;
+  gport->view_y0 = priv->view.flip_y ? PCB->MaxHeight - cy : cy;
   gport->view_y0 -= gport->view_width  / 2;
 
   /* clear background */
@@ -1334,12 +1389,132 @@ ghid_finish_debug_draw (void)
 bool
 ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y)
 {
+  render_priv *priv = gport->render_priv;
+
   *pcb_x = EVENT_TO_PCB_X (event_x);
   *pcb_y = EVENT_TO_PCB_Y (event_y);
 
   return true;
 }
 
+bool
+ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y)
+{
+  render_priv *priv = gport->render_priv;
+
+  *event_x = DRAW_X (pcb_x);
+  *event_y = DRAW_Y (pcb_y);
+
+  return true;
+}
+
+void
+ghid_pan_view_abs (Coord pcb_x, Coord pcb_y, int widget_x, int widget_y)
+{
+  render_priv *priv = gport->render_priv;
+
+  gport->view_x0 = MAX (0, SIDE_X (pcb_x) - widget_x * gport->zoom);
+  gport->view_y0 = MAX (0, SIDE_Y (pcb_y) - widget_y * gport->zoom);
+
+  /* don't pan so far to the right that we see way past the right edge of the
+   * board, or so far down that we see way past the bottom edge of the board.
+   */
+  gport->view_x0 = MIN (gport->view_x0, PCB->MaxWidth  - gport->view_width);
+  gport->view_y0 = MIN (gport->view_y0, PCB->MaxHeight - gport->view_height);
+
+  /* don't view above or to the left of the board... ever */
+  gport->view_x0 = MAX (0, gport->view_x0);
+  gport->view_y0 = MAX (0, gport->view_y0);
+
+  /* if we can see the entire board and some, then zoom to fit */
+  if (gport->view_width  > PCB->MaxWidth  &&
+      gport->view_height > PCB->MaxHeight)
+    {
+      ghid_zoom_view_fit ();
+      return;
+    }
+
+  ghidgui->adjustment_changed_holdoff = TRUE;
+  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view_x0);
+  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view_y0);
+  ghidgui->adjustment_changed_holdoff = FALSE;
+
+  ghid_port_ranges_changed();
+}
+
+
+/* gport->zoom:
+ * zoom value is PCB units per screen pixel.  Larger numbers mean zooming
+ * out - the largest value means you are looking at the whole board.
+ *
+ * gport->view_width and gport->view_height are in PCB coordinates
+ */
+
+void
+ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
+{
+  render_priv *priv = gport->render_priv;
+  double min_zoom, max_zoom;
+  double xtmp, ytmp;
+
+  /* Limit the "minimum" zoom constant (maximum zoom), at 1 pixel per PCB
+   * unit, and set the "maximum" zoom constant (minimum zoom), such that
+   * the entire board just fits inside the viewport
+   */
+  min_zoom = 1;
+  max_zoom = MAX (PCB->MaxWidth  / gport->width,
+                  PCB->MaxHeight / gport->height);
+  new_zoom = MIN (MAX (min_zoom, new_zoom), max_zoom);
+
+  if (gport->zoom == new_zoom)
+    return;
+
+  xtmp = (SIDE_X (center_x) - gport->view_x0) / (double)gport->view_width;
+  ytmp = (SIDE_Y (center_y) - gport->view_y0) / (double)gport->view_height;
+
+  gport->zoom = new_zoom;
+  pixel_slop = new_zoom;
+  ghid_port_ranges_scale (FALSE);
+
+  gport->view_x0 = MAX (0, SIDE_X (center_x) - xtmp * gport->view_width);
+  gport->view_y0 = MAX (0, SIDE_Y (center_y) - ytmp * gport->view_height);
+
+  ghidgui->adjustment_changed_holdoff = TRUE;
+  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view_x0);
+  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view_y0);
+  ghidgui->adjustment_changed_holdoff = FALSE;
+
+  ghid_port_ranges_changed ();
+  ghid_set_status_line_label ();
+}
+
+void
+ghid_zoom_view_rel (Coord center_x, Coord center_y, double factor)
+{
+  ghid_zoom_view_abs (center_x, center_y, gport->zoom * factor);
+}
+
+void
+ghid_zoom_view_fit (void)
+{
+  ghid_zoom_view_abs (0, 0, MAX (PCB->MaxWidth  / gport->width,
+                                 PCB->MaxHeight / gport->height));
+}
+
+void
+ghid_flip_view (Coord center_x, Coord center_y, bool flip_x, bool flip_y)
+{
+  render_priv *priv = gport->render_priv;
+
+  priv->view.flip_x = flip_x ? ! priv->view.flip_x : priv->view.flip_x;
+  priv->view.flip_y = flip_y ? ! priv->view.flip_y : priv->view.flip_y;
+
+  /* XXX: PAN THE BOARD SO THE CENTER LOCATION REMAINS IN THE SAME PLACE */
+
+  ghid_invalidate_all ();
+}
+
+
 #define LEAD_USER_WIDTH           0.2          /* millimeters */
 #define LEAD_USER_PERIOD          (1000 / 5)   /* 5fps (in ms) */
 #define LEAD_USER_VELOCITY        3.           /* millimeters per second */
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index a910946..b341d3f 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -38,8 +38,16 @@ static hidGC current_gc = NULL;
 */
 #define USE_GC(gc) if (!use_gc(gc)) return
 
+#define SIDE_X(x)   ((priv->view.flip_x ? PCB->MaxWidth  - (x) : (x)))
+#define SIDE_Y(y)   ((priv->view.flip_y ? PCB->MaxHeight - (y) : (y)))
+
 static int cur_mask = -1;
 
+typedef struct view_data {
+  bool flip_x;
+  bool flip_y;
+} view_data;
+
 typedef struct render_priv {
   GdkGLConfig *glconfig;
   bool trans_lines;
@@ -48,6 +56,8 @@ typedef struct render_priv {
   char *current_colorname;
   double current_alpha_mult;
 
+  view_data view;
+
   /* Feature for leading the user to a particular location */
   guint lead_user_timeout;
   GTimer *lead_user_timer;
@@ -71,9 +81,34 @@ typedef struct hid_gc_struct
 }
 hid_gc_struct;
 
-
 static void draw_lead_user (render_priv *priv);
 
+/* Px converts view->pcb, Vx converts pcb->view */
+static inline int
+Vz (int z)
+{
+  return z / gport->zoom + 0.5;
+}
+
+static inline int
+Px (int x)
+{
+  render_priv *priv = gport->render_priv;
+  int rv = x * gport->zoom + gport->view_x0;
+  if (priv->view.flip_x)
+    rv = PCB->MaxWidth - (x * gport->zoom + gport->view_x0);
+  return  rv;
+}
+
+static inline int
+Py (int y)
+{
+  render_priv *priv = gport->render_priv;
+  int rv = y * gport->zoom + gport->view_y0;
+  if (priv->view.flip_y)
+    rv = PCB->MaxHeight - (y * gport->zoom + gport->view_y0);
+  return  rv;
+}
 
 static void
 start_subcomposite (void)
@@ -743,6 +778,7 @@ draw_crosshair (gint x, gint y, gint z)
 void
 ghid_show_crosshair (gboolean paint_new_location)
 {
+  render_priv *priv = gport->render_priv;
   gint x, y, z;
   gboolean draw_markers;
   int vcw = VCW * gport->zoom;
@@ -933,13 +969,13 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glLoadIdentity ();
   glTranslatef (0.0f, 0.0f, -Z_NEAR);
 
-  glScalef ((ghid_flip_x ? -1. : 1.) / port->zoom,
-            (ghid_flip_y ? -1. : 1.) / port->zoom,
-            ((ghid_flip_x == ghid_flip_y) ? 1. : -1.) / port->zoom);
-  glTranslatef (ghid_flip_x ? port->view_x0 - PCB->MaxWidth  :
-                             -port->view_x0,
-                ghid_flip_y ? port->view_y0 - PCB->MaxHeight :
-                             -port->view_y0, 0);
+  glScalef ((priv->view.flip_x ? -1. : 1.) / port->zoom,
+            (priv->view.flip_y ? -1. : 1.) / port->zoom,
+            ((priv->view.flip_x == priv->view.flip_y) ? 1. : -1.) / port->zoom);
+  glTranslatef (priv->view.flip_x ?  port->view_x0 - PCB->MaxWidth  :
+                               -port->view_x0,
+                priv->view.flip_y ?  port->view_y0 - PCB->MaxHeight :
+                               -port->view_y0, 0);
 
   glEnable (GL_STENCIL_TEST);
   glClearColor (port->offlimits_color.red / 65535.,
@@ -1020,6 +1056,7 @@ gboolean
 ghid_pinout_preview_expose (GtkWidget *widget,
                             GdkEventExpose *ev)
 {
+  render_priv *priv = gport->render_priv;
   GdkGLContext* pGlContext = gtk_widget_get_gl_context (widget);
   GdkGLDrawable* pGlDrawable = gtk_widget_get_gl_drawable (widget);
   GhidPinoutPreview *pinout = GHID_PINOUT_PREVIEW (widget);
@@ -1092,12 +1129,12 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
   glPushMatrix ();
-  glScalef ((ghid_flip_x ? -1. : 1.) / gport->zoom,
-            (ghid_flip_y ? -1. : 1.) / gport->zoom, 1);
-  glTranslatef (ghid_flip_x ? gport->view_x0 - PCB->MaxWidth  :
-                             -gport->view_x0,
-                ghid_flip_y ? gport->view_y0 - PCB->MaxHeight :
-                             -gport->view_y0, 0);
+  glScalef ((priv->view.flip_x ? -1. : 1.) / gport->zoom,
+            (priv->view.flip_y ? -1. : 1.) / gport->zoom, 1);
+  glTranslatef (priv->view.flip_x ?  gport->view_x0 - PCB->MaxWidth  :
+                               -gport->view_x0,
+                priv->view.flip_y ?  gport->view_y0 - PCB->MaxHeight :
+                               -gport->view_y0, 0);
   hid_expose_callback (&ghid_hid, NULL, &pinout->element);
   hidgl_flush_triangles (&buffer);
   glPopMatrix ();
@@ -1126,6 +1163,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
 GdkPixmap *
 ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int depth)
 {
+  render_priv *priv = gport->render_priv;
   GdkGLConfig *glconfig;
   GdkPixmap *pixmap;
   GdkGLPixmap *glpixmap;
@@ -1164,9 +1202,9 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   gport->height = height;
   gport->view_width = width * gport->zoom;
   gport->view_height = height * gport->zoom;
-  gport->view_x0 = ghid_flip_x ? PCB->MaxWidth - cx : cx;
+  gport->view_x0 = priv->view.flip_x ? PCB->MaxWidth - cx : cx;
   gport->view_x0 -= gport->view_height / 2;
-  gport->view_y0 = ghid_flip_y ? PCB->MaxHeight - cy : cy;
+  gport->view_y0 = priv->view.flip_y ? PCB->MaxHeight - cy : cy;
   gport->view_y0 -= gport->view_width  / 2;
 
   /* make GL-context "current" */
@@ -1203,12 +1241,12 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
   glPushMatrix ();
-  glScalef ((ghid_flip_x ? -1. : 1.) / gport->zoom,
-            (ghid_flip_y ? -1. : 1.) / gport->zoom, 1);
-  glTranslatef (ghid_flip_x ? gport->view_x0 - PCB->MaxWidth  :
-                             -gport->view_x0,
-                ghid_flip_y ? gport->view_y0 - PCB->MaxHeight :
-                             -gport->view_y0, 0);
+  glScalef ((priv->view.flip_x ? -1. : 1.) / gport->zoom,
+            (priv->view.flip_y ? -1. : 1.) / gport->zoom, 1);
+  glTranslatef (priv->view.flip_x ?  gport->view_x0 - PCB->MaxWidth  :
+                               -gport->view_x0,
+                priv->view.flip_y ?  gport->view_y0 - PCB->MaxHeight :
+                               -gport->view_y0, 0);
   region.X1 = MIN(Px(0), Px(gport->width + 1));
   region.Y1 = MIN(Py(0), Py(gport->height + 1));
   region.X2 = MAX(Px(0), Px(gport->width + 1));
@@ -1243,6 +1281,7 @@ HID *
 ghid_request_debug_draw (void)
 {
   GHidPort *port = gport;
+  render_priv *priv = port->render_priv;
   GtkWidget *widget = port->drawing_area;
 
   ghid_start_drawing (port);
@@ -1263,13 +1302,13 @@ ghid_request_debug_draw (void)
   glDisable (GL_STENCIL_TEST);
 
   glPushMatrix ();
-  glScalef ((ghid_flip_x ? -1. : 1.) / port->zoom,
-            (ghid_flip_y ? -1. : 1.) / port->zoom,
-            (ghid_flip_x == ghid_flip_y) ? 1. : -1.);
-  glTranslatef (ghid_flip_x ? port->view_x0 - PCB->MaxWidth  :
-                             -port->view_x0,
-                ghid_flip_y ? port->view_y0 - PCB->MaxHeight :
-                             -port->view_y0, 0);
+  glScalef ((priv->view.flip_x ? -1. : 1.) / port->zoom,
+            (priv->view.flip_y ? -1. : 1.) / port->zoom,
+            (priv->view.flip_x == priv->view.flip_y) ? 1. : -1.);
+  glTranslatef (priv->view.flip_x ?  port->view_x0 - PCB->MaxWidth  :
+                               -port->view_x0,
+                priv->view.flip_y ?  port->view_y0 - PCB->MaxHeight :
+                               -port->view_y0, 0);
 
   return &ghid_hid;
 }
@@ -1300,12 +1339,132 @@ ghid_finish_debug_draw (void)
 bool
 ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y)
 {
+  render_priv *priv = gport->render_priv;
+
   *pcb_x = EVENT_TO_PCB_X (event_x);
   *pcb_y = EVENT_TO_PCB_Y (event_y);
 
   return true;
 }
 
+bool
+ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y)
+{
+  render_priv *priv = gport->render_priv;
+
+  *event_x = DRAW_X (pcb_x);
+  *event_y = DRAW_Y (pcb_y);
+
+  return true;
+}
+
+void
+ghid_pan_view_abs (Coord pcb_x, Coord pcb_y, int widget_x, int widget_y)
+{
+  render_priv *priv = gport->render_priv;
+
+  gport->view_x0 = MAX (0, SIDE_X (pcb_x) - widget_x * gport->zoom);
+  gport->view_y0 = MAX (0, SIDE_Y (pcb_y) - widget_y * gport->zoom);
+
+  /* don't pan so far to the right that we see way past the right edge of the
+   * board, or so far down that we see way past the bottom edge of the board.
+   */
+  gport->view_x0 = MIN (gport->view_x0, PCB->MaxWidth  - gport->view_width);
+  gport->view_y0 = MIN (gport->view_y0, PCB->MaxHeight - gport->view_height);
+
+  /* don't view above or to the left of the board... ever */
+  gport->view_x0 = MAX (0, gport->view_x0);
+  gport->view_y0 = MAX (0, gport->view_y0);
+
+  /* if we can see the entire board and some, then zoom to fit */
+  if (gport->view_width  > PCB->MaxWidth  &&
+      gport->view_height > PCB->MaxHeight)
+    {
+      ghid_zoom_view_fit ();
+      return;
+    }
+
+  ghidgui->adjustment_changed_holdoff = TRUE;
+  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view_x0);
+  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view_y0);
+  ghidgui->adjustment_changed_holdoff = FALSE;
+
+  ghid_port_ranges_changed();
+}
+
+
+/* gport->zoom:
+ * zoom value is PCB units per screen pixel.  Larger numbers mean zooming
+ * out - the largest value means you are looking at the whole board.
+ *
+ * gport->view_width and gport->view_height are in PCB coordinates
+ */
+
+void
+ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
+{
+  render_priv *priv = gport->render_priv;
+  double min_zoom, max_zoom;
+  double xtmp, ytmp;
+
+  /* Limit the "minimum" zoom constant (maximum zoom), at 1 pixel per PCB
+   * unit, and set the "maximum" zoom constant (minimum zoom), such that
+   * the entire board just fits inside the viewport
+   */
+  min_zoom = 1;
+  max_zoom = MAX (PCB->MaxWidth  / gport->width,
+                  PCB->MaxHeight / gport->height);
+  new_zoom = MIN (MAX (min_zoom, new_zoom), max_zoom);
+
+  if (gport->zoom == new_zoom)
+    return;
+
+  xtmp = (SIDE_X (center_x) - gport->view_x0) / (double)gport->view_width;
+  ytmp = (SIDE_Y (center_y) - gport->view_y0) / (double)gport->view_height;
+
+  gport->zoom = new_zoom;
+  pixel_slop = new_zoom;
+  ghid_port_ranges_scale (FALSE);
+
+  gport->view_x0 = MAX (0, SIDE_X (center_x) - xtmp * gport->view_width);
+  gport->view_y0 = MAX (0, SIDE_Y (center_y) - ytmp * gport->view_height);
+
+  ghidgui->adjustment_changed_holdoff = TRUE;
+  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view_x0);
+  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view_y0);
+  ghidgui->adjustment_changed_holdoff = FALSE;
+
+  ghid_port_ranges_changed ();
+  ghid_set_status_line_label ();
+}
+
+void
+ghid_zoom_view_rel (Coord center_x, Coord center_y, double factor)
+{
+  ghid_zoom_view_abs (center_x, center_y, gport->zoom * factor);
+}
+
+void
+ghid_zoom_view_fit (void)
+{
+  ghid_zoom_view_abs (0, 0, MAX (PCB->MaxWidth  / gport->width,
+                                 PCB->MaxHeight / gport->height));
+}
+
+void
+ghid_flip_view (Coord center_x, Coord center_y, bool flip_x, bool flip_y)
+{
+  render_priv *priv = gport->render_priv;
+
+  priv->view.flip_x = flip_x ? ! priv->view.flip_x : priv->view.flip_x;
+  priv->view.flip_y = flip_y ? ! priv->view.flip_y : priv->view.flip_y;
+
+  /* XXX: PAN THE BOARD SO THE CENTER LOCATION REMAINS IN THE SAME PLACE */
+
+  ghid_invalidate_all ();
+}
+
+
 #define LEAD_USER_WIDTH           0.2          /* millimeters */
 #define LEAD_USER_PERIOD          (1000 / 20)  /* 20fps (in ms) */
 #define LEAD_USER_VELOCITY        3.           /* millimeters per second */
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 83df23f..c106690 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -29,54 +29,6 @@
 RCSID ("$Id$");
 
 
-static void zoom_to (double factor, int x, int y);
-static void zoom_by (double factor, int x, int y);
-static void zoom_fit (void);
-
-int ghid_flip_x = 0, ghid_flip_y = 0;
-
-
-void
-ghid_pan_fixup ()
-{
-
-  /*
-   * don't pan so far to the right that we see way past the right 
-   * edge of the board.
-   */
-  if (gport->view_x0 > PCB->MaxWidth - gport->view_width)
-    gport->view_x0 = PCB->MaxWidth - gport->view_width;
-
-  /*
-   * don't pan so far down that we see way past the bottom edge of
-   * the board.
-   */
-  if (gport->view_y0 > PCB->MaxHeight - gport->view_height)
-    gport->view_y0 = PCB->MaxHeight - gport->view_height;
-
-  /* don't view above or to the left of the board... ever */
-  if (gport->view_x0 < 0)
-    gport->view_x0 = 0;
-
-   if (gport->view_y0 < 0)
-    gport->view_y0 = 0;
-
-  /* if we can see the entire board and some, then zoom to fit */
-  if (gport->view_width > PCB->MaxWidth &&
-      gport->view_height > PCB->MaxHeight)
-    {
-      zoom_fit ();
-      return;
-    }
-
-  ghidgui->adjustment_changed_holdoff = TRUE;
-  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view_x0);
-  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view_y0);
-  ghidgui->adjustment_changed_holdoff = FALSE;
-
-  ghid_port_ranges_changed();
-}
-
 /* ------------------------------------------------------------ */
 
 static const char zoom_syntax[] =
@@ -136,7 +88,7 @@ Zoom (int argc, char **argv, int x, int y)
 
   if (argc < 1)
     {
-      zoom_fit ();
+      ghid_zoom_view_fit ();
       return 0;
     }
 
@@ -149,81 +101,20 @@ Zoom (int argc, char **argv, int x, int y)
   switch (argv[0][0])
     {
     case '-':
-      zoom_by (1 / v, x, y);
+      ghid_zoom_view_rel (x, y, 1 / v);
       break;
     default:
     case '+':
-      zoom_by (v, x, y);
+      ghid_zoom_view_rel (x, y, v);
       break;
     case '=':
-      /* this needs to set the scale factor absolutely*/
-      zoom_to (v, x, y);
+      ghid_zoom_view_abs (x, y, v);
       break;
     }
 
   return 0;
 }
 
-
-static void
-zoom_to (double new_zoom, int x, int y)
-{
-  double min_zoom, max_zoom;
-  double xtmp, ytmp;
-
-  /* gport->zoom:
-   * zoom value is PCB units per screen pixel.  Larger numbers mean zooming
-   * out - the largest value means you are looking at the whole board.
-   *
-   * gport->view_width and gport->view_height are in PCB coordinates
-   */
-
-  /* Set the "minimum" zoom constant (maximum zoom),
-   * at 1 pixel per PCB unit */
-  min_zoom = 1;
-
-  /* Set the "maximum" zoom constant (minimum zoom),
-   * to make the entire board just fit inside the viewport */
-  max_zoom = MAX (PCB->MaxWidth  / gport->width,
-                  PCB->MaxHeight / gport->height);
-
-  new_zoom = MIN (MAX (min_zoom, new_zoom), max_zoom);
-
-  if (gport->zoom == new_zoom)
-    return;
-
-  xtmp = (SIDE_X (x) - gport->view_x0) / (double)gport->view_width;
-  ytmp = (SIDE_Y (y) - gport->view_y0) / (double)gport->view_height;
-
-  gport->zoom = new_zoom;
-  pixel_slop = new_zoom;
-  ghid_port_ranges_scale (FALSE);
-
-  gport->view_x0 = MAX (0, SIDE_X (x) - xtmp * gport->view_width);
-  gport->view_y0 = MAX (0, SIDE_Y (y) - ytmp * gport->view_height);
-
-  ghidgui->adjustment_changed_holdoff = TRUE;
-  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view_x0);
-  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view_y0);
-  ghidgui->adjustment_changed_holdoff = FALSE;
-
-  ghid_port_ranges_changed ();
-  ghid_set_status_line_label ();
-}
-
-static void
-zoom_by (double factor, int x, int y)
-{
-  zoom_to (gport->zoom * factor, x, y);
-}
-
-static void
-zoom_fit (void)
-{
-  zoom_to (MAX (PCB->MaxWidth  / gport->width,
-                PCB->MaxHeight / gport->height), 0, 0);
-}
-
 /* ------------------------------------------------------------ */
 
 void
@@ -286,95 +177,71 @@ ghid_mod1_is_pressed ()
 void
 ghid_set_crosshair (int x, int y, int action)
 {
+  GdkDisplay *display;
+  GdkScreen *screen;
+  int offset_x, offset_y;
+  int widget_x, widget_y;
+  int pointer_x, pointer_y;
+  Coord pcb_x, pcb_y;
+
   if (gport->crosshair_x != x || gport->crosshair_y != y)
     {
       ghid_set_cursor_position_labels ();
       gport->crosshair_x = x;
       gport->crosshair_y = y;
 
-      /*
-       * FIXME - does this trigger the idle_proc stuff?  It is in the
+      /* FIXME - does this trigger the idle_proc stuff?  It is in the
        * lesstif HID.  Maybe something is needed here?
        *
        * need_idle_proc ();
        */
-
     }
 
-  /*
-   * Pan the viewport so that the crosshair (which is in a fixed
-   * location relative to the board) lands where the pointer
-   * is.  What happens is the crosshair is moved on the board
-   * (see above) and then we move the board here to line it up
-   * again.  We do this by figuring out where the pointer is
-   * in board coordinates and we know where the crosshair is
-   * in board coordinates.  Then we know how far to pan.
+  if (action != HID_SC_PAN_VIEWPORT &&
+      action != HID_SC_WARP_POINTER)
+    return;
+
+  /* Find out where the drawing area is on the screen. gdk_display_get_pointer
+   * and gdk_display_warp_pointer work relative to the whole display, whilst
+   * our coordinates are relative to the drawing area origin.
    */
-  if (action == HID_SC_PAN_VIEWPORT)
-    {
-      GdkDisplay *display;
-      gint pos_x, pos_y, xofs, yofs;
-      
-      display = gdk_display_get_default ();
-      
-      /* figure out where the pointer is relative to the display */ 
-      gdk_display_get_pointer (display, NULL, &pos_x, &pos_y, NULL); 
-      
-      /*
-       * Figure out where the drawing area is on the screen so we can
-       * figure out where the pointer is relative to the viewport.
-       */ 
-      gdk_window_get_origin (gport->drawing_area->window, &xofs, &yofs);
-      
-      pos_x -= xofs;
-      pos_y -= yofs;
+  gdk_window_get_origin (gport->drawing_area->window, &offset_x, &offset_y);
+  display = gdk_display_get_default ();
 
-      /*
-       * pointer is at
-       *  px = gport->view_x0 + pos_x * gport->zoom
-       *  py = gport->view_y0 + pos_y * gport->zoom
-       *
-       * cross hair is at
-       *  x
-       *  y
-       *
-       * we need to shift x0 by (x - px) and y0 by (y - py)
-       * x0 = x0 + x - (x0 + pos_x * zoom)
-       *    = x - pos_x*zoom
+  switch (action) {
+    case HID_SC_PAN_VIEWPORT:
+      /* Pan the board in the viewport so that the crosshair (who's location
+       * relative on the board was set above) lands where the pointer is.
+       * We pass the request to pan a particular point on the board to a
+       * given widget coordinate of the viewport into the rendering code
        */
 
-      if (ghid_flip_x)
-        gport->view_x0 = x - (gport->view_width - pos_x * gport->zoom);
-      else
-        gport->view_x0 = x - pos_x * gport->zoom;
-
-      if (ghid_flip_y)
-        gport->view_y0 = y - (gport->view_height - pos_y * gport->zoom);
-      else
-        gport->view_y0 = y - pos_y * gport->zoom;
+      /* Find out where the pointer is relative to the display */
+      gdk_display_get_pointer (display, NULL, &pointer_x, &pointer_y, NULL);
 
-      ghid_pan_fixup();
+      widget_x = pointer_x - offset_x;
+      widget_y = pointer_y - offset_y;
 
-      action = HID_SC_WARP_POINTER;
-    }
+      ghid_event_to_pcb_coords (widget_x, widget_y, &pcb_x, &pcb_y);
+      ghid_pan_view_abs (pcb_x, pcb_y, widget_x, widget_y);
 
-  if (action == HID_SC_WARP_POINTER)
-    {
-      gint xofs, yofs;
-      GdkDisplay *display;
-      GdkScreen *screen;
+      /* Just in case we couldn't pan the board the whole way,
+       * we warp the pointer to where the crosshair DID land.
+       */
+      /* Fall through */
 
-      display = gdk_display_get_default ();
+    case HID_SC_WARP_POINTER:
       screen = gdk_display_get_default_screen (display);
 
-      /*
-       * Figure out where the drawing area is on the screen because
-       * gdk_display_warp_pointer will warp relative to the whole display
-       * but the value we've been given is relative to your drawing area
-       */
-      gdk_window_get_origin (gport->drawing_area->window, &xofs, &yofs);
-      gdk_display_warp_pointer (display, screen, xofs + Vx (x), yofs + Vy (y));
-    }
+      ghid_pcb_to_event_coords (x, y, &widget_x, &widget_y);
+
+      pointer_x = offset_x + widget_x;
+      pointer_y = offset_y + widget_y;
+
+      gdk_display_warp_pointer (display, screen, pointer_x, pointer_y);
+
+      break;
+  }
 }
 
 typedef struct
@@ -1177,7 +1044,7 @@ PCBChanged (int argc, char **argv, int x, int y)
   RouteStylesChanged (0, NULL, 0, 0);
   ghid_port_ranges_scale (TRUE);
   ghid_port_ranges_pan (0, 0, FALSE);
-  zoom_fit ();
+  ghid_zoom_view_fit ();
   ghid_port_ranges_changed ();
   ghid_sync_with_new_layout ();
   return 0;
@@ -1390,84 +1257,48 @@ side'' of the board.
 static int
 SwapSides (int argc, char **argv, int x, int y)
 {
-  gint flipd;
-  int do_flip_x = 0;
-  int do_flip_y = 0;
-  int comp_group = GetLayerGroupNumberByNumber (component_silk_layer);
-  int solder_group = GetLayerGroupNumberByNumber (solder_silk_layer);
   int active_group = GetLayerGroupNumberByNumber (LayerStack[0]);
-  int comp_showing =
-    PCB->Data->Layer[PCB->LayerGroups.Entries[comp_group][0]].On;
-  int solder_showing =
-    PCB->Data->Layer[PCB->LayerGroups.Entries[solder_group][0]].On;
+  int comp_group =   GetLayerGroupNumberByNumber (component_silk_layer);
+  int solder_group = GetLayerGroupNumberByNumber (solder_silk_layer);
+  int comp_showing =   LAYER_PTR (PCB->LayerGroups.Entries[comp_group][0])->On;
+  int solder_showing = LAYER_PTR (PCB->LayerGroups.Entries[solder_group][0])->On;
 
 
   if (argc > 0)
     {
       switch (argv[0][0]) {
-      case 'h':
-      case 'H':
-	ghid_flip_x = ! ghid_flip_x;
-	do_flip_x = 1;
-	break;
-      case 'v':
-      case 'V':
-	ghid_flip_y = ! ghid_flip_y;
-	do_flip_y = 1;
-	break;
-      case 'r':
-      case 'R':
-	ghid_flip_x = ! ghid_flip_x;
-	ghid_flip_y = ! ghid_flip_y;
-	do_flip_x = 1;
-	do_flip_y = 1;
-	break;
-      default:
-	return 1;
+        case 'h':
+        case 'H':
+          ghid_flip_view (x, y, true, false);
+          break;
+        case 'v':
+        case 'V':
+          ghid_flip_view (x, y, false, true);
+          break;
+        case 'r':
+        case 'R':
+          ghid_flip_view (x, y, true, true);
+          Settings.ShowSolderSide = !Settings.ShowSolderSide; /* Swapped back below */
+          break;
+        default:
+          return 1;
       }
-      /* SwapSides will swap this */
-      Settings.ShowSolderSide = (ghid_flip_x == ghid_flip_y);
     }
 
   Settings.ShowSolderSide = !Settings.ShowSolderSide;
-  if (Settings.ShowSolderSide)
-    {
-      if (active_group == comp_group && comp_showing && !solder_showing)
-	{
-	  ChangeGroupVisibility (PCB->LayerGroups.Entries[comp_group][0], 0,
-				 0);
-	  ChangeGroupVisibility (PCB->LayerGroups.Entries[solder_group][0], 1,
-				 1);
-	}
-    }
-  else
-    {
-      if (active_group == solder_group && solder_showing && !comp_showing)
-	{
-	  ChangeGroupVisibility (PCB->LayerGroups.Entries[solder_group][0], 0,
-				 0);
-	  ChangeGroupVisibility (PCB->LayerGroups.Entries[comp_group][0], 1,
-				 1);
-	}
-    }
 
-  /* Update coordinates so that the current location stays where it was on the
-     other side; we need to do this since the actual flip center is the
-     center of the board while the user expect the center would be the current
-     location */
-  if (do_flip_x)
-    {
-	flipd = PCB->MaxWidth / 2 - SIDE_X (gport->pcb_x);
-	ghid_port_ranges_pan (-2 * flipd, 0, TRUE);
-    }
-  if (do_flip_y)
+  if ((active_group == comp_group   && comp_showing   && !solder_showing) ||
+      (active_group == solder_group && solder_showing && !comp_showing))
     {
-	flipd = PCB->MaxHeight / 2 - SIDE_Y (gport->pcb_y);
-	ghid_port_ranges_pan (0, -2 * flipd, TRUE);
+      bool new_comp_vis = Settings.ShowSolderSide && active_group == comp_group;
+
+      ChangeGroupVisibility (PCB->LayerGroups.Entries[comp_group][0],
+                             new_comp_vis, new_comp_vis);
+      ChangeGroupVisibility (PCB->LayerGroups.Entries[solder_group][0],
+                             !new_comp_vis, !new_comp_vis);
     }
 
-  ghid_invalidate_all ();
-  return 0;
+   return 0;
 }
 
 /* ------------------------------------------------------------ */
@@ -1621,53 +1452,36 @@ currently within the window already.
 static int
 Center(int argc, char **argv, int x, int y)
 {
-  int x0, y0, w2, h2;
   GdkDisplay *display;
   GdkScreen *screen;
-  int xofs, yofs;
+  int offset_x, offset_y;
+  int widget_x, widget_y;
+  int pointer_x, pointer_y;
 
   if (argc != 0)
     AFAIL (center);
 
-  x = GRIDFIT_X (SIDE_X (x), PCB->Grid);
-  y = GRIDFIT_Y (SIDE_Y (y), PCB->Grid);
-
-  w2 = gport->view_width / 2;
-  h2 = gport->view_height / 2;
-  x0 = x - w2;
-  y0 = y - h2;
+  /* Aim to put the given x, y PCB coordinates in the center of the widget */
+  widget_x = gport->width / 2;
+  widget_y = gport->height / 2;
 
-  if (x0 < 0)
-    {
-      x0 = 0;
-      x = x0 + w2;
-    }
+  ghid_pan_view_abs (x, y, widget_x, widget_y);
 
-  if (y0 < 0)
-    {
-      y0 = 0;
-      y = y0 + h2;
-    }
-
-  gport->view_x0 = x0;
-  gport->view_y0 = y0;
+  /* Now move the mouse pointer to the place where the board location
+   * actually ended up.
+   *
+   * XXX: Should only do this if we confirm we are inside our window?
+   */
 
-  ghid_pan_fixup ();
+  ghid_pcb_to_event_coords (x, y, &widget_x, &widget_y);
+  gdk_window_get_origin (gport->drawing_area->window, &offset_x, &offset_y);
 
-  /* Move the pointer to the center of the window, but only if it's
-     currently within the window already.  Watch out for edges,
-     though.  */
+  pointer_x = offset_x + widget_x;
+  pointer_y = offset_y + widget_y;
 
   display = gdk_display_get_default ();
   screen = gdk_display_get_default_screen (display);
-
-  /*
-   * Figure out where the drawing area is on the screen because
-   * gdk_display_warp_pointer will warp relative to the whole display
-   * but the value we've been given is relative to your drawing area
-   */
-  gdk_window_get_origin (gport->drawing_area->window, &xofs, &yofs);
-  gdk_display_warp_pointer (display, screen, xofs + Vx (x), yofs + Vy (y));
+  gdk_display_warp_pointer (display, screen, pointer_x, pointer_y);
 
   return 0;
 }
@@ -1743,11 +1557,12 @@ CursorAction(int argc, char **argv, int x, int y)
     AFAIL (cursor);
 
   dx = GetValueEx (argv[1], argv[3], NULL, extra_units_x, "");
-  if (ghid_flip_x)
-    dx = -dx;
   dy = GetValueEx (argv[2], argv[3], NULL, extra_units_y, "");
-  if (!ghid_flip_y)
-    dy = -dy;
+
+#if 0 /* We cannot know this sensibly from the renderer, so we have to remove it */
+  if (ghid_flip_x) dx = -dx;
+  if (!ghid_flip_y) dy = -dy;
+#endif
 
   EventMoveCrosshair (Crosshair.X + dx, Crosshair.Y + dy);
   gui->set_crosshair (Crosshair.X, Crosshair.Y, pan_warp);
@@ -2127,24 +1942,6 @@ HID_Action ghid_main_action_list[] = {
 REGISTER_ACTIONS (ghid_main_action_list)
 
 
-static int
-flag_flipx (int x)
-{ 
-  return ghid_flip_x;
-} 
-static int  
-flag_flipy (int x)
-{ 
-  return ghid_flip_y;
-} 
-
-HID_Flag ghid_main_flag_list[] = {
-  {"flip_x", flag_flipx, 0},
-  {"flip_y", flag_flipy, 0}
-};  
-
-REGISTER_FLAGS (ghid_main_flag_list)
-
 #include "dolists.h"
 
 /*
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index bc47214..7e3891d 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -52,7 +52,7 @@
 
 #define TOOLTIP_UPDATE_DELAY 200
 
-static gint x_pan_speed, y_pan_speed;
+// static gint x_pan_speed, y_pan_speed;
 void
 ghid_port_ranges_changed (void)
 {
@@ -647,6 +647,7 @@ ghid_port_window_enter_cb (GtkWidget * widget,
   return FALSE;
 }
 
+#if 0
 static gboolean
 ghid_pan_idle_cb (gpointer data)
 {
@@ -658,12 +659,13 @@ ghid_pan_idle_cb (gpointer data)
   dx = gport->zoom * x_pan_speed;
   return (ghid_port_ranges_pan (dx, dy, TRUE));
 }
+#endif
 
 gint
 ghid_port_window_leave_cb (GtkWidget * widget, 
                            GdkEventCrossing * ev, GHidPort * out)
 {
-  gint x0, y0, x, y, dx, dy, w, h;
+  // gint x0, y0, x, y, dx, dy, w, h;
   
   /* printf("leave mode: %d detail: %d\n", ev->mode, ev->detail); */
 
@@ -679,6 +681,7 @@ ghid_port_window_leave_cb (GtkWidget * widget,
       return FALSE;
     }
 
+#if 0
   if(out->has_entered && !ghidgui->in_popup)
     {
       /* if actively drawing, start scrolling */
@@ -734,6 +737,7 @@ ghid_port_window_leave_cb (GtkWidget * widget,
 	  g_idle_add (ghid_pan_idle_cb, NULL);
 	}
     }
+#endif
 
   out->has_entered = FALSE;
 
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index d17cca2..ba19d66 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -61,10 +61,6 @@
 #define	FROM_PCB_UNITS(v)	(Settings.grid_units_mm ? COORD_TO_MM(v) : COORD_TO_MIL(v))
 #define	TO_PCB_UNITS(v)		(Settings.grid_units_mm ? MM_TO_COORD(v) : MIL_TO_COORD(v))
 
-extern int ghid_flip_x, ghid_flip_y;
-#define SIDE_X(x)   ((ghid_flip_x ? PCB->MaxWidth - (x) : (x)))
-#define SIDE_Y(y)   ((ghid_flip_y ? PCB->MaxHeight - (y) : (y)))
-
 #define	DRAW_X(x)	(gint)((SIDE_X(x) - gport->view_x0) / gport->zoom)
 #define	DRAW_Y(y)	(gint)((SIDE_Y(y) - gport->view_y0) / gport->zoom)
 
@@ -504,12 +500,17 @@ HID *ghid_request_debug_draw (void);
 void ghid_flush_debug_draw (void);
 void ghid_finish_debug_draw (void);
 bool ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y);
+bool ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y);
+void ghid_pan_view_abs (Coord pcb_x, Coord pcb_y, int widget_x, int widget_y);
+void ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom);
+void ghid_zoom_view_rel (Coord center_x, Coord center_y, double factor);
+void ghid_zoom_view_fit (void);
+void ghid_flip_view (Coord center_x, Coord center_y, bool flip_x, bool flip_y);
 
 void ghid_lead_user_to_location (Coord x, Coord y);
 void ghid_cancel_lead_user (void);
 
 /* gtkhid-main.c */
-void ghid_pan_fixup (void);
 void ghid_get_coords (const char *msg, int *x, int *y);
 gint PCBChanged (int argc, char **argv, int x, int y);
 
@@ -521,58 +522,4 @@ extern GdkPixmap *XC_lock_source, *XC_lock_mask;
 extern GdkPixmap *XC_clock_source, *XC_clock_mask;
 
 
-/* Coordinate conversions */
-/* Px converts view->pcb, Vx converts pcb->view */
-static inline int
-Vx (int x)
-{
-  int rv;
-  if (ghid_flip_x)
-    rv = (PCB->MaxWidth - x - gport->view_x0) / gport->zoom + 0.5;
-  else
-    rv = (x - gport->view_x0) / gport->zoom + 0.5;
-  return rv;
-}
-
-static inline int
-Vy (int y)
-{
-  int rv;
-  if (ghid_flip_y)
-    rv = (PCB->MaxHeight - y - gport->view_y0) / gport->zoom + 0.5;
-  else
-    rv = (y - gport->view_y0) / gport->zoom + 0.5;
-  return rv;
-}
-
-static inline int
-Vz (int z)
-{
-  return z / gport->zoom + 0.5;
-}
-
-static inline int
-Px (int x)
-{
-  int rv = x * gport->zoom + gport->view_x0;
-  if (ghid_flip_x)
-    rv = PCB->MaxWidth - (x * gport->zoom + gport->view_x0);
-  return  rv;
-}
-
-static inline int
-Py (int y)
-{
-  int rv = y * gport->zoom + gport->view_y0;
-  if (ghid_flip_y)
-    rv = PCB->MaxHeight - (y * gport->zoom + gport->view_y0);
-  return  rv;
-}
-
-static inline int
-Pz (int z)
-{
-  return (z * gport->zoom);
-}
-
 #endif /* __GHID_INCLUDED__  */

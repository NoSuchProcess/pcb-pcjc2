Bottom: bde09837966af6260dab85c7c523be38863f3de0
Top:    4e1d8231bd7e54fa9844f66dc2cf50e5f2bf7093
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-04-29 20:55:13 +0100

Convert object memory allocations to use g_slice()


---

diff --git a/src/action.c b/src/action.c
index ed087c1..1e01e87 100644
--- a/src/action.c
+++ b/src/action.c
@@ -1900,37 +1900,39 @@ static int
 ActionDumpLibrary (int argc, char **argv, int x, int y)
 {
   int i, j;
+  GList *ii, *jj;
 
   printf ("**** Do not count on this format.  It will change ****\n\n");
   printf ("MenuN   = %d\n", Library.MenuN);
-  printf ("MenuMax = %d\n", Library.MenuMax);
-  for (i = 0; i < Library.MenuN; i++)
+  for (ii = Library.Menu, i = 0; ii != NULL; ii = g_list_next (ii), i++)
     {
+      LibraryMenuType *menu = ii->data;
+
       printf ("Library #%d:\n", i);
-      printf ("    EntryN    = %d\n", Library.Menu[i].EntryN);
-      printf ("    EntryMax  = %d\n", Library.Menu[i].EntryMax);
-      printf ("    Name      = \"%s\"\n", UNKNOWN (Library.Menu[i].Name));
-      printf ("    directory = \"%s\"\n",
-	      UNKNOWN (Library.Menu[i].directory));
-      printf ("    Style     = \"%s\"\n", UNKNOWN (Library.Menu[i].Style));
-      printf ("    flag      = %d\n", Library.Menu[i].flag);
-
-      for (j = 0; j < Library.Menu[i].EntryN; j++)
+      printf ("    EntryN    = %d\n", menu->EntryN);
+      printf ("    Name      = \"%s\"\n", UNKNOWN (menu->Name));
+      printf ("    directory = \"%s\"\n", UNKNOWN (menu->directory));
+      printf ("    Style     = \"%s\"\n", UNKNOWN (menu->Style));
+      printf ("    flag      = %d\n", menu->flag);
+
+      for (jj = menu->Entry, j = 0; jj != NULL; jj = g_list_next (jj), j++)
 	{
+          LibraryEntryType *entry = jj->data;
+
 	  printf ("    #%4d: ", j);
-	  if (Library.Menu[i].Entry[j].Template == (char *) -1)
+	  if (entry->Template == (char *) -1)
 	    {
 	      printf ("newlib: \"%s\"\n",
-		      UNKNOWN (Library.Menu[i].Entry[j].ListEntry));
+		      UNKNOWN (entry->ListEntry));
 	    }
 	  else
 	    {
 	      printf ("\"%s\", \"%s\", \"%s\", \"%s\", \"%s\"\n",
-		      UNKNOWN (Library.Menu[i].Entry[j].ListEntry),
-		      UNKNOWN (Library.Menu[i].Entry[j].Template),
-		      UNKNOWN (Library.Menu[i].Entry[j].Package),
-		      UNKNOWN (Library.Menu[i].Entry[j].Value),
-		      UNKNOWN (Library.Menu[i].Entry[j].Description));
+		      UNKNOWN (entry->ListEntry),
+		      UNKNOWN (entry->Template),
+		      UNKNOWN (entry->Package),
+		      UNKNOWN (entry->Value),
+		      UNKNOWN (entry->Description));
 	    }
 	}
     }
@@ -3297,6 +3299,8 @@ static const char renumber_help[] =
 static int
 ActionRenumber (int argc, char **argv, int x, int y)
 {
+  return 0;
+#if 0
   bool changed = false;
   ElementTypePtr *element_list;
   ElementTypePtr *locked_element_list;
@@ -3635,6 +3639,7 @@ ActionRenumber (int argc, char **argv, int x, int y)
   free (element_list);
   free (cnt_list);
   return 0;
+#endif
 }
 
 
@@ -4629,16 +4634,15 @@ ActionChangeName (int argc, char **argv, int x, int y)
 		    SetChangedFlag (true);
 		    if (type == ELEMENT_TYPE)
 		      {
-			RubberbandTypePtr ptr;
-			int i;
+			GList *iter;
 
 			RestoreUndoSerialNumber ();
 			Crosshair.AttachedObject.RubberbandN = 0;
 			LookupRatLines (type, ptr1, ptr2, ptr3);
-			ptr = Crosshair.AttachedObject.Rubberband;
-			for (i = 0; i < Crosshair.AttachedObject.RubberbandN;
-			     i++, ptr++)
+			for (iter = Crosshair.AttachedObject.Rubberband;
+			     iter != NULL; iter = g_list_next (iter))
 			  {
+			    RubberbandType *ptr = iter->data;
 			    if (PCB->RatOn)
 			      EraseRat ((RatTypePtr) ptr->Line);
 			    MoveObjectToRemoveUndoList (RATLINE_TYPE,
@@ -6950,22 +6954,26 @@ find_element_by_refdes (char *refdes)
 static AttributeType *
 lookup_attr (AttributeListTypePtr list, const char *name)
 {
-  int i;
-  for (i=0; i<list->Number; i++)
-    if (strcmp (list->List[i].name, name) == 0)
-      return & list->List[i];
+  GList *iter;
+  for (iter = list->List; iter != NULL; iter = g_list_next (iter))
+    {
+      AttributeType *attr = iter->data;
+      if (strcmp (attr->name, name) == 0)
+        return attr;
+    }
   return NULL;
 }
 
 static void
 delete_attr (AttributeListTypePtr list, AttributeType *attr)
 {
-  int idx = attr - list->List;
-  if (idx < 0 || idx >= list->Number)
-    return;
-  if (list->Number - idx > 1)
-    memmove (attr, attr+1, (list->Number - idx - 1) * sizeof(AttributeType));
-  list->Number --;
+  GList *iter;
+
+  iter = g_list_find (list->List, attr);
+  g_return_if_fail (iter != NULL);
+
+  FreeAttribute (attr);
+  list->List = g_list_delete_link (list->List, iter);
 }
 
 /* ---------------------------------------------------------------- */
@@ -7136,7 +7144,7 @@ ActionElementList (int argc, char **argv, int x, int y)
 	return 1;
 
       er = ElementOrientation (e);
-      pe = & PASTEBUFFER->Data->Element[0];
+      pe = PASTEBUFFER->Data->Element->data;
       pr = ElementOrientation (pe);
 
       mx = e->MarkX;
diff --git a/src/autoplace.c b/src/autoplace.c
index 65eef92..31a17fb 100644
--- a/src/autoplace.c
+++ b/src/autoplace.c
@@ -157,16 +157,17 @@ static void
 UpdateXY (NetListTypePtr Nets)
 {
   Cardinal SLayer, CLayer;
-  Cardinal i, j;
+  GList *i, *j;
   /* find layer groups of the component side and solder side */
   SLayer = GetLayerGroupNumberByNumber (solder_silk_layer);
   CLayer = GetLayerGroupNumberByNumber (component_silk_layer);
   /* update all nets */
-  for (i = 0; i < Nets->NetN; i++)
+  for (i = Nets->Net; i != NULL; i = g_list_next (i))
     {
-      for (j = 0; j < Nets->Net[i].ConnectionN; j++)
+      NetType *net = i->data;
+      for (j = net->Connection; j != NULL; j = g_list_next (j))
 	{
-	  ConnectionTypePtr c = &(Nets->Net[i].Connection[j]);
+	  ConnectionType *c = j->data;
 	  switch (c->type)
 	    {
 	    case PAD_TYPE:
@@ -195,7 +196,7 @@ UpdateXY (NetListTypePtr Nets)
 static PointerListType
 collectSelectedElements ()
 {
-  PointerListType list = { 0, 0, NULL };
+  PointerListType list = {0, NULL};
   ELEMENT_LOOP (PCB->Data);
   {
     if (TEST_FLAG (SELECTEDFLAG, element))
@@ -335,32 +336,38 @@ ComputeCost (NetListTypePtr Nets, double T0, double T)
   double delta3 = 0;		/* out of bounds penalty */
   double delta4 = 0;		/* alignment bonus */
   double delta5 = 0;		/* total area penalty */
-  Cardinal i, j;
+  int i;
+  GList *ii, *j;
   LocationType minx, maxx, miny, maxy;
   bool allpads, allsameside;
   Cardinal thegroup;
-  BoxListType bounds = { 0, 0, NULL };	/* save bounding rectangles here */
-  BoxListType solderside = { 0, 0, NULL };	/* solder side component bounds */
-  BoxListType componentside = { 0, 0, NULL };	/* component side bounds */
+  BoxListType bounds = {0, NULL};	/* save bounding rectangles here */
+  BoxListType solderside = {0, NULL};	/* solder side component bounds */
+  BoxListType componentside = {0, NULL};	/* component side bounds */
   /* make sure the NetList have the proper updated X and Y coords */
   UpdateXY (Nets);
   /* wire length term.  approximated by half-perimeter of minimum
    * rectangle enclosing the net.  Note that we penalize vias in
    * all-SMD nets by making the rectangle a cube and weighting
    * the "layer height" of the net. */
-  for (i = 0; i < Nets->NetN; i++)
+  for (ii = Nets->Net; ii != NULL; ii = g_list_next (ii))
     {
-      NetTypePtr n = &Nets->Net[i];
+      NetType *n = ii->data;
+      ConnectionType *c;
+
       if (n->ConnectionN < 2)
 	continue;		/* no cost to go nowhere */
-      minx = maxx = n->Connection[0].X;
-      miny = maxy = n->Connection[0].Y;
-      thegroup = n->Connection[0].group;
-      allpads = (n->Connection[0].type == PAD_TYPE);
+
+      j = n->Connection;
+      c = j->data;
+      minx = maxx = c->X;
+      miny = maxy = c->Y;
+      thegroup = c->group;
+      allpads = (c->type == PAD_TYPE);
       allsameside = true;
-      for (j = 1; j < n->ConnectionN; j++)
+      for (; j != NULL; j = g_list_next (j))
 	{
-	  ConnectionTypePtr c = &(n->Connection[j]);
+	  c = j->data;
 	  MAKEMIN (minx, c->X);
 	  MAKEMAX (maxx, c->X);
 	  MAKEMIN (miny, c->Y);
@@ -511,10 +518,8 @@ ComputeCost (NetListTypePtr Nets, double T0, double T)
    * aligning to something far away isn't profitable */
   {
     /* create r tree */
-    PointerListType seboxes = { 0, 0, NULL }
-    , ceboxes =
-    {
-    0, 0, NULL};
+    PointerListType seboxes = {0, NULL};
+    PointerListType ceboxes = {0, NULL};
     struct ebox
     {
       BoxType box;
@@ -615,6 +620,12 @@ ComputeCost (NetListTypePtr Nets, double T0, double T)
   return W + (delta1 + delta2 + delta3 - delta4 + delta5);
 }
 
+void *
+random_pointer_from_list (PointerListType *pl)
+{
+  return g_list_nth_data (pl->Ptr, random () % pl->PtrN);
+}
+
 /* ---------------------------------------------------------------------------
  * Perturb:
  *  1) flip SMD from solder side to component side or vice-versa.
@@ -628,7 +639,7 @@ createPerturbation (PointerListTypePtr selected, double T)
 {
   PerturbationType pt = { 0 };
   /* pick element to perturb */
-  pt.element = (ElementTypePtr) selected->Ptr[random () % selected->PtrN];
+  pt.element = (ElementType*) random_pointer_from_list (selected);
   /* exchange, flip/rotate or shift? */
   switch (random () % ((selected->PtrN > 1) ? 3 : 2))
     {
@@ -666,10 +677,9 @@ createPerturbation (PointerListTypePtr selected, double T)
     case 2:
       {				/* exchange! */
 	pt.which = EXCHANGE;
-	pt.other = (ElementTypePtr)
-	  selected->Ptr[random () % (selected->PtrN - 1)];
-	if (pt.other == pt.element)
-	  pt.other = (ElementTypePtr) selected->Ptr[selected->PtrN - 1];
+	pt.other = pt.element;
+	while (pt.other == pt.element)
+	  pt.other = (ElementType*) random_pointer_from_list (selected);
 	/* don't allow exchanging a solderside-side SMD component
 	 * with a non-SMD component. */
 	if ((pt.element->PinN != 0 /* non-SMD */  &&
@@ -760,7 +770,7 @@ bool
 AutoPlaceSelected (void)
 {
   NetListTypePtr Nets;
-  PointerListType Selected = { 0, 0, NULL };
+  PointerListType Selected = {0, NULL};
   PerturbationType pt;
   double C0, T0;
   bool changed = false;
diff --git a/src/autoroute.c b/src/autoroute.c
index c17a8fe..dd127b4 100644
--- a/src/autoroute.c
+++ b/src/autoroute.c
@@ -170,6 +170,7 @@ static hidGC ar_gc = 0;
 
 #define LIST_LOOP(init, which, x) do {\
      routebox_t *__next_one__ = (init);\
+   GList *__copy; /* DUMMY */\
    x = NULL;\
    if (!__next_one__)\
      assert(__next_one__);\
@@ -1006,7 +1007,6 @@ CreateRouteData ()
     {
       layergroupboxes[i].Ptr = NULL;
       layergroupboxes[i].PtrN = 0;
-      layergroupboxes[i].PtrMax = 0;
       GROUP_LOOP (PCB->Data, i);
       {
 	if (layer->LineN || layer->ArcN)
diff --git a/src/buffer.c b/src/buffer.c
index 907c7e6..554c580 100644
--- a/src/buffer.c
+++ b/src/buffer.c
@@ -236,77 +236,56 @@ AddElementToBuffer (ElementTypePtr Element)
  * moves a via to paste buffer without allocating memory for the name
  */
 static void *
-MoveViaToBuffer (PinTypePtr Via)
+MoveViaToBuffer (PinType *via)
 {
-  PinTypePtr via;
+  RestoreToPolygon (Source, VIA_TYPE, via, via);
+
+  r_delete_entry (Source->via_tree, (BoxType *) via);
+  Source->Via = g_list_remove (Source->Via, via);
+  Dest->Via = g_list_append (Dest->Via, via);
 
-  RestoreToPolygon (Source, VIA_TYPE, Via, Via);
-  r_delete_entry (Source->via_tree, (BoxType *) Via);
-  via = GetViaMemory (Dest);
-  *via = *Via;
   CLEAR_FLAG (WARNFLAG | FOUNDFLAG, via);
-  if (Via != &Source->Via[--Source->ViaN])
-  {
-  *Via = Source->Via[Source->ViaN];
-  r_substitute (Source->via_tree, (BoxType *) & Source->Via[Source->ViaN],
-		(BoxType *) Via);
-  }
-  memset (&Source->Via[Source->ViaN], 0, sizeof (PinType));
+
   if (!Dest->via_tree)
     Dest->via_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (Dest->via_tree, (BoxType *) via, 0);
   ClearFromPolygon (Dest, VIA_TYPE, via, via);
-  return (via);
+  return via;
 }
 
 /* ---------------------------------------------------------------------------
  * moves a rat-line to paste buffer
  */
 static void *
-MoveRatToBuffer (RatTypePtr Rat)
+MoveRatToBuffer (RatType *rat)
 {
-  RatTypePtr rat;
-
-  r_delete_entry (Source->rat_tree, &Rat->BoundingBox);
-  rat = GetRatMemory (Dest);
-  *rat = *Rat;
+  r_delete_entry (Source->rat_tree, (BoxType *)rat);
+  Source->Rat = g_list_remove (Source->Rat, rat);
+  Dest->Rat = g_list_append (Dest->Rat, rat);
   CLEAR_FLAG (FOUNDFLAG, rat);
-  if (Rat != &Source->Rat[--Source->RatN])
-  {
-  *Rat = Source->Rat[Source->RatN];
-  r_substitute (Source->rat_tree, &Source->Rat[Source->RatN].BoundingBox,
-		&Rat->BoundingBox);
-  }
-  memset (&Source->Rat[Source->RatN], 0, sizeof (RatType));
+
   if (!Dest->rat_tree)
     Dest->rat_tree = r_create_tree (NULL, 0, 0);
-  r_insert_entry (Dest->rat_tree, &rat->BoundingBox, 0);
-  return (rat);
+  r_insert_entry (Dest->rat_tree, (BoxType *)rat, 0);
+  return rat;
 }
 
 /* ---------------------------------------------------------------------------
  * moves a line to buffer  
  */
 static void *
-MoveLineToBuffer (LayerTypePtr Layer, LineTypePtr Line)
+MoveLineToBuffer (LayerType *layer, LineTypePtr line)
 {
-  LayerTypePtr lay;
-  LineTypePtr line;
+  LayerTypePtr lay = &Dest->Layer[GetLayerNumber (Source, layer)];
+
+  RestoreToPolygon (Source, LINE_TYPE, layer, line);
+  r_delete_entry (layer->line_tree, (BoxType*)line);
+
+  layer->Line = g_list_remove (layer->Line, line);
+  lay->Line = g_list_append (lay->Line, line);
 
-  RestoreToPolygon (Source, LINE_TYPE, Layer, Line);
-  r_delete_entry (Layer->line_tree, (BoxTypePtr) Line);
-  lay = &Dest->Layer[GetLayerNumber (Source, Layer)];
-  line = GetLineMemory (lay);
-  *line = *Line;
   CLEAR_FLAG (FOUNDFLAG, line);
-  /* line pointers being shuffled */
-  if (Line != &Layer->Line[--Layer->LineN])
-  {
-  *Line = Layer->Line[Layer->LineN];
-  r_substitute (Layer->line_tree, (BoxTypePtr) & Layer->Line[Layer->LineN],
-		(BoxTypePtr) Line);
-  }
-  memset (&Layer->Line[Layer->LineN], 0, sizeof (LineType));
+
   if (!lay->line_tree)
     lay->line_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (lay->line_tree, (BoxTypePtr) line, 0);
@@ -318,25 +297,18 @@ MoveLineToBuffer (LayerTypePtr Layer, LineTypePtr Line)
  * moves an arc to buffer  
  */
 static void *
-MoveArcToBuffer (LayerTypePtr Layer, ArcTypePtr Arc)
+MoveArcToBuffer (LayerType *layer, ArcType *arc)
 {
-  LayerTypePtr lay;
-  ArcTypePtr arc;
-
-  RestoreToPolygon (Source, ARC_TYPE, Layer, Arc);
-  r_delete_entry (Layer->arc_tree, (BoxTypePtr) Arc);
-  lay = &Dest->Layer[GetLayerNumber (Source, Layer)];
-  arc = GetArcMemory (lay);
-  *arc = *Arc;
+  LayerType *lay = &Dest->Layer[GetLayerNumber (Source, layer)];
+
+  RestoreToPolygon (Source, ARC_TYPE, layer, arc);
+  r_delete_entry (layer->arc_tree, (BoxTypePtr) arc);
+
+  layer->Arc = g_list_remove (layer->Arc, arc);
+  lay->Arc = g_list_append (lay->Arc, arc);
+
   CLEAR_FLAG (FOUNDFLAG, arc);
-  /* arc pointers being shuffled */
-  if (Arc != &Layer->Arc[--Layer->ArcN])
-  {
-  *Arc = Layer->Arc[Layer->ArcN];
-  r_substitute (Layer->arc_tree, (BoxTypePtr) & Layer->Arc[Layer->ArcN],
-		(BoxTypePtr) Arc);
-  }
-  memset (&Layer->Arc[Layer->ArcN], 0, sizeof (ArcType));
+
   if (!lay->arc_tree)
     lay->arc_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (lay->arc_tree, (BoxTypePtr) arc, 0);
@@ -348,23 +320,16 @@ MoveArcToBuffer (LayerTypePtr Layer, ArcTypePtr Arc)
  * moves a text to buffer without allocating memory for the name
  */
 static void *
-MoveTextToBuffer (LayerTypePtr Layer, TextTypePtr Text)
+MoveTextToBuffer (LayerType *layer, TextType *text)
 {
-  TextTypePtr text;
-  LayerTypePtr lay;
-
-  r_delete_entry (Layer->text_tree, (BoxTypePtr) Text);
-  RestoreToPolygon (Source, TEXT_TYPE, Layer, Text);
-  lay = &Dest->Layer[GetLayerNumber (Source, Layer)];
-  text = GetTextMemory (lay);
-  *text = *Text;
-  if (Text != &Layer->Text[--Layer->TextN])
-  {
-  *Text = Layer->Text[Layer->TextN];
-  r_substitute (Layer->text_tree, (BoxTypePtr) & Layer->Text[Layer->TextN],
-		(BoxTypePtr) Text);
-  }
-  memset (&Layer->Text[Layer->TextN], 0, sizeof (TextType));
+  LayerType *lay = &Dest->Layer[GetLayerNumber (Source, layer)];
+
+  r_delete_entry (layer->text_tree, (BoxTypePtr) text);
+  RestoreToPolygon (Source, TEXT_TYPE, layer, text);
+
+  layer->Text = g_list_remove (layer->Text, text);
+  lay->Text = g_list_append (lay->Text, text);
+
   if (!lay->text_tree)
     lay->text_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (lay->text_tree, (BoxTypePtr) text, 0);
@@ -376,27 +341,20 @@ MoveTextToBuffer (LayerTypePtr Layer, TextTypePtr Text)
  * moves a polygon to buffer. Doesn't allocate memory for the points
  */
 static void *
-MovePolygonToBuffer (LayerTypePtr Layer, PolygonTypePtr Polygon)
+MovePolygonToBuffer (LayerType *layer, PolygonType *polygon)
 {
-  LayerTypePtr lay;
-  PolygonTypePtr polygon;
+  LayerType *lay = &Dest->Layer[GetLayerNumber (Source, layer)];
+
+  r_delete_entry (layer->polygon_tree, (BoxType *)polygon);
+
+  layer->Polygon = g_list_remove (layer->Polygon, polygon);
+  lay->Polygon = g_list_append (lay->Polygon, polygon);
 
-  r_delete_entry (Layer->polygon_tree, (BoxTypePtr) Polygon);
-  lay = &Dest->Layer[GetLayerNumber (Source, Layer)];
-  polygon = GetPolygonMemory (lay);
-  *polygon = *Polygon;
   CLEAR_FLAG (FOUNDFLAG, polygon);
-  if (Polygon != &Layer->Polygon[--Layer->PolygonN])
-  {
-  *Polygon = Layer->Polygon[Layer->PolygonN];
-  r_substitute (Layer->polygon_tree,
-		(BoxTypePtr) & Layer->Polygon[Layer->PolygonN],
-		(BoxTypePtr) Polygon);
-  }
-  memset (&Layer->Polygon[Layer->PolygonN], 0, sizeof (PolygonType));
+
   if (!lay->polygon_tree)
     lay->polygon_tree = r_create_tree (NULL, 0, 0);
-  r_insert_entry (lay->polygon_tree, (BoxTypePtr) polygon, 0);
+  r_insert_entry (lay->polygon_tree, (BoxType *)polygon, 0);
   return (polygon);
 }
 
@@ -404,36 +362,27 @@ MovePolygonToBuffer (LayerTypePtr Layer, PolygonTypePtr Polygon)
  * moves a element to buffer without allocating memory for pins/names
  */
 static void *
-MoveElementToBuffer (ElementTypePtr Element)
+MoveElementToBuffer (ElementType *element)
 {
-  ElementTypePtr element;
-  int i;
-
   /*
-   * Two steps at once:  Delete the element from the source (remove it
-   * from trees, restore to polygons) and simultaneously adjust its
-   * component pointers to the new storage in Dest
+   * Delete the element from the source (remove it from trees,
+   * restore to polygons)
    */
-  r_delete_element (Source, Element);
-  element = GetElementMemory (Dest);
-  *element = *Element;
+  r_delete_element (Source, element);
+
+  Source->Element = g_list_remove (Source->Element, element);
+  Dest->Element = g_list_append (Dest->Element, element);
+
   PIN_LOOP (element);
   {
-    RestoreToPolygon(Source, PIN_TYPE, Element, pin);
+    RestoreToPolygon(Source, PIN_TYPE, element, pin);
     CLEAR_FLAG (WARNFLAG | FOUNDFLAG, pin);
-    pin->Element = element;
   }
   END_LOOP;
   PAD_LOOP (element);
   {
-    RestoreToPolygon(Source, PAD_TYPE, Element, pad);
+    RestoreToPolygon(Source, PAD_TYPE, element, pad);
     CLEAR_FLAG (WARNFLAG | FOUNDFLAG, pad);
-    pad->Element = element;
-  }
-  END_LOOP;
-  ELEMENTTEXT_LOOP (element);
-  {
-    text->Element = element;
   }
   END_LOOP;
   SetElementBoundingBox (Dest, element, &PCB->Font);
@@ -451,41 +400,7 @@ MoveElementToBuffer (ElementTypePtr Element)
   }
   END_LOOP;
 
-  /*
-   * Now compact the Source's Element array by moving the last element
-   * to the hole created by the removal above.  Then make a pass adjusting
-   * *its* component pointers.  Confusingly, this element (which is of no
-   * particular relation to this removal) becomes `Element' while the
-   * original Element is now in `element'.
-   */
-  if (Element != &Source->Element[--Source->ElementN])
-    {
-  *Element = Source->Element[Source->ElementN];
-  r_substitute (Source->element_tree,
-		(BoxType *) & Source->Element[Source->ElementN],
-		(BoxType *) Element);
-  for (i = 0; i < MAX_ELEMENTNAMES; i++)
-    r_substitute (Source->name_tree[i],
-		  (BoxType *) & Source->Element[Source->ElementN].Name[i],
-		  (BoxType *) & Element->Name[i]);
-  ELEMENTTEXT_LOOP (Element);
-  {
-    text->Element = Element;
-  }
-  END_LOOP;
-  PIN_LOOP (Element);
-  {
-    pin->Element = Element;
-  }
-  END_LOOP;
-  PAD_LOOP (Element);
-  {
-    pad->Element = Element;
-  }
-  END_LOOP;
-  }
-  memset (&Source->Element[Source->ElementN], 0, sizeof (ElementType));
-  return (element);
+  return element;
 }
 
 /* ---------------------------------------------------------------------------
@@ -567,7 +482,7 @@ LoadElementToBuffer (BufferTypePtr Buffer, char *Name, bool FromFile)
 	  SetBufferBoundingBox (Buffer);
 	  if (Buffer->Data->ElementN)
 	    {
-	      element = &(Buffer->Data->Element[0]);
+	      element = Buffer->Data->Element->data;
 	      Buffer->X = element->MarkX;
 	      Buffer->Y = element->MarkY;
 	    }
@@ -584,7 +499,7 @@ LoadElementToBuffer (BufferTypePtr Buffer, char *Name, bool FromFile)
       if (!ParseLibraryEntry (Buffer->Data, Name)
 	  && Buffer->Data->ElementN != 0)
 	{
-	  element = &(Buffer->Data->Element[0]);
+	  element = Buffer->Data->Element->data;
 
 	  /* always add elements using top-side coordinates */
 	  if (Settings.ShowSolderSide)
@@ -666,47 +581,55 @@ void
 make_footprint_hash ()
 {
   int i, j;
+  GList *ii, *jj;
   char *fp;
   int num_entries = 0;
 
   clear_footprint_hash ();
 
-  for (i=0; i<Library.MenuN; i++)
-    for (j=0; j<Library.Menu[i].EntryN; j++)
-      num_entries ++;
+  for (ii = Library.Menu; ii != NULL; ii = g_list_next (ii))
+    {
+      LibraryMenuType *menu = ii->data;
+      for (jj = menu->Entry; jj != NULL; jj = g_list_next (jj))
+        num_entries ++;
+    }
   footprint_hash = (FootprintHashEntry *)malloc (num_entries * sizeof(FootprintHashEntry));
+
   num_entries = 0;
 
   /* There are two types of library entries.  The file-based types
      have a Template of (char *)-1 and the AllocatedMemory is the full
      path to the footprint file.  The m4 ones have the footprint name
      in brackets in the description.  */
-  for (i=0; i<Library.MenuN; i++)
+  for (ii = Library.Menu, i = 0; ii != NULL; ii = g_list_next (ii), i++)
     {
+      LibraryMenuType *menu = ii->data;
 #ifdef DEBUG
   printf("In make_footprint_hash, looking for footprints in %s\n", 
-	 Library.Menu[i].directory);
+	 menu->directory);
 #endif
 
-    for (j=0; j<Library.Menu[i].EntryN; j++)
+      for (jj = menu->Entry, j = 0; jj != NULL; jj = g_list_next (jj), j++)
 	{
+          LibraryEntryType *entry = jj->data;
+
 	  footprint_hash[num_entries].menu_idx = i;
 	  footprint_hash[num_entries].entry_idx = j;
-	  if (Library.Menu[i].Entry[j].Template == (char *) -1) 
+	  if (entry->Template == (char *) -1) 
           /* file */
 	    {
 #ifdef DEBUG
-/*	      printf(" ... Examining file %s\n", Library.Menu[i].Entry[j].AllocatedMemory); */
+/*	      printf(" ... Examining file %s\n", entry->AllocatedMemory); */
 #endif
-	      fp = strrchr (Library.Menu[i].Entry[j].AllocatedMemory, '/');
+	      fp = strrchr (entry->AllocatedMemory, '/');
 
 	      if (!fp)
-		fp = strrchr (Library.Menu[i].Entry[j].AllocatedMemory, '\\');
+		fp = strrchr (entry->AllocatedMemory, '\\');
 
 	      if (fp)
 		fp ++;
 	      else 
-		fp = Library.Menu[i].Entry[j].AllocatedMemory;
+		fp = entry->AllocatedMemory;
 
 #ifdef DEBUG
 /* 	      printf(" ... found file footprint %s\n",  fp); */
@@ -718,7 +641,7 @@ make_footprint_hash ()
 	  else 
           /* m4 */
 	    {
-	      fp = strrchr (Library.Menu[i].Entry[j].Description, '[');
+	      fp = strrchr (entry->Description, '[');
 	      if (fp)
 		{
 		  footprint_hash[num_entries].footprint = strdup (fp+1);
@@ -729,7 +652,7 @@ make_footprint_hash ()
 		}
 	      else
 		{
-		  fp = Library.Menu[i].Entry[j].Description;
+		  fp = entry->Description;
 		  footprint_hash[num_entries].footprint = fp;
 		  footprint_hash[num_entries].footprint_allocated = 0;
 		}
@@ -806,8 +729,8 @@ LoadFootprintByName (BufferTypePtr Buffer, char *Footprint)
       return 1;
     }
 
-  menu = & Library.Menu[fpe->menu_idx];
-  entry = & menu->Entry[fpe->entry_idx];
+  menu = g_list_nth_data (Library.Menu, fpe->menu_idx);
+  entry = g_list_nth_data (menu->Entry, fpe->entry_idx);
 
   if (entry->Template == (char *) -1)
     {
@@ -900,7 +823,7 @@ LoadFootprint (int argc, char **argv, int x, int y)
       return 1;
     }
 
-  e = & PASTEBUFFER->Data->Element[0];
+  e = PASTEBUFFER->Data->Element->data;
 
   if (e->Name[0].TextString)
     free (e->Name[0].TextString);
@@ -942,7 +865,7 @@ SmashBufferElement (BufferTypePtr Buffer)
    * around for us to smash bits off it.  It then becomes our responsibility,
    * however, to free the single element when we're finished with it.
    */
-  element = &Buffer->Data->Element[0];
+  element = Buffer->Data->Element->data;
   Buffer->Data->Element = NULL;
   Buffer->Data->ElementN = 0;
   ClearBuffer (Buffer);
diff --git a/src/copy.c b/src/copy.c
index b93fcfb..51781ca 100644
--- a/src/copy.c
+++ b/src/copy.c
@@ -122,7 +122,7 @@ CopyElementLowLevel (DataTypePtr Data, ElementTypePtr Dest,
 		     ElementTypePtr Src, bool uniqueName, LocationType dx,
 		     LocationType dy)
 {
-  int i;
+  GList *iter;
   /* release old memory if necessary */
   if (Dest)
     FreeElementMemory (Dest);
@@ -172,10 +172,11 @@ CopyElementLowLevel (DataTypePtr Data, ElementTypePtr Dest,
   }
   END_LOOP;
 
-  for (i=0; i<Src->Attributes.Number; i++)
-    CreateNewAttribute (& Dest->Attributes,
-			Src->Attributes.List[i].name,
-			Src->Attributes.List[i].value);
+  for (iter = Src->Attributes.List; iter != NULL; iter = g_list_next (iter))
+    {
+      AttributeType *attr = iter->data;
+      CreateNewAttribute (&Dest->Attributes, attr->name, attr->value);
+    }
 
   Dest->MarkX = Src->MarkX + dx;
   Dest->MarkY = Src->MarkY + dy;
diff --git a/src/create.c b/src/create.c
index 6409139..1bf5627 100644
--- a/src/create.c
+++ b/src/create.c
@@ -713,16 +713,11 @@ CreateNewArcInElement (ElementTypePtr Element,
 		       BDimension Width, BDimension Height,
 		       int Angle, int Delta, BDimension Thickness)
 {
-  ArcTypePtr arc = Element->Arc;
+  ArcType *arc;
 
-  /* realloc new memory if necessary and clear it */
-  if (Element->ArcN >= Element->ArcMax)
-    {
-      Element->ArcMax += STEP_ELEMENTARC;
-      arc = (ArcTypePtr)realloc (arc, Element->ArcMax * sizeof (ArcType));
-      Element->Arc = arc;
-      memset (arc + Element->ArcN, 0, STEP_ELEMENTARC * sizeof (ArcType));
-    }
+  arc = g_slice_new0 (ArcType);
+  Element->Arc = g_list_append (Element->Arc, arc);
+  Element->ArcN ++;
 
   /* set Delta (0,360], StartAngle in [0,360) */
   if ((Delta = Delta % 360) == 0)
@@ -736,7 +731,6 @@ CreateNewArcInElement (ElementTypePtr Element,
     Angle += 360;
 
   /* copy values */
-  arc = arc + Element->ArcN++;
   arc->X = X;
   arc->Y = Y;
   arc->Width = Width;
@@ -745,7 +739,7 @@ CreateNewArcInElement (ElementTypePtr Element,
   arc->Delta = Delta;
   arc->Thickness = Thickness;
   arc->ID = ID++;
-  return (arc);
+  return arc;
 }
 
 /* ---------------------------------------------------------------------------
@@ -757,21 +751,16 @@ CreateNewLineInElement (ElementTypePtr Element,
 			LocationType X2, LocationType Y2,
 			BDimension Thickness)
 {
-  LineTypePtr line = Element->Line;
+  LineType *line;
 
   if (Thickness == 0)
-    return (NULL);
-  /* realloc new memory if necessary and clear it */
-  if (Element->LineN >= Element->LineMax)
-    {
-      Element->LineMax += STEP_ELEMENTLINE;
-      line = (LineTypePtr)realloc (line, Element->LineMax * sizeof (LineType));
-      Element->Line = line;
-      memset (line + Element->LineN, 0, STEP_ELEMENTLINE * sizeof (LineType));
-    }
+    return NULL;
+
+  line = g_slice_new0 (LineType);
+  Element->Line = g_list_append (Element->Line, line);
+  Element->LineN ++;
 
   /* copy values */
-  line = line + Element->LineN++;
   line->Point1.X = X1;
   line->Point1.Y = Y1;
   line->Point2.X = X2;
@@ -779,7 +768,7 @@ CreateNewLineInElement (ElementTypePtr Element,
   line->Thickness = Thickness;
   line->Flags = NoFlags ();
   line->ID = ID++;
-  return (line);
+  return line;
 }
 
 /* ---------------------------------------------------------------------------
@@ -926,25 +915,19 @@ CreateNewLineInSymbol (SymbolTypePtr Symbol,
 		       LocationType X1, LocationType Y1,
 		       LocationType X2, LocationType Y2, BDimension Thickness)
 {
-  LineTypePtr line = Symbol->Line;
+  LineType* line;
 
-  /* realloc new memory if necessary and clear it */
-  if (Symbol->LineN >= Symbol->LineMax)
-    {
-      Symbol->LineMax += STEP_SYMBOLLINE;
-      line = (LineTypePtr)realloc (line, Symbol->LineMax * sizeof (LineType));
-      Symbol->Line = line;
-      memset (line + Symbol->LineN, 0, STEP_SYMBOLLINE * sizeof (LineType));
-    }
+  line = g_slice_new0 (LineType);
+  Symbol->Line = g_list_append (Symbol->Line, line);
+  Symbol->LineN ++;
 
   /* copy values */
-  line = line + Symbol->LineN++;
   line->Point1.X = X1;
   line->Point1.Y = Y1;
   line->Point2.X = X2;
   line->Point2.Y = Y2;
   line->Thickness = Thickness;
-  return (line);
+  return line;
 }
 
 /* ---------------------------------------------------------------------------
@@ -1013,16 +996,17 @@ CreateNewConnection (LibraryMenuTypePtr net, char *conn)
 /* ---------------------------------------------------------------------------
  * Add an attribute to a list.
  */
-AttributeTypePtr
-CreateNewAttribute (AttributeListTypePtr list, char *name, char *value)
+AttributeType *
+CreateNewAttribute (AttributeListType *list, char *name, char *value)
 {
-  if (list->Number >= list->Max)
-    {
-      list->Max += 10;
-      list->List = (AttributeType *)realloc (list->List, list->Max * sizeof (AttributeType));
-    }
-  list->List[list->Number].name = STRDUP (name);
-  list->List[list->Number].value = STRDUP (value);
-  list->Number++;
-  return &list->List[list->Number - 1];
+  AttributeType *attr;
+
+  attr = g_slice_new0 (AttributeType);
+  list->List = g_list_append (list->List, attr);
+  list->Number ++;
+
+  attr->name = STRDUP (name);
+  attr->value = STRDUP (value);
+
+  return attr;
 }
diff --git a/src/crosshair.c b/src/crosshair.c
index 2abe960..6b81ae5 100644
--- a/src/crosshair.c
+++ b/src/crosshair.c
@@ -384,8 +384,7 @@ XORDrawInsertPointObject (void)
 static void
 XORDrawMoveOrCopyObject (void)
 {
-  RubberbandTypePtr ptr;
-  Cardinal i;
+  GList *i;
   LocationType dx = Crosshair.X - Crosshair.AttachedObject.X,
     dy = Crosshair.Y - Crosshair.AttachedObject.Y;
 
@@ -503,11 +502,10 @@ XORDrawMoveOrCopyObject (void)
     }
 
   /* draw the attached rubberband lines too */
-  i = Crosshair.AttachedObject.RubberbandN;
-  ptr = Crosshair.AttachedObject.Rubberband;
-  while (i)
+  for (i = Crosshair.AttachedObject.Rubberband; i != NULL; i = g_list_next (i))
     {
-      PointTypePtr point1, point2;
+      RubberbandType *ptr = i->data;
+      PointType *point1, *point2;
 
       if (TEST_FLAG (VIAFLAG, ptr->Line))
 	{
@@ -535,9 +533,6 @@ XORDrawMoveOrCopyObject (void)
 			     ptr->Line->Point1.Y + dy,
 			     ptr->Line->Point2.X + dx,
 			     ptr->Line->Point2.Y + dy, ptr->Line->Thickness);
-
-      ptr++;
-      i--;
     }
 }
 
diff --git a/src/draw.c b/src/draw.c
index 9ebcba6..4a254dd 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -774,10 +774,17 @@ DrawEMark (ElementTypePtr e, LocationType X, LocationType Y,
   if (!PCB->InvisibleObjectsOn && invisible)
     return;
 
-  if (e->PinN && mark_size > e->Pin[0].Thickness / 2)
-    mark_size = e->Pin[0].Thickness / 2;
-  if (e->PadN && mark_size > e->Pad[0].Thickness / 2)
-    mark_size = e->Pad[0].Thickness / 2;
+  if (e->Pin != NULL)
+    {
+      PinType *pin0 = e->Pin->data;
+      mark_size = MIN (mark_size, pin0->Thickness / 2);
+    }
+
+  if (e->Pad != NULL)
+    {
+      PadType *pad0 = e->Pad->data;
+      mark_size = MIN (mark_size, pad0->Thickness / 2);
+    }
 
   gui->set_color (Output.fgGC,
 		  invisible ? PCB->InvisibleMarkColor : PCB->ElementColor);
@@ -1195,7 +1202,7 @@ DrawTextLowLevel (TextTypePtr Text, int min_line_width)
 {
   LocationType x = 0;
   unsigned char *string = (unsigned char *) Text->TextString;
-  Cardinal n;
+  GList *iter;
   FontTypePtr font = &PCB->Font;
 
   while (string && *string)
@@ -1203,11 +1210,12 @@ DrawTextLowLevel (TextTypePtr Text, int min_line_width)
       /* draw lines if symbol is valid and data is present */
       if (*string <= MAX_FONTPOSITION && font->Symbol[*string].Valid)
 	{
-	  LineTypePtr line = font->Symbol[*string].Line;
-	  LineType newline;
-
-	  for (n = font->Symbol[*string].LineN; n; n--, line++)
+	  for (iter = font->Symbol[*string].Line;
+	       iter != NULL; iter = g_list_next (iter))
 	    {
+	      LineType *line = iter->data;
+	      LineType newline;
+
 	      /* create one line, scale, move, rotate and swap it */
 	      newline = *line;
 	      newline.Point1.X = (newline.Point1.X + x) * Text->Scale / 100;
diff --git a/src/drill.c b/src/drill.c
index a7a908b..46e8f80 100644
--- a/src/drill.c
+++ b/src/drill.c
@@ -90,11 +90,9 @@ InitializeDrill (DrillTypePtr drill, PinTypePtr pin, ElementTypePtr element)
   drill->ViaCount = 0;
   drill->PinCount = 0;
   drill->UnplatedCount = 0;
-  drill->ElementMax = 0;
   drill->Element = NULL;
   drill->PinN = 0;
   drill->Pin = NULL;
-  drill->PinMax = 0;
   ptr = (void *) GetDrillPinMemory (drill);
   *((PinTypeHandle) ptr) = pin;
   if (element)
@@ -166,9 +164,8 @@ GetDrillInfo (DataTypePtr top)
 		}
 	    }
 	    END_LOOP;
-	    if (AllDrills->Drill[AllDrills->DrillN - 1].DrillSize <
-		pin->DrillingHole)
-	      {
+	    if (AllDrills->Drill[AllDrills->DrillN - 1].DrillSize < pin->DrillingHole)
+	      { /* ^^ Last drill in the list, presumably sorted? */
 		Drill = GetDrillInfoDrillMemory (AllDrills);
 		InitializeDrill (Drill, pin, element);
 	      }
@@ -231,8 +228,7 @@ RoundDrillInfo (DrillInfoTypePtr d, int roundto)
 	{
 	  int ei, ej;
 
-	  d->Drill[i].ElementMax
-	    = d->Drill[i].ElementN + d->Drill[i+1].ElementN;
+	  d->Drill[i].ElementMax = d->Drill[i].ElementN + d->Drill[i+1].ElementN;
 	  if (d->Drill[i].ElementMax)
 	    {
 	      d->Drill[i].Element = (ElementTypePtr *)realloc (d->Drill[i].Element,
@@ -280,16 +276,3 @@ RoundDrillInfo (DrillInfoTypePtr d, int roundto)
 	}
     }
 }
-
-void
-FreeDrillInfo (DrillInfoTypePtr Drills)
-{
-  DRILL_LOOP (Drills);
-  {
-    free (drill->Element);
-    free (drill->Pin);
-  }
-  END_LOOP;
-  free (Drills->Drill);
-  free (Drills);
-}
diff --git a/src/find.c b/src/find.c
index b740890..eb4cac2 100644
--- a/src/find.c
+++ b/src/find.c
@@ -1935,15 +1935,14 @@ LookupLOConnectionsToArc (ArcTypePtr Arc, Cardinal LayerGroup)
   /* loop over all layers of the group */
   for (entry = 0; entry < PCB->LayerGroups.Number[LayerGroup]; entry++)
     {
-      Cardinal layer, i;
+      Cardinal layer;
+      GList *i;
 
       layer = PCB->LayerGroups.Entries[LayerGroup][entry];
 
       /* handle normal layers */
       if (layer < max_copper_layer)
         {
-          PolygonTypePtr polygon;
-
           info.layer = layer;
           /* add arcs */
           if (setjmp (info.env) == 0)
@@ -1959,12 +1958,14 @@ LookupLOConnectionsToArc (ArcTypePtr Arc, Cardinal LayerGroup)
             return true;
 
           /* now check all polygons */
-          i = 0;
-          polygon = PCB->Data->Layer[layer].Polygon;
-          for (; i < PCB->Data->Layer[layer].PolygonN; i++, polygon++)
-            if (!TEST_FLAG (TheFlag, polygon) && IsArcInPolygon (Arc, polygon)
-                && ADD_POLYGON_TO_LIST (layer, polygon))
-              return true;
+          for (i = PCB->Data->Layer[layer].Polygon;
+               i != NULL; i = g_list_next (i))
+            {
+              PolygonType *polygon = i->data;
+              if (!TEST_FLAG (TheFlag, polygon) && IsArcInPolygon (Arc, polygon)
+                  && ADD_POLYGON_TO_LIST (layer, polygon))
+                return true;
+            }
         }
       else
         {
@@ -2080,8 +2081,6 @@ LookupLOConnectionsToLine (LineTypePtr Line, Cardinal LayerGroup,
       /* handle normal layers */
       if (layer < max_copper_layer)
         {
-          PolygonTypePtr polygon;
-
           info.layer = layer;
           /* add lines */
           if (setjmp (info.env) == 0)
@@ -2098,13 +2097,16 @@ LookupLOConnectionsToLine (LineTypePtr Line, Cardinal LayerGroup,
           /* now check all polygons */
           if (PolysTo)
             {
-              Cardinal i = 0;
-              polygon = PCB->Data->Layer[layer].Polygon;
-              for (; i < PCB->Data->Layer[layer].PolygonN; i++, polygon++)
-                if (!TEST_FLAG
-                    (TheFlag, polygon) && IsLineInPolygon (Line, polygon)
-                    && ADD_POLYGON_TO_LIST (layer, polygon))
-                  return true;
+              GList *i;
+              for (i = PCB->Data->Layer[layer].Polygon;
+                   i != NULL; i = g_list_next (i))
+                {
+                  PolygonType *polygon = i->data;
+                  if (!TEST_FLAG
+                      (TheFlag, polygon) && IsLineInPolygon (Line, polygon)
+                      && ADD_POLYGON_TO_LIST (layer, polygon))
+                    return true;
+                }
             }
         }
       else
@@ -2162,7 +2164,6 @@ static bool
 LOTouchesLine (LineTypePtr Line, Cardinal LayerGroup)
 {
   Cardinal entry;
-  Cardinal i;
   struct lo_info info;
 
 
@@ -2179,7 +2180,7 @@ LOTouchesLine (LineTypePtr Line, Cardinal LayerGroup)
       /* handle normal layers */
       if (layer < max_copper_layer)
         {
-          PolygonTypePtr polygon;
+          GList *i;
 
           /* find the first line that touches coordinates */
 
@@ -2195,12 +2196,14 @@ LOTouchesLine (LineTypePtr Line, Cardinal LayerGroup)
             return (true);
 
           /* now check all polygons */
-          i = 0;
-          polygon = PCB->Data->Layer[layer].Polygon;
-          for (; i < PCB->Data->Layer[layer].PolygonN; i++, polygon++)
-            if (!TEST_FLAG (TheFlag, polygon)
-                && IsLineInPolygon (Line, polygon))
-              return (true);
+          for (i = PCB->Data->Layer[layer].Polygon;
+               i != NULL; i = g_list_next (i))
+            {
+              PolygonType *polygon = i->data;
+              if (!TEST_FLAG (TheFlag, polygon)
+                  && IsLineInPolygon (Line, polygon))
+                return (true);
+            }
         }
       else
         {
@@ -2571,23 +2574,25 @@ LookupLOConnectionsToPolygon (PolygonTypePtr Polygon, Cardinal LayerGroup)
 /* loop over all layers of the group */
   for (entry = 0; entry < PCB->LayerGroups.Number[LayerGroup]; entry++)
     {
-      Cardinal layer, i;
+      Cardinal layer;
 
       layer = PCB->LayerGroups.Entries[LayerGroup][entry];
 
       /* handle normal layers */
       if (layer < max_copper_layer)
         {
-          PolygonTypePtr polygon;
+          GList *i;
 
           /* check all polygons */
-
-          polygon = PCB->Data->Layer[layer].Polygon;
-          for (i = 0; i < PCB->Data->Layer[layer].PolygonN; i++, polygon++)
-            if (!TEST_FLAG (TheFlag, polygon)
-                && IsPolygonInPolygon (polygon, Polygon)
-                && ADD_POLYGON_TO_LIST (layer, polygon))
-              return true;
+          for (i = PCB->Data->Layer[layer].Polygon;
+               i != NULL; i = g_list_next (i))
+            {
+              PolygonType *polygon = i->data;
+              if (!TEST_FLAG (TheFlag, polygon)
+                  && IsPolygonInPolygon (polygon, Polygon)
+                  && ADD_POLYGON_TO_LIST (layer, polygon))
+                return true;
+            }
 
           info.layer = layer;
           /* check all lines */
diff --git a/src/fontmode.c b/src/fontmode.c
index eae2545..a754843 100644
--- a/src/fontmode.c
+++ b/src/fontmode.c
@@ -81,6 +81,7 @@ FontEdit (int argc, char **argv, int Ux, int Uy)
   SymbolType *symbol;
   LayerTypePtr lfont, lorig, lwidth, lgrid;
   int s, l;
+  GList *ll;
 
   if (hid_actionl ("New", "Font", 0))
     return 1;
@@ -118,25 +119,26 @@ FontEdit (int argc, char **argv, int Ux, int Uy)
       miny = 500;
       maxy = font->MaxHeight;
 
-      for (l = 0; l < symbol->LineN; l++)
+      for (ll = symbol->Line; ll != NULL; ll = g_list_next (ll))
 	{
+	  LineType *line = ll->data;
+
 	  CreateDrawnLineOnLayer (lfont,
-				  symbol->Line[l].Point1.X + ox,
-				  symbol->Line[l].Point1.Y + oy,
-				  symbol->Line[l].Point2.X + ox,
-				  symbol->Line[l].Point2.Y + oy,
-				  symbol->Line[l].Thickness,
-				  symbol->Line[l].Thickness, NoFlags ());
-	  CreateDrawnLineOnLayer (lorig, symbol->Line[l].Point1.X + ox,
-				  symbol->Line[l].Point1.Y + oy,
-				  symbol->Line[l].Point2.X + ox,
-				  symbol->Line[l].Point2.Y + oy,
-				  symbol->Line[l].Thickness,
-				  symbol->Line[l].Thickness, NoFlags ());
-	  if (maxx < symbol->Line[l].Point1.X)
-	    maxx = symbol->Line[l].Point1.X;
-	  if (maxx < symbol->Line[l].Point2.X)
-	    maxx = symbol->Line[l].Point2.X;
+				  line->Point1.X + ox,
+				  line->Point1.Y + oy,
+				  line->Point2.X + ox,
+				  line->Point2.Y + oy,
+				  line->Thickness,
+				  line->Thickness, NoFlags ());
+	  CreateDrawnLineOnLayer (lorig,
+				  line->Point1.X + ox,
+				  line->Point1.Y + oy,
+				  line->Point2.X + ox,
+				  line->Point2.Y + oy,
+				  line->Thickness,
+				  line->Thickness, NoFlags ());
+	  maxx = MAX (maxx, line->Point1.X);
+	  maxx = MAX (maxx, line->Point2.X);
 	}
       w = maxx + symbol->Delta + ox;
       CreateDrawnLineOnLayer (lwidth,
@@ -173,6 +175,7 @@ FontSave (int argc, char **argv, int Ux, int Uy)
   FontTypePtr font;
   SymbolTypePtr symbol;
   int i;
+  GList *ii;
   LayerTypePtr lfont, lwidth;
 
   font = &PCB->Font;
@@ -186,9 +189,9 @@ FontSave (int argc, char **argv, int Ux, int Uy)
       font->Symbol[i].Width = 0;
     }
 
-  for (i = 0; i < lfont->LineN; i++)
+  for (ii = lfont->Line; ii != NULL; ii = g_list_next (ii))
     {
-      LineTypePtr l = &lfont->Line[i];
+      LineType *l = ii->data;
       int x1 = l->Point1.X;
       int y1 = l->Point1.Y;
       int x2 = l->Point2.X;
@@ -214,9 +217,9 @@ FontSave (int argc, char **argv, int Ux, int Uy)
       CreateNewLineInSymbol (symbol, x1, y1, x2, y2, l->Thickness);
     }
 
-  for (i = 0; i < lwidth->LineN; i++)
+  for (ii = lwidth->Line; ii != NULL; ii = g_list_next (ii))
     {
-      LineTypePtr l = &lwidth->Line[i];
+      LineType *l = ii->data;
       int x1 = l->Point1.X;
       int y1 = l->Point1.Y;
       int ox, oy, s;
diff --git a/src/global.h b/src/global.h
index a036ee5..66bf3e6 100644
--- a/src/global.h
+++ b/src/global.h
@@ -50,6 +50,7 @@
 #include <ctype.h>
 #include <sys/types.h>
 #include <stdbool.h>
+#include <glib.h>
 
 /* Forward declarations for structures the HIDs need.  */
 typedef struct BoxType BoxType, *BoxTypePtr;
@@ -206,8 +207,8 @@ typedef struct
 
 struct AttributeListType
 {
-  int Number, Max;
-  AttributeType *List;
+  int Number;
+  GList *List;
 };
 
 /* ---------------------------------------------------------------------------
@@ -250,15 +251,13 @@ typedef struct
 struct polygon_st			/* holds information about a polygon */
 {
   ANYOBJECTFIELDS;
-  Cardinal PointN,		/* number of points in polygon */
-    PointMax;			/* max number from malloc() */
+  Cardinal PointN;		/* number of points in polygon */
   POLYAREA *Clipped;		/* the clipped region of this polygon */
   PLINE *NoHoles;		/* the polygon broken into hole-less regions */
   int NoHolesValid;		/* Is the NoHoles polygon up to date? */
-  PointTypePtr Points;		/* data */
-  Cardinal *HoleIndex;		/* Index of hole data within the Points array */
+  GList *Points;		/* data */
+  GList *HoleIndex;		/* Index of hole data within the Points array */
   Cardinal HoleIndexN;		/* number of holes in polygon */
-  Cardinal HoleIndexMax;	/* max number from malloc() */
 
 };
 
@@ -285,13 +284,11 @@ typedef struct			/* holds information about one layer */
   Cardinal LineN,		/* number of lines */
     TextN,			/* labels */
     PolygonN,			/* polygons */
-    ArcN,			/* and arcs */
-    LineMax,			/* max number from malloc() */
-    TextMax, PolygonMax, ArcMax;
-  LineTypePtr Line;		/* pointer to additional structures */
-  TextTypePtr Text;
-  PolygonTypePtr Polygon;
-  ArcTypePtr Arc;
+    ArcN;			/* and arcs */
+  GList *Line;			/* pointer to additional structures */
+  GList *Text;
+  GList *Polygon;
+  GList *Arc;
   rtree_t *line_tree, *text_tree, *polygon_tree, *arc_tree;
   bool On;			/* visible flag */
   char *Color,			/* color */
@@ -336,12 +333,14 @@ typedef struct
   /* see macro.h */
   LocationType MarkX,		/* position mark */
     MarkY;
-  Cardinal PinN,		/* number of pins, lines and arcs */
-    PinMax, PadN, PadMax, LineN, LineMax, ArcN, ArcMax;
-  PinTypePtr Pin;		/* pin description */
-  PadTypePtr Pad;		/* pad description of SMD components */
-  LineTypePtr Line;
-  ArcTypePtr Arc;
+  Cardinal PinN;		/* number of pins */
+  Cardinal PadN;		/* number of pads */
+  Cardinal LineN;		/* number of lines */
+  Cardinal ArcN;		/* number of arcs */
+  GList *Pin;			/* pin description */
+  GList *Pad;			/* pad description of SMD components */
+  GList *Line;
+  GList *Arc;
   BoxType VBox;
   AttributeListType Attributes;
 } ElementType, *ElementTypePtr, **ElementTypeHandle;
@@ -351,10 +350,9 @@ typedef struct
  */
 typedef struct			/* a single symbol */
 {
-  LineTypePtr Line;
+  GList *Line;
   bool Valid;
-  Cardinal LineN,		/* number of lines */
-    LineMax;
+  Cardinal LineN;		/* number of lines */
   BDimension Width,		/* size of cell */
     Height, Delta;		/* distance to next symbol in 0.00001'' */
 } SymbolType, *SymbolTypePtr;
@@ -371,15 +369,12 @@ typedef struct			/* complete set of symbols */
 typedef struct			/* holds all objects */
 {
   Cardinal ViaN,		/* number of vias */
-    ViaMax,			/* max number from malloc() */
     ElementN,			/* and elements */
-    ElementMax,			/* max number from malloc() */
-    RatN,			/* and rat-lines */
-    RatMax;
+    RatN;			/* and rat-lines */
   int LayerN;			/* number of layers in this board */
-  PinTypePtr Via;		/* pointer to object data */
-  ElementTypePtr Element;
-  RatTypePtr Rat;
+  GList *Via;			/* pointer to object data */
+  GList *Element;
+  GList *Rat;
   rtree_t *via_tree, *element_tree, *pin_tree, *pad_tree, *name_tree[3],	/* for element names */
    *rat_tree;
   struct PCBType *pcb;
@@ -390,21 +385,18 @@ typedef struct			/* holds drill information */
 {
   BDimension DrillSize;		/* this drill's diameter */
   Cardinal ElementN,		/* the number of elements using this drill size */
-    ElementMax,			/* max number of elements from malloc() */
     PinCount,			/* number of pins drilled this size */
     ViaCount,			/* number of vias drilled this size */
     UnplatedCount,		/* number of these holes that are unplated */
-    PinN,			/* number of drill coordinates in the list */
-    PinMax;			/* max number of coordinates from malloc() */
-  PinTypePtr *Pin;		/* coordinates to drill */
-  ElementTypePtr *Element;	/* a pointer to an array of element pointers */
+    PinN;			/* number of drill coordinates in the list */
+  GList *Pin;		/* coordinates to drill */
+  GList *Element;		/* a pointer to an array of element pointers */
 } DrillType, *DrillTypePtr;
 
 typedef struct			/* holds a range of Drill Infos */
 {
-  Cardinal DrillN,		/* number of drill sizes */
-    DrillMax;			/* max number from malloc() */
-  DrillTypePtr Drill;		/* plated holes */
+  Cardinal DrillN;		/* number of drill sizes */
+  GList *Drill;			/* plated holes */
 } DrillInfoType, *DrillInfoTypePtr;
 
 typedef struct
@@ -442,9 +434,8 @@ typedef struct
   char *Name,			/* name of the menu entry */
    *directory,			/* Directory name library elements are from */
    *Style;			/* routing style */
-  Cardinal EntryN,		/* number of objects */
-    EntryMax;			/* number of reserved memory locations */
-  LibraryEntryTypePtr Entry;	/* the entries */
+  Cardinal EntryN;		/* number of objects */
+  GList *Entry;			/* the entries */
   char flag;			/* used by the netlist window to enable/disable nets */
   char internal;		/* if set, this is an internal-only entry, not
 				   part of the global netlist. */
@@ -453,8 +444,7 @@ typedef struct
 typedef struct
 {
   Cardinal MenuN;               /* number of objects */
-  Cardinal MenuMax;             /* number of reserved memory locations */
-  LibraryMenuTypePtr Menu;      /* the entries */
+  GList *Menu;                  /* the entries */
 } LibraryType, *LibraryTypePtr;
 
 
@@ -557,9 +547,8 @@ typedef struct			/* currently attached object */
   void *Ptr1,			/* three pointers to data, see */
    *Ptr2,			/* search.c */
    *Ptr3;
-  Cardinal RubberbandN,		/* number of lines in array */
-    RubberbandMax;
-  RubberbandTypePtr Rubberband;
+  Cardinal RubberbandN;		/* number of lines in array */
+  GList *Rubberband;
 } AttachedObjectType, *AttachedObjectTypePtr;
 
 enum crosshair_shape
@@ -720,38 +709,33 @@ typedef struct			/* holds a connection */
 
 typedef struct			/* holds a net of connections */
 {
-  Cardinal ConnectionN,		/* the number of connections contained */
-    ConnectionMax;		/* max connections from malloc */
-  ConnectionTypePtr Connection;
+  Cardinal ConnectionN;		/* the number of connections contained */
+  GList *Connection;
   RouteStyleTypePtr Style;
 } NetType, *NetTypePtr;
 
 typedef struct			/* holds a list of nets */
 {
-  Cardinal NetN,		/* the number of subnets contained */
-    NetMax;			/* max subnets from malloc */
-  NetTypePtr Net;
+  Cardinal NetN;		/* the number of subnets contained */
+  GList *Net;
 } NetListType, *NetListTypePtr;
 
 typedef struct			/* holds a list of net lists */
 {
-  Cardinal NetListN,		/* the number of net lists contained */
-    NetListMax;			/* max net lists from malloc */
-  NetListTypePtr NetList;
+  Cardinal NetListN;		/* the number of net lists contained */
+  GList *NetList;
 } NetListListType, *NetListListTypePtr;
 
 typedef struct			/* holds a generic list of pointers */
 {
-  Cardinal PtrN,		/* the number of pointers contained */
-    PtrMax;			/* max subnets from malloc */
-  void **Ptr;
+  Cardinal PtrN;		/* the number of pointers contained */
+  GList *Ptr;
 } PointerListType, *PointerListTypePtr;
 
 typedef struct
 {
-  Cardinal BoxN,		/* the number of boxes contained */
-    BoxMax;			/* max boxes from malloc */
-  BoxTypePtr Box;
+  Cardinal BoxN;		/* the number of boxes contained */
+  GList *Box;
 
 } BoxListType, *BoxListTypePtr;
 
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index f5e2717..e8b4a17 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -828,6 +828,7 @@ static void
 ghid_attributes_revert ()
 {
   int i;
+  GList *iter;
 
   ghid_attributes_need_rows (attributes_list->Number);
 
@@ -841,11 +842,14 @@ ghid_attributes_revert ()
     }
 
   /* Fill in values */
-  for (i=0; i<attributes_list->Number; i++)
+  for (iter = attributes_list->List, i = 0;
+       iter != NULL; iter = g_list_next (iter), i++)
     {
+      AttributeType *attr = iter->data;
+
       /* create row [i] */
-      gtk_entry_set_text (GTK_ENTRY (attr_row[i].w_name), attributes_list->List[i].name);
-      gtk_entry_set_text (GTK_ENTRY (attr_row[i].w_value), attributes_list->List[i].value);
+      gtk_entry_set_text (GTK_ENTRY (attr_row[i].w_name), attr->name);
+      gtk_entry_set_text (GTK_ENTRY (attr_row[i].w_value), attr->value);
 #if 0
 #endif
     }
@@ -911,28 +915,14 @@ ghid_attributes (char *owner, AttributeListType *attrs)
       if (response == GTK_RESPONSE_OK)
 	{
 	  int i;
+	  FreeAttributeListMemory (attributes_list);
+
 	  /* Copy the values back */
-	  for (i=0; i<attributes_list->Number; i++)
-	    {
-	      if (attributes_list->List[i].name)
-		free (attributes_list->List[i].name);
-	      if (attributes_list->List[i].value)
-		free (attributes_list->List[i].value);
-	    }
-	  if (attributes_list->Max < attr_num_rows)
-	    {
-	      int sz = attr_num_rows * sizeof (AttributeType);
-	      if (attributes_list->List == NULL)
-		attributes_list->List = (AttributeType *) malloc (sz);
-	      else
-		attributes_list->List = (AttributeType *) realloc (attributes_list->List, sz);
-	      attributes_list->Max = attr_num_rows;
-	    }
-	  for (i=0; i<attr_num_rows; i++)
+	  for (i = 0; i < attr_num_rows; i++)
 	    {
-	      attributes_list->List[i].name = strdup (gtk_entry_get_text (GTK_ENTRY (attr_row[i].w_name)));
-	      attributes_list->List[i].value = strdup (gtk_entry_get_text (GTK_ENTRY (attr_row[i].w_value)));
-	      attributes_list->Number = attr_num_rows;
+	      AttributeType *attr = GetAttributeMemory (attributes_list);
+	      attr->name = strdup (gtk_entry_get_text (GTK_ENTRY (attr_row[i].w_name)));
+	      attr->value = strdup (gtk_entry_get_text (GTK_ENTRY (attr_row[i].w_value)));
 	    }
 
 	  break;
diff --git a/src/hid/gtk/gui-netlist-window.c b/src/hid/gtk/gui-netlist-window.c
index b60b8ba..c638a51 100644
--- a/src/hid/gtk/gui-netlist-window.c
+++ b/src/hid/gtk/gui-netlist-window.c
@@ -509,9 +509,8 @@ netlist_disable_all_cb (GtkToggleButton * button, gpointer data)
 static void
 netlist_select_cb (GtkWidget * widget, gpointer data)
 {
-  LibraryEntryType *entry;
   ConnectionType conn;
-  gint i;
+  GList *iter;
   gboolean select_flag = GPOINTER_TO_INT (data);
 
   if (!selected_net)
@@ -522,9 +521,12 @@ netlist_select_cb (GtkWidget * widget, gpointer data)
   InitConnectionLookup ();
   ResetConnections (true);
 
-  for (i = selected_net->EntryN, entry = selected_net->Entry; i; i--, entry++)
+  for (iter = selected_net->Entry; iter != NULL; iter = g_list_next (iter)) {
+    LibraryEntryType *entry = iter->data;
+
     if (SeekPad (entry, &conn, false))
       RatFindHook (conn.type, conn.ptr1, conn.ptr2, conn.ptr2, true, true);
+  }
 
   SelectConnection (select_flag);
   ResetConnections (false);
@@ -585,7 +587,7 @@ node_get_node_from_name (gchar * node_name, LibraryMenuType ** node_net)
   GtkTreeIter iter;
   LibraryMenuType *net;
   LibraryEntryType *node;
-  gint j;
+  GList *j;
 
   if (!node_name)
     return NULL;
@@ -609,13 +611,16 @@ node_get_node_from_name (gchar * node_name, LibraryMenuType ** node_net)
 
 	/* Look for the node name in this net.
 	 */
-	for (j = net->EntryN, node = net->Entry; j; j--, node++)
-	  if (node->ListEntry && !strcmp (node_name, node->ListEntry))
+	for (j = net->Entry; j != NULL; j = g_list_next (j)) {
+          LibraryEntryType *entry = j->data;
+
+	  if (entry->ListEntry && !strcmp (node_name, entry->ListEntry))
 	    {
 	      if (node_net)
 		*node_net = net;
 	      return node;
 	    }
+        }
       }
     while (gtk_tree_model_iter_next (net_model, &iter));
 
@@ -819,9 +824,8 @@ hunt_named_node (GtkTreeModel *model, GtkTreePath *path,
 {
   struct ggnfnn_task *task = (struct ggnfnn_task *)data;
   LibraryMenuType *net;
-  LibraryEntryType *node;
   gchar *str;
-  gint j;
+  GList *j;
   gboolean is_disabled;
 
   /* We only want to inspect leaf nodes in the tree */
@@ -838,13 +842,16 @@ hunt_named_node (GtkTreeModel *model, GtkTreePath *path,
     return FALSE;
 
   /* Look for the node name in this net. */
-  for (j = net->EntryN, node = net->Entry; j; j--, node++)
-    if (node->ListEntry && !strcmp (task->node_name, node->ListEntry))
+  for (j = net->Entry; j != NULL; j = g_list_next (j)) {
+    LibraryEntryType *entry = j->data;
+
+    if (entry->ListEntry && !strcmp (task->node_name, entry->ListEntry))
       {
         task->found_net = net;
         task->iter = *iter;
         return TRUE;
       }
+  }
 
   return FALSE;
 }
@@ -974,7 +981,7 @@ ghid_netlist_window_update (gboolean init_nodes)
 
   /* XXX Check if the select callback does this for us */
   if (init_nodes)
-    node_model_update ((&PCB->NetlistLib)->Menu);
+    node_model_update ((LibraryMenuType *)PCB->NetlistLib.Menu->data);
 }
 
 static gint
diff --git a/src/hid/gtk/gui-pinout-preview.c b/src/hid/gtk/gui-pinout-preview.c
index 2a205fa..d5a512f 100644
--- a/src/hid/gtk/gui-pinout-preview.c
+++ b/src/hid/gtk/gui-pinout-preview.c
@@ -76,6 +76,8 @@ static void
 pinout_set_data (GhidPinoutPreview * pinout, ElementType * element)
 {
   gint tx, ty, x_min = 0, y_min = 0;
+  PinType *pin0, *pin1;
+  PadType *pad0, *pad1;
 
   if (element == NULL)
     {
@@ -92,10 +94,14 @@ pinout_set_data (GhidPinoutPreview * pinout, ElementType * element)
    * set all package lines/arcs to zero width
    */
   CopyElementLowLevel (NULL, &pinout->element, element, FALSE, 0, 0);
+
+  pin0 = pinout->element.Pin->data;
+  pin1 = g_list_next (pinout->element.Pin)->data;
+
   PIN_LOOP (&pinout->element);
   {
-    tx = abs (pinout->element.Pin[0].X - pin->X);
-    ty = abs (pinout->element.Pin[0].Y - pin->Y);
+    tx = abs (pin0->X - pin->X);
+    ty = abs (pin0->Y - pin->Y);
     if (x_min == 0 || (tx != 0 && tx < x_min))
       x_min = tx;
     if (y_min == 0 || (ty != 0 && ty < y_min))
@@ -104,10 +110,13 @@ pinout_set_data (GhidPinoutPreview * pinout, ElementType * element)
   }
   END_LOOP;
 
+  pad0 = pinout->element.Pad->data;
+  pad1 = g_list_next (pinout->element.Pad)->data;
+
   PAD_LOOP (&pinout->element);
   {
-    tx = abs (pinout->element.Pad[0].Point1.X - pad->Point1.X);
-    ty = abs (pinout->element.Pad[0].Point1.Y - pad->Point1.Y);
+    tx = abs (pad0->Point1.X - pad->Point1.X);
+    ty = abs (pad0->Point1.Y - pad->Point1.Y);
     if (x_min == 0 || (tx != 0 && tx < x_min))
       x_min = tx;
     if (y_min == 0 || (ty != 0 && ty < y_min))
diff --git a/src/hid/nelma/nelma.c b/src/hid/nelma/nelma.c
index 9dbf24c..c552b9a 100644
--- a/src/hid/nelma/nelma.c
+++ b/src/hid/nelma/nelma.c
@@ -296,28 +296,26 @@ nelma_write_materials(FILE * out)
 static void 
 nelma_write_nets(FILE * out)
 {
-	LibraryType     netlist;
 	LibraryMenuTypePtr net;
 	LibraryEntryTypePtr pin;
+	GList *n, *m;
 
-	int             n, m, i, idx;
+	int             i, idx;
 
 	const char     *ext;
 
-	netlist = PCB->NetlistLib;
-
 	fprintf(out, "\n/* **** Nets **** */\n\n");
 
-	for (n = 0; n < netlist.MenuN; n++) {
-		net = &netlist.Menu[n];
+	for (n = PCB->NetlistLib.Menu; n != NULL; n = g_list_next (n)) {
+		net = n->data;
 
 		/* Weird, but correct */
 		fprintf(out, "net %s {\n", &net->Name[2]);
 
 		fprintf(out, "\tobjects = {\n");
 
-		for (m = 0; m < net->EntryN; m++) {
-			pin = &net->Entry[m];
+		for (m = net->Entry; m != NULL; m = g_list_next (m)) {
+			pin = m->data;
 
 			/* pin_name_to_xy(pin, &x, &y); */
 
@@ -349,7 +347,7 @@ nelma_write_layer(FILE * out, int z, int h,
 	LibraryMenuTypePtr net;
 	LibraryEntryTypePtr pin;
 
-	int             n, m;
+	GList *n, *m;
 
 	fprintf(out, "layer %s {\n", name);
 	fprintf(out, "\theight = %d\n", h);
@@ -360,11 +358,11 @@ nelma_write_layer(FILE * out, int z, int h,
 		fprintf(out, "\tobjects = {\n");
 		netlist = PCB->NetlistLib;
 
-		for (n = 0; n < netlist.MenuN; n++) {
-			net = &netlist.Menu[n];
+		for (n = PCB->NetlistLib.Menu; n != NULL; n = g_list_next (n)) {
+			net = n->data;
 
-			for (m = 0; m < net->EntryN; m++) {
-				pin = &net->Entry[m];
+			for (m = net->Entry; m != NULL; m = g_list_next (m)) {
+				pin = m->data;
 
 				if (m != 0 || n != 0)
 					fprintf(out, ",\n");
@@ -469,17 +467,17 @@ nelma_write_objects(FILE * out)
 	LibraryMenuTypePtr net;
 	LibraryEntryTypePtr pin;
 
-	int             n, m;
+	GList *n, *m;
 
 	netlist = PCB->NetlistLib;
 
 	fprintf(out, "\n/* **** Objects **** */\n\n");
 
-	for (n = 0; n < netlist.MenuN; n++) {
-		net = &netlist.Menu[n];
+	for (n = PCB->NetlistLib.Menu; n != NULL; n = g_list_next (n)) {
+		net = n->data;
 
-		for (m = 0; m < net->EntryN; m++) {
-			pin = &net->Entry[m];
+		for (m = net->Entry; m != NULL; m = g_list_next (m)) {
+			pin = m->data;
 
 			nelma_write_object(out, pin);
 		}
diff --git a/src/intersect.c b/src/intersect.c
index e7612e9..104ca29 100644
--- a/src/intersect.c
+++ b/src/intersect.c
@@ -90,18 +90,20 @@ LocationList;
  * Create a sorted list of unique y coords from a BoxList.
  */
 static LocationList
-createSortedYList (BoxListTypePtr boxlist)
+createSortedYList (BoxListType *boxlist)
 {
   LocationList yCoords;
   LocationType last;
   int i, n;
+  GList *ii;
   /* create sorted list of Y coordinates */
   yCoords.size = 2 * boxlist->BoxN;
   yCoords.p = (LocationType *)calloc (yCoords.size, sizeof (*yCoords.p));
-  for (i = 0; i < boxlist->BoxN; i++)
+  for (ii = boxlist->Box, i = 0; ii != NULL; ii = g_list_next (ii), i++)
     {
-      yCoords.p[2 * i] = boxlist->Box[i].Y1;
-      yCoords.p[2 * i + 1] = boxlist->Box[i].Y2;
+      BoxType *box = ii->data;
+      yCoords.p[2 * i + 0] = box->Y1;
+      yCoords.p[2 * i + 1] = box->Y2;
     }
   qsort (yCoords.p, yCoords.size, sizeof (*yCoords.p), comparepos);
   /* count uniq y coords */
@@ -202,12 +204,15 @@ deleteSegment (SegmentTree * st, int n, LocationType Y1, LocationType Y2)
 double
 ComputeIntersectionArea (BoxListTypePtr boxlist)
 {
-  Cardinal i;
+  GList *i;
   double area = 0.0;
   /* first get the aggregate area. */
-  for (i = 0; i < boxlist->BoxN; i++)
-    area += (double) (boxlist->Box[i].X2 - boxlist->Box[i].X1) *
-      (double) (boxlist->Box[i].Y2 - boxlist->Box[i].Y1);
+  for (i = boxlist->Box; i != NULL; i = g_list_next (i))
+    {
+      BoxType *box = i->data;
+      area += (double) (box->X2 - box->X1) *
+              (double) (box->Y2 - box->Y1);
+    }
   /* intersection area is aggregate - union. */
   return area * 0.0001 - ComputeUnionArea (boxlist);
 }
@@ -221,6 +226,7 @@ ComputeUnionArea (BoxListTypePtr boxlist)
 {
   BoxTypePtr *rectLeft, *rectRight;
   Cardinal i, j;
+  GList *ii;
   LocationList yCoords;
   SegmentTree segtree;
   LocationType lastX;
@@ -236,11 +242,12 @@ ComputeUnionArea (BoxListTypePtr boxlist)
   /* create sorted list of left and right X coordinates of rectangles */
   rectLeft = (BoxTypePtr *)calloc (boxlist->BoxN, sizeof (*rectLeft));
   rectRight = (BoxTypePtr *)calloc (boxlist->BoxN, sizeof (*rectRight));
-  for (i = 0; i < boxlist->BoxN; i++)
+  for (ii = boxlist->Box, i = 0; ii != NULL; ii = g_list_next (ii), i++)
     {
-      assert (boxlist->Box[i].X1 <= boxlist->Box[i].X2);
-      assert (boxlist->Box[i].Y1 <= boxlist->Box[i].Y2);
-      rectLeft[i] = rectRight[i] = &boxlist->Box[i];
+      BoxType *box = ii->data;
+      assert (boxlist->Box[i].X1 <= box->X2);
+      assert (boxlist->Box[i].Y1 <= box->Y2);
+      rectLeft[i] = rectRight[i] = box;
     }
   qsort (rectLeft, boxlist->BoxN, sizeof (*rectLeft), compareleft);
   qsort (rectRight, boxlist->BoxN, sizeof (*rectRight), compareright);
diff --git a/src/macro.h b/src/macro.h
index 1fb6584..b27d891 100644
--- a/src/macro.h
+++ b/src/macro.h
@@ -14,7 +14,7 @@
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
  *
- *  You should have received a copy of the GNU General Public License
+ *  You should have received a __copy of the GNU General Public License
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
@@ -171,109 +171,129 @@ extern int mem_any_set (unsigned char *, int);
  * all data is relativ to an objects name 'top' which can be either
  * PCB or PasteBuffer
  */
-#define END_LOOP  }} while (0)
-
-#define STYLE_LOOP(top)  do {		\
-	Cardinal	n;			\
-	RouteStyleTypePtr	style;			\
-	for (n = 0; n < NUM_STYLES; n++)	\
-	{					\
-		style = &(top)->RouteStyle[n]
-
-#define	VIA_LOOP(top)	do { 		\
-	Cardinal	n, sn;			\
-	PinTypePtr	via;			\
-        for (sn = (top)->ViaN, n = 0; (top)->ViaN > 0 && n < (top)->ViaN ; \
-		n += 1 + (top)->ViaN - sn, sn = (top)->ViaN)   \
-	{					\
-		via = &(top)->Via[n]
-
-#define DRILL_LOOP(top) do             {               \
-        Cardinal        n;                                      \
-        DrillTypePtr    drill;                                  \
-        for (n = 0; (top)->DrillN > 0 && n < (top)->DrillN; n++)                        \
-        {                                                       \
-                drill = &(top)->Drill[n]
-
-#define NETLIST_LOOP(top) do   {                         \
-        Cardinal        n;                                      \
-        NetListTypePtr   netlist;                               \
-        for (n = (top)->NetListN-1; n != -1; n--)               \
-        {                                                       \
-                netlist = &(top)->NetList[n]
-
-#define NET_LOOP(top) do   {                             \
-        Cardinal        n;                                      \
-        NetTypePtr   net;                                       \
-        for (n = (top)->NetN-1; n != -1; n--)                   \
-        {                                                       \
-                net = &(top)->Net[n]
-
-#define CONNECTION_LOOP(net) do {                         \
-        Cardinal        n;                                      \
-        ConnectionTypePtr       connection;                     \
-        for (n = (net)->ConnectionN-1; n != -1; n--)            \
-        {                                                       \
-                connection = & (net)->Connection[n]
-
-#define	ELEMENT_LOOP(top) do	{ 		\
-	Cardinal 		n;			\
-	ElementTypePtr	element;			\
-	for (n = (top)->ElementN-1; n != -1; n--)	\
-	{						\
-		element = &(top)->Element[n]
-
-#define RAT_LOOP(top) do	{			\
-	Cardinal	n;				\
-	RatTypePtr	line;				\
-	for (n = (top)->RatN-1; n != -1; n--)		\
-	{						\
-		line = &(top)->Rat[n]
-
-
-#define	ELEMENTTEXT_LOOP(element) do { 	\
-	Cardinal	n;				\
-	TextTypePtr	text;				\
-	for (n = MAX_ELEMENTNAMES-1; n != -1; n--)	\
-	{						\
-		text = &(element)->Name[n]
-
-#define	ELEMENTNAME_LOOP(element) do	{ 		\
+#define END_LOOP  }                                                 \
+    g_list_free (__copy);                                           \
+  } while (0)
+
+#define STYLE_LOOP(top)  do {                                       \
+        GList *__copy = NULL; /* DUMMY */                           \
+        Cardinal n;                                                 \
+        RouteStyleTypePtr style;                                    \
+        for (n = 0; n < NUM_STYLES; n++)                            \
+        {                                                           \
+                style = &(top)->RouteStyle[n]
+
+#define VIA_LOOP(top) do {                                          \
+  GList *__iter;                                                    \
+  GList *__copy = g_list_copy ((top)->Via);                         \
+  Cardinal n;                                                       \
+  for (__iter = __copy, n = 0; __iter != NULL;                      \
+       __iter = g_list_next (__iter), n++) {                        \
+    PinType *via = __iter->data;
+
+#define DRILL_LOOP(top) do {                                        \
+  GList *__iter;                                                    \
+  GList *__copy = g_list_copy ((top)->Drill);                       \
+  Cardinal n;                                                       \
+  for (__iter = __copy, n = 0; __iter != NULL;                      \
+       __iter = g_list_next (__iter), n++) {                        \
+    DrillType *drill = __iter->data;
+
+#define NETLIST_LOOP(top) do {                                      \
+  GList *__iter;                                                    \
+  GList *__copy = g_list_reverse (g_list_copy ((top)->NetList));    \
+  Cardinal n;                                                       \
+  for (__iter = __copy, n = (top)->NetListN - 1; __iter != NULL;    \
+       __iter = g_list_next (__iter), n--) {                        \
+    NetListType *netlist = __iter->data;
+
+#define NET_LOOP(top) do {                                          \
+  GList *__iter;                                                    \
+  GList *__copy = g_list_reverse (g_list_copy ((top)->Net));        \
+  Cardinal n;                                                       \
+  for (__iter = __copy, n = (top)->NetN - 1; __iter != NULL;        \
+       __iter = g_list_next (__iter), n--) {                        \
+    NetType *net = __iter->data;
+
+#define CONNECTION_LOOP(net) do {                                   \
+  GList *__iter;                                                    \
+  GList *__copy = g_list_reverse (g_list_copy ((net)->Connection)); \
+  Cardinal n;                                                       \
+  for (__iter = __copy, n = (net)->ConnectionN - 1; __iter != NULL; \
+       __iter = g_list_next (__iter), n--) {                        \
+    ConnectionType *connection = __iter->data;
+
+#define ELEMENT_LOOP(top) do {                                      \
+  GList *__iter;                                                    \
+  GList *__copy = g_list_reverse (g_list_copy ((top)->Element));    \
+  Cardinal n;                                                       \
+  for (__iter = __copy, n = (top)->ElementN - 1; __iter != NULL;    \
+       __iter = g_list_next (__iter), n--) {                        \
+    ElementType *element = __iter->data;
+
+#define RAT_LOOP(top) do {                                          \
+  GList *__iter;                                                    \
+  GList *__copy = g_list_reverse (g_list_copy ((top)->Rat));        \
+  Cardinal n;                                                       \
+  for (__iter = __copy, n = (top)->RatN - 1; __iter != NULL;        \
+       __iter = g_list_next (__iter), n--) {                        \
+    RatType *line = __iter->data;
+
+#define	ELEMENTTEXT_LOOP(element) do {                              \
+        Cardinal n;                                                 \
+        GList *__copy = NULL; /* DUMMY */                           \
+        TextTypePtr text;                                           \
+        for (n = MAX_ELEMENTNAMES-1; n != -1; n--)                  \
+        {                                                           \
+                text = &(element)->Name[n]
+
+#define	ELEMENTNAME_LOOP(element) do	{ 			\
+	GList *__copy = NULL; /* DUMMY */				\
 	Cardinal	n;					\
 	char		*textstring;				\
 	for (n = MAX_ELEMENTNAMES-1; n != -1; n--)		\
 	{							\
 		textstring = (element)->Name[n].TextString
 
-#define	PIN_LOOP(element)	do { 		\
-	Cardinal	n, sn;				\
-	PinTypePtr	pin;				\
-        for (sn = (element)->PinN, n = 0; (element)->PinN > 0 && n < (element)->PinN ; \
-		n += 1 + (element)->PinN - sn, sn = (element)->PinN)   \
-	{						\
-		pin = &(element)->Pin[n]
-
-#define	PAD_LOOP(element)	do { 		\
-	Cardinal	n, sn;				\
-	PadTypePtr	pad;				\
-        for (sn = (element)->PadN, n = 0; (element)->PadN > 0 && n < (element)->PadN ; \
-		 sn == (element)->PadN ? n++ : 0)   \
-	{						\
-		pad = &(element)->Pad[n]
-
-#define	ARC_LOOP(element)	do { 		\
-	Cardinal	n;				\
-	ArcTypePtr	arc;				\
-	for (n = (element)->ArcN-1; n != -1; n--)	\
-	{						\
-		arc = &(element)->Arc[n]
-
-#define	ELEMENTLINE_LOOP(element)	do { 	\
-	Cardinal	n;				\
-	LineTypePtr	line;				\
-	for (n = (element)->LineN-1; n != -1; n--)	\
-	{						\
-		line = &(element)->Line[n]
+#define PIN_LOOP(element) do {                                      \
+  GList *__iter;                                                    \
+  GList *__copy = g_list_copy ((element)->Pin);                     \
+  Cardinal n;                                                       \
+  for (__iter = __copy, n = 0; __iter != NULL;                      \
+       __iter = g_list_next (__iter), n++) {                        \
+    PinType *pin = __iter->data;
+
+#define PAD_LOOP(element) do {                                      \
+  GList *__iter;                                                    \
+  GList *__copy = g_list_copy ((element)->Pad);                     \
+  Cardinal n;                                                       \
+  for (__iter = __copy, n = 0; __iter != NULL;                      \
+       __iter = g_list_next (__iter), n++) {                        \
+    PadType *pad = __iter->data;
+
+#define ARC_LOOP(element) do {                                      \
+  GList *__iter;                                                    \
+  GList *__copy = g_list_reverse (g_list_copy ((element)->Arc));    \
+  Cardinal n;                                                       \
+  for (__iter = __copy, n = (element)->ArcN - 1; __iter != NULL;    \
+       __iter = g_list_next (__iter), n--) {                        \
+    ArcType *arc = __iter->data;
+
+#define ELEMENTLINE_LOOP(element) do {                              \
+  GList *__iter;                                                    \
+  GList *__copy = g_list_reverse (g_list_copy ((element)->Line));   \
+  Cardinal n;                                                       \
+  for (__iter = __copy, n = (element)->LineN - 1; __iter != NULL;   \
+       __iter = g_list_next (__iter), n--) {                        \
+    LineType *line = __iter->data;
+
+#define ELEMENTARG(element) do {                                    \
+  GList *__iter;                                                    \
+  GList *__copy = g_list_reverse (g_list_copy ((element)->Arc));    \
+  Cardinal n;                                                       \
+  for (__iter = __copy, n = (element)->ArcN - 1; __iter != NULL;    \
+       __iter = g_list_next (__iter), n--) {                        \
+    ArcType *line = __iter->data;
 
 #define	ELEMENTARC_LOOP(element)	do { 	\
 	Cardinal	n;				\
@@ -282,26 +302,29 @@ extern int mem_any_set (unsigned char *, int);
 	{						\
 		arc = &(element)->Arc[n]
 
-#define	LINE_LOOP(layer) do {			\
-	Cardinal		n;			\
-	LineTypePtr		line;			\
-	for (n = (layer)->LineN-1; n != -1; n--)	\
-	{						\
-		line = &(layer)->Line[n]
-
-#define	TEXT_LOOP(layer) do {			\
-	Cardinal		n;			\
-	TextTypePtr		text;			\
-	for (n = (layer)->TextN-1; n != -1; n--)	\
-	{						\
-		text = &(layer)->Text[n]
-
-#define	POLYGON_LOOP(layer) do {			\
-	Cardinal		n;			\
-	PolygonTypePtr	polygon;			\
-	for (n = (layer)->PolygonN-1; n != -1; n--)	\
-	{						\
-		polygon = &(layer)->Polygon[n]
+#define LINE_LOOP(layer) do {                                       \
+  GList *__iter;                                                    \
+  GList *__copy = g_list_reverse (g_list_copy ((layer)->Line));     \
+  Cardinal n;                                                       \
+  for (__iter = __copy, n = (layer)->LineN - 1; __iter != NULL;     \
+       __iter = g_list_next (__iter), n--) {                        \
+    LineType *line = __iter->data;
+
+#define TEXT_LOOP(layer) do {                                       \
+  GList *__iter;                                                    \
+  GList *__copy = g_list_reverse (g_list_copy ((layer)->Text));     \
+  Cardinal n;                                                       \
+  for (__iter = __copy, n = (layer)->LineN - 1; __iter != NULL;     \
+       __iter = g_list_next (__iter), n--) {                        \
+    TextType *text = __iter->data;
+
+#define POLYGON_LOOP(layer) do {                                    \
+  GList *__iter;                                                    \
+  GList *__copy = g_list_reverse (g_list_copy ((layer)->Polygon));  \
+  Cardinal n;                                                       \
+  for (__iter = __copy, n = (layer)->PolygonN - 1; __iter != NULL;  \
+       __iter = g_list_next (__iter), n--) {                        \
+    PolygonType *polygon = __iter->data;
 
 #define	POLYGONPOINT_LOOP(polygon) do	{	\
 	Cardinal			n;		\
@@ -414,7 +437,7 @@ extern int mem_any_set (unsigned char *, int);
 	LayerTypePtr	layer = (board)->Data->Layer;		\
 	for (l = 0; l < max_copper_layer + 2; l++, layer++)	\
 	{ \
-                TEXT_LOOP(layer);                                      \
+                TEXT_LOOP(layer);                                   \
                   if (TEXT_IS_VISIBLE((board), layer, text))
 
 #define	VISIBLEPOLYGON_LOOP(top) do	{	\
@@ -425,42 +448,47 @@ extern int mem_any_set (unsigned char *, int);
 		if (layer->On)				\
 			POLYGON_LOOP(layer)
 
-#define POINTER_LOOP(top) do	{	\
-	Cardinal	n;			\
-	void	**ptr;				\
-	for (n = (top)->PtrN-1; n != -1; n--)	\
-	{					\
-		ptr = &(top)->Ptr[n]
-
-#define MENU_LOOP(top)	do {	\
-	Cardinal	l;			\
-	LibraryMenuTypePtr menu;		\
-	for (l = (top)->MenuN-1; l != -1; l--)	\
-	{					\
-		menu = &(top)->Menu[l]
-
-#define ENTRY_LOOP(top) do	{	\
-	Cardinal	n;			\
-	LibraryEntryTypePtr entry;		\
-	for (n = (top)->EntryN-1; n != -1; n--)	\
-	{					\
-		entry = &(top)->Entry[n]
-
-#define GROUP_LOOP(data, group) do { 	\
-	Cardinal entry; \
-        for (entry = 0; entry < ((PCBTypePtr)(data->pcb))->LayerGroups.Number[(group)]; entry++) \
-        { \
-		LayerTypePtr layer;		\
-		Cardinal number; 		\
-		number = ((PCBTypePtr)(data->pcb))->LayerGroups.Entries[(group)][entry]; \
-		if (number >= max_copper_layer)	\
-		  continue;			\
-		layer = &data->Layer[number];
-
-#define LAYER_LOOP(data, ml) do { \
-        Cardinal n; \
-	for (n = 0; n < ml; n++) \
-	{ \
-	   LayerTypePtr layer = (&data->Layer[(n)]);
+#define POINTER_LOOP(top) do {                                      \
+  GList *__iter;                                                    \
+  GList *__copy = g_list_reverse (g_list_copy ((top)->Ptr));        \
+  Cardinal n;                                                       \
+  for (__iter = __copy, n = (top)->PtrN - 1; __iter != NULL;        \
+       __iter = g_list_next (__iter), n--) {                        \
+    void **ptr = &__iter->data;
+
+#define MENU_LOOP(top) do {                                         \
+  GList *__iter;                                                    \
+  GList *__copy = g_list_reverse (g_list_copy ((top)->Menu));       \
+  Cardinal n;                                                       \
+  for (__iter = __copy, n = (top)->MenuN - 1; __iter != NULL;       \
+       __iter = g_list_next (__iter), n--) {                        \
+    LibraryMenuType *menu = __iter->data;
+
+#define ENTRY_LOOP(top) do {                                        \
+  GList *__iter;                                                    \
+  GList *__copy = g_list_reverse (g_list_copy ((top)->Entry));      \
+  Cardinal n;                                                       \
+  for (__iter = __copy, n = (top)->EntryN - 1; __iter != NULL;      \
+       __iter = g_list_next (__iter), n--) {                        \
+    LibraryEntryType *entry = __iter->data;
+
+#define GROUP_LOOP(data, group) do {                                \
+  GList *__copy = NULL; /* DUMMY */                                 \
+  Cardinal entry; \
+  for (entry = 0; entry < ((PCBTypePtr)(data->pcb))->LayerGroups.Number[(group)]; entry++) \
+  {                                                                 \
+    LayerTypePtr layer;                                             \
+    Cardinal number;                                                \
+    number = ((PCBTypePtr)(data->pcb))->LayerGroups.Entries[(group)][entry]; \
+    if (number >= max_copper_layer)                                 \
+      continue;                                                     \
+    layer = &data->Layer[number];
+
+#define LAYER_LOOP(data, ml) do {                                   \
+        Cardinal n;                                                 \
+        GList *__copy = NULL; /* DUMMY */                           \
+        for (n = 0; n < ml; n++)                                    \
+        {                                                           \
+           LayerTypePtr layer = (&data->Layer[(n)]);
 
 #endif
diff --git a/src/misc.c b/src/misc.c
index 0e25089..cbbb172 100644
--- a/src/misc.c
+++ b/src/misc.c
@@ -441,7 +441,7 @@ SetTextBoundingBox (FontTypePtr FontPtr, TextTypePtr Text)
   SymbolTypePtr symbol = FontPtr->Symbol;
   unsigned char *s = (unsigned char *) Text->TextString;
   BDimension minThick = 0;
-  int i;
+  GList *i;
   int space = 0;
 
   LocationType minx=0, miny=0, maxx=0, maxy=0;
@@ -462,9 +462,9 @@ SetTextBoundingBox (FontTypePtr FontPtr, TextTypePtr Text)
     {
       if (*s <= MAX_FONTPOSITION && symbol[*s].Valid)
 	{
-	  LineTypePtr line = symbol[*s].Line;
-	  for (i = 0; i < symbol[*s].LineN; line++, i++)
+	  for (i = symbol[*s].Line; i != NULL; i = g_list_next (i))
 	    {
+              LineType *line = i->data;
 	      int t = line->Thickness / 4;
 	      if (t < minThick)
 		t = minThick;
@@ -723,9 +723,9 @@ CenterDisplay (LocationType X, LocationType Y, bool Delta)
 void
 SetFontInfo (FontTypePtr Ptr)
 {
-  Cardinal i, j;
+  Cardinal i;
+  GList *iter;
   SymbolTypePtr symbol;
-  LineTypePtr line;
   LocationType totalminy = MAX_COORD;
 
   /* calculate cell with and height (is at least DEFAULT_CELLSIZE)
@@ -744,8 +744,9 @@ SetFontInfo (FontTypePtr Ptr)
 
       minx = miny = MAX_COORD;
       maxx = maxy = 0;
-      for (line = symbol->Line, j = symbol->LineN; j; j--, line++)
+      for (iter = symbol->Line ; iter != NULL; iter = g_list_next (iter))
         {
+          LineType *line = iter->data;
           minx = MIN (minx, line->Point1.X);
           miny = MIN (miny, line->Point1.Y);
           minx = MIN (minx, line->Point2.X);
@@ -757,8 +758,11 @@ SetFontInfo (FontTypePtr Ptr)
         }
 
       /* move symbol to left edge */
-      for (line = symbol->Line, j = symbol->LineN; j; j--, line++)
-        MOVE_LINE_LOWLEVEL (line, -minx, 0);
+      for (iter = symbol->Line; iter != NULL; iter = g_list_next (iter))
+        {
+          LineType *line = iter->data;
+          MOVE_LINE_LOWLEVEL (line, -minx, 0);
+        }
 
       /* set symbol bounding box with a minimum cell size of (1,1) */
       symbol->Width = maxx - minx + 1;
@@ -775,8 +779,11 @@ SetFontInfo (FontTypePtr Ptr)
     if (symbol->Valid)
       {
         symbol->Height -= totalminy;
-        for (line = symbol->Line, j = symbol->LineN; j; j--, line++)
-          MOVE_LINE_LOWLEVEL (line, 0, -totalminy);
+        for (iter = symbol->Line; iter != NULL; iter = g_list_next (iter))
+          {
+            LineType *line = iter->data;
+            MOVE_LINE_LOWLEVEL (line, 0, -totalminy);
+          }
       }
 
   /* setup the box for the default symbol */
@@ -1696,8 +1703,11 @@ GetGridLockCoordinates (int type, void *ptr1,
       *y = ((ElementTypePtr) ptr2)->MarkY;
       break;
     case POLYGON_TYPE:
-      *x = ((PolygonTypePtr) ptr2)->Points[0].X;
-      *y = ((PolygonTypePtr) ptr2)->Points[0].Y;
+      {
+        PointType *point0 = ((PolygonTypePtr) ptr2)->Points->data;
+        *x = point0->X;
+        *y = point0->Y;
+      }
       break;
 
     case LINEPOINT_TYPE:
@@ -1980,10 +1990,13 @@ pcb_author (void)
 char *
 AttributeGetFromList (AttributeListType *list, char *name)
 {
-  int i;
-  for (i=0; i<list->Number; i++)
-    if (strcmp (name, list->List[i].name) == 0)
-      return list->List[i].value;
+  GList *i;
+  for (i = list->List; i != NULL; i = g_list_next (i))
+    {
+      AttributeType *attr = i->data;
+      if (strcmp (name, attr->name) == 0)
+        return attr->value;
+    }
   return NULL;
 }
 
diff --git a/src/move.c b/src/move.c
index c8d1938..da1f550 100644
--- a/src/move.c
+++ b/src/move.c
@@ -436,44 +436,36 @@ MovePolygonPoint (LayerTypePtr Layer, PolygonTypePtr Polygon,
  * moves a line between layers; lowlevel routines
  */
 void *
-MoveLineToLayerLowLevel (LayerTypePtr Source, LineTypePtr Line,
+MoveLineToLayerLowLevel (LayerTypePtr Source, LineTypePtr line,
 			 LayerTypePtr Destination)
 {
-  LineTypePtr newone = GetLineMemory (Destination);
-
-  r_delete_entry (Source->line_tree, (BoxTypePtr) Line);
-  /* copy the data and remove it from the former layer */
-  *newone = *Line;
-  *Line = Source->Line[--Source->LineN];
-  r_substitute (Source->line_tree, (BoxType *) & Source->Line[Source->LineN],
-		(BoxType *) Line);
-  memset (&Source->Line[Source->LineN], 0, sizeof (LineType));
+  r_delete_entry (Source->line_tree, (BoxType *)line);
+
+  Source->Line = g_list_remove (Source->Line, line);
+  Destination->Line = g_list_append (Destination->Line, line);
+
   if (!Destination->line_tree)
     Destination->line_tree = r_create_tree (NULL, 0, 0);
-  r_insert_entry (Destination->line_tree, (BoxTypePtr) newone, 0);
-  return (newone);
+  r_insert_entry (Destination->line_tree, (BoxType *)line, 0);
+  return line;
 }
 
 /* ---------------------------------------------------------------------------
  * moves an arc between layers; lowlevel routines
  */
 void *
-MoveArcToLayerLowLevel (LayerTypePtr Source, ArcTypePtr Arc,
+MoveArcToLayerLowLevel (LayerTypePtr Source, ArcTypePtr arc,
 			LayerTypePtr Destination)
 {
-  ArcTypePtr newone = GetArcMemory (Destination);
-
-  r_delete_entry (Source->arc_tree, (BoxTypePtr) Arc);
-  /* copy the data and remove it from the former layer */
-  *newone = *Arc;
-  *Arc = Source->Arc[--Source->ArcN];
-  r_substitute (Source->arc_tree, (BoxType *) & Source->Arc[Source->ArcN],
-		(BoxType *) Arc);
-  memset (&Source->Arc[Source->ArcN], 0, sizeof (ArcType));
+  r_delete_entry (Source->arc_tree, (BoxType *)arc);
+
+  Source->Arc = g_list_remove (Source->Arc, arc);
+  Destination->Arc = g_list_append (Destination->Arc, arc);
+
   if (!Destination->arc_tree)
     Destination->arc_tree = r_create_tree (NULL, 0, 0);
-  r_insert_entry (Destination->arc_tree, (BoxTypePtr) newone, 0);
-  return (newone);
+  r_insert_entry (Destination->arc_tree, (BoxType *)arc, 0);
+  return arc;
 }
 
 
@@ -640,83 +632,74 @@ MoveLineToLayer (LayerTypePtr Layer, LineTypePtr Line)
 /* ---------------------------------------------------------------------------
  * moves a text object between layers; lowlevel routines
  */
-void *
-MoveTextToLayerLowLevel (LayerTypePtr Source, TextTypePtr Text,
+TextType *
+MoveTextToLayerLowLevel (LayerTypePtr Source, TextType *text,
 			 LayerTypePtr Destination)
 {
-  TextTypePtr newone = GetTextMemory (Destination);
-
-  RestoreToPolygon (PCB->Data, TEXT_TYPE, Source, Text);
-  r_delete_entry (Source->text_tree, (BoxTypePtr) Text);
-  /* copy the data and remove it from the former layer */
-  *newone = *Text;
-  *Text = Source->Text[--Source->TextN];
-  r_substitute (Source->text_tree, (BoxType *) & Source->Text[Source->TextN],
-		(BoxType *) Text);
-  memset (&Source->Text[Source->TextN], 0, sizeof (TextType));
+  RestoreToPolygon (PCB->Data, TEXT_TYPE, Source, text);
+  r_delete_entry (Source->text_tree, (BoxType *)text);
+
+  Source->Text = g_list_remove (Source->Text, text);
+  Destination->Text = g_list_append (Destination->Text, text);
+
   if (GetLayerGroupNumberByNumber (solder_silk_layer) ==
       GetLayerGroupNumberByPointer (Destination))
-    SET_FLAG (ONSOLDERFLAG, newone);
+    SET_FLAG (ONSOLDERFLAG, text);
   else
-    CLEAR_FLAG (ONSOLDERFLAG, newone);
+    CLEAR_FLAG (ONSOLDERFLAG, text);
+
   /* re-calculate the bounding box (it could be mirrored now) */
-  SetTextBoundingBox (&PCB->Font, newone);
+  SetTextBoundingBox (&PCB->Font, text);
   if (!Destination->text_tree)
     Destination->text_tree = r_create_tree (NULL, 0, 0);
-  r_insert_entry (Destination->text_tree, (BoxTypePtr) newone, 0);
-  ClearFromPolygon (PCB->Data, TEXT_TYPE, Destination, newone);
-  return (newone);
+  r_insert_entry (Destination->text_tree, (BoxType *) text, 0);
+  ClearFromPolygon (PCB->Data, TEXT_TYPE, Destination, text);
+
+  return text;
 }
 
 /* ---------------------------------------------------------------------------
  * moves a text object between layers
  */
 static void *
-MoveTextToLayer (LayerTypePtr Layer, TextTypePtr Text)
+MoveTextToLayer (LayerType *layer, TextType *text)
 {
-  TextTypePtr newone;
-
-  if (TEST_FLAG (LOCKFLAG, Text))
+  if (TEST_FLAG (LOCKFLAG, text))
     {
       Message (_("Sorry, the object is locked\n"));
       return NULL;
     }
-  if (Dest != Layer)
+  if (Dest != layer)
     {
-      AddObjectToMoveToLayerUndoList (TEXT_TYPE, Layer, Text, Text);
-      if (Layer->On)
-	EraseText (Layer, Text);
-      newone = (TextTypePtr)MoveTextToLayerLowLevel (Layer, Text, Dest);
+      AddObjectToMoveToLayerUndoList (TEXT_TYPE, layer, text, text);
+      if (layer->On)
+	EraseText (layer, text);
+      text = MoveTextToLayerLowLevel (layer, text, Dest);
       if (Dest->On)
-	DrawText (Dest, newone);
-      if (Layer->On || Dest->On)
+	DrawText (Dest, text);
+      if (layer->On || Dest->On)
 	Draw ();
-      return (newone);
     }
-  return (Text);
+  return text;
 }
 
 /* ---------------------------------------------------------------------------
  * moves a polygon between layers; lowlevel routines
  */
 void *
-MovePolygonToLayerLowLevel (LayerTypePtr Source, PolygonTypePtr Polygon,
+MovePolygonToLayerLowLevel (LayerTypePtr Source, PolygonType *polygon,
 			    LayerTypePtr Destination)
 {
-  PolygonTypePtr newone = GetPolygonMemory (Destination);
-
-  r_delete_entry (Source->polygon_tree, (BoxType *) Polygon);
-  /* copy the data and remove it from the former layer */
-  *newone = *Polygon;
-  *Polygon = Source->Polygon[--Source->PolygonN];
-  r_substitute (Source->polygon_tree,
-		(BoxType *) & Source->Polygon[Source->PolygonN],
-		(BoxType *) Polygon);
-  memset (&Source->Polygon[Source->PolygonN], 0, sizeof (PolygonType));
+  r_delete_entry (Source->polygon_tree, (BoxType *) polygon);
+
+  Source->Polygon = g_list_remove (Source->Polygon, polygon);
+  Destination->Polygon = g_list_append (Destination->Polygon, polygon);
+
   if (!Destination->polygon_tree)
     Destination->polygon_tree = r_create_tree (NULL, 0, 0);
-  r_insert_entry (Destination->polygon_tree, (BoxType *) newone, 0);
-  return (newone);
+  r_insert_entry (Destination->polygon_tree, (BoxType *) polygon, 0);
+
+  return polygon;
 }
 
 struct mptlc
@@ -806,7 +789,7 @@ void *
 MoveObjectAndRubberband (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
 			 LocationType DX, LocationType DY)
 {
-  RubberbandTypePtr ptr;
+  GList *iter;
   void *ptr2;
 
   /* setup offset */
@@ -816,9 +799,11 @@ MoveObjectAndRubberband (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
     return (NULL);
 
   /* move all the lines... and reset the counter */
-  ptr = Crosshair.AttachedObject.Rubberband;
-  while (Crosshair.AttachedObject.RubberbandN)
+  for (iter = Crosshair.AttachedObject.Rubberband;
+       iter != NULL; iter = g_list_next (iter))
     {
+      RubberbandType *ptr = iter->data;
+
       /* first clear any marks that we made in the line flags */
       CLEAR_FLAG (RUBBERENDFLAG, ptr->Line);
       AddObjectToMoveUndoList (LINEPOINT_TYPE,
@@ -826,7 +811,6 @@ MoveObjectAndRubberband (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
 			       DY);
       MoveLinePoint (ptr->Layer, ptr->Line, ptr->MovedPoint);
       Crosshair.AttachedObject.RubberbandN--;
-      ptr++;
     }
 
   AddObjectToMoveUndoList (Type, Ptr1, Ptr2, Ptr3, DX, DY);
diff --git a/src/move.h b/src/move.h
index c4a844b..489224b 100644
--- a/src/move.h
+++ b/src/move.h
@@ -101,7 +101,6 @@ void *MoveObjectToLayer (int, void *, void *, void *, LayerTypePtr, bool);
 void *MoveObjectAndRubberband (int, void *, void *, void *,
 			       LocationType, LocationType);
 void *MoveLineToLayerLowLevel (LayerTypePtr, LineTypePtr, LayerTypePtr);
-void *MoveTextToLayerLowLevel (LayerTypePtr, TextTypePtr, LayerTypePtr);
 void *MovePolygonToLayerLowLevel (LayerTypePtr, PolygonTypePtr, LayerTypePtr);
 bool MoveSelectedObjectsToLayer (LayerTypePtr);
 
diff --git a/src/mymem.c b/src/mymem.c
index 24f20a2..a3bc896 100644
--- a/src/mymem.c
+++ b/src/mymem.c
@@ -36,8 +36,6 @@
 
 #include "global.h"
 
-#include <memory.h>
-
 #include "data.h"
 #include "error.h"
 #include "mymem.h"
@@ -59,388 +57,316 @@ static void DSRealloc (DynamicStringTypePtr, size_t);
 /* ---------------------------------------------------------------------------
  * get next slot for a rubberband connection, allocates memory if necessary
  */
-RubberbandTypePtr
+RubberbandType *
 GetRubberbandMemory (void)
 {
-  RubberbandTypePtr ptr = Crosshair.AttachedObject.Rubberband;
+  AttachedObjectType *attached = &Crosshair.AttachedObject;
+  RubberbandType *new_obj;
 
-  /* realloc new memory if necessary and clear it */
-  if (Crosshair.AttachedObject.RubberbandN >=
-      Crosshair.AttachedObject.RubberbandMax)
-    {
-      Crosshair.AttachedObject.RubberbandMax += STEP_RUBBERBAND;
-      ptr = (RubberbandTypePtr)realloc (ptr, Crosshair.AttachedObject.RubberbandMax *
-                          sizeof (RubberbandType));
-      Crosshair.AttachedObject.Rubberband = ptr;
-      memset (ptr + Crosshair.AttachedObject.RubberbandN, 0,
-	      STEP_RUBBERBAND * sizeof (RubberbandType));
-    }
-  return (ptr + Crosshair.AttachedObject.RubberbandN++);
+  new_obj = g_slice_new0 (RubberbandType);
+  attached->Rubberband = g_list_append (attached->Rubberband, new_obj);
+  attached->RubberbandN ++;
+
+  return new_obj;
 }
 
 void **
-GetPointerMemory (PointerListTypePtr list)
+GetPointerMemory (PointerListType *list)
 {
-  void **ptr = list->Ptr;
+  void **new_obj;
 
-  /* realloc new memory if necessary and clear it */
-  if (list->PtrN >= list->PtrMax)
-    {
-      list->PtrMax = STEP_POINT + (2 * list->PtrMax);
-      ptr = (void **)realloc (ptr, list->PtrMax * sizeof (void *));
-      list->Ptr = ptr;
-      memset (ptr + list->PtrN, 0,
-	      (list->PtrMax - list->PtrN) * sizeof (void *));
-    }
-  return (ptr + list->PtrN++);
+  new_obj = g_slice_new0 (void *);
+  list->Ptr = g_list_append (list->Ptr, new_obj);
+  list->PtrN ++;
+
+  return new_obj;
+}
+
+static void
+FreePointer (gpointer data)
+{
+  g_slice_free (void *, data);
 }
 
 void
-FreePointerListMemory (PointerListTypePtr list)
+FreePointerListMemory (PointerListType *list)
 {
-  free (list->Ptr);
+  g_list_free_full (list->Ptr, (GDestroyNotify)FreePointer);
   memset (list, 0, sizeof (PointerListType));
 }
 
 /* ---------------------------------------------------------------------------
  * get next slot for a box, allocates memory if necessary
  */
-BoxTypePtr
-GetBoxMemory (BoxListTypePtr Boxes)
+BoxType *
+GetBoxMemory (BoxListType *boxlist)
 {
-  BoxTypePtr box = Boxes->Box;
+  BoxType *new_obj;
 
-  /* realloc new memory if necessary and clear it */
-  if (Boxes->BoxN >= Boxes->BoxMax)
-    {
-      Boxes->BoxMax = STEP_POINT + (2 * Boxes->BoxMax);
-      box = (BoxTypePtr)realloc (box, Boxes->BoxMax * sizeof (BoxType));
-      Boxes->Box = box;
-      memset (box + Boxes->BoxN, 0,
-	      (Boxes->BoxMax - Boxes->BoxN) * sizeof (BoxType));
-    }
-  return (box + Boxes->BoxN++);
+  new_obj = g_slice_new0 (BoxType);
+  boxlist->Box = g_list_append (boxlist->Box, new_obj);
+  boxlist->BoxN ++;
+
+  return new_obj;
 }
 
+static void
+FreeBox (BoxType *data)
+{
+  g_slice_free (BoxType, data);
+}
 
 /* ---------------------------------------------------------------------------
  * get next slot for a connection, allocates memory if necessary
  */
-ConnectionTypePtr
-GetConnectionMemory (NetTypePtr Net)
+ConnectionType *
+GetConnectionMemory (NetType *net)
 {
-  ConnectionTypePtr con = Net->Connection;
+  ConnectionType *new_obj;
 
-  /* realloc new memory if necessary and clear it */
-  if (Net->ConnectionN >= Net->ConnectionMax)
-    {
-      Net->ConnectionMax += STEP_POINT;
-      con = (ConnectionTypePtr)realloc (con, Net->ConnectionMax * sizeof (ConnectionType));
-      Net->Connection = con;
-      memset (con + Net->ConnectionN, 0,
-	      STEP_POINT * sizeof (ConnectionType));
-    }
-  return (con + Net->ConnectionN++);
+  new_obj = g_slice_new (ConnectionType);
+  net->Connection = g_list_append (net->Connection, new_obj);
+  net->ConnectionN ++;
+
+  return new_obj;
+}
+
+static void
+FreeConnection (ConnectionType *data)
+{
+  g_slice_free (ConnectionType, data);
 }
 
 /* ---------------------------------------------------------------------------
  * get next slot for a subnet, allocates memory if necessary
  */
-NetTypePtr
-GetNetMemory (NetListTypePtr Netlist)
+NetType *
+GetNetMemory (NetListType *netlist)
 {
-  NetTypePtr net = Netlist->Net;
+  NetType *new_obj;
 
-  /* realloc new memory if necessary and clear it */
-  if (Netlist->NetN >= Netlist->NetMax)
-    {
-      Netlist->NetMax += STEP_POINT;
-      net = (NetTypePtr)realloc (net, Netlist->NetMax * sizeof (NetType));
-      Netlist->Net = net;
-      memset (net + Netlist->NetN, 0, STEP_POINT * sizeof (NetType));
-    }
-  return (net + Netlist->NetN++);
+  new_obj = g_slice_new (NetType);
+  netlist->Net = g_list_append (netlist->Net, new_obj);
+  netlist->NetN ++;
+
+  return new_obj;
+}
+
+static void
+FreeNet (NetType *data)
+{
+  g_slice_free (NetType, data);
 }
 
 /* ---------------------------------------------------------------------------
  * get next slot for a net list, allocates memory if necessary
  */
-NetListTypePtr
-GetNetListMemory (NetListListTypePtr Netlistlist)
+NetListType *
+GetNetListMemory (NetListListType *netlistlist)
 {
-  NetListTypePtr netlist = Netlistlist->NetList;
+  NetListType* new_obj;
 
-  /* realloc new memory if necessary and clear it */
-  if (Netlistlist->NetListN >= Netlistlist->NetListMax)
-    {
-      Netlistlist->NetListMax += STEP_POINT;
-      netlist = (NetListTypePtr)realloc (netlist,
-                         Netlistlist->NetListMax * sizeof (NetListType));
-      Netlistlist->NetList = netlist;
-      memset (netlist + Netlistlist->NetListN, 0,
-	      STEP_POINT * sizeof (NetListType));
-    }
-  return (netlist + Netlistlist->NetListN++);
+  new_obj = g_slice_new (NetListType);
+  netlistlist->NetList = g_list_append (netlistlist->NetList, new_obj);
+  netlistlist->NetListN ++;
+
+  return new_obj;
+}
+
+static void
+FreeNetList (NetListType *data)
+{
+  g_slice_free (NetListType, data);
 }
 
 /* ---------------------------------------------------------------------------
  * get next slot for a pin, allocates memory if necessary
  */
-PinTypePtr
-GetPinMemory (ElementTypePtr Element)
+PinType *
+GetPinMemory (ElementType *element)
 {
-  PinTypePtr pin = Element->Pin;
-  bool onBoard = false;
+  PinType *new_obj;
 
-  /* realloc new memory if necessary and clear it */
-  if (Element->PinN >= Element->PinMax)
-    {
-      if (PCB->Data->pin_tree)
-	{
-	  PIN_LOOP (Element);
-	  {
-	    if (r_delete_entry (PCB->Data->pin_tree, (BoxType *) pin))
-	      onBoard = true;
-	  }
-	  END_LOOP;
-	}
-      Element->PinMax += STEP_PIN;
-      pin = (PinTypePtr)realloc (pin, Element->PinMax * sizeof (PinType));
-      Element->Pin = pin;
-      memset (pin + Element->PinN, 0, STEP_PIN * sizeof (PinType));
-      if (onBoard)
-	{
-	  PIN_LOOP (Element);
-	  {
-	    r_insert_entry (PCB->Data->pin_tree, (BoxType *) pin, 0);
-	  }
-	  END_LOOP;
-	}
-    }
-  return (pin + Element->PinN++);
+  new_obj = g_slice_new (PinType);
+  element->Pin = g_list_append (element->Pin, new_obj);
+  element->PinN ++;
+
+  return new_obj;
+}
+
+static void
+FreePin (PinType *data)
+{
+  g_slice_free (PinType, data);
 }
 
 /* ---------------------------------------------------------------------------
  * get next slot for a pad, allocates memory if necessary
  */
-PadTypePtr
-GetPadMemory (ElementTypePtr Element)
+PadType *
+GetPadMemory (ElementType *element)
 {
-  PadTypePtr pad = Element->Pad;
-  bool onBoard = false;
+  PadType *new_obj;
 
-  /* realloc new memory if necessary and clear it */
-  if (Element->PadN >= Element->PadMax)
-    {
-      if (PCB->Data->pad_tree)
-	{
-	  PAD_LOOP (Element);
-	  {
-	    if (r_delete_entry (PCB->Data->pad_tree, (BoxType *) pad))
-	      onBoard = true;
-	  }
-	  END_LOOP;
-	}
-      Element->PadMax += STEP_PAD;
-      pad = (PadTypePtr)realloc (pad, Element->PadMax * sizeof (PadType));
-      Element->Pad = pad;
-      memset (pad + Element->PadN, 0, STEP_PAD * sizeof (PadType));
-      if (onBoard)
-	{
-	  PAD_LOOP (Element);
-	  {
-	    r_insert_entry (PCB->Data->pad_tree, (BoxType *) pad, 0);
-	  }
-	  END_LOOP;
-	}
-    }
-  return (pad + Element->PadN++);
+  new_obj = g_slice_new (PadType);
+  element->Pad = g_list_append (element->Pad, new_obj);
+  element->PadN ++;
+
+  return new_obj;
+}
+
+static void
+FreePad (PadType *data)
+{
+  g_slice_free (PadType, data);
 }
 
 /* ---------------------------------------------------------------------------
  * get next slot for a via, allocates memory if necessary
  */
-PinTypePtr
-GetViaMemory (DataTypePtr Data)
+PinType *
+GetViaMemory (DataType *data)
 {
-  PinTypePtr via = Data->Via;
+  PinType *new_obj;
 
-  /* realloc new memory if necessary and clear it */
-  if (Data->ViaN >= Data->ViaMax)
-    {
-      Data->ViaMax += STEP_VIA;
-      if (Data->via_tree)
-	r_destroy_tree (&Data->via_tree);
-      via = (PinTypePtr)realloc (via, Data->ViaMax * sizeof (PinType));
-      Data->Via = via;
-      memset (via + Data->ViaN, 0, STEP_VIA * sizeof (PinType));
-      Data->via_tree = r_create_tree (NULL, 0, 0);
-      VIA_LOOP (Data);
-      {
-	r_insert_entry (Data->via_tree, (BoxType *) via, 0);
-      }
-      END_LOOP;
-    }
-  return (via + Data->ViaN++);
+  new_obj = g_slice_new (PinType);
+  data->Via = g_list_append (data->Via, new_obj);
+  data->ViaN ++;
+
+  return new_obj;
+}
+
+static void
+FreeVia (PinType *data)
+{
+  g_slice_free (PinType, data);
 }
 
 /* ---------------------------------------------------------------------------
  * get next slot for a Rat, allocates memory if necessary
  */
-RatTypePtr
-GetRatMemory (DataTypePtr Data)
+RatType *
+GetRatMemory (DataType *data)
 {
-  RatTypePtr rat = Data->Rat;
+  RatType *new_obj;
 
-  /* realloc new memory if necessary and clear it */
-  if (Data->RatN >= Data->RatMax)
-    {
-      Data->RatMax += STEP_RAT;
-      /* all of the pointers move, so rebuild the whole tree */
-      if (Data->rat_tree)
-        r_destroy_tree (&Data->rat_tree);
-      rat = (RatTypePtr)realloc (rat, Data->RatMax * sizeof (RatType));
-      Data->Rat = rat;
-      memset (rat + Data->RatN, 0, STEP_RAT * sizeof (RatType));
-      Data->rat_tree = r_create_tree (NULL, 0, 0);
-      RAT_LOOP (Data);
-      {
-        r_insert_entry (Data->rat_tree, (BoxTypePtr) line, 0);
-      }
-      END_LOOP;
-    }
-  return (rat + Data->RatN++);
+  new_obj = g_slice_new (RatType);
+  data->Rat = g_list_append (data->Rat, new_obj);
+  data->RatN ++;
+
+  return new_obj;
+}
+
+static void
+FreeRat (RatType *data)
+{
+  g_slice_free (RatType, data);
 }
 
 /* ---------------------------------------------------------------------------
  * get next slot for a line, allocates memory if necessary
  */
-LineTypePtr
-GetLineMemory (LayerTypePtr Layer)
+LineType *
+GetLineMemory (LayerType *layer)
 {
-  LineTypePtr line = Layer->Line;
+  LineType *new_obj;
 
-  /* realloc new memory if necessary and clear it */
-  if (Layer->LineN >= Layer->LineMax)
-    {
-      Layer->LineMax += STEP_LINE;
-      /* all of the pointers move, so rebuild the whole tree */
-      if (Layer->line_tree)
-	r_destroy_tree (&Layer->line_tree);
-      line = (LineTypePtr)realloc (line, Layer->LineMax * sizeof (LineType));
-      Layer->Line = line;
-      memset (line + Layer->LineN, 0, STEP_LINE * sizeof (LineType));
-      Layer->line_tree = r_create_tree (NULL, 0, 0);
-      LINE_LOOP (Layer);
-      {
-	r_insert_entry (Layer->line_tree, (BoxTypePtr) line, 0);
-      }
-      END_LOOP;
-    }
-  return (line + Layer->LineN++);
+  new_obj = g_slice_new (LineType);
+  layer->Line = g_list_append (layer->Line, new_obj);
+  layer->LineN ++;
+
+  return new_obj;
+}
+
+static void
+FreeLine (LineType *data)
+{
+  g_slice_free (LineType, data);
 }
 
 /* ---------------------------------------------------------------------------
  * get next slot for an arc, allocates memory if necessary
  */
 ArcTypePtr
-GetArcMemory (LayerTypePtr Layer)
+GetArcMemory (LayerType *layer)
 {
-  ArcTypePtr arc = Layer->Arc;
+  ArcType *new_obj;
 
-  /* realloc new memory if necessary and clear it */
-  if (Layer->ArcN >= Layer->ArcMax)
-    {
-      Layer->ArcMax += STEP_ARC;
-      if (Layer->arc_tree)
-	r_destroy_tree (&Layer->arc_tree);
-      arc = (ArcTypePtr)realloc (arc, Layer->ArcMax * sizeof (ArcType));
-      Layer->Arc = arc;
-      memset (arc + Layer->ArcN, 0, STEP_ARC * sizeof (ArcType));
-      Layer->arc_tree = r_create_tree (NULL, 0, 0);
-      ARC_LOOP (Layer);
-      {
-	r_insert_entry (Layer->arc_tree, (BoxTypePtr) arc, 0);
-      }
-      END_LOOP;
-    }
-  return (arc + Layer->ArcN++);
+  new_obj = g_slice_new (ArcType);
+  layer->Arc = g_list_append (layer->Arc, new_obj);
+  layer->ArcN ++;
+
+  return new_obj;
+}
+
+static void
+FreeArc (ArcType *data)
+{
+  g_slice_free (ArcType, data);
 }
 
 /* ---------------------------------------------------------------------------
  * get next slot for a text object, allocates memory if necessary
  */
 TextTypePtr
-GetTextMemory (LayerTypePtr Layer)
+GetTextMemory (LayerType *layer)
 {
-  TextTypePtr text = Layer->Text;
+  TextType *new_obj;
 
-  /* realloc new memory if necessary and clear it */
-  if (Layer->TextN >= Layer->TextMax)
-    {
-      Layer->TextMax += STEP_TEXT;
-      if (Layer->text_tree)
-	r_destroy_tree (&Layer->text_tree);
-      text = (TextTypePtr)realloc (text, Layer->TextMax * sizeof (TextType));
-      Layer->Text = text;
-      memset (text + Layer->TextN, 0, STEP_TEXT * sizeof (TextType));
-      Layer->text_tree = r_create_tree (NULL, 0, 0);
-      TEXT_LOOP (Layer);
-      {
-	r_insert_entry (Layer->text_tree, (BoxTypePtr) text, 0);
-      }
-      END_LOOP;
-    }
-  return (text + Layer->TextN++);
+  new_obj = g_slice_new (TextType);
+  layer->Text = g_list_append (layer->Text, new_obj);
+  layer->TextN ++;
+
+  return new_obj;
+}
+
+static void
+FreeText (TextType *data)
+{
+  g_slice_free (TextType, data);
 }
 
 /* ---------------------------------------------------------------------------
  * get next slot for a polygon object, allocates memory if necessary
  */
-PolygonTypePtr
-GetPolygonMemory (LayerTypePtr Layer)
+PolygonType *
+GetPolygonMemory (LayerType *layer)
 {
-  PolygonTypePtr polygon = Layer->Polygon;
+  PolygonType *new_obj;
 
-  /* realloc new memory if necessary and clear it */
-  if (Layer->PolygonN >= Layer->PolygonMax)
-    {
-      Layer->PolygonMax += STEP_POLYGON;
-      if (Layer->polygon_tree)
-	r_destroy_tree (&Layer->polygon_tree);
-      polygon = (PolygonTypePtr)realloc (polygon, Layer->PolygonMax * sizeof (PolygonType));
-      Layer->Polygon = polygon;
-      memset (polygon + Layer->PolygonN, 0,
-	      STEP_POLYGON * sizeof (PolygonType));
-      Layer->polygon_tree = r_create_tree (NULL, 0, 0);
-      POLYGON_LOOP (Layer);
-      {
-	r_insert_entry (Layer->polygon_tree, (BoxType *) polygon, 0);
-      }
-      END_LOOP;
-    }
-  return (polygon + Layer->PolygonN++);
+  new_obj = g_slice_new (PolygonType);
+  layer->Polygon = g_list_append (layer->Polygon, new_obj);
+  layer->PolygonN ++;
+
+  return new_obj;
+}
+
+static void
+FreePolygon (PolygonType *data)
+{
+  g_slice_free (PolygonType, data);
 }
 
 /* ---------------------------------------------------------------------------
  * gets the next slot for a point in a polygon struct, allocates memory
  * if necessary
  */
-PointTypePtr
-GetPointMemoryInPolygon (PolygonTypePtr Polygon)
+PointType *
+GetPointMemoryInPolygon (PolygonType *polygon)
 {
-  PointTypePtr points = Polygon->Points;
+  PointType *new_obj;
 
-  /* realloc new memory if necessary and clear it */
-  if (Polygon->PointN >= Polygon->PointMax)
-    {
-      Polygon->PointMax += STEP_POLYGONPOINT;
-      points = (PointTypePtr)realloc (points, Polygon->PointMax * sizeof (PointType));
-      Polygon->Points = points;
-      memset (points + Polygon->PointN, 0,
-	      STEP_POLYGONPOINT * sizeof (PointType));
-    }
-  return (points + Polygon->PointN++);
+  new_obj = g_slice_new (PointType);
+  polygon->Points = g_list_append (polygon->Points, new_obj);
+  polygon->PointN ++;
+
+  return new_obj;
+}
+
+static void
+FreePoint (PointType *data)
+{
+  g_slice_free (PointType, data);
 }
 
 /* ---------------------------------------------------------------------------
@@ -448,441 +374,422 @@ GetPointMemoryInPolygon (PolygonTypePtr Polygon)
  * if necessary
  */
 Cardinal *
-GetHoleIndexMemoryInPolygon (PolygonTypePtr Polygon)
+GetHoleIndexMemoryInPolygon (PolygonType *polygon)
 {
-  Cardinal *holeindex = Polygon->HoleIndex;
+  Cardinal *new_obj;
 
-  /* realloc new memory if necessary and clear it */
-  if (Polygon->HoleIndexN >= Polygon->HoleIndexMax)
-    {
-      Polygon->HoleIndexMax += STEP_POLYGONHOLEINDEX;
-      holeindex = (Cardinal *)realloc (holeindex, Polygon->HoleIndexMax * sizeof (int));
-      Polygon->HoleIndex = holeindex;
-      memset (holeindex + Polygon->HoleIndexN, 0,
-	      STEP_POLYGONHOLEINDEX * sizeof (int));
-    }
-  return (holeindex + Polygon->HoleIndexN++);
+  new_obj = g_slice_new (Cardinal);
+  polygon->HoleIndex = g_list_append (polygon->HoleIndex, new_obj);
+  polygon->HoleIndexN ++;
+
+  return new_obj;
+}
+
+static void
+FreeHoleIndex (Cardinal *data)
+{
+  g_slice_free (Cardinal, data);
 }
 
 /* ---------------------------------------------------------------------------
  * get next slot for an element, allocates memory if necessary
  */
-ElementTypePtr
-GetElementMemory (DataTypePtr Data)
+ElementType *
+GetElementMemory (DataType *data)
 {
-  ElementTypePtr element = Data->Element;
-  int i;
+  ElementType *new_obj;
 
-  /* realloc new memory if necessary and clear it */
-  if (Data->ElementN >= Data->ElementMax)
-    {
-      Data->ElementMax += STEP_ELEMENT;
-      if (Data->element_tree)
-	r_destroy_tree (&Data->element_tree);
-      element = (ElementTypePtr)realloc (element, Data->ElementMax * sizeof (ElementType));
-      Data->Element = element;
-      memset (element + Data->ElementN, 0,
-	      STEP_ELEMENT * sizeof (ElementType));
-      Data->element_tree = r_create_tree (NULL, 0, 0);
-      for (i = 0; i < MAX_ELEMENTNAMES; i++)
-	{
-	  if (Data->name_tree[i])
-	    r_destroy_tree (&Data->name_tree[i]);
-	  Data->name_tree[i] = r_create_tree (NULL, 0, 0);
-	}
-
-      ELEMENT_LOOP (Data);
-      {
-	r_insert_entry (Data->element_tree, (BoxType *) element, 0);
-	PIN_LOOP (element);
-	{
-	  pin->Element = element;
-	}
-	END_LOOP;
-	PAD_LOOP (element);
-	{
-	  pad->Element = element;
-	}
-	END_LOOP;
-	ELEMENTTEXT_LOOP (element);
-	{
-	  text->Element = element;
-	  r_insert_entry (Data->name_tree[n], (BoxType *) text, 0);
-	}
-	END_LOOP;
-      }
-      END_LOOP;
-    }
-  return (element + Data->ElementN++);
+  new_obj = g_slice_new (ElementType);
+  data->Element = g_list_append (data->Element, new_obj);
+  data->ElementN ++;
+
+  return new_obj;
+}
+
+static void
+FreeElement (ElementType *data)
+{
+  g_slice_free (ElementType, data);
 }
 
 /* ---------------------------------------------------------------------------
- * get next slot for a library menu, allocates memory if necessary
+ * get next slot for a library entry, allocates memory if necessary
  */
-LibraryMenuTypePtr
-GetLibraryMenuMemory (LibraryTypePtr lib)
+LibraryEntryType *
+GetLibraryEntryMemory (LibraryMenuType *menu)
 {
-  LibraryMenuTypePtr menu = lib->Menu;
+  LibraryEntryType *new_obj;
 
-  /* realloc new memory if necessary and clear it */
-  if (lib->MenuN >= lib->MenuMax)
-    {
-      lib->MenuMax += STEP_LIBRARYMENU;
-      menu = (LibraryMenuTypePtr)realloc (menu, lib->MenuMax * sizeof (LibraryMenuType));
-      lib->Menu = menu;
-      memset (menu + lib->MenuN, 0,
-	      STEP_LIBRARYMENU * sizeof (LibraryMenuType));
-    }
-  return (menu + lib->MenuN++);
+  new_obj = g_slice_new (LibraryEntryType);
+  menu->Entry = g_list_append (menu->Entry, new_obj);
+  menu->EntryN ++;
+
+  return new_obj;
+}
+
+static void
+FreeLibraryEntry (LibraryEntryType *entry)
+{
+  free (entry->AllocatedMemory);
+  free (entry->ListEntry);
+
+  g_slice_free (LibraryEntryType, entry);
 }
 
 /* ---------------------------------------------------------------------------
- * get next slot for a library entry, allocates memory if necessary
+ * get next slot for a library menu, allocates memory if necessary
  */
-LibraryEntryTypePtr
-GetLibraryEntryMemory (LibraryMenuTypePtr Menu)
+LibraryMenuType *
+GetLibraryMenuMemory (LibraryType *lib)
 {
-  LibraryEntryTypePtr entry = Menu->Entry;
+  LibraryMenuType *new_obj;
 
-  /* realloc new memory if necessary and clear it */
-  if (Menu->EntryN >= Menu->EntryMax)
-    {
-      Menu->EntryMax += STEP_LIBRARYENTRY;
-      entry = (LibraryEntryTypePtr)realloc (entry, Menu->EntryMax * sizeof (LibraryEntryType));
-      Menu->Entry = entry;
-      memset (entry + Menu->EntryN, 0,
-	      STEP_LIBRARYENTRY * sizeof (LibraryEntryType));
-    }
-  return (entry + Menu->EntryN++);
+  new_obj = g_slice_new (LibraryMenuType);
+  lib->Menu = g_list_append (lib->Menu, new_obj);
+  lib->MenuN ++;
+
+  return new_obj;
+}
+
+static void
+FreeLibraryMenu (LibraryMenuType *menu)
+{
+  g_list_free_full (menu->Entry, (GDestroyNotify)FreeLibraryEntry);
+  free (menu->Name);
+  g_slice_free (LibraryMenuType, menu);
 }
 
 /* ---------------------------------------------------------------------------
  * get next slot for a DrillElement, allocates memory if necessary
  */
-ElementTypeHandle
-GetDrillElementMemory (DrillTypePtr Drill)
+ElementType **
+GetDrillElementMemory (DrillType *drill)
 {
-  ElementTypePtr *element;
+  ElementType **new_obj;
 
-  element = Drill->Element;
+  new_obj = g_slice_new (ElementType *);
+  drill->Element = g_list_append (drill->Element, new_obj);
+  drill->ElementN ++;
 
-  /* realloc new memory if necessary and clear it */
-  if (Drill->ElementN >= Drill->ElementMax)
-    {
-      Drill->ElementMax += STEP_ELEMENT;
-      element = (ElementTypePtr *)realloc (element,
-                         Drill->ElementMax * sizeof (ElementTypeHandle));
-      Drill->Element = element;
-      memset (element + Drill->ElementN, 0,
-	      STEP_ELEMENT * sizeof (ElementTypeHandle));
-    }
-  return (element + Drill->ElementN++);
+  return new_obj;
+}
+
+static void
+FreeDrillElement (ElementType **data)
+{
+  g_slice_free (ElementType *, data);
 }
 
 /* ---------------------------------------------------------------------------
  * get next slot for a DrillPoint, allocates memory if necessary
  */
-PinTypeHandle
-GetDrillPinMemory (DrillTypePtr Drill)
+PinType **
+GetDrillPinMemory (DrillType *drill)
 {
-  PinTypePtr *pin;
+  PinType **new_obj;
 
-  pin = Drill->Pin;
+  new_obj = g_slice_new (PinType *);
+  drill->Pin = g_list_append (drill->Pin, new_obj);
+  drill->PinN ++;
 
-  /* realloc new memory if necessary and clear it */
-  if (Drill->PinN >= Drill->PinMax)
-    {
-      Drill->PinMax += STEP_POINT;
-      pin = (PinTypePtr *)realloc (pin, Drill->PinMax * sizeof (PinTypeHandle));
-      Drill->Pin = pin;
-      memset (pin + Drill->PinN, 0, STEP_POINT * sizeof (PinTypeHandle));
-    }
-  return (pin + Drill->PinN++);
+  return new_obj;
+}
+
+static void
+FreeDrillPin (PinType **data)
+{
+  g_slice_free (PinType *, data);
 }
 
 /* ---------------------------------------------------------------------------
  * get next slot for a Drill, allocates memory if necessary
  */
-DrillTypePtr
-GetDrillInfoDrillMemory (DrillInfoTypePtr DrillInfo)
+DrillType *
+GetDrillInfoDrillMemory (DrillInfoType *drillinfo)
 {
-  DrillTypePtr drill = DrillInfo->Drill;
+  DrillType *new_obj;
 
-  /* realloc new memory if necessary and clear it */
-  if (DrillInfo->DrillN >= DrillInfo->DrillMax)
-    {
-      DrillInfo->DrillMax += STEP_DRILL;
-      drill = (DrillTypePtr)realloc (drill, DrillInfo->DrillMax * sizeof (DrillType));
-      DrillInfo->Drill = drill;
-      memset (drill + DrillInfo->DrillN, 0, STEP_DRILL * sizeof (DrillType));
-    }
-  return (drill + DrillInfo->DrillN++);
+  new_obj = g_slice_new (DrillType);
+  drillinfo->Drill = g_list_append (drillinfo->Drill, new_obj);
+  drillinfo->DrillN ++;
+
+  return new_obj;
+}
+
+static void
+FreeDrill (DrillType *drill)
+{
+  g_list_free_full (drill->Element, (GDestroyNotify)FreeDrillElement);
+  g_list_free_full (drill->Pin, (GDestroyNotify)FreeDrillPin);
+  g_slice_free (DrillType, drill);
+}
+
+void
+FreeDrillInfo (DrillInfoType *drill_info)
+{
+  g_list_free_full (drill_info->Drill, (GDestroyNotify)FreeDrill);
+  g_slice_free (DrillInfoType, drill_info);
+}
+
+AttributeType *
+GetAttributeMemory (AttributeListType *attr_list)
+{
+  AttributeType *new_obj;
+
+  new_obj = g_slice_new0 (AttributeType);
+  attr_list->List = g_list_append (attr_list->List, new_obj);
+  attr_list->Number ++;
+
+  return new_obj;
+}
+
+void
+FreeAttribute (AttributeType *attr)
+{
+  free (attr->name);
+  free (attr->value);
+  g_slice_free (AttributeType, attr);
 }
 
 /* ---------------------------------------------------------------------------
  * frees memory used by a polygon
  */
 void
-FreePolygonMemory (PolygonTypePtr Polygon)
+FreePolygonMemory (PolygonType *polygon)
 {
-  if (Polygon)
-    {
-      free (Polygon->Points);
-      free (Polygon->HoleIndex);
-      if (Polygon->Clipped)
-	poly_Free (&Polygon->Clipped);
-      poly_FreeContours (&Polygon->NoHoles);
-      memset (Polygon, 0, sizeof (PolygonType));
-    }
+  if (polygon == NULL)
+    return;
+
+  g_list_free_full (polygon->Points, (GDestroyNotify)FreePoint);
+  g_list_free_full (polygon->HoleIndex, (GDestroyNotify)FreeHoleIndex);
+
+  if (polygon->Clipped)
+    poly_Free (&polygon->Clipped);
+  poly_FreeContours (&polygon->NoHoles);
+
+  memset (polygon, 0, sizeof (PolygonType));
 }
 
 /* ---------------------------------------------------------------------------
  * frees memory used by a box list
  */
 void
-FreeBoxListMemory (BoxListTypePtr Boxlist)
+FreeBoxListMemory (BoxListType *boxlist)
 {
-  if (Boxlist)
-    {
-      free (Boxlist->Box);
-      memset (Boxlist, 0, sizeof (BoxListType));
-    }
+  if (boxlist == NULL)
+    return;
+
+  g_list_free_full (boxlist->Box, (GDestroyNotify)FreeBox);
+  memset (boxlist, 0, sizeof (BoxListType));
 }
 
 /* ---------------------------------------------------------------------------
  * frees memory used by a net 
  */
 void
-FreeNetListMemory (NetListTypePtr Netlist)
+FreeNetListMemory (NetListType *netlist)
 {
-  if (Netlist)
-    {
-      NET_LOOP (Netlist);
-      {
-	FreeNetMemory (net);
-      }
-      END_LOOP;
-      free (Netlist->Net);
-      memset (Netlist, 0, sizeof (NetListType));
-    }
+  if (netlist == NULL)
+    return;
+
+  NET_LOOP (netlist);
+  {
+    FreeNetMemory (net);
+  }
+  END_LOOP;
+
+  g_list_free_full (netlist->Net, (GDestroyNotify)FreeNet);
+  memset (netlist, 0, sizeof (NetListType));
 }
 
 /* ---------------------------------------------------------------------------
  * frees memory used by a net list
  */
 void
-FreeNetListListMemory (NetListListTypePtr Netlistlist)
+FreeNetListListMemory (NetListListType *netlistlist)
 {
-  if (Netlistlist)
-    {
-      NETLIST_LOOP (Netlistlist);
-      {
-	FreeNetListMemory (netlist);
-      }
-      END_LOOP;
-      free (Netlistlist->NetList);
-      memset (Netlistlist, 0, sizeof (NetListListType));
-    }
+  if (netlistlist == NULL)
+    return;
+
+  NETLIST_LOOP (netlistlist);
+  {
+    FreeNetListMemory (netlist);
+  }
+  END_LOOP;
+
+  g_list_free_full (netlistlist->NetList, (GDestroyNotify)FreeNetList);
+  memset (netlistlist, 0, sizeof (NetListListType));
 }
 
 /* ---------------------------------------------------------------------------
  * frees memory used by a subnet 
  */
 void
-FreeNetMemory (NetTypePtr Net)
+FreeNetMemory (NetType *net)
 {
-  if (Net)
-    {
-      free (Net->Connection);
-      memset (Net, 0, sizeof (NetType));
-    }
+  if (net == NULL)
+    return;
+
+  g_list_free_full (net->Connection, (GDestroyNotify)FreeConnection);
+  memset (net, 0, sizeof (NetType));
 }
+
 /* ---------------------------------------------------------------------------
  * frees memory used by an attribute list
- */
-static void
-FreeAttributeListMemory (AttributeListTypePtr list)
+*/
+void
+FreeAttributeListMemory (AttributeListType *list)
 {
-  int i;
-
-  for (i = 0; i < list->Number; i++)
-    {
-      free (list->List[i].name);
-      free (list->List[i].value);
-    }
-  free (list->List);
-  list->List = NULL;
-  list->Max = 0;
+  g_list_free_full (list->List, (GDestroyNotify)FreeAttribute);
+  memset (list, 0, sizeof (AttributeListType));
 }
 
 /* ---------------------------------------------------------------------------
  * frees memory used by an element
  */
 void
-FreeElementMemory (ElementTypePtr Element)
+FreeElementMemory (ElementType *element)
 {
-  if (Element)
-    {
-      ELEMENTNAME_LOOP (Element);
-      {
-	free (textstring);
-      }
-      END_LOOP;
-      PIN_LOOP (Element);
-      {
-	free (pin->Name);
-	free (pin->Number);
-      }
-      END_LOOP;
-      PAD_LOOP (Element);
-      {
-	free (pad->Name);
-	free (pad->Number);
-      }
-      END_LOOP;
-      free (Element->Pin);
-      free (Element->Pad);
-      free (Element->Line);
-      free (Element->Arc);
-      FreeAttributeListMemory (&Element->Attributes);
-      memset (Element, 0, sizeof (ElementType));
-    }
+  if (element == NULL)
+    return;
+
+  ELEMENTNAME_LOOP (element);
+  {
+    free (textstring);
+  }
+  END_LOOP;
+  PIN_LOOP (element);
+  {
+    free (pin->Name);
+    free (pin->Number);
+  }
+  END_LOOP;
+  PAD_LOOP (element);
+  {
+    free (pad->Name);
+    free (pad->Number);
+  }
+  END_LOOP;
+
+  g_list_free_full (element->Pin,  (GDestroyNotify)FreePin);
+  g_list_free_full (element->Pad,  (GDestroyNotify)FreePad);
+  g_list_free_full (element->Line, (GDestroyNotify)FreeLine);
+  g_list_free_full (element->Arc,  (GDestroyNotify)FreeArc);
+
+  FreeAttributeListMemory (&element->Attributes);
+  memset (element, 0, sizeof (ElementType));
 }
 
 /* ---------------------------------------------------------------------------
  * free memory used by PCB
  */
 void
-FreePCBMemory (PCBTypePtr PCBPtr)
+FreePCBMemory (PCBType *pcb)
 {
   int i;
 
-  if (PCBPtr)
-    {
-      free (PCBPtr->Name);
-      free (PCBPtr->Filename);
-      free (PCBPtr->PrintFilename);
-      if (PCBPtr->Data)
-	FreeDataMemory (PCBPtr->Data);
-      free (PCBPtr->Data);
-      /* release font symbols */
-      for (i = 0; i <= MAX_FONTPOSITION; i++)
-	free (PCBPtr->Font.Symbol[i].Line);
-      FreeLibraryMemory (&PCBPtr->NetlistLib);
-      FreeAttributeListMemory (&PCBPtr->Attributes);
-      /* clear struct */
-      memset (PCBPtr, 0, sizeof (PCBType));
-    }
-  else
-    {
-      fprintf (stderr, "Warning:  Tried to FreePCBMemory(null)\n");
-    }
+  if (pcb == NULL)
+    return;
+
+  free (pcb->Name);
+  free (pcb->Filename);
+  free (pcb->PrintFilename);
+  FreeDataMemory (pcb->Data);
+  free (pcb->Data);
+  /* release font symbols */
+  for (i = 0; i <= MAX_FONTPOSITION; i++)
+    free (pcb->Font.Symbol[i].Line);
+  FreeLibraryMemory (&pcb->NetlistLib);
+  FreeAttributeListMemory (&pcb->Attributes);
+  /* clear struct */
+  memset (pcb, 0, sizeof (PCBType));
 }
 
 /* ---------------------------------------------------------------------------
  * free memory used by data struct
  */
 void
-FreeDataMemory (DataTypePtr Data)
+FreeDataMemory (DataType *data)
 {
   LayerTypePtr layer;
   int i;
 
-  if (Data)
+  if (data == NULL)
+    return;
+
+  VIA_LOOP (data);
+  {
+    free (via->Name);
+  }
+  END_LOOP;
+  g_list_free_full (data->Via, (GDestroyNotify)FreeVia);
+  ELEMENT_LOOP (data);
+  {
+    FreeElementMemory (element);
+  }
+  END_LOOP;
+  g_list_free_full (data->Element, (GDestroyNotify)FreeElement);
+  g_list_free_full (data->Rat, (GDestroyNotify)FreeRat);
+
+  for (layer = data->Layer, i = 0; i < MAX_LAYER + 2; layer++, i++)
     {
-      VIA_LOOP (Data);
+      FreeAttributeListMemory (&layer->Attributes);
+      TEXT_LOOP (layer);
       {
-	free (via->Name);
+        free (text->TextString);
       }
       END_LOOP;
-      free (Data->Via);
-      ELEMENT_LOOP (Data);
+      if (layer->Name)
+        free (layer->Name);
+      LINE_LOOP (layer);
       {
-	FreeElementMemory (element);
+        if (line->Number)
+          free (line->Number);
       }
       END_LOOP;
-      free (Data->Element);
-      free (Data->Rat);
-
-      for (layer = Data->Layer, i = 0; i < MAX_LAYER + 2; layer++, i++)
-	{
-	  FreeAttributeListMemory (&layer->Attributes);
-	  TEXT_LOOP (layer);
-	  {
-	    free (text->TextString);
-	  }
-	  END_LOOP;
-	  if (layer->Name)
-	    free (layer->Name);
-	  LINE_LOOP (layer);
-	  {
-	    if (line->Number)
-	      free (line->Number);
-	  }
-	  END_LOOP;
-	  free (layer->Line);
-	  free (layer->Arc);
-	  free (layer->Text);
-	  POLYGON_LOOP (layer);
-	  {
-	    FreePolygonMemory (polygon);
-	  }
-	  END_LOOP;
-	  free (layer->Polygon);
-	  if (layer->line_tree)
-	    r_destroy_tree (&layer->line_tree);
-	  if (layer->arc_tree)
-	    r_destroy_tree (&layer->arc_tree);
-	  if (layer->text_tree)
-	    r_destroy_tree (&layer->text_tree);
-	  if (layer->polygon_tree)
-	    r_destroy_tree (&layer->polygon_tree);
-	}
-
-      if (Data->element_tree)
-	r_destroy_tree (&Data->element_tree);
-      for (i = 0; i < MAX_ELEMENTNAMES; i++)
-	if (Data->name_tree[i])
-	  r_destroy_tree (&Data->name_tree[i]);
-      if (Data->via_tree)
-	r_destroy_tree (&Data->via_tree);
-      if (Data->pin_tree)
-	r_destroy_tree (&Data->pin_tree);
-      if (Data->pad_tree)
-	r_destroy_tree (&Data->pad_tree);
-      if (Data->rat_tree)
-	r_destroy_tree (&Data->rat_tree);
-      /* clear struct */
-      memset (Data, 0, sizeof (DataType));
-    }
-  else
-    {
-      fprintf (stderr, "Warning:  Tried to FreeDataMemory(null)\n");
-    }
+      g_list_free_full (layer->Line, (GDestroyNotify)FreeLine);
+      g_list_free_full (layer->Arc, (GDestroyNotify)FreeArc);
+      g_list_free_full (layer->Text, (GDestroyNotify)FreeText);
+      POLYGON_LOOP (layer);
+      {
+        FreePolygonMemory (polygon);
+      }
+      END_LOOP;
+      g_list_free_full (layer->Polygon, (GDestroyNotify)FreePolygon);
+      if (layer->line_tree)
+        r_destroy_tree (&layer->line_tree);
+      if (layer->arc_tree)
+        r_destroy_tree (&layer->arc_tree);
+      if (layer->text_tree)
+        r_destroy_tree (&layer->text_tree);
+      if (layer->polygon_tree)
+        r_destroy_tree (&layer->polygon_tree);
+    }
+
+  if (data->element_tree)
+    r_destroy_tree (&data->element_tree);
+  for (i = 0; i < MAX_ELEMENTNAMES; i++)
+    if (data->name_tree[i])
+      r_destroy_tree (&data->name_tree[i]);
+  if (data->via_tree)
+    r_destroy_tree (&data->via_tree);
+  if (data->pin_tree)
+    r_destroy_tree (&data->pin_tree);
+  if (data->pad_tree)
+    r_destroy_tree (&data->pad_tree);
+  if (data->rat_tree)
+    r_destroy_tree (&data->rat_tree);
+  /* clear struct */
+  memset (data, 0, sizeof (DataType));
 }
 
 /* ---------------------------------------------------------------------------
  * releases the memory that's allocated by the library
  */
 void
-FreeLibraryMemory (LibraryTypePtr lib)
+FreeLibraryMemory (LibraryType *lib)
 {
-  MENU_LOOP (lib);
-  {
-    ENTRY_LOOP (menu);
-    {
-      free (entry->AllocatedMemory);
-      free (entry->ListEntry);
-    }
-    END_LOOP;
-    free (menu->Entry);
-    free (menu->Name);
-  }
-  END_LOOP;
-  free (lib->Menu);
-
-  /* clear struct */
-  memset (lib, 0, sizeof (LibraryType));
+  g_list_free_full (lib->Menu, (GDestroyNotify)FreeLibraryMenu);
 }
 
 /* ---------------------------------------------------------------------------
diff --git a/src/mymem.h b/src/mymem.h
index 4e36640..b7bbd16 100644
--- a/src/mymem.h
+++ b/src/mymem.h
@@ -38,32 +38,6 @@
 #include <stdlib.h>
 #include "global.h"
 
-/* ---------------------------------------------------------------------------
- * number of additional objects that are allocated with one system call
- */
-#define	STEP_VIA			2000	/* block size for realloc() calls */
-#define	STEP_PIN			20
-#define	STEP_PAD			20
-#define	STEP_LINE			10000
-#define STEP_ARC			1000
-#define	STEP_ELEMENTLINE	10
-#define	STEP_ELEMENTARC		5
-#define	STEP_TEXT			50
-#define	STEP_ELEMENT		50
-#define STEP_DRILL		30
-#define STEP_POINT		100
-#define	STEP_SYMBOLLINE		10
-#define	STEP_SELECTORENTRY	128
-#define	STEP_REMOVELIST		500
-#define	STEP_UNDOLIST		500
-#define	STEP_POLYGON		10
-#define	STEP_POLYGONPOINT	10
-#define	STEP_POLYGONHOLEINDEX	10
-#define	STEP_LIBRARYMENU	10
-#define	STEP_LIBRARYENTRY	20
-#define	STEP_RUBBERBAND		100
-#define STEP_RAT		2000
-
 #define STRDUP(x) (((x) != NULL) ? strdup (x) : NULL)
 
 /* ---------------------------------------------------------------------------
@@ -96,8 +70,12 @@ LibraryEntryTypePtr GetLibraryEntryMemory (LibraryMenuTypePtr);
 ElementTypeHandle GetDrillElementMemory (DrillTypePtr);
 PinTypeHandle GetDrillPinMemory (DrillTypePtr);
 DrillTypePtr GetDrillInfoDrillMemory (DrillInfoTypePtr);
+void FreeDrillInfo (DrillInfoTypePtr);
 void **GetPointerMemory (PointerListTypePtr);
+AttributeTypePtr GetAttributeMemory (AttributeListTypePtr);
+void FreeAttribute (AttributeTypePtr);
 void FreePolygonMemory (PolygonTypePtr);
+void FreeAttributeListMemory (AttributeListTypePtr);
 void FreeElementMemory (ElementTypePtr);
 void FreePCBMemory (PCBTypePtr);
 void FreeBoxListMemory (BoxListTypePtr);
diff --git a/src/parse_y.y b/src/parse_y.y
index d0f31aa..ad8cb44 100644
--- a/src/parse_y.y
+++ b/src/parse_y.y
@@ -171,7 +171,6 @@ parsepcb
 		  pcbdata
 		  pcbnetlist
 			{
-			  int i, j;
 			  PCBTypePtr pcb_save = PCB;
 
 			  if (layer_group_string == NULL)
@@ -186,9 +185,11 @@ parsepcb
 			 * we didn't know the layer grouping before.
 			 */
 			PCB = yyPCB;
-			for (i = 0; i < yyData->LayerN+2; i++)
-			  for (j = 0; j < yyData->Layer[i].PolygonN; j++)
-			      InitClip (yyData, &yyData->Layer[i], &yyData->Layer[i].Polygon[j]);
+			ALLPOLYGON_LOOP (yyData);
+			{
+			  InitClip (yyData, layer, polygon);
+			}
+			ENDALL_LOOP;
 			PCB = pcb_save;
 			}
 			   
diff --git a/src/report.c b/src/report.c
index 5131ec6..5890c16 100644
--- a/src/report.c
+++ b/src/report.c
@@ -335,8 +335,7 @@ ReportDialog (int argc, char **argv, int x, int y)
 
 	sprintf (&report[0], "POLYGON ID# %ld;  Flags:%s\n"
 		 "Its bounding box is (%.*f,%.*f) (%.*f,%.*f) %s.\n"
-		 "It has %d points and could store %d more\n"
-		 "  without using more memory.\n"
+		 "It has %d points.\n"
 		 "It has %d holes and resides on layer %d.\n"
 		 "%s", Polygon->ID,
 		 flags_to_string (Polygon->Flags, POLYGON_TYPE),
@@ -344,7 +343,7 @@ ReportDialog (int argc, char **argv, int x, int y)
 		 prec, units(Polygon->BoundingBox.Y1),
 		 prec, units(Polygon->BoundingBox.X2),
 		 prec, UNIT(Polygon->BoundingBox.Y2),
-		 Polygon->PointN, Polygon->PointMax - Polygon->PointN,
+		 Polygon->PointN,
 		 Polygon->HoleIndexN,
 		 GetLayerNumber (PCB->Data, (LayerTypePtr) ptr1),
 		 TEST_FLAG (LOCKFLAG, Polygon) ? "It is LOCKED.\n" : "");
diff --git a/src/select.c b/src/select.c
index e42d4bb..48261a9 100644
--- a/src/select.c
+++ b/src/select.c
@@ -1022,18 +1022,20 @@ SelectObjectByName (int Type, char *Pattern, bool Flag)
 
       MENU_LOOP (&PCB->NetlistLib);
       {
-        Cardinal i;
-        LibraryEntryType *entry;
+        GList *i;
         ConnectionType conn;
 
         /* Name[0] and Name[1] are special purpose, not the actual name*/
         if (menu->Name && menu->Name[0] != '\0' && menu->Name[1] != '\0' &&
             REGEXEC (menu->Name + 2))
           {
-            for (i = menu->EntryN, entry = menu->Entry; i; i--, entry++)
-              if (SeekPad (entry, &conn, false))
-                RatFindHook (conn.type, conn.ptr1, conn.ptr2, conn.ptr2,
-                             true, true);
+            for (i = menu->Entry; i != NULL; i = g_list_next (i))
+              {
+                LibraryEntryType *entry = i->data;
+                if (SeekPad (entry, &conn, false))
+                  RatFindHook (conn.type, conn.ptr1, conn.ptr2, conn.ptr2,
+                               true, true);
+              }
           }
       }
       END_LOOP;
diff --git a/src/toporouter.c b/src/toporouter.c
index 3590472..75006c5 100644
--- a/src/toporouter.c
+++ b/src/toporouter.c
@@ -2804,7 +2804,8 @@ import_clusters(toporouter_t *r)
   NETLIST_LOOP(&nets);
   {
     if(netlist->NetN > 0) {
-      toporouter_netlist_t *nl = netlist_create(r, netlist->Net->Connection->menu->Name, netlist->Net->Connection->menu->Style);
+      toporouter_netlist_t *nl = netlist_create(r, ((ConnectionType *)(((NetType *)(netlist->Net->data))->Connection->data))->menu->Name,
+                                                   ((ConnectionType *)(((NetType *)(netlist->Net->data))->Connection->data))->menu->Style);
       
       NET_LOOP(netlist);
       {
@@ -7986,9 +7987,13 @@ escape (int argc, char **argv, int x, int y)
     if( TEST_FLAG(SELECTEDFLAG, pad) ) {
       PinTypePtr via;
       LineTypePtr line;
+      PadType *pad0, *pad1;
 
-      pitch = sqrt( pow(abs(element->Pad[0].Point1.X - element->Pad[1].Point1.X), 2) + 
-        pow(abs(element->Pad[0].Point1.Y - element->Pad[1].Point1.Y), 2) );
+      pad0 = element->Pad->data;
+      pad1 = g_list_next (element->Pad)->data;
+
+      pitch = sqrt (pow (abs (pad0->Point1.X - pad1->Point1.X), 2) +
+                    pow (abs (pad0->Point1.Y - pad1->Point1.Y), 2) );
       length = sqrt(pow(pitch,2) + pow(pitch,2)) / 2.;
 
       dx = length * sin(M_PI/4.);
diff --git a/src/undo.c b/src/undo.c
index 21b86f4..843527c 100644
--- a/src/undo.c
+++ b/src/undo.c
@@ -164,7 +164,7 @@ UndoListType, *UndoListTypePtr;
  * some local variables
  */
 static DataTypePtr RemoveList = NULL;	/* list of removed objects */
-static UndoListTypePtr UndoList = NULL;	/* list of operations */
+static GList *UndoList = NULL;	/* list of operations */
 static int Serial = 1,		/* serial number */
   SavedSerial;
 static size_t UndoN, RedoN,	/* number of entries */
@@ -202,13 +202,15 @@ static int PerformUndo (UndoListTypePtr);
 /* ---------------------------------------------------------------------------
  * adds a command plus some data to the undo list
  */
-static UndoListTypePtr
+static UndoListType *
 GetUndoSlot (int CommandType, int ID, int Kind)
 {
-  UndoListTypePtr ptr;
+  UndoListType *ptr;
   void *ptr1, *ptr2, *ptr3;
   int type;
   static size_t limit = UNDO_WARNING_SIZE;
+  size_t size;
+  GList *iter;
 
 #ifdef DEBUG_ID
   if (SearchObjectByID (PCB->Data, &ptr1, &ptr2, &ptr3, ID, Kind) == NO_TYPE)
@@ -216,53 +218,59 @@ GetUndoSlot (int CommandType, int ID, int Kind)
 	     Kind);
 #endif
 
-  /* allocate memory */
-  if (UndoN >= UndoMax)
+  size = UndoN * sizeof (UndoListType);
+
+  /* ask user to flush the table because of it's size */
+  if (size > limit)
     {
-      size_t size;
+      limit = (size / UNDO_WARNING_SIZE + 1) * UNDO_WARNING_SIZE;
+      Message (_("Size of 'undo-list' exceeds %li kb\n"),
+               (long) (size >> 10));
+    }
 
-      UndoMax += STEP_UNDOLIST;
-      size = UndoMax * sizeof (UndoListType);
-      UndoList = (UndoListTypePtr) realloc (UndoList, size);
-      memset (&UndoList[UndoN], 0, STEP_REMOVELIST * sizeof (UndoListType));
+  /* free structures from the pruned redo list */
 
-      /* ask user to flush the table because of it's size */
-      if (size > limit)
-	{
-	  limit = (size / UNDO_WARNING_SIZE + 1) * UNDO_WARNING_SIZE;
-	  Message (_("Size of 'undo-list' exceeds %li kb\n"),
-		   (long) (size >> 10));
-	}
+  for (iter = g_list_nth (UndoList, UndoN);
+       iter != NULL; iter = g_list_next (iter), RedoN--)
+    {
+      ptr = iter->data;
+
+      switch (ptr->Type)
+        {
+        case UNDO_CHANGENAME:
+          free (ptr->Data.ChangeName.Name);
+          break;
+        case UNDO_REMOVE:
+          type =
+            SearchObjectByID (RemoveList, &ptr1, &ptr2, &ptr3, ptr->ID,
+                              ptr->Kind);
+          if (type != NO_TYPE)
+            {
+              DestroyObject (RemoveList, type, ptr1, ptr2, ptr3);
+            }
+          break;
+        default:
+          break;
+        }
+      g_slice_free (UndoListType, ptr);
     }
 
-  /* free structures from the pruned redo list */
+  /* Break off and free the pruned redo list */
+  iter = g_list_nth (UndoList, UndoN);
+  iter->prev->next = NULL;
+  iter->prev = NULL;
 
-  for (ptr = &UndoList[UndoN]; RedoN; ptr++, RedoN--)
-    switch (ptr->Type)
-      {
-      case UNDO_CHANGENAME:
-	free (ptr->Data.ChangeName.Name);
-	break;
-      case UNDO_REMOVE:
-	type =
-	  SearchObjectByID (RemoveList, &ptr1, &ptr2, &ptr3, ptr->ID,
-			    ptr->Kind);
-	if (type != NO_TYPE)
-	  {
-	    DestroyObject (RemoveList, type, ptr1, ptr2, ptr3);
-	  }
-	break;
-      default:
-	break;
-      }
+  g_list_free (iter);
 
   /* copy typefield and serial number to the list */
-  ptr = &UndoList[UndoN++];
+  ptr = g_slice_new0 (UndoListType);
+  UndoList = g_list_append (UndoList, ptr);
+
   ptr->Type = CommandType;
   ptr->Kind = Kind;
   ptr->ID = ID;
   ptr->Serial = Serial;
-  return (ptr);
+  return ptr;
 }
 
 /* ---------------------------------------------------------------------------
@@ -901,50 +909,35 @@ static bool
 UndoNetlistChange (UndoListTypePtr Entry)
 {
   NetlistChangeTypePtr l = & Entry->Data.NetlistChange;
-  unsigned int i, j;
+  GList *i, *j;
   LibraryTypePtr lib, saved;
 
   lib = l->lib;
   saved = l->old;
 
   /* iterate over each net */
-  for (i = 0 ; i < lib->MenuN; i++)
+  for (i = lib->Menu; i != NULL; i = g_list_next (i))
     {
-      if (lib->Menu[i].Name)
-	free (lib->Menu[i].Name);
+      LibraryMenuType *menu = i->data;
 
-      if (lib->Menu[i].directory)
-	free (lib->Menu[i].directory);
-
-      if (lib->Menu[i].Style)
-	free (lib->Menu[i].Style);
+      free (menu->Name);
+      free (menu->directory);
+      free (menu->Style);
 
       /* iterate over each pin on the net */
-      for (j = 0; j < lib->Menu[i].EntryN; j++) {
-	
-	if (lib->Menu[i].Entry[j].ListEntry)
-	  free (lib->Menu[i].Entry[j].ListEntry);
-	
-	if (lib->Menu[i].Entry[j].AllocatedMemory)
-	  free (lib->Menu[i].Entry[j].AllocatedMemory);
-	
-	if (lib->Menu[i].Entry[j].Template)
-	  free (lib->Menu[i].Entry[j].Template);
-	
-	if (lib->Menu[i].Entry[j].Package)
-	  free (lib->Menu[i].Entry[j].Package);
-	
-	if (lib->Menu[i].Entry[j].Value)
-	  free (lib->Menu[i].Entry[j].Value);
-	
-	if (lib->Menu[i].Entry[j].Description)
-	  free (lib->Menu[i].Entry[j].Description);
-	
+      for (j = menu->Entry; j != NULL; j = g_list_next (j)) {
+        LibraryEntryType *entry = j->data;
+
+        free (entry->ListEntry);
+        free (entry->AllocatedMemory);
+        free (entry->Template);
+        free (entry->Package);
+        free (entry->Value);
+        free (entry->Description);
       }
     }
 
-  if (lib->Menu)
-    free (lib->Menu);
+  free (lib->Menu);
 
   *lib = *saved;
 
@@ -1620,7 +1613,8 @@ void
 AddNetlistLibToUndoList (LibraryTypePtr lib)
 {
   UndoListTypePtr undo;
-  unsigned int i, j;
+  int i, j;
+  GList *ii, *jj;
   LibraryTypePtr old;
   
   if (!Locked)
@@ -1633,7 +1627,6 @@ AddNetlistLibToUndoList (LibraryTypePtr lib)
       undo->Data.NetlistChange.old = (LibraryTypePtr)malloc (sizeof (LibraryTypePtr));
       old = undo->Data.NetlistChange.old;
       old->MenuN = lib->MenuN;
-      old->MenuMax = lib->MenuMax;
       old->Menu = (LibraryMenuTypePtr)malloc (old->MenuMax * sizeof (LibraryMenuType));
       if (old->Menu == NULL)
 	{
@@ -1642,21 +1635,15 @@ AddNetlistLibToUndoList (LibraryTypePtr lib)
 	}
 
       /* iterate over each net */
-      for (i = 0 ; i < lib->MenuN; i++)
+      for (ii = liib->Menu, i = 0; ii != NULL; ii = g_liist_next (ii), i++)
 	{
-	  old->Menu[i].EntryN = lib->Menu[i].EntryN;
-	  old->Menu[i].EntryMax = lib->Menu[i].EntryMax;
+	  MenuType *menu = ii->data;
 
-	  old->Menu[i].Name = 
-	    lib->Menu[i].Name ? strdup (lib->Menu[i].Name) : NULL;
-	  
-	  old->Menu[i].directory = 
-	    lib->Menu[i].directory ? strdup (lib->Menu[i].directory) : NULL;
-	  
-	  old->Menu[i].Style = 
-	    lib->Menu[i].Style ? strdup (lib->Menu[i].Style) : NULL;
+	  old->Menu[i].EntryN = menu->EntryN;
+	  old->Menu[i].Name = menu->Name ? strdup (menu->Name) : NULL;
+	  old->Menu[i].directory = menu->directory ? strdup (menu->directory) : NULL;
+	  old->Menu[i].Style = menu->Style ? strdup (menu->Style) : NULL;
 
-      
 	  old->Menu[i].Entry = 
 	    (LibraryEntryTypePtr)malloc (old->Menu[i].EntryMax * sizeof (LibraryEntryType));
 	  if (old->Menu[i].Entry == NULL)
@@ -1666,39 +1653,19 @@ AddNetlistLibToUndoList (LibraryTypePtr lib)
 	    }
 	  
 	  /* iterate over each pin on the net */
-	  for (j = 0; j < lib->Menu[i].EntryN; j++) {
-
-	    old->Menu[i].Entry[j].ListEntry = 
-	      lib->Menu[i].Entry[j].ListEntry ? 
-	      strdup (lib->Menu[i].Entry[j].ListEntry) :
-	      NULL;
-
-	    old->Menu[i].Entry[j].AllocatedMemory = 
-	      lib->Menu[i].Entry[j].AllocatedMemory ? 
-	      strdup (lib->Menu[i].Entry[j].AllocatedMemory) :
-	      NULL;
-
-	    old->Menu[i].Entry[j].Template = 
-	      lib->Menu[i].Entry[j].Template ? 
-	      strdup (lib->Menu[i].Entry[j].Template) :
-	      NULL;
-
-	    old->Menu[i].Entry[j].Package = 
-	      lib->Menu[i].Entry[j].Package ? 
-	      strdup (lib->Menu[i].Entry[j].Package) :
-	      NULL;
-
-	    old->Menu[i].Entry[j].Value = 
-	      lib->Menu[i].Entry[j].Value ? 
-	      strdup (lib->Menu[i].Entry[j].Value) :
-	      NULL;
-
-	    old->Menu[i].Entry[j].Description = 
-	      lib->Menu[i].Entry[j].Description ? 
-	      strdup (lib->Menu[i].Entry[j].Description) :
-	      NULL;
-	    
-
+	  for (jj = menu->Entry, j = 0; jj != NULL; jj = g_list_next (jj), j++) {
+            LibraryEntryType *entry = jj->data;
+
+	    old->Menu[i].Entry[j].ListEntry =
+              entry->ListEntry ? strdup (entry->ListEntry) : NULL;
+	    old->Menu[i].Entry[j].AllocatedMemory =
+              entry->AllocatedMemory ? strdup (entry->AllocatedMemory) : NULL;
+	    old->Menu[i].Entry[j].Template =
+	      entry->Template ? strdup (entry->Template) : NULL;
+	    old->Menu[i].Entry[j].Package = entry->Package ? strdup (entry->Package) : NULL;
+	    old->Menu[i].Entry[j].Value = entry->Value ? strdup (entry->Value) : NULL;
+	    old->Menu[i].Entry[j].Description =
+              entry->Description ? strdup (entry->Description) : NULL;
 	  }
 	}

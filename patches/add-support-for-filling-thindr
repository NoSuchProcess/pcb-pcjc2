Bottom: 0a13b292a799445fc333dfc4cc3636ffc6822fb9
Top:    6979d018d06ccb16c61579c284e2fba19834873a
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-02-21 17:51:54 +0000

Add support for filling / thindrawing raw polygons to the HID interface

Refactor core polygon drawing to use these member functions, and split
the old code which used the HID's fill_polygon and draw_line functions
into a helper function which the guis now use to convert the polygon
into the primitives it knows how to draw.

Alter the NoHoles dicer to pass back PLINE contours, rather than
wrapping them in a POLYAREA and PolygonType.


---

diff --git a/src/Makefile.am b/src/Makefile.am
index 3d3fd0f..c786e00 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -143,6 +143,8 @@ PCB_SRCS = \
 	hid/common/hidinit.c \
 	hid/common/hidnogui.c \
 	hid/common/extents.c \
+	hid/common/draw_helpers.c \
+	hid/common/draw_helpers.h \
 	hid/hidint.h 
 pcb_SOURCES = ${PCB_SRCS} core_lists.h
 
diff --git a/src/dbus.c b/src/dbus.c
index 653d294..b3bb007 100644
--- a/src/dbus.c
+++ b/src/dbus.c
@@ -29,7 +29,7 @@
 #include "dbus.h"
 #include "dbus-pcbmain.h"
 #include "dbus-introspect.h"
-#include "hid.h"
+#include "global.h"
 #include "data.h"
 
 /* For lrealpath */
diff --git a/src/draw.c b/src/draw.c
index 3da0bf9..1d902b2 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -44,7 +44,6 @@
 #include "error.h"
 #include "mymem.h"
 #include "misc.h"
-#include "polygon.h"
 #include "rotate.h"
 #include "rtree.h"
 #include "search.h"
@@ -1681,41 +1680,16 @@ DrawTextLowLevel (TextTypePtr Text, int min_line_width)
 static void
 DrawPolygonLowLevel (PolygonTypePtr Polygon)
 {
-  int *x, *y, n, i = 0;
-  PLINE *pl;
-  VNODE *v;
   if (!Polygon->Clipped)
     return;
+
   if (Gathering)
     {
       AddPart (Polygon);
       return;
     }
-  pl = Polygon->Clipped->contours;
-  n = pl->Count;
-  x = (int *) malloc (n * sizeof (int));
-  y = (int *) malloc (n * sizeof (int));
-  for (v = &pl->head; i < n; v = v->next)
-    {
-      x[i] = v->point[0];
-      y[i++] = v->point[1];
-    }
-  if (TEST_FLAG (THINDRAWFLAG, PCB)
-      || TEST_FLAG (THINDRAWPOLYFLAG, PCB))
-    {
-      gui->set_line_width (Output.fgGC, 0);
-      gui->set_line_cap (Output.fgGC, Round_Cap);
-      for (i = 0; i < n - 1; i++)
-	{
-	  gui->draw_line (Output.fgGC, x[i], y[i], x[i + 1], y[i + 1]);
-	  //  gui->fill_circle (Output.fgGC, x[i], y[i], 30);
-	}
-      gui->draw_line (Output.fgGC, x[n - 1], y[n - 1], x[0], y[0]);
-    }
-  else
-    gui->fill_polygon (Output.fgGC, n, x, y);
-  free (x);
-  free (y);
+
+  printf ("DrawPolygonLowLevel: Called without Gathering set!\n");
 }
 
 /* ---------------------------------------------------------------------------
@@ -2104,68 +2078,43 @@ thin_callback (PLINE * pl, LayerTypePtr lay, PolygonTypePtr poly)
 static void
 DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
 {
-  if (TEST_FLAG (SELECTEDFLAG | FOUNDFLAG, Polygon))
+  static char *color;
+
+  if (!Polygon->Clipped)
+    return;
+
+  if (Gathering)
     {
-      if (TEST_FLAG (SELECTEDFLAG, Polygon))
-	gui->set_color (Output.fgGC, Layer->SelectedColor);
-      else
-	gui->set_color (Output.fgGC, PCB->ConnectedColor);
+      AddPart (Polygon);
+      return;
     }
+
+  if (TEST_FLAG (SELECTEDFLAG, Polygon))
+    color = Layer->SelectedColor;
+  else if (TEST_FLAG (FOUNDFLAG, Polygon))
+    color = PCB->ConnectedColor;
   else
-    gui->set_color (Output.fgGC, Layer->Color);
-  /* if the gui has the dicer flag set then it won't accept thin draw */
-  if ((TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG (THINDRAWPOLYFLAG, PCB))
-      && !gui->poly_dicer)
-    {
-      DrawPolygonLowLevel (Polygon);
-      if (!Gathering)
-	PolygonHoles (clip_box, Layer, Polygon, thin_callback);
-    }
-  else if (Polygon->Clipped)
-    {
-      NoHolesPolygonDicer (Polygon, clip_box, DrawPolygonLowLevel, NULL);
-      /* draw other parts of the polygon if fullpoly flag is set */
-      if (TEST_FLAG (FULLPOLYFLAG, Polygon))
-	{
-	  POLYAREA *pg;
-	  for (pg = Polygon->Clipped->f; pg != Polygon->Clipped; pg = pg->f)
-	    {
-	      PolygonType poly;
-	      poly.Clipped = pg;
-	      NoHolesPolygonDicer (&poly, clip_box, DrawPolygonLowLevel, NULL);
-	    }
-	}
-    }
-  /* if the gui has the dicer flag set then it won't draw missing poly outlines */
-  if (TEST_FLAG (CHECKPLANESFLAG, PCB) && Polygon->Clipped && !Gathering
-      && !gui->poly_dicer)
+    color = Layer->Color;
+  gui->set_color (Output.fgGC, color);
+
+  if (gui->thindraw_pcb_polygon != NULL &&
+      (TEST_FLAG (THINDRAWFLAG, PCB) ||
+       TEST_FLAG (THINDRAWPOLYFLAG, PCB)))
+    gui->thindraw_pcb_polygon (Output.fgGC, Polygon, clip_box);
+  else
+    gui->fill_pcb_polygon (Output.fgGC, Polygon, clip_box);
+
+  /* If checking planes, thin-draw any pieces which have been clipped away */
+  if (gui->thindraw_pcb_polygon != NULL &&
+      TEST_FLAG (CHECKPLANESFLAG, PCB) &&
+      !TEST_FLAG (FULLPOLYFLAG, Polygon))
     {
-      POLYAREA *pg;
+      PolygonType poly = *Polygon;
 
-      for (pg = Polygon->Clipped->f; pg != Polygon->Clipped; pg = pg->f)
-	{
-	  VNODE *v;
-	  PLINE *pl = pg->contours;
-	  int i = 0;
-	  int n = pl->Count;
-	  int *x = (int *) malloc (n * sizeof (int));
-	  int *y = (int *) malloc (n * sizeof (int));
-	  for (v = &pl->head; i < n; v = v->next)
-	    {
-	      x[i] = v->point[0];
-	      y[i++] = v->point[1];
-	    }
-	  gui->set_line_width (Output.fgGC, 0);
-	  gui->set_line_cap (Output.fgGC, Round_Cap);
-	  for (i = 0; i < n - 1; i++)
-	    {
-	      gui->draw_line (Output.fgGC, x[i], y[i], x[i + 1], y[i + 1]);
-	      /* gui->fill_circle (Output.bgGC, x[i], y[i], 10); */
-	    }
-	  gui->draw_line (Output.fgGC, x[n - 1], y[n - 1], x[0], y[0]);
-	  free (x);
-	  free (y);
-	}
+      for (poly.Clipped = Polygon->Clipped->f;
+           poly.Clipped != Polygon->Clipped;
+           poly.Clipped = poly.Clipped->f)
+        gui->thindraw_pcb_polygon (Output.fgGC, &poly, clip_box);
     }
 }
 
diff --git a/src/global.h b/src/global.h
index 767808f..93af49b 100644
--- a/src/global.h
+++ b/src/global.h
@@ -51,6 +51,9 @@
 #include <ctype.h>
 #include <sys/types.h>
 
+typedef struct BoxType BoxType, *BoxTypePtr;
+typedef struct polygon_st PolygonType, *PolygonTypePtr;
+
 #include "hid.h"
 
 #define _(S) (S)
@@ -137,11 +140,11 @@ typedef struct
     Entries[MAX_LAYER][MAX_LAYER + 2];
 } LayerGroupType, *LayerGroupTypePtr;
 
-typedef struct BoxType		/* a bounding box */
+struct BoxType		/* a bounding box */
 {
   LocationType X1, Y1,		/* upper left */
     X2, Y2;			/* and lower right corner */
-} BoxType, *BoxTypePtr;
+};
 
 typedef struct
 {
@@ -199,14 +202,14 @@ typedef struct
   void *Element;
 } TextType, *TextTypePtr;
 
-typedef struct			/* holds information about a polygon */
+struct polygon_st			/* holds information about a polygon */
 {
   ANYOBJECTFIELDS;
   Cardinal PointN,		/* number of points in polygon */
     PointMax;			/* max number from malloc() */
   POLYAREA *Clipped;		/* the clipped region of this polygon */
   PointTypePtr Points;		/* data */
-} PolygonType, *PolygonTypePtr;
+};
 
 typedef struct			/* holds information about arcs */
 {
diff --git a/src/hid.h b/src/hid.h
index a7e156d..f01b43f 100644
--- a/src/hid.h
+++ b/src/hid.h
@@ -357,6 +357,10 @@ typedef enum
     void (*draw_rect) (hidGC gc_, int x1_, int y1_, int x2_, int y2_);
     void (*fill_circle) (hidGC gc_, int cx_, int cy_, int radius_);
     void (*fill_polygon) (hidGC gc_, int n_coords_, int *x_, int *y_);
+    void (*fill_pcb_polygon) (hidGC gc_, PolygonType *poly,
+                              const BoxType *clip_box);
+    void (*thindraw_pcb_polygon) (hidGC gc_, PolygonType *poly,
+                                  const BoxType *clip_box);
     void (*fill_rect) (hidGC gc_, int x1_, int y1_, int x2_, int y2_);
 
 
diff --git a/src/hid/batch/batch.c b/src/hid/batch/batch.c
index 1579c6e..3e80139 100644
--- a/src/hid/batch/batch.c
+++ b/src/hid/batch/batch.c
@@ -284,6 +284,16 @@ batch_fill_polygon (hidGC gc, int n_coords, int *x, int *y)
 }
 
 static void
+batch_fill_pcb_polygon (hidGC gc, PolygonType *poly)
+{
+}
+
+static void
+batch_thindraw_pcb_polygon (hidGC gc, PolygonType *poly)
+{
+}
+
+static void
 batch_fill_rect (hidGC gc, int x1, int y1, int x2, int y2)
 {
 }
@@ -473,6 +483,8 @@ HID batch_gui = {
   batch_draw_rect,
   batch_fill_circle,
   batch_fill_polygon,
+  batch_fill_pcb_polygon,
+  batch_thindraw_pcb_polygon,
   batch_fill_rect,
   batch_calibrate,
   batch_shift_is_pressed,
diff --git a/src/hid/bom/bom.c b/src/hid/bom/bom.c
index 059e84e..18fca46 100644
--- a/src/hid/bom/bom.c
+++ b/src/hid/bom/bom.c
@@ -562,6 +562,8 @@ HID bom_hid = {
   0,				/* bom_draw_rect */
   0,				/* bom_fill_circle */
   0,				/* bom_fill_polygon */
+  0,				/* bom_fill_pcb_polygon */
+  0,				/* bom_thindraw_pcb_polygon */
   0,				/* bom_fill_rect */
   0,				/* bom_calibrate */
   0,				/* bom_shift_is_pressed */
diff --git a/src/hid/common/draw_helpers.c b/src/hid/common/draw_helpers.c
new file mode 100644
index 0000000..1b7c6b7
--- /dev/null
+++ b/src/hid/common/draw_helpers.c
@@ -0,0 +1,97 @@
+#include "global.h"
+#include "hid.h"
+#include "polygon.h"
+
+static void fill_contour (hidGC gc, PLINE *pl)
+{
+  int *x, *y, n, i = 0;
+  VNODE *v;
+
+  n = pl->Count;
+  x = malloc (n * sizeof (int));
+  y = malloc (n * sizeof (int));
+
+  for (v = &pl->head; i < n; v = v->next)
+    {
+      x[i] = v->point[0];
+      y[i++] = v->point[1];
+    }
+
+  gui->fill_polygon (gc, n, x, y);
+
+  free (x);
+  free (y);
+}
+
+static void thindraw_contour (hidGC gc, PLINE *pl)
+{
+  VNODE *v;
+  int last_x, last_y;
+  int this_x, this_y;
+
+  /* Need at least two points in the contour */
+  if (pl->head.next == NULL)
+    return;
+
+  gui->set_line_width (gc, 0);
+  gui->set_line_cap (gc, Round_Cap);
+
+  last_x = pl->head.point[0];
+  last_y = pl->head.point[1];
+  v = pl->head.next;
+
+  do
+    {
+      this_x = v->point[0];
+      this_y = v->point[1];
+
+      gui->draw_line (gc, last_x, last_y, this_x, this_y);
+      // gui->fill_circle (gc, this_x, this_y, 30);
+
+      last_x = this_x;
+      last_y = this_y;
+    }
+  while ((v = v->next) != pl->head.next);
+}
+
+static void fill_contour_cb (PLINE *pl, void *user_data)
+{
+  hidGC gc = user_data;
+  fill_contour (gc, pl);
+}
+
+void common_fill_pcb_polygon (hidGC gc, PolygonType *poly,
+                              const BoxType *clip_box)
+{
+  /* FIXME: We aren't checking the gui's dicer flag..
+            we are dicing for every case. Some GUIs
+            rely on this, and need their flags fixing. */
+
+  NoHolesPolygonDicer (poly, clip_box, fill_contour_cb, gc);
+
+  /* Draw other parts of the polygon if fullpoly flag is set */
+  if (TEST_FLAG (FULLPOLYFLAG, poly))
+    {
+      PolygonType p = *poly;
+
+      for (p.Clipped = poly->Clipped->f;
+           p.Clipped != poly->Clipped;
+           p.Clipped = p.Clipped->f)
+        NoHolesPolygonDicer (&p, clip_box, fill_contour_cb, gc);
+    }
+
+}
+
+static int thindraw_hole_cb (PLINE *pl, void *user_data)
+{
+  hidGC gc = user_data;
+  thindraw_contour (gc, pl);
+  return 0;
+}
+
+void common_thindraw_pcb_polygon (hidGC gc, PolygonType *poly,
+                                  const BoxType *clip_box)
+{
+  thindraw_contour (gc, poly->Clipped->contours);
+  PolygonHoles (poly, clip_box, thindraw_hole_cb, gc);
+}
diff --git a/src/hid/common/draw_helpers.h b/src/hid/common/draw_helpers.h
new file mode 100644
index 0000000..3705317
--- /dev/null
+++ b/src/hid/common/draw_helpers.h
@@ -0,0 +1,4 @@
+void common_fill_pcb_polygon (hidGC gc, PolygonType *poly,
+                              const BoxType *clip_box);
+void common_thindraw_pcb_polygon (hidGC gc, PolygonType *poly,
+                                  const BoxType *clip_box);
diff --git a/src/hid/common/extents.c b/src/hid/common/extents.c
index 58aa756..60a7174 100644
--- a/src/hid/common/extents.c
+++ b/src/hid/common/extents.c
@@ -14,6 +14,7 @@
 
 #include "hid.h"
 #include "../hidint.h"
+#include "hid/common/draw_helpers.h"
 
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
@@ -202,6 +203,8 @@ static HID extents_hid = {
   extents_draw_rect,
   extents_fill_circle,
   extents_fill_polygon,
+  common_fill_pcb_polygon,
+  0 /* extents_thindraw_pcb_polygon */,
   extents_fill_rect,
 
   0 /* extents_calibrate */ ,
diff --git a/src/hid/common/hidinit.c b/src/hid/common/hidinit.c
index 846cb4f..9581d32 100644
--- a/src/hid/common/hidinit.c
+++ b/src/hid/common/hidinit.c
@@ -21,6 +21,7 @@
 #include <windows.h>
 #endif
 
+#include "global.h"
 #include "hid.h"
 #include "../hidint.h"
 
diff --git a/src/hid/common/hidnogui.c b/src/hid/common/hidnogui.c
index 458d16a..28b2168 100644
--- a/src/hid/common/hidnogui.c
+++ b/src/hid/common/hidnogui.c
@@ -159,6 +159,19 @@ nogui_fill_polygon (hidGC gc, int n_coords, int *x, int *y)
 }
 
 static void
+nogui_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+{
+  CRASH;
+}
+
+static void
+nogui_thindraw_pcb_polygon (hidGC gc, PolygonType *poly,
+                            const BoxType *clip_box)
+{
+  CRASH;
+}
+
+static void
 nogui_fill_rect (hidGC gc, int x1, int y1, int x2, int y2)
 {
   CRASH;
@@ -364,6 +377,8 @@ HID hid_nogui = {
   nogui_draw_rect,
   nogui_fill_circle,
   nogui_fill_polygon,
+  nogui_fill_pcb_polygon,
+  nogui_thindraw_pcb_polygon,
   nogui_fill_rect,
   nogui_calibrate,
   nogui_shift_is_pressed,
@@ -415,6 +430,8 @@ apply_default_hid (HID * d, HID * s)
   AD (draw_arc);
   AD (fill_circle);
   AD (fill_polygon);
+  AD (fill_pcb_polygon);
+  AD (thindraw_pcb_polygon);
   AD (calibrate);
   AD (shift_is_pressed);
   AD (control_is_pressed);
diff --git a/src/hid/gerber/gerber.c b/src/hid/gerber/gerber.c
index 1557228..7fc62f9 100644
--- a/src/hid/gerber/gerber.c
+++ b/src/hid/gerber/gerber.c
@@ -28,6 +28,7 @@
 
 #include "hid.h"
 #include "../hidint.h"
+#include "hid/common/draw_helpers.h"
 
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
@@ -1095,6 +1096,8 @@ static HID gerber_hid = {
   gerber_draw_rect,
   gerber_fill_circle,
   gerber_fill_polygon,
+  common_fill_pcb_polygon,
+  0 /* gerber_thindraw_pcb_polygon */ ,
   gerber_fill_rect,
   gerber_calibrate,
   0 /* gerber_shift_is_pressed */ ,
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 61e114e..484cee0 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -13,12 +13,12 @@
 #include <time.h>
 
 
+#include "global.h"
 #include "action.h"
 #include "crosshair.h"
 #include "data.h"
 #include "draw.h"
 #include "error.h"
-#include "global.h"
 #include "mymem.h"
 #include "draw.h"
 #include "clip.h"
@@ -26,6 +26,7 @@
 #include "hid.h"
 #include "../hidint.h"
 #include "gui.h"
+#include "hid/common/draw_helpers.h"
 
 
 #if !GTK_CHECK_VERSION(2,8,0) && defined(HAVE_GDK_GDKX_H)
@@ -1552,6 +1553,8 @@ HID ghid_hid = {
   ghid_draw_rect,
   ghid_fill_circle,
   ghid_fill_polygon,
+  common_fill_pcb_polygon,
+  common_thindraw_pcb_polygon,
   ghid_fill_rect,
 
   ghid_calibrate,
@@ -1612,6 +1615,8 @@ HID ghid_extents = {
   ghid_extents_draw_rect,
   ghid_extents_fill_circle,
   ghid_extents_fill_polygon,
+  common_fill_pcb_polygon,
+  0 /* ghid_extents_thindraw_pcb_polygon */ ,
   ghid_extents_fill_rect,
 
   0 /* ghid_calibrate */ ,
diff --git a/src/hid/gtk/gui-config.c b/src/hid/gtk/gui-config.c
index 55ab6e7..1b50d32 100644
--- a/src/hid/gtk/gui-config.c
+++ b/src/hid/gtk/gui-config.c
@@ -34,11 +34,11 @@
 #include <stdlib.h>
 #endif
 
+#include "gui.h"
 #include "hid.h"
 #include "../hidint.h"
 #include "gtkhid.h"
 
-#include "gui.h"
 #include "global.h"
 #include "action.h"
 #include "change.h"
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index f0b0618..0b4eb21 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -27,6 +27,7 @@
 #ifndef __GHID_INCLUDED__
 #define __GHID_INCLUDED__
 
+#include "global.h"
 #include "hid.h"
 
 #include "data.h"
diff --git a/src/hid/lesstif/main.c b/src/hid/lesstif/main.c
index ce5e6a3..d2b680b 100644
--- a/src/hid/lesstif/main.c
+++ b/src/hid/lesstif/main.c
@@ -28,6 +28,7 @@
 
 #include "hid.h"
 #include "../hidint.h"
+#include "hid/common/draw_helpers.h"
 #include "lesstif.h"
 
 #ifdef HAVE_LIBDMALLOC
@@ -3901,6 +3902,8 @@ HID lesstif_gui = {
   lesstif_draw_rect,
   lesstif_fill_circle,
   lesstif_fill_polygon,
+  common_fill_pcb_polygon,
+  common_thindraw_pcb_polygon,
   lesstif_fill_rect,
 
   lesstif_calibrate,
diff --git a/src/hid/lpr/lpr.c b/src/hid/lpr/lpr.c
index 5fcc9a7..cbf19c6 100644
--- a/src/hid/lpr/lpr.c
+++ b/src/hid/lpr/lpr.c
@@ -139,6 +139,8 @@ HID lpr_hid = {
   0 /* lpr_draw_rect */ ,
   0 /* lpr_fill_circle */ ,
   0 /* lpr_fill_polygon */ ,
+  0 /* lpr_fill_pcb_polygon */ ,
+  0 /* lpr_thindraw_pcb_polygon */ ,
   0 /* lpr_fill_rect */ ,
   lpr_calibrate,
   0 /* lpr_shift_is_pressed */ ,
diff --git a/src/hid/nelma/nelma.c b/src/hid/nelma/nelma.c
index 964265a..d06193c 100644
--- a/src/hid/nelma/nelma.c
+++ b/src/hid/nelma/nelma.c
@@ -70,6 +70,7 @@
 
 #include "hid.h"
 #include "../hidint.h"
+#include "hid/common/draw_helpers.h"
 #include "nelma.h"
 
 #include <gd.h>
@@ -1073,6 +1074,8 @@ HID             nelma_hid = {
 	nelma_draw_rect,
 	nelma_fill_circle,
 	nelma_fill_polygon,
+	common_fill_pcb_polygon,
+	0 /* nelma_thindraw_pcb_polygon */ ,
 	nelma_fill_rect,
 	nelma_calibrate,
 	0 /* nelma_shift_is_pressed */ ,
diff --git a/src/hid/png/png.c b/src/hid/png/png.c
index 3c688bc..0aa62ac 100644
--- a/src/hid/png/png.c
+++ b/src/hid/png/png.c
@@ -42,6 +42,7 @@
 
 #include "hid.h"
 #include "../hidint.h"
+#include "hid/common/draw_helpers.h"
 #include "png.h"
 
 /* the gd library which makes this all so easy */
@@ -1351,6 +1352,8 @@ HID png_hid = {
   png_draw_rect,
   png_fill_circle,
   png_fill_polygon,
+  common_fill_pcb_polygon,
+  0 /* png_thindraw_pcb_polygon */ ,
   png_fill_rect,
   png_calibrate,
   0 /* png_shift_is_pressed */ ,
diff --git a/src/hid/ps/eps.c b/src/hid/ps/eps.c
index 3545ddf..15febe8 100644
--- a/src/hid/ps/eps.c
+++ b/src/hid/ps/eps.c
@@ -16,6 +16,7 @@
 
 #include "hid.h"
 #include "../hidint.h"
+#include "hid/common/draw_helpers.h"
 #include "../ps/ps.h"
 
 #ifdef HAVE_LIBDMALLOC
@@ -636,6 +637,8 @@ static HID eps_hid = {
   eps_draw_rect,
   eps_fill_circle,
   eps_fill_polygon,
+  common_fill_pcb_polygon,
+  0 /* eps_thindraw_pcb_polygon */ ,
   eps_fill_rect,
   eps_calibrate,
   0 /* eps_shift_is_pressed */ ,
diff --git a/src/hid/ps/ps.c b/src/hid/ps/ps.c
index bfb2e09..d742a5f 100644
--- a/src/hid/ps/ps.c
+++ b/src/hid/ps/ps.c
@@ -18,6 +18,7 @@
 
 #include "hid.h"
 #include "../hidint.h"
+#include "hid/common/draw_helpers.h"
 #include "../ps/ps.h"
 #include "../../print.h"
 
@@ -1174,6 +1175,8 @@ HID ps_hid = {
   ps_draw_rect,
   ps_fill_circle,
   ps_fill_polygon,
+  common_fill_pcb_polygon,
+  0 /* ps_thindraw_pcb_polygon */,
   ps_fill_rect,
   ps_calibrate,
   0 /* ps_shift_is_pressed */ ,
diff --git a/src/polygon.c b/src/polygon.c
index 8cee66a..bc7b555 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -58,10 +58,8 @@ intersection is "is the target shape inside POLYAREA.contours and NOT
 fully enclosed in any of POLYAREA.contours.next... (the holes)".
 
 The polygon dicer (NoHolesPolygonDicer and r_NoHolesPolygonDicer)
-emits a series of PolygonTypes with Clipped pointing to a "simple"
-shape.  That is, there is a single POLYAREA (the dlink pointers point
-to itself) and the contours list has only one element (the solid
-outline, with no "holes" oulines).  That's the meaning of the first
+emits a series of "simple" PLINE shapes.  That is, the PLINE isn't
+linked to any other "holes" oulines).  That's the meaning of the first
 test in r_NoHolesPolygonDicer.  It is testing to see if the PLINE
 contour (the first, making it a solid outline) has a valid next
 pointer (which would point to one or more holes).  The dicer works by
@@ -1245,10 +1243,9 @@ CopyAttachedPolygonToLayer (void)
  * the search.
  */
 int
-PolygonHoles (const BoxType * range, LayerTypePtr layer,
-              PolygonTypePtr polygon, int (*any_call) (PLINE * contour,
-                                                       LayerTypePtr lay,
-                                                       PolygonTypePtr poly))
+PolygonHoles (PolygonType *polygon, const BoxType *range,
+              int (*callback) (PLINE *contour, void *user_data),
+              void *user_data)
 {
   POLYAREA *pa = polygon->Clipped;
   PLINE *pl;
@@ -1262,7 +1259,7 @@ PolygonHoles (const BoxType * range, LayerTypePtr layer,
       if (pl->xmin > range->X2 || pl->xmax < range->X1 ||
           pl->ymin > range->Y2 || pl->ymax < range->Y1)
         continue;
-      if (any_call (pl, layer, polygon))
+      if (callback (pl, user_data))
         {
           return 1;
         }
@@ -1510,7 +1507,7 @@ IsRectangleInPolygon (LocationType X1, LocationType Y1, LocationType X2,
 
 static void
 r_NoHolesPolygonDicer (PLINE * p,
-                       void (*emit) (PolygonTypePtr, void *), void *user_data)
+                       void (*emit) (PLINE *, void *), void *user_data)
 {
   POLYAREA *pa;
 
@@ -1519,26 +1516,7 @@ r_NoHolesPolygonDicer (PLINE * p,
   pa->contours = p;
   if (!p->next)                 /* no holes */
     {
-      PolygonType poly;
-      PointType pts[4];
-
-      poly.BoundingBox.X1 = p->xmin;
-      poly.BoundingBox.X2 = p->xmax;
-      poly.BoundingBox.Y1 = p->ymin;
-      poly.BoundingBox.Y2 = p->ymax;
-      poly.PointN = poly.PointMax = 4;
-      poly.Clipped = pa;
-      poly.Points = pts;
-      pts[0].X = pts[0].X2 = p->xmin;
-      pts[0].Y = pts[0].Y2 = p->ymin;
-      pts[1].X = pts[1].X2 = p->xmax;
-      pts[1].Y = pts[1].Y2 = p->ymin;
-      pts[2].X = pts[2].X2 = p->xmax;
-      pts[2].Y = pts[2].Y2 = p->ymax;
-      pts[3].X = pts[3].X2 = p->xmin;
-      pts[3].Y = pts[3].Y2 = p->ymax;
-      poly.Flags = MakeFlags (CLEARPOLYFLAG);
-      emit (&poly, user_data);
+      emit (p, user_data);
       poly_Free (&pa);
       return;
     }
@@ -1583,7 +1561,7 @@ r_NoHolesPolygonDicer (PLINE * p,
 
 void
 NoHolesPolygonDicer (PolygonTypePtr p, const BoxType * clip,
-                     void (*emit) (PolygonTypePtr, void *), void *user_data)
+                     void (*emit) (PLINE *, void *), void *user_data)
 {
   POLYAREA *save, *ans;
 
diff --git a/src/polygon.h b/src/polygon.h
index a0563d2..1ec0a04 100644
--- a/src/polygon.h
+++ b/src/polygon.h
@@ -39,8 +39,9 @@ Boolean RemoveExcessPolygonPoints (LayerTypePtr, PolygonTypePtr);
 void GoToPreviousPoint (void);
 void ClosePolygon (void);
 void CopyAttachedPolygonToLayer (void);
-int PolygonHoles (const BoxType * range, LayerTypePtr, PolygonTypePtr,
-		  int (*callback) (PLINE *, LayerTypePtr, PolygonTypePtr));
+int PolygonHoles (PolygonType *ptr, const BoxType *range,
+		  int (*callback) (PLINE *, void *user_data),
+                  void *user_data);
 int PlowsPolygon (DataType *, int, void *, void *,
 		  int (*callback) (DataTypePtr, LayerTypePtr, PolygonTypePtr, int, void *, void *));
 POLYAREA * ContourToPoly (PLINE *);
@@ -63,6 +64,5 @@ Boolean IsRectangleInPolygon (LocationType, LocationType, LocationType,
 Boolean isects (POLYAREA *, PolygonTypePtr, Boolean);
 Boolean MorphPolygon (LayerTypePtr, PolygonTypePtr);
 void NoHolesPolygonDicer (PolygonType *p, const BoxType *clip,
-                          void (*emit) (PolygonTypePtr, void *),
-                          void *user_data);
+                          void (*emit) (PLINE *, void *), void *user_data);
 #endif

Bottom: 81fd77c2dbde70c4b2d73d1b7102dd45f04d16b4
Top:    ad7b8f87ee49afacec4583276073752213bdb533
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-03-19 00:09:08 +0000

Try Bert's DXF HID


---

diff --git a/configure.ac b/configure.ac
index d9620df..9949619 100644
--- a/configure.ac
+++ b/configure.ac
@@ -447,7 +447,7 @@ esac
 
 AC_MSG_CHECKING([for which exporters to use])
 AC_ARG_WITH([exporters],
-[  --with-exporters=       Enable export devices: bom gerber gcode nelma png ps [[default=bom gerber gcode nelma png ps]]],
+[  --with-exporters=       Enable export devices: bom dxf gerber gcode nelma png ps [[default=bom dxf gerber gcode nelma png ps]]],
 [],[with_exporters=$hid_exporters])
 AC_MSG_RESULT([$with_exporters])
 for e in `echo $with_exporters | sed 's/,/ /g'`; do
diff --git a/src/Makefile.am b/src/Makefile.am
index b709c27..c415f77 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -13,7 +13,7 @@ noinst_LIBRARIES = @HIDLIBS@
 EXTRA_LIBRARIES = \
 	libgtk.a liblesstif.a libbatch.a \
 	liblpr.a libgerber.a libbom.a libpng.a libps.a libnelma.a libgts.a \
-	libgcode.a
+	libgcode.a libdxf.a
 
 pcblib_DATA=	\
 	default_font \
@@ -230,6 +230,7 @@ EXTRA_DIST= \
 	default_font \
 	$(srcdir)/hid/batch/hid.conf \
 	$(srcdir)/hid/bom/hid.conf \
+	$(srcdir)/hid/dxf/hid.conf \
 	$(srcdir)/hid/gcode/hid.conf \
 	$(srcdir)/hid/gerber/hid.conf \
 	$(srcdir)/hid/gtk/gui-icons-misc.data \
@@ -464,6 +465,10 @@ hid/png/png_lists.h : ${LIBPNG_SRCS} Makefile
 	(for f in ${LIBPNG_SRCS} ; do cat $(srcdir)/$$f ; done) | grep "^REGISTER" > $@.tmp
 	mv $@.tmp $@
 
+libdxf_a_SOURCES = \
+	hid/hidint.h \
+	hid/dxf/dxf.c
+
 libgcode_a_CPPFLAGS = -I./hid/gcode
 LIBGCODE_SRCS = \
 	dolists.h \
diff --git a/src/hid/dxf/doc/AUTHORS b/src/hid/dxf/doc/AUTHORS
new file mode 100644
index 0000000..ca6a599
--- /dev/null
+++ b/src/hid/dxf/doc/AUTHORS
@@ -0,0 +1,5 @@
+$Id$
+
+The PCB DXF HID is originally written by:
+
+Bert Timmerman <bert.timmerman@xs4all.nl>
diff --git a/src/hid/dxf/doc/COPYING b/src/hid/dxf/doc/COPYING
new file mode 100644
index 0000000..ebbd3c8
--- /dev/null
+++ b/src/hid/dxf/doc/COPYING
@@ -0,0 +1,342 @@
+$Id$
+
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year  name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff --git a/src/hid/dxf/doc/INSTALL b/src/hid/dxf/doc/INSTALL
new file mode 100644
index 0000000..49d79a4
--- /dev/null
+++ b/src/hid/dxf/doc/INSTALL
@@ -0,0 +1,260 @@
+The PCB DXF HID uses the same standard GNU autoconf/automake based build
+system as PCB, which should make compilation go smoothly on most unix-like
+systems.
+Please do read this section first however.
+
+The installation and subsequent use of the DXF HID requires recompilation
+of the pcb package with the pcb-dxf-HID package merged into pcb.
+
+This requires the following actions:
+ * Untar and ungzip the pcb-dxf-HID.tar.gz file in the parent directory
+   where the pcb directory lives.
+ * Typically this would require "tar -xzf pcb-dxf-HID.tar.gz" entered on the 
+   command line.
+ * Edit the following entry in "configure.ac" in the "pcb/" toplevel directory
+   to apply the DXF hid (remember to use real [TAB] characters where needed !).
+   Something like this:
+ 
+AC_MSG_CHECKING([for which exporters to use])
+AC_ARG_WITH([exporters],
+[  --with-exporters=       Enable export devices: bom dxf gerber png ps [[default=bom dxf gerber png ps]]],
+[],[with_exporters=$hid_exporters])
+AC_MSG_RESULT([$with_exporters])
+for e in `echo $with_exporters | sed 's/,/ /g'`; do
+    case " $hid_exporters " in
+      *\ $e\ * )
+        HIDLIST="$HIDLIST $e"
+        ;;
+      * ) AC_MSG_ERROR([$e is not a valid exporter]) ;;
+    esac
+done
+
+ * Edit the following or add entries in the "pcb/src/Makefile.am" for the
+ * DXF hid: (remember to use real [TAB] characters where needed !)
+
+EXTRA_LIBRARIES = \
+        libgtk.a liblesstif.a libbatch.a \
+        liblpr.a libgerber.a libbom.a libdxf.a libpng.a libps.a
+
+...
+
+EXTRA_DIST= \
+        check_icon.data \
+        default_font \
+        $(srcdir)/hid/bom/hid.conf \
+        $(srcdir)/hid/dxf/hid.conf \
+        $(srcdir)/hid/gerber/hid.conf \
+        ...
+
+...
+
+libdxf_a_SOURCES = \
+        hid/hidint.h \
+        hid/dxf/dxf.c
+
+ * Run "./autogen.sh" from the "pcb" toplevel directory.
+ * Run "./configure" with the arguments that best fit to your needs.
+ * Run "make"
+ * Change to directory "src"
+ * Run "./pcb"
+ * Load a pcb file.
+ * Export with "File/Export Layout/dxf" or any other exporter you want to 
+ * export with.
+ * If all goes well, run "make install" from the toplevel directory
+ * if you want this version of pcb to be installed.
+ * Documentation of the DXF-HID is written for Doxygen (version >= 1.4.6).
+ * To (re)generate this Doxygen documentation, edit (if needed) and run
+ * "doxygen dxf-dox-no-call-graphs.dox" or
+ * "doxygen dxf-dox-with-call-graphs.dox" in the "pcb/src/hid/dxf/doc"
+ * directory to create HTML, latex and other docs in the 
+ * "pcb/src/hid/dxf/doc/*" directories.
+ * Please send remarks, bugs, improvements, relevant opinions to
+ * bert.timmerman@xs4all.nl or to the geda-dev mailing list.
+ * Donations to speed up the development of the gEDA suite best go to
+ * www.gedaconsulting.com.
+ * Have fun ;-)
+
+-------- Standard PCB INSTALL Instructions Follow --------------------
+
+PCB is organized into a core program that deals with all of the
+internal database procedures and a collection of Human Interface
+Devices (HID's).
+The HID's provide exporting/printing capability as well as a graphical user
+interface.
+At the time of writing this document PCB includes the following HIDs:
+
+GUI HID's:
+     gtk      -- GTK based GUI.  This is the default GUI.
+
+     lesstif  -- motif/lesstif based GUI.
+
+Export HID's:
+     ps       -- Postscript and Encapsulated Postscript output.
+     
+     gerber   -- RS-274-X (Gerber) and Excellon drill output.
+     
+     bom      -- Bill of materials (BOM) and Centroid (X-Y) output.
+		 
+     dxf      -- Drawing eXchange Format (DXF) files for every layer and a
+                 DXF file with external references (XREF) is generated. 
+                 No additional libraries are needed for the DXF exporter HID. 
+
+     png      -- png/gif/jpeg output.
+
+    The choice of which export HID's to compile is indicated with:
+
+      --with-exporters="ps gerber bom dxf png"
+
+    By default all available exporters will be configured in if --with-exporters
+    is not given.  
+
+Printer HID's:
+     lpr     -- Unix line printer support.
+
+For help on how to implement the DXF exporter please refer to the documentation
+generated by Doxygen (by running doxygen .doxygen in the dxf subdirectory.
+
+Please refer to the output of
+
+  ./configure --help
+
+for the most up to date details on the options.
+
+After running ./configure with your selected options, run
+
+  make
+
+to build PCB.
+You can try out the program by running
+
+  cd src
+  ./pcbtest.sh
+
+prior to installation.
+
+To install PCB after it has been built run:
+
+  make install
+
+from the top level directory.
+
+-------- Standard GNU INSTALL Instructions Follow --------------------
+
+This is a generic INSTALL file for utilities distributions.
+If this package does not come with, e.g., installable documentation or
+data files, please ignore the references to them below.
+
+To compile this package:
+
+1.  Configure the package for your system.  In the directory that this
+file is in, type `./configure'.  If you're using `csh' on an old
+version of System V, you might need to type `sh configure' instead to
+prevent `csh' from trying to execute `configure' itself.
+
+The `configure' shell script attempts to guess correct values for
+various system-dependent variables used during compilation, and
+creates the Makefile(s) (one in each subdirectory of the source
+directory).  In some packages it creates a C header file containing
+system-dependent definitions.  It also creates a file `config.status'
+that you can run in the future to recreate the current configuration.
+
+Running `configure' takes a minute or two.  While it is running, it
+prints some messages that tell what it is doing.  If you don't want to
+see the messages, run `configure' with its standard output redirected
+to `/dev/null'; for example, `./configure >/dev/null'.
+
+To compile the package in a different directory from the one
+containing the source code, you must use a version of `make' that
+supports the VPATH variable, such as GNU `make'.  `cd' to the directory
+where you want the object files and executables to go and run
+`configure'.  `configure' automatically checks for the source code in
+the directory that `configure' is in and in `..'.  If for some reason
+`configure' is not in the source code directory that you are
+configuring, then it will report that it can't find the source code.
+In that case, run `configure' with the option `--srcdir=DIR', where
+DIR is the directory that contains the source code.
+
+By default, `make install' will install the package's files in
+/usr/local/bin, /usr/local/lib, /usr/local/man, etc.  You can specify an
+installation prefix other than /usr/local by giving `configure' the option
+`--prefix=PATH'.  Alternately, you can do so by consistently giving a value
+for the `prefix' variable when you run `make', e.g.,
+	make prefix=/usr/gnu
+	make prefix=/usr/gnu install
+
+You can specify separate installation prefixes for
+architecture-specific files and architecture-independent files.  If
+you give `configure' the option `--exec-prefix=PATH' or set the
+`make' variable `exec_prefix' to PATH, the package will use PATH as
+the prefix for installing programs and libraries.  Data files and
+documentation will still use the regular prefix.  Normally, all files
+are installed using the regular prefix.
+
+Another `configure' option is useful mainly in `Makefile' rules for
+updating `config.status' and `Makefile'.  The `--no-create' option
+figures out the configuration for your system and records it in
+`config.status', without actually configuring the package (creating
+`Makefile's and perhaps a configuration header file).  Later, you can
+run `./config.status' to actually configure the package.  You can also
+give `config.status' the `--recheck' option, which makes it re-run
+`configure' with the same arguments you used before.  This option is
+useful if you change `configure'.
+
+Some packages pay attention to `--with-PACKAGE' options to `configure',
+where PACKAGE is something like `gnu-libc' or `x' (for the X Window System).
+The README should mention any --with- options that the package recognizes.
+
+`configure' ignores any other arguments that you give it.
+
+If your system requires unusual options for compilation or linking
+that `configure' doesn't know about, you can give `configure' initial
+values for some variables by setting them in the environment.  In
+Bourne-compatible shells, you can do that on the command line like
+this:
+	CC='gcc -traditional' DEFS=-D_POSIX_SOURCE ./configure
+
+The `make' variables that you might want to override with environment
+variables when running `configure' are:
+
+(For these variables, any value given in the environment overrides the
+value that `configure' would choose:)
+CC		C compiler program.
+		Default is `cc', or `gcc' if `gcc' is in your PATH.
+INSTALL		Program to use to install files.
+		Default is `install' if you have it, `cp' otherwise.
+
+(For these variables, any value given in the environment is added to
+the value that `configure' chooses:)
+DEFS		Configuration options, in the form `-Dfoo -Dbar ...'
+		Do not use this variable in packages that create a
+		configuration header file.
+LIBS		Libraries to link with, in the form `-lfoo -lbar ...'
+
+If you need to do unusual things to compile the package, we encourage
+you to figure out how `configure' could check whether to do them, and
+mail diffs or instructions to the address given in the README so we
+can include them in the next release.
+
+2.  Type `make' to compile the package.  If you want, you can override
+the `make' variables CFLAGS and LDFLAGS like this:
+
+	make CFLAGS=-O2 LDFLAGS=-s
+
+3.  If the package comes with self-tests and you want to run them,
+type `make check'.  If you're not sure whether there are any, try it;
+if `make' responds with something like
+	make: *** No way to make target `check'.  Stop.
+then the package does not come with self-tests.
+
+4.  Type `make install' to install programs, data files, and
+documentation.
+
+5.  You can remove the program binaries and object files from the
+source directory by typing `make clean'.  To also remove the
+Makefile(s), the header file containing system-dependent definitions
+(if the package uses one), and `config.status' (all the files that
+`configure' created), type `make distclean'.
+
+The file `configure.in' is used as a template to create `configure' by
+a program called `autoconf'.  You will only need it if you want to
+regenerate `configure' using a newer version of `autoconf'.
diff --git a/src/hid/dxf/doc/README b/src/hid/dxf/doc/README
new file mode 100644
index 0000000..18f006f
--- /dev/null
+++ b/src/hid/dxf/doc/README
@@ -0,0 +1,20 @@
+The pcb DXF HID is a DXF exporter for pcb.
+
+pcb is a Computer Aided Design (CAD) program for the physical
+design of printed circuit boards.
+
+For installing the release refer to the file 'INSTALL'.
+For additional information read the manual ({toplevel directory}/doc/pcb.pdf) 
+
+If you are updating you may wish to read the ChangeLog
+
+There is also a bug tracking system and user forum available
+on the sourceforge project page which can be found from
+http://pcb.sourceforge.net.  
+
+
+-------------------------------------------------------------------------
+                            COPYRIGHT
+
+The pcb DXF HID is covered by the GNU General Public License.
+See the individual files for the exact copyright notices.
diff --git a/src/hid/dxf/doc/dxf-dox-no-call-graphs.dox b/src/hid/dxf/doc/dxf-dox-no-call-graphs.dox
new file mode 100644
index 0000000..2e94ac0
--- /dev/null
+++ b/src/hid/dxf/doc/dxf-dox-no-call-graphs.dox
@@ -0,0 +1,1237 @@
+# Doxyfile 1.4.6
+
+# This file describes the settings to be used by the documentation system
+# doxygen (www.doxygen.org) for a project
+#
+# All text after a hash (#) is considered a comment and will be ignored
+# The format is:
+#       TAG = value [value, ...]
+# For lists items can also be appended using:
+#       TAG += value [value, ...]
+# Values that contain spaces should be placed between quotes (" ")
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+
+# The PROJECT_NAME tag is a single word (or a sequence of words surrounded 
+# by quotes) that should identify the project.
+
+PROJECT_NAME           = PCB-DXF-HID
+
+# The PROJECT_NUMBER tag can be used to enter a project or revision number. 
+# This could be handy for archiving the generated documentation or 
+# if some version control system is used.
+
+PROJECT_NUMBER         = 0.0.2
+
+# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) 
+# base path where the generated documentation will be put. 
+# If a relative path is entered, it will be relative to the location 
+# where doxygen was started. If left blank the current directory will be used.
+
+OUTPUT_DIRECTORY       =
+
+# If the CREATE_SUBDIRS tag is set to YES, then doxygen will create 
+# 4096 sub-directories (in 2 levels) under the output directory of each output 
+# format and will distribute the generated files over these directories. 
+# Enabling this option can be useful when feeding doxygen a huge amount of 
+# source files, where putting all generated files in the same directory would 
+# otherwise cause performance problems for the file system.
+
+CREATE_SUBDIRS         = NO
+
+# The OUTPUT_LANGUAGE tag is used to specify the language in which all 
+# documentation generated by doxygen is written. Doxygen will use this 
+# information to generate all constant output in the proper language. 
+# The default language is English, other supported languages are: 
+# Brazilian, Catalan, Chinese, Chinese-Traditional, Croatian, Czech, Danish, 
+# Dutch, Finnish, French, German, Greek, Hungarian, Italian, Japanese, 
+# Japanese-en (Japanese with English messages), Korean, Korean-en, Norwegian, 
+# Polish, Portuguese, Romanian, Russian, Serbian, Slovak, Slovene, Spanish, 
+# Swedish, and Ukrainian.
+
+OUTPUT_LANGUAGE        = English
+
+# This tag can be used to specify the encoding used in the generated output. 
+# The encoding is not always determined by the language that is chosen, 
+# but also whether or not the output is meant for Windows or non-Windows users. 
+# In case there is a difference, setting the USE_WINDOWS_ENCODING tag to YES 
+# forces the Windows encoding (this is the default for the Windows binary), 
+# whereas setting the tag to NO uses a Unix-style encoding (the default for 
+# all platforms other than Windows).
+
+USE_WINDOWS_ENCODING   = NO
+
+# If the BRIEF_MEMBER_DESC tag is set to YES (the default) Doxygen will 
+# include brief member descriptions after the members that are listed in 
+# the file and class documentation (similar to JavaDoc). 
+# Set to NO to disable this.
+
+BRIEF_MEMBER_DESC      = YES
+
+# If the REPEAT_BRIEF tag is set to YES (the default) Doxygen will prepend 
+# the brief description of a member or function before the detailed description. 
+# Note: if both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the 
+# brief descriptions will be completely suppressed.
+
+REPEAT_BRIEF           = YES
+
+# This tag implements a quasi-intelligent brief description abbreviator 
+# that is used to form the text in various listings. Each string 
+# in this list, if found as the leading text of the brief description, will be 
+# stripped from the text and the result after processing the whole list, is 
+# used as the annotated text. Otherwise, the brief description is used as-is. 
+# If left blank, the following values are used ("$name" is automatically 
+# replaced with the name of the entity): "The $name class" "The $name widget" 
+# "The $name file" "is" "provides" "specifies" "contains" 
+# "represents" "a" "an" "the"
+
+ABBREVIATE_BRIEF       = 
+
+# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then 
+# Doxygen will generate a detailed section even if there is only a brief 
+# description.
+
+ALWAYS_DETAILED_SEC    = YES
+
+# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all 
+# inherited members of a class in the documentation of that class as if those 
+# members were ordinary class members. Constructors, destructors and assignment 
+# operators of the base classes will not be shown.
+
+INLINE_INHERITED_MEMB  = YES
+
+# If the FULL_PATH_NAMES tag is set to YES then Doxygen will prepend the full 
+# path before files name in the file list and in the header files. If set 
+# to NO the shortest path that makes the file name unique will be used.
+
+FULL_PATH_NAMES        = NO
+
+# If the FULL_PATH_NAMES tag is set to YES then the STRIP_FROM_PATH tag 
+# can be used to strip a user-defined part of the path. Stripping is 
+# only done if one of the specified strings matches the left-hand part of 
+# the path. The tag can be used to show relative paths in the file list. 
+# If left blank the directory from which doxygen is run is used as the 
+# path to strip.
+
+STRIP_FROM_PATH        = 
+
+# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of 
+# the path mentioned in the documentation of a class, which tells 
+# the reader which header file to include in order to use a class. 
+# If left blank only the name of the header file containing the class 
+# definition is used. Otherwise one should specify the include paths that 
+# are normally passed to the compiler using the -I flag.
+
+STRIP_FROM_INC_PATH    = 
+
+# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter 
+# (but less readable) file names. This can be useful is your file systems 
+# doesn't support long names like on DOS, Mac, or CD-ROM.
+
+SHORT_NAMES            = NO
+
+# If the JAVADOC_AUTOBRIEF tag is set to YES then Doxygen 
+# will interpret the first line (until the first dot) of a JavaDoc-style 
+# comment as the brief description. If set to NO, the JavaDoc 
+# comments will behave just like the Qt-style comments (thus requiring an 
+# explicit @brief command for a brief description.
+
+JAVADOC_AUTOBRIEF      = NO
+
+# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make Doxygen 
+# treat a multi-line C++ special comment block (i.e. a block of //! or /// 
+# comments) as a brief description. This used to be the default behaviour. 
+# The new default is to treat a multi-line C++ comment block as a detailed 
+# description. Set this tag to YES if you prefer the old behaviour instead.
+
+MULTILINE_CPP_IS_BRIEF = NO
+
+# If the DETAILS_AT_TOP tag is set to YES then Doxygen 
+# will output the detailed description near the top, like JavaDoc.
+# If set to NO, the detailed description appears after the member 
+# documentation.
+
+DETAILS_AT_TOP         = YES
+
+# If the INHERIT_DOCS tag is set to YES (the default) then an undocumented 
+# member inherits the documentation from any documented member that it 
+# re-implements.
+
+INHERIT_DOCS           = YES
+
+# If the SEPARATE_MEMBER_PAGES tag is set to YES, then doxygen will produce 
+# a new page for each member. If set to NO, the documentation of a member will 
+# be part of the file/class/namespace that contains it.
+
+SEPARATE_MEMBER_PAGES  = NO
+
+# The TAB_SIZE tag can be used to set the number of spaces in a tab. 
+# Doxygen uses this value to replace tabs by spaces in code fragments.
+
+TAB_SIZE               = 8
+
+# This tag can be used to specify a number of aliases that acts 
+# as commands in the documentation. An alias has the form "name=value". 
+# For example adding "sideeffect=\par Side Effects:\n" will allow you to 
+# put the command \sideeffect (or @sideeffect) in the documentation, which 
+# will result in a user-defined paragraph with heading "Side Effects:". 
+# You can put \n's in the value part of an alias to insert newlines.
+
+ALIASES                = 
+
+# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C 
+# sources only. Doxygen will then generate output that is more tailored for C. 
+# For instance, some of the names that are used will be different. The list 
+# of all members will be omitted, etc.
+
+OPTIMIZE_OUTPUT_FOR_C  = YES
+
+# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java 
+# sources only. Doxygen will then generate output that is more tailored for Java. 
+# For instance, namespaces will be presented as packages, qualified scopes 
+# will look different, etc.
+
+OPTIMIZE_OUTPUT_JAVA   = NO
+
+# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want to 
+# include (a tag file for) the STL sources as input, then you should 
+# set this tag to YES in order to let doxygen match functions declarations and 
+# definitions whose arguments contain STL classes (e.g. func(std::string); v.s. 
+# func(std::string) {}). This also make the inheritance and collaboration 
+# diagrams that involve STL classes more complete and accurate.
+
+BUILTIN_STL_SUPPORT    = NO
+
+# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC 
+# tag is set to YES, then doxygen will reuse the documentation of the first 
+# member in the group (if any) for the other members of the group. By default 
+# all members of a group must be documented explicitly.
+
+DISTRIBUTE_GROUP_DOC   = NO
+
+# Set the SUBGROUPING tag to YES (the default) to allow class member groups of 
+# the same type (for instance a group of public functions) to be put as a 
+# subgroup of that type (e.g. under the Public Functions section). Set it to 
+# NO to prevent subgrouping. Alternatively, this can be done per class using 
+# the \nosubgrouping command.
+
+SUBGROUPING            = YES
+
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+
+# If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in 
+# documentation are documented, even if no documentation was available. 
+# Private class members and static file members will be hidden unless 
+# the EXTRACT_PRIVATE and EXTRACT_STATIC tags are set to YES
+
+EXTRACT_ALL            = NO
+
+# If the EXTRACT_PRIVATE tag is set to YES all private members of a class 
+# will be included in the documentation.
+
+EXTRACT_PRIVATE        = NO
+
+# If the EXTRACT_STATIC tag is set to YES all static members of a file 
+# will be included in the documentation.
+
+EXTRACT_STATIC         = YES
+
+# If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs) 
+# defined locally in source files will be included in the documentation. 
+# If set to NO only classes defined in header files are included.
+
+EXTRACT_LOCAL_CLASSES  = YES
+
+# This flag is only useful for Objective-C code. When set to YES local 
+# methods, which are defined in the implementation section but not in 
+# the interface are included in the documentation. 
+# If set to NO (the default) only methods in the interface are included.
+
+EXTRACT_LOCAL_METHODS  = NO
+
+# If the HIDE_UNDOC_MEMBERS tag is set to YES, Doxygen will hide all 
+# undocumented members of documented classes, files or namespaces. 
+# If set to NO (the default) these members will be included in the 
+# various overviews, but no documentation section is generated. 
+# This option has no effect if EXTRACT_ALL is enabled.
+
+HIDE_UNDOC_MEMBERS     = NO
+
+# If the HIDE_UNDOC_CLASSES tag is set to YES, Doxygen will hide all 
+# undocumented classes that are normally visible in the class hierarchy. 
+# If set to NO (the default) these classes will be included in the various 
+# overviews. This option has no effect if EXTRACT_ALL is enabled.
+
+HIDE_UNDOC_CLASSES     = NO
+
+# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, Doxygen will hide all 
+# friend (class|struct|union) declarations. 
+# If set to NO (the default) these declarations will be included in the 
+# documentation.
+
+HIDE_FRIEND_COMPOUNDS  = NO
+
+# If the HIDE_IN_BODY_DOCS tag is set to YES, Doxygen will hide any 
+# documentation blocks found inside the body of a function. 
+# If set to NO (the default) these blocks will be appended to the 
+# function's detailed documentation block.
+
+HIDE_IN_BODY_DOCS      = NO
+
+# The INTERNAL_DOCS tag determines if documentation 
+# that is typed after a \internal command is included. If the tag is set 
+# to NO (the default) then the documentation will be excluded. 
+# Set it to YES to include the internal documentation.
+
+INTERNAL_DOCS          = NO
+
+# If the CASE_SENSE_NAMES tag is set to NO then Doxygen will only generate 
+# file names in lower-case letters. If set to YES upper-case letters are also 
+# allowed. This is useful if you have classes or files whose names only differ 
+# in case and if your file system supports case sensitive file names. Windows 
+# and Mac users are advised to set this option to NO.
+
+CASE_SENSE_NAMES       = YES
+
+# If the HIDE_SCOPE_NAMES tag is set to NO (the default) then Doxygen 
+# will show members with their full class and namespace scopes in the 
+# documentation. If set to YES the scope will be hidden.
+
+HIDE_SCOPE_NAMES       = NO
+
+# If the SHOW_INCLUDE_FILES tag is set to YES (the default) then Doxygen 
+# will put a list of the files that are included by a file in the documentation 
+# of that file.
+
+SHOW_INCLUDE_FILES     = YES
+
+# If the INLINE_INFO tag is set to YES (the default) then a tag [inline] 
+# is inserted in the documentation for inline members.
+
+INLINE_INFO            = YES
+
+# If the SORT_MEMBER_DOCS tag is set to YES (the default) then doxygen 
+# will sort the (detailed) documentation of file and class members 
+# alphabetically by member name. If set to NO the members will appear in 
+# declaration order.
+
+SORT_MEMBER_DOCS       = YES
+
+# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the 
+# brief documentation of file, namespace and class members alphabetically 
+# by member name. If set to NO (the default) the members will appear in 
+# declaration order.
+
+SORT_BRIEF_DOCS        = NO
+
+# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be 
+# sorted by fully-qualified names, including namespaces. If set to 
+# NO (the default), the class list will be sorted only by class name, 
+# not including the namespace part. 
+# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
+# Note: This option applies only to the class list, not to the 
+# alphabetical list.
+
+SORT_BY_SCOPE_NAME     = NO
+
+# The GENERATE_TODOLIST tag can be used to enable (YES) or 
+# disable (NO) the todo list. This list is created by putting \todo 
+# commands in the documentation.
+
+GENERATE_TODOLIST      = YES
+
+# The GENERATE_TESTLIST tag can be used to enable (YES) or 
+# disable (NO) the test list. This list is created by putting \test 
+# commands in the documentation.
+
+GENERATE_TESTLIST      = YES
+
+# The GENERATE_BUGLIST tag can be used to enable (YES) or 
+# disable (NO) the bug list. This list is created by putting \bug 
+# commands in the documentation.
+
+GENERATE_BUGLIST       = YES
+
+# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or 
+# disable (NO) the deprecated list. This list is created by putting 
+# \deprecated commands in the documentation.
+
+GENERATE_DEPRECATEDLIST= YES
+
+# The ENABLED_SECTIONS tag can be used to enable conditional 
+# documentation sections, marked by \if sectionname ... \endif.
+
+ENABLED_SECTIONS       = 
+
+# The MAX_INITIALIZER_LINES tag determines the maximum number of lines 
+# the initial value of a variable or define consists of for it to appear in 
+# the documentation. If the initializer consists of more lines than specified 
+# here it will be hidden. Use a value of 0 to hide initializers completely. 
+# The appearance of the initializer of individual variables and defines in the 
+# documentation can be controlled using \showinitializer or \hideinitializer 
+# command in the documentation regardless of this setting.
+
+MAX_INITIALIZER_LINES  = 30
+
+# Set the SHOW_USED_FILES tag to NO to disable the list of files generated 
+# at the bottom of the documentation of classes and structs. If set to YES the 
+# list will mention the files that were used to generate the documentation.
+
+SHOW_USED_FILES        = YES
+
+# If the sources in your project are distributed over multiple directories 
+# then setting the SHOW_DIRECTORIES tag to YES will show the directory hierarchy 
+# in the documentation. The default is NO.
+
+SHOW_DIRECTORIES       = NO
+
+# The FILE_VERSION_FILTER tag can be used to specify a program or script that 
+# doxygen should invoke to get the current version for each file (typically from the 
+# version control system). Doxygen will invoke the program by executing (via 
+# popen()) the command <command> <input-file>, where <command> is the value of 
+# the FILE_VERSION_FILTER tag, and <input-file> is the name of an input file 
+# provided by doxygen. Whatever the program writes to standard output 
+# is used as the file version. See the manual for examples.
+
+FILE_VERSION_FILTER    = 
+
+#---------------------------------------------------------------------------
+# configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+
+# The QUIET tag can be used to turn on/off the messages that are generated 
+# by doxygen. Possible values are YES and NO. If left blank NO is used.
+
+QUIET                  = NO
+
+# The WARNINGS tag can be used to turn on/off the warning messages that are 
+# generated by doxygen. Possible values are YES and NO. If left blank 
+# NO is used.
+
+WARNINGS               = YES
+
+# If WARN_IF_UNDOCUMENTED is set to YES, then doxygen will generate warnings 
+# for undocumented members. If EXTRACT_ALL is set to YES then this flag will 
+# automatically be disabled.
+
+WARN_IF_UNDOCUMENTED   = YES
+
+# If WARN_IF_DOC_ERROR is set to YES, doxygen will generate warnings for 
+# potential errors in the documentation, such as not documenting some 
+# parameters in a documented function, or documenting parameters that 
+# don't exist or using markup commands wrongly.
+
+WARN_IF_DOC_ERROR      = YES
+
+# This WARN_NO_PARAMDOC option can be abled to get warnings for 
+# functions that are documented, but have no documentation for their parameters 
+# or return value. If set to NO (the default) doxygen will only warn about 
+# wrong or incomplete parameter documentation, but not about the absence of 
+# documentation.
+
+WARN_NO_PARAMDOC       = NO
+
+# The WARN_FORMAT tag determines the format of the warning messages that 
+# doxygen can produce. The string should contain the $file, $line, and $text 
+# tags, which will be replaced by the file and line number from which the 
+# warning originated and the warning text. Optionally the format may contain 
+# $version, which will be replaced by the version of the file (if it could 
+# be obtained via FILE_VERSION_FILTER)
+
+WARN_FORMAT            = "$file:$line: $text"
+
+# The WARN_LOGFILE tag can be used to specify a file to which warning 
+# and error messages should be written. If left blank the output is written 
+# to stderr.
+
+WARN_LOGFILE           = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the input files
+#---------------------------------------------------------------------------
+
+# The INPUT tag can be used to specify the files and/or directories that contain 
+# documented source files. You may enter file names like "myfile.cpp" or 
+# directories like "/usr/src/myproject". Separate the files or directories 
+# with spaces.
+
+INPUT                  = .. ../doc/pcb-dxf-hid-main.txt
+
+# If the value of the INPUT tag contains directories, you can use the 
+# FILE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp 
+# and *.h) to filter out the source-files in the directories. If left 
+# blank the following patterns are tested: 
+# *.c *.cc *.cxx *.cpp *.c++ *.java *.ii *.ixx *.ipp *.i++ *.inl *.h *.hh *.hxx 
+# *.hpp *.h++ *.idl *.odl *.cs *.php *.php3 *.inc *.m *.mm *.py
+
+FILE_PATTERNS          = *.c *.h
+
+# The RECURSIVE tag can be used to turn specify whether or not subdirectories 
+# should be searched for input files as well. Possible values are YES and NO. 
+# If left blank NO is used.
+
+RECURSIVE              = YES
+
+# The EXCLUDE tag can be used to specify files and/or directories that should 
+# excluded from the INPUT source files. This way you can easily exclude a 
+# subdirectory from a directory tree whose root is specified with the INPUT tag.
+
+EXCLUDE                = 
+
+# The EXCLUDE_SYMLINKS tag can be used select whether or not files or 
+# directories that are symbolic links (a Unix filesystem feature) are excluded 
+# from the input.
+
+EXCLUDE_SYMLINKS       = NO
+
+# If the value of the INPUT tag contains directories, you can use the 
+# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude 
+# certain files from those directories. Note that the wildcards are matched 
+# against the file with absolute path, so to exclude all test directories 
+# for example use the pattern */test/*
+
+EXCLUDE_PATTERNS       = 
+
+# The EXAMPLE_PATH tag can be used to specify one or more files or 
+# directories that contain example code fragments that are included (see 
+# the \include command).
+
+EXAMPLE_PATH           = ../doc
+
+# If the value of the EXAMPLE_PATH tag contains directories, you can use the 
+# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp 
+# and *.h) to filter out the source-files in the directories. If left 
+# blank all files are included.
+
+EXAMPLE_PATTERNS       = 
+
+# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be 
+# searched for input files to be used with the \include or \dontinclude 
+# commands irrespective of the value of the RECURSIVE tag. 
+# Possible values are YES and NO. If left blank NO is used.
+
+EXAMPLE_RECURSIVE      = NO
+
+# The IMAGE_PATH tag can be used to specify one or more files or 
+# directories that contain image that are included in the documentation (see 
+# the \image command).
+
+IMAGE_PATH             = ../doc
+
+# The INPUT_FILTER tag can be used to specify a program that doxygen should 
+# invoke to filter for each input file. Doxygen will invoke the filter program 
+# by executing (via popen()) the command <filter> <input-file>, where <filter> 
+# is the value of the INPUT_FILTER tag, and <input-file> is the name of an 
+# input file. Doxygen will then use the output that the filter program writes 
+# to standard output.  If FILTER_PATTERNS is specified, this tag will be 
+# ignored.
+
+INPUT_FILTER           = 
+
+# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern 
+# basis.  Doxygen will compare the file name with each pattern and apply the 
+# filter if there is a match.  The filters are a list of the form: 
+# pattern=filter (like *.cpp=my_cpp_filter). See INPUT_FILTER for further 
+# info on how filters are used. If FILTER_PATTERNS is empty, INPUT_FILTER 
+# is applied to all files.
+
+FILTER_PATTERNS        = 
+
+# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using 
+# INPUT_FILTER) will be used to filter the input files when producing source 
+# files to browse (i.e. when SOURCE_BROWSER is set to YES).
+
+FILTER_SOURCE_FILES    = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to source browsing
+#---------------------------------------------------------------------------
+
+# If the SOURCE_BROWSER tag is set to YES then a list of source files will 
+# be generated. Documented entities will be cross-referenced with these sources. 
+# Note: To get rid of all source code in the generated output, make sure also 
+# VERBATIM_HEADERS is set to NO.
+
+SOURCE_BROWSER         = YES
+
+# Setting the INLINE_SOURCES tag to YES will include the body 
+# of functions and classes directly in the documentation.
+
+INLINE_SOURCES         = NO
+
+# Setting the STRIP_CODE_COMMENTS tag to YES (the default) will instruct 
+# doxygen to hide any special comment blocks from generated source code 
+# fragments. Normal C and C++ comments will always remain visible.
+
+STRIP_CODE_COMMENTS    = YES
+
+# If the REFERENCED_BY_RELATION tag is set to YES (the default) 
+# then for each documented function all documented 
+# functions referencing it will be listed.
+
+REFERENCED_BY_RELATION = YES
+
+# If the REFERENCES_RELATION tag is set to YES (the default) 
+# then for each documented function all documented entities 
+# called/used by that function will be listed.
+
+REFERENCES_RELATION    = YES
+
+# If the USE_HTAGS tag is set to YES then the references to source code 
+# will point to the HTML generated by the htags(1) tool instead of doxygen 
+# built-in source browser. The htags tool is part of GNU's global source 
+# tagging system (see http://www.gnu.org/software/global/global.html). You 
+# will need version 4.8.6 or higher.
+
+USE_HTAGS              = NO
+
+# If the VERBATIM_HEADERS tag is set to YES (the default) then Doxygen 
+# will generate a verbatim copy of the header file for each class for 
+# which an include is specified. Set to NO to disable this.
+
+VERBATIM_HEADERS       = YES
+
+#---------------------------------------------------------------------------
+# configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+
+# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index 
+# of all compounds will be generated. Enable this if the project 
+# contains a lot of classes, structs, unions or interfaces.
+
+ALPHABETICAL_INDEX     = YES
+
+# If the alphabetical index is enabled (see ALPHABETICAL_INDEX) then 
+# the COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns 
+# in which this list will be split (can be a number in the range [1..20])
+
+COLS_IN_ALPHA_INDEX    = 5
+
+# In case all classes in a project start with a common prefix, all 
+# classes will be put under the same header in the alphabetical index. 
+# The IGNORE_PREFIX tag can be used to specify one or more prefixes that 
+# should be ignored while generating the index headers.
+
+IGNORE_PREFIX          = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the HTML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_HTML tag is set to YES (the default) Doxygen will 
+# generate HTML output.
+
+GENERATE_HTML          = YES
+
+# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `html' will be used as the default path.
+
+HTML_OUTPUT            = html
+
+# The HTML_FILE_EXTENSION tag can be used to specify the file extension for 
+# each generated HTML page (for example: .htm,.php,.asp). If it is left blank 
+# doxygen will generate files with .html extension.
+
+HTML_FILE_EXTENSION    = .html
+
+# The HTML_HEADER tag can be used to specify a personal HTML header for 
+# each generated HTML page. If it is left blank doxygen will generate a 
+# standard header.
+
+HTML_HEADER            = 
+
+# The HTML_FOOTER tag can be used to specify a personal HTML footer for 
+# each generated HTML page. If it is left blank doxygen will generate a 
+# standard footer.
+
+HTML_FOOTER            = 
+
+# The HTML_STYLESHEET tag can be used to specify a user-defined cascading 
+# style sheet that is used by each HTML page. It can be used to 
+# fine-tune the look of the HTML output. If the tag is left blank doxygen 
+# will generate a default style sheet. Note that doxygen will try to copy 
+# the style sheet file to the HTML output directory, so don't put your own 
+# stylesheet in the HTML output directory as well, or it will be erased!
+
+HTML_STYLESHEET        = 
+
+# If the HTML_ALIGN_MEMBERS tag is set to YES, the members of classes, 
+# files or namespaces will be aligned in HTML using tables. If set to 
+# NO a bullet list will be used.
+
+HTML_ALIGN_MEMBERS     = YES
+
+# If the GENERATE_HTMLHELP tag is set to YES, additional index files 
+# will be generated that can be used as input for tools like the 
+# Microsoft HTML help workshop to generate a compressed HTML help file (.chm) 
+# of the generated HTML documentation.
+
+GENERATE_HTMLHELP      = NO
+
+# If the GENERATE_HTMLHELP tag is set to YES, the CHM_FILE tag can 
+# be used to specify the file name of the resulting .chm file. You 
+# can add a path in front of the file if the result should not be 
+# written to the html output directory.
+
+CHM_FILE               = 
+
+# If the GENERATE_HTMLHELP tag is set to YES, the HHC_LOCATION tag can 
+# be used to specify the location (absolute path including file name) of 
+# the HTML help compiler (hhc.exe). If non-empty doxygen will try to run 
+# the HTML help compiler on the generated index.hhp.
+
+HHC_LOCATION           = 
+
+# If the GENERATE_HTMLHELP tag is set to YES, the GENERATE_CHI flag 
+# controls if a separate .chi index file is generated (YES) or that 
+# it should be included in the master .chm file (NO).
+
+GENERATE_CHI           = NO
+
+# If the GENERATE_HTMLHELP tag is set to YES, the BINARY_TOC flag 
+# controls whether a binary table of contents is generated (YES) or a 
+# normal table of contents (NO) in the .chm file.
+
+BINARY_TOC             = NO
+
+# The TOC_EXPAND flag can be set to YES to add extra items for group members 
+# to the contents of the HTML help documentation and to the tree view.
+
+TOC_EXPAND             = NO
+
+# The DISABLE_INDEX tag can be used to turn on/off the condensed index at 
+# top of each HTML page. The value NO (the default) enables the index and 
+# the value YES disables it.
+
+DISABLE_INDEX          = NO
+
+# This tag can be used to set the number of enum values (range [1..20]) 
+# that doxygen will group on one line in the generated HTML documentation.
+
+ENUM_VALUES_PER_LINE   = 4
+
+# If the GENERATE_TREEVIEW tag is set to YES, a side panel will be
+# generated containing a tree-like index structure (just like the one that 
+# is generated for HTML Help). For this to work a browser that supports 
+# JavaScript, DHTML, CSS and frames is required (for instance Mozilla 1.0+, 
+# Netscape 6.0+, Internet explorer 5.0+, or Konqueror). Windows users are 
+# probably better off using the HTML help feature.
+
+GENERATE_TREEVIEW      = NO
+
+# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be 
+# used to set the initial width (in pixels) of the frame in which the tree 
+# is shown.
+
+TREEVIEW_WIDTH         = 250
+
+#---------------------------------------------------------------------------
+# configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_LATEX tag is set to YES (the default) Doxygen will 
+# generate Latex output.
+
+GENERATE_LATEX         = YES
+
+# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `latex' will be used as the default path.
+
+LATEX_OUTPUT           = latex
+
+# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be 
+# invoked. If left blank `latex' will be used as the default command name.
+
+LATEX_CMD_NAME         = latex
+
+# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to 
+# generate index for LaTeX. If left blank `makeindex' will be used as the 
+# default command name.
+
+MAKEINDEX_CMD_NAME     = makeindex
+
+# If the COMPACT_LATEX tag is set to YES Doxygen generates more compact 
+# LaTeX documents. This may be useful for small projects and may help to 
+# save some trees in general.
+
+COMPACT_LATEX          = YES
+
+# The PAPER_TYPE tag can be used to set the paper type that is used 
+# by the printer. Possible values are: a4, a4wide, letter, legal and 
+# executive. If left blank a4wide will be used.
+
+PAPER_TYPE             = a4wide
+
+# The EXTRA_PACKAGES tag can be to specify one or more names of LaTeX 
+# packages that should be included in the LaTeX output.
+
+EXTRA_PACKAGES         = 
+
+# The LATEX_HEADER tag can be used to specify a personal LaTeX header for 
+# the generated latex document. The header should contain everything until 
+# the first chapter. If it is left blank doxygen will generate a 
+# standard header. Notice: only use this tag if you know what you are doing!
+
+LATEX_HEADER           = 
+
+# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated 
+# is prepared for conversion to pdf (using ps2pdf). The pdf file will 
+# contain links (just like the HTML output) instead of page references 
+# This makes the output suitable for online browsing using a pdf viewer.
+
+PDF_HYPERLINKS         = YES
+
+# If the USE_PDFLATEX tag is set to YES, pdflatex will be used instead of 
+# plain latex in the generated Makefile. Set this option to YES to get a 
+# higher quality PDF documentation.
+
+USE_PDFLATEX           = YES
+
+# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \\batchmode. 
+# command to the generated LaTeX files. This will instruct LaTeX to keep 
+# running if errors occur, instead of asking the user for help. 
+# This option is also used when generating formulas in HTML.
+
+LATEX_BATCHMODE        = YES
+
+# If LATEX_HIDE_INDICES is set to YES then doxygen will not 
+# include the index chapters (such as File Index, Compound Index, etc.) 
+# in the output.
+
+LATEX_HIDE_INDICES     = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the RTF output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_RTF tag is set to YES Doxygen will generate RTF output 
+# The RTF output is optimized for Word 97 and may not look very pretty with 
+# other RTF readers or editors.
+
+GENERATE_RTF           = NO
+
+# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `rtf' will be used as the default path.
+
+RTF_OUTPUT             = rtf
+
+# If the COMPACT_RTF tag is set to YES Doxygen generates more compact 
+# RTF documents. This may be useful for small projects and may help to 
+# save some trees in general.
+
+COMPACT_RTF            = NO
+
+# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated 
+# will contain hyperlink fields. The RTF file will 
+# contain links (just like the HTML output) instead of page references. 
+# This makes the output suitable for online browsing using WORD or other 
+# programs which support those fields. 
+# Note: wordpad (write) and others do not support links.
+
+RTF_HYPERLINKS         = NO
+
+# Load stylesheet definitions from file. Syntax is similar to doxygen's 
+# config file, i.e. a series of assignments. You only have to provide 
+# replacements, missing definitions are set to their default value.
+
+RTF_STYLESHEET_FILE    = 
+
+# Set optional variables used in the generation of an rtf document. 
+# Syntax is similar to doxygen's config file.
+
+RTF_EXTENSIONS_FILE    = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the man page output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_MAN tag is set to YES (the default) Doxygen will 
+# generate man pages
+
+GENERATE_MAN           = NO
+
+# The MAN_OUTPUT tag is used to specify where the man pages will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `man' will be used as the default path.
+
+MAN_OUTPUT             = man
+
+# The MAN_EXTENSION tag determines the extension that is added to 
+# the generated man pages (default is the subroutine's section .3)
+
+MAN_EXTENSION          = .3
+
+# If the MAN_LINKS tag is set to YES and Doxygen generates man output, 
+# then it will generate one additional man file for each entity 
+# documented in the real man page(s). These additional files 
+# only source the real man page, but without them the man command 
+# would be unable to find the correct page. The default is NO.
+
+MAN_LINKS              = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the XML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_XML tag is set to YES Doxygen will 
+# generate an XML file that captures the structure of 
+# the code including all documentation.
+
+GENERATE_XML           = NO
+
+# The XML_OUTPUT tag is used to specify where the XML pages will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `xml' will be used as the default path.
+
+XML_OUTPUT             = xml
+
+# The XML_SCHEMA tag can be used to specify an XML schema, 
+# which can be used by a validating XML parser to check the 
+# syntax of the XML files.
+
+XML_SCHEMA             = 
+
+# The XML_DTD tag can be used to specify an XML DTD, 
+# which can be used by a validating XML parser to check the 
+# syntax of the XML files.
+
+XML_DTD                = 
+
+# If the XML_PROGRAMLISTING tag is set to YES Doxygen will 
+# dump the program listings (including syntax highlighting 
+# and cross-referencing information) to the XML output. Note that 
+# enabling this will significantly increase the size of the XML output.
+
+XML_PROGRAMLISTING     = YES
+
+#---------------------------------------------------------------------------
+# configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_AUTOGEN_DEF tag is set to YES Doxygen will 
+# generate an AutoGen Definitions (see autogen.sf.net) file 
+# that captures the structure of the code including all 
+# documentation. Note that this feature is still experimental 
+# and incomplete at the moment.
+
+GENERATE_AUTOGEN_DEF   = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_PERLMOD tag is set to YES Doxygen will 
+# generate a Perl module file that captures the structure of 
+# the code including all documentation. Note that this 
+# feature is still experimental and incomplete at the 
+# moment.
+
+GENERATE_PERLMOD       = NO
+
+# If the PERLMOD_LATEX tag is set to YES Doxygen will generate 
+# the necessary Makefile rules, Perl scripts and LaTeX code to be able 
+# to generate PDF and DVI output from the Perl module output.
+
+PERLMOD_LATEX          = NO
+
+# If the PERLMOD_PRETTY tag is set to YES the Perl module output will be 
+# nicely formatted so it can be parsed by a human reader.  This is useful 
+# if you want to understand what is going on.  On the other hand, if this 
+# tag is set to NO the size of the Perl module output will be much smaller 
+# and Perl will parse it just the same.
+
+PERLMOD_PRETTY         = YES
+
+# The names of the make variables in the generated doxyrules.make file 
+# are prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. 
+# This is useful so different doxyrules.make files included by the same 
+# Makefile don't overwrite each other's variables.
+
+PERLMOD_MAKEVAR_PREFIX = 
+
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor   
+#---------------------------------------------------------------------------
+
+# If the ENABLE_PREPROCESSING tag is set to YES (the default) Doxygen will 
+# evaluate all C-preprocessor directives found in the sources and include 
+# files.
+
+ENABLE_PREPROCESSING   = YES
+
+# If the MACRO_EXPANSION tag is set to YES Doxygen will expand all macro 
+# names in the source code. If set to NO (the default) only conditional 
+# compilation will be performed. Macro expansion can be done in a controlled 
+# way by setting EXPAND_ONLY_PREDEF to YES.
+
+MACRO_EXPANSION        = NO
+
+# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES 
+# then the macro expansion is limited to the macros specified with the 
+# PREDEFINED and EXPAND_AS_DEFINED tags.
+
+EXPAND_ONLY_PREDEF     = NO
+
+# If the SEARCH_INCLUDES tag is set to YES (the default) the includes files 
+# in the INCLUDE_PATH (see below) will be search if a #include is found.
+
+SEARCH_INCLUDES        = YES
+
+# The INCLUDE_PATH tag can be used to specify one or more directories that 
+# contain include files that are not input files but should be processed by 
+# the preprocessor.
+
+INCLUDE_PATH           = 
+
+# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard 
+# patterns (like *.h and *.hpp) to filter out the header-files in the 
+# directories. If left blank, the patterns specified with FILE_PATTERNS will 
+# be used.
+
+INCLUDE_FILE_PATTERNS  = 
+
+# The PREDEFINED tag can be used to specify one or more macro names that 
+# are defined before the preprocessor is started (similar to the -D option of 
+# gcc). The argument of the tag is a list of macros of the form: name 
+# or name=definition (no spaces). If the definition and the = are 
+# omitted =1 is assumed. To prevent a macro definition from being 
+# undefined via #undef or recursively expanded use the := operator 
+# instead of the = operator.
+
+PREDEFINED             = 
+
+# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then 
+# this tag can be used to specify a list of macro names that should be expanded. 
+# The macro definition that is found in the sources will be used. 
+# Use the PREDEFINED tag if you want to use a different macro definition.
+
+EXPAND_AS_DEFINED      = 
+
+# If the SKIP_FUNCTION_MACROS tag is set to YES (the default) then 
+# doxygen's preprocessor will remove all function-like macros that are alone 
+# on a line, have an all uppercase name, and do not end with a semicolon. Such 
+# function macros are typically used for boiler-plate code, and will confuse 
+# the parser if not removed.
+
+SKIP_FUNCTION_MACROS   = YES
+
+#---------------------------------------------------------------------------
+# Configuration::additions related to external references   
+#---------------------------------------------------------------------------
+
+# The TAGFILES option can be used to specify one or more tagfiles. 
+# Optionally an initial location of the external documentation 
+# can be added for each tagfile. The format of a tag file without 
+# this location is as follows: 
+#   TAGFILES = file1 file2 ... 
+# Adding location for the tag files is done as follows: 
+#   TAGFILES = file1=loc1 "file2 = loc2" ... 
+# where "loc1" and "loc2" can be relative or absolute paths or 
+# URLs. If a location is present for each tag, the installdox tool 
+# does not have to be run to correct the links.
+# Note that each tag file must have a unique name
+# (where the name does NOT include the path)
+# If a tag file is not located in the directory in which doxygen 
+# is run, you must also specify the path to the tagfile here.
+
+TAGFILES               = 
+
+# When a file name is specified after GENERATE_TAGFILE, doxygen will create 
+# a tag file that is based on the input files it reads.
+
+GENERATE_TAGFILE       = 
+
+# If the ALLEXTERNALS tag is set to YES all external classes will be listed 
+# in the class index. If set to NO only the inherited external classes 
+# will be listed.
+
+ALLEXTERNALS           = NO
+
+# If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed 
+# in the modules index. If set to NO, only the current project's groups will 
+# be listed.
+
+EXTERNAL_GROUPS        = YES
+
+# The PERL_PATH should be the absolute path and name of the perl script 
+# interpreter (i.e. the result of `which perl').
+
+PERL_PATH              = /usr/bin/perl
+
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool   
+#---------------------------------------------------------------------------
+
+# If the CLASS_DIAGRAMS tag is set to YES (the default) Doxygen will 
+# generate a inheritance diagram (in HTML, RTF and LaTeX) for classes with base 
+# or super classes. Setting the tag to NO turns the diagrams off. Note that 
+# this option is superseded by the HAVE_DOT option below. This is only a 
+# fallback. It is recommended to install and use dot, since it yields more 
+# powerful graphs.
+
+CLASS_DIAGRAMS         = YES
+
+# If set to YES, the inheritance and collaboration graphs will hide 
+# inheritance and usage relations if the target is undocumented 
+# or is not a class.
+
+HIDE_UNDOC_RELATIONS   = YES
+
+# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is 
+# available from the path. This tool is part of Graphviz, a graph visualization 
+# toolkit from AT&T and Lucent Bell Labs. The other options in this section 
+# have no effect if this option is set to NO (the default)
+
+HAVE_DOT               = NO
+
+# If the CLASS_GRAPH and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for each documented class showing the direct and 
+# indirect inheritance relations. Setting this tag to YES will force the 
+# the CLASS_DIAGRAMS tag to NO.
+
+CLASS_GRAPH            = YES
+
+# If the COLLABORATION_GRAPH and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for each documented class showing the direct and 
+# indirect implementation dependencies (inheritance, containment, and 
+# class references variables) of the class with other documented classes.
+
+COLLABORATION_GRAPH    = YES
+
+# If the GROUP_GRAPHS and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for groups, showing the direct groups dependencies
+
+GROUP_GRAPHS           = YES
+
+# If the UML_LOOK tag is set to YES doxygen will generate inheritance and 
+# collaboration diagrams in a style similar to the OMG's Unified Modeling 
+# Language.
+
+UML_LOOK               = NO
+
+# If set to YES, the inheritance and collaboration graphs will show the 
+# relations between templates and their instances.
+
+TEMPLATE_RELATIONS     = NO
+
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDE_GRAPH, and HAVE_DOT 
+# tags are set to YES then doxygen will generate a graph for each documented 
+# file showing the direct and indirect include dependencies of the file with 
+# other documented files.
+
+INCLUDE_GRAPH          = YES
+
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDED_BY_GRAPH, and 
+# HAVE_DOT tags are set to YES then doxygen will generate a graph for each 
+# documented header file showing the documented files that directly or 
+# indirectly include this file.
+
+INCLUDED_BY_GRAPH      = YES
+
+# If the CALL_GRAPH and HAVE_DOT tags are set to YES then doxygen will 
+# generate a call dependency graph for every global function or class method. 
+# Note that enabling this option will significantly increase the time of a run. 
+# So in most cases it will be better to enable call graphs for selected 
+# functions only using the \callgraph command.
+
+CALL_GRAPH             = NO
+
+# If the GRAPHICAL_HIERARCHY and HAVE_DOT tags are set to YES then doxygen 
+# will graphical hierarchy of all classes instead of a textual one.
+
+GRAPHICAL_HIERARCHY    = YES
+
+# If the DIRECTORY_GRAPH, SHOW_DIRECTORIES and HAVE_DOT tags are set to YES 
+# then doxygen will show the dependencies a directory has on other directories 
+# in a graphical way. The dependency relations are determined by the #include
+# relations between the files in the directories.
+
+DIRECTORY_GRAPH        = YES
+
+# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images 
+# generated by dot. Possible values are png, jpg, or gif
+# If left blank png will be used.
+
+DOT_IMAGE_FORMAT       = png
+
+# The tag DOT_PATH can be used to specify the path where the dot tool can be 
+# found. If left blank, it is assumed the dot tool can be found in the path.
+
+DOT_PATH               = 
+
+# The DOTFILE_DIRS tag can be used to specify one or more directories that 
+# contain dot files that are included in the documentation (see the 
+# \dotfile command).
+
+DOTFILE_DIRS           = 
+
+# The MAX_DOT_GRAPH_WIDTH tag can be used to set the maximum allowed width 
+# (in pixels) of the graphs generated by dot. If a graph becomes larger than 
+# this value, doxygen will try to truncate the graph, so that it fits within 
+# the specified constraint. Beware that most browsers cannot cope with very 
+# large images.
+
+MAX_DOT_GRAPH_WIDTH    = 1024
+
+# The MAX_DOT_GRAPH_HEIGHT tag can be used to set the maximum allows height 
+# (in pixels) of the graphs generated by dot. If a graph becomes larger than 
+# this value, doxygen will try to truncate the graph, so that it fits within 
+# the specified constraint. Beware that most browsers cannot cope with very 
+# large images.
+
+MAX_DOT_GRAPH_HEIGHT   = 1024
+
+# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the 
+# graphs generated by dot. A depth value of 3 means that only nodes reachable 
+# from the root by following a path via at most 3 edges will be shown. Nodes 
+# that lay further from the root node will be omitted. Note that setting this 
+# option to 1 or 2 may greatly reduce the computation time needed for large 
+# code bases. Also note that a graph may be further truncated if the graph's 
+# image dimensions are not sufficient to fit the graph (see MAX_DOT_GRAPH_WIDTH 
+# and MAX_DOT_GRAPH_HEIGHT). If 0 is used for the depth value (the default), 
+# the graph is not depth-constrained.
+
+MAX_DOT_GRAPH_DEPTH    = 0
+
+# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent 
+# background. This is disabled by default, which results in a white background. 
+# Warning: Depending on the platform used, enabling this option may lead to 
+# badly anti-aliased labels on the edges of a graph (i.e. they become hard to 
+# read).
+
+DOT_TRANSPARENT        = NO
+
+# Set the DOT_MULTI_TARGETS tag to YES allow dot to generate multiple output 
+# files in one run (i.e. multiple -o and -T options on the command line). This 
+# makes dot run faster, but since only newer versions of dot (>1.8.10) 
+# support this, this feature is disabled by default.
+
+DOT_MULTI_TARGETS      = NO
+
+# If the GENERATE_LEGEND tag is set to YES (the default) Doxygen will 
+# generate a legend page explaining the meaning of the various boxes and 
+# arrows in the dot generated graphs.
+
+GENERATE_LEGEND        = YES
+
+# If the DOT_CLEANUP tag is set to YES (the default) Doxygen will 
+# remove the intermediate dot files that are used to generate 
+# the various graphs.
+
+DOT_CLEANUP            = YES
+
+#---------------------------------------------------------------------------
+# Configuration::additions related to the search engine   
+#---------------------------------------------------------------------------
+
+# The SEARCHENGINE tag specifies whether or not a search engine should be 
+# used. If set to NO the values of all tags below this one will be ignored.
+
+SEARCHENGINE           = NO
diff --git a/src/hid/dxf/doc/dxf-dox-with-call-graphs.dox b/src/hid/dxf/doc/dxf-dox-with-call-graphs.dox
new file mode 100644
index 0000000..b66ed5e
--- /dev/null
+++ b/src/hid/dxf/doc/dxf-dox-with-call-graphs.dox
@@ -0,0 +1,1237 @@
+# Doxyfile 1.4.6
+
+# This file describes the settings to be used by the documentation system
+# doxygen (www.doxygen.org) for a project
+#
+# All text after a hash (#) is considered a comment and will be ignored
+# The format is:
+#       TAG = value [value, ...]
+# For lists items can also be appended using:
+#       TAG += value [value, ...]
+# Values that contain spaces should be placed between quotes (" ")
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+
+# The PROJECT_NAME tag is a single word (or a sequence of words surrounded 
+# by quotes) that should identify the project.
+
+PROJECT_NAME           = PCB-DXF-HID
+
+# The PROJECT_NUMBER tag can be used to enter a project or revision number. 
+# This could be handy for archiving the generated documentation or 
+# if some version control system is used.
+
+PROJECT_NUMBER         = 0.0.2
+
+# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) 
+# base path where the generated documentation will be put. 
+# If a relative path is entered, it will be relative to the location 
+# where doxygen was started. If left blank the current directory will be used.
+
+OUTPUT_DIRECTORY       = 
+
+# If the CREATE_SUBDIRS tag is set to YES, then doxygen will create 
+# 4096 sub-directories (in 2 levels) under the output directory of each output 
+# format and will distribute the generated files over these directories. 
+# Enabling this option can be useful when feeding doxygen a huge amount of 
+# source files, where putting all generated files in the same directory would 
+# otherwise cause performance problems for the file system.
+
+CREATE_SUBDIRS         = NO
+
+# The OUTPUT_LANGUAGE tag is used to specify the language in which all 
+# documentation generated by doxygen is written. Doxygen will use this 
+# information to generate all constant output in the proper language. 
+# The default language is English, other supported languages are: 
+# Brazilian, Catalan, Chinese, Chinese-Traditional, Croatian, Czech, Danish, 
+# Dutch, Finnish, French, German, Greek, Hungarian, Italian, Japanese, 
+# Japanese-en (Japanese with English messages), Korean, Korean-en, Norwegian, 
+# Polish, Portuguese, Romanian, Russian, Serbian, Slovak, Slovene, Spanish, 
+# Swedish, and Ukrainian.
+
+OUTPUT_LANGUAGE        = English
+
+# This tag can be used to specify the encoding used in the generated output. 
+# The encoding is not always determined by the language that is chosen, 
+# but also whether or not the output is meant for Windows or non-Windows users. 
+# In case there is a difference, setting the USE_WINDOWS_ENCODING tag to YES 
+# forces the Windows encoding (this is the default for the Windows binary), 
+# whereas setting the tag to NO uses a Unix-style encoding (the default for 
+# all platforms other than Windows).
+
+USE_WINDOWS_ENCODING   = NO
+
+# If the BRIEF_MEMBER_DESC tag is set to YES (the default) Doxygen will 
+# include brief member descriptions after the members that are listed in 
+# the file and class documentation (similar to JavaDoc). 
+# Set to NO to disable this.
+
+BRIEF_MEMBER_DESC      = YES
+
+# If the REPEAT_BRIEF tag is set to YES (the default) Doxygen will prepend 
+# the brief description of a member or function before the detailed description. 
+# Note: if both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the 
+# brief descriptions will be completely suppressed.
+
+REPEAT_BRIEF           = YES
+
+# This tag implements a quasi-intelligent brief description abbreviator 
+# that is used to form the text in various listings. Each string 
+# in this list, if found as the leading text of the brief description, will be 
+# stripped from the text and the result after processing the whole list, is 
+# used as the annotated text. Otherwise, the brief description is used as-is. 
+# If left blank, the following values are used ("$name" is automatically 
+# replaced with the name of the entity): "The $name class" "The $name widget" 
+# "The $name file" "is" "provides" "specifies" "contains" 
+# "represents" "a" "an" "the"
+
+ABBREVIATE_BRIEF       = 
+
+# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then 
+# Doxygen will generate a detailed section even if there is only a brief 
+# description.
+
+ALWAYS_DETAILED_SEC    = YES
+
+# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all 
+# inherited members of a class in the documentation of that class as if those 
+# members were ordinary class members. Constructors, destructors and assignment 
+# operators of the base classes will not be shown.
+
+INLINE_INHERITED_MEMB  = YES
+
+# If the FULL_PATH_NAMES tag is set to YES then Doxygen will prepend the full 
+# path before files name in the file list and in the header files. If set 
+# to NO the shortest path that makes the file name unique will be used.
+
+FULL_PATH_NAMES        = NO
+
+# If the FULL_PATH_NAMES tag is set to YES then the STRIP_FROM_PATH tag 
+# can be used to strip a user-defined part of the path. Stripping is 
+# only done if one of the specified strings matches the left-hand part of 
+# the path. The tag can be used to show relative paths in the file list. 
+# If left blank the directory from which doxygen is run is used as the 
+# path to strip.
+
+STRIP_FROM_PATH        = 
+
+# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of 
+# the path mentioned in the documentation of a class, which tells 
+# the reader which header file to include in order to use a class. 
+# If left blank only the name of the header file containing the class 
+# definition is used. Otherwise one should specify the include paths that 
+# are normally passed to the compiler using the -I flag.
+
+STRIP_FROM_INC_PATH    = 
+
+# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter 
+# (but less readable) file names. This can be useful is your file systems 
+# doesn't support long names like on DOS, Mac, or CD-ROM.
+
+SHORT_NAMES            = NO
+
+# If the JAVADOC_AUTOBRIEF tag is set to YES then Doxygen 
+# will interpret the first line (until the first dot) of a JavaDoc-style 
+# comment as the brief description. If set to NO, the JavaDoc 
+# comments will behave just like the Qt-style comments (thus requiring an 
+# explicit @brief command for a brief description.
+
+JAVADOC_AUTOBRIEF      = NO
+
+# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make Doxygen 
+# treat a multi-line C++ special comment block (i.e. a block of //! or /// 
+# comments) as a brief description. This used to be the default behaviour. 
+# The new default is to treat a multi-line C++ comment block as a detailed 
+# description. Set this tag to YES if you prefer the old behaviour instead.
+
+MULTILINE_CPP_IS_BRIEF = NO
+
+# If the DETAILS_AT_TOP tag is set to YES then Doxygen 
+# will output the detailed description near the top, like JavaDoc.
+# If set to NO, the detailed description appears after the member 
+# documentation.
+
+DETAILS_AT_TOP         = YES
+
+# If the INHERIT_DOCS tag is set to YES (the default) then an undocumented 
+# member inherits the documentation from any documented member that it 
+# re-implements.
+
+INHERIT_DOCS           = YES
+
+# If the SEPARATE_MEMBER_PAGES tag is set to YES, then doxygen will produce 
+# a new page for each member. If set to NO, the documentation of a member will 
+# be part of the file/class/namespace that contains it.
+
+SEPARATE_MEMBER_PAGES  = NO
+
+# The TAB_SIZE tag can be used to set the number of spaces in a tab. 
+# Doxygen uses this value to replace tabs by spaces in code fragments.
+
+TAB_SIZE               = 8
+
+# This tag can be used to specify a number of aliases that acts 
+# as commands in the documentation. An alias has the form "name=value". 
+# For example adding "sideeffect=\par Side Effects:\n" will allow you to 
+# put the command \sideeffect (or @sideeffect) in the documentation, which 
+# will result in a user-defined paragraph with heading "Side Effects:". 
+# You can put \n's in the value part of an alias to insert newlines.
+
+ALIASES                = 
+
+# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C 
+# sources only. Doxygen will then generate output that is more tailored for C. 
+# For instance, some of the names that are used will be different. The list 
+# of all members will be omitted, etc.
+
+OPTIMIZE_OUTPUT_FOR_C  = YES
+
+# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java 
+# sources only. Doxygen will then generate output that is more tailored for Java. 
+# For instance, namespaces will be presented as packages, qualified scopes 
+# will look different, etc.
+
+OPTIMIZE_OUTPUT_JAVA   = NO
+
+# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want to 
+# include (a tag file for) the STL sources as input, then you should 
+# set this tag to YES in order to let doxygen match functions declarations and 
+# definitions whose arguments contain STL classes (e.g. func(std::string); v.s. 
+# func(std::string) {}). This also make the inheritance and collaboration 
+# diagrams that involve STL classes more complete and accurate.
+
+BUILTIN_STL_SUPPORT    = NO
+
+# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC 
+# tag is set to YES, then doxygen will reuse the documentation of the first 
+# member in the group (if any) for the other members of the group. By default 
+# all members of a group must be documented explicitly.
+
+DISTRIBUTE_GROUP_DOC   = NO
+
+# Set the SUBGROUPING tag to YES (the default) to allow class member groups of 
+# the same type (for instance a group of public functions) to be put as a 
+# subgroup of that type (e.g. under the Public Functions section). Set it to 
+# NO to prevent subgrouping. Alternatively, this can be done per class using 
+# the \nosubgrouping command.
+
+SUBGROUPING            = YES
+
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+
+# If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in 
+# documentation are documented, even if no documentation was available. 
+# Private class members and static file members will be hidden unless 
+# the EXTRACT_PRIVATE and EXTRACT_STATIC tags are set to YES
+
+EXTRACT_ALL            = NO
+
+# If the EXTRACT_PRIVATE tag is set to YES all private members of a class 
+# will be included in the documentation.
+
+EXTRACT_PRIVATE        = NO
+
+# If the EXTRACT_STATIC tag is set to YES all static members of a file 
+# will be included in the documentation.
+
+EXTRACT_STATIC         = YES
+
+# If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs) 
+# defined locally in source files will be included in the documentation. 
+# If set to NO only classes defined in header files are included.
+
+EXTRACT_LOCAL_CLASSES  = YES
+
+# This flag is only useful for Objective-C code. When set to YES local 
+# methods, which are defined in the implementation section but not in 
+# the interface are included in the documentation. 
+# If set to NO (the default) only methods in the interface are included.
+
+EXTRACT_LOCAL_METHODS  = NO
+
+# If the HIDE_UNDOC_MEMBERS tag is set to YES, Doxygen will hide all 
+# undocumented members of documented classes, files or namespaces. 
+# If set to NO (the default) these members will be included in the 
+# various overviews, but no documentation section is generated. 
+# This option has no effect if EXTRACT_ALL is enabled.
+
+HIDE_UNDOC_MEMBERS     = NO
+
+# If the HIDE_UNDOC_CLASSES tag is set to YES, Doxygen will hide all 
+# undocumented classes that are normally visible in the class hierarchy. 
+# If set to NO (the default) these classes will be included in the various 
+# overviews. This option has no effect if EXTRACT_ALL is enabled.
+
+HIDE_UNDOC_CLASSES     = NO
+
+# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, Doxygen will hide all 
+# friend (class|struct|union) declarations. 
+# If set to NO (the default) these declarations will be included in the 
+# documentation.
+
+HIDE_FRIEND_COMPOUNDS  = NO
+
+# If the HIDE_IN_BODY_DOCS tag is set to YES, Doxygen will hide any 
+# documentation blocks found inside the body of a function. 
+# If set to NO (the default) these blocks will be appended to the 
+# function's detailed documentation block.
+
+HIDE_IN_BODY_DOCS      = NO
+
+# The INTERNAL_DOCS tag determines if documentation 
+# that is typed after a \internal command is included. If the tag is set 
+# to NO (the default) then the documentation will be excluded. 
+# Set it to YES to include the internal documentation.
+
+INTERNAL_DOCS          = NO
+
+# If the CASE_SENSE_NAMES tag is set to NO then Doxygen will only generate 
+# file names in lower-case letters. If set to YES upper-case letters are also 
+# allowed. This is useful if you have classes or files whose names only differ 
+# in case and if your file system supports case sensitive file names. Windows 
+# and Mac users are advised to set this option to NO.
+
+CASE_SENSE_NAMES       = YES
+
+# If the HIDE_SCOPE_NAMES tag is set to NO (the default) then Doxygen 
+# will show members with their full class and namespace scopes in the 
+# documentation. If set to YES the scope will be hidden.
+
+HIDE_SCOPE_NAMES       = NO
+
+# If the SHOW_INCLUDE_FILES tag is set to YES (the default) then Doxygen 
+# will put a list of the files that are included by a file in the documentation 
+# of that file.
+
+SHOW_INCLUDE_FILES     = YES
+
+# If the INLINE_INFO tag is set to YES (the default) then a tag [inline] 
+# is inserted in the documentation for inline members.
+
+INLINE_INFO            = YES
+
+# If the SORT_MEMBER_DOCS tag is set to YES (the default) then doxygen 
+# will sort the (detailed) documentation of file and class members 
+# alphabetically by member name. If set to NO the members will appear in 
+# declaration order.
+
+SORT_MEMBER_DOCS       = YES
+
+# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the 
+# brief documentation of file, namespace and class members alphabetically 
+# by member name. If set to NO (the default) the members will appear in 
+# declaration order.
+
+SORT_BRIEF_DOCS        = NO
+
+# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be 
+# sorted by fully-qualified names, including namespaces. If set to 
+# NO (the default), the class list will be sorted only by class name, 
+# not including the namespace part. 
+# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
+# Note: This option applies only to the class list, not to the 
+# alphabetical list.
+
+SORT_BY_SCOPE_NAME     = NO
+
+# The GENERATE_TODOLIST tag can be used to enable (YES) or 
+# disable (NO) the todo list. This list is created by putting \todo 
+# commands in the documentation.
+
+GENERATE_TODOLIST      = YES
+
+# The GENERATE_TESTLIST tag can be used to enable (YES) or 
+# disable (NO) the test list. This list is created by putting \test 
+# commands in the documentation.
+
+GENERATE_TESTLIST      = YES
+
+# The GENERATE_BUGLIST tag can be used to enable (YES) or 
+# disable (NO) the bug list. This list is created by putting \bug 
+# commands in the documentation.
+
+GENERATE_BUGLIST       = YES
+
+# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or 
+# disable (NO) the deprecated list. This list is created by putting 
+# \deprecated commands in the documentation.
+
+GENERATE_DEPRECATEDLIST= YES
+
+# The ENABLED_SECTIONS tag can be used to enable conditional 
+# documentation sections, marked by \if sectionname ... \endif.
+
+ENABLED_SECTIONS       = 
+
+# The MAX_INITIALIZER_LINES tag determines the maximum number of lines 
+# the initial value of a variable or define consists of for it to appear in 
+# the documentation. If the initializer consists of more lines than specified 
+# here it will be hidden. Use a value of 0 to hide initializers completely. 
+# The appearance of the initializer of individual variables and defines in the 
+# documentation can be controlled using \showinitializer or \hideinitializer 
+# command in the documentation regardless of this setting.
+
+MAX_INITIALIZER_LINES  = 30
+
+# Set the SHOW_USED_FILES tag to NO to disable the list of files generated 
+# at the bottom of the documentation of classes and structs. If set to YES the 
+# list will mention the files that were used to generate the documentation.
+
+SHOW_USED_FILES        = YES
+
+# If the sources in your project are distributed over multiple directories 
+# then setting the SHOW_DIRECTORIES tag to YES will show the directory hierarchy 
+# in the documentation. The default is NO.
+
+SHOW_DIRECTORIES       = NO
+
+# The FILE_VERSION_FILTER tag can be used to specify a program or script that 
+# doxygen should invoke to get the current version for each file (typically from the 
+# version control system). Doxygen will invoke the program by executing (via 
+# popen()) the command <command> <input-file>, where <command> is the value of 
+# the FILE_VERSION_FILTER tag, and <input-file> is the name of an input file 
+# provided by doxygen. Whatever the program writes to standard output 
+# is used as the file version. See the manual for examples.
+
+FILE_VERSION_FILTER    = 
+
+#---------------------------------------------------------------------------
+# configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+
+# The QUIET tag can be used to turn on/off the messages that are generated 
+# by doxygen. Possible values are YES and NO. If left blank NO is used.
+
+QUIET                  = NO
+
+# The WARNINGS tag can be used to turn on/off the warning messages that are 
+# generated by doxygen. Possible values are YES and NO. If left blank 
+# NO is used.
+
+WARNINGS               = YES
+
+# If WARN_IF_UNDOCUMENTED is set to YES, then doxygen will generate warnings 
+# for undocumented members. If EXTRACT_ALL is set to YES then this flag will 
+# automatically be disabled.
+
+WARN_IF_UNDOCUMENTED   = YES
+
+# If WARN_IF_DOC_ERROR is set to YES, doxygen will generate warnings for 
+# potential errors in the documentation, such as not documenting some 
+# parameters in a documented function, or documenting parameters that 
+# don't exist or using markup commands wrongly.
+
+WARN_IF_DOC_ERROR      = YES
+
+# This WARN_NO_PARAMDOC option can be abled to get warnings for 
+# functions that are documented, but have no documentation for their parameters 
+# or return value. If set to NO (the default) doxygen will only warn about 
+# wrong or incomplete parameter documentation, but not about the absence of 
+# documentation.
+
+WARN_NO_PARAMDOC       = NO
+
+# The WARN_FORMAT tag determines the format of the warning messages that 
+# doxygen can produce. The string should contain the $file, $line, and $text 
+# tags, which will be replaced by the file and line number from which the 
+# warning originated and the warning text. Optionally the format may contain 
+# $version, which will be replaced by the version of the file (if it could 
+# be obtained via FILE_VERSION_FILTER)
+
+WARN_FORMAT            = "$file:$line: $text"
+
+# The WARN_LOGFILE tag can be used to specify a file to which warning 
+# and error messages should be written. If left blank the output is written 
+# to stderr.
+
+WARN_LOGFILE           = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the input files
+#---------------------------------------------------------------------------
+
+# The INPUT tag can be used to specify the files and/or directories that contain 
+# documented source files. You may enter file names like "myfile.cpp" or 
+# directories like "/usr/src/myproject". Separate the files or directories 
+# with spaces.
+
+INPUT                  = .. ../doc/pcb-dxf-hid-main.txt
+
+# If the value of the INPUT tag contains directories, you can use the 
+# FILE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp 
+# and *.h) to filter out the source-files in the directories. If left 
+# blank the following patterns are tested: 
+# *.c *.cc *.cxx *.cpp *.c++ *.java *.ii *.ixx *.ipp *.i++ *.inl *.h *.hh *.hxx 
+# *.hpp *.h++ *.idl *.odl *.cs *.php *.php3 *.inc *.m *.mm *.py
+
+FILE_PATTERNS          = *.c *.h
+
+# The RECURSIVE tag can be used to turn specify whether or not subdirectories 
+# should be searched for input files as well. Possible values are YES and NO. 
+# If left blank NO is used.
+
+RECURSIVE              = YES
+
+# The EXCLUDE tag can be used to specify files and/or directories that should 
+# excluded from the INPUT source files. This way you can easily exclude a 
+# subdirectory from a directory tree whose root is specified with the INPUT tag.
+
+EXCLUDE                = 
+
+# The EXCLUDE_SYMLINKS tag can be used select whether or not files or 
+# directories that are symbolic links (a Unix filesystem feature) are excluded 
+# from the input.
+
+EXCLUDE_SYMLINKS       = NO
+
+# If the value of the INPUT tag contains directories, you can use the 
+# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude 
+# certain files from those directories. Note that the wildcards are matched 
+# against the file with absolute path, so to exclude all test directories 
+# for example use the pattern */test/*
+
+EXCLUDE_PATTERNS       = 
+
+# The EXAMPLE_PATH tag can be used to specify one or more files or 
+# directories that contain example code fragments that are included (see 
+# the \include command).
+
+EXAMPLE_PATH           = ../doc
+
+# If the value of the EXAMPLE_PATH tag contains directories, you can use the 
+# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp 
+# and *.h) to filter out the source-files in the directories. If left 
+# blank all files are included.
+
+EXAMPLE_PATTERNS       = 
+
+# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be 
+# searched for input files to be used with the \include or \dontinclude 
+# commands irrespective of the value of the RECURSIVE tag. 
+# Possible values are YES and NO. If left blank NO is used.
+
+EXAMPLE_RECURSIVE      = NO
+
+# The IMAGE_PATH tag can be used to specify one or more files or 
+# directories that contain image that are included in the documentation (see 
+# the \image command).
+
+IMAGE_PATH             = ../doc
+
+# The INPUT_FILTER tag can be used to specify a program that doxygen should 
+# invoke to filter for each input file. Doxygen will invoke the filter program 
+# by executing (via popen()) the command <filter> <input-file>, where <filter> 
+# is the value of the INPUT_FILTER tag, and <input-file> is the name of an 
+# input file. Doxygen will then use the output that the filter program writes 
+# to standard output.  If FILTER_PATTERNS is specified, this tag will be 
+# ignored.
+
+INPUT_FILTER           = 
+
+# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern 
+# basis.  Doxygen will compare the file name with each pattern and apply the 
+# filter if there is a match.  The filters are a list of the form: 
+# pattern=filter (like *.cpp=my_cpp_filter). See INPUT_FILTER for further 
+# info on how filters are used. If FILTER_PATTERNS is empty, INPUT_FILTER 
+# is applied to all files.
+
+FILTER_PATTERNS        = 
+
+# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using 
+# INPUT_FILTER) will be used to filter the input files when producing source 
+# files to browse (i.e. when SOURCE_BROWSER is set to YES).
+
+FILTER_SOURCE_FILES    = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to source browsing
+#---------------------------------------------------------------------------
+
+# If the SOURCE_BROWSER tag is set to YES then a list of source files will 
+# be generated. Documented entities will be cross-referenced with these sources. 
+# Note: To get rid of all source code in the generated output, make sure also 
+# VERBATIM_HEADERS is set to NO.
+
+SOURCE_BROWSER         = YES
+
+# Setting the INLINE_SOURCES tag to YES will include the body 
+# of functions and classes directly in the documentation.
+
+INLINE_SOURCES         = NO
+
+# Setting the STRIP_CODE_COMMENTS tag to YES (the default) will instruct 
+# doxygen to hide any special comment blocks from generated source code 
+# fragments. Normal C and C++ comments will always remain visible.
+
+STRIP_CODE_COMMENTS    = YES
+
+# If the REFERENCED_BY_RELATION tag is set to YES (the default) 
+# then for each documented function all documented 
+# functions referencing it will be listed.
+
+REFERENCED_BY_RELATION = YES
+
+# If the REFERENCES_RELATION tag is set to YES (the default) 
+# then for each documented function all documented entities 
+# called/used by that function will be listed.
+
+REFERENCES_RELATION    = YES
+
+# If the USE_HTAGS tag is set to YES then the references to source code 
+# will point to the HTML generated by the htags(1) tool instead of doxygen 
+# built-in source browser. The htags tool is part of GNU's global source 
+# tagging system (see http://www.gnu.org/software/global/global.html). You 
+# will need version 4.8.6 or higher.
+
+USE_HTAGS              = NO
+
+# If the VERBATIM_HEADERS tag is set to YES (the default) then Doxygen 
+# will generate a verbatim copy of the header file for each class for 
+# which an include is specified. Set to NO to disable this.
+
+VERBATIM_HEADERS       = YES
+
+#---------------------------------------------------------------------------
+# configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+
+# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index 
+# of all compounds will be generated. Enable this if the project 
+# contains a lot of classes, structs, unions or interfaces.
+
+ALPHABETICAL_INDEX     = YES
+
+# If the alphabetical index is enabled (see ALPHABETICAL_INDEX) then 
+# the COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns 
+# in which this list will be split (can be a number in the range [1..20])
+
+COLS_IN_ALPHA_INDEX    = 5
+
+# In case all classes in a project start with a common prefix, all 
+# classes will be put under the same header in the alphabetical index. 
+# The IGNORE_PREFIX tag can be used to specify one or more prefixes that 
+# should be ignored while generating the index headers.
+
+IGNORE_PREFIX          = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the HTML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_HTML tag is set to YES (the default) Doxygen will 
+# generate HTML output.
+
+GENERATE_HTML          = YES
+
+# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `html' will be used as the default path.
+
+HTML_OUTPUT            = html
+
+# The HTML_FILE_EXTENSION tag can be used to specify the file extension for 
+# each generated HTML page (for example: .htm,.php,.asp). If it is left blank 
+# doxygen will generate files with .html extension.
+
+HTML_FILE_EXTENSION    = .html
+
+# The HTML_HEADER tag can be used to specify a personal HTML header for 
+# each generated HTML page. If it is left blank doxygen will generate a 
+# standard header.
+
+HTML_HEADER            = 
+
+# The HTML_FOOTER tag can be used to specify a personal HTML footer for 
+# each generated HTML page. If it is left blank doxygen will generate a 
+# standard footer.
+
+HTML_FOOTER            = 
+
+# The HTML_STYLESHEET tag can be used to specify a user-defined cascading 
+# style sheet that is used by each HTML page. It can be used to 
+# fine-tune the look of the HTML output. If the tag is left blank doxygen 
+# will generate a default style sheet. Note that doxygen will try to copy 
+# the style sheet file to the HTML output directory, so don't put your own 
+# stylesheet in the HTML output directory as well, or it will be erased!
+
+HTML_STYLESHEET        = 
+
+# If the HTML_ALIGN_MEMBERS tag is set to YES, the members of classes, 
+# files or namespaces will be aligned in HTML using tables. If set to 
+# NO a bullet list will be used.
+
+HTML_ALIGN_MEMBERS     = YES
+
+# If the GENERATE_HTMLHELP tag is set to YES, additional index files 
+# will be generated that can be used as input for tools like the 
+# Microsoft HTML help workshop to generate a compressed HTML help file (.chm) 
+# of the generated HTML documentation.
+
+GENERATE_HTMLHELP      = NO
+
+# If the GENERATE_HTMLHELP tag is set to YES, the CHM_FILE tag can 
+# be used to specify the file name of the resulting .chm file. You 
+# can add a path in front of the file if the result should not be 
+# written to the html output directory.
+
+CHM_FILE               = 
+
+# If the GENERATE_HTMLHELP tag is set to YES, the HHC_LOCATION tag can 
+# be used to specify the location (absolute path including file name) of 
+# the HTML help compiler (hhc.exe). If non-empty doxygen will try to run 
+# the HTML help compiler on the generated index.hhp.
+
+HHC_LOCATION           = 
+
+# If the GENERATE_HTMLHELP tag is set to YES, the GENERATE_CHI flag 
+# controls if a separate .chi index file is generated (YES) or that 
+# it should be included in the master .chm file (NO).
+
+GENERATE_CHI           = NO
+
+# If the GENERATE_HTMLHELP tag is set to YES, the BINARY_TOC flag 
+# controls whether a binary table of contents is generated (YES) or a 
+# normal table of contents (NO) in the .chm file.
+
+BINARY_TOC             = NO
+
+# The TOC_EXPAND flag can be set to YES to add extra items for group members 
+# to the contents of the HTML help documentation and to the tree view.
+
+TOC_EXPAND             = NO
+
+# The DISABLE_INDEX tag can be used to turn on/off the condensed index at 
+# top of each HTML page. The value NO (the default) enables the index and 
+# the value YES disables it.
+
+DISABLE_INDEX          = NO
+
+# This tag can be used to set the number of enum values (range [1..20]) 
+# that doxygen will group on one line in the generated HTML documentation.
+
+ENUM_VALUES_PER_LINE   = 4
+
+# If the GENERATE_TREEVIEW tag is set to YES, a side panel will be
+# generated containing a tree-like index structure (just like the one that 
+# is generated for HTML Help). For this to work a browser that supports 
+# JavaScript, DHTML, CSS and frames is required (for instance Mozilla 1.0+, 
+# Netscape 6.0+, Internet explorer 5.0+, or Konqueror). Windows users are 
+# probably better off using the HTML help feature.
+
+GENERATE_TREEVIEW      = NO
+
+# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be 
+# used to set the initial width (in pixels) of the frame in which the tree 
+# is shown.
+
+TREEVIEW_WIDTH         = 250
+
+#---------------------------------------------------------------------------
+# configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_LATEX tag is set to YES (the default) Doxygen will 
+# generate Latex output.
+
+GENERATE_LATEX         = YES
+
+# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `latex' will be used as the default path.
+
+LATEX_OUTPUT           = latex
+
+# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be 
+# invoked. If left blank `latex' will be used as the default command name.
+
+LATEX_CMD_NAME         = latex
+
+# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to 
+# generate index for LaTeX. If left blank `makeindex' will be used as the 
+# default command name.
+
+MAKEINDEX_CMD_NAME     = makeindex
+
+# If the COMPACT_LATEX tag is set to YES Doxygen generates more compact 
+# LaTeX documents. This may be useful for small projects and may help to 
+# save some trees in general.
+
+COMPACT_LATEX          = YES
+
+# The PAPER_TYPE tag can be used to set the paper type that is used 
+# by the printer. Possible values are: a4, a4wide, letter, legal and 
+# executive. If left blank a4wide will be used.
+
+PAPER_TYPE             = a4wide
+
+# The EXTRA_PACKAGES tag can be to specify one or more names of LaTeX 
+# packages that should be included in the LaTeX output.
+
+EXTRA_PACKAGES         = 
+
+# The LATEX_HEADER tag can be used to specify a personal LaTeX header for 
+# the generated latex document. The header should contain everything until 
+# the first chapter. If it is left blank doxygen will generate a 
+# standard header. Notice: only use this tag if you know what you are doing!
+
+LATEX_HEADER           = 
+
+# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated 
+# is prepared for conversion to pdf (using ps2pdf). The pdf file will 
+# contain links (just like the HTML output) instead of page references 
+# This makes the output suitable for online browsing using a pdf viewer.
+
+PDF_HYPERLINKS         = YES
+
+# If the USE_PDFLATEX tag is set to YES, pdflatex will be used instead of 
+# plain latex in the generated Makefile. Set this option to YES to get a 
+# higher quality PDF documentation.
+
+USE_PDFLATEX           = YES
+
+# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \\batchmode. 
+# command to the generated LaTeX files. This will instruct LaTeX to keep 
+# running if errors occur, instead of asking the user for help. 
+# This option is also used when generating formulas in HTML.
+
+LATEX_BATCHMODE        = YES
+
+# If LATEX_HIDE_INDICES is set to YES then doxygen will not 
+# include the index chapters (such as File Index, Compound Index, etc.) 
+# in the output.
+
+LATEX_HIDE_INDICES     = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the RTF output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_RTF tag is set to YES Doxygen will generate RTF output 
+# The RTF output is optimized for Word 97 and may not look very pretty with 
+# other RTF readers or editors.
+
+GENERATE_RTF           = NO
+
+# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `rtf' will be used as the default path.
+
+RTF_OUTPUT             = rtf
+
+# If the COMPACT_RTF tag is set to YES Doxygen generates more compact 
+# RTF documents. This may be useful for small projects and may help to 
+# save some trees in general.
+
+COMPACT_RTF            = NO
+
+# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated 
+# will contain hyperlink fields. The RTF file will 
+# contain links (just like the HTML output) instead of page references. 
+# This makes the output suitable for online browsing using WORD or other 
+# programs which support those fields. 
+# Note: wordpad (write) and others do not support links.
+
+RTF_HYPERLINKS         = NO
+
+# Load stylesheet definitions from file. Syntax is similar to doxygen's 
+# config file, i.e. a series of assignments. You only have to provide 
+# replacements, missing definitions are set to their default value.
+
+RTF_STYLESHEET_FILE    = 
+
+# Set optional variables used in the generation of an rtf document. 
+# Syntax is similar to doxygen's config file.
+
+RTF_EXTENSIONS_FILE    = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the man page output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_MAN tag is set to YES (the default) Doxygen will 
+# generate man pages
+
+GENERATE_MAN           = NO
+
+# The MAN_OUTPUT tag is used to specify where the man pages will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `man' will be used as the default path.
+
+MAN_OUTPUT             = man
+
+# The MAN_EXTENSION tag determines the extension that is added to 
+# the generated man pages (default is the subroutine's section .3)
+
+MAN_EXTENSION          = .3
+
+# If the MAN_LINKS tag is set to YES and Doxygen generates man output, 
+# then it will generate one additional man file for each entity 
+# documented in the real man page(s). These additional files 
+# only source the real man page, but without them the man command 
+# would be unable to find the correct page. The default is NO.
+
+MAN_LINKS              = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the XML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_XML tag is set to YES Doxygen will 
+# generate an XML file that captures the structure of 
+# the code including all documentation.
+
+GENERATE_XML           = NO
+
+# The XML_OUTPUT tag is used to specify where the XML pages will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `xml' will be used as the default path.
+
+XML_OUTPUT             = xml
+
+# The XML_SCHEMA tag can be used to specify an XML schema, 
+# which can be used by a validating XML parser to check the 
+# syntax of the XML files.
+
+XML_SCHEMA             = 
+
+# The XML_DTD tag can be used to specify an XML DTD, 
+# which can be used by a validating XML parser to check the 
+# syntax of the XML files.
+
+XML_DTD                = 
+
+# If the XML_PROGRAMLISTING tag is set to YES Doxygen will 
+# dump the program listings (including syntax highlighting 
+# and cross-referencing information) to the XML output. Note that 
+# enabling this will significantly increase the size of the XML output.
+
+XML_PROGRAMLISTING     = YES
+
+#---------------------------------------------------------------------------
+# configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_AUTOGEN_DEF tag is set to YES Doxygen will 
+# generate an AutoGen Definitions (see autogen.sf.net) file 
+# that captures the structure of the code including all 
+# documentation. Note that this feature is still experimental 
+# and incomplete at the moment.
+
+GENERATE_AUTOGEN_DEF   = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_PERLMOD tag is set to YES Doxygen will 
+# generate a Perl module file that captures the structure of 
+# the code including all documentation. Note that this 
+# feature is still experimental and incomplete at the 
+# moment.
+
+GENERATE_PERLMOD       = NO
+
+# If the PERLMOD_LATEX tag is set to YES Doxygen will generate 
+# the necessary Makefile rules, Perl scripts and LaTeX code to be able 
+# to generate PDF and DVI output from the Perl module output.
+
+PERLMOD_LATEX          = NO
+
+# If the PERLMOD_PRETTY tag is set to YES the Perl module output will be 
+# nicely formatted so it can be parsed by a human reader.  This is useful 
+# if you want to understand what is going on.  On the other hand, if this 
+# tag is set to NO the size of the Perl module output will be much smaller 
+# and Perl will parse it just the same.
+
+PERLMOD_PRETTY         = YES
+
+# The names of the make variables in the generated doxyrules.make file 
+# are prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. 
+# This is useful so different doxyrules.make files included by the same 
+# Makefile don't overwrite each other's variables.
+
+PERLMOD_MAKEVAR_PREFIX = 
+
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor   
+#---------------------------------------------------------------------------
+
+# If the ENABLE_PREPROCESSING tag is set to YES (the default) Doxygen will 
+# evaluate all C-preprocessor directives found in the sources and include 
+# files.
+
+ENABLE_PREPROCESSING   = YES
+
+# If the MACRO_EXPANSION tag is set to YES Doxygen will expand all macro 
+# names in the source code. If set to NO (the default) only conditional 
+# compilation will be performed. Macro expansion can be done in a controlled 
+# way by setting EXPAND_ONLY_PREDEF to YES.
+
+MACRO_EXPANSION        = NO
+
+# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES 
+# then the macro expansion is limited to the macros specified with the 
+# PREDEFINED and EXPAND_AS_DEFINED tags.
+
+EXPAND_ONLY_PREDEF     = NO
+
+# If the SEARCH_INCLUDES tag is set to YES (the default) the includes files 
+# in the INCLUDE_PATH (see below) will be search if a #include is found.
+
+SEARCH_INCLUDES        = YES
+
+# The INCLUDE_PATH tag can be used to specify one or more directories that 
+# contain include files that are not input files but should be processed by 
+# the preprocessor.
+
+INCLUDE_PATH           = 
+
+# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard 
+# patterns (like *.h and *.hpp) to filter out the header-files in the 
+# directories. If left blank, the patterns specified with FILE_PATTERNS will 
+# be used.
+
+INCLUDE_FILE_PATTERNS  = 
+
+# The PREDEFINED tag can be used to specify one or more macro names that 
+# are defined before the preprocessor is started (similar to the -D option of 
+# gcc). The argument of the tag is a list of macros of the form: name 
+# or name=definition (no spaces). If the definition and the = are 
+# omitted =1 is assumed. To prevent a macro definition from being 
+# undefined via #undef or recursively expanded use the := operator 
+# instead of the = operator.
+
+PREDEFINED             = 
+
+# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then 
+# this tag can be used to specify a list of macro names that should be expanded. 
+# The macro definition that is found in the sources will be used. 
+# Use the PREDEFINED tag if you want to use a different macro definition.
+
+EXPAND_AS_DEFINED      = 
+
+# If the SKIP_FUNCTION_MACROS tag is set to YES (the default) then 
+# doxygen's preprocessor will remove all function-like macros that are alone 
+# on a line, have an all uppercase name, and do not end with a semicolon. Such 
+# function macros are typically used for boiler-plate code, and will confuse 
+# the parser if not removed.
+
+SKIP_FUNCTION_MACROS   = YES
+
+#---------------------------------------------------------------------------
+# Configuration::additions related to external references   
+#---------------------------------------------------------------------------
+
+# The TAGFILES option can be used to specify one or more tagfiles. 
+# Optionally an initial location of the external documentation 
+# can be added for each tagfile. The format of a tag file without 
+# this location is as follows: 
+#   TAGFILES = file1 file2 ... 
+# Adding location for the tag files is done as follows: 
+#   TAGFILES = file1=loc1 "file2 = loc2" ... 
+# where "loc1" and "loc2" can be relative or absolute paths or 
+# URLs. If a location is present for each tag, the installdox tool 
+# does not have to be run to correct the links.
+# Note that each tag file must have a unique name
+# (where the name does NOT include the path)
+# If a tag file is not located in the directory in which doxygen 
+# is run, you must also specify the path to the tagfile here.
+
+TAGFILES               = 
+
+# When a file name is specified after GENERATE_TAGFILE, doxygen will create 
+# a tag file that is based on the input files it reads.
+
+GENERATE_TAGFILE       = 
+
+# If the ALLEXTERNALS tag is set to YES all external classes will be listed 
+# in the class index. If set to NO only the inherited external classes 
+# will be listed.
+
+ALLEXTERNALS           = NO
+
+# If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed 
+# in the modules index. If set to NO, only the current project's groups will 
+# be listed.
+
+EXTERNAL_GROUPS        = YES
+
+# The PERL_PATH should be the absolute path and name of the perl script 
+# interpreter (i.e. the result of `which perl').
+
+PERL_PATH              = /usr/bin/perl
+
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool   
+#---------------------------------------------------------------------------
+
+# If the CLASS_DIAGRAMS tag is set to YES (the default) Doxygen will 
+# generate a inheritance diagram (in HTML, RTF and LaTeX) for classes with base 
+# or super classes. Setting the tag to NO turns the diagrams off. Note that 
+# this option is superseded by the HAVE_DOT option below. This is only a 
+# fallback. It is recommended to install and use dot, since it yields more 
+# powerful graphs.
+
+CLASS_DIAGRAMS         = YES
+
+# If set to YES, the inheritance and collaboration graphs will hide 
+# inheritance and usage relations if the target is undocumented 
+# or is not a class.
+
+HIDE_UNDOC_RELATIONS   = YES
+
+# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is 
+# available from the path. This tool is part of Graphviz, a graph visualization 
+# toolkit from AT&T and Lucent Bell Labs. The other options in this section 
+# have no effect if this option is set to NO (the default)
+
+HAVE_DOT               = YES
+
+# If the CLASS_GRAPH and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for each documented class showing the direct and 
+# indirect inheritance relations. Setting this tag to YES will force the 
+# the CLASS_DIAGRAMS tag to NO.
+
+CLASS_GRAPH            = YES
+
+# If the COLLABORATION_GRAPH and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for each documented class showing the direct and 
+# indirect implementation dependencies (inheritance, containment, and 
+# class references variables) of the class with other documented classes.
+
+COLLABORATION_GRAPH    = YES
+
+# If the GROUP_GRAPHS and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for groups, showing the direct groups dependencies
+
+GROUP_GRAPHS           = YES
+
+# If the UML_LOOK tag is set to YES doxygen will generate inheritance and 
+# collaboration diagrams in a style similar to the OMG's Unified Modeling 
+# Language.
+
+UML_LOOK               = NO
+
+# If set to YES, the inheritance and collaboration graphs will show the 
+# relations between templates and their instances.
+
+TEMPLATE_RELATIONS     = NO
+
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDE_GRAPH, and HAVE_DOT 
+# tags are set to YES then doxygen will generate a graph for each documented 
+# file showing the direct and indirect include dependencies of the file with 
+# other documented files.
+
+INCLUDE_GRAPH          = YES
+
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDED_BY_GRAPH, and 
+# HAVE_DOT tags are set to YES then doxygen will generate a graph for each 
+# documented header file showing the documented files that directly or 
+# indirectly include this file.
+
+INCLUDED_BY_GRAPH      = YES
+
+# If the CALL_GRAPH and HAVE_DOT tags are set to YES then doxygen will 
+# generate a call dependency graph for every global function or class method. 
+# Note that enabling this option will significantly increase the time of a run. 
+# So in most cases it will be better to enable call graphs for selected 
+# functions only using the \callgraph command.
+
+CALL_GRAPH             = YES
+
+# If the GRAPHICAL_HIERARCHY and HAVE_DOT tags are set to YES then doxygen 
+# will graphical hierarchy of all classes instead of a textual one.
+
+GRAPHICAL_HIERARCHY    = YES
+
+# If the DIRECTORY_GRAPH, SHOW_DIRECTORIES and HAVE_DOT tags are set to YES 
+# then doxygen will show the dependencies a directory has on other directories 
+# in a graphical way. The dependency relations are determined by the #include
+# relations between the files in the directories.
+
+DIRECTORY_GRAPH        = YES
+
+# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images 
+# generated by dot. Possible values are png, jpg, or gif
+# If left blank png will be used.
+
+DOT_IMAGE_FORMAT       = png
+
+# The tag DOT_PATH can be used to specify the path where the dot tool can be 
+# found. If left blank, it is assumed the dot tool can be found in the path.
+
+DOT_PATH               = 
+
+# The DOTFILE_DIRS tag can be used to specify one or more directories that 
+# contain dot files that are included in the documentation (see the 
+# \dotfile command).
+
+DOTFILE_DIRS           = 
+
+# The MAX_DOT_GRAPH_WIDTH tag can be used to set the maximum allowed width 
+# (in pixels) of the graphs generated by dot. If a graph becomes larger than 
+# this value, doxygen will try to truncate the graph, so that it fits within 
+# the specified constraint. Beware that most browsers cannot cope with very 
+# large images.
+
+MAX_DOT_GRAPH_WIDTH    = 1024
+
+# The MAX_DOT_GRAPH_HEIGHT tag can be used to set the maximum allows height 
+# (in pixels) of the graphs generated by dot. If a graph becomes larger than 
+# this value, doxygen will try to truncate the graph, so that it fits within 
+# the specified constraint. Beware that most browsers cannot cope with very 
+# large images.
+
+MAX_DOT_GRAPH_HEIGHT   = 1024
+
+# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the 
+# graphs generated by dot. A depth value of 3 means that only nodes reachable 
+# from the root by following a path via at most 3 edges will be shown. Nodes 
+# that lay further from the root node will be omitted. Note that setting this 
+# option to 1 or 2 may greatly reduce the computation time needed for large 
+# code bases. Also note that a graph may be further truncated if the graph's 
+# image dimensions are not sufficient to fit the graph (see MAX_DOT_GRAPH_WIDTH 
+# and MAX_DOT_GRAPH_HEIGHT). If 0 is used for the depth value (the default), 
+# the graph is not depth-constrained.
+
+MAX_DOT_GRAPH_DEPTH    = 0
+
+# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent 
+# background. This is disabled by default, which results in a white background. 
+# Warning: Depending on the platform used, enabling this option may lead to 
+# badly anti-aliased labels on the edges of a graph (i.e. they become hard to 
+# read).
+
+DOT_TRANSPARENT        = YES
+
+# Set the DOT_MULTI_TARGETS tag to YES allow dot to generate multiple output 
+# files in one run (i.e. multiple -o and -T options on the command line). This 
+# makes dot run faster, but since only newer versions of dot (>1.8.10) 
+# support this, this feature is disabled by default.
+
+DOT_MULTI_TARGETS      = NO
+
+# If the GENERATE_LEGEND tag is set to YES (the default) Doxygen will 
+# generate a legend page explaining the meaning of the various boxes and 
+# arrows in the dot generated graphs.
+
+GENERATE_LEGEND        = YES
+
+# If the DOT_CLEANUP tag is set to YES (the default) Doxygen will 
+# remove the intermediate dot files that are used to generate 
+# the various graphs.
+
+DOT_CLEANUP            = YES
+
+#---------------------------------------------------------------------------
+# Configuration::additions related to the search engine   
+#---------------------------------------------------------------------------
+
+# The SEARCHENGINE tag specifies whether or not a search engine should be 
+# used. If set to NO the values of all tags below this one will be ignored.
+
+SEARCHENGINE           = NO
diff --git a/src/hid/dxf/doc/pcb-dxf-hid-main.txt b/src/hid/dxf/doc/pcb-dxf-hid-main.txt
new file mode 100644
index 0000000..64ac73e
--- /dev/null
+++ b/src/hid/dxf/doc/pcb-dxf-hid-main.txt
@@ -0,0 +1,5 @@
+/*! \mainpage PCB DXF HID - Printed Circuit Board DXF exporter.
+\image html pcb-logo-small.png
+\section pcb-intro PCB DXF HID Introduction
+    \htmlinclude what-is-pcb-dxf-hid.html
+*/
diff --git a/src/hid/dxf/doc/pcb-logo-small.png b/src/hid/dxf/doc/pcb-logo-small.png
new file mode 100644
index 0000000000000000000000000000000000000000..962fdd6e1ecd056b461814202a8e74c34d51ed10
GIT binary patch
literal 16090
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

literal 0
HcmV?d00001

diff --git a/src/hid/dxf/doc/what-is-pcb-dxf-hid.html b/src/hid/dxf/doc/what-is-pcb-dxf-hid.html
new file mode 100644
index 0000000..cf7a0d7
--- /dev/null
+++ b/src/hid/dxf/doc/what-is-pcb-dxf-hid.html
@@ -0,0 +1,15 @@
+<body>
+What is PCB DXF HID ?
+<p/>
+PCB DXF HID is a DXF exporter for <b>PCB</b>.<br>
+DXF is the defacto <b>D</b>ata e<b>X</b>change <b>F</b>ormat for exchanging data in between mechanical CAD
+applications.<br>
+<br>
+PCB is an interactive <b>P</b>rinted <b>C</b>ircuit <b>B</b>oard editor for the
+X11 window system.<br>
+PCB includes a rats nest feature, design rule checking, and can provide
+industry standard RS-274-X (Gerber), NC drill, and centroid data (X-Y data)
+output for use in the board fabrication and assembly process.<br>
+PCB offers high end features such as an autorouter and trace optimizer which
+can tremendously reduce layout time.
+</body>
diff --git a/src/hid/dxf/dxf.c b/src/hid/dxf/dxf.c
new file mode 100644
index 0000000..a3338b2
--- /dev/null
+++ b/src/hid/dxf/dxf.c
@@ -0,0 +1,5455 @@
+/*!
+ * \file dxf.c
+ * \author Copyright (C) 2007 .. 2009 by Bert Timmerman <bert.timmerman@xs4all.nl>
+ * for DXF relevant code.\n
+ * \brief This file contains the DXF HID (Human Interface Device) exporter to
+ * generate a DXF file containing Xref's of components and a series of DXF
+ * files, one for every pcb layer.
+ *
+ * <hr>
+ * <h1><b>Copyright Notices.</b></h1>\n
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License,
+ * or (at your option) any later version.\n\n
+ * This program is distributed in the hope that it will be useful, but
+ * <b>WITHOUT ANY WARRANTY</b>; without even the implied warranty of
+ * <b>MERCHANTABILITY</b> or <b>FITNESS FOR A PARTICULAR PURPOSE</b>.\n
+ * See the GNU General Public License for more details.\n\n
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to:\n
+ * Free Software Foundation, Inc.,\n
+ * 59 Temple Place,\n
+ * Suite 330,\n
+ * Boston,\n
+ * MA 02111 USA.
+ * <hr>
+ * <b>Drawing eXchange Format (DXF)</b>\n
+ * DXF is a defacto industry standard for the exchange of drawing files
+ * between various Computer Aided Drafting programs.\n
+ * DXF is designed by Autodesk(TM).\n
+ * For more details see http://www.autodesk.com .
+ * <hr>
+ * <b>PCB, interactive printed circuit board design.</b>\n
+ * Copyright (C) 1994,1995,1996 Thomas Nau.\n
+ * Copyright (C) 1997, 1998, 1999, 2000, 2001 Harry Eaton.\n
+ * For contact addresses for paper mail and e-mail see:\n
+ * http://sourceforge.net/projects/pcb\n
+ * \n
+ * The DXF exporter is based on the BOM and Gerber HID's.\n
+ * I have copied the bom.c file and added portions from gerber.c and edited
+ * the used bits for DXF relevant code.\n
+ * \author Copyright (C) for BOM and Gerber HID parts by their respective
+ * authors.\n
+ * <hr>
+ * <h1><b>Warning.</b></h1>\n
+ * Some notes about Coordinate systems:\n
+ * <ul>
+ * <li>PCB follows a "left handed" Cartesian Coordinate System.\n
+ * Positive X is right, positive Y is down.\n
+ * Angles are increasing counter clockwise (CCW) in degrees, with 0 degrees being left
+ * (negative X-axis) and 90 degrees being down (positive Y-axis).\n
+ * <li>AutoCAD DXF follows a "right handed" Cartesian Coordinate system.\n
+ * Positive X is right, positive Y is up.\n
+ * Angles are counter clockwise (CCW) in degrees, with 0 being right
+ * (positive X) and 90 being up (positive Y).\n
+ * <li>PCB coordinates are <b>ALWAYS</b> in a (default) resolution  of
+ * 1/100 mil (at the moment).\n
+ * <li>Autocad coordinates are either in mil (default) or in mm (see checkbox
+ * in the DXF HID dialog).\n
+ * <li>Lookup Wikipedia with keywords "Cartesian Coordinates" if you want more
+ * information on this subject.\n
+ * </ul>
+ * Filled polygons are drawn with a hatch entity.\n
+ * Elliptic arcs are drawn with an ellipse entity.\n
+ * Successful importing the generated dxf files with these entities
+ * requires AutoCAD version R14 or higher, or any other mechanical CAD
+ * program with the same level of compatibility with regard to the DXF
+ * format.\n
+ * <hr>
+ * <p>
+ * <h1><b>Installation Notes.</b></h1>\n
+ * The installation and subsequent use of the DXF HID requires recompilation
+ * of the pcb package with the pcb-dxf-HID package merged into pcb.
+ * This requires the following actions:\n
+ * \todo
+ * <ul>
+ * <li>Untar and ungzip the pcb-dxf-HID.tar.gz file in the parent directory
+ * where the pcb directory lives.\n
+ * Typically this would require <c>tar -xzf pcb-dxf-HID.tar.gz</c> \n
+ * \n
+ * <li>Edit the following entry in configure.ac in the "pcb" toplevel directory
+ * to apply the DXF hid.\n
+ * Something like this: (remember to use real [TAB] characters where needed !)\n
+<pre>
+AC_MSG_CHECKING([for which exporters to use])
+AC_ARG_WITH([exporters],
+[  --with-exporters=       Enable export devices: bom <b>dxf</b> gerber png ps [[default=bom <b>dxf</b> gerber png ps]]],
+[],[with_exporters=$hid_exporters])
+AC_MSG_RESULT([$with_exporters])
+for e in `echo $with_exporters | sed 's/,/ /g'`; do
+    case " $hid_exporters " in
+      *\ $e\ * )
+        HIDLIST="$HIDLIST $e"
+        ;;
+      * ) AC_MSG_ERROR([$e is not a valid exporter]) ;;
+    esac
+done
+</pre>
+ * \n
+ * <li>Edit the following or add entries in the pcb/src/Makefile.am for the
+ * DXF hid: (remember to use real [TAB] characters where needed !)\n
+ * \n
+<pre>
+EXTRA_LIBRARIES = \
+        libgtk.a liblesstif.a libbatch.a \
+        liblpr.a libgerber.a libbom.a <b>libdxf.a</b> libpng.a libps.a
+
+...
+
+EXTRA_DIST= \
+        check_icon.data \
+        default_font \
+        \$(srcdir)/hid/bom/hid.conf \
+        <b>\$(srcdir)/hid/dxf/hid.conf</b> \
+        \$(srcdir)/hid/gerber/hid.conf \
+        ...
+
+...
+libbom_a_SOURCES = \
+        hid/hidint.h \
+        hid/bom/bom.c
+
+<b>
+libdxf_a_SOURCES = \
+        hid/hidint.h \
+        hid/dxf/dxf.c</b>
+
+libps_a_CPPFLAGS = -I./hid/ps
+LIBPS_SRCS = \
+        dolists.h \
+        hid/hidint.h \
+        hid/ps/ps.c \
+        hid/ps/ps.h \
+        hid/ps/eps.c
+libps_a_SOURCES = ${LIBPS_SRCS} hid/ps/ps_lists.h
+...
+</pre>
+ * \n
+ * <li>Run <c>./autogen.sh</c> from the pcb/ toplevel directory.
+ * <li>Run <c>./configure</c> with the arguments that best fit to your needs.
+ * <li>Run <c>make</c>
+ * <li>Change to directory <c>src</c>
+ * <li>Run <c>./pcb</c>
+ * <li>Load a pcb file.
+ * <li>Export with <c>File/Export Layout/dxf</c> or any other exporter you
+ * want to export with.
+ * <li>If all goes well, run <c>make install</c> from the toplevel directory
+ * if you want this version of pcb to be installed.
+ * <li>Documentation of the DXF-HID is written for Doxygen
+ * (version >= 1.4.6).\n
+ * To (re)generate this Doxygen documentation, edit (if needed) and run
+ * <c>doxygen dxf-dox-no-call-graphs.dox</c> or
+ * <c>doxygen dxf-dox-with-call-graphs.dox</c> in the src/hid/dxf
+ * directory to create HTML, latex and other docs in the pcb/src/hid/dxf/doc
+ * directory.
+ * <li>Please send remarks, bugs, improvements, relevant opinions to
+ * bert.timmerman@xs4all.nl or to the geda-dev mailing list.
+ * <li>Donations to speed up the development of the gEDA suite best go to
+ * www.gedaconsulting.com.
+ * <li>Have fun ;-)
+ * </ul>
+ * <hr>
+ * <p>
+ * <h1><b>The DXF HID function treeview.</b></h1>\n
+ * The following function hierarchy, with the status of the functions in
+ * between [], exists:
+ * <ul>
+ * <li>dxf_get_export_options [stable]
+ * <li>dxf_do_export [stable]
+ *   <ul>
+ *   <li>dxf_get_export_options [stable]
+ *   <li>dxf_export_xref_file [exp]
+ *     <ul>
+ *     <li>dxf_write_comment [stable]
+ *     <li>dxf_write_header [stable]
+ *       <ul>
+ *       <li>dxf_write_header_metric_new [stable]
+ *       <li>dxf_write_header_imperial_new [todo]
+ *       </ul>
+ *     <li>dxf_write_block_record [todo]
+ *     <li>dxf_write_block [stable]
+ *     <li>dxf_write_endsection [stable]
+ *     <li>dxf_write_section [stable]
+ *     <li>dxf_insert [stable]
+ *     <li>dxf_write_eof [stable]
+ *     </ul>
+ *   <li>dxf_maybe_close_file [exp]
+ *     <ul>
+ *     <li>dxf_write_tail [todo]
+ *     <li>dxf_write_tail_metric_new [todo]
+ *     <li>dxf_write_tail_imperial_new [todo]
+ *     <li>dxf_write_eof [stable]
+ *     </ul>
+ *   </ul>
+ * <li>dxf_parse_arguments [stable]
+ * <li>dxf_set_layer [exp]
+ *     <ul>
+ *     <li>dxf_maybe_close_file [stable]
+ *     <li>dxf_write_header [stable]
+ *       <ul>
+ *       <li>dxf_write_header_metric_new [stable]
+ *       <li>dxf_write_header_imperial_new [todo]
+ *       </ul>
+ *     <li>dxf_write_block_record [todo]
+ *     <li>dxf_write_block [stable]
+ *     <li>dxf_write_endsection [stable]
+ *     <li>dxf_write_section [stable]
+ *     </ul>
+ * <li>dxf_make_gc [stable]
+ * <li>dxf_destroy_gc [stable]
+ * <li>dxf_use_mask [stable]
+ * <li>dxf_set_color [stable]
+ * <li>dxf_set_line_cap [stable]
+ * <li>dxf_set_line_width [stable]
+ * <li>dxf_draw_line [exp]
+ *   <ul>
+ *   <li>dxf_write_polyline [exp]
+ *   <li>dxf_write_vertex [stable]
+ *   <li>dxf_write_endseq [stable]
+ *   </ul>
+ * <li>dxf_draw_arc [exp]
+ *   <ul>
+ *   <li>dxf_write_ellipse [exp]
+ *   </ul>
+ * <li>dxf_draw_rect [exp]
+ *   <ul>
+ *   <li>dxf_write_polyline [exp]
+ *   <li>dxf_write_vertex [stable]
+ *   <li>dxf_write_endseq [stable]
+ *   </ul>
+ * <li>dxf_fill_circle [exp]
+ *   <ul>
+ *   <li>dxf_write_circle [exp]
+ *   </ul>
+ * <li>dxf_fill_polygon [exp]
+ *   <ul>
+ *   <li>dxf_write_hatch [stable]
+ *   <li>dxf_write_hatch_boundary_path_polyline [stable]
+ *   <li>dxf_write_hatch_boundary_path_polyline_vertex [stable]
+ *   </ul>
+ * <li>dxf_fill_rect [stable]
+ *   <ul>
+ *   <li>dxf_write_solid [stable]
+ *   </ul>
+ * <li>dxf_calibrate [stable]
+ * <li>dxf_set_crosshair [stable]
+ * </ul>
+ * <br>
+ * Notes:\n
+ * [todo] denotes a function not yet implemented.\n
+ * [exp] denotes a function not yet fully implemented.\n
+ * [stable] denotes a function fully implemented.\n
+ * <hr>
+ * \n\n
+ * <b>Include files</b>
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdio.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+
+#include <unistd.h>
+#include <sys/types.h>
+#include <pwd.h>
+
+#include "global.h"
+#include "data.h"
+#include "error.h"
+#include "misc.h"
+
+#include "hid.h"
+#include "../hidint.h"
+#include "hid/common/draw_helpers.h"
+
+#ifdef HAVE_LIBDMALLOC
+#include <dmalloc.h>
+#endif
+
+/*!
+ * \brief RCS identification string.
+ */
+RCSID ("$Id$");
+
+/*!
+ * \brief Debugging on/off switch.
+ */
+//#define DEBUG 1
+
+/*!
+ * \brief Error handling of not yet implemented functions.
+ */
+#define CRASH fprintf(stderr, "DXF error: pcb called unimplemented DXF-HID function %s.\n", __FUNCTION__); abort()
+
+/*!
+ * pcb dxf HID version string
+ */
+#define PCB_DXF_HID_VERSION "PCB DXF HID - Version 0.0.2"
+
+/*!
+ * \brief Dxf X-coordinate (in mil).
+ */
+#define DXF_X(pcb, x) ((long) ((x) / 100))
+
+/*!
+ * \brief Dxf Y-coordinate (in mil).
+ */
+#define DXF_Y(pcb, y) ((long) (((pcb)->MaxHeight - (y))) / 100)
+
+/*!
+ * \brief Dxf X offset (in mil).
+ */
+#define DXF_XOffset(pcb, x) ((long) ((x) / 100))
+
+/*!
+ * \brief Dxf Y offset (in mil).
+ */
+#define DXF_YOffset(pcb, y) ((long) (-(y) / 100))
+
+/*!
+ * \brief Round of value to the nearest multiple of 100.
+ */
+#define DXF_ROUND(x) ((int)(((x) + 50) / 100) * 100)
+
+/*!
+ * \brief DXF color definition, entities with this color follow the color
+ * definition of the block in which it lives.
+ */
+#define DXF_COLOR_BYBLOCK 0
+
+/*!
+ * \brief DXF color definition, pen number "1" in the virtual pen-plotter.
+ */
+#define DXF_COLOR_RED 1
+
+/*!
+ * \brief DXF color definition, pen number "2" in the virtual pen-plotter.
+ */
+#define DXF_COLOR_YELLOW 2
+
+/*!
+ * \brief DXF color definition, pen number "3" in the virtual pen-plotter.
+ */
+#define DXF_COLOR_GREEN 3
+
+/*!
+ * \brief DXF color definition, pen number "4" in the virtual pen-plotter.
+ */
+#define DXF_COLOR_CYAN 4
+
+/*!
+ * \brief DXF color definition, pen number "5" in the virtual pen-plotter.
+ */
+#define DXF_COLOR_BLUE 5
+
+/*!
+ * \brief DXF color definition, pen number "6" in the virtual pen-plotter.
+ */
+#define DXF_COLOR_MAGENTA 6
+
+/*!
+ * \brief DXF color definition, pen number "7" in the virtual pen-plotter.
+ */
+#define DXF_COLOR_WHITE 7
+
+/*!
+ * \brief DXF color definition, pen number "8" in the virtual pen-plotter.
+ */
+#define DXF_COLOR_GREY 8
+
+/*!
+ * \brief DXF color definition, color of the entity follows the color
+ * definition of the layer on which it lives.
+ */
+#define DXF_COLOR_BYLAYER 256
+
+/*!
+ * \brief This is where our hardware is going to live, default value, can be
+ * ommitted in dxf output.
+ */
+#define DXF_MODELSPACE 0
+
+/*!
+ * \brief This is where your annotation (papersheet templates, fab notes and
+ * such) should live, has to be included in DXF output for any entity to live
+ * on paperspace.
+ */
+#define DXF_PAPERSPACE 1
+
+/*!
+ * \brief There is <b>always</b> a layer "0" defined, it's reasonably safe to
+ * assume that this is a valid layername.
+ */
+#define DXF_DEFAULT_LAYER "0"
+
+/*!
+ * \brief There is <b>always</b> a linetype "BYLAYER" defined, it's reasonably
+ * safe to assume that this is a valid linetype.
+ */
+#define DXF_DEFAULT_LINETYPE "BYLAYER"
+
+/*!
+ * \brief There is <b>always</b> a textstyle "STANDARD" defined, it's
+ * reasonably safe to assume that this is a valid text style.
+ */
+#define DXF_DEFAULT_TEXTSTYLE "STANDARD"
+
+/*!
+ * \brief Directory where 3D models of parts live.
+ *
+ * For now the dxf_xref_pathname is set to "parts", in AutoCAD one can
+ * configure default search directories for xrefs.
+ */
+#define DXF_DEFAULT_XREF_PATH_NAME "parts"
+
+/*!
+ * \brief Directory separator character (back slash).
+ *
+ * For now we live in a micro$oft & Autodesk universe with all of their
+ * quirks.
+ *
+ * \todo This has to be solved in a more elegant manner if we want to use DXF
+ * file on *nix based CAD software.
+ */
+#define DXF_DIR_SEPARATOR "\\"
+
+/*!
+ * \brief Default hatch pattern for pcb polygons.
+ *
+ * \todo For now the hatch pattern name is set to "SOLID".\n
+ * If pcb is ever to have thieving implemented, a hatch pattern name field
+ * has to be added to the graphic context.
+ */
+#define DXF_DEFAULT_HATCH_PATTERN_NAME "SOLID"
+
+/*!
+ * \brief File pointer for DXF layer files.
+ */
+static FILE *fp;
+
+/*!
+ * \brief File name of layer DXF files.
+ */
+static char *dxf_filename;
+
+/*!
+ * \brief File name of DXF header template file.
+ */
+static char *dxf_header_filename;
+
+/*!
+ * \brief File name suffix for layer files.
+ */
+static char *dxf_filesuffix;
+
+/*!
+ * \brief Layer name.
+ */
+static char *dxf_layername = 0;
+
+/*!
+ * \brief Line count ??.
+ */
+static int lncount = 0;
+
+/*!
+ * \brief DXF file with xrefs needed.
+ */
+static int dxf_xrefs;
+
+/*!
+ * \brief File name of Xref (blocks) DXF file.
+ */
+static char *dxf_xref_filename;
+
+/*!
+ * \brief DXF file with output in mm (not mils).
+ */
+static int dxf_metric;
+
+/*!
+ * \brief DXF file with layer color BYBLOCK (or by layer number).
+ */
+static int dxf_color_is_byblock;
+
+/*!
+ * \brief DXF file with verbose output (to contain DXF comments).
+ */
+static int dxf_verbose;
+
+/*!
+ * \brief export all PCB layers to DXF files.
+ */
+static int dxf_export_all_layers;
+
+/*!
+ * \brief Every DXF entity has a unique identifier (per DXF file).
+ */
+static int dxf_id_code = 0;
+
+/* forward declaration */
+static HID dxf_hid;
+
+/*!
+ * \brief Shape definitions of apertures.
+ */
+enum ApertureShape
+{
+        ROUND, /*!< shaped like a circle  */
+        OCTAGON, /*!< octagonal shape  */
+        SQUARE,  /*!< shaped like a square  */
+        ROUNDCLEAR, /*!< clearance in negatives  */
+        SQUARECLEAR, /*!< clearance in negatives  */
+        THERMAL /*!< negative thermal relief  */
+};
+
+/*!
+ * \brief Shape of aperture.
+ */
+typedef enum ApertureShape ApertureShape;
+
+/*!
+ * \brief Aperture properties.
+ */
+typedef struct Aperture
+{
+        int dCode; /*!< The RS-274X D code.  */
+        int apertureSize; /*!< size in mils.  */
+        ApertureShape apertureShape; /*!< Shape of aperture [ROUND, SQUARE
+                etc.  */
+} Aperture;
+
+/*!
+ * \brief List of apertures.
+ */
+typedef struct
+{
+        DynamicStringType appList; /*!< aperture list  */
+        int lastdCode; /*!< last D-code  */
+        int lastTherm; /*!< last thermal  */
+        int nextAperture; /*!< number of apertures  */
+        Aperture aperture[GBX_MAXAPERTURECOUNT]; /*!< Aperture properties  */
+} Apertures;
+
+/*!
+ * \brief Drill (hole) properties.
+ */
+typedef struct
+{
+        int diam; /*!< drill diameter (in mils)  */
+        int x; /*!< X-coordinate  */
+        int y; /*!< Y-coordinate  */
+} DxfPendingDrills;
+
+/*!
+ * \brief Layer is a mask.
+ */
+static int is_mask;
+
+/*!
+ * \brief Current mask.
+ */
+static int current_mask;
+
+/*!
+ * \brief Entity is a drill (hole).
+ */
+static int is_drill;
+
+static int was_drill;
+
+static Apertures *layerapps = 0;
+
+static Apertures *curapp;
+
+static int n_layerapps = 0;
+
+static int c_layerapps = 0;
+
+/*!
+ * \brief Pending drill (holes).
+ */
+DxfPendingDrills *dxf_pending_drills = 0;
+
+/*!
+ * \brief Number of pending drill (holes).
+ */
+int dxf_n_pending_drills = 0;
+
+/*!
+ * \brief Maximum number of pending drills (holes).
+ */
+int dxf_max_pending_drills = 0;
+
+/*!
+ * \brief Find aperture code.
+ *
+ * Search for an appropriate aperture, and if not found, create a new aperture
+ * and add it to the list.\n
+ * When line width is 0 nothing is done.
+ */
+static int
+dxf_find_aperture_code
+(
+        int width, /*!< Line width  */
+        ApertureShape shape /*!< aperture for drawing line (cap style)  */
+)
+{
+        int i;
+        Aperture *ap;
+        char appMacro[256];
+        if (width == 0)
+        {
+                /* we never draw zero-width lines */
+                return (0);
+        }
+        /* search for an appropriate aperture */
+        for (i = 0; i < curapp->nextAperture; i++)
+        {
+                ap = &(curapp->aperture[i]);
+                if (ap->apertureSize == width && ap->apertureShape == shape)
+                {
+                        return (ap->dCode);
+                }
+        }
+        appMacro[0] = '\0';
+        if (curapp->nextAperture < GBX_MAXAPERTURECOUNT)
+        {
+                /* aperture not found, create a new aperture and add it to
+                 * the list */
+                i = curapp->nextAperture++;
+                ap = &(curapp->aperture[i]);
+                ap->dCode = curapp->lastdCode++;
+                ap->apertureSize = width;
+                ap->apertureShape = shape;
+                switch (shape)
+                {
+#if 0
+                        case ROUND:
+                                sprintf
+                                (
+                                        appMacro,
+                                        "ROUND aperture here",
+                                        ap->dCode,
+                                        width / 100000.0
+                                );
+                                break;
+                        case SQUARE:
+                                sprintf
+                                (
+                                        appMacro,
+                                        "SQUARE aperure here",
+                                        ap->dCode,
+                                        width / 100000.0,
+                                        width / 100000.0
+                                );
+                                break;
+                        case OCTAGON:
+                                sprintf
+                                (
+                                        appMacro,
+                                        "OCTAGON aperture here",
+                                        curapp->lastTherm,
+                                        width / (100000.0 * COS_22_5_DEGREE),
+                                        ap->dCode,
+                                        curapp->lastTherm
+                                );
+                                curapp->lastTherm++;
+                                break;
+                        case THERMAL:
+                                sprintf
+                                (
+                                        appMacro,
+                                        "THERMAL aperture here",
+                                        lastTherm,
+                                        gap / 100000.0,
+                                        width / 100000.0,
+                                        finger / 100000.0,
+                                        ap->dCode,
+                                        lastTherm
+                                 );
+                                lastTherm++;
+                                break;
+                        case ROUNDCLEAR:
+                                sprintf
+                                (
+                                        appMacro,
+                                        "ROUNDCLEAR aperture here",
+                                        ap->dCode,
+                                        gap / 100000.0,
+                                        width / 100000.0
+                                );
+                                break;
+                        case SQUARECLEAR:
+                                sprintf
+                                (
+                                        appMacro,
+                                        "SQUARECLEAR aperture here",
+                                        ap->dCode,
+                                        gap / 100000.0,
+                                        gap / 100000.0,
+                                        width / 100000.0,
+                                        width / 100000.0
+                                );
+                                break;
+#else
+#endif
+                        default:
+                                break;
+                }
+                DSAddString (&(curapp->appList), appMacro);
+                return (ap->dCode);
+        }
+        else
+        {
+                Message (_("DXF Error: too many apertures needed for DXF file.\n"));
+                if (dxf_verbose)
+                {
+                        fprintf (stderr, "DXF Error: too many apertures needed for DXF file.\n");
+                }
+                return (10);
+        }
+}
+
+static void
+dxf_init_apertures ()
+{
+        layerapps = 0;
+        n_layerapps = 0;
+}
+
+static void
+dxf_set_app_layer
+(
+        int l
+)
+{
+        if (l >= n_layerapps)
+        {
+                int prev = n_layerapps;
+                n_layerapps = l + 1;
+                layerapps = MyRealloc (layerapps,
+                                       n_layerapps * sizeof (Apertures),
+                                       "dxf_set_app_layer");
+                curapp = layerapps + prev;
+                while (curapp < layerapps + n_layerapps)
+                {
+                        curapp->appList.Data = NULL;
+                        curapp->appList.MaxLength = 0;
+                        curapp->lastdCode = 11;
+                        curapp->lastTherm = 1;
+                        curapp->nextAperture = 0;
+                        curapp++;
+                }
+        }
+        curapp = layerapps + l;
+}
+
+/*!
+ * \brief Definition of graphic context for the dxf HID.
+ *
+ * This graphics context is an opaque pointer defined by the HID.\n
+ * GCs are HID-specific; attempts to use one HID's GC for a different HID
+ * will result in a fatal error.\n
+ *
+ * \todo In pcb the cap <b>always</b> extends beyond the coordinates given, by
+ * half the width of the line.\n
+ * With DXF polylines the cap is by default 0, and thus doesn't extend beyond
+ * the coordinates.\n
+ * A round cap could be implemented by drawing a donut (a series of polyline
+ * vertices) with an inner radius of zero at the start and endpoint of a line,
+ * this doesn't solve the problem for other aperure shapes, and is thus not
+ * yet implemented.
+ */
+typedef struct hid_gc_struct
+{
+        EndCapStyle cap; /*!< end cap style */
+        int width; /*!< width */
+        int color; /*!< color */
+        int erase; /*!< erase */
+        int drill; /*!< drill */
+} hid_gc_struct;
+
+/*!
+ * \brief Definition of options the user can select in the DXF exporter
+ * dialog.
+ */
+static HID_Attribute dxf_options[] =
+{
+  {"dxffile", "DXF layer filename base", HID_String, 0, 0, {0, 0, 0}, 0, 0},
+#define HA_dxffile 0
+  {"metric", "export DXF files in mm", HID_Boolean, 0, 0, {0, 0, 0}, 0, 0},
+#define HA_metric 1
+  {"layer color BYBLOCK", "export entities in color BYBLOCK", HID_Boolean, 0, 0, {0, 0, 0}, 0, 0},
+#define HA_color_byblock 2
+  {"xrefs", "export a DXF file with xrefs", HID_Boolean, 0, 0, {0, 0, 0}, 0, 0},
+#define HA_xrefs 3
+  {"xreffile", "DXF Xrefs filename", HID_String, 0, 0, {0, 0, 0}, 0, 0},
+#define HA_xreffile 4
+  {"be verbose", "verbose output to stderr (comments)", HID_Boolean, 0, 0, {0, 0, 0}, 0, 0},
+#define HA_verbose 5
+  {"export all layers", "export all layers", HID_Boolean, 0, 0, {0, 0, 0}, 0, 0},
+#define HA_export_all_layers 6
+};
+
+#define NUM_OPTIONS (sizeof(dxf_options)/sizeof(dxf_options[0]))
+
+/*!
+ * \brief Used for HID attributes (exporting and printing, mostly).
+ *
+ * HA_boolean uses int_value, HA_enum sets int_value to the index and
+ * str_value to the enumeration string.\n
+ * HID_Label just shows the default str_value.\n
+ * HID_Mixed is a real_value followed by an enum, like 0.5in or 100mm.
+ */
+static HID_Attr_Val dxf_values[NUM_OPTIONS];
+
+/*!
+ * \brief List with string data.
+ */
+typedef struct _StringList
+{
+        char *str; /*!< String value.  */
+        struct _StringList *next; /*!< Pointer to next item.  */
+} StringList;
+
+/*!
+ * \brief List with pcb element header data.
+ */
+typedef struct _DxfList
+{
+        char *descr; /*!< description of pcb element.  */
+        char *value; /*!< value of pcb element.  */
+        int num; /*!< amount of elements per unique pcb element.  */
+        StringList *refdes; /*!< list of reference designators (refdes's) of
+                pcb elements.  */
+        struct _DxfList *next; /*!< pointer to next (unique) element header
+                data.  */
+} DxfList;
+
+static int finding_apertures = 0;
+
+static int pagecount = 0;
+
+static int linewidth = -1;
+
+static int lastgroup = -1;
+
+static int lastcap = -1;
+
+static int lastcolor = -1;
+
+static int print_group[MAX_LAYER];
+
+static int print_layer[MAX_LAYER];
+
+/*!
+ * \brief The last X coordinate.
+ */
+static int dxf_lastX;
+
+/*!
+ * \brief The last Y coordinate.
+ */
+static int dxf_lastY;
+
+/*!
+ * \brief Find a group for a given layer ??.
+ */
+static int
+dxf_group_for_layer
+(
+        int l
+)
+{
+        if ((l < max_layer + 2) && (l >= 0))
+        {
+                return GetLayerGroupNumberByNumber (l);
+        }
+        /* something unique */
+        return max_layer + 3 + l;
+}
+
+/*!
+ * \brief Sort layers ??.
+ */
+static int
+dxf_layer_sort
+(
+        const void *va,
+        const void *vb
+)
+{
+        int a = *(int *) va;
+        int b = *(int *) vb;
+        int d = dxf_group_for_layer (b) - dxf_group_for_layer (a);
+        if (d) return d;
+        return b - a;
+}
+
+/*!
+ * \brief Convert pcb x,y coordinates to an angle relative to (0.0, 0.0).
+ */
+static double
+dxf_xy_to_angle
+(
+        double x,
+        double y
+)
+{
+        double theta;
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_xy_to_angle () function.\n", __FILE__, __LINE__);
+#endif
+        if ((x > 0.0) && (y >= 0.0)) theta = 180.0;
+        else if ((x <= 0.0) && (y > 0.0)) theta = 90.0;
+        else if ((x < 0.0) && (y <= 0.0)) theta = 0.0;
+        else if ((x >= 0.0) && (y < 0.0)) theta = 270.0;
+        else
+        {
+                theta = 0.0;
+                Message ("DXF Warning: in dxf_xy_to_angle ():\n"
+                         "     unable to figure out angle of element\n"
+                         "     because the pin is at the centroid of the part.\n"
+                         "     This is a BUG!!!\n"
+                         "     Setting to %g degrees\n", theta);
+                if (dxf_verbose)
+                {
+                        fprintf (stderr, "DXF Warning: in dxf_xy_to_angle ():\n"
+                                 "\tunable to figure out the angle of the element because the pin is at the centroid of the part.\n"
+                                 "\tThis is considered to be a BUG!!!\n"
+                                 "\tSetting to %f degrees\n", theta);
+                }
+        }
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_xy_to_angle () function.\n", __FILE__, __LINE__);
+#endif
+        return (theta);
+}
+
+/*!
+ * \brief Clean up a string.
+ *
+ * Copy over input string to output string with some character conversions.\n
+ * Go all the way to end of string to get the termination character.
+ */
+static char *
+dxf_clean_string
+(
+        char *in
+)
+{
+        char *out;
+        int i;
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_clean_string () function.\n", __FILE__, __LINE__);
+#endif
+        if ((out = malloc ((strlen (in) + 1) * sizeof (char))) == NULL)
+        {
+                Message ("DXF Error: in dxf_clean_string (): malloc () failed.\n");
+                if (dxf_verbose)
+                {
+                        fprintf (stderr, "DXF Error: in dxf_clean_string (): malloc () failed.\n");
+                }
+                exit (1);
+        }
+        for (i = 0; i <= strlen (in); i++)
+        {
+                switch (in[i])
+                {
+                        case '"':
+                                out[i] = '\'';
+                                break;
+                        default:
+                                out[i] = in[i];
+                }
+        }
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_clean_string () function.\n", __FILE__, __LINE__);
+#endif
+        return (out);
+}
+
+/*!
+ * \brief Insert the string to the list of strings.
+ */
+static StringList *
+dxf_string_insert
+(
+        char *str,
+        StringList * list
+)
+{
+        StringList *new;
+        StringList *cur;
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_string_insert () function.\n", __FILE__, __LINE__);
+#endif
+        if ((new = (StringList *) malloc (sizeof (StringList))) == NULL)
+        {
+                Message ("DXF Error: in dxf_string_insert (): malloc () failed.\n");
+                if (dxf_verbose)
+                {
+                        fprintf (stderr, "DXF Error: in dxf_string_insert (): malloc () failed.\n");
+                }
+                exit (1);
+        }
+        new->next = NULL;
+        new->str = strdup (str);
+        if (list == NULL)
+        {
+                return (new);
+        }
+        cur = list;
+        while (cur->next != NULL) cur = cur->next;
+        cur->next = new;
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_string_insert () function.\n", __FILE__, __LINE__);
+#endif
+        return (list);
+}
+
+/*!
+ * \brief Write DXF output to a file for a block entity.
+ *
+ *The <c>BLOCKS</c> section of the DXF file contains all the block
+ * definitions.\n
+ * It contains the entities that make up the blocks used in the drawing,
+ * including anonymous blocks generated by the HATCH command and by
+ * associative dimensioning.\n
+ * The format of the entities in this section is identical to those in the
+ * <c>ENTITIES</c> section.\n
+ * All entities in the <c>BLOCKS</c> section appear between block and endblk
+ * entities.\n
+ * Block and endblk entities appear only in the <c>BLOCKS</c> section.\n
+ * Block definitions are never nested (that is, no block or endblk entity ever
+ * appears within another block-endblk pair), although a block definition can
+ * contain an insert entity.\n
+ * \n
+ * External references are written in the DXF file as block definitions,
+ * except that they also include a string (group code 1) that specifies the
+ * path and file name of the external reference.\n
+ * \n
+ * The block table handle, along with any xdata and persistent reactors,
+ * appears in each block definition immediately following the <c>BLOCK</c>
+ * record, which contains all of the specific information that a block table
+ * record stores.\n
+ * \n
+ * The UCS in effect when a block definition is created becomes the WCS for
+ * all entities in the block definition.\n
+ * The new origin for these entities is shifted to match the base point
+ * defined for the block definition.\n
+ * All entity data is translated to fit this new WCS.\n
+ * \n
+ * <c>*MODEL_SPACE</c> and <c>*PAPER_SPACE</c> Block Definition.\n
+ * Now, there are always two extra, empty definitions in the BLOCKS section,
+ * titled <c>*MODEL_SPACE</c> and <c>*PAPER_SPACE</c>.\n
+ * These definitions manifest the new representation of model space and paper
+ * space as block definitions internally.\n
+ * The entities contained in these definitions still appear in the
+ * <c>ENTITIES</c> section for compatibility.\n
+ * \n
+ * Model Space and Paper Space Entity Segregation.\n
+ * The interleaving between model space and paper space will no longer occurs,
+ * because of internal organization.\n
+ * Instead, all paper space entities are output, followed by model space
+ * entities.\n
+ * The flag distinguishing them is the group code 67.\n
+ *
+ * \todo Add group code 102 stuff.
+ */
+static void
+dxf_write_block
+(
+        FILE *fp,
+                /*!< file pointer to output file (or device) */
+        int id_code,
+                /*!< group code = 5 */
+        char *xref_name,
+                /*!< group code = 1 */
+        char *block_name,
+                /*!< group code = 2 and 3 */
+        char *linetype,
+                /*!< group code = 6\n
+                 * optional, if omitted defaults to BYLAYER */
+        char *layer,
+                /*!< group code = 8 */
+        double x0,
+                /*!< group code = 10\n base point */
+        double y0,
+                /*!< group code = 20\n base point */
+        double z0,
+                /*!< group code = 30\n base point */
+        double thickness,
+                /*!< group code = 39\n
+                 * optional, if omitted defaults to 0.0 */
+        int color,
+                /*!< group code = 62\n
+                 * optional, if omitted defaults to BYLAYER */
+        int paperspace,
+                /*!< group code = 67\n
+                 * optional, if omitted defaults to 0 (modelspace) */
+        int block_type
+                /*!< group code = 70\n
+                 * bit codes:\n
+                 * 1 = this is an anonymous Block generated by hatching,
+                 * associative dimensioning, other internal operations, or an
+                 * application\n
+                 * 2 = this Block has Attributes\n
+                 * 4 = this Block is an external reference (Xref)\n
+                 * 8 = not used\n
+                 * 16 = this Block is externally dependent\n
+                 * 32 = this is a resolved external reference, or dependent
+                 * of an external reference\n
+                 * 64 = this definition is referenced */
+)
+{
+        char *dxf_entity_name = strdup ("BLOCK");
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_write_block () function.\n", __FILE__, __LINE__);
+        fprintf (stderr, "[DXF entity with code %x]\n", id_code);
+#endif
+        if (strcmp (block_name, "") == 0)
+        {
+                if (dxf_verbose)
+                {
+                        fprintf (stderr, "DXF Warning: empty block name string for the %s entity with id-code: %x\n", dxf_entity_name, id_code);
+                        fprintf (stderr, "\t%s entity is discarded from output.\n", dxf_entity_name);
+                }
+                return;
+        }
+        if (strcmp (xref_name, "") == 0)
+        {
+                if (dxf_verbose)
+                {
+                        fprintf (stderr, "DXF Warning: empty xref name string for the %s entity with id-code: %x\n", dxf_entity_name, id_code);
+                        fprintf (stderr, "\t%s entity is discarded from output.\n", dxf_entity_name);
+                }
+                return;
+        }
+        if (strcmp (layer, "") == 0)
+        {
+                if (dxf_verbose)
+                {
+                        fprintf (stderr, "DXF Warning: empty layer string for the %s entity with id-code: %x\n", dxf_entity_name, id_code);
+                        fprintf (stderr, "\t%s entity is relocated to layer 0.\n", dxf_entity_name);
+                }
+                layer = strdup (DXF_DEFAULT_LAYER);
+        }
+        fprintf (fp, "  0\n%s\n", dxf_entity_name);
+        if (id_code != -1)
+        {
+                fprintf (fp, "  5\n%x\n", id_code);
+        }
+        /* group code 102 stuff goes here  */
+        fprintf (fp, "100\nAcDbEntity\n");
+        fprintf (fp, "  8\n%s\n", layer);
+        fprintf (fp, "100\nAcDbBlockBegin\n");
+        fprintf (fp, "  2\n%s\n", block_name);
+        fprintf (fp, " 70\n%d\n", block_type);
+        fprintf (fp, " 10\n%f\n", x0);
+        fprintf (fp, " 20\n%f\n", y0);
+        fprintf (fp, " 30\n%f\n", z0);
+        fprintf (fp, "  3\n%s\n", block_name);
+        if ((block_type && 4) || (block_type && 32))
+        {
+                fprintf (fp, "  1\n%s%s%s.dwg\n", xref_name, DXF_DIR_SEPARATOR, block_name);
+        }
+//        if (strcmp (linetype, DXF_DEFAULT_LINETYPE) != 0) fprintf (fp, "  6\n%s\n", linetype);
+//        if (thickness != 0.0) fprintf (fp, " 39\n%f\n", thickness);
+//        if (color != DXF_COLOR_BYLAYER) fprintf (fp, " 62\n%d\n", color);
+        if (paperspace == DXF_PAPERSPACE)
+        {
+                fprintf (fp, " 67\n%d\n", DXF_PAPERSPACE);
+        }
+        /* now write an end block marker */
+        fprintf (fp, "  0\nENDBLK\n");
+        if (id_code != -1)
+        {
+                fprintf (fp, "  5\n%x\n", id_code);
+        }
+        /* group code 102 stuff goes here */
+        fprintf (fp, "100\nAcDbBlockEnd\n");
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_write_block () function.\n", __FILE__, __LINE__);
+#endif
+}
+
+/*!
+ * \brief Write DXF output to a file for a <c>BLOCK_RECORD</c> table.
+ *
+ * The DXF <c>BLOCK_RECORD</c> table is part of the <c>TABLES</c> section of
+ * the header that comes after the <c>DIMSTYLE</c> table and before the
+ * <c>ENTITIES</c> section.\n
+ * The <c>BLOCK_RECORD</c> table contains record definitions of all
+ * <c>BLOCK</c> entities, either regular <c>BLOCK</c> entities or external
+ * referenced <c>BLOCK</c> entities, the so calld XREFS.\n
+ * \todo Code it !! Make it happen !!
+ */
+static void
+dxf_write_table_block_record
+(
+        FILE *fp
+                /*!< file pointer to output file (or device) */
+)
+{
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_write_table_block_record () function.\n", __FILE__, __LINE__);
+#endif
+
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_write_table_block_record () function.\n", __FILE__, __LINE__);
+#endif
+}
+
+/*!
+ * \brief Write DXF output to a file for a <c>CIRCLE</c> entity.
+ *
+ * \todo The <c>CIRCLE</c> entity has to be replaced by a <c>POLYLINE</c>
+ * entity  with the correct line width (trace width).
+ * \todo The <c>CIRCLE</c> entity is to be used for (unplated) drill holes only.
+ * In the mechanical CAD program these circles (drill holes) can be extruded
+ * to the board thickness and subtracted from the extruded pcb outline.
+ */
+static void
+dxf_write_circle
+(
+        FILE *fp,
+                /*!< file pointer to output file (or device) */
+        int id_code,
+                /*!< group code = 5 */
+        char *linetype,
+                /*!< group code = 6\n
+                 * optional, defaults to BYLAYER */
+        char *layer,
+                /*!< group code = 8 */
+        double x0,
+                /*!< group code = 10\n
+                 * base point */
+        double y0,
+                /*!< group code = 20\n
+                 * base point */
+        double z0,
+                /*!< group code = 30\n
+                 * base point */
+        double extr_x0,
+                /*!< group code = 210\n
+                 * extrusion direction\n
+                 * optional, if ommited defaults to 0.0 */
+        double extr_y0,
+                /*!< group code = 220\n
+                 * extrusion direction\n
+                 * optional, if ommited defaults to 0.0 */
+        double extr_z0,
+                /*!< group code = 230\n
+                 * extrusion direction\n
+                 * optional, if ommited defaults to 1.0 */
+        double thickness,
+                /*!< group code = 39\n
+                 * optional, defaults to 0.0 */
+        double radius,
+                /*!< group code = 40 */
+        int color,
+                /*!< group code = 62\n
+                 * optional, defaults to BYLAYER */
+        int paperspace
+                /*!< group code = 67\n
+                 * optional, defaults to 0 (modelspace) */
+)
+{
+        char *dxf_entity_name = strdup ("CIRCLE");
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_write_circle () function.\n", __FILE__, __LINE__);
+        fprintf (stderr, "[DXF entity with code %x]\n", id_code);
+#endif
+        if (radius == 0.0)
+        {
+                if (dxf_verbose)
+                {
+                        fprintf (stderr, "Error: radius value equals 0.0 for the %s entity with id-code: %x\n", dxf_entity_name, id_code);
+                        return;
+                }
+        }
+        if (strcmp (layer, "") == 0)
+        {
+                layer = strdup (DXF_DEFAULT_LAYER);
+                if (dxf_verbose)
+                {
+                        fprintf (stderr, "Warning: empty layer string for the %s entity with id-code: %x\n", dxf_entity_name, id_code);
+                        fprintf (stderr, "    %s entity is relocated to layer 0", dxf_entity_name);
+                }
+        }
+        fprintf (fp, "  0\n%s\n", dxf_entity_name);
+        fprintf (fp, "100\nAcDbCircle\n");
+        if (id_code != -1)
+        {
+                fprintf (fp, "  5\n%x\n", id_code);
+        }
+        if (strcmp (linetype, DXF_DEFAULT_LINETYPE) != 0)
+        {
+                fprintf (fp, "  6\n%s\n", linetype);
+        }
+        fprintf (fp, "  8\n%s\n", layer);
+        fprintf (fp, " 10\n%f\n", x0);
+        fprintf (fp, " 20\n%f\n", y0);
+        fprintf (fp, " 30\n%f\n", z0);
+        fprintf (fp, " 210\n%f\n", extr_x0);
+        fprintf (fp, " 220\n%f\n", extr_y0);
+        fprintf (fp, " 230\n%f\n", extr_z0);
+        if (thickness != 0.0)
+        {
+                fprintf (fp, " 39\n%f\n", thickness);
+        }
+        fprintf (fp, " 40\n%f\n", radius);
+        if (color != DXF_COLOR_BYLAYER)
+        {
+                fprintf (fp, " 62\n%d\n", color);
+        }
+        if (paperspace == DXF_PAPERSPACE)
+        {
+                fprintf (fp, " 67\n%d\n", DXF_PAPERSPACE);
+        }
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_write_circle () function.\n", __FILE__, __LINE__);
+#endif
+        return;
+}
+
+/*!
+ * \brief Write DXF output for a comment string with line termination.
+ *
+ * The group code "999" indicates that the following line is a comment
+ * string.\n
+ * The AutoCAD command "DXFOUT" does not currently include such groups in a
+ * DXF output file.\n
+ * The AutoCAD command "DXFIN" honors them and ignores the comments.\n
+ * Thus, you can use the 999 group to include comments in a DXF file you've
+ * created.
+ */
+static void
+dxf_write_comment
+(
+        FILE *fp,
+                /*!< file pointer to output file (or device) */
+        char *comment_string)
+                /*!< comment string */
+{
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_write_comment () function.\n", __FILE__, __LINE__);
+#endif
+        if (strcmp (comment_string, "") == 0)
+        {
+                /* no use in writing an empty comment string to file */
+                return;
+        }
+        fprintf (fp, "999\n%s\n", comment_string);
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_write_comment () function.\n", __FILE__, __LINE__);
+#endif
+}
+
+/*!
+ * \brief Write DXF output to a file for an ellipse entity.
+ *
+ * This entity requires AutoCAD version R14 or higher.\n
+ * The ellipse entity is currently used to draw arcs.\n
+ * Since the pcb file format allows for a height and a width value, it is thus
+ * possible to draw an elliptical arc.
+ *
+ * \todo The ellipse entity has to be replaced by a polyline with the correct
+ * line width (trace width).
+ * When we figured out how to draw a polyline (with vertices) for an arc
+ * (part of a circle) or an elliptical arc (part of an ellipse).
+ * This function will then become obsolete.
+ */
+static void
+dxf_write_ellipse
+(
+        FILE *fp,
+                /*!< file pointer to output file (or device) */
+        int id_code,
+                /*!< group code = 5 */
+        char *linetype,
+                /*!< group code = 6\n
+                 * optional, defaults to BYLAYER */
+        char *layer,
+                /*!< group code = 8 */
+        double x0,
+                /*!< group code = 10\n
+                 * base point */
+        double y0,
+                /*!< group code = 20\n
+                 * base point */
+        double z0,
+                /*!< group code = 30\n
+                 * base point */
+        double x1,
+                /*!< group code = 11\n
+                 * endpoint of major axis, relative to the center (in WCS) */
+        double y1,
+                /*!< group code = 21\n
+                 * endpoint of major axis, relative to the center (in WCS) */
+        double z1,
+                /*!< group code = 31\n
+                 * endpoint of major axis, relative to the center (in WCS) */
+        double extr_x0,
+                /*!< group code = 210\n
+                 * extrusion direction\n
+                 * optional, if ommited defaults to 0.0 */
+        double extr_y0,
+                /*!< group code = 220\n
+                 * extrusion direction\n
+                 * optional, if ommited defaults to 0.0 */
+        double extr_z0,
+                /*!< group code = 230\n
+                 * extrusion direction\n
+                 * optional, if ommited defaults to 1.0 */
+        double thickness,
+                /*!< group code = 39\n
+                 * optional, defaults to 0.0 */
+        double ratio,
+                /*!< group code = 40\n
+                 * ratio of minor axis to major axis */
+        double start_angle,
+                /*!< group code = 41\n
+                 * start parameter (this value is 0.0 for a full ellipse) */
+        double end_angle,
+                /*!< group code = 42\n
+                 * end parameter (this value is 2*pi for a full ellipse) */
+        int color,
+                /*!< group code = 62\n
+                 * optional, defaults to BYLAYER */
+        int paperspace
+                /*!< group code = 67\n
+                 * optional, defaults to 0 (modelspace) */
+)
+{
+        char *dxf_entity_name = strdup ("ELLIPSE");
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_write_ellipse () function.\n", __FILE__, __LINE__);
+#endif
+        if (ratio == 0.0)
+        {
+                if (dxf_verbose)
+                {
+                        fprintf (stderr, "Error: ratio value equals 0.0 for the %s entity with id-code: %x\n", dxf_entity_name, id_code);
+                }
+                return;
+        }
+        if (strcmp (layer, "") == 0)
+        {
+                layer = strdup (DXF_DEFAULT_LAYER);
+                if (dxf_verbose)
+                {
+                        fprintf (stderr, "Warning: empty layer string for the %s entity with id-code: %x\n", dxf_entity_name, id_code);
+                        fprintf (stderr, "    %s entity is relocated to layer 0", dxf_entity_name);
+                }
+        }
+        fprintf (fp, "  0\n%s\n", dxf_entity_name);
+        fprintf (fp, "100\nAcDbEllipse\n");
+        if (id_code != -1)
+        {
+                fprintf (fp, "  5\n%x\n", id_code);
+        }
+        if (strcmp (linetype, DXF_DEFAULT_LINETYPE) != 0)
+        {
+                fprintf (fp, "  6\n%s\n", linetype);
+        }
+        fprintf (fp, "  8\n%s\n", layer);
+        fprintf (fp, " 10\n%f\n", x0);
+        fprintf (fp, " 20\n%f\n", y0);
+        fprintf (fp, " 30\n%f\n", z0);
+        fprintf (fp, " 11\n%f\n", x1);
+        fprintf (fp, " 21\n%f\n", y1);
+        fprintf (fp, " 31\n%f\n", z1);
+        fprintf (fp, " 210\n%f\n", extr_x0);
+        fprintf (fp, " 220\n%f\n", extr_y0);
+        fprintf (fp, " 230\n%f\n", extr_z0);
+        if (thickness != 0.0)
+        {
+                fprintf (fp, " 39\n%f\n", thickness);
+        }
+        fprintf (fp, " 40\n%f\n", ratio);
+        fprintf (fp, " 41\n%f\n", start_angle);
+        fprintf (fp, " 42\n%f\n", end_angle);
+        if (color != DXF_COLOR_BYLAYER)
+        {
+                fprintf (fp, " 62\n%d\n", color);
+        }
+        if (paperspace == DXF_PAPERSPACE)
+        {
+                fprintf (fp, " 67\n%d\n", DXF_PAPERSPACE);
+        }
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_write_ellipse () function.\n", __FILE__, __LINE__);
+#endif
+        return;
+}
+
+/*!
+ * \brief Write DXF output to a file for an end of section marker.
+ */
+static void
+dxf_write_endsection
+(
+        FILE *fp
+                /*!< file pointer to output file (or device) */
+)
+{
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_write_endsection () function.\n", __FILE__, __LINE__);
+#endif
+        fprintf (fp, "  0\nENDSEC\n");
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_write_endsection () function.\n", __FILE__, __LINE__);
+#endif
+}
+
+/*!
+ * \brief Write DXF output to a file for an end of sequence marker.
+ *
+ * No fields.\n
+ * This marks the end of:\n
+ * <ul>
+ * <li>vertices (one or more "Vertex" entity) of a Polyline
+ * <li>attribute entities ("Attrib" entity) to an "Insert" entity that has
+ * Attributes (indicated by 66 group present and nonzero in Insert
+ * entity).\n
+ * </ul>
+ */
+static void
+dxf_write_endseq
+(
+        FILE *fp
+                /*!< file pointer to output file (or device).  */
+)
+{
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_write_endseq () function.\n", __FILE__, __LINE__);
+#endif
+        fprintf (fp, "  0\nENDSEQ\n");
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_write_endseq () function.\n", __FILE__, __LINE__);
+#endif
+}
+
+
+/*!
+ * \brief Write dxf output to a file for an EOF marker.
+ */
+static void
+dxf_write_eof
+(
+        FILE *fp
+                /*!< file pointer to output file (or device).  */
+)
+{
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_write_eof () function.\n", __FILE__, __LINE__);
+#endif
+        fprintf (fp, "  0\nEOF\n");
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_write_eof () function.\n", __FILE__, __LINE__);
+#endif
+}
+
+/*!
+ * \brief Write DXF output to a file for a hatch entity.
+ *
+ * This entity requires AutoCAD version R14 or higher.
+ *
+ * \todo writing a hatch with a number of hatch_seed_points > 0 is creating a
+ * segmentation fault in the dxf hid (and thus pcb).
+ */
+static void
+dxf_write_hatch
+(
+        FILE *fp,
+                /*!< file pointer to output file (or device). */
+        char *pattern_name,
+                /*!< group code = 2. */
+        int id_code,
+                /*!< group code = 5. */
+        char *linetype,
+                /*!< group code = 6\n
+                 * optional, defaults to BYLAYER. */
+        char *layer,
+                /*!< group code = 8. */
+        double x0,
+                /*!< group code = 10\n
+                 * base point. */
+        double y0,
+                /*!< group code = 20\n
+                 * base point.  */
+        double z0,
+                /*!< group code = 30\n
+                 * base point. */
+        double extr_x0,
+                /*!< group code = 210\n
+                 * extrusion direction\n
+                 * optional, if ommited defaults to 0.0. */
+        double extr_y0,
+                /*!< group code = 220\n
+                 * extrusion direction\n
+                 * optional, if ommited defaults to 0.0.  */
+        double extr_z0,
+                /*!< group code = 230\n
+                 * extrusion direction\n
+                 * optional, if ommited defaults to 1.0.  */
+        double thickness,
+                /*!< group code = 39\n
+                 * optional, defaults to 0.0.  */
+        double pattern_scale,
+                /*!< group code 41\n
+                 * pattern fill only. */
+        double pixel_size,
+                /*!< group code 47. */
+        double pattern_angle,
+                /*!< group code 52\n
+                 * pattern fill only. */
+        int color,
+                /*!< group code = 62\n
+                 * optional, defaults to \c BYLAYER. */
+        int paperspace,
+                /*!< group code = 67\n
+                 * optional, defaults to 0 (modelspace). */
+        int solid_fill,
+                /*!< group code = 70\n
+                 * 0 = pattern fill\n
+                 * 1 = solid fill. */
+        int associative,
+                /*!< group code = 71\n
+                 * 0 = non-associative\n
+                 * 1 = associative. */
+        int style,
+                /*!< group code = 75\n
+                 * 0 = hatch "odd parity" area (Normal style)\n
+                 * 1 = hatch outermost area only (Outer style)\n
+                 * 2 = hatch through entire area (Ignore style). */
+        int pattern_style,
+                /*!< group code = 76\n
+                 * 0 = user defined\n
+                 * 1 = predefined\n
+                 * 2 = custom. */
+        int pattern_double,
+                /*!< group code = 77\n
+                 * pattern fill only\n
+                 * 0 = not double\n
+                 * 1 = double. */
+        int pattern_def_lines,
+                /*!< group code = 78\n
+                 * number of pattern definition lines. */
+        int boundary_paths,
+                /*!< group code = 91\n
+                 * number of boundary paths (loops). */
+        int seed_points,
+                /*!< group code = 98\n
+                 * number of seed points.  */
+                double *seed_x0,
+                        /*!< group code = 10\n
+                         * seed point X-value. */
+                double *seed_y0
+                        /*!< group code = 20\n
+                         * seed point Y-value.  */
+)
+{
+        char *dxf_entity_name = strdup ("HATCH");
+        int i;
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_write_hatch () function.\n", __FILE__, __LINE__);
+        fprintf (stderr, "[DXF entity with code %x]\n", id_code);
+#endif
+        if (strcmp (layer, "") == 0)
+        {
+                fprintf (stderr, "Warning: empty layer string for the %s entity with id-code: %x\n", dxf_entity_name, id_code);
+                fprintf (stderr, "    %s entity is relocated to layer 0", dxf_entity_name);
+                layer = strdup (DXF_DEFAULT_LAYER);
+        }
+        fprintf (fp, "  0\n%s\n", dxf_entity_name);
+        fprintf (fp, "100\nAcDbHatch\n");
+        fprintf (fp, "  2\n%s\n", pattern_name);
+        if (id_code != -1) fprintf (fp, "  5\n%x\n", id_code);
+        if (strcmp (linetype, DXF_DEFAULT_LINETYPE) != 0) fprintf (fp, "  6\n%s\n", linetype);
+        fprintf (fp, "  8\n%s\n", layer);
+        fprintf (fp, " 10\n%f\n", x0);
+        fprintf (fp, " 20\n%f\n", y0);
+        fprintf (fp, " 30\n%f\n", z0);
+        fprintf (fp, "210\n%f\n", extr_x0);
+        fprintf (fp, "220\n%f\n", extr_y0);
+        fprintf (fp, "230\n%f\n", extr_z0);
+        if (thickness != 0.0) fprintf (fp, " 39\n%f\n", thickness);
+        if (!solid_fill) fprintf (fp, " 42\n%f\n", pattern_scale);
+        fprintf (fp, " 47\n%f\n", pixel_size);
+        if (!solid_fill) fprintf (fp, " 52\n%f\n", pattern_angle);
+        if (color != DXF_COLOR_BYLAYER) fprintf (fp, " 62\n%d\n", color);
+        if (paperspace == DXF_PAPERSPACE) fprintf (fp, " 67\n%d\n", DXF_PAPERSPACE);
+        fprintf (fp, " 70\n%d\n", solid_fill);
+        fprintf (fp, " 71\n%d\n", associative);
+        fprintf (fp, " 75\n%d\n", style);
+        if (!solid_fill) fprintf (fp, " 77\n%d\n", pattern_double);
+        fprintf (fp, " 78\n%d\n", pattern_def_lines);
+        fprintf (fp, " 98\n%d\n", seed_points);
+        for (i = 0; i < seed_points; i++)
+        {
+                fprintf (fp, " 10\n%f\n", seed_x0[i]);
+                fprintf (fp, " 20\n%f\n", seed_y0[i]);
+        }
+        fprintf (fp, " 91\n%d\n", boundary_paths);
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_write_hatch () function.\n", __FILE__, __LINE__);
+#endif
+        return;
+}
+
+/*!
+ * \brief Write DXF output to a file for a hatch boundary path polyline.
+ *
+ * This entity requires AutoCAD version R14 or higher.
+ */
+static void
+dxf_write_hatch_boundary_path_polyline
+(
+        FILE *fp,
+                /*!< file pointer to output file (or device). */
+        int type_flag,
+                /*!< group code 92.  */
+        int polyline_has_bulge,
+                /*!< group code = 72\n
+                 * polyline boundary data group only. */
+        int polyline_is_closed,
+                /*!< group code = 73\n
+                 * polyline boundary data group only. */
+        int polyline_vertices
+                /*!< group code 93\n
+                 * number of polyline vertices to follow. */
+)
+{
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_write_hatch_boundary_path_polyline () function.\n", __FILE__, __LINE__);
+#endif
+        fprintf (fp, " 92\n%d\n", type_flag);
+        fprintf (fp, " 72\n%d\n", polyline_has_bulge);
+        fprintf (fp, " 73\n%d\n", polyline_is_closed);
+        fprintf (fp, " 93\n%d\n", polyline_vertices);
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_write_hatch_boundary_path_polyline () function.\n", __FILE__, __LINE__);
+#endif
+        return;
+}
+
+/*!
+ * \brief Write DXF output to a file for a hatch boundary polyline entity.
+ *
+ * This entity requires AutoCAD version R14 or higher.
+ */
+static void
+dxf_write_hatch_boundary_path_polyline_vertex
+(
+        FILE *fp,
+                /*!< file pointer to output file (or device). */
+        double x0,
+                /*!< group code = 10\n
+                 * X-value of vertex point. */
+        double y0,
+                /*!< group code = 20\n
+                 * Y-value of vertex point. */
+        double bulge
+                /*!< group code 42\n
+                 * bulge of polyline vertex\n
+                 * optional, defaults to 0.0. */
+)
+{
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_write_hatch_boundary_polyline_vertex () function.\n", __FILE__, __LINE__);
+#endif
+        fprintf (fp, " 10\n%f\n", x0);
+        fprintf (fp, " 20\n%f\n", y0);
+        if (bulge != 0.0) fprintf (fp, " 42\n%f\n", bulge);
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_write_hatch_boundary_polyline_vertex () function.\n", __FILE__, __LINE__);
+#endif
+        return;
+}
+
+/*!
+ * \brief Write DXF output to a file for a imperial DXF header.
+ *
+ * Fall back for if no default imperial header template file exists in the
+ * pcb/src/hid/dxf/template directory.\n
+ * Write down a DXF header from scratch based on imperial values.\n
+ * Included sections and tables are:\n
+ * <ul>
+* <li>HEADER section
+ * <li>CLASSES section
+ * <li>TABLES section
+ *   <ul>
+ *   <li>VPORT table
+ *   <li>LTYPE table
+ *   <li>LAYER table
+ *   <li>STYLE table
+ *   <li>VIEW table
+ *   <li>UCS table
+ *   <li>APPID table
+ *   <li>DIMSTYLE table
+ *   </ul>
+ * </ul>
+ */
+static void
+dxf_write_header_imperial_new
+(
+)
+{
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_write_header_imperial_new () function.\n", __FILE__, __LINE__);
+#endif
+        /* write an imperial HEADER section */
+        fprintf (fp, "  0\nSECTION\n");
+        fprintf (fp, "  2\nHEADER\n");
+        fprintf (fp, "  9\n$ACADVER\n  1\nAC1014\n");
+        fprintf (fp, "  9\n$ACADMAINTVER\n 70\n     0\n");
+        fprintf (fp, "  9\n$DWGCODEPAGE\n  3\nANSI_1252\n");
+        fprintf (fp, "  9\n$INSBASE\n 10\n0.0\n 20\n0.0\n 30\n0.0\n");
+        /* more lines to be added */
+
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_write_header_imperial_new () function.\n", __FILE__, __LINE__);
+#endif
+}
+
+/*!
+ * \brief Write DXF output to a file for a metric DXF header.
+ *
+ * Fall back for if no default metric header template file exists in the
+ * pcb/src/hid/dxf/template directory.\n
+ * Write down a DXF header from scratch based on metric values.\n
+ * Included sections and tables are:\n
+ * <ul>
+* <li>HEADER section
+ * <li>CLASSES section
+ * <li>TABLES section
+ *   <ul>
+ *   <li>VPORT table
+ *   <li>LTYPE table
+ *   <li>LAYER table
+ *   <li>STYLE table
+ *   <li>VIEW table
+ *   <li>UCS table
+ *   <li>APPID table
+ *   <li>DIMSTYLE table
+ *   </ul>
+ * </ul>
+ */
+static void
+dxf_write_header_metric_new
+(
+)
+{
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_write_header_metric_new () function.\n", __FILE__, __LINE__);
+#endif
+        /* write a metric HEADER section */
+        fprintf (fp, "  0\nSECTION\n");
+        fprintf (fp, "  2\nHEADER\n");
+        fprintf (fp, "  9\n$ACADVER\n  1\nAC1014\n");
+        fprintf (fp, "  9\n$ACADMAINTVER\n 70\n     0\n");
+        fprintf (fp, "  9\n$DWGCODEPAGE\n  3\nANSI_1252\n");
+        fprintf (fp, "  9\n$INSBASE\n 10\n0.0\n 20\n0.0\n 30\n0.0\n");
+        fprintf (fp, "  9\n$EXTMIN\n 10\n-0.012816\n 20\n-0.009063\n 30\n-0.001526\n");
+        fprintf (fp, "  9\n$EXTMAX\n 10\n88.01056\n 20\n35.022217\n 30\n0.0\n");
+        fprintf (fp, "  9\n$LIMMIN\n 10\n0.0\n 20\n0.0\n");
+        fprintf (fp, "  9\n$LIMMAX\n 10\n420.0\n 20\n297.0\n");
+        fprintf (fp, "  9\n$ORTHOMODE\n 70\n     0\n");
+        fprintf (fp, "  9\n$REGENMODE\n 70\n     1\n");
+        fprintf (fp, "  9\n$FILLMODE\n 70\n     1\n");
+        fprintf (fp, "  9\n$QTEXTMODE\n 70\n     0\n");
+        fprintf (fp, "  9\n$MIRRTEXT\n 70\n     1\n");
+        fprintf (fp, "  9\n$DRAGMODE\n 70\n     2\n");
+        fprintf (fp, "  9\n$LTSCALE\n 40\n1.0\n");
+        fprintf (fp, "  9\n$OSMODE\n 70\n   125\n");
+        fprintf (fp, "  9\n$ATTMODE\n 70\n     1\n");
+        fprintf (fp, "  9\n$TEXTSIZE\n 40\n2.5\n");
+        fprintf (fp, "  9\n$TRACEWID\n 40\n1.0\n");
+        fprintf (fp, "  9\n$TEXTSTYLE\n  7\nSTANDARD\n");
+        fprintf (fp, "  9\n$CLAYER\n  8\n0\n");
+        fprintf (fp, "  9\n$CELTYPE\n  6\nBYLAYER\n");
+        fprintf (fp, "  9\n$CECOLOR\n 62\n   256\n");
+        fprintf (fp, "  9\n$CELTSCALE\n 40\n1.0\n");
+        fprintf (fp, "  9\n$DELOBJ\n 70\n     1\n");
+        fprintf (fp, "  9\n$DISPSILH\n 70\n     0\n");
+        fprintf (fp, "  9\n$DIMSCALE\n 40\n1.0\n");
+        fprintf (fp, "  9\n$DIMASZ\n 40\n2.5\n");
+        fprintf (fp, "  9\n$DIMEXO\n 40\n0.625\n");
+        fprintf (fp, "  9\n$DIMDLI\n 40\n3.75\n");
+        fprintf (fp, "  9\n$DIMRND\n 40\n0.0\n");
+        fprintf (fp, "  9\n$DIMDLE\n 40\n0.0\n");
+        fprintf (fp, "  9\n$DIMEXE\n 40\n1.25\n");
+        fprintf (fp, "  9\n$DIMTP\n 40\n0.0\n");
+        fprintf (fp, "  9\n$DIMTM\n 40\n0.0\n");
+        fprintf (fp, "  9\n$DIMTXT\n 40\n2.5\n");
+        fprintf (fp, "  9\n$DIMCEN\n 40\n2.5\n");
+        fprintf (fp, "  9\n$DIMTSZ\n 40\n0.0\n");
+        fprintf (fp, "  9\n$DIMTOL\n 70\n     0\n");
+        fprintf (fp, "  9\n$DIMLIM\n 70\n     0\n");
+        fprintf (fp, "  9\n$DIMTIH\n 70\n     0\n");
+        fprintf (fp, "  9\n$DIMTOH\n 70\n     0\n");
+        fprintf (fp, "  9\n$DIMSE1\n 70\n     0\n");
+        fprintf (fp, "  9\n$DIMSE2\n 70\n     0\n");
+        fprintf (fp, "  9\n$DIMTAD\n 70\n     1\n");
+        fprintf (fp, "  9\n$DIMZIN\n 70\n     8\n");
+        fprintf (fp, "  9\n$DIMBLK\n  1\n\n");
+        fprintf (fp, "  9\n$DIMASO\n 70\n     1\n");
+        fprintf (fp, "  9\n$DIMSHO\n 70\n     1\n");
+        fprintf (fp, "  9\n$DIMPOST\n  1\n\n");
+        fprintf (fp, "  9\n$DIMAPOST\n  1\n\n");
+        fprintf (fp, "  9\n$DIMALT\n 70\n     0\n");
+        fprintf (fp, "  9\n$DIMALTD\n 70\n     4\n");
+        fprintf (fp, "  9\n$DIMALTF\n 40\n0.0394\n");
+        fprintf (fp, "  9\n$DIMLFAC\n 40\n1.0\n");
+        fprintf (fp, "  9\n$DIMTOFL\n 70\n     1\n");
+        fprintf (fp, "  9\n$DIMTVP\n 40\n0.0\n");
+        fprintf (fp, "  9\n$DIMTIX\n 70\n     0\n");
+        fprintf (fp, "  9\n$DIMSOXD\n 70\n     0\n");
+        fprintf (fp, "  9\n$DIMSAH\n 70\n     0\n");
+        fprintf (fp, "  9\n$DIMBLK1\n  1\n\n");
+        fprintf (fp, "  9\n$DIMBLK2\n  1\n\n");
+        fprintf (fp, "  9\n$DIMSTYLE\n  2\nSTANDARD\n");
+        fprintf (fp, "  9\n$DIMCLRD\n 70\n     0\n");
+        fprintf (fp, "  9\n$DIMCLRE\n 70\n     0\n");
+        fprintf (fp, "  9\n$DIMCLRT\n 70\n     0\n");
+        fprintf (fp, "  9\n$DIMTFAC\n 40\n1.0\n");
+        fprintf (fp, "  9\n$DIMGAP\n 40\n0.625\n");
+        fprintf (fp, "  9\n$DIMJUST\n 70\n     0\n");
+        fprintf (fp, "  9\n$DIMSD1\n 70\n     0\n");
+        fprintf (fp, "  9\n$DIMSD2\n 70\n     0\n");
+        fprintf (fp, "  9\n$DIMTOLJ\n 70\n     1\n");
+        fprintf (fp, "  9\n$DIMTZIN\n 70\n     0\n");
+        fprintf (fp, "  9\n$DIMALTZ\n 70\n     0\n");
+        fprintf (fp, "  9\n$DIMALTTZ\n 70\n     0\n");
+        fprintf (fp, "  9\n$DIMFIT\n 70\n     3\n");
+        fprintf (fp, "  9\n$DIMUPT\n 70\n     0\n");
+        fprintf (fp, "  9\n$DIMUNIT\n 70\n     2\n");
+        fprintf (fp, "  9\n$DIMDEC\n 70\n     4\n");
+        fprintf (fp, "  9\n$DIMTDEC\n 70\n     4\n");
+        fprintf (fp, "  9\n$DIMALTU\n 70\n     2\n");
+        fprintf (fp, "  9\n$DIMALTTD\n 70\n     2\n");
+        fprintf (fp, "  9\n$DIMTXSTY\n  7\nSTANDARD\n");
+        fprintf (fp, "  9\n$DIMAUNIT\n 70\n     0\n");
+        fprintf (fp, "  9\n$LUNITS\n 70\n     2\n");
+        fprintf (fp, "  9\n$LUPREC\n 70\n     4\n");
+        fprintf (fp, "  9\n$SKETCHINC\n 40\n1.0\n");
+        fprintf (fp, "  9\n$FILLETRAD\n 40\n1.0\n");
+        fprintf (fp, "  9\n$AUNITS\n 70\n     0\n");
+        fprintf (fp, "  9\n$AUPREC\n 70\n     0\n");
+        fprintf (fp, "  9\n$MENU\n  1\n.\n");
+        fprintf (fp, "  9\n$ELEVATION\n 40\n0.0\n");
+        fprintf (fp, "  9\n$PELEVATION\n 40\n0.0\n");
+        fprintf (fp, "  9\n$THICKNESS\n 40\n0.0\n");
+        fprintf (fp, "  9\n$LIMCHECK\n 70\n     0\n");
+        fprintf (fp, "  9\n$BLIPMODE\n 70\n     0\n");
+        fprintf (fp, "  9\n$CHAMFERA\n 40\n10.0\n");
+        fprintf (fp, "  9\n$CHAMFERB\n 40\n10.0\n");
+        fprintf (fp, "  9\n$CHAMFERC\n 40\n0.0\n");
+        fprintf (fp, "  9\n$CHAMFERD\n 40\n0.0\n");
+        fprintf (fp, "  9\n$SKPOLY\n 70\n     0\n");
+        fprintf (fp, "  9\n$TDCREATE\n 40\n2452949.844398842\n");
+        fprintf (fp, "  9\n$TDUPDATE\n 40\n2453105.563639282\n");
+        fprintf (fp, "  9\n$TDINDWG\n 40\n0.0994079282\n");
+        fprintf (fp, "  9\n$TDUSRTIMER\n 40\n0.0994079282\n");
+        fprintf (fp, "  9\n$USRTIMER\n 70\n     1\n");
+        fprintf (fp, "  9\n$ANGBASE\n 50\n0.0\n");
+        fprintf (fp, "  9\n$ANGDIR\n 70\n     0\n");
+        fprintf (fp, "  9\n$PDMODE\n 70\n    98\n");
+        fprintf (fp, "  9\n$PDSIZE\n 40\n0.0\n");
+        fprintf (fp, "  9\n$PLINEWID\n 40\n0.0\n");
+        fprintf (fp, "  9\n$COORDS\n 70\n     2\n");
+        fprintf (fp, "  9\n$SPLFRAME\n 70\n     0\n");
+        fprintf (fp, "  9\n$SPLINETYPE\n 70\n     6\n");
+        fprintf (fp, "  9\n$SPLINESEGS\n 70\n     8\n");
+        fprintf (fp, "  9\n$ATTDIA\n 70\n     0\n");
+        fprintf (fp, "  9\n$ATTREQ\n 70\n     1\n");
+        fprintf (fp, "  9\n$HANDLING\n 70\n     1\n");
+        fprintf (fp, "  9\n$HANDSEED\n  5\n262\n");
+        fprintf (fp, "  9\n$SURFTAB1\n 70\n     6\n");
+        fprintf (fp, "  9\n$SURFTAB2\n 70\n     6\n");
+        fprintf (fp, "  9\n$SURFTYPE\n 70\n     6\n");
+        fprintf (fp, "  9\n$SURFU\n 70\n     6\n");
+        fprintf (fp, "  9\n$SURFV\n 70\n     6\n");
+        fprintf (fp, "  9\n$UCSNAME\n  2\n\n");
+        fprintf (fp, "  9\n$UCSORG\n 10\n0.0\n 20\n0.0\n 30\n0.0\n");
+        fprintf (fp, "  9\n$UCSXDIR\n 10\n1.0\n 20\n0.0\n 30\n0.0\n");
+        fprintf (fp, "  9\n$UCSYDIR\n 10\n0.0\n 20\n1.0\n 30\n0.0\n");
+        fprintf (fp, "  9\n$PUCSNAME\n  2\n\n");
+        fprintf (fp, "  9\n$PUCSORG\n 10\n0.0\n 20\n0.0\n 30\n0.0\n");
+        fprintf (fp, "  9\n$PUCSXDIR\n 10\n1.0\n 20\n0.0\n 30\n0.0\n");
+        fprintf (fp, "  9\n$PUCSYDIR\n 10\n0.0\n 20\n1.0\n 30\n0.0\n");
+        fprintf (fp, "  9\n$USERI1\n 70\n     0\n");
+        fprintf (fp, "  9\n$USERI2\n 70\n     0\n");
+        fprintf (fp, "  9\n$USERI3\n 70\n     0\n");
+        fprintf (fp, "  9\n$USERI4\n 70\n     0\n");
+        fprintf (fp, "  9\n$USERI5\n 70\n     0\n");
+        fprintf (fp, "  9\n$USERR1\n 40\n0.0\n");
+        fprintf (fp, "  9\n$USERR2\n 40\n0.0\n");
+        fprintf (fp, "  9\n$USERR3\n 40\n0.0\n");
+        fprintf (fp, "  9\n$USERR4\n 40\n0.0\n");
+        fprintf (fp, "  9\n$USERR5\n 40\n0.0\n");
+        fprintf (fp, "  9\n$WORLDVIEW\n 70\n     1\n");
+        fprintf (fp, "  9\n$SHADEDGE\n 70\n     3\n");
+        fprintf (fp, "  9\n$SHADEDIF\n 70\n    70\n");
+        fprintf (fp, "  9\n$TILEMODE\n 70\n     1\n");
+        fprintf (fp, "  9\n$MAXACTVP\n 70\n    48\n");
+        fprintf (fp, "  9\n$PINSBASE\n 10\n0.0\n 20\n0.0\n 30\n0.0\n");
+        fprintf (fp, "  9\n$PLIMCHECK\n 70\n     0\n");
+        fprintf (fp, "  9\n$PEXTMIN\n 10\n1.000000E+20\n 20\n1.000000E+20\n 30\n1.000000E+20\n");
+        fprintf (fp, "  9\n$PEXTMAX\n 10\n-1.000000E+20\n 20\n-1.000000E+20\n 30\n-1.000000E+20\n");
+        fprintf (fp, "  9\n$PLIMMIN\n 10\n0.0\n 20\n0.0\n");
+        fprintf (fp, "  9\n$PLIMMAX\n 10\n420.0\n 20\n297.0");
+        fprintf (fp, "  9\n$UNITMODE\n 70\n     0\n");
+        fprintf (fp, "  9\n$VISRETAIN\n 70\n     1\n");
+        fprintf (fp, "  9\n$PLINEGEN\n 70\n     0\n");
+        fprintf (fp, "  9\n$PSLTSCALE\n 70\n     1\n");
+        fprintf (fp, "  9\n$TREEDEPTH\n 70\n  3020\n");
+        fprintf (fp, "  9\n$PICKSTYLE\n 70\n     1\n");
+        fprintf (fp, "  9\n$CMLSTYLE\n  2\nSTANDARD\n");
+        fprintf (fp, "  9\n$CMLJUST\n 70\n     0\n");
+        fprintf (fp, "  9\n$CMLSCALE\n 40\n1.0\n");
+        fprintf (fp, "  9\n$PROXYGRAPHICS\n 70\n     1\n");
+        fprintf (fp, "  9\n$MEASUREMENT\n 70\n     0\n");
+        fprintf (fp, "  0\nENDSEC\n");
+        /* write a CLASSES section */
+        fprintf (fp, "  0\nSECTION\n");
+        fprintf (fp, "  2\nCLASSES\n");
+        fprintf (fp, "  0\nENDSEC\n");
+        /* write a TABLES section */
+        fprintf (fp, "  0\nSECTION\n");
+        fprintf (fp, "  2\nTABLES\n");
+        /* write a VPORT (viewport) table entry */
+        fprintf (fp, "  0\nTABLE\n");
+        fprintf (fp, "  2\nVPORT\n");
+        fprintf (fp, "  5\n23A\n");
+        fprintf (fp, "100\nAcDbSymbolTable\n");
+        fprintf (fp, " 70\n     2\n");
+        fprintf (fp, "  0\nVPORT\n");
+        fprintf (fp, "  5\n261\n");
+        fprintf (fp, "100\nAcDbSymbolTableRecord\n");
+        fprintf (fp, "100\nAcDbViewportTableRecord\n");
+        fprintf (fp, "  2\n*ACTIVE\n");
+        fprintf (fp, " 70\n     0\n");
+        fprintf (fp, " 10\n0.0\n 20\n0.0\n");
+        fprintf (fp, " 11\n1.0\n 21\n1.0\n");
+        fprintf (fp, " 12\n43.998872\n 22\n17.506577\n");
+        fprintf (fp, " 13\n0.0\n 23\n0.0\n");
+        fprintf (fp, " 14\n1.0\n 24\n1.0\n");
+        fprintf (fp, " 15\n10.0\n 25\n10.0\n");
+        fprintf (fp, " 16\n0.0\n 26\n0.0\n 36\n1.0\n");
+        fprintf (fp, " 17\n0.0\n 27\n0.0\n 37\n0.0\n");
+        fprintf (fp, " 40\n47.164502\n");
+        fprintf (fp, " 41\n1.882514\n");
+        fprintf (fp, " 42\n50.0\n");
+        fprintf (fp, " 43\n0.0\n");
+        fprintf (fp, " 44\n0.0\n");
+        fprintf (fp, " 50\n0.0\n");
+        fprintf (fp, " 51\n0.0\n");
+        fprintf (fp, " 71\n     0\n");
+        fprintf (fp, " 72\n   100\n");
+        fprintf (fp, " 73\n     1\n");
+        fprintf (fp, " 74\n     3\n");
+        fprintf (fp, " 75\n     0\n");
+        fprintf (fp, " 76\n     0\n");
+        fprintf (fp, " 77\n     0\n");
+        fprintf (fp, " 78\n     0\n");
+        fprintf (fp, "  0\nENDTAB\n");
+        /* write LTYPE (linetype) table entries */
+        fprintf (fp, "  0\nTABLE\n");
+        fprintf (fp, "  2\nLTYPE\n");
+        fprintf (fp, "  5\n237\n");
+        fprintf (fp, "100\nAcDbSymbolTable\n");
+        fprintf (fp, " 70\n     1\n");
+        fprintf (fp, "  0\nLTYPE\n");
+        fprintf (fp, "  5\n244\n");
+        fprintf (fp, "100\nAcDbSymbolTableRecord\n");
+        /* write a record entry for a BYBLOCK linetype */
+        fprintf (fp, "100\nAcDbLinetypeTableRecord\n");
+        fprintf (fp, "  2\nBYBLOCK\n");
+        fprintf (fp, " 70\n     0\n");
+        fprintf (fp, "  3\n\n");
+        fprintf (fp, " 72\n    65\n");
+        fprintf (fp, " 73\n     0\n");
+        fprintf (fp, " 40\n0.0\n");
+        fprintf (fp, "  0\nLTYPE\n");
+        fprintf (fp, "  5\n245\n");
+        fprintf (fp, "100\nAcDbSymbolTableRecord\n");
+        /* write a record entry for a BYLAYER linetype */
+        fprintf (fp, "100\nAcDbLinetypeTableRecord\n");
+        fprintf (fp, "  2\nBYLAYER\n");
+        fprintf (fp, " 70\n     0\n");
+        fprintf (fp, "  3\n\n");
+        fprintf (fp, " 72\n    65\n");
+        fprintf (fp, " 73\n     0\n");
+        fprintf (fp, " 40\n0.0\n");
+        fprintf (fp, "  0\nLTYPE\n");
+        fprintf (fp, "  5\n246\n");
+        fprintf (fp, "100\nAcDbSymbolTableRecord\n");
+        /* write a record entry for a CONTINUOUS linetype */
+        fprintf (fp, "100\nAcDbLinetypeTableRecord\n");
+        fprintf (fp, "  2\nCONTINUOUS\n");
+        fprintf (fp, " 70\n     0\n");
+        fprintf (fp, "  3\nSolid line\n");
+        fprintf (fp, " 72\n    65\n");
+        fprintf (fp, " 73\n     0\n");
+        fprintf (fp, " 40\n0.0\n");
+        fprintf (fp, "  0\nENDTAB\n");
+        /* write LAYER table entries */
+        fprintf (fp, "  0\nTABLE\n");
+        fprintf (fp, "  2\nLAYER\n");
+        fprintf (fp, "  5\n234\n");
+        fprintf (fp, "100\nAcDbSymbolTable\n");
+        fprintf (fp, " 70\n     2\n");
+        fprintf (fp, "  0\nLAYER\n");
+        fprintf (fp, "  5\n240\n");
+        fprintf (fp, "100\nAcDbSymbolTableRecord\n");
+        /* write a record entry for layer "0" */
+        fprintf (fp, "100\nAcDbLayerTableRecord\n");
+        fprintf (fp, "  2\n0\n");
+        fprintf (fp, " 70\n     0\n");
+        fprintf (fp, " 62\n     7\n");
+        fprintf (fp, "  6\nCONTINUOUS\n");
+        fprintf (fp, "  0\nLAYER\n");
+        fprintf (fp, "  5\n251\n");
+        fprintf (fp, "100\nAcDbSymbolTableRecord\n");
+        /* * write a record entry for a layer "ASHADE" */
+        fprintf (fp, "100\nAcDbLayerTableRecord\n");
+        fprintf (fp, "  2\nASHADE\n");
+        fprintf (fp, " 70\n     4\n");
+        fprintf (fp, " 62\n     7\n");
+        fprintf (fp, "  6\nCONTINUOUS\n");
+        fprintf (fp, "  0\nENDTAB\n");
+        /* write STYLE table entries */
+        fprintf (fp, "  0\nTABLE\n");
+        fprintf (fp, "  2\nSTYLE\n");
+        fprintf (fp, "  5\n235\n");
+        fprintf (fp, "100\nAcDbSymbolTable\n");
+        fprintf (fp, " 70\n     2\n");
+        fprintf (fp, "  0\nSTYLE\n");
+        fprintf (fp, "  5\n241\n");
+        fprintf (fp, "100\nAcDbSymbolTableRecord\n");
+        /* write a record entry for a style "STANDARD" */
+        fprintf (fp, "100\nAcDbTextStyleTableRecord\n");
+        fprintf (fp, "  2\nSTANDARD\n");
+        fprintf (fp, " 70\n     0\n");
+        fprintf (fp, " 40\n0.0\n");
+        fprintf (fp, " 41\n1.0\n");
+        fprintf (fp, " 50\n0.0\n");
+        fprintf (fp, " 71\n     0\n");
+        fprintf (fp, " 42\n2.5\n");
+        fprintf (fp, "  3\ntxt\n");
+        fprintf (fp, "  4\n\n");
+        fprintf (fp, "  0\nSTYLE\n");
+        fprintf (fp, "  5\n252\n");
+        fprintf (fp, "100\nAcDbSymbolTableRecord\n");
+        /* write a record entry for a style "ASHADE" */
+        fprintf (fp, "100\nAcDbTextStyleTableRecord\n");
+        fprintf (fp, "  2\nASHADE\n");
+        fprintf (fp, " 70\n     0\n");
+        fprintf (fp, " 40\n0.2\n");
+        fprintf (fp, " 41\n1.0\n");
+        fprintf (fp, " 50\n0.0\n");
+        fprintf (fp, " 71\n     0\n");
+        fprintf (fp, " 42\n2.5\n");
+        fprintf (fp, "  3\nsimplex.shx\n");
+        fprintf (fp, "  4\n\n");
+        fprintf (fp, "  0\nENDTAB\n");
+        /* write a VIEW table entry */
+        fprintf (fp, "  0\nTABLE\n");
+        fprintf (fp, "  2\nVIEW\n");
+        fprintf (fp, "  5\n238\n");
+        fprintf (fp, "100\nAcDbSymbolTable\n");
+        fprintf (fp, " 70\n     0\n");
+        fprintf (fp, "  0\nENDTAB\n");
+        /* write a UCS (User Coordinate System) table entry */
+        fprintf (fp, "  0\nTABLE\n");
+        fprintf (fp, "  2\nUCS\n");
+        fprintf (fp, "  5\n239\n");
+        fprintf (fp, "100\nAcDbSymbolTable\n");
+        fprintf (fp, " 70\n     0\n");
+        fprintf (fp, "  0\nENDTAB\n");
+        /* write a APPID (APPlication ID) table entry */
+        fprintf (fp, "  0\nTABLE\n");
+        fprintf (fp, "  2\nAPPID\n");
+        fprintf (fp, "  5\n23B\n");
+        fprintf (fp, "100\nAcDbSymbolTable\n");
+        fprintf (fp, " 70\n     6\n");
+        fprintf (fp, "  0\nAPPID\n");
+        fprintf (fp, "  5\n242\n");
+        fprintf (fp, "100\nAcDbSymbolTableRecord\n");
+        /* write a record entry for a appid "ACAD" */
+        fprintf (fp, "100\nAcDbRegAppTableRecord\n");
+        fprintf (fp, "  2\nACAD\n");
+        fprintf (fp, " 70\n     0\n");
+        fprintf (fp, "  0\nAPPID\n");
+        fprintf (fp, "  5\n253\n");
+        fprintf (fp, "100\nAcDbSymbolTableRecord\n");
+        /* write a record entry for a appid "AVE_RENDER" */
+        fprintf (fp, "100\nAcDbRegAppTableRecord\n");
+        fprintf (fp, "  2\nAVE_RENDER\n");
+        fprintf (fp, " 70\n     0\n");
+        fprintf (fp, "  0\nAPPID\n");
+        fprintf (fp, "  5\n254\n");
+        fprintf (fp, "100\nAcDbSymbolTableRecord\n");
+        /* write a record entry for a appid "AVE_ENTITY_MATERIAL" */
+        fprintf (fp, "100\nAcDbRegAppTableRecord\n");
+        fprintf (fp, "  2\nAVE_ENTITY_MATERIAL\n");
+        fprintf (fp, " 70\n     0\n");
+        fprintf (fp, "  0\nAPPID\n");
+        fprintf (fp, "  5\n255\n");
+        fprintf (fp, "100\nAcDbSymbolTableRecord\n");
+        /* write a record entry for a appid "AVE_FINISH" */
+        fprintf (fp, "100\nAcDbRegAppTableRecord\n");
+        fprintf (fp, "  2\nAVE_FINISH\n");
+        fprintf (fp, " 70\n     0\n");
+        fprintf (fp, "  0\nAPPID\n");
+        fprintf (fp, "  5\n256\n");
+        fprintf (fp, "100\nAcDbSymbolTableRecord\n");
+        /* write a record entry for a appid "AVE_MATERIAL" */
+        fprintf (fp, "100\nAcDbRegAppTableRecord\n");
+        fprintf (fp, "  2\nAVE_MATERIAL\n");
+        fprintf (fp, " 70\n     0\n");
+        fprintf (fp, "  0\nAPPID\n");
+        fprintf (fp, "  5\n257\n");
+        fprintf (fp, "100\nAcDbSymbolTableRecord\n");
+        /* write a record entry for a appid "AVE_GLOBAL" */
+        fprintf (fp, "100\nAcDbRegAppTableRecord\n");
+        fprintf (fp, "  2\nAVE_GLOBAL\n");
+        fprintf (fp, " 70\n     0\n");
+        fprintf (fp, "  0\nENDTAB\n");
+        /* write a DIMSTYLE (DIMensioning STYLE) table entry */
+        fprintf (fp, "  0\nTABLE\n");
+        fprintf (fp, "  2\nDIMSTYLE\n");
+        fprintf (fp, "  5\n23C\n");
+        fprintf (fp, "100\nAcDbSymbolTable\n");
+        fprintf (fp, " 70\n     1\n");
+        fprintf (fp, "  0\nDIMSTYLE\n");
+        fprintf (fp, "105\n258\n");
+        fprintf (fp, "100\nAcDbSymbolTableRecord\n");
+        /* write a record entry for a dimstyle "STANDARD" */
+        fprintf (fp, "100\nAcDbDimStyleTableRecord\n");
+        fprintf (fp, "  2\nSTANDARD\n");
+        fprintf (fp, " 70\n     0\n");
+        fprintf (fp, "  3\n\n");
+        fprintf (fp, "  4\n\n");
+        fprintf (fp, "  5\n\n");
+        fprintf (fp, "  6\n\n");
+        fprintf (fp, "  7\n\n");
+        fprintf (fp, " 40\n1.0\n");
+        fprintf (fp, " 41\n0.18\n");
+        fprintf (fp, " 42\n0.0625\n");
+        fprintf (fp, " 43\n0.38\n");
+        fprintf (fp, " 44\n0.18\n");
+        fprintf (fp, " 45\n0.0\n");
+        fprintf (fp, " 46\n0.0\n");
+        fprintf (fp, " 47\n0.0\n");
+        fprintf (fp, " 48\n0.0\n");
+        fprintf (fp, "140\n0.18\n");
+        fprintf (fp, "141\n0.09\n");
+        fprintf (fp, "142\n0.0\n");
+        fprintf (fp, "143\n25.4\n");
+        fprintf (fp, "144\n1.0\n");
+        fprintf (fp, "145\n0.0\n");
+        fprintf (fp, "146\n1.0\n");
+        fprintf (fp, "147\n0.09\n");
+        fprintf (fp, " 71\n     0\n");
+        fprintf (fp, " 72\n     0\n");
+        fprintf (fp, " 73\n     1\n");
+        fprintf (fp, " 74\n     1\n");
+        fprintf (fp, " 75\n     0\n");
+        fprintf (fp, " 76\n     0\n");
+        fprintf (fp, " 77\n     0\n");
+        fprintf (fp, " 78\n     0\n");
+        fprintf (fp, "170\n     0\n");
+        fprintf (fp, "171\n     2\n");
+        fprintf (fp, "172\n     0\n");
+        fprintf (fp, "173\n     0\n");
+        fprintf (fp, "174\n     0\n");
+        fprintf (fp, "175\n     0\n");
+        fprintf (fp, "176\n     0\n");
+        fprintf (fp, "177\n     0\n");
+        fprintf (fp, "178\n     0\n");
+        fprintf (fp, "270\n     2\n");
+        fprintf (fp, "271\n     4\n");
+        fprintf (fp, "272\n     4\n");
+        fprintf (fp, "273\n     2\n");
+        fprintf (fp, "274\n     2\n");
+        fprintf (fp, "340\n241\n");
+        /* this doesn't look like good dxf syntax to me */
+        fprintf (fp, "275\n     0\n");
+        fprintf (fp, "280\n     0\n");
+        fprintf (fp, "281\n     0\n");
+        fprintf (fp, "282\n     0\n");
+        fprintf (fp, "283\n     1\n");
+        fprintf (fp, "284\n     0\n");
+        fprintf (fp, "285\n     0\n");
+        fprintf (fp, "286\n     0\n");
+        fprintf (fp, "287\n     3\n");
+        fprintf (fp, "288\n     0\n");
+        fprintf (fp, "  0\nENDTAB\n");
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_write_header_metric_new () function.\n", __FILE__, __LINE__);
+#endif
+}
+
+/*!
+ * \brief Write DXF output to a file for a DXF header derived from a default
+ * header template file if available. If no default header template file is
+ * available, generate one depending on the dxf_metric variable.
+ *
+ * Write down a DXF header based on values derived from a default header
+ * template file (in pcb/src/hid/dxf/template directory).\n
+ * Included sections and tables are:\n
+ * <ul>
+ * <li>HEADER section
+ * <li>CLASSES section
+ * <li>TABLES section
+ *   <ul>
+ *   <li>VPORT table
+ *   <li>LTYPE table
+ *   <li>LAYER table
+ *   <li>STYLE table
+ *   <li>VIEW table
+ *   <li>UCS table
+ *   <li>APPID table
+ *   <li>DIMSTYLE table
+ *   </ul>
+ * </ul>
+ * Continue from here with writing a BLOCK_RECORD table and close the section
+ * with an ENDSEC marker.
+ */
+static void
+dxf_write_header
+(
+)
+{
+        FILE *f_temp;
+        char *temp = NULL;
+        int no_matched = 0;
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_write_header () function.\n", __FILE__, __LINE__);
+#endif
+
+        if (dxf_metric)
+        {
+                dxf_header_filename = strdup ("hid/dxf/template/metric_header.dxf");
+        }
+        else
+        {
+#if 0
+                dxf_header_filename = strdup ("hid/dxf/template/imperial_header.dxf");
+#endif
+        }
+        /* check if template metric header file exists and open file
+         * read-only  */
+        f_temp = fopen (dxf_header_filename, "r");
+        if (f_temp)
+        {
+                /* do until EOF of the template file:
+                 * copy line by line from template file (f_temp) to
+                 * destination file (fp) */
+                while (no_matched != EOF)
+                {
+                        no_matched = fscanf (f_temp, "%s", temp);
+                        fprintf (fp, "%s", temp);
+                }
+                /* when we're done close the template file */
+                fclose (f_temp);
+        }
+        else
+        {
+                gui->log ("Error in dxf_write_header_from_template (): cannot open file %s for reading.\n", dxf_header_filename);
+                if (dxf_metric)
+                {
+                        dxf_write_header_metric_new ();
+                }
+                else
+                {
+                        dxf_write_header_imperial_new ();
+                }
+        }
+        /* write a block record table */
+        dxf_write_table_block_record (fp);
+        /* write ENDSEC marker to close the header */
+        dxf_write_endsection (fp);
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_write_header () function.\n", __FILE__, __LINE__);
+#endif
+}
+
+/*!
+ * \brief Write DXF output to a file for an insert entity.
+ */
+static void
+dxf_write_insert
+(
+        FILE *fp,
+                /*!< file pointer to output file (or device). */
+        int id_code,
+                /*!< group code = 5. */
+        char *block_name,
+                /*!< group code = 2. */
+        char *linetype,
+                /*!< group code = 6\n
+                 * optional, if omitted defaults to \c BYLAYER. */
+        char *layer,
+                /*!< group code = 8. */
+        double x0,
+                /*!< group code = 10\n
+                 * base point. */
+        double y0,
+                /*!< group code = 20\n
+                 * base point. */
+        double z0,
+                /*!< group code = 30\n
+                 * base point. */
+        double thickness,
+                /*!< group code = 39\n
+                 * optional, if omitted defaults to 0.0. */
+        double rel_x_scale,
+                /*!< group code = 41\n
+                 * optional, if omitted defaults to 1.0. */
+        double rel_y_scale,
+                /*!< group code = 42\n
+                 * optional, if omitted defaults to 1.0. */
+        double rel_z_scale,
+                /*!< group code = 43\n
+                 * optional, if omitted defaults to 1.0. */
+        double column_spacing,
+                /*!< group code = 44\n
+                 * optional, if omitted defaults to 0.0. */
+        double row_spacing,
+                /*!< group code = 45\n
+                 * optional, if omitted defaults to 0.0. */
+        double rot_angle,
+                /*!< group code = 50\n
+                 * optional, if omitted defaults to 0.0. */
+        int color,
+                /*!< group code = 62\n
+                 * optional, if omitted defaults to \c BYLAYER. */
+        int attribute_follows,
+                /*!< group code = 66\n
+                 * optional, if omitted defaults to 0. */
+        int paperspace,
+                /*!< group code = 67\n
+                 * optional, if omitted defaults to 0 (modelspace). */
+        int columns,
+                /*!< group code = 70\n
+                 * optional, if omitted defaults to 1. */
+        int rows
+                /*!< group code = 71\n
+                 * optional, if omitted defaults to 1. */
+)
+{
+        char *dxf_entity_name = strdup ("INSERT");
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_write_insert () function.\n", __FILE__, __LINE__);
+        fprintf (stderr, "[DXF entity with ID code %x]\n", id_code);
+#endif
+        if (strcmp (block_name, "") == 0)
+        {
+                fprintf (stderr, "Warning: empty block name string for the %s entity with id-code: %x\n", dxf_entity_name, id_code);
+                fprintf (stderr, "         %s entity is discarded from output.\n", dxf_entity_name);
+                return;
+        }
+        if (strcmp (layer, "") == 0)
+        {
+                fprintf (stderr, "Warning: empty layer string for the %s entity with id-code: %x\n", dxf_entity_name, id_code);
+                fprintf (stderr, "    %s entity is relocated to layer 0.\n", dxf_entity_name);
+                layer = strdup (DXF_DEFAULT_LAYER);
+        }
+        if (rel_x_scale == 0.0)
+        {
+                fprintf (stderr, "Warning: relative X-scale factor has a value of 0.0 for the %s entity with id-code: %x\n", dxf_entity_name, id_code);
+                fprintf (stderr, "    default relative X-scale of 1.0 applied to %s entity.\n", dxf_entity_name);
+                rel_x_scale = 1.0;
+        }
+        if (rel_y_scale == 0.0)
+        {
+                fprintf (stderr, "Warning: relative Y-scale factor has a value of 0.0 for the %s entity with id-code: %x\n", dxf_entity_name, id_code);
+                fprintf (stderr, "    default relative Y-scale of 1.0 applied to %s entity.\n", dxf_entity_name);
+                rel_y_scale = 1.0;
+        }
+        if (rel_z_scale == 0.0)
+        {
+                fprintf (stderr, "Warning: relative Z-scale factor has a value of 0.0 for the %s entity with id-code: %x\n", dxf_entity_name, id_code);
+                fprintf (stderr, "    default relative Z-scale of 1.0 applied to %s entity.\n", dxf_entity_name);
+                rel_z_scale = 1.0;
+        }
+        if ((columns > 1) && (column_spacing == 0.0))
+        {
+                fprintf (stderr, "Warning: number of columns is greater than 1 and the column spacing has a value of 0.0 for the %s entity with id-code: %x\n", dxf_entity_name, id_code);
+                fprintf (stderr, "    default number of columns value of 1 applied to %s entity.\n", dxf_entity_name);
+                columns = 1;
+        }
+        if ((rows > 1) && (row_spacing == 0.0))
+        {
+                fprintf (stderr, "Warning: number of rows is greater than 1 and the row spacing has a value of 0.0 for the %s entity with id-code: %x\n", dxf_entity_name, id_code);
+                fprintf (stderr, "    default number of rows value of 1 applied to %s entity.\n", dxf_entity_name);
+                rows = 1;
+        }
+        fprintf (fp, "  0\n%s\n", dxf_entity_name);
+        fprintf (fp, "  2\n%s\n", block_name);
+        if (id_code != -1)
+        {
+                fprintf (fp, "  5\n%x\n", id_code);
+        }
+        if (strcmp (linetype, DXF_DEFAULT_LINETYPE) != 0)
+        {
+                fprintf (fp, "  6\n%s\n", linetype);
+        }
+        fprintf (fp, "  8\n%s\n", layer);
+        fprintf (fp, " 10\n%f\n", x0);
+        fprintf (fp, " 20\n%f\n", y0);
+        fprintf (fp, " 30\n%f\n", z0);
+        if (thickness != 0.0)
+        {
+                fprintf (fp, " 39\n%f\n", thickness);
+        }
+        if (rel_x_scale != 1.0)
+        {
+                fprintf (fp, " 41\n%f\n", rel_x_scale);
+        }
+        if (rel_y_scale != 1.0)
+        {
+                fprintf (fp, " 42\n%f\n", rel_y_scale);
+        }
+        if (rel_z_scale != 1.0) fprintf (fp, " 43\n%f\n", rel_z_scale);
+        if ((columns > 1) && (column_spacing > 0.0)) fprintf (fp, " 44\n%f\n", column_spacing);
+        if ((rows > 1) && (row_spacing > 0.0)) fprintf (fp, " 45\n%f\n", row_spacing);
+        if (rot_angle != 0.0) fprintf (fp, " 50\n%f\n", rot_angle);
+        if (color != DXF_COLOR_BYLAYER) fprintf (fp, " 62\n%d\n", color);
+        if (attribute_follows != 0) fprintf (fp, " 66\n%d\n", attribute_follows);
+        if (paperspace == DXF_PAPERSPACE) fprintf (fp, " 67\n%d\n", DXF_PAPERSPACE);
+        if (columns > 1) fprintf (fp, " 70\n%d\n", columns);
+        if (rows > 1) fprintf (fp, " 71\n%d\n", rows);
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_write_insert () function.\n", __FILE__, __LINE__);
+#endif
+}
+
+/*!
+ * \brief Write DXF output to a file for a polyline entity.
+ *
+ * Following the Polyline header is a sequence of <c>Vertex</c> entities that
+ * specify the vertex coordinates and faces that compose the mesh.\n
+ * Vertices such as these are described in the following subsection on
+ * Vertex.\n
+ * \n
+ * Applications might want to represent polygons with an arbitrarily large
+ * number of sides in polyface meshes.\n
+ * However, the AutoCAD entity structure imposes a limit on the number of
+ * vertices that a given face entity can specify.\n
+ * You can represent more complex polygons by decomposing them into triangular
+ * wedges.\n
+ */
+static void
+dxf_write_polyline
+(
+        FILE *fp, /*!< file pointer to output device  */
+        int id_code, /*!< group code = 5  */
+        char *linetype, /*!< group code = 6 \n optional, if omitted defaults to BYLAYER  */
+        char *layer, /*!< group code = 8  */
+        double x0, /*!< group code = 10 \n if omitted defaults to 0.0  */
+        double y0, /*!< group code = 20 \n if omitted defaults to 0.0  */
+        double z0, /*!< group code = 30 \n default elevation for vertices  */
+        double extr_x0, /*!< group code = 210 \n extrusion direction \n optional, if ommited defaults to 0.0  */
+        double extr_y0, /*!< group code = 220 \n extrusion direction \n optional, if ommited defaults to 0.0  */
+        double extr_z0, /*!< group code = 230 \n extrusion direction \n optional, if ommited defaults to 1.0  */
+        double thickness, /*!< group code = 39 \n optional, if omitted defaults to 0.0  */
+        double start_width, /*!< group code = 40 \n optional, if omitted defaults to 0.0  */
+        double end_width, /*!< group code = 41 \n optional, if omitted defaults to 0.0  */
+        int color, /*!< group code = 62 \n optional, if omitted defaults to BYLAYER  */
+        int vertices_follow, /*!< group code = 66 \n mandatory, always 1 (one or more vertices make up a polyline)  */
+        int paperspace, /*!< group code = 67 \n optional, if omitted defaults to 0 (modelspace)  */
+        int flag, /*!< group code = 70 \n optional, if omitted defaults to 0  */
+                /*!< 1 = This is a closed Polyline (or a polygon mesh closed in the M direction) \n  */
+                /*!< 2 = Curve-fit vertices have been added \n  */
+                /*!< 4 = Spline-fit vertices have been added \n  */
+                /*!< 8 = This is a 3D Polyline \n  */
+                /*!< 16 = This is a 3D polygon mesh. \n  */
+                /*!< 32 = The polygon mesh is closed in the N direction \n  */
+                /*!< 64 = This Polyline is a polyface mesh \n  */
+                /*!< 128 = The linetype pattern is generated continuously around the vertices of this Polyline  */
+        int polygon_mesh_M_vertex_count, /*!< group code = 71 \n optional, if omitted defaults to 0  */
+        int polygon_mesh_N_vertex_count, /*!< group code = 72 \n optional, if omitted defaults to 0  */
+        int smooth_M_surface_density, /*!< group code = 73 \n optional, if omitted defaults to 0  */
+        int smooth_N_surface_density, /*!< group code = 74 \n optional, if omitted defaults to 0  */
+        int surface_type /*!< group code = 75 \n optional, if omitted defaults to 0 \n integer coded, not bit-coded: \n  */
+                /*!< 0 = no smooth surface fitted \n  */
+                /*!< 5 = quadratic B-spline surface \n  */
+                /*!< 6 = cubic B-spline surface \n  */
+                /*!< 8 = Bezier surface \n  */
+)
+{
+        char *dxf_entity_name = strdup ("POLYLINE");
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_write_polyline () function.\n", __FILE__, __LINE__);
+        fprintf (stderr, "[DXF entity with code %x]\n", id_code);
+#endif
+        if (x0 != 0.0)
+        {
+                fprintf (stderr, "Warning: start point has an invalid X-value for the %s entity with id-code: %x\n", dxf_entity_name, id_code);
+                fprintf (stderr, "         %s entity is discarded from output.\n", dxf_entity_name);
+                return;
+        }
+        if (y0 != 0.0)
+        {
+                fprintf (stderr, "Warning: start point has an invalid Y-value for the %s entity with id-code: %x\n", dxf_entity_name, id_code);
+                fprintf (stderr, "         %s entity is discarded from output.\n", dxf_entity_name);
+                return;
+        }
+        if (vertices_follow != 1)
+        {
+                fprintf (stderr, "Warning: vertices follow flag has an invalid value for the %s entity with id-code: %x\n", dxf_entity_name, id_code);
+                fprintf (stderr, "         %s entity is discarded from output.\n", dxf_entity_name);
+                return;
+        }
+        if (strcmp (layer, "") == 0)
+        {
+                fprintf (stderr, "Warning: empty layer string for the %s entity with id-code: %x\n", dxf_entity_name, id_code);
+                fprintf (stderr, "         %s entity is relocated to layer 0\n", dxf_entity_name);
+                layer = strdup (DXF_DEFAULT_LAYER);
+        }
+        fprintf (fp, "  0\n%s\n", dxf_entity_name);
+        fprintf (fp, "100\nAcDb3dPolyline\n");
+        if (id_code != -1) fprintf (fp, "  5\n%x\n", id_code);
+        if (strcmp (linetype, DXF_DEFAULT_LINETYPE) != 0) fprintf (fp, "  6\n%s\n", linetype);
+        fprintf (fp, "  8\n%s\n", layer);
+        fprintf (fp, " 10\n%f\n", x0);
+        fprintf (fp, " 20\n%f\n", y0);
+        fprintf (fp, " 30\n%f\n", z0);
+        fprintf (fp, "210\n%f\n", extr_x0);
+        fprintf (fp, "220\n%f\n", extr_y0);
+        fprintf (fp, "230\n%f\n", extr_z0);
+        if (thickness != 0.0) fprintf (fp, " 39\n%f\n", thickness);
+        if (start_width != 0.0) fprintf (fp, " 40\n%f\n", start_width);
+        if (end_width != 0.0) fprintf (fp, " 41\n%f\n", end_width);
+        if (color != DXF_COLOR_BYLAYER) fprintf (fp, " 62\n%d\n", color);
+        fprintf (fp, " 66\n%d\n", vertices_follow);
+        if (paperspace == DXF_PAPERSPACE) fprintf (fp, " 67\n%d\n", DXF_PAPERSPACE);
+        fprintf (fp, " 70\n%d\n", flag);
+        fprintf (fp, " 71\n%d\n", polygon_mesh_M_vertex_count);
+        fprintf (fp, " 72\n%d\n", polygon_mesh_N_vertex_count);
+        fprintf (fp, " 73\n%d\n", smooth_M_surface_density);
+        fprintf (fp, " 74\n%d\n", smooth_N_surface_density);
+        fprintf (fp, " 75\n%d\n", surface_type);
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_write_polyline () function.\n", __FILE__, __LINE__);
+#endif
+}
+
+/*!
+ * \brief Write DXF output to a file for a section marker.
+ */
+static void
+dxf_write_section
+(
+        FILE *fp, /*!< file pointer to output device  */
+        char *section_name /*!< section name  */
+)
+{
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_write_section () function.\n", __FILE__, __LINE__);
+#endif
+        /* no use in writing an empty string to file */
+        if (strcmp (section_name, "") == 0)
+        {
+                return;
+        }
+        fprintf (fp, "  0\nSECTION\n  2\n%s\n", section_name);
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_write_section () function.\n", __FILE__, __LINE__);
+#endif
+}
+
+/*!
+ * \brief Write DXF output to a file for a solid entity.
+ */
+static void
+dxf_write_solid
+(
+        FILE *fp, /*!< file pointer to output device  */
+        int id_code, /*!< group code = 5  */
+        char *linetype, /*!< group code = 6 \n optional, defaults to BYLAYER  */
+        char *layer, /*!< group code = 8  */
+        double x0, /*!< group code = 10 \n base point X-value, bottom left  */
+        double y0, /*!< group code = 20 \n base point Y-value, bottom left  */
+        double z0, /*!< group code = 30 \n base point Z-value, bottom left  */
+        double x1, /*!< group code = 11 \n alignment point X-vaule, bottom right  */
+        double y1, /*!< group code = 21 \n alignment point Y-vaule, bottom right  */
+        double z1, /*!< group code = 31 \n alignment point Z-vaule, bottom right  */
+        double x2, /*!< group code = 12 \n alignment point X-value, top left  */
+        double y2, /*!< group code = 22 \n alignment point Y-value, top left  */
+        double z2, /*!< group code = 32 \n alignment point Z-value, top left  */
+        double x3, /*!< group code = 13 \n alignment point X-value, top right  */
+        double y3, /*!< group code = 23 \n alignment point Y-value, top right  */
+        double z3, /*!< group code = 33 \n alignment point Z-value, top right  */
+        double thickness, /*!< group code = 39 \n optional, defaults to 0.0  */
+        int color, /*!< group code = 62 \n optional, defaults to BYLAYER  */
+        int paperspace /*!< group code = 67 \n optional, defaults to 0 (modelspace)  */
+)
+{
+        char *dxf_entity_name = strdup ("SOLID");
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_write_solid () function.\n", __FILE__, __LINE__);
+        fprintf (stderr, "[DXF entity with code %x]\n", id_code);
+#endif
+        if (strcmp (layer, "") == 0)
+        {
+                fprintf (stderr, "Warning: empty layer string for the %s entity with id-code: %x\n", dxf_entity_name, id_code);
+                fprintf (stderr, "    %s entity is relocated to layer 0", dxf_entity_name);
+                layer = strdup (DXF_DEFAULT_LAYER);
+        }
+        fprintf (fp, "  0\n%s\n", dxf_entity_name);
+        if (id_code != -1) fprintf (fp, "  5\n%x\n", id_code);
+        if (strcmp (linetype, DXF_DEFAULT_LINETYPE) != 0) fprintf (fp, "  6\n%s\n", linetype);
+        fprintf (fp, "  8\n%s\n", layer);
+        fprintf (fp, " 10\n%f\n", x0);
+        fprintf (fp, " 20\n%f\n", y0);
+        fprintf (fp, " 30\n%f\n", z0);
+        fprintf (fp, " 11\n%f\n", x1);
+        fprintf (fp, " 21\n%f\n", y1);
+        fprintf (fp, " 31\n%f\n", z1);
+        fprintf (fp, " 12\n%f\n", x2);
+        fprintf (fp, " 22\n%f\n", y2);
+        fprintf (fp, " 32\n%f\n", z2);
+        fprintf (fp, " 13\n%f\n", x3);
+        fprintf (fp, " 23\n%f\n", y3);
+        fprintf (fp, " 33\n%f\n", z3);
+        if (thickness != 0.0) fprintf (fp, " 39\n%f\n", thickness);
+        if (color != DXF_COLOR_BYLAYER) fprintf (fp, " 62\n%d\n", color);
+        if (paperspace == DXF_PAPERSPACE) fprintf (fp, " 67\n%d\n", DXF_PAPERSPACE);
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_write_solid () function.\n", __FILE__, __LINE__);
+#endif
+}
+
+/*!
+ * \brief Write DXF output to a file for a polyline vertex entity.
+ */
+static void
+dxf_write_vertex
+(
+        FILE *fp, /*!< file pointer to output device  */
+        int id_code, /*!< group code = 5  */
+        char *linetype, /*!< group code = 6 \n optional, if omitted defaults to BYLAYER  */
+        char *layer, /*!< group code = 8  */
+        double x0, /*!< group code = 10 \n  */
+        double y0, /*!< group code = 20 \n  */
+        double z0, /*!< group code = 30 \n  */
+        double thickness, /*!< group code = 39 \n optional, if omitted defaults to 0.0  */
+        double start_width, /*!< group code = 40 \n optional, if omitted defaults to 0.0  */
+        double end_width, /*!< group code = 41 \n optional, if omitted defaults to 0.0  */
+        double bulge, /*!< group code = 42 \n optional, if omitted defaults to 0.0 \n The bulge is the tangent of 1/4 of the included angle for an arc segment. \n  */
+        /*!< Made negative if the arc goes clockwise from the start point to the endpoint. \n  */
+        /*!< A bulge of 0 indicates a straight segment, and a bulge of 1 is a semicircle. \n  */
+        double curve_fit_tangent_direction, /*!< group code = 50 \n optional, a curve-fit tangent direction of 0.0 may be omitted from the DXF output, but is significant if the flag bit is set. \n  */
+        int color, /*!< group code = 62 \n optional, if omitted defaults to BYLAYER  */
+        int paperspace, /*!< group code = 67 \n optional, if omitted defaults to 0 (modelspace)  */
+        int flag /*!< group code = 70 \n optional, if omitted defaults to 0  */
+        /*!< bit coded: \n  */
+        /*!< 1 = extra vertex created by curve-fitting \n  */
+        /*!< 2 = curve-fit tangent defined for this vertex. \n  */
+        /*!< 4 = unused (never set in DXF files) \n  */
+        /*!< 8 = spline vertex created by spline-fitting \n  */
+        /*!< 16 = spline frame control point \n  */
+        /*!< 32 = 3D Polyline vertex \n  */
+        /*!< 64 = 3D polygon mesh vertex \n  */
+        /*!< 128 = polyface mesh vertex  */
+)
+{
+        char *dxf_entity_name = strdup ("VERTEX");
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_write_vertex () function.\n", __FILE__, __LINE__);
+        fprintf (stderr, "[DXF entity with code %x]\n", id_code);
+#endif
+        if (strcmp (layer, "") == 0)
+        {
+                fprintf (stderr, "Warning: empty layer string for the %s entity with id-code: %x\n", dxf_entity_name, id_code);
+                fprintf (stderr, "    %s entity is relocated to layer 0", dxf_entity_name);
+                layer = strdup (DXF_DEFAULT_LAYER);
+        }
+
+        fprintf (fp, "  0\n%s\n", dxf_entity_name);
+        if (id_code != -1) fprintf (fp, "  5\n%x\n", id_code);
+        if (strcmp (linetype, DXF_DEFAULT_LINETYPE) != 0) fprintf (fp, "  6\n%s\n", linetype);
+        fprintf (fp, "  8\n%s\n", layer);
+        fprintf (fp, " 10\n%f\n", x0);
+        fprintf (fp, " 20\n%f\n", y0);
+        fprintf (fp, " 30\n%f\n", z0);
+        if (thickness != 0.0) fprintf (fp, " 39\n%f\n", thickness);
+        if (start_width != 0.0) fprintf (fp, " 40\n%f\n", start_width);
+        if (end_width != 0.0) fprintf (fp, " 41\n%f\n", end_width);
+        if (bulge != 0.0) fprintf (fp, " 42\n%f\n", bulge);
+        if (curve_fit_tangent_direction != 0.0) fprintf (fp, " 50\n%f\n", curve_fit_tangent_direction);
+        if (color != DXF_COLOR_BYLAYER) fprintf (fp, " 62\n%d\n", color);
+        if (paperspace == DXF_PAPERSPACE) fprintf (fp, " 67\n%d\n", DXF_PAPERSPACE);
+        fprintf (fp, " 70\n%d\n", flag);
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_write_vertex () function.\n", __FILE__, __LINE__);
+#endif
+}
+
+/*!
+ * \brief Get export options such as filename and filename base.
+ *
+ * Returns a set of resources describing options the export or print HID
+ * supports.\n
+ * In GUI mode, the print/export dialogs use this to set up the selectable
+ * options.\n
+ * In command line mode, these are used to interpret command line options.\n
+ * If n_ret is non-NULL, the number of attributes is stored there.
+ */
+static HID_Attribute *
+dxf_get_export_options (int *n)
+{
+        static char *last_dxf_filename = 0;
+        static char *last_dxf_xref_filename = 0;
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_get_export_options () function.\n", __FILE__, __LINE__);
+#endif
+        if (PCB)
+        {
+                derive_default_filename (PCB->Filename, &dxf_options[HA_dxffile], "", &last_dxf_filename);
+                derive_default_filename (PCB->Filename, &dxf_options[HA_xreffile], "", &last_dxf_xref_filename);
+        }
+        if (n)
+        {
+                *n = NUM_OPTIONS;
+        }
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_get_export_options () function.\n", __FILE__, __LINE__);
+#endif
+        return dxf_options;
+}
+
+/*!
+ * \brief Insert an element in the list of elements.
+ */
+static DxfList *
+dxf_insert
+(
+        char *refdes, /*!< reference designator.  */
+        char *descr, /*!< description or footprint.  */
+        char *value, /*!< element value.  */
+        DxfList * dxf /*!< next item in list.  */
+)
+{
+        DxfList *new, *cur, *prev = NULL;
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_insert () function.\n", __FILE__, __LINE__);
+#endif
+        if (dxf == NULL)
+        {
+        /*
+         * this is the first element so automatically create an entry.
+         */
+        if ((new = (DxfList *) malloc (sizeof (DxfList))) == NULL)
+        {
+                fprintf (stderr, "Error in dxf.c|dxf_insert (): malloc() failed.\n");
+                exit (1);
+        }
+        new->next = NULL;
+        new->descr = strdup (descr);
+        new->value = strdup (value);
+        new->num = 1;
+        new->refdes = dxf_string_insert (refdes, NULL);
+        return (new);
+        }
+        /*
+         * search and see if we already have used one of these components.
+         */
+        cur = dxf;
+        while (cur != NULL)
+        {
+                if ((NSTRCMP (descr, cur->descr) == 0) && (NSTRCMP (value, cur->value) == 0))
+                {
+                        cur->num++;
+                        cur->refdes = dxf_string_insert (refdes, cur->refdes);
+                        break;
+                }
+                prev = cur;
+                cur = cur->next;
+        }
+        if (cur == NULL)
+        {
+                if ((new = (DxfList *) malloc (sizeof (DxfList))) == NULL)
+                {
+                        fprintf (stderr, "Error in dxf.c|dxf_insert (): malloc() failed.\n");
+                        exit (1);
+                }
+                prev->next = new;
+                new->next = NULL;
+                new->descr = strdup (descr);
+                new->value = strdup (value);
+                new->num = 1;
+                new->refdes = dxf_string_insert (refdes, NULL);
+        }
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_insert () function.\n", __FILE__, __LINE__);
+#endif
+        return (dxf);
+}
+
+/*!
+ * \brief Print Xrefs to DXF file.
+ *
+ * Generate a file in the AutoCAD R14 DXF format for insertion of 3D models as
+ * external references (Xref's).\n
+ * An external reference is a reference to an external drawing block which is
+ * loaded at runtime (of the mechanical CAD software; for example AutoCAD)
+ * during the loading of the toplevel drawing model (the dxf file) in a
+ * mechanical CAD program or during separate insertions after the initial
+ * loading whilst in drawing mode.\n
+ * Note that for most mechanical CAD software the inserted block cannot be a
+ * DXF file.\n
+ * In most cases a DXF file representing a (3D) model must first be converted
+ * to a ".dwg" file, or any other file format native to the mechanical CAD
+ * software used.\n
+ * The filename of the 3D model inserted in the dxf file is:\n
+ * "Description or footprint name" + ".dwg" (file extension).\n
+ * Any element without a valid description or footprint name is inserted in the
+ * dxf file with a 3D model with a text "undefined part" and this has to be
+ * manually inserted in the toplevel model after the initial loading of the dxf
+ * file.\n
+ * This is to prevent unnoticed ommissions of parts in the toplevel 3D model.
+ */
+static int
+dxf_export_xref_file (void)
+{
+        char *name = NULL;
+        char utcTime[64];
+        double x;
+        double y;
+        double theta = 0.0;
+        double sumx;
+        double sumy;
+        double pin1x = 0.0;
+        double pin1y = 0.0;
+        double pin1angle = 0.0;
+        double pin2x = 0.0;
+        double pin2y = 0.0;
+        double pin2angle;
+        int found_pin1;
+        int found_pin2;
+        int pin_cnt;
+        time_t currenttime;
+        DxfList *dxf = NULL;
+        DxfList *lastb;
+        char *dxf_block_name = NULL;
+        char *dxf_xref_name = NULL;
+        double dxf_x0 = 0.0;
+        double dxf_y0 = 0.0;
+        double dxf_rot_angle = 0.0;
+
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_export_xref_file () function.\n", __FILE__, __LINE__);
+#endif
+
+        fp = fopen (dxf_xref_filename, "w");
+        if (!fp)
+        {
+                gui->log ("Error in dxf.c|dxf_export_xref_file (): cannot open file %s for writing.\n", dxf_xref_filename);
+                return 1;
+        }
+        /*
+         * create a portable timestamp.
+         */
+        currenttime = time (NULL);
+        strftime (utcTime, sizeof (utcTime), "%c UTC", gmtime (&currenttime));
+        if (dxf_verbose)
+        {
+                /* report at the beginning of each file */
+                fprintf (stderr, "DXF: Board Name: %s, %s \n", UNKNOWN (PCB->Name),
+                        UNKNOWN (name));
+                fprintf (stderr, "DXF: Created by: %s.\n", PCB_DXF_HID_VERSION);
+                fprintf (stderr, "DXF: Creation date: %s \n", utcTime);
+                fprintf (stderr, "DXF: File Format according to: AutoCAD R14.\n");
+                if (dxf_metric)
+                {
+                        fprintf (stderr, "DXF using Metric coordinates [mm].\n");
+                }
+                else
+                {
+                        fprintf (stderr, "DXF using Imperial coordinates [mil].\n");
+                }
+                fprintf (stderr, "PCB Dimensions: %d %d.\n", PCB->MaxWidth,
+                        PCB->MaxHeight);
+                fprintf (stderr, "PCB Coordinate Origin: lower left.\n");
+                fprintf (stderr, "DXF: Now processing Xrefs file.\n");
+        }
+        /* write version info as a dxf comment */
+        dxf_write_comment (fp, PCB_DXF_HID_VERSION);
+        /* write dxf header information */
+        dxf_write_header (fp);
+        dxf_write_section (fp, "BLOCKS");
+        /*
+         * lookup all elements on pcb and insert element in the list of elements.
+         */
+        ELEMENT_LOOP (PCB->Data);
+        {
+                /*
+                 * insert the elements into the dxf list.
+                 */
+                dxf = dxf_insert (UNKNOWN (NAMEONPCB_NAME (element)),
+                                  UNKNOWN (DESCRIPTION_NAME (element)),
+                                  UNKNOWN (VALUE_NAME (element)), dxf);
+        }
+        END_LOOP; /* End of ELEMENT_LOOP  */
+        /*
+         * now write a single block definition for every unique element to
+         * the BLOCKS section of the DXF file.
+         * since these are all supposed to be Xref blocks they are not to
+         * contain entities, just the path and filename (including extension).
+         * write a section BLOCKS marker to the DXF file.
+         */
+        while (dxf != NULL)
+        {
+                dxf_block_name = strdup (dxf_clean_string (dxf->descr));
+                dxf_xref_name = DXF_DEFAULT_XREF_PATH_NAME;
+                dxf_write_block
+                (
+                        fp,
+                        dxf_id_code,
+                        dxf_xref_name,
+                        dxf_block_name,
+                        DXF_DEFAULT_LINETYPE, /* linetype, */
+                        DXF_DEFAULT_LAYER, /* layer, */
+                        0.0, /* dxf_x0, */
+                        0.0, /* dxf_y0, */
+                        0.0, /* dxf_z0, */
+                        0.0, /* dxf_thickness, */
+                        DXF_COLOR_BYLAYER, /* dxf_color, */
+                        0, /* dxf_paperspace, */
+                        36 /* dxf_block_type*/
+                );
+                dxf_id_code++;
+                lastb = dxf;
+                dxf = dxf->next;
+                free (lastb);
+        }
+        /* write an ENDSEC marker to the DXF file */
+        dxf_write_endsection (fp);
+        /*
+         * write a section ENTITIES marker to the DXF file.
+         */
+        dxf_write_section (fp, "ENTITIES");
+        /*
+         * for each element we calculate the centroid of the footprint.
+         * in addition, we need to extract some notion of rotation.
+         */
+        ELEMENT_LOOP (PCB->Data);
+        {
+                /*
+                 * initialize our pin count and our totals for finding the
+                 * centroid.
+                 */
+                pin_cnt = 0;
+                sumx = 0.0;
+                sumy = 0.0;
+                found_pin1 = 0;
+                found_pin2 = 0;
+                /*
+                 * iterate over the pins and pads keeping a running count of
+                 * many pins/pads total and the sum of x and y coordinates.
+                 * While we're at it, store the location of pin/pad #1 and #2
+                 * if we can find them.
+                 */
+                PIN_LOOP (element);
+                {
+                        sumx += (double) pin->X;
+                        sumy += (double) pin->Y;
+                        pin_cnt++;
+                        if (NSTRCMP (pin->Number, "1") == 0)
+                        {
+                                pin1x = (double) pin->X;
+                                pin1y = (double) pin->Y;
+                                pin1angle = 0.0;
+                                found_pin1 = 1;
+                        }
+                        else if (NSTRCMP (pin->Number, "2") == 0)
+                        {
+                                pin2x = (double) pin->X;
+                                pin2y = (double) pin->Y;
+                                pin2angle = 0.0;
+                                found_pin2 = 1;
+                        }
+                }
+                END_LOOP; /* End of PIN_LOOP  */
+                PAD_LOOP (element);
+                {
+                        sumx += (pad->Point1.X + pad->Point2.X) / 2.0;
+                        sumy += (pad->Point1.Y + pad->Point2.Y) / 2.0;
+                        pin_cnt++;
+                        if (NSTRCMP (pad->Number, "1") == 0)
+                        {
+                                pin1x = (double) (pad->Point1.X + pad->Point2.X) / 2.0;
+                                pin1y = (double) (pad->Point1.Y + pad->Point2.Y) / 2.0;
+                                /*
+                                 * NOTE: we swap the Y points, because in PCB
+                                 * the Y-axis is inverted, and increasing Y
+                                 * moves down.
+                                 * we want to deal with a right-handed
+                                 * Cartesian Coordinate System where
+                                 * increasing Y moves up.
+                                 */
+                                pin1angle = (180.0 / M_PI) * atan2 (pad->Point1.Y - pad->Point2.Y, pad->Point2.X - pad->Point1.X);
+                                found_pin1 = 1;
+                        }
+                        else if (NSTRCMP (pad->Number, "2") == 0)
+                        {
+                                pin2x = (double) (pad->Point1.X + pad->Point2.X) / 2.0;
+                                pin2y = (double) (pad->Point1.Y + pad->Point2.Y) / 2.0;
+                                pin2angle = (180.0 / M_PI) * atan2 (pad->Point1.Y - pad->Point2.Y, pad->Point2.X - pad->Point1.X);
+                                found_pin2 = 1;
+                        }
+                }
+                END_LOOP; /* End of PAD_LOOP  */
+                if (pin_cnt > 0)
+                {
+                        x = sumx / (double) pin_cnt;
+                        y = sumy / (double) pin_cnt;
+                        if (found_pin1)
+                        {
+                                /*
+                                 * recenter pin #1 onto the axis which cross
+                                 * at the part centroid.
+                                 */
+                                pin1x -= x;
+                                pin1y -= y;
+                                pin1y = -1.0 * pin1y;
+                                /* if only 1 pin, use pin 1's angle */
+                                if (pin_cnt == 1) theta = pin1angle;
+                                else
+                                {
+                                /*
+                                 * if pin #1 is at (0,0) use pin #2 for
+                                 * rotation
+                                 */
+                                        if ((pin1x == 0.0) && (pin1y == 0.0))
+                                        {
+                                                if (found_pin2) theta = dxf_xy_to_angle (pin2x, pin2y);
+                                                else
+                                                {
+                                                        Message  ("Warning in dxf.c|dxf_export_xref_file ():\n"
+                                                                  "     unable to figure out angle of element\n"
+                                                                  "     %s because pin #1 is at the centroid of the part\n"
+                                                                  "     and I could not find pin #2's location.\n"
+                                                                  "     Setting to %g degrees.\n", UNKNOWN (NAMEONPCB_NAME (element)), theta);
+                                                }
+                                        }
+                                        else theta = dxf_xy_to_angle (pin1x, pin1y);
+                                }
+                        }
+                        /* we did not find pin #1 */
+                        else
+                        {
+                                theta = 0.0;
+                                Message  ("Warning in dxf.c|dxf_export_xref_file ():\n"
+                                          "     unable to figure out angle because I could\n"
+                                          "     not find pin #1 of element %s.\n"
+                                          "     Setting to %g degrees.\n", UNKNOWN (NAMEONPCB_NAME (element)), theta);
+                        }
+                        dxf_block_name = strdup (dxf_clean_string (UNKNOWN (DESCRIPTION_NAME (element))));
+                        if (dxf_metric)
+                        {
+                                /* convert mils to mm */
+                                dxf_x0 = MIL_TO_MM * x;
+                                /* convert mils to mm and a right handed
+                                 * Cartesian Coordinate System */
+                                dxf_y0 = MIL_TO_MM * (PCB->MaxHeight - y);
+                        }
+                        else
+                        {
+                                /*
+                                 * no need to convert, some things remain the
+                                 * same.
+                                 */
+                                dxf_x0 = x;
+                                /*
+                                 * only convert to a right handed Cartesian
+                                 * Coordinate System.
+                                 */
+                                dxf_y0 = (PCB->MaxHeight - y);
+                        }
+#if 0
+                        /*
+                         * convert the rotation angle as well:
+                         * theta -> CW, DXF -> CCW.
+                         */
+                        /*!
+                         * \todo for now we only support Cardinal angles
+                         * [North, East, South, West]
+                         */
+                        if (theta == 0.0) dxf_rot_angle = 90.0;
+                        else if (theta == 90.0) dxf_rot_angle = 0.0;
+                        else if (theta == 180.0) dxf_rot_angle = 270.0;
+                        else if (theta == 270.0) dxf_rot_angle = 180.0;
+                        else
+                        {
+                                dxf_rot_angle = 0.0;
+                                Message  ("Warning in dxf.c|dxf_export_xref_file ():\n"
+                                          "     unable to figure out angle of dxf block\n"
+                                          "     %s because pcb angle theta is not Cardinal [0.0, 90.0, 180.0, 270.0].\n"
+                                          "     Setting dxf_rot_angle to %g degrees\n", UNKNOWN (NAMEONPCB_NAME (element)), dxf_rot_angle);
+                       }
+#endif
+                       dxf_write_insert
+                       (
+                               fp,
+                               dxf_id_code,
+                               dxf_block_name,
+                               DXF_DEFAULT_LINETYPE, /* dxf_linetype, */
+                               DXF_DEFAULT_LAYER, /* dxf_layer, */
+                               dxf_x0,
+                               dxf_y0,
+                               0.0, /* dxf_z0, */
+                               0.0, /* dxf_thickness, */
+                               1.0, /* dxf_rel_x_scale, */
+                               1.0, /* dxf_rel_y_scale, */
+                               1.0, /* dxf_rel_z_scale, */
+                               0.0, /* dxf_column_spacing, */
+                               0.0, /* dxf_row_spacing, */
+                               dxf_rot_angle,
+                               DXF_COLOR_BYLAYER, /* dxf_color, */
+                               0, /* dxf_attribute_follows, */
+                               0, /* dxf_paperspace, */
+                               1, /* dxf_columns, */
+                               1 /* dxf_rows */
+                        );
+                }
+                dxf_id_code++;
+        }
+        END_LOOP; /* End of ELEMENT_LOOP  */
+        /*
+         * write an ENDSEC marker to the DXF file.
+         */
+        dxf_write_endsection(fp);
+        /*
+         * write an EOF marker and close the DXF file.
+         */
+        dxf_write_eof (fp);
+        fclose (fp);
+        fp = NULL;
+        dxf_id_code = 0;
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_export_xref_file () function.\n", __FILE__, __LINE__);
+#endif
+        return (0);
+}
+
+/*!
+ * \brief Close DXF layer file.
+ */
+static void
+dxf_maybe_close_file ()
+{
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_maybe_close_file () function.\n", __FILE__, __LINE__);
+#endif
+        if (fp)
+        {
+                /* write an EOF marker and close the DXF file */
+                dxf_write_eof (fp);
+                fclose (fp);
+        }
+        dxf_id_code = 0;
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_maybe_close_file () function.\n", __FILE__, __LINE__);
+#endif
+}
+
+/*!
+ * \brief Export (or print) the current PCB.
+ *
+ * The options given represent the choices made from the options returned
+ * from dxf_get_export_options.\n
+ * Call with options == NULL to start the primary GUI (create a main window,
+ * print, export, etc).\n
+ * \n
+ * First get the export options.\n
+ * Do export all the DXF files required.\n
+ * <ul>
+ * <li>Export the DXF file with Xref blocks to a seperate dxf file if required.\n
+ * <li>Export a DXF file for every PCB layer.\n
+ * </ul>
+ */
+static void
+dxf_do_export (HID_Attr_Val * options)
+{
+        char *dxf_fnbase = NULL;
+        int i;
+        static int saved_layer_stack[MAX_LAYER];
+        BoxType region;
+        int save_ons[MAX_LAYER + 2];
+
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_do_export () function.\n", __FILE__, __LINE__);
+#endif
+
+        if (!options)
+        {
+                dxf_get_export_options (0);
+                for (i = 0; i < NUM_OPTIONS; i++)
+                {
+                        dxf_values[i] = dxf_options[i].default_val;
+                }
+                options = dxf_values;
+        }
+        /*
+         * verbose output (dxf files to contain comments).
+         */
+        dxf_verbose = options[HA_verbose].int_value;
+        /*
+         * if all layers needs to be exported.
+         */
+        dxf_export_all_layers = options[HA_export_all_layers].int_value;
+        /*
+         * output to be in in mils or mm.
+         */
+        dxf_metric = options[HA_metric].int_value;
+        /*
+         * entity color to be BYBLOCK (or by layer number).
+         */
+        dxf_color_is_byblock = options[HA_color_byblock].int_value;
+        /*
+         * if xrefs DXF file needs to be exported.
+         */
+        dxf_xrefs = options[HA_xrefs].int_value;
+        if (dxf_xrefs)
+        {
+                /*
+                 * determine a file name for the xref file.
+                 */
+                dxf_xref_filename = options[HA_xreffile].str_value;
+                if (!dxf_xref_filename)
+                {
+                        strcat (dxf_xref_filename, "pcb-out_xrefs");
+                }
+                i = strlen (dxf_xref_filename);
+                dxf_xref_filename = MyRealloc (dxf_xref_filename, i + 40, "dxf");
+                strcat (dxf_xref_filename, "_xrefs.dxf");
+                dxf_filesuffix = dxf_xref_filename + strlen (dxf_xref_filename);
+                dxf_export_xref_file ();
+        }
+        /*
+         * determine a file name base for the DXF layer files.
+         */
+        dxf_fnbase = options[HA_dxffile].str_value;
+        if (!dxf_fnbase)
+        {
+                dxf_fnbase = "pcb_layers";
+        }
+        i = strlen (dxf_fnbase);
+        dxf_filename = MyRealloc (dxf_filename, i + 40, "dxf");
+        strcpy (dxf_filename, dxf_fnbase);
+        strcat (dxf_filename, "_");
+        dxf_filesuffix = dxf_filename + strlen (dxf_filename);
+        memset (print_group, 0, sizeof (print_group));
+        memset (print_layer, 0, sizeof (print_layer));
+        /*
+         * use this to temporarily enable all layers.
+         */
+        hid_save_and_show_layer_ons (save_ons);
+        for (i = 0; i < max_layer; i++)
+        {
+                LayerType *layer = PCB->Data->Layer + i;
+                if (layer->LineN || layer->TextN || layer->ArcN || layer->PolygonN)
+                {
+                        print_group[GetLayerGroupNumberByNumber (i)] = 1;
+                }
+        }
+        print_group[GetLayerGroupNumberByNumber (max_layer)] = 1;
+        print_group[GetLayerGroupNumberByNumber (max_layer + 1)] = 1;
+        for (i = 0; i < max_layer; i++)
+        {
+                if (print_group[GetLayerGroupNumberByNumber (i)])
+                {
+                        print_layer[i] = 1;
+                }
+        }
+        memcpy (saved_layer_stack, LayerStack, sizeof (LayerStack));
+        qsort (LayerStack, max_layer, sizeof (LayerStack[0]), dxf_layer_sort);
+        linewidth = -1;
+        lastcap = -1;
+        lastgroup = -1;
+        lastcolor = -1;
+        region.X1 = 0;
+        region.Y1 = 0;
+        region.X2 = PCB->MaxWidth;
+        region.Y2 = PCB->MaxHeight;
+        pagecount = 1;
+        dxf_init_apertures ();
+        lastgroup = -1;
+        c_layerapps = 0;
+        finding_apertures = 1;
+        hid_expose_callback (&dxf_hid, &region, 0);
+        c_layerapps = 0;
+        finding_apertures = 0;
+        hid_expose_callback (&dxf_hid, &region, 0);
+        memcpy (LayerStack, saved_layer_stack, sizeof (LayerStack));
+        dxf_maybe_close_file ();
+        hid_restore_layer_ons (save_ons);
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_do_export () function.\n", __FILE__, __LINE__);
+#endif
+}
+
+/*!
+ * \brief Parse the command line.
+ *
+ * Parse HID register attributes and HID command line arguments.\n
+ * Call this early for whatever HID will be the primary HID, as it will set
+ * all the registered attributes.\n
+ * The HID should remove all arguments, leaving any possible file names
+ * behind.
+ */
+static void
+dxf_parse_arguments (int *argc, char ***argv)
+{
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_parse_arguments () function.\n", __FILE__, __LINE__);
+#endif
+        hid_register_attributes (dxf_options, sizeof (dxf_options) / sizeof (dxf_options[0]));
+        hid_parse_command_line (argc, argv);
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_parse_arguments () function.\n", __FILE__, __LINE__);
+#endif
+}
+
+/*!
+ * \brief Sort drills (holes).
+ */
+static int
+dxf_drill_sort
+(
+        const void *va,
+        const void *vb
+)
+{
+        DxfPendingDrills *a = (DxfPendingDrills *) va;
+        DxfPendingDrills *b = (DxfPendingDrills *) vb;
+
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_drill_sort () function.\n", __FILE__, __LINE__);
+#endif
+        if (a->diam != b->diam) return a->diam - b->diam;
+        if (a->x != b->x) return a->x - a->x;
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_drill_sort () function.\n", __FILE__, __LINE__);
+#endif
+        return b->y - b->y;
+}
+
+/*!
+ * \brief Set the layer with <c>name</c> for DXF export.
+ *
+ * During redraw or print/export cycles, this is called once per layer
+ * (or layer group, for copper layers).\n
+ * If it returns false (zero), the HID does not want that layer, and none of
+ * the drawing functions should be called.\n
+ * If it returns true (nonzero), the items in that layer [group] should be
+ * drawn using the various drawing functions.\n
+ * In addition to the MAX_LAYERS copper layer groups, you may select layers
+ * indicated by the macros SL_* defined, or any others with an index of -1.\n
+ * For copper layer groups, you may pass NULL for name to have a name fetched
+ * from the PCB struct.\n
+ * \n
+ * All copper containing layers are set for DXF export.\n
+ * All assembly layers are set for DXF export.\n
+ * Exceptions are: \n
+ * <ul>
+ * <li>Layers with the name "invisible" are not set for DXF export.
+ * <li>Layers with the name "keepout" are not set for DXF export.
+ * <li>Layers without exportable items are not set for DXF export.
+ * </ul>
+ */
+static int
+dxf_set_layer
+(
+        const char *name,
+        int group,
+        int empty
+)
+{
+        char *cp;
+        int idx = (group >= 0 && group < max_layer) ?
+                PCB->LayerGroups.Entries[group][0] : group;
+
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_set_layer () function.\n",
+                __FILE__, __LINE__);
+#endif
+
+        if (name == 0)
+        {
+                /* if none given, get the layer name from pcb */
+                name = PCB->Data->Layer[idx].Name;
+        }
+        if (dxf_verbose)
+        {
+                fprintf (stderr, "DXF: now processing Layer %s group %d\n", name, group);
+        }
+        if (dxf_export_all_layers)
+        {
+                /* do nothing here to export all layers */
+        }
+        else
+        {
+                if (idx >= 0 && idx < max_layer && !print_layer[idx])
+                {
+                        /* do not export empty layers */
+                        if (dxf_verbose)
+                        {
+                                fprintf (stderr, "DXF: Warning, Layer %s contains no exportable items and is not set.\n", name);
+                                fprintf (stderr, "[File: %s: line: %d] Leaving dxf_set_layer () function.\n", __FILE__, __LINE__);
+                        }
+                        return 0;
+                }
+                if (strcmp (name, "invisible") == 0)
+                {
+                        /* do not export the layer with the name "invisible" */
+                        if (dxf_verbose)
+                        {
+                                fprintf (stderr, "DXF: Warning, Layer %s not set.\n", name);
+                                fprintf (stderr, "[File: %s: line: %d] Leaving dxf_set_layer () function.\n",
+                                        __FILE__, __LINE__);
+                        }
+                        return 0;
+                }
+                if (strcmp (name, "keepout") == 0)
+                {
+                        /* do not export the layer with the name "keepout" */
+                        if (dxf_verbose)
+                        {
+                                fprintf (stderr, "DXF: Warning, Layer %s not set.\n", name);
+                                fprintf (stderr, "[File: %s: line: %d] Leaving dxf_set_layer () function.\n",
+                                        __FILE__, __LINE__);
+                        }
+                        return 0;
+                }
+                if (SL_TYPE (idx) == SL_ASSY)
+                {
+                        /* do not export the layers with the type SL_ASSY */
+                        if (dxf_verbose)
+                        {
+                                fprintf (stderr, "DXF: Warning, Layer %s with type SL_ASSY not set.\n", name);
+                                fprintf (stderr, "[File: %s: line: %d] Leaving dxf_set_layer () function.\n", __FILE__, __LINE__);
+                        }
+                        return 0;
+                }
+        }
+        if (is_drill && dxf_n_pending_drills)
+        {
+                int i;
+                /* dump pending drills in sequence */
+                qsort (dxf_pending_drills, dxf_n_pending_drills,
+                        sizeof (DxfPendingDrills), dxf_drill_sort);
+                for (i = 0; i < dxf_n_pending_drills; i++)
+                {
+                        if (i == 0 || dxf_pending_drills[i].diam != dxf_pending_drills[i - 1].diam)
+                        {
+                                int ap = dxf_find_aperture_code (dxf_pending_drills[i].diam, ROUND);
+                                if (dxf_verbose)
+                                {
+                                        /*!
+                                         * \todo this output should go to file in
+                                         * whatever form instead of being put on stderr.
+                                         */
+                                        fprintf (stderr, "DXF: T%02d\015\012", ap);
+                                }
+                        }
+                        if (dxf_verbose)
+                        {
+                                /*!
+                                 * \todo this output should go to file in
+                                 * whatever form instead of being put on stderr.
+                                 */
+                                fprintf (stderr, "DXF: X:%06ld Y:%06ld\n",
+                                        DXF_X(PCB, dxf_pending_drills[i].x),
+                                        DXF_Y(PCB, dxf_pending_drills[i].y));
+                        }
+                }
+                free (dxf_pending_drills);
+                dxf_n_pending_drills = dxf_max_pending_drills = 0;
+                dxf_pending_drills = 0;
+        }
+        is_drill = (SL_TYPE (idx) == SL_PDRILL || SL_TYPE (idx) == SL_UDRILL);
+        is_mask = (SL_TYPE (idx) == SL_MASK);
+        current_mask = 0;
+        if (group < 0 || group != lastgroup)
+        {
+                time_t currenttime;
+                char utcTime[64];
+#ifdef HAVE_GETPWUID
+                struct passwd *pwentry;
+#endif
+                char *sext = "_layer.dxf";
+                int i;
+                lastgroup = group;
+                dxf_lastX = -1;
+                dxf_lastY = -1;
+                lastcolor = 0;
+                linewidth = -1;
+                lastcap = -1;
+                dxf_set_app_layer (c_layerapps);
+                c_layerapps++;
+                if (finding_apertures)
+                {
+                        return 1;
+                }
+                if (!curapp->nextAperture)
+                {
+                        return 0;
+                }
+                dxf_maybe_close_file ();
+                pagecount++;
+                switch (idx)
+                {
+                        case SL (PDRILL, 0):
+                                sext = ".cnc";
+                                break;
+                        case SL (UDRILL, 0):
+                                sext = ".cnc";
+                                break;
+                }
+                strcpy (dxf_filesuffix, layer_type_to_file_name (idx));
+                strcat (dxf_filesuffix, sext);
+                fp = fopen (dxf_filename, "w");
+                if (fp == NULL)
+                {
+                        Message ("DXF: Error, could not open %s for writing.\n", dxf_filename);
+                        if (dxf_verbose)
+                        {
+                                fprintf (stderr, "DXF: Error, could not open %s for writing.\n", dxf_filename);
+                        }
+                        return 1;
+                }
+                /* write version info as a dxf comment */
+                dxf_write_comment (fp, PCB_DXF_HID_VERSION);
+                /* write dxf header information */
+                dxf_write_header ();
+                /* write a section ENTITIES marker to the DXF file */
+                dxf_write_section (fp, "ENTITIES");
+                was_drill = is_drill;
+                /*!
+                 * \todo this output should go to file in
+                 * whatever form instead of being put on stderr.
+                 */
+                if (dxf_verbose)
+                {
+                        fprintf (stderr, "DXF: %d aperture%s in %s\n",
+                                curapp->nextAperture,
+                                curapp->nextAperture == 1 ? "" : "%s",
+                                dxf_filename);
+                }
+                if (dxf_verbose && is_drill)
+                {
+                        fprintf (stderr, "DXF: List of tool bits" "INCH,TZ\n");
+                        for (i = 0; i < curapp->nextAperture; i++)
+                                fprintf (stderr, "Toolbit #%02d - diam. %.3f\n",
+                                        curapp->aperture[i].dCode,
+                                        curapp->aperture[i].apertureSize / 100000.0);
+                        /*!
+                         * \todo FIXME: probably a decent return code needs to
+                         * be added here.
+                         */
+                        return 1;
+                }
+                if (dxf_verbose)
+                {
+                        fprintf (stderr, "DXF: Start of page %d for group %d idx %d\n",
+                                pagecount, group, idx);
+                }
+                if (group < 0 || group != lastgroup)
+                {
+                        const char *fmt = "%c UTC";
+                        /* create a portable timestamp */
+                        currenttime = time (NULL);
+                        /* avoid gcc complaints */
+                        strftime (utcTime, sizeof utcTime, fmt, gmtime (&currenttime));
+                }
+#ifdef HAVE_GETPWUID
+                /* ID the user */
+                pwentry = getpwuid (getuid ());
+                /*!
+                 * \todo fprintf (stderr, "For: %s \n", pwentry->pw_name);
+                 * doesn't behave properly !
+                 */
+#endif
+                if (dxf_verbose)
+                {
+                        /* report at the beginning of each file */
+                        fprintf (stderr, "DXF: Board Name: %s, %s \n", UNKNOWN (PCB->Name),
+                                UNKNOWN (name));
+                        fprintf (stderr, "DXF: Created by: %s.\n", PCB_DXF_HID_VERSION);
+                        fprintf (stderr, "DXF: Creation date: %s \n", utcTime);
+                        fprintf (stderr, "DXF: File Format according to: AutoCAD R14.\n");
+                        if (dxf_metric)
+                        {
+                                fprintf (stderr, "DXF using Metric coordinates [mm].\n");
+                        }
+                        else
+                        {
+                                fprintf (stderr, "DXF using Imperial coordinates [mil].\n");
+                        }
+                        fprintf (stderr, "PCB Dimensions: %d %d.\n", PCB->MaxWidth,
+                                PCB->MaxHeight);
+                        fprintf (stderr, "PCB Coordinate Origin: lower left.\n");
+                        fprintf (stderr, "DXF: Now processing Layer %s group %d drill %d mask %d\n", name, group,
+                                is_drill, is_mask);
+                }
+                /* build a legal identifier */
+                if (dxf_layername)
+                {
+                        free (dxf_layername);
+                }
+                dxf_layername = strdup (dxf_filesuffix);
+                dxf_layername[strlen (dxf_layername) - strlen (sext)] = 0;
+                /* remove all non-alpha-nummerical characters and change all to upper characters */
+                for (cp = dxf_layername; *cp; cp++)
+                {
+                        if (isalnum ((int) *cp))
+                        {
+                                *cp = toupper (*cp);
+                        }
+                        else
+                        {
+                                *cp = '_';
+                        }
+                }
+                lncount = 1;
+                if (dxf_verbose)
+                {
+                        fprintf (stderr, "DXF: Setting Layer %s.\n", dxf_layername);
+                        fprintf (stderr, "DXF: Aperture Data %s.\n", curapp->appList.Data);
+                }
+        }
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_set_layer () function.\n",
+                __FILE__, __LINE__);
+#endif
+        return 1;
+}
+
+/*!
+ * \brief Constructor for the graphic context.
+ */
+static hidGC
+dxf_make_gc (void)
+{
+        hidGC rv;
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_make_gc () function.\n", __FILE__, __LINE__);
+#endif
+        rv = (hidGC) calloc (1, sizeof (hid_gc_struct));
+        rv->cap = Trace_Cap;
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_make_gc () function.\n", __FILE__, __LINE__);
+#endif
+        return rv;
+}
+
+/*!
+ * \brief Destructor for the graphic context.
+ */
+static void
+dxf_destroy_gc (hidGC gc)
+{
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_destroy_gc () function.\n", __FILE__, __LINE__);
+#endif
+        free (gc);
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_destroy_gc () function.\n", __FILE__, __LINE__);
+#endif
+}
+
+/*!
+ * Special note about the "erase" color: To use this color, you must use this
+ * function to tell the HID when you're using it.\n
+ * At the beginning of a layer redraw cycle (i.e. after set_layer), call
+ * use_mask() to redirect output to a buffer.\n
+ * Draw to the buffer (using regular HID calls) using regular and "erase"
+ * colors.\n
+ * Then call use_mask(HID_MASK_OFF) to flush the buffer to the HID.\n
+ * If you use the "erase" color when use_mask is disabled, it simply draws in
+ * the background color.\n
+ * Values:\n
+ * <ul>
+ *   <li> <c>HID_MASK_OFF == 0 </c> Flush the buffer and return to non-mask operation.
+ *   <li> <c>HID_MASK_BEFORE == 1 </c> Polygons being drawn before clears.
+ *   <li> <c>HID_MASK_CLEAR == 2 </c> Clearances being drawn.
+ *   <li> <c>HID_MASK_AFTER == 3 </c> Polygons being drawn after clears.
+ * </ul>
+ */
+static void
+dxf_use_mask
+(
+        int use_it
+)
+{
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_use_mask () function.\n", __FILE__, __LINE__);
+#endif
+        current_mask = use_it;
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_use_mask () function.\n", __FILE__, __LINE__);
+#endif
+}
+
+/*!
+ * \brief Set a color.
+ *
+ * Set the color of the entity.
+ * Names can be like "red" or "#rrggbb" or special names like "erase".
+ * <b>Always</b> use the "erase" color for removing ink (like polygon reliefs
+ * or thermals), as you cannot rely on knowing the background color or special
+ * needs of the HID.\n
+ * Always use the "drill" color to draw holes.\n
+ * You may assume this is cheap enough to call inside the redraw callback,
+ * but not cheap enough to call for each item drawn.
+ */
+static void
+dxf_set_color
+(
+        hidGC gc, /*!< graphic context  */
+        const char *name
+)
+{
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_set_color () function.\n", __FILE__, __LINE__);
+#endif
+        if (strcmp (name, "erase") == 0)
+        {
+                gc->color = 1;
+                gc->erase = 1;
+                gc->drill = 0;
+        }
+        else if (strcmp (name, "drill") == 0)
+        {
+                gc->color = 1;
+                gc->erase = 0;
+                gc->drill = 1;
+        }
+        else
+        {
+                gc->color = 0;
+                gc->erase = 0;
+                gc->drill = 0;
+        }
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_set_color () function.\n", __FILE__, __LINE__);
+#endif
+}
+
+/*!
+ * \brief Set the line style.
+ *
+ * Set the line cap style in the graphic context.\n
+ * While calling this is cheap, calling it with different values each time
+ * may be expensive, so grouping items by line style is helpful.
+*/
+static void
+dxf_set_line_cap
+(
+        hidGC gc,
+        EndCapStyle style
+)
+{
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_set_line_cap () function.\n", __FILE__, __LINE__);
+#endif
+        gc->cap = style;
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_set_line_cap () function.\n", __FILE__, __LINE__);
+#endif
+}
+
+
+/*!
+ * \brief Set the line width.
+ *
+ * Set the line width in the graphic context.\n
+ * While calling this is cheap, calling it with different values each time
+ * may be expensive, so grouping items by line width is helpful.
+ */
+static void
+dxf_set_line_width
+(
+        hidGC gc,
+        int width
+)
+{
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_set_line_width () function.\n", __FILE__, __LINE__);
+#endif
+        gc->width = width;
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_set_line_width () function.\n", __FILE__, __LINE__);
+#endif
+}
+
+/*!
+ * \brief Use the graphic context.
+ */
+static void
+dxf_use_gc
+(
+        hidGC gc,
+        int radius
+)
+{
+        int c;
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_use_gc () function.\n", __FILE__, __LINE__);
+#endif
+        if (radius)
+        {
+                radius *= 2;
+                if (radius != linewidth || lastcap != Round_Cap)
+                {
+                        c = dxf_find_aperture_code (radius, ROUND);
+                        if (c <= 0)
+                        {
+                                fprintf (stderr, "DXF: Error, aperture for radius %d type ROUND is %d\n", radius, c);
+                        }
+                        if (fp && !is_drill)
+                        {
+                                fprintf (stderr, "DXF: is not a drill %d.\n", c);
+                        }
+                        linewidth = radius;
+                        lastcap = Round_Cap;
+                }
+        }
+        else if (linewidth != gc->width || lastcap != gc->cap)
+        {
+                int ap;
+                linewidth = gc->width;
+                lastcap = gc->cap;
+                switch (gc->cap)
+                {
+                        case Round_Cap:
+                        case Trace_Cap:
+                                c = ROUND;
+                                break;
+                        default:
+                        case Square_Cap:
+                                c = SQUARE;
+                                break;
+                }
+                ap = dxf_find_aperture_code (linewidth, c);
+                if (ap <= 0)
+                {
+                        fprintf (stderr, "DXF: Error, aperture for width %d type %s is %d\n", linewidth, c == ROUND ? "ROUND" : "SQUARE", ap);
+                }
+                if (fp)
+                {
+                        fprintf (stderr, "DXF: aperture %d.\n ", ap);
+                }
+        }
+#if 0
+        if (lastcolor != gc->color)
+        {
+                c = gc->color;
+                if (is_drill) return;
+                if (is_mask) c = (gc->erase ? 0 : 1);
+                lastcolor = gc->color;
+                if (fp)
+                {
+                        if (c)
+                        {
+                                /*!
+                                 * \todo this output should go to file in
+                                 * whatever form instead of being put on stderr.
+                                 */
+                                fprintf (stderr, "%%LN%s_C%d*%%\015\012", layername, lncount++);
+                                fprintf (stderr, "%%LPC*%%\015\012");
+                        }
+                        else
+                        {
+                                fprintf (stderr, "%%LN%s_D%d*%%\015\012", layername, lncount++);
+                                fprintf (stderr, "%%LPD*%%\015\012");
+                        }
+                }
+        }
+#endif
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leavinging dxf_use_gc () function.\n", __FILE__, __LINE__);
+#endif
+}
+
+/*!
+ * \brief Draw a rectangle.
+ *
+ * The usual drawing functions.\n
+ * "draw" means to use segments of the given width, whereas "fill" means to
+ * fill to a zero-width outline.\n
+ * We draw the rectangle counter clockwise (CCW) with 5 vertices
+ * (XY-coordinates).\n
+ * It is assumed that the first XY-coordinate pair (x1, y1) contains the
+ * bottom left corner values and that the second XY-coordinate pair (x2, y2)
+ * contains the top right corner values. \n
+ * The rectangle is not filled, use dxf_fill_rect () for a filled rectangle.
+ */
+static void
+dxf_draw_rect
+(
+        hidGC gc, /*!< graphic context  */
+        int x1, /*!< X-value bottom left ?? point  */
+        int y1, /*!< Y-value bottom left ?? point  */
+        int x2, /*!< X-value top right ?? point  */
+        int y2 /*!< Y-value top right ?? point  */
+)
+{
+        int dxf_color;
+        double dxf_x0;
+        double dxf_y0;
+        double dxf_x1;
+        double dxf_y1;
+        double dxf_x2;
+        double dxf_y2;
+        double dxf_x3;
+        double dxf_y3;
+        double dxf_width;
+
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_draw_rect () function.\n", __FILE__, __LINE__);
+#endif
+
+        /*
+         * return if no valid file pointer exists.
+         */
+        if (!fp)
+        {
+                fprintf (stderr, "Warning: no valid file pointer exists.\n");
+                return;
+        }
+        if ((x1 == x2) && (y1 == y2))
+        {
+                fprintf (stderr, "Warning: start point and end point are identical for the entity with id-code: %x\n", dxf_id_code);
+                fprintf (stderr, "         entity is discarded from output.\n");
+                return;
+        }
+        dxf_width = (double) gc->width;
+        if (dxf_color_is_byblock)
+        {
+                dxf_color = DXF_COLOR_BYBLOCK;
+        }
+        else dxf_color = gc->color;
+        dxf_x0 = DXF_X(PCB, x1);
+        dxf_y0 = DXF_Y(PCB, y1);
+        dxf_x1 = DXF_X(PCB, x2);
+        dxf_y1 = DXF_Y(PCB, y1);
+        dxf_x2 = DXF_X(PCB, x1);
+        dxf_y2 = DXF_Y(PCB, y2);
+        dxf_x3 = DXF_X(PCB, x2);
+        dxf_y3 = DXF_Y(PCB, y2);
+        /*
+         * write polyline sequence.
+         */
+        dxf_write_polyline
+        (
+                fp,
+                dxf_id_code,
+                DXF_DEFAULT_LINETYPE, /* linetype, */
+                DXF_DEFAULT_LAYER, /* layer, */
+                0.0, /* x0, */ /* the polyline entity <b>always</b> remains on 0.0, 0.0, 0.0  */
+                0.0, /* y0, */
+                0.0, /* z0, */
+                0.0, /* extr_x0, */ /* the polyline extrusion vector <b>always</b> is 0.0, 0.0, 1.0  */
+                0.0, /* extr_y0, */
+                1.0, /* extr_z0, */
+                0.0, /* thickness, */ /* copper weight ??  */
+                dxf_width,
+                dxf_width,
+                dxf_color, /* color, */
+                1, /* vertices_follow, */
+                0, /* modelspace, */
+                0, /* flag, */
+                0, /* polygon_mesh_M_vertex_count, */
+                0, /* polygon_mesh_N_vertex_count, */
+                0, /* smooth_M_surface_density, */
+                0, /* smooth_N_surface_density, */
+                0 /* surface_type */
+        );
+        dxf_id_code++;
+        /*
+         * write first XY-coordinate (base point, bottom left corner).
+         */
+        dxf_write_vertex
+        (
+                fp,
+                dxf_id_code,
+                DXF_DEFAULT_LINETYPE, /* linetype, */
+                DXF_DEFAULT_LAYER, /* layer, */
+                dxf_x0,
+                dxf_y0,
+                0.0, /* z0, */ /* stacked, curved or flexable pcb's ??  */
+                0.0, /* thickness, */ /* copper weight ??  */
+                dxf_width,
+                dxf_width,
+                0.0, /* bulge, */
+                0.0, /* curve_fit_tangent_direction, */
+                dxf_color,
+                0, /* modelspace, */
+                0 /* flag */
+        );
+        dxf_id_code++;
+        /*
+         * write second XY-coordinate (bottom right corner).
+         */
+        dxf_write_vertex
+        (
+                fp,
+                dxf_id_code,
+                DXF_DEFAULT_LINETYPE, /* linetype, */
+                DXF_DEFAULT_LAYER, /* layer, */
+                dxf_x1,
+                dxf_y0,
+                0.0, /* z0, */ /* stacked, curved or flexable pcb's ??  */
+                0.0, /* thickness, */ /* copper weight ??  */
+                dxf_width,
+                dxf_width,
+                0.0, /* bulge, */
+                0.0, /* curve_fit_tangent_direction, */
+                dxf_color,
+                0, /* modelspace, */
+                0 /* flag */
+        );
+        dxf_id_code++;
+        /*
+         * write third XY-coordinate (top right left corner).
+         */
+        dxf_write_vertex
+        (
+                fp,
+                dxf_id_code,
+                DXF_DEFAULT_LINETYPE, /* linetype, */
+                DXF_DEFAULT_LAYER, /* layer, */
+                dxf_x1,
+                dxf_y1,
+                0.0, /* z0, */ /* stacked, curved or flexable pcb's ??  */
+                0.0, /* thickness, */ /* copper weight ??  */
+                dxf_width,
+                dxf_width,
+                0.0, /* bulge, */
+                0.0, /* curve_fit_tangent_direction, */
+                dxf_color,
+                0, /* modelspace, */
+                0 /* flag */
+        );
+        dxf_id_code++;
+        /*
+         * write fourth XY-coordinate (top left corner).
+         */
+        dxf_write_vertex
+        (
+                fp,
+                dxf_id_code,
+                DXF_DEFAULT_LINETYPE, /* linetype, */
+                DXF_DEFAULT_LAYER, /* layer, */
+                dxf_x0,
+                dxf_y1,
+                0.0, /* z0, */ /* stacked, curved or flexable pcb's ??  */
+                0.0, /* thickness, */ /* copper weight ??  */
+                dxf_width,
+                dxf_width,
+                0.0, /* bulge, */
+                0.0, /* curve_fit_tangent_direction, */
+                dxf_color,
+                0, /* modelspace, */
+                0 /* flag */
+        );
+        dxf_id_code++;
+        /*
+         * write fifth XY-coordinate (again the bottom left corner, to close
+         * the rectangle).
+         */
+        dxf_write_vertex
+        (
+                fp,
+                dxf_id_code,
+                DXF_DEFAULT_LINETYPE, /* linetype, */
+                DXF_DEFAULT_LAYER, /* layer, */
+                dxf_x0,
+                dxf_y0,
+                0.0, /* z0, */ /* stacked, curved or flexable pcb's ??  */
+                0.0, /* thickness, */ /* copper weight ??  */
+                dxf_width,
+                dxf_width,
+                0.0, /* bulge, */
+                0.0, /* curve_fit_tangent_direction, */
+                dxf_color,
+                0, /* modelspace, */
+                0 /* flag */
+        );
+        dxf_id_code++;
+        /*
+         * end of polyline sequence.
+         */
+        dxf_write_endseq (fp);
+        dxf_lastX = dxf_x1;
+        dxf_lastY = dxf_y1;
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_draw_rect () function.\n", __FILE__, __LINE__);
+#endif
+}
+
+
+/*!
+ * \brief Draw a line.
+ *
+ * The usual drawing functions.\n
+ * "draw" means to use segments of the given width, whereas "fill" means to
+ * fill to a zero-width outline.\n
+ * Translate the pcb X,Y-coordinates of lines and trace segments to dxf
+ * X,Y,Z-coordinates.\n
+ * Add layer, linetype, color and width values.\n
+ * Write a series of polylines and vertices by calling low level functions.\n
+ * If the endcap style is ROUND add a donut at the begin and end coordinates
+ * of the line segment.\n
+ * If the endcap style is SQUARE elongate the line segment with half its
+ * width.\n
+ * Remarks:\n
+ * <ul>
+ * <li>We do not draw lines of 1 mil wide or smaller.\n
+ * <li>We do not draw lines with identical start and end XY-coordinates (zero
+ * length).\n
+ * <li>We draw every trace segment as a single AutoCAD entity (polyline).\n
+ * </ul>
+ *
+ * \todo In case of a series of trace segments, we have to continue with a
+ * vertex from the last XY-coordinates.\n
+ * While the conditions for starting or continuing are simple to determine:\n
+ * <c>if ((dxf_x1, dxf_y1) == dxf_lastX, dxf_lastY)) ... </c>\n
+ * The caveat is how to determine when to close the polyline sequence
+ * (with an ENDSEQ marker) after the last vertex (endpoint of the last trace
+ * segment).\n
+ * One approach could be to close the series when the start coordinates of the
+ * new (to be drawn) trace segment do not coincide with the endpoint of the
+ * previously used trace segment (dxf_last[X. Y] values).\n
+ * This however would not be a solution for a branching trace segment or the
+ * last trace segment to be drawn on that particular layer.\n
+ * For the last trace segment to be drawn on a particular layer, we would have
+ * to check if the layer didn't change since the last trace segment was
+ * drawn.\n
+ */
+static void
+dxf_draw_line
+(
+        hidGC gc, /*!< graphic context  */
+        int x1, /*!< X-value start point  */
+        int y1, /*!< Y-value start point  */
+        int x2, /*!< X-value end point  */
+        int y2 /*!< Y-value end point  */
+)
+{
+        Boolean m = False;
+        double dxf_x0; /* start point */
+        double dxf_y0; /* start point */
+        double dxf_x1; /* end point */
+        double dxf_y1; /* end point */
+        double dxf_width; /* trace width */
+        int dxf_color;
+
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_draw_line () function.\n", __FILE__, __LINE__);
+#endif
+
+        if (!fp)
+        {
+                /* return if no valid file pointer exists */
+                fprintf (stderr, "Warning: no valid file pointer exists.\n");
+                return;
+        }
+        if (gc->width == 1)
+        {
+                /* we do not draw 1 mil width traces */
+                fprintf (stderr, "Warning: lines with a width == 1 mil will not be drawn.\n");
+                fprintf (stderr, "         entity is discarded from output.\n");
+                return;
+        }
+        if ((x1 == x2) && (y1 == y2))
+        {
+                /* we do not draw zero length traces */
+                fprintf (stderr, "Warning: start point and end point are identical for the entity with id-code: %x.\n", dxf_id_code);
+                fprintf (stderr, "         entity is discarded from output.\n");
+                return;
+        }
+        dxf_use_gc (gc, 0);
+        /* determine the polyline widths */
+        if (dxf_metric)
+        {
+                dxf_width = MIL_TO_MM * (double) gc->width;
+        }
+        else
+        {
+                dxf_width = (double) gc->width;
+        }
+        /* determine polyline color */
+        if (dxf_color_is_byblock)
+        {
+                dxf_color = DXF_COLOR_BYBLOCK;
+        }
+        else dxf_color = gc->color;
+        /*
+         * determine start and end point X,Y-values w.r.t. metric or imperial.
+         */
+        if (dxf_metric)
+        {
+                dxf_x0 = MIL_TO_MM * DXF_X(PCB, x1);
+                dxf_y0 = MIL_TO_MM * DXF_Y(PCB, y1);
+                dxf_x1 = MIL_TO_MM * DXF_X(PCB, x2);
+                dxf_y1 = MIL_TO_MM * DXF_Y(PCB, y2);
+        }
+        else
+        {
+                dxf_x0 = DXF_X(PCB, x1);
+                dxf_y0 = DXF_Y(PCB, y1);
+                dxf_x1 = DXF_X(PCB, x2);
+                dxf_y1 = DXF_Y(PCB, y2);
+        }
+        /*!
+         * \todo Someday we have to do something here with multiple trace
+         * segments here, the problem for now is how to determine when the
+         * last trace segment was passed.
+         */
+        if ((dxf_x0 == dxf_lastX) && (dxf_y0 == dxf_lastY))
+        {
+                m = True;
+        }
+        /*
+         * This is just a dirty hack for AutoCAD doesn't have endcap styles.
+         * Donuts can not be implementend in the trace polyline since donuts
+         * are a closed polyline themselves.
+         */
+        if (gc->cap == ROUND)
+        {
+                /* place a donut at the start of the trace segment */
+                dxf_write_polyline
+                (
+                        fp,
+                        dxf_id_code,
+                        DXF_DEFAULT_LINETYPE, /* linetype, */
+                        DXF_DEFAULT_LAYER, /* layer, */
+                        0.0, /* x0, */
+                        0.0, /* y0, */
+                        0.0, /* z0, */
+                        0.0, /* extr_x0, */
+                        0.0, /* extr_y0, */
+                        1.0, /* extr_z0, */
+                        0.0, /* thickness, copper weight ??  */
+                        0.5 * dxf_width,
+                        0.5 * dxf_width,
+                        dxf_color, /* color, */
+                        1, /* vertices_follow, */
+                        0, /* modelspace, */
+                        1, /* flag, */
+                        0, /* polygon_mesh_M_vertex_count, */
+                        0, /* polygon_mesh_N_vertex_count, */
+                        0, /* smooth_M_surface_density, */
+                        0, /* smooth_N_surface_density, */
+                        0 /* surface_type */
+                );
+                dxf_id_code++;
+                /*
+                 * write first XY-coordinate (at the start of trace segment).
+                 */
+                dxf_write_vertex
+                (
+                        fp,
+                        dxf_id_code,
+                        DXF_DEFAULT_LINETYPE, /* linetype, */
+                        DXF_DEFAULT_LAYER, /* layer, */
+                        dxf_x0 - (0.25 * dxf_width),
+                        dxf_y0,
+                        0.0, /* z0, */ /* stacked, curved or flexable pcb's ?? */
+                        0.0, /* thickness, */ /* copper weight ?? */
+                        0.5 * dxf_width,
+                        0.5 * dxf_width,
+                        1.0, /* bulge, */
+                        0.0, /* curve_fit_tangent_direction, */
+                        dxf_color,
+                        0, /* modelspace, */
+                        0 /* flag */
+                );
+                dxf_id_code++;
+                /*
+                 * write second XY-coordinate (at the start of trace segment).
+                 */
+                dxf_write_vertex
+                (
+                        fp,
+                        dxf_id_code,
+                        DXF_DEFAULT_LINETYPE, /* linetype, */
+                        DXF_DEFAULT_LAYER, /* layer, */
+                        dxf_x0 + (0.25 * dxf_width),
+                        dxf_y0,
+                        0.0, /* z0, */ /* stacked, curved or flexable pcb's ??  */
+                        0.0, /* thickness, */ /* copper weight ?? */
+                        0.5 * dxf_width,
+                        0.5 * dxf_width,
+                        1.0, /* bulge, */
+                        0.0, /* curve_fit_tangent_direction, */
+                        dxf_color,
+                        0, /* modelspace, */
+                        0 /* flag */
+                );
+                dxf_id_code++;
+                /* write the end of polyline sequence marker */
+                dxf_write_endseq (fp);
+                /* place a donut at the end of the trace segment */
+                dxf_write_polyline
+                (
+                        fp,
+                        dxf_id_code,
+                        DXF_DEFAULT_LINETYPE, /* linetype, */
+                        DXF_DEFAULT_LAYER, /* layer, */
+                        0.0, /* x0, */
+                        0.0, /* y0, */
+                        0.0, /* z0, */
+                        0.0, /* extr_x0, */
+                        0.0, /* extr_y0, */
+                        1.0, /* extr_z0, */
+                        0.0, /* thickness, */ /* copper weight ?? */
+                        0.5 * dxf_width,
+                        0.5 * dxf_width,
+                        dxf_color, /* color, */
+                        1, /* vertices_follow, */
+                        0, /* modelspace, */
+                        1, /* flag, */
+                        0, /* polygon_mesh_M_vertex_count, */
+                        0, /* polygon_mesh_N_vertex_count, */
+                        0, /* smooth_M_surface_density, */
+                        0, /* smooth_N_surface_density, */
+                        0 /* surface_type */
+                );
+                dxf_id_code++;
+                /*
+                 * write first XY-coordinate (at the end of trace segment).
+                 */
+                dxf_write_vertex
+                (
+                        fp,
+                        dxf_id_code,
+                        DXF_DEFAULT_LINETYPE, /* linetype, */
+                        DXF_DEFAULT_LAYER, /* layer, */
+                        dxf_x1 - (0.25 * dxf_width),
+                        dxf_y1,
+                        0.0, /* z0, */ /* stacked, curved or flexable pcb's ?? */
+                        0.0, /* thickness, */ /* copper weight ??  */
+                        0.5 * dxf_width,
+                        0.5 * dxf_width,
+                        1.0, /* bulge, */
+                        0.0, /* curve_fit_tangent_direction, */
+                        dxf_color,
+                        0, /* modelspace, */
+                        0 /* flag */
+                );
+                dxf_id_code++;
+                /*
+                 * write second XY-coordinate (at the end of trace segment).
+                 */
+                dxf_write_vertex
+                (
+                        fp,
+                        dxf_id_code,
+                        DXF_DEFAULT_LINETYPE, /* linetype, */
+                        DXF_DEFAULT_LAYER, /* layer, */
+                        dxf_x1 + (0.25 * dxf_width),
+                        dxf_y1,
+                        0.0, /* z0, */ /* stacked, curved or flexable pcb's ??  */
+                        0.0, /* thickness, */ /* copper weight ??  */
+                        0.5 * dxf_width,
+                        0.5 * dxf_width,
+                        1.0, /* bulge, */
+                        0.0, /* curve_fit_tangent_direction, */
+                        dxf_color,
+                        0, /* modelspace, */
+                        0 /* flag */
+                );
+                dxf_id_code++;
+                /*
+                 * write the end of polyline sequence marker.
+                 */
+                dxf_write_endseq (fp);
+        }
+        /* if the end cap style is an OCTAGON: ?? */
+        if (gc->cap == OCTAGON)
+        {
+                /*!
+                 * \todo This end cap style has yet to be implemented at the
+                 * start and end point of a trace.
+                 * Note: done for ROUND and SQUARE.
+                 */
+        }
+        /*
+         * if the end cap style is SQUARE: recompute the start and end
+         * coordinates, that is, elongate the trace with half of the width.
+         */
+        if (gc->cap == SQUARE)
+        {
+                double length; /* trace length */
+                double dxf_x0_1; /* extended start point */
+                double dxf_y0_1; /* extended start point */
+                double dxf_x1_1; /* extended end point */
+                double dxf_y1_1; /* extended end point */
+                length = sqrt ((dxf_y1 - dxf_y0) * (dxf_y1 - dxf_y0) +
+                        (dxf_x1 - dxf_x0) * (dxf_x1 - dxf_x0));
+                dxf_x0_1 = dxf_x0 - ((dxf_x1 - dxf_x0) / length) * 0.5 * dxf_width;
+                dxf_y0_1 = dxf_y0 - ((dxf_y1 - dxf_y0) / length) * 0.5 * dxf_width;
+                dxf_x1_1 = dxf_x1 + ((dxf_x1 - dxf_x0) / length) * 0.5 * dxf_width;
+                dxf_y1_1 = dxf_y1 + ((dxf_y1 - dxf_y0) / length) * 0.5 * dxf_width;
+                dxf_x0 = dxf_x0_1;
+                dxf_y0 = dxf_y0_1;
+                dxf_x1 = dxf_x1_1;
+                dxf_y1 = dxf_y1_1;
+        }
+        /* write polyline sequence for the trace */
+        dxf_write_polyline
+        (
+                fp,
+                dxf_id_code,
+                DXF_DEFAULT_LINETYPE, /* linetype, */
+                DXF_DEFAULT_LAYER, /* layer, */
+                0.0, /* x0, */
+                0.0, /* y0, */
+                0.0, /* z0, */
+                0.0, /* extr_x0, */
+                0.0, /* extr_y0, */
+                1.0, /* extr_z0, */
+                0.0, /* thickness, */ /* copper weight ?? */
+                dxf_width,
+                dxf_width,
+                dxf_color, /* color, */
+                1, /* vertices_follow, */
+                0, /* modelspace, */
+                0, /* flag, */
+                0, /* polygon_mesh_M_vertex_count, */
+                0, /* polygon_mesh_N_vertex_count, */
+                0, /* smooth_M_surface_density, */
+                0, /* smooth_N_surface_density, */
+                0 /* surface_type */
+        );
+        dxf_id_code++;
+        /* write first XY-coordinate (start of trace segment) */
+        dxf_write_vertex
+        (
+                fp,
+                dxf_id_code,
+                DXF_DEFAULT_LINETYPE, /* linetype, */
+                DXF_DEFAULT_LAYER, /* layer, */
+                dxf_x0,
+                dxf_y0,
+                0.0, /* z0, */ /* stacked, curved or flexable pcb's ??  */
+                0.0, /* thickness, */ /* copper weight ??  */
+                dxf_width,
+                dxf_width,
+                0.0, /* bulge, */
+                0.0, /* curve_fit_tangent_direction, */
+                dxf_color,
+                0, /* modelspace, */
+                0 /* flag */
+        );
+        dxf_id_code++;
+        /* write second XY-coordinate (end of trace segment) */
+        dxf_write_vertex
+        (
+                fp,
+                dxf_id_code,
+                DXF_DEFAULT_LINETYPE, /* linetype, */
+                DXF_DEFAULT_LAYER, /* layer, */
+                dxf_x1,
+                dxf_y1,
+                0.0, /* z0, */ /* stacked, curved or flexable pcb's ??  */
+                0.0, /* thickness, */ /* copper weight ??  */
+                dxf_width,
+                dxf_width,
+                0.0, /* bulge, */
+                0.0, /* curve_fit_tangent_direction, */
+                dxf_color,
+                0, /* modelspace, */
+                0 /* flag */
+        );
+        dxf_id_code++;
+        /* write the end of polyline sequence marker */
+        dxf_write_endseq (fp);
+        dxf_lastX = dxf_x1;
+        dxf_lastY = dxf_y1;
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_draw_line () function.\n", __FILE__, __LINE__);
+#endif
+}
+
+
+/*!
+ * \brief Draw an (elliptic ?) arc.
+ *
+ * The usual drawing functions.\n
+ * "draw" means to use segments of the given width, whereas "fill" means to
+ * fill to a zero-width outline.\n
+ * For now we draw an (elliptic) arc with the assumption that the width is
+ * along the X-axis and the height is along the Y-axis.\n
+ * Thus the major axis of the ellipse has a size of 2 * the maximum of the
+ * greatest value of [width, height], and the minor axis has a size of 2 * the
+ * minimum value of [width, height].\n
+ * An elliptic arc with a line width of 0 is implemented for now.
+ *
+ * \todo The elliptic arc entity has to be replaced by a polyline with the
+ * correct line width (trace width).
+ * \todo In the case of a series of trace segments, continue with a vertex
+ * from the last XY-coordinates.\n
+ * While the conditions for starting or continuing are simple to determine:\n
+ * <c>if ((x1, y1) == dxf_lastX, dxf_lastY)) ... </c> \n
+ * The caveat is how to determine when to close the polyline sequence (with
+ * an ENDSEQ marker) after the last vertex (endpoint of the last trace
+ * segment).\n
+ * \todo The end cap style has to be implemented at the start and end point of
+ * a trace.
+ */
+static void
+dxf_draw_arc
+(
+        hidGC gc, /*!< graphic context  */
+        int cx, /*!< X-value center point  */
+        int cy, /*!< X-value center point  */
+        int width, /*!< length of major axis  */
+        int height, /*!< length of minor axis  */
+        int start_angle, /*!< start angle of elliptic arc  */
+        int delta_angle /*!< relative angle to end angle  */
+)
+{
+#if 0
+        Boolean m = False;
+#endif
+        float arcStartX;
+        float arcStopX;
+        float arcStartY;
+        float arcStopY;
+        double dxf_x0; /* center point */
+        double dxf_y0; /* center point */
+        double dxf_x1; /* end point major axis */
+        double dxf_y1; /* end point major axis */
+        double dxf_arcstart_x;
+        double dxf_arcstart_y;
+        double dxf_arcstop_x;
+        double dxf_arcstop_y;
+        double dxf_width; /* arc width */
+        double dxf_height; /* arc height */
+        double dxf_ratio;
+        double dxf_start_angle;
+        double dxf_end_angle;
+        int dxf_color;
+
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_draw_arc () function.\n", __FILE__, __LINE__);
+#endif
+
+        if (!fp)
+        {
+                /* return if no valid file pointer exists */
+                fprintf (stderr, "Warning: no valid file pointer exists.\n");
+                return;
+        }
+        if (gc->width == 0)
+        {
+                /* we do not draw 0 mil wide traces */
+                fprintf (stderr, "Warning: arcs with a width == 0 mil will not be drawn.\n");
+                fprintf (stderr, "         entity is discarded from output.\n");
+                return;
+        }
+        dxf_use_gc (gc, 0);
+        arcStartX = cx - width * cos (TO_RADIANS (start_angle));
+        arcStartY = cy + height * sin (TO_RADIANS (start_angle));
+        arcStopX = cx - width * cos (TO_RADIANS (start_angle + delta_angle));
+        arcStopY = cy + height * sin (TO_RADIANS (start_angle + delta_angle));
+        if (dxf_metric)
+        {
+                /* use metric (mm) */
+                dxf_x0 = MIL_TO_MM * DXF_X(PCB, cx);
+                dxf_y0 = MIL_TO_MM * DXF_Y(PCB, cy);
+                dxf_width = MIL_TO_MM * DXF_X(PCB, width);
+                dxf_height = MIL_TO_MM * DXF_X(PCB, height);
+                if (dxf_width > dxf_height)
+                {
+                        /*
+                         * the major axis of the ellipse coincides with the
+                         * X-axis.
+                         */
+                        dxf_x1 = MIL_TO_MM * DXF_X(PCB, (cx + width));
+                        dxf_y1 = MIL_TO_MM * DXF_Y(PCB, cy);
+                        /*
+                         * the dxf_ratio is the minor axis length over major
+                         * axis length, and is always <= 1.0
+                         */
+                        dxf_ratio = dxf_height / dxf_width;
+                }
+                else
+                {
+                        /*
+                         * the major axis of the ellipse coincides with the
+                         * Y-axis.
+                         */
+                        dxf_x1 = MIL_TO_MM * DXF_X(PCB, cx);
+                        dxf_y1 = MIL_TO_MM * DXF_Y(PCB, (cy + height));
+                        /*
+                         * the dxf_ratio is the minor axis length over major
+                         * axis length, and is always <= 1.0
+                         */
+                        dxf_ratio = dxf_width / dxf_height;
+                }
+        }
+        else
+        {
+                /* use imperial (mil) */
+                dxf_x0 = DXF_X(PCB, cx);
+                dxf_y0 = DXF_Y(PCB, cy);
+                dxf_width = DXF_X(PCB, width);
+                dxf_height = DXF_Y(PCB, height);
+                if (dxf_width > dxf_height)
+                {
+                        /*
+                         * the major axis of the ellipse coincides with the
+                         * X-axis.
+                         */
+                        dxf_x1 = DXF_X(PCB, (cx + width));
+                        dxf_y1 = DXF_Y(PCB, cy);
+                        /*
+                         * the dxf_ratio is the minor axis length over major
+                         * axis length, and is always <= 1.0
+                         */
+                        dxf_ratio = dxf_height / dxf_width;
+                }
+                else
+                {
+                        /*
+                         * the major axis of the ellipse coincides with the
+                         * Y-axis.
+                         */
+                        dxf_x1 = DXF_X(PCB, cx);
+                        dxf_y1 = DXF_Y(PCB, (cy + height));
+                        /*
+                         * the dxf_ratio is the minor axis length over major
+                         * axis length, and is always <= 1.0
+                         */
+                        dxf_ratio = dxf_width / dxf_height;
+                }
+        }
+        /*
+         * we have to add 180 degrees for start_angle and end_angle because
+         * in the pcb universe 0 degrees (the negative X-axis) is to the left,
+         * and in the dxf universe 0 degrees is to the right.
+         */
+        dxf_start_angle = TO_RADIANS (start_angle + 180);
+        dxf_end_angle = TO_RADIANS (start_angle + delta_angle + 180);
+        if (dxf_start_angle >= (2 * M_PI))
+        {
+                dxf_start_angle = dxf_start_angle - (2 * M_PI);
+        }
+        if (dxf_end_angle >= (2 * M_PI))
+        {
+                dxf_end_angle = dxf_end_angle - (2 * M_PI);
+        }
+        if (dxf_color_is_byblock)
+        {
+                dxf_color = DXF_COLOR_BYBLOCK;
+        }
+        else dxf_color = gc->color;
+        /*
+         * This is just a dirty hack for AutoCAD doesn't have endcap styles.
+         * Donuts can not be implementend in the trace polyline since donuts
+         * are a closed polyline themselves.
+         */
+        if (gc->cap == ROUND)
+        {
+                /* place a donut at the start of the trace segment */
+                dxf_write_polyline
+                (
+                        fp,
+                        dxf_id_code,
+                        DXF_DEFAULT_LINETYPE, /* linetype, */
+                        DXF_DEFAULT_LAYER, /* layer, */
+                        0.0, /* x0, */
+                        0.0, /* y0, */
+                        0.0, /* z0, */
+                        0.0, /* extr_x0, */
+                        0.0, /* extr_y0, */
+                        1.0, /* extr_z0, */
+                        0.0, /* thickness, */ /* copper weight ?? */
+                        0.5 * dxf_width,
+                        0.5 * dxf_width,
+                        dxf_color, /* color, */
+                        1, /* vertices_follow, */
+                        0, /* modelspace, */
+                        1, /* flag, */
+                        0, /* polygon_mesh_M_vertex_count, */
+                        0, /* polygon_mesh_N_vertex_count, */
+                        0, /* smooth_M_surface_density, */
+                        0, /* smooth_N_surface_density, */
+                        0 /* surface_type */
+                );
+                dxf_id_code++;
+                /*
+                 * write first XY-coordinate (at the start of trace segment).
+                 */
+                dxf_write_vertex
+                (
+                        fp,
+                        dxf_id_code,
+                        DXF_DEFAULT_LINETYPE, /* linetype, */
+                        DXF_DEFAULT_LAYER, /* layer, */
+                        dxf_arcstart_x - (0.25 * dxf_width),
+                        dxf_arcstart_y,
+                        0.0, /* z0, */ /* stacked, curved or flexable pcb's ?? */
+                        0.0, /* thickness, */ /* copper weight ?? */
+                        0.5 * dxf_width,
+                        0.5 * dxf_width,
+                        1.0, /* bulge, */
+                        0.0, /* curve_fit_tangent_direction, */
+                        dxf_color,
+                        0, /* modelspace, */
+                        0 /* flag */
+                );
+                dxf_id_code++;
+                /*
+                 * write second XY-coordinate (at the start of trace segment).
+                 */
+                dxf_write_vertex
+                (
+                        fp,
+                        dxf_id_code,
+                        DXF_DEFAULT_LINETYPE, /* linetype, */
+                        DXF_DEFAULT_LAYER, /* layer, */
+                        dxf_arcstart_x + (0.25 * dxf_width),
+                        dxf_arcstart_y,
+                        0.0, /* z0, */ /* stacked, curved or flexable pcb's ?? */
+                        0.0, /* thickness, */ /* copper weight ?? */
+                        0.5 * dxf_width,
+                        0.5 * dxf_width,
+                        1.0, /* bulge, */
+                        0.0, /* curve_fit_tangent_direction, */
+                        dxf_color,
+                        0, /* modelspace, */
+                        0 /* flag */
+                );
+                dxf_id_code++;
+                /*
+                 * write the end of polyline sequence marker.
+                 */
+                dxf_write_endseq (fp);
+                /*
+                 * place a donut at the end of the trace segment.
+                 */
+                dxf_write_polyline
+                (
+                        fp,
+                        dxf_id_code,
+                        DXF_DEFAULT_LINETYPE, /* linetype, */
+                        DXF_DEFAULT_LAYER, /* layer, */
+                        0.0, /* x0, */
+                        0.0, /* y0, */
+                        0.0, /* z0, */
+                        0.0, /* extr_x0, */
+                        0.0, /* extr_y0, */
+                        1.0, /* extr_z0, */
+                        0.0, /* thickness, */ /* copper weight ?? */
+                        0.5 * dxf_width,
+                        0.5 * dxf_width,
+                        dxf_color, /* color, */
+                        1, /* vertices_follow, */
+                        0, /* modelspace, */
+                        1, /* flag, */
+                        0, /* polygon_mesh_M_vertex_count, */
+                        0, /* polygon_mesh_N_vertex_count, */
+                        0, /* smooth_M_surface_density, */
+                        0, /* smooth_N_surface_density, */
+                        0 /* surface_type */
+                );
+                dxf_id_code++;
+                /*
+                 * write first XY-coordinate (at the end of trace segment).
+                 */
+                dxf_write_vertex
+                (
+                        fp,
+                        dxf_id_code,
+                        DXF_DEFAULT_LINETYPE, /* linetype, */
+                        DXF_DEFAULT_LAYER, /* layer, */
+                        dxf_arcstop_x - (0.25 * dxf_width),
+                        dxf_arcstop_y,
+                        0.0, /* z0, */ /* stacked, curved or flexable pcb's ?? */
+                        0.0, /* thickness, */ /* copper weight ?? */
+                        0.5 * dxf_width,
+                        0.5 * dxf_width,
+                        1.0, /* bulge, */
+                        0.0, /* curve_fit_tangent_direction, */
+                        dxf_color,
+                        0, /* modelspace, */
+                        0 /* flag */
+                );
+                dxf_id_code++;
+                /*
+                 * write second XY-coordinate (at the end of trace segment).
+                 */
+                dxf_write_vertex
+                (
+                        fp,
+                        dxf_id_code,
+                        DXF_DEFAULT_LINETYPE, /* linetype, */
+                        DXF_DEFAULT_LAYER, /* layer, */
+                        dxf_arcstop_x + (0.25 * dxf_width),
+                        dxf_arcstop_y,
+                        0.0, /* z0, */ /* stacked, curved or flexable pcb's ?? */
+                        0.0, /* thickness, */ /* copper weight ?? */
+                        0.5 * dxf_width,
+                        0.5 * dxf_width,
+                        1.0, /* bulge, */
+                        0.0, /* curve_fit_tangent_direction, */
+                        dxf_color,
+                        0, /* modelspace, */
+                        0 /* flag */
+                );
+                dxf_id_code++;
+                /*
+                 * write the end of polyline sequence marker.
+                 */
+                dxf_write_endseq (fp);
+        }
+        /*
+         * write an ellipse for the trace.
+         */
+        dxf_write_ellipse
+        (
+                fp,
+                dxf_id_code,
+                DXF_DEFAULT_LINETYPE, /* linetype, */
+                DXF_DEFAULT_LAYER, /* layer, */
+                dxf_x0,
+                dxf_y0,
+                0.0, /* z0, */
+                dxf_x1,
+                dxf_y1,
+                0.0, /* z1, */ /* stacked, curved or flexable pcb's ?? */
+                0.0, /* dxf_extr_x0, */
+                0.0, /* dxf_extr_y0, */
+                1.0, /* dxf_extr_z0, */
+                0.0, /* thickness, */ /* copper weight ?? */
+                dxf_ratio,
+                dxf_start_angle,
+                dxf_end_angle,
+                dxf_color,
+                0 /* modelspace */
+        );
+        dxf_id_code++;
+        dxf_lastX = arcStopX;
+        dxf_lastY = arcStopY;
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_draw_arc () function.\n", __FILE__, __LINE__);
+#endif
+}
+
+
+/*!
+ * \brief Draw a filled circle.
+ *
+ * The usual drawing functions.\n
+ * "draw" means to use segments of the given width, whereas "fill" means to
+ * fill to a zero-width outline.\n
+ * \todo Implement a donut (polyline) instead of a circle.
+ */
+static void
+dxf_fill_circle
+(
+        hidGC gc, /*!< graphic context  */
+        int cx, /*!< X-value center point  */
+        int cy, /*!< Y-value center point  */
+        int radius /*!< radius of circle  */
+)
+{
+          double dxf_x0;
+        double dxf_y0;
+        double dxf_radius;
+        int dxf_color;
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_fill_circle () function.\n", __FILE__, __LINE__);
+#endif
+        /*
+         * return if no valid file pointer exists.
+         */
+        if (!fp)
+        {
+                fprintf (stderr, "Warning: no valid file pointer exists.\n");
+                return;
+        }
+        /*
+         * drill sizes increase per 2 mil ?
+         */
+        if (is_drill)
+        {
+                radius = DXF_ROUND(radius*2) / 2;
+        }
+        dxf_use_gc (gc, radius);
+        if (is_drill)
+        {
+                if (dxf_n_pending_drills >= dxf_max_pending_drills)
+                {
+                        dxf_max_pending_drills += 100;
+                        /*
+                         * re-allocate for another 100 pending drills.
+                         */
+                        dxf_pending_drills = (DxfPendingDrills *) realloc (dxf_pending_drills, dxf_max_pending_drills * sizeof (DxfPendingDrills));
+                }
+                dxf_pending_drills[dxf_n_pending_drills].x = cx;
+                dxf_pending_drills[dxf_n_pending_drills].y = cy;
+                dxf_pending_drills[dxf_n_pending_drills].diam = radius * 2;
+                dxf_n_pending_drills++;
+                return;
+        }
+        else if (gc->drill) return;
+        if (dxf_metric) /* use metric mm */
+        {
+                dxf_x0 = MIL_TO_MM * DXF_X(PCB, cx);
+                dxf_y0 = MIL_TO_MM * DXF_Y(PCB, cy);
+                dxf_radius = MIL_TO_MM * DXF_X(PCB, radius);
+        }
+        else /* use imperial mil */
+        {
+                dxf_x0 = DXF_X(PCB, cx);
+                dxf_y0 = DXF_Y(PCB, cy);
+                dxf_radius = DXF_X(PCB, radius);
+        }
+        if (dxf_color_is_byblock)
+        {
+                dxf_color = DXF_COLOR_BYBLOCK;
+        }
+        else dxf_color = gc->color;
+        dxf_write_circle
+        (
+                fp,
+                dxf_id_code,
+                DXF_DEFAULT_LINETYPE, /* linetype, */
+                DXF_DEFAULT_LAYER, /* layer, */
+                dxf_x0,
+                dxf_y0,
+                0.0, /* z0, */ /* curved or flexable pcb's ??  */
+                0.0, /* dxf_extr_x0, */
+                0.0, /* dxf_extr_y0, */
+                1.0, /* dxf_extr_z0, */
+                0.0, /* thickness, */ /* copper weight ??  */
+                dxf_radius,
+                dxf_color,
+                0 /* modelspace */
+        );
+        dxf_id_code++;
+        dxf_lastX = dxf_x0;
+        dxf_lastY = dxf_y0;
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_fill_circle () function.\n", __FILE__, __LINE__);
+#endif
+}
+
+
+/*!
+ * \brief Draw a filled polygon.
+ *
+ * The usual drawing functions.\n
+ * "draw" means to use segments of the given width, whereas "fill" means to
+ * fill to a zero-width outline.\n
+ * A polygon is drawn with a solid fill pattern.
+ *
+ * The filled polygon is by drawn by a (closed) polyline sequence with
+ * (n_coords + 1) vertices and add a SOLID hatch pattern to this polyline.\n
+ * This solution would allow for thieving if it were ever implemented in pcb
+ * (select a hatch pattern, create a boundary path, apply a scale and all the
+ * other stuff that is needed).
+ */
+static void
+dxf_fill_polygon
+(
+        hidGC gc, /*!< graphic context  */
+        int n_coords, /*!< number of XY-coordinates  */
+        int *x, /*!< pointer to array of X-values of coordinates  */
+        int *y /*!< pointer to array of Y-values of coordinates  */
+)
+{
+        //Boolean m = False;
+        int i;
+        double dxf_x0 = 0.0;
+        double dxf_y0 = 0.0;
+        int dxf_color = DXF_COLOR_BYLAYER;
+
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_fill_polygon () function.\n", __FILE__, __LINE__);
+#endif
+
+        if (is_mask && current_mask == HID_MASK_BEFORE)
+        {
+                return;
+        }
+        dxf_use_gc (gc, 10 * 100);
+        /*
+         * return if no valid file pointer exists.
+         */
+        if (!fp)
+        {
+                fprintf (stderr, "Warning: no valid file pointer exists.\n");
+                return;
+        }
+        if (dxf_color_is_byblock)
+        {
+                dxf_color = DXF_COLOR_BYBLOCK;
+        }
+        else dxf_color = gc->color;
+        /*
+         * write hatch sequence.
+         */
+        dxf_write_hatch
+        (
+                fp,
+                DXF_DEFAULT_HATCH_PATTERN_NAME, /* pattern_name, */
+                dxf_id_code,
+                DXF_DEFAULT_LINETYPE, /* linetype, */
+                DXF_DEFAULT_LAYER, /* layer, */
+                dxf_x0,
+                dxf_y0,
+                0.0, /* z0, */ /* stacked, curved or flexable pcb's ?? */
+                0.0, /* extr_x0, */
+                0.0, /* extr_y0, */
+                1.0, /* extr_z0, */
+                0.0, /* thickness, */ /* copper weight ?? */
+                1.0, /* pattern_scale, */
+                0.0, /* pixel_size, */
+                45.0, /* pattern_angle, */
+                dxf_color,
+                0, /* modelspace, */
+                1, /* solid_fill, */
+                1, /* associative, */
+                0, /* style, */
+                1, /* pattern_style, */
+                0, /* pattern_double, */
+                0, /* pattern_def_lines, */
+                1, /* boundary_paths, */
+                0, /* seed_points, */
+                0, /* seed_x0, */
+                0  /* seed_y0, */
+        );
+        /*
+         * draw hatch boundary path polyline.
+         */
+        dxf_write_hatch_boundary_path_polyline
+        (
+                fp,
+                2, /* path_type_flag, */ /* 2 = polyline  */
+                0, /* polyline_has_bulge, */ /* 0 = polygons have sharp angles  */
+                1, /* polyline_is_closed, */ /* 1 = closed  */
+                n_coords + 1 /* polyline_vertices, */ /* number of polyline vertices to follow  */
+        );
+        /*
+         * draw hatch boundary polyline vertices, write (n_coords)
+         * XY-coordinates.
+         */
+        for (i = 0; i < n_coords; i++)
+        {
+                dxf_x0 = DXF_X(PCB, x[i]);
+                dxf_y0 = DXF_Y(PCB, y[i]);
+                dxf_write_hatch_boundary_path_polyline_vertex
+                (
+                        fp,
+                        dxf_x0,
+                        dxf_y0,
+                        0.0 /* dxf_z0 */
+                );
+                /*
+                 * close polyline with first coordinate X-Y pair.
+                 */
+                dxf_x0 = DXF_X(PCB, x[0]);
+                dxf_y0 = DXF_Y(PCB, y[0]);
+                dxf_write_hatch_boundary_path_polyline_vertex
+                (
+                        fp,
+                        dxf_x0,
+                        dxf_y0,
+                        0.0 /* dxf_z0 */
+                );
+        }
+        dxf_id_code++;
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_fill_polygon () function.\n", __FILE__, __LINE__);
+#endif
+}
+
+
+/*!
+ * \brief Draw a filled rectangle.
+ *
+ * The usual drawing functions.\n
+ * "draw" means to use segments of the given width, whereas "fill" means to
+ * fill to a zero-width outline.\n
+ */
+static void
+dxf_fill_rect
+(
+        hidGC gc, /*!< graphic context  */
+        int x1, /*!< X-value bottom left ?? point  */
+        int y1, /*!< Y-value bottom left ?? point  */
+        int x2, /*!< X-value top right ?? point  */
+        int y2 /*!< Y-value top right ?? point  */
+)
+{
+        int dxf_color;
+        double dxf_x0;
+        double dxf_y0;
+        double dxf_x1;
+        double dxf_y1;
+        double dxf_x2;
+        double dxf_y2;
+        double dxf_x3;
+        double dxf_y3;
+
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering dxf_fill_rect () function.\n", __FILE__, __LINE__);
+#endif
+
+        /*
+         * return if no valid file pointer exists.
+         */
+        if (!fp)
+        {
+                fprintf (stderr, "Warning: no valid file pointer exists.\n");
+                return;
+        }
+        if ((x1 == x2) && (y1 == y2))
+        {
+                fprintf (stderr, "Warning: start point and end point are identical for the entity with id-code: %x\n", dxf_id_code);
+                fprintf (stderr, "         entity is discarded from output.\n");
+                return;
+        }
+        if (dxf_color_is_byblock)
+        {
+                dxf_color = DXF_COLOR_BYBLOCK;
+        }
+        else dxf_color = gc->color;
+        dxf_x0 = DXF_X(PCB, x1);
+        dxf_y0 = DXF_Y(PCB, y1);
+        dxf_x1 = DXF_X(PCB, x2);
+        dxf_y1 = DXF_Y(PCB, y1);
+        dxf_x2 = DXF_X(PCB, x1);
+        dxf_y2 = DXF_Y(PCB, y2);
+        dxf_x3 = DXF_X(PCB, x2);
+        dxf_y3 = DXF_Y(PCB, y2);
+        dxf_write_solid
+        (
+                fp,
+                dxf_id_code,
+                DXF_DEFAULT_LINETYPE, /* linetype, */
+                DXF_DEFAULT_LAYER, /* layer, */
+                dxf_x0, /* base point, bottom left  */
+                dxf_y0,
+                0.0, /* z0, */
+                dxf_x1, /* alignment point, bottom right  */
+                dxf_y1,
+                0.0, /* z1, */
+                dxf_x2, /* alignment point, top left  */
+                dxf_y2,
+                0.0, /* z2, */
+                dxf_x3, /* alignment point, top right  */
+                dxf_y3,
+                0.0, /* z3, */
+                0.0, /* thickness, */
+                dxf_color,
+                0 /* modelspace */
+        );
+        dxf_id_code++;
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving dxf_fill_rect () function.\n", __FILE__, __LINE__);
+#endif
+}
+
+
+/*!
+ * \brief This is for the printer.
+ *
+ * If you call this for the GUI, xval and yval are ignored, and a dialog pops
+ * up to lead you through the calibration procedure.\n
+ * For the printer, if xval and yval are zero, a calibration page is printed
+ * with instructions for calibrating your printer.\n
+ * After calibrating, nonzero xval and yval are passed according to the
+ * instructions.\n
+ * Metric is nonzero if the user prefers metric units, else inches are used.\n
+ * Calibrate a DXF file ?.\n
+ * Since we do not calibrate a DXF file, we ignore this one.
+ */
+static void
+dxf_calibrate
+(
+        double xval, /*!< X-value  */
+        double yval /*!< Y-value  */
+)
+{
+        /* Intentionally: do nothing here */
+}
+
+
+/*!
+ * \brief Sets the crosshair.
+ *
+ * Which may differ from the pointer depending on grid and pad snap.\n
+ * Note that the HID is responsible for hiding, showing, redrawing, etc.\n
+ * The core just tells it what coordinates it's actually using.\n
+ * Note that this routine may need to know what "pcb units" are so it can
+ * display them in mm or mils accordingly.\n
+ * Set a crosshair in a DXF file ?.\n
+ * Since it is useless to set a crosshair in a DXF file, we ignore this one.
+ */
+static void
+dxf_set_crosshair
+(
+        int x, /*!< X-value of coordinate  */
+        int y, /*!< Y-value of coordinate  */
+        int cursor_action
+)
+{
+        /* Intentionally: do nothing here */
+}
+
+
+/*!
+ * \brief Show item ?.
+ */
+static void
+dxf_show_item (void *item)
+{
+}
+
+
+/*!
+ * \brief Send beep signal to stdout ?.
+ */
+static void
+dxf_beep (void)
+{
+  putchar (7);
+  fflush (stdout);
+}
+
+
+/*!
+ * \brief Show progress ?.
+ */
+static int
+dxf_progress (int dxf_so_far, int dxf_total, const char *dxf_message)
+{
+  return 0;
+}
+
+
+/*!
+ * \brief Record with all values of the DXF HID.
+ */
+static HID dxf_hid =
+{
+        sizeof (HID),
+        "dxf",
+        "Exports DXF files",
+        0, /*!< gui */
+        0, /*!< printer */
+        1, /*!< exporter */
+        0, /*!< poly before */
+        0, /*!< poly after */
+        0, /*!< poly dicer */
+        dxf_get_export_options, /*!< dxf_get_export_options. */
+        dxf_do_export, /*!< dxf_do_export */
+        dxf_parse_arguments, /*!< dxf_parse_arguments */
+        0, /*!< dxf_invalidate_lr */
+        0, /*!< dxf_invalidate_all */
+        dxf_set_layer, /*!< dxf_set_layer */
+        dxf_make_gc, /*!< dxf_make_gc */
+        dxf_destroy_gc, /*!< dxf_destroy_gc */
+        dxf_use_mask, /*!< dxf_use_mask */
+        dxf_set_color, /*!< dxf_set_color */
+        dxf_set_line_cap, /*!< dxf_set_line_cap */
+        dxf_set_line_width, /*!< dxf_set_line_width */
+        0, /*!< dxf_set_draw_xor */
+        0, /*!< dxf_set_draw_faded */
+        0, /*!< dxf_set_line_cap_angle */
+        dxf_draw_line, /*!< dxf_draw_line */
+        dxf_draw_arc, /*!< dxf_draw_arc */
+        dxf_draw_rect, /*!< dxf_draw_rect */
+        dxf_fill_circle, /*!< dxf_fill_circle */
+        dxf_fill_polygon, /*!< dxf_fill_polygon*/
+        common_fill_pcb_polygon, /*!< common_fill_pcb_polygon */
+        0, /*!< dxf_thindraw_pcb_polygon */
+        dxf_fill_rect, /*!< dxf_fill_rect */
+        dxf_calibrate, /*!< dxf_calibrate */
+        0, /*!< dxf_shift_is_pressed */
+        0, /*!< dxf_control_is_pressed */
+        0, /*!< dxf_mod1_is_pressed */
+        0, /*!< dxf_get_coords */
+        dxf_set_crosshair, /*!< dxf_set_crosshair */
+        0, /*!< dxf_add_timer */
+        0, /*!< dxf_stop_timer */
+        0, /*!< dxf_watch_file */
+        0, /*!< dxf_unwatch_file */
+        0, /*!< dxf_add_block_hook */
+        0, /*!< dzfstop_block_hook */
+        0, /*!< dxf_log */
+        0, /*!< dxf_logv */
+        0, /*!< dxf_confirm_dialog */
+        0, /*!< dxf_close_confirm_dialog */
+        0, /*!< dxf_report_dialog */
+        0, /*!< dxf_prompt_for */
+        0, /*!< dxf_fileselect */
+        0, /*!< dxf_attribute_dialog */
+        dxf_show_item, /*!< dxf_show_item */
+        dxf_beep, /*!< dxf_beep */
+        dxf_progress, /*!< dxf_progress */
+        0, /*!< dxf_drc_gui */
+        0 /*!< dxf_edit_attributes */
+};
+
+
+/*!
+ * \brief Call this as soon as possible from main().
+ *
+ * Initialise and register the DXF HID.
+ * No other HID calls are valid until this is called.
+ */
+void
+hid_dxf_init ()
+{
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Entering hid_dxf_init () function.\n", __FILE__, __LINE__);
+#endif
+        apply_default_hid (&dxf_hid, 0);
+        hid_register_hid (&dxf_hid);
+#if DEBUG
+        fprintf (stderr, "[File: %s: line: %d] Leaving hid_dxf_init () function.\n", __FILE__, __LINE__);
+#endif
+}
+
+
+/*
+$Log$
+*/
diff --git a/src/hid/dxf/hid.conf b/src/hid/dxf/hid.conf
new file mode 100644
index 0000000..e1ec247
--- /dev/null
+++ b/src/hid/dxf/hid.conf
@@ -0,0 +1 @@
+type=export
\ No newline at end of file
diff --git a/src/hid/dxf/template/metric_header.dxf b/src/hid/dxf/template/metric_header.dxf
new file mode 100644
index 0000000..ee74e57
--- /dev/null
+++ b/src/hid/dxf/template/metric_header.dxf
@@ -0,0 +1,1240 @@
+  0
+SECTION
+  2
+HEADER
+  9
+$ACADVER
+  1
+AC1014
+  9
+$ACADMAINTVER
+ 70
+     0
+  9
+$DWGCODEPAGE
+  3
+ANSI_1252
+  9
+$INSBASE
+ 10
+0.0
+ 20
+0.0
+ 30
+0.0
+  9
+$EXTMIN
+ 10
+-0.012816
+ 20
+-0.009063
+ 30
+-0.001526
+  9
+$EXTMAX
+ 10
+88.01056
+ 20
+35.022217
+ 30
+0.0
+  9
+$LIMMIN
+ 10
+0.0
+ 20
+0.0
+  9
+$LIMMAX
+ 10
+420.0
+ 20
+297.0
+  9
+$ORTHOMODE
+ 70
+     0
+  9
+$REGENMODE
+ 70
+     1
+  9
+$FILLMODE
+ 70
+     1
+  9
+$QTEXTMODE
+ 70
+     0
+  9
+$MIRRTEXT
+ 70
+     1
+  9
+$DRAGMODE
+ 70
+     2
+  9
+$LTSCALE
+ 40
+1.0
+  9
+$OSMODE
+ 70
+   125
+  9
+$ATTMODE
+ 70
+     1
+  9
+$TEXTSIZE
+ 40
+2.5
+  9
+$TRACEWID
+ 40
+1.0
+  9
+$TEXTSTYLE
+  7
+STANDARD
+  9
+$CLAYER
+  8
+0
+  9
+$CELTYPE
+  6
+BYLAYER
+  9
+$CECOLOR
+ 62
+   256
+  9
+$CELTSCALE
+ 40
+1.0
+  9
+$DELOBJ
+ 70
+     1
+  9
+$DISPSILH
+ 70
+     0
+  9
+$DIMSCALE
+ 40
+1.0
+  9
+$DIMASZ
+ 40
+2.5
+  9
+$DIMEXO
+ 40
+0.625
+  9
+$DIMDLI
+ 40
+3.75
+  9
+$DIMRND
+ 40
+0.0
+  9
+$DIMDLE
+ 40
+0.0
+  9
+$DIMEXE
+ 40
+1.25
+  9
+$DIMTP
+ 40
+0.0
+  9
+$DIMTM
+ 40
+0.0
+  9
+$DIMTXT
+ 40
+2.5
+  9
+$DIMCEN
+ 40
+2.5
+  9
+$DIMTSZ
+ 40
+0.0
+  9
+$DIMTOL
+ 70
+     0
+  9
+$DIMLIM
+ 70
+     0
+  9
+$DIMTIH
+ 70
+     0
+  9
+$DIMTOH
+ 70
+     0
+  9
+$DIMSE1
+ 70
+     0
+  9
+$DIMSE2
+ 70
+     0
+  9
+$DIMTAD
+ 70
+     1
+  9
+$DIMZIN
+ 70
+     8
+  9
+$DIMBLK
+  1
+
+  9
+$DIMASO
+ 70
+     1
+  9
+$DIMSHO
+ 70
+     1
+  9
+$DIMPOST
+  1
+
+  9
+$DIMAPOST
+  1
+
+  9
+$DIMALT
+ 70
+     0
+  9
+$DIMALTD
+ 70
+     4
+  9
+$DIMALTF
+ 40
+0.0394
+  9
+$DIMLFAC
+ 40
+1.0
+  9
+$DIMTOFL
+ 70
+     1
+  9
+$DIMTVP
+ 40
+0.0
+  9
+$DIMTIX
+ 70
+     0
+  9
+$DIMSOXD
+ 70
+     0
+  9
+$DIMSAH
+ 70
+     0
+  9
+$DIMBLK1
+  1
+
+  9
+$DIMBLK2
+  1
+
+  9
+$DIMSTYLE
+  2
+STANDARD
+  9
+$DIMCLRD
+ 70
+     0
+  9
+$DIMCLRE
+ 70
+     0
+  9
+$DIMCLRT
+ 70
+     0
+  9
+$DIMTFAC
+ 40
+1.0
+  9
+$DIMGAP
+ 40
+0.625
+  9
+$DIMJUST
+ 70
+     0
+  9
+$DIMSD1
+ 70
+     0
+  9
+$DIMSD2
+ 70
+     0
+  9
+$DIMTOLJ
+ 70
+     1
+  9
+$DIMTZIN
+ 70
+     0
+  9
+$DIMALTZ
+ 70
+     0
+  9
+$DIMALTTZ
+ 70
+     0
+  9
+$DIMFIT
+ 70
+     3
+  9
+$DIMUPT
+ 70
+     0
+  9
+$DIMUNIT
+ 70
+     2
+  9
+$DIMDEC
+ 70
+     4
+  9
+$DIMTDEC
+ 70
+     4
+  9
+$DIMALTU
+ 70
+     2
+  9
+$DIMALTTD
+ 70
+     2
+  9
+$DIMTXSTY
+  7
+STANDARD
+  9
+$DIMAUNIT
+ 70
+     0
+  9
+$LUNITS
+ 70
+     2
+  9
+$LUPREC
+ 70
+     4
+  9
+$SKETCHINC
+ 40
+1.0
+  9
+$FILLETRAD
+ 40
+1.0
+  9
+$AUNITS
+ 70
+     0
+  9
+$AUPREC
+ 70
+     0
+  9
+$MENU
+  1
+.
+  9
+$ELEVATION
+ 40
+0.0
+  9
+$PELEVATION
+ 40
+0.0
+  9
+$THICKNESS
+ 40
+0.0
+  9
+$LIMCHECK
+ 70
+     0
+  9
+$BLIPMODE
+ 70
+     0
+  9
+$CHAMFERA
+ 40
+10.0
+  9
+$CHAMFERB
+ 40
+10.0
+  9
+$CHAMFERC
+ 40
+0.0
+  9
+$CHAMFERD
+ 40
+0.0
+  9
+$SKPOLY
+ 70
+     0
+  9
+$TDCREATE
+ 40
+2452949.844398842
+  9
+$TDUPDATE
+ 40
+2453105.563639282
+  9
+$TDINDWG
+ 40
+0.0994079282
+  9
+$TDUSRTIMER
+ 40
+0.0994079282
+  9
+$USRTIMER
+ 70
+     1
+  9
+$ANGBASE
+ 50
+0.0
+  9
+$ANGDIR
+ 70
+     0
+  9
+$PDMODE
+ 70
+    98
+  9
+$PDSIZE
+ 40
+0.0
+  9
+$PLINEWID
+ 40
+0.0
+  9
+$COORDS
+ 70
+     2
+  9
+$SPLFRAME
+ 70
+     0
+  9
+$SPLINETYPE
+ 70
+     6
+  9
+$SPLINESEGS
+ 70
+     8
+  9
+$ATTDIA
+ 70
+     0
+  9
+$ATTREQ
+ 70
+     1
+  9
+$HANDLING
+ 70
+     1
+  9
+$HANDSEED
+  5
+262
+  9
+$SURFTAB1
+ 70
+     6
+  9
+$SURFTAB2
+ 70
+     6
+  9
+$SURFTYPE
+ 70
+     6
+  9
+$SURFU
+ 70
+     6
+  9
+$SURFV
+ 70
+     6
+  9
+$UCSNAME
+  2
+
+  9
+$UCSORG
+ 10
+0.0
+ 20
+0.0
+ 30
+0.0
+  9
+$UCSXDIR
+ 10
+1.0
+ 20
+0.0
+ 30
+0.0
+  9
+$UCSYDIR
+ 10
+0.0
+ 20
+1.0
+ 30
+0.0
+  9
+$PUCSNAME
+  2
+
+  9
+$PUCSORG
+ 10
+0.0
+ 20
+0.0
+ 30
+0.0
+  9
+$PUCSXDIR
+ 10
+1.0
+ 20
+0.0
+ 30
+0.0
+  9
+$PUCSYDIR
+ 10
+0.0
+ 20
+1.0
+ 30
+0.0
+  9
+$USERI1
+ 70
+     0
+  9
+$USERI2
+ 70
+     0
+  9
+$USERI3
+ 70
+     0
+  9
+$USERI4
+ 70
+     0
+  9
+$USERI5
+ 70
+     0
+  9
+$USERR1
+ 40
+0.0
+  9
+$USERR2
+ 40
+0.0
+  9
+$USERR3
+ 40
+0.0
+  9
+$USERR4
+ 40
+0.0
+  9
+$USERR5
+ 40
+0.0
+  9
+$WORLDVIEW
+ 70
+     1
+  9
+$SHADEDGE
+ 70
+     3
+  9
+$SHADEDIF
+ 70
+    70
+  9
+$TILEMODE
+ 70
+     1
+  9
+$MAXACTVP
+ 70
+    48
+  9
+$PINSBASE
+ 10
+0.0
+ 20
+0.0
+ 30
+0.0
+  9
+$PLIMCHECK
+ 70
+     0
+  9
+$PEXTMIN
+ 10
+1.000000E+20
+ 20
+1.000000E+20
+ 30
+1.000000E+20
+  9
+$PEXTMAX
+ 10
+-1.000000E+20
+ 20
+-1.000000E+20
+ 30
+-1.000000E+20
+  9
+$PLIMMIN
+ 10
+0.0
+ 20
+0.0
+  9
+$PLIMMAX
+ 10
+420.0
+ 20
+297.0
+  9
+$UNITMODE
+ 70
+     0
+  9
+$VISRETAIN
+ 70
+     1
+  9
+$PLINEGEN
+ 70
+     0
+  9
+$PSLTSCALE
+ 70
+     1
+  9
+$TREEDEPTH
+ 70
+  3020
+  9
+$PICKSTYLE
+ 70
+     1
+  9
+$CMLSTYLE
+  2
+STANDARD
+  9
+$CMLJUST
+ 70
+     0
+  9
+$CMLSCALE
+ 40
+1.0
+  9
+$PROXYGRAPHICS
+ 70
+     1
+  9
+$MEASUREMENT
+ 70
+     0
+  0
+ENDSEC
+  0
+SECTION
+  2
+CLASSES
+  0
+ENDSEC
+  0
+SECTION
+  2
+TABLES
+  0
+TABLE
+  2
+VPORT
+  5
+23A
+100
+AcDbSymbolTable
+ 70
+     2
+  0
+VPORT
+  5
+261
+100
+AcDbSymbolTableRecord
+100
+AcDbViewportTableRecord
+  2
+*ACTIVE
+ 70
+     0
+ 10
+0.0
+ 20
+0.0
+ 11
+1.0
+ 21
+1.0
+ 12
+43.998872
+ 22
+17.506577
+ 13
+0.0
+ 23
+0.0
+ 14
+1.0
+ 24
+1.0
+ 15
+10.0
+ 25
+10.0
+ 16
+0.0
+ 26
+0.0
+ 36
+1.0
+ 17
+0.0
+ 27
+0.0
+ 37
+0.0
+ 40
+47.164502
+ 41
+1.882514
+ 42
+50.0
+ 43
+0.0
+ 44
+0.0
+ 50
+0.0
+ 51
+0.0
+ 71
+     0
+ 72
+   100
+ 73
+     1
+ 74
+     3
+ 75
+     0
+ 76
+     0
+ 77
+     0
+ 78
+     0
+  0
+ENDTAB
+  0
+TABLE
+  2
+LTYPE
+  5
+237
+100
+AcDbSymbolTable
+ 70
+     1
+  0
+LTYPE
+  5
+244
+100
+AcDbSymbolTableRecord
+100
+AcDbLinetypeTableRecord
+  2
+BYBLOCK
+ 70
+     0
+  3
+
+ 72
+    65
+ 73
+     0
+ 40
+0.0
+  0
+LTYPE
+  5
+245
+100
+AcDbSymbolTableRecord
+100
+AcDbLinetypeTableRecord
+  2
+BYLAYER
+ 70
+     0
+  3
+
+ 72
+    65
+ 73
+     0
+ 40
+0.0
+  0
+LTYPE
+  5
+246
+100
+AcDbSymbolTableRecord
+100
+AcDbLinetypeTableRecord
+  2
+CONTINUOUS
+ 70
+     0
+  3
+Solid line
+ 72
+    65
+ 73
+     0
+ 40
+0.0
+  0
+ENDTAB
+  0
+TABLE
+  2
+LAYER
+  5
+234
+100
+AcDbSymbolTable
+ 70
+     2
+  0
+LAYER
+  5
+240
+100
+AcDbSymbolTableRecord
+100
+AcDbLayerTableRecord
+  2
+0
+ 70
+     0
+ 62
+     7
+  6
+CONTINUOUS
+  0
+LAYER
+  5
+251
+100
+AcDbSymbolTableRecord
+100
+AcDbLayerTableRecord
+  2
+ASHADE
+ 70
+     4
+ 62
+     7
+  6
+CONTINUOUS
+  0
+ENDTAB
+  0
+TABLE
+  2
+STYLE
+  5
+235
+100
+AcDbSymbolTable
+ 70
+     2
+  0
+STYLE
+  5
+241
+100
+AcDbSymbolTableRecord
+100
+AcDbTextStyleTableRecord
+  2
+STANDARD
+ 70
+     0
+ 40
+0.0
+ 41
+1.0
+ 50
+0.0
+ 71
+     0
+ 42
+2.5
+  3
+txt
+  4
+
+  0
+STYLE
+  5
+252
+100
+AcDbSymbolTableRecord
+100
+AcDbTextStyleTableRecord
+  2
+ASHADE
+ 70
+     0
+ 40
+0.2
+ 41
+1.0
+ 50
+0.0
+ 71
+     0
+ 42
+2.5
+  3
+simplex.shx
+  4
+
+  0
+ENDTAB
+  0
+TABLE
+  2
+VIEW
+  5
+238
+100
+AcDbSymbolTable
+ 70
+     0
+  0
+ENDTAB
+  0
+TABLE
+  2
+UCS
+  5
+239
+100
+AcDbSymbolTable
+ 70
+     0
+  0
+ENDTAB
+  0
+TABLE
+  2
+APPID
+  5
+23B
+100
+AcDbSymbolTable
+ 70
+     6
+  0
+APPID
+  5
+242
+100
+AcDbSymbolTableRecord
+100
+AcDbRegAppTableRecord
+  2
+ACAD
+ 70
+     0
+  0
+APPID
+  5
+253
+100
+AcDbSymbolTableRecord
+100
+AcDbRegAppTableRecord
+  2
+AVE_RENDER
+ 70
+     0
+  0
+APPID
+  5
+254
+100
+AcDbSymbolTableRecord
+100
+AcDbRegAppTableRecord
+  2
+AVE_ENTITY_MATERIAL
+ 70
+     0
+  0
+APPID
+  5
+255
+100
+AcDbSymbolTableRecord
+100
+AcDbRegAppTableRecord
+  2
+AVE_FINISH
+ 70
+     0
+  0
+APPID
+  5
+256
+100
+AcDbSymbolTableRecord
+100
+AcDbRegAppTableRecord
+  2
+AVE_MATERIAL
+ 70
+     0
+  0
+APPID
+  5
+257
+100
+AcDbSymbolTableRecord
+100
+AcDbRegAppTableRecord
+  2
+AVE_GLOBAL
+ 70
+     0
+  0
+ENDTAB
+  0
+TABLE
+  2
+DIMSTYLE
+  5
+23C
+100
+AcDbSymbolTable
+ 70
+     1
+  0
+DIMSTYLE
+105
+258
+100
+AcDbSymbolTableRecord
+100
+AcDbDimStyleTableRecord
+  2
+STANDARD
+ 70
+     0
+  3
+
+  4
+
+  5
+
+  6
+
+  7
+
+ 40
+1.0
+ 41
+0.18
+ 42
+0.0625
+ 43
+0.38
+ 44
+0.18
+ 45
+0.0
+ 46
+0.0
+ 47
+0.0
+ 48
+0.0
+140
+0.18
+141
+0.09
+142
+0.0
+143
+25.4
+144
+1.0
+145
+0.0
+146
+1.0
+147
+0.09
+ 71
+     0
+ 72
+     0
+ 73
+     1
+ 74
+     1
+ 75
+     0
+ 76
+     0
+ 77
+     0
+ 78
+     0
+170
+     0
+171
+     2
+172
+     0
+173
+     0
+174
+     0
+175
+     0
+176
+     0
+177
+     0
+178
+     0
+270
+     2
+271
+     4
+272
+     4
+273
+     2
+274
+     2
+340
+241
+275
+     0
+280
+     0
+281
+     0
+282
+     0
+283
+     1
+284
+     0
+285
+     0
+286
+     0
+287
+     3
+288
+     0
+  0
+ENDTAB

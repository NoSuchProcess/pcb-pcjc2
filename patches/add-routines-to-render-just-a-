Bottom: 643bf3cc3e59430e5afa2adbd4df659f4dc08fb8
Top:    d5acb924769fc300825106091a7eccd80b5ccc93
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-11-12 14:10:15 +0000

Add routines to render just a single contour

Use them rather than the GLU tessellator


---

diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index 360aa83..6931651 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -585,27 +585,7 @@ hidgl_fill_polygon (int n_coords, int *x, int *y)
   free (vertices);
 }
 
-void tesselate_contour (GLUtesselator *tobj, VNODE *vnode, GLdouble *vertices)
-{
-  VNODE *vn = vnode;
-  int offset = 0;
-
-  gluTessBeginPolygon (tobj, NULL);
-  gluTessBeginContour (tobj);
-  do {
-    vertices [0 + offset] = vn->point[0];
-    vertices [1 + offset] = vn->point[1];
-    vertices [2 + offset] = 0.;
-    gluTessVertex (tobj, &vertices [offset], &vertices [offset]);
-    offset += 3;
-  } while ((vn = vn->next) != vnode);
-  gluTessEndContour (tobj);
-  gluTessEndPolygon (tobj);
-}
-
 struct do_hole_info {
-  GLUtesselator *tobj;
-  GLdouble *vertices;
   double scale;
 };
 
@@ -614,6 +594,7 @@ do_hole (const BoxType *b, void *cl)
 {
   struct do_hole_info *info = cl;
   PLINE *curc = (PLINE *) b;
+  cairo_traps_t traps;
 
   /* Ignore the outer contour - we draw it first explicitly*/
   if (curc->Flags.orient == PLF_DIR) {
@@ -632,7 +613,10 @@ do_hole (const BoxType *b, void *cl)
     }
   }
 
-  tesselate_contour (info->tobj, &curc->head, info->vertices);
+  _cairo_traps_init (&traps);
+  bo_contour_to_traps (curc, &traps);
+  _cairo_traps_fini (&traps);
+
   return 1;
 }
 
@@ -644,18 +628,10 @@ static int assigned_bits = 0;
 void
 hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale)
 {
-  int vertex_count = 0;
-  PLINE *contour;
   struct do_hole_info info;
   int stencil_bit;
   cairo_traps_t traps;
 
-  _cairo_traps_init (&traps);
-  bo_poly_to_traps (poly->Clipped, &traps);
-  _cairo_traps_fini (&traps);
-
-  return;
-
   info.scale = scale;
   global_scale = scale;
 
@@ -675,19 +651,6 @@ hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale
   /* Flush out any existing geoemtry to be rendered */
   hidgl_flush_triangles (&buffer);
 
-  /* Walk the polygon structure, counting vertices */
-  /* This gives an upper bound on the amount of storage required */
-  for (contour = poly->Clipped->contours;
-       contour != NULL; contour = contour->next)
-    vertex_count = MAX (vertex_count, contour->Count);
-
-  info.vertices = malloc (sizeof(GLdouble) * vertex_count * 3);
-  info.tobj = gluNewTess ();
-  gluTessCallback(info.tobj, GLU_TESS_BEGIN, myBegin);
-  gluTessCallback(info.tobj, GLU_TESS_VERTEX, myVertex);
-  gluTessCallback(info.tobj, GLU_TESS_COMBINE, myCombine);
-  gluTessCallback(info.tobj, GLU_TESS_ERROR, myError);
-
   glPushAttrib (GL_STENCIL_BUFFER_BIT);                   // Save the write mask etc.. for final restore
   glPushAttrib (GL_STENCIL_BUFFER_BIT |                   // Resave the stencil write-mask etc.., and
                 GL_COLOR_BUFFER_BIT);                     // the colour buffer write mask etc.. for part way restore
@@ -716,17 +679,15 @@ hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale
                                                               // any bits permitted by the stencil writemask
 
   /* Draw the polygon outer */
-  tesselate_contour (info.tobj, &poly->Clipped->contours->head, info.vertices);
+  _cairo_traps_init (&traps);
+  bo_contour_to_traps (poly->Clipped->contours, &traps);
+  _cairo_traps_fini (&traps);
   hidgl_flush_triangles (&buffer);
 
   /* Unassign our stencil buffer bit */
   hidgl_return_stencil_bit (stencil_bit);
 
   glPopAttrib ();                                             // Restore the stencil buffer write-mask etc..
-
-  gluDeleteTess (info.tobj);
-  myFreeCombined ();
-  free (info.vertices);
 }
 
 void

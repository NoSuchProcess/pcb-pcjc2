Bottom: ef8ca3b822d9e73fbfe0b6ca4b1b5ed23f5a3ac1
Top:    477bc0ef1365d501b29b532a75ce3704e86043e6
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2015-03-21 11:51:07 +0000

hid/gtk (GL): Add hacky code to render outline of board, and mask cutout geometry


---

diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 7f99368..1c8b92b 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -1610,15 +1610,108 @@ clearPad_callback_solid (const BoxType * b, void *cl)
 }
 
 static void
-GhidDrawMask (int side, BoxType * screen)
+ensure_board_outline (void)
+{
+  if (!PCB->Data->outline_valid) {
+
+    if (PCB->Data->outline != NULL)
+      poly_Free (&PCB->Data->outline);
+
+    PCB->Data->outline = board_outline_poly ();
+    PCB->Data->outline_valid = true;
+  }
+}
+
+static void
+fill_board_outline (hidGC gc, const BoxType *drawn_area)
+{
+  PolygonType polygon;
+
+  ensure_board_outline ();
+
+  memset (&polygon, 0, sizeof (polygon));
+  polygon.Clipped = PCB->Data->outline;
+  if (drawn_area)
+    polygon.BoundingBox = *drawn_area;
+  polygon.Flags = NoFlags ();
+  SET_FLAG (FULLPOLYFLAG, &polygon);
+  hid_draw_fill_pcb_polygon (gc, &polygon, drawn_area);
+  poly_FreeContours (&polygon.NoHoles);
+}
+
+struct outline_info {
+  hidGC gc;
+  float z1;
+  float z2;
+};
+
+static int
+fill_outline_hole_cb (PLINE *pl, void *user_data)
+{
+  struct outline_info *info = (struct outline_info *)user_data;
+  PolygonType polygon;
+  PLINE *pl_copy = NULL;
+
+  poly_CopyContour (&pl_copy, pl);
+  poly_InvContour (pl_copy);
+
+  memset (&polygon, 0, sizeof (polygon));
+  polygon.Clipped = poly_Create ();
+  poly_InclContour (polygon.Clipped, pl_copy);
+
+//  if (polygon.Clipped->contours == NULL)
+//    return 0;
+
+  polygon.Flags = NoFlags ();
+  SET_FLAG (FULLPOLYFLAG, &polygon);
+
+  /* XXX: For some reason, common_fill_pcb_polygon doesn't work for all contours here.. not sure why */
+//  common_fill_pcb_polygon (info->gc, &polygon, NULL);
+  hid_draw_fill_pcb_polygon (info->gc, &polygon, NULL);
+
+  poly_FreeContours (&polygon.NoHoles);
+
+  poly_Free (&polygon.Clipped);
+
+  return 0;
+}
+
+static void
+fill_board_outline_holes (hidGC gc, const BoxType *drawn_area)
 {
   render_priv *priv = gport->render_priv;
+  PolygonType polygon, p;
+  struct outline_info info;
+
+  ensure_board_outline ();
+
+  memset (&polygon, 0, sizeof (polygon));
+  polygon.Clipped = PCB->Data->outline;
+  if (drawn_area)
+    polygon.BoundingBox = *drawn_area;
+  polygon.Flags = NoFlags ();
+  SET_FLAG (FULLPOLYFLAG, &polygon);
+
+  info.gc = gc;
+
+  p = polygon;
+  do {
+    PolygonHoles (&p, drawn_area, fill_outline_hole_cb, &info);
+  } while ((p.Clipped = p.Clipped->f) != polygon.Clipped);
+
+//  poly_FreeContours (&polygon.NoHoles);
+
+  hidgl_flush_triangles (priv->hidgl);
+}
+
+static void
+GhidDrawMask (int side, BoxType * screen)
+{
 //  static bool first_run = true;
 //  static GLuint texture;
   int thin = TEST_FLAG(THINDRAWFLAG, PCB) || TEST_FLAG(THINDRAWPOLYFLAG, PCB);
   LayerType *Layer = LAYER_PTR (side == TOP_SIDE ? top_soldermask_layer : bottom_soldermask_layer);
   struct poly_info info;
-  PolygonType polygon;
 
   OutputType *out = &Output;
 
@@ -1679,14 +1772,8 @@ GhidDrawMask (int side, BoxType * screen)
   glEnable (GL_TEXTURE_2D);
 #endif
 
-  if (!PCB->Data->outline_valid) {
-
-    if (PCB->Data->outline != NULL)
-      poly_Free (&PCB->Data->outline);
-
-    PCB->Data->outline = board_outline_poly ();
-    PCB->Data->outline_valid = true;
-  }
+#if 0
+  ensure_board_outline ();
 
   memset (&polygon, 0, sizeof (polygon));
   polygon.Clipped = PCB->Data->outline;
@@ -1696,8 +1783,12 @@ GhidDrawMask (int side, BoxType * screen)
   SET_FLAG (FULLPOLYFLAG, &polygon);
   hid_draw_fill_pcb_polygon (out->fgGC, &polygon, screen);
   poly_FreeContours (&polygon.NoHoles);
+#endif
+
+  fill_board_outline (out->fgGC, screen);
+
   ghid_set_alpha_mult (out->fgGC, 1.0);
-  hidgl_flush_triangles (priv->hidgl);
+//  hidgl_flush_triangles (priv->hidgl);
 #if 0
   glDisable (GL_TEXTURE_GEN_S);
   glDisable (GL_TEXTURE_GEN_T);
@@ -1711,6 +1802,79 @@ GhidDrawMask (int side, BoxType * screen)
 //  first_run = false;
 }
 
+static void
+draw_outline_contour (hidGC gc, PLINE *pl, float z1, float z2)
+{
+  VNODE *v;
+  GLfloat x, y;
+
+  hidgl_ensure_vertex_space (gc, 2 * pl->Count + 2 + 2);
+
+  /* NB: Repeated first virtex to separate from other tri-strip */
+
+  x = pl->head.point[0];
+  y = pl->head.point[1];
+
+  hidgl_add_vertex_3D_tex (gc, x, y, z1, 0.0, 0.0);
+  hidgl_add_vertex_3D_tex (gc, x, y, z1, 0.0, 0.0);
+  hidgl_add_vertex_3D_tex (gc, x, y, z2, 0.0, 0.0);
+
+  v = pl->head.next;
+
+  do
+    {
+      x = v->point[0];
+      y = v->point[1];
+
+      hidgl_add_vertex_3D_tex (gc, x, y, z1, 0.0, 0.0);
+      hidgl_add_vertex_3D_tex (gc, x, y, z2, 0.0, 0.0);
+    }
+  while ((v = v->next) != pl->head.next);
+
+  /* NB: Repeated last virtex to separate from other tri-strip */
+  hidgl_add_vertex_3D_tex (gc, x, y, z2, 0.0, 0.0);
+}
+
+static int
+outline_hole_cb (PLINE *pl, void *user_data)
+{
+  struct outline_info *info = (struct outline_info *)user_data;
+
+  draw_outline_contour (info->gc, pl, info->z1, info->z2);
+  return 0;
+}
+
+static void
+ghid_draw_outline_between_layers (int from_layer, int to_layer, BoxType *drawn_area)
+{
+  render_priv *priv = gport->render_priv;
+  PolygonType polygon, p;
+  struct outline_info info;
+
+  ensure_board_outline ();
+
+  memset (&polygon, 0, sizeof (polygon));
+  polygon.Clipped = PCB->Data->outline;
+  if (drawn_area)
+    polygon.BoundingBox = *drawn_area;
+  polygon.Flags = NoFlags ();
+  SET_FLAG (FULLPOLYFLAG, &polygon);
+
+  info.gc = Output.fgGC;
+  info.z1 = compute_depth (from_layer);
+  info.z2 = compute_depth (to_layer);
+
+  p = polygon;
+  do {
+    draw_outline_contour (info.gc, p.Clipped->contours, info.z1, info.z2);
+    PolygonHoles (&p, drawn_area, outline_hole_cb, &info);
+  } while ((p.Clipped = p.Clipped->f) != polygon.Clipped);
+
+  poly_FreeContours (&polygon.NoHoles);
+
+  hidgl_flush_triangles (priv->hidgl);
+}
+
 static int
 GhidDrawLayerGroup (int group, const BoxType * screen)
 {
@@ -1754,6 +1918,7 @@ GhidDrawLayerGroup (int group, const BoxType * screen)
         hid_draw_set_color (Output.bgGC, PCB->MaskColor);
         if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
         if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
+        fill_board_outline_holes (Output.bgGC, screen);
         hidgl_flush_triangles (priv->hidgl);
         glPopAttrib ();
       }
@@ -1778,6 +1943,7 @@ GhidDrawLayerGroup (int group, const BoxType * screen)
           /* Mask out drilled holes on this layer */
           if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
           if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
+          fill_board_outline_holes (Output.bgGC, screen);
           hidgl_flush_triangles (priv->hidgl);
           glPopAttrib ();
         }
@@ -2064,6 +2230,7 @@ ghid_draw_everything (BoxType *drawn_area)
       cyl_info.scale = gport->view.coord_per_px;
       hid_draw_set_color (Output.fgGC, "drill");
       ghid_set_alpha_mult (Output.fgGC, alpha_mult * 0.75);
+      ghid_draw_outline_between_layers (cyl_info.from_layer, cyl_info.to_layer, drawn_area);
       if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_hole_cyl_callback, &cyl_info);
       if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, via_hole_cyl_callback, &cyl_info);
     }
@@ -2090,6 +2257,7 @@ ghid_draw_everything (BoxType *drawn_area)
       glDepthMask (GL_FALSE);
       if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, hole_callback, NULL);
       if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, hole_callback, NULL);
+      fill_board_outline_holes (Output.bgGC, drawn_area);
       hidgl_flush_triangles (priv->hidgl);
       glPopAttrib ();
     }
diff --git a/src/polygon.c b/src/polygon.c
index e91f990..d6996b7 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -2047,6 +2047,7 @@ POLYAREA *board_outline_poly (void)
   POLYAREA *piece;
   POLYAREA *check;
   GList *pieces_to_delete = NULL;
+  bool any_pieces_kept = false;
 
 #define BLOAT_WORLD MIL_TO_COORD (10)
 
@@ -2100,6 +2101,7 @@ POLYAREA *board_outline_poly (void)
   region.X2 = PCB->MaxWidth;
   region.Y2 = PCB->MaxHeight;
 
+
   r_search (Layer->line_tree, &region, NULL, line_outline_callback, &info);
   r_search (Layer->arc_tree,  &region, NULL, arc_outline_callback, &info);
 
@@ -2129,15 +2131,28 @@ POLYAREA *board_outline_poly (void)
         continue;
       if (poly_ContourInContour (check->contours, piece->contours))
         count ++;
+
     } while ((check = check->f) != clipped);
 
     /* If the piece is inside an odd number of others, delete it */
     if ((count & 1) == 0)
       pieces_to_delete = g_list_prepend (pieces_to_delete, piece);
+    else
+      any_pieces_kept = true;
 
   } while ((piece = piece->f) != clipped);
 
-  g_list_foreach (pieces_to_delete, delete_piece_cb, &clipped);
+  /* If we did not find an enclosed area (the board) trimmed from the world polygon,
+     return the entire subtracted result. This keeps the behaviour similar to what
+     you see when individual lines on the outline layer don't close to form an
+     enclosed region. (This fixes being able to cope with such a case where the
+     outline layer geometry lies outside the world rect polygon above, and divides
+     that world rect into multiple pieces.
+   */
+  if (any_pieces_kept)
+    g_list_foreach (pieces_to_delete, delete_piece_cb, &clipped);
+
+  g_list_free (pieces_to_delete);
 
   return clipped;
 }

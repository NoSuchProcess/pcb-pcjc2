Bottom: af2a81e9919b4d402a094f9f2163a8682e46b558
Top:    1c452145c58e5771645421b6d9e5aaa3f39ac7b7
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-09-29 23:02:14 +0100

hid/gtk: Extend layer selector to allow editing layer names in situ


---

diff --git a/src/hid/gtk/ghid-layer-selector.c b/src/hid/gtk/ghid-layer-selector.c
index 43b0fa3..1afd211 100644
--- a/src/hid/gtk/ghid-layer-selector.c
+++ b/src/hid/gtk/ghid-layer-selector.c
@@ -29,6 +29,7 @@ static void menu_pick_cb (GtkRadioAction *action, struct _layer *ldata);
 enum {
   SELECT_LAYER_SIGNAL,
   TOGGLE_LAYER_SIGNAL,
+  RENAME_LAYER_SIGNAL,
   LAST_SIGNAL
 };
 
@@ -40,6 +41,7 @@ enum {
   COLOR_COL,
   TEXT_COL,
   FONT_COL,
+  EDITABLE_COL,
   SELECTABLE_COL,
   SEPARATOR_COL,
   N_COLS
@@ -73,6 +75,7 @@ struct _GHidLayerSelectorClass
 
   void (* select_layer) (GHidLayerSelector *, gint);
   void (* toggle_layer) (GHidLayerSelector *, gint);
+  void (* rename_layer) (GHidLayerSelector *, gint, gchar *);
 };
 
 struct _layer
@@ -85,6 +88,42 @@ struct _layer
   GtkTreeRowReference *rref;
 };
 
+static void
+g_cclosure_user_marshal_VOID__INT_STRING (GClosure     *closure,
+                                          GValue       *return_value G_GNUC_UNUSED,
+                                          guint         n_param_values,
+                                          const GValue *param_values,
+                                          gpointer      invocation_hint G_GNUC_UNUSED,
+                                          gpointer      marshal_data)
+{
+  typedef void (*GMarshalFunc_VOID__INT_STRING) (gpointer     data1,
+                                                 gint         arg_1,
+                                                 gpointer     arg_2,
+                                                 gpointer     data2);
+  register GMarshalFunc_VOID__INT_STRING callback;
+  register GCClosure *cc = (GCClosure*) closure;
+  register gpointer data1, data2;
+
+  g_return_if_fail (n_param_values == 3);
+
+  if (G_CCLOSURE_SWAP_DATA (closure))
+    {
+      data1 = closure->data;
+      data2 = g_value_peek_pointer (param_values + 0);
+    }
+  else
+    {
+      data1 = g_value_peek_pointer (param_values + 0);
+      data2 = closure->data;
+    }
+  callback = (GMarshalFunc_VOID__INT_STRING) (marshal_data ? marshal_data : cc->callback);
+
+  callback (data1,
+            g_value_get_int (param_values + 1),
+            (char *)g_value_get_string (param_values + 2),
+            data2);
+}
+
 /*! \brief Deletes the action and accelerator from a layer */
 static void
 free_ldata (GHidLayerSelector *ls, struct _layer *ldata)
@@ -243,6 +282,70 @@ selection_changed_cb (GtkTreeSelection *selection, GHidLayerSelector *ls)
     }
 }
 
+/*! \brief Callback for when a layer name has been edited  */
+static void
+layer_name_editing_started_cb (GtkCellRenderer *renderer,
+                               GtkCellEditable *editable,
+                               gchar           *path,
+                               gpointer         user_data)
+{
+  /* When editing begins, we need to detach PCB's accelerators
+   * so they don't steal all the user's keystrokes.
+   *
+   * XXX: We should not have to do this within a simple widget,
+   *
+   *      and this quick hack workaround breaks the widget's
+   *      abstraction from the rest of the application :(
+   */
+  ghid_remove_accel_groups (GTK_WINDOW (gport->top_window), ghidgui);
+}
+
+/*! \brief Callback for when layer name editing has been canceled */
+static void
+layer_name_editing_canceled_cb (GtkCellRenderer *renderer,
+                                 gpointer         user_data)
+{
+  /* Put PCB's accelerators back.
+   *
+   * XXX: We should not have to do this within a simple widget,
+   *      and this quick hack workaround breaks the widget's
+   *      abstraction from the rest of the application :(
+   */
+  ghid_install_accel_groups (GTK_WINDOW (gport->top_window), ghidgui);
+}
+
+/*! \brief Callback for when a layer name has been edited  */
+static void
+layer_name_edited_cb (GtkCellRendererText *renderer,
+                      gchar               *path,
+                      gchar               *new_text,
+                      gpointer             user_data)
+{
+  GHidLayerSelector *ls = user_data;
+  GtkTreeIter iter;
+  int user_id;
+
+  /* Put PCB's accelerators back.
+   *
+   * XXX: We should not have to do this within a simple widget,
+   *      and this quick hack workaround breaks the widget's
+   *      abstraction from the rest of the application :(
+   */
+  ghid_install_accel_groups (GTK_WINDOW (gport->top_window), ghidgui);
+
+  if (!gtk_tree_model_get_iter_from_string (GTK_TREE_MODEL (ls->list_store), &iter, path))
+    return;
+
+  gtk_tree_model_get (GTK_TREE_MODEL (ls->list_store),
+                      &iter,
+                      USER_ID_COL, &user_id,
+                      -1);
+
+  g_signal_emit (ls, ghid_layer_selector_signals[RENAME_LAYER_SIGNAL],
+                 0, user_id, new_text);
+}
+
+
 /*! \brief Callback for menu actions: sync layer selection list, emit signal */
 static void
 menu_view_cb (GtkToggleAction *action, struct _layer *ldata)
@@ -300,20 +403,37 @@ ghid_layer_selector_init (GHidLayerSelector *ls)
 
   renderer1 = ghid_cell_renderer_visibility_new ();
   renderer2 = gtk_cell_renderer_text_new ();
-
-  opacity_col = gtk_tree_view_column_new_with_attributes ("", renderer1,
+  g_object_set (renderer2, "editable-set", TRUE, NULL);
+  g_signal_connect (renderer2, "editing-started",
+                    G_CALLBACK (layer_name_editing_started_cb), ls);
+  g_signal_connect (renderer2, "editing-canceled",
+                    G_CALLBACK (layer_name_editing_canceled_cb), ls);
+  g_signal_connect (renderer2, "edited",
+                    G_CALLBACK (layer_name_edited_cb), ls);
+
+  opacity_col = gtk_tree_view_column_new_with_attributes ("",
+                                                          renderer1,
                                                           "active", VISIBLE_COL,
-                                                          "color", COLOR_COL, NULL);
-  name_col = gtk_tree_view_column_new_with_attributes ("", renderer2,
+                                                          "color",  COLOR_COL,
+                                                          NULL);
+  name_col = gtk_tree_view_column_new_with_attributes ("",
+                                                       renderer2,
                                                        "text", TEXT_COL,
                                                        "font", FONT_COL,
+                                                       "editable", EDITABLE_COL,
                                                        NULL);
 
-  /* action index, active, color, text, font, is_separator */
-  ls->list_store = gtk_list_store_new (N_COLS, G_TYPE_POINTER, G_TYPE_INT,
-                                       G_TYPE_BOOLEAN, G_TYPE_STRING,
-                                       G_TYPE_STRING, G_TYPE_STRING,
-                                       G_TYPE_BOOLEAN, G_TYPE_BOOLEAN);
+  ls->list_store = gtk_list_store_new (N_COLS,
+                 /* STRUCT_COL      */ G_TYPE_POINTER,
+                 /* USER_ID_COL     */ G_TYPE_INT,
+                 /* VISIBLE_COL     */ G_TYPE_BOOLEAN,
+                 /* COLOR_COL       */ G_TYPE_STRING,
+                 /* TEXT_COL        */ G_TYPE_STRING,
+                 /* FONT_COL        */ G_TYPE_STRING,
+                 /* EDITABLE_COL    */ G_TYPE_BOOLEAN,
+                 /* ACTIVATABLE_COL */ G_TYPE_BOOLEAN,
+                 /* SEPARATOR_COL   */ G_TYPE_BOOLEAN);
+
   gtk_tree_view_insert_column (GTK_TREE_VIEW (ls), opacity_col, -1);
   gtk_tree_view_insert_column (GTK_TREE_VIEW (ls), name_col, -1);
   gtk_tree_view_set_model (GTK_TREE_VIEW (ls), GTK_TREE_MODEL (ls->list_store));
@@ -364,6 +484,14 @@ ghid_layer_selector_class_init (GHidLayerSelectorClass *klass)
                   NULL, NULL,
                   g_cclosure_marshal_VOID__INT, G_TYPE_NONE,
                   1, G_TYPE_INT);
+  ghid_layer_selector_signals[RENAME_LAYER_SIGNAL] =
+    g_signal_new ("rename-layer",
+                  G_TYPE_FROM_CLASS (klass),
+                  G_SIGNAL_RUN_FIRST | G_SIGNAL_ACTION,
+                  G_STRUCT_OFFSET (GHidLayerSelectorClass, rename_layer),
+                  NULL, NULL,
+                  g_cclosure_user_marshal_VOID__INT_STRING, G_TYPE_NONE,
+                  2, G_TYPE_INT, G_TYPE_STRING);
 
   object_class->finalize = ghid_layer_selector_finalize;
 }
@@ -455,7 +583,8 @@ ghid_layer_selector_add_layer (GHidLayerSelector *ls,
                                const gchar *name,
                                const gchar *color_string,
                                gboolean visible,
-                               gboolean selectable)
+                               gboolean selectable,
+                               gboolean builtin)
 {
   struct _layer *new_layer = NULL;
   gchar *pname, *vname;
@@ -523,6 +652,7 @@ ghid_layer_selector_add_layer (GHidLayerSelector *ls,
                       COLOR_COL,       color_string,
                       TEXT_COL,        name,
                       FONT_COL,        selectable ? NULL : "Italic",
+                      EDITABLE_COL,    !builtin,
                       SELECTABLE_COL,  selectable,
                       SEPARATOR_COL,   FALSE,
                       -1);
diff --git a/src/hid/gtk/ghid-layer-selector.h b/src/hid/gtk/ghid-layer-selector.h
index ff67800..1ed5e01 100644
--- a/src/hid/gtk/ghid-layer-selector.h
+++ b/src/hid/gtk/ghid-layer-selector.h
@@ -24,7 +24,8 @@ void ghid_layer_selector_add_layer (GHidLayerSelector *ls,
                                     const gchar *name,
                                     const gchar *color_string,
                                     gboolean visible,
-                                    gboolean selectable);
+                                    gboolean selectable,
+                                    gboolean builtin);
 
 gint ghid_layer_selector_install_pick_items (GHidLayerSelector *ls,
                                              GtkMenuShell *shell, gint pos);
diff --git a/src/hid/gtk/gui-top-window.c b/src/hid/gtk/gui-top-window.c
index 98bfcfe..4f25e72 100644
--- a/src/hid/gtk/gui-top-window.c
+++ b/src/hid/gtk/gui-top-window.c
@@ -553,6 +553,33 @@ layer_selector_select_callback (GHidLayerSelector *ls, int layer, gpointer d)
   ghid_invalidate_all ();
 }
 
+/*! \brief Callback for GHidLayerSelector layer renaming */
+static void
+layer_selector_rename_callback (GHidLayerSelector *ls,
+                                int layer_id,
+                                char *new_name,
+                                void *userdata)
+{
+  LayerType *layer = LAYER_PTR (layer_id);
+
+  /* Check for a legal layer name - for now, allow anything non-empty */
+  if (new_name[0] == '\0')
+    return;
+
+  /* Don't bother if the name is identical to the current one */
+  if (strcmp (layer->Name, new_name) == 0)
+    return;
+
+  free (layer->Name);
+  layer->Name = strdup (new_name);
+  ghid_layer_buttons_update ();
+  if (!PCB->Changed)
+    {
+      SetChangedFlag (true);
+      ghid_window_set_name_label (PCB->Name);
+    }
+}
+
 /*! \brief Callback for GHidLayerSelector layer toggling */
 static void
 layer_selector_toggle_callback (GHidLayerSelector *ls, int layer, gpointer d)
@@ -772,22 +799,22 @@ make_virtual_layer_buttons (GtkWidget *layer_selector)
  
   layer_process (&color_string, &text, &active, LAYER_BUTTON_SILK);
   ghid_layer_selector_add_layer (layersel, LAYER_BUTTON_SILK,
-                                 text, color_string, active, TRUE);
+                                 text, color_string, active, TRUE, TRUE);
   layer_process (&color_string, &text, &active, LAYER_BUTTON_RATS);
   ghid_layer_selector_add_layer (layersel, LAYER_BUTTON_RATS,
-                                 text, color_string, active, TRUE);
+                                 text, color_string, active, TRUE, TRUE);
   layer_process (&color_string, &text, &active, LAYER_BUTTON_PINS);
   ghid_layer_selector_add_layer (layersel, LAYER_BUTTON_PINS,
-                                 text, color_string, active, FALSE);
+                                 text, color_string, active, FALSE, TRUE);
   layer_process (&color_string, &text, &active, LAYER_BUTTON_VIAS);
   ghid_layer_selector_add_layer (layersel, LAYER_BUTTON_VIAS,
-                                 text, color_string, active, FALSE);
+                                 text, color_string, active, FALSE, TRUE);
   layer_process (&color_string, &text, &active, LAYER_BUTTON_FARSIDE);
   ghid_layer_selector_add_layer (layersel, LAYER_BUTTON_FARSIDE,
-                                 text, color_string, active, FALSE);
+                                 text, color_string, active, FALSE, TRUE);
   layer_process (&color_string, &text, &active, LAYER_BUTTON_MASK);
   ghid_layer_selector_add_layer (layersel, LAYER_BUTTON_MASK,
-                                 text, color_string, active, FALSE);
+                                 text, color_string, active, FALSE, TRUE);
 }
 
 /*! \brief callback for ghid_layer_selector_update_colors */
@@ -821,7 +848,7 @@ make_layer_buttons (GtkWidget *layersel)
     {
       layer_process (&color_string, &text, &active, i);
       ghid_layer_selector_add_layer (GHID_LAYER_SELECTOR (layersel), i,
-                                     text, color_string, active, TRUE);
+                                     text, color_string, active, TRUE, FALSE);
     }
 }
 
@@ -1248,12 +1275,15 @@ ghid_build_pcb_top_window (void)
   ghidgui->layer_selector = ghid_layer_selector_new ();
   make_layer_buttons (ghidgui->layer_selector);
   make_virtual_layer_buttons (ghidgui->layer_selector);
-  g_signal_connect (G_OBJECT (ghidgui->layer_selector), "select_layer",
+  g_signal_connect (G_OBJECT (ghidgui->layer_selector), "select-layer",
                     G_CALLBACK (layer_selector_select_callback),
                     NULL);
-  g_signal_connect (G_OBJECT (ghidgui->layer_selector), "toggle_layer",
+  g_signal_connect (G_OBJECT (ghidgui->layer_selector), "toggle-layer",
                     G_CALLBACK (layer_selector_toggle_callback),
                     NULL);
+  g_signal_connect (G_OBJECT (ghidgui->layer_selector), "rename-layer",
+                    G_CALLBACK (layer_selector_rename_callback),
+                    NULL);
   /* Build main menu */
   ghidgui->menu_bar = ghid_load_menus ();
   gtk_box_pack_start (GTK_BOX (ghidgui->menubar_toolbar_vbox),

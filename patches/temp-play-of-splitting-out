Bottom: ca8dd22b28dc6c465169614f9ee98b7da1f25755
Top:    c4f5876f73cf0f68c07c911103f8051ca3ede76b
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2015-01-07 02:10:23 +0000

Temp play of splitting out hidgl API changes from big refactor


---

diff --git a/src/borast/borast-bentley-ottmann.c b/src/borast/borast-bentley-ottmann.c
index 37a73c9..e998d4d 100644
--- a/src/borast/borast-bentley-ottmann.c
+++ b/src/borast/borast-bentley-ottmann.c
@@ -49,6 +49,7 @@
 
 #include "polygon.h"
 #include <GL/gl.h>
+#include "hid_draw.h"
 #include "hid/common/hidgl.h"
 
 #define _borast_error(x) (x)
@@ -1382,7 +1383,7 @@ poly_area_to_start_events (POLYAREA                *poly,
 
 
 borast_status_t
-bo_poly_to_traps (POLYAREA *poly, borast_traps_t *traps)
+bo_poly_to_traps (hidGC gc, POLYAREA *poly, borast_traps_t *traps)
 {
   int intersections;
   borast_bo_start_event_t stack_events[BORAST_STACK_ARRAY_LENGTH (borast_bo_start_event_t)];
@@ -1445,26 +1446,26 @@ bo_poly_to_traps (POLYAREA *poly, borast_traps_t *traps)
 
 #if 1
     if (x1 == x2) {
-      hidgl_ensure_triangle_space (&buffer, 1);
-      hidgl_add_triangle (&buffer, x1, y1, x3, y3, x4, y4);
+      hidgl_ensure_triangle_space (gc, 1);
+      hidgl_add_triangle (gc, x1, y1, x3, y3, x4, y4);
     } else if (x3 == x4) {
-      hidgl_ensure_triangle_space (&buffer, 1);
-      hidgl_add_triangle (&buffer, x1, y1, x2, y2, x3, y3);
+      hidgl_ensure_triangle_space (gc, 1);
+      hidgl_add_triangle (gc, x1, y1, x2, y2, x3, y3);
     } else {
 #if 0
-      hidgl_ensure_triangle_space (&buffer, 2);
-      hidgl_add_triangle (&buffer, x1, y1, x2, y2, x3, y3);
-      hidgl_add_triangle (&buffer, x3, y3, x4, y4, x1, y1);
+      hidgl_ensure_triangle_space (gc, 2);
+      hidgl_add_triangle (gc, x1, y1, x2, y2, x3, y3);
+      hidgl_add_triangle (gc, x3, y3, x4, y4, x1, y1);
 #endif
-      hidgl_ensure_vertex_space (&buffer, 6);
+      hidgl_ensure_vertex_space (gc, 6);
 
       /* NB: Repeated first virtex to separate from other tri-strip */
-      hidgl_add_vertex_tex (&buffer, x2, y2, 0.0, 0.0);
-      hidgl_add_vertex_tex (&buffer, x2, y2, 0.0, 0.0);
-      hidgl_add_vertex_tex (&buffer, x1, y1, 0.0, 0.0);
-      hidgl_add_vertex_tex (&buffer, x3, y3, 0.0, 0.0);
-      hidgl_add_vertex_tex (&buffer, x4, y4, 0.0, 0.0);
-      hidgl_add_vertex_tex (&buffer, x4, y4, 0.0, 0.0);
+      hidgl_add_vertex_tex (gc, x2, y2, 0.0, 0.0);
+      hidgl_add_vertex_tex (gc, x2, y2, 0.0, 0.0);
+      hidgl_add_vertex_tex (gc, x1, y1, 0.0, 0.0);
+      hidgl_add_vertex_tex (gc, x3, y3, 0.0, 0.0);
+      hidgl_add_vertex_tex (gc, x4, y4, 0.0, 0.0);
+      hidgl_add_vertex_tex (gc, x4, y4, 0.0, 0.0);
       /* NB: Repeated last virtex to separate from other tri-strip */
     }
 #else
@@ -1490,7 +1491,7 @@ bo_poly_to_traps (POLYAREA *poly, borast_traps_t *traps)
 }
 
 borast_status_t
-bo_contour_to_traps (PLINE *contour,  borast_traps_t *traps)
+bo_contour_to_traps (hidGC gc, PLINE *contour,  borast_traps_t *traps)
 {
   int intersections;
   borast_bo_start_event_t stack_events[BORAST_STACK_ARRAY_LENGTH (borast_bo_start_event_t)];
@@ -1546,15 +1547,15 @@ bo_contour_to_traps (PLINE *contour,  borast_traps_t *traps)
 
 #if 1
     if (x1 == x2) {
-      hidgl_ensure_triangle_space (&buffer, 1);
-      hidgl_add_triangle (&buffer, x1, y1, x3, y3, x4, y4);
+      hidgl_ensure_triangle_space (gc, 1);
+      hidgl_add_triangle (gc, x1, y1, x3, y3, x4, y4);
     } else if (x3 == x4) {
-      hidgl_ensure_triangle_space (&buffer, 1);
-      hidgl_add_triangle (&buffer, x1, y1, x2, y2, x3, y3);
+      hidgl_ensure_triangle_space (gc, 1);
+      hidgl_add_triangle (gc, x1, y1, x2, y2, x3, y3);
     } else {
-      hidgl_ensure_triangle_space (&buffer, 2);
-      hidgl_add_triangle (&buffer, x1, y1, x2, y2, x3, y3);
-      hidgl_add_triangle (&buffer, x3, y3, x4, y4, x1, y1);
+      hidgl_ensure_triangle_space (gc, 2);
+      hidgl_add_triangle (gc, x1, y1, x2, y2, x3, y3);
+      hidgl_add_triangle (gc, x3, y3, x4, y4, x1, y1);
     }
 #else
     glBegin (GL_LINES);
@@ -1580,7 +1581,7 @@ bo_contour_to_traps (PLINE *contour,  borast_traps_t *traps)
 
 
 borast_status_t
-bo_contour_to_traps_no_draw (PLINE *contour, borast_traps_t *traps)
+bo_contour_to_traps_no_draw (hidGC gc, PLINE *contour, borast_traps_t *traps)
 {
   int intersections;
   borast_bo_start_event_t stack_events[BORAST_STACK_ARRAY_LENGTH (borast_bo_start_event_t)];
diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index 0c4ac20..9606415 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -99,6 +99,7 @@ PFNGLACTIVETEXTUREARBPROC   glActiveTextureARB   = NULL;
 #include "clip.h"
 
 #include "hid.h"
+#include "hid_draw.h"
 #include "hidgl.h"
 #include "rtree.h"
 #include "sweep.h"
@@ -107,8 +108,7 @@ PFNGLACTIVETEXTUREARBPROC   glActiveTextureARB   = NULL;
 #include <dmalloc.h>
 #endif
 
-triangle_buffer buffer;
-float global_depth = 0;
+
 hidgl_shader *circular_program = NULL;
 hidgl_shader *resistor_program = NULL;
 
@@ -128,48 +128,52 @@ static bool in_context = false;
 
 /* NB: If using VBOs, the caller must ensure the VBO is bound to the GL_ARRAY_BUFFER */
 static void
-hidgl_reset_triangle_array (triangle_buffer *buffer)
+hidgl_reset_triangle_array (hidGC gc)
 {
-  if (buffer->use_map) {
+  hidglGC hidgl_gc = (hidglGC)gc;
+
+  if (hidgl_gc->buffer.use_map) {
     /* Hint to the driver that we're done with the previous buffer contents */
     glBufferData (GL_ARRAY_BUFFER, BUFFER_SIZE, NULL, GL_STREAM_DRAW);
     /* Map the new memory to upload vertices into. */
-    buffer->triangle_array = glMapBuffer (GL_ARRAY_BUFFER, GL_WRITE_ONLY);
+    hidgl_gc->buffer.triangle_array = glMapBuffer (GL_ARRAY_BUFFER, GL_WRITE_ONLY);
   }
 
   /* If mapping the VBO fails (or if we aren't using VBOs) fall back to
    * local storage.
    */
-  if (buffer->triangle_array == NULL) {
-    buffer->triangle_array = malloc (BUFFER_SIZE);
-    buffer->use_map = false;
+  if (hidgl_gc->buffer.triangle_array == NULL) {
+    hidgl_gc->buffer.triangle_array = malloc (BUFFER_SIZE);
+    hidgl_gc->buffer.use_map = false;
   }
 
   /* Don't want this bound for now */
   glBindBuffer (GL_ARRAY_BUFFER, 0);
 
-  buffer->triangle_count = 0;
-  buffer->coord_comp_count = 0;
-  buffer->vertex_count = 0;
+  hidgl_gc->buffer.triangle_count = 0;
+  hidgl_gc->buffer.coord_comp_count = 0;
+  hidgl_gc->buffer.vertex_count = 0;
 }
 
 static void
-hidgl_init_triangle_array (triangle_buffer *buffer)
+hidgl_init_triangle_array (hidGC gc)
 {
+  hidglGC hidgl_gc = (hidglGC)gc;
+
   CHECK_IS_IN_CONTEXT ();
 
-  buffer->use_vbo = true;
-  /* buffer->use_vbo = false; */
+  hidgl_gc->buffer.use_vbo = true;
+  /* hidgl_gc->buffer.use_vbo = false; */
 
-  if (buffer->use_vbo) {
-    glGenBuffers (1, &buffer->vbo_id);
-    glBindBuffer (GL_ARRAY_BUFFER, buffer->vbo_id);
+  if (hidgl_gc->buffer.use_vbo) {
+    glGenBuffers (1, &hidgl_gc->buffer.vbo_id);
+    glBindBuffer (GL_ARRAY_BUFFER, hidgl_gc->buffer.vbo_id);
   }
 
-  if (buffer->vbo_id == 0)
-    buffer->use_vbo = false;
+  if (hidgl_gc->buffer.vbo_id == 0)
+    hidgl_gc->buffer.use_vbo = false;
 
-  buffer->use_map = buffer->use_vbo;
+  hidgl_gc->buffer.use_map = hidgl_gc->buffer.use_vbo;
 
   /* NB: Mapping the whole buffer can be expensive since we ask the driver
    *     to discard previous data and give us a "new" buffer to write into
@@ -180,52 +184,55 @@ hidgl_init_triangle_array (triangle_buffer *buffer)
    *     into a temporary buffer and queues a GPU copy of the uploaded data
    *     for when the "main" buffer has finished rendering.
    */
-  buffer->use_map = false;
+  hidgl_gc->buffer.use_map = false;
 
-  buffer->triangle_array = NULL;
-  hidgl_reset_triangle_array (buffer);
+  hidgl_gc->buffer.triangle_array = NULL;
+  hidgl_reset_triangle_array (gc);
 }
 
 static void
-hidgl_finish_triangle_array (triangle_buffer *buffer)
+hidgl_finish_triangle_array (hidGC gc)
 {
-  if (buffer->use_map) {
-    glBindBuffer (GL_ARRAY_BUFFER, buffer->vbo_id);
+  hidglGC hidgl_gc = (hidglGC)gc;
+
+  if (hidgl_gc->buffer.use_map) {
+    glBindBuffer (GL_ARRAY_BUFFER, hidgl_gc->buffer.vbo_id);
     glUnmapBuffer (GL_ARRAY_BUFFER);
     glBindBuffer (GL_ARRAY_BUFFER, 0);
   } else {
-    free (buffer->triangle_array);
+    free (hidgl_gc->buffer.triangle_array);
   }
 
-  if (buffer->use_vbo) {
-    glDeleteBuffers (1, &buffer->vbo_id);
-    buffer->vbo_id = 0;
+  if (hidgl_gc->buffer.use_vbo) {
+    glDeleteBuffers (1, &hidgl_gc->buffer.vbo_id);
+    hidgl_gc->buffer.vbo_id = 0;
   }
 }
 
 void
-hidgl_flush_triangles (triangle_buffer *buffer)
+hidgl_flush_triangles (hidGC gc)
 {
+  hidglGC hidgl_gc = (hidglGC)gc;
   GLfloat *data_pointer = NULL;
 
   CHECK_IS_IN_CONTEXT ();
-  if (buffer->vertex_count == 0)
+  if (hidgl_gc->buffer.vertex_count == 0)
     return;
 
-  if (buffer->use_vbo) {
-    glBindBuffer (GL_ARRAY_BUFFER, buffer->vbo_id);
+  if (hidgl_gc->buffer.use_vbo) {
+    glBindBuffer (GL_ARRAY_BUFFER, hidgl_gc->buffer.vbo_id);
 
-    if (buffer->use_map) {
+    if (hidgl_gc->buffer.use_map) {
       glUnmapBuffer (GL_ARRAY_BUFFER);
-      buffer->triangle_array = NULL;
+      hidgl_gc->buffer.triangle_array = NULL;
     } else {
       glBufferData (GL_ARRAY_BUFFER,
-                    BUFFER_STRIDE * buffer->vertex_count,
-                    buffer->triangle_array,
+                    BUFFER_STRIDE * hidgl_gc->buffer.vertex_count,
+                    hidgl_gc->buffer.triangle_array,
                     GL_STREAM_DRAW);
     }
   } else {
-    data_pointer = buffer->triangle_array;
+    data_pointer = hidgl_gc->buffer.triangle_array;
   }
 
   glTexCoordPointer (2, GL_FLOAT, BUFFER_STRIDE, data_pointer + 3);
@@ -233,22 +240,24 @@ hidgl_flush_triangles (triangle_buffer *buffer)
 
   glEnableClientState (GL_TEXTURE_COORD_ARRAY);
   glEnableClientState (GL_VERTEX_ARRAY);
-  glDrawArrays (GL_TRIANGLE_STRIP, 0, buffer->vertex_count);
+  glDrawArrays (GL_TRIANGLE_STRIP, 0, hidgl_gc->buffer.vertex_count);
 #if 0
   glPushAttrib (GL_CURRENT_BIT);
   glColor4f (1., 1., 1., 1.);
-  glDrawArrays (GL_LINE_STRIP, 0, buffer->vertex_count);
+  glDrawArrays (GL_LINE_STRIP, 0, hidgl_gc->buffer.vertex_count);
   glPopAttrib ();
 #endif
   glDisableClientState (GL_VERTEX_ARRAY);
   glDisableClientState (GL_TEXTURE_COORD_ARRAY);
 
-  hidgl_reset_triangle_array (buffer);
+  hidgl_reset_triangle_array (gc);
 }
 
 void
-hidgl_ensure_vertex_space (triangle_buffer *buffer, int count)
+hidgl_ensure_vertex_space (hidGC gc, int count)
 {
+  hidglGC hidgl_gc = (hidglGC)gc;
+
   CHECK_IS_IN_CONTEXT ();
   if (count > 3 * TRIANGLE_ARRAY_SIZE)
     {
@@ -257,27 +266,31 @@ hidgl_ensure_vertex_space (triangle_buffer *buffer, int count)
                        count, 3 * TRIANGLE_ARRAY_SIZE);
       exit (1);
     }
-  if (count > 3 * TRIANGLE_ARRAY_SIZE - buffer->vertex_count)
-    hidgl_flush_triangles (buffer);
+  if (count > 3 * TRIANGLE_ARRAY_SIZE - hidgl_gc->buffer.vertex_count)
+    hidgl_flush_triangles (gc);
 }
 
 void
-hidgl_ensure_triangle_space (triangle_buffer *buffer, int count)
+hidgl_ensure_triangle_space (hidGC gc, int count)
 {
   CHECK_IS_IN_CONTEXT ();
   /* NB: 5 = 3 + 2 extra vertices to separate from other triangle strips */
-  hidgl_ensure_vertex_space (buffer, count * 5);
+  hidgl_ensure_vertex_space (gc, count * 5);
 }
 
 void
-hidgl_set_depth (float depth)
+hidgl_set_depth (hidGC gc, float depth)
 {
-  global_depth = depth;
+  hidglGC hidgl_gc = (hidglGC)gc;
+
+  hidgl_gc->depth = depth;
 }
 
 void
-hidgl_draw_grid (BoxType *drawn_area)
+hidgl_draw_grid (hidGC gc)
 {
+  hidglGC hidgl_gc = (hidglGC)gc;
+
   static GLfloat *points = 0;
   static int npoints = 0;
   Coord x1, y1, x2, y2, n, i;
@@ -286,10 +299,10 @@ hidgl_draw_grid (BoxType *drawn_area)
   if (!Settings.DrawGrid)
     return;
 
-  x1 = GridFit (MAX (0, drawn_area->X1), PCB->Grid, PCB->GridOffsetX);
-  y1 = GridFit (MAX (0, drawn_area->Y1), PCB->Grid, PCB->GridOffsetY);
-  x2 = GridFit (MIN (PCB->MaxWidth, drawn_area->X2), PCB->Grid, PCB->GridOffsetX);
-  y2 = GridFit (MIN (PCB->MaxHeight, drawn_area->Y2), PCB->Grid, PCB->GridOffsetY);
+  x1 = GridFit (MAX (0, gc->clip_box->X1), PCB->Grid, PCB->GridOffsetX);
+  y1 = GridFit (MAX (0, gc->clip_box->Y1), PCB->Grid, PCB->GridOffsetY);
+  x2 = GridFit (MIN (PCB->MaxWidth,  gc->clip_box->X2), PCB->Grid, PCB->GridOffsetX);
+  y2 = GridFit (MIN (PCB->MaxHeight, gc->clip_box->Y2), PCB->Grid, PCB->GridOffsetY);
 
   if (x1 > x2)
     {
@@ -319,7 +332,7 @@ hidgl_draw_grid (BoxType *drawn_area)
   for (x = x1; x <= x2; x += PCB->Grid)
     {
       points[3 * n + 0] = x;
-      points[3 * n + 2] = global_depth;
+      points[3 * n + 2] = hidgl_gc->depth;
       n++;
     }
   for (y = y1; y <= y2; y += PCB->Grid)
@@ -345,30 +358,30 @@ int calc_slices (float pix_radius, float sweep_angle)
   return (int)ceilf (slices);
 }
 
-static void draw_cap (Coord width, int x, int y, double angle)
+static void draw_cap (hidGC gc, Coord width, int x, int y, double angle)
 {
   float radius = width / 2.;
 
   CHECK_IS_IN_CONTEXT ();
 
-  hidgl_ensure_vertex_space (&buffer, 6);
+  hidgl_ensure_vertex_space (gc, 6);
 
   /* FIXME: Should draw an offset rectangle at the appropriate angle,
    *        avoiding relying on the subcompositing between layers to
    *        stop us creatign an artaefact by drawing a full circle.
    */
   /* NB: Repeated first virtex to separate from other tri-strip */
-  hidgl_add_vertex_tex (&buffer, x - radius, y - radius, -1.0, -1.0);
-  hidgl_add_vertex_tex (&buffer, x - radius, y - radius, -1.0, -1.0);
-  hidgl_add_vertex_tex (&buffer, x - radius, y + radius, -1.0,  1.0);
-  hidgl_add_vertex_tex (&buffer, x + radius, y - radius,  1.0, -1.0);
-  hidgl_add_vertex_tex (&buffer, x + radius, y + radius,  1.0,  1.0);
-  hidgl_add_vertex_tex (&buffer, x + radius, y + radius,  1.0,  1.0);
+  hidgl_add_vertex_tex (gc, x - radius, y - radius, -1.0, -1.0);
+  hidgl_add_vertex_tex (gc, x - radius, y - radius, -1.0, -1.0);
+  hidgl_add_vertex_tex (gc, x - radius, y + radius, -1.0,  1.0);
+  hidgl_add_vertex_tex (gc, x + radius, y - radius,  1.0, -1.0);
+  hidgl_add_vertex_tex (gc, x + radius, y + radius,  1.0,  1.0);
+  hidgl_add_vertex_tex (gc, x + radius, y + radius,  1.0,  1.0);
   /* NB: Repeated last virtex to separate from other tri-strip */
 }
 
 void
-hidgl_draw_line (int cap, Coord width, Coord x1, Coord y1, Coord x2, Coord y2, double scale)
+hidgl_draw_line (hidGC gc, int cap, Coord width, Coord x1, Coord y1, Coord x2, Coord y2, double scale)
 {
   double deltax, deltay, length;
   float wdx, wdy;
@@ -421,42 +434,42 @@ hidgl_draw_line (int cap, Coord width, Coord x1, Coord y1, Coord x2, Coord y2, d
     {
       if (length == 0)
         {
-          hidgl_fill_circle (x1, y1, width / 2.);
+          hidgl_fill_circle (gc, x1, y1, width / 2.);
         }
       else
         {
           float capx = deltax * width / 2. / length;
           float capy = deltay * width / 2. / length;
 
-          hidgl_ensure_vertex_space (&buffer, 10);
+          hidgl_ensure_vertex_space (gc, 10);
 
           /* NB: Repeated first virtex to separate from other tri-strip */
-          hidgl_add_vertex_tex (&buffer, x1 - wdx - capx, y1 - wdy - capy, -1.0, -1.0);
-          hidgl_add_vertex_tex (&buffer, x1 - wdx - capx, y1 - wdy - capy, -1.0, -1.0);
-          hidgl_add_vertex_tex (&buffer, x1 + wdx - capx, y1 + wdy - capy, -1.0,  1.0);
-          hidgl_add_vertex_tex (&buffer, x1 - wdx,        y1 - wdy,         0.0, -1.0);
-          hidgl_add_vertex_tex (&buffer, x1 + wdx,        y1 + wdy,         0.0,  1.0);
-
-          hidgl_add_vertex_tex (&buffer, x2 - wdx,        y2 - wdy,         0.0, -1.0);
-          hidgl_add_vertex_tex (&buffer, x2 + wdx,        y2 + wdy,         0.0,  1.0);
-          hidgl_add_vertex_tex (&buffer, x2 - wdx + capx, y2 - wdy + capy,  1.0, -1.0);
-          hidgl_add_vertex_tex (&buffer, x2 + wdx + capx, y2 + wdy + capy,  1.0,  1.0);
-          hidgl_add_vertex_tex (&buffer, x2 + wdx + capx, y2 + wdy + capy,  1.0,  1.0);
+          hidgl_add_vertex_tex (gc, x1 - wdx - capx, y1 - wdy - capy, -1.0, -1.0);
+          hidgl_add_vertex_tex (gc, x1 - wdx - capx, y1 - wdy - capy, -1.0, -1.0);
+          hidgl_add_vertex_tex (gc, x1 + wdx - capx, y1 + wdy - capy, -1.0,  1.0);
+          hidgl_add_vertex_tex (gc, x1 - wdx,        y1 - wdy,         0.0, -1.0);
+          hidgl_add_vertex_tex (gc, x1 + wdx,        y1 + wdy,         0.0,  1.0);
+
+          hidgl_add_vertex_tex (gc, x2 - wdx,        y2 - wdy,         0.0, -1.0);
+          hidgl_add_vertex_tex (gc, x2 + wdx,        y2 + wdy,         0.0,  1.0);
+          hidgl_add_vertex_tex (gc, x2 - wdx + capx, y2 - wdy + capy,  1.0, -1.0);
+          hidgl_add_vertex_tex (gc, x2 + wdx + capx, y2 + wdy + capy,  1.0,  1.0);
+          hidgl_add_vertex_tex (gc, x2 + wdx + capx, y2 + wdy + capy,  1.0,  1.0);
           /* NB: Repeated last virtex to separate from other tri-strip */
         }
     }
   else
     {
-      hidgl_ensure_vertex_space (&buffer, 6);
+      hidgl_ensure_vertex_space (gc, 6);
 
       /* NB: Repeated first virtex to separate from other tri-strip */
-      hidgl_add_vertex_tex (&buffer, x1 - wdx, y1 - wdy, 0.0, -1.0);
-      hidgl_add_vertex_tex (&buffer, x1 - wdx, y1 - wdy, 0.0, -1.0);
-      hidgl_add_vertex_tex (&buffer, x1 + wdx, y1 + wdy, 0.0,  1.0);
+      hidgl_add_vertex_tex (gc, x1 - wdx, y1 - wdy, 0.0, -1.0);
+      hidgl_add_vertex_tex (gc, x1 - wdx, y1 - wdy, 0.0, -1.0);
+      hidgl_add_vertex_tex (gc, x1 + wdx, y1 + wdy, 0.0,  1.0);
 
-      hidgl_add_vertex_tex (&buffer, x2 - wdx, y2 - wdy, 0.0, -1.0);
-      hidgl_add_vertex_tex (&buffer, x2 + wdx, y2 + wdy, 0.0,  1.0);
-      hidgl_add_vertex_tex (&buffer, x2 + wdx, y2 + wdy, 0.0,  1.0);
+      hidgl_add_vertex_tex (gc, x2 - wdx, y2 - wdy, 0.0, -1.0);
+      hidgl_add_vertex_tex (gc, x2 + wdx, y2 + wdy, 0.0,  1.0);
+      hidgl_add_vertex_tex (gc, x2 + wdx, y2 + wdy, 0.0,  1.0);
       /* NB: Repeated last virtex to separate from other tri-strip */
     }
 }
@@ -464,7 +477,7 @@ hidgl_draw_line (int cap, Coord width, Coord x1, Coord y1, Coord x2, Coord y2, d
 #define MIN_SLICES_PER_ARC 6
 #define MAX_SLICES_PER_ARC 360
 void
-hidgl_draw_arc (Coord width, Coord x, Coord y, Coord rx, Coord ry,
+hidgl_draw_arc (hidGC gc, Coord width, Coord x, Coord y, Coord rx, Coord ry,
                 Angle start_angle, Angle delta_angle, double scale)
 {
   float last_inner_x, last_inner_y;
@@ -507,7 +520,7 @@ hidgl_draw_arc (Coord width, Coord x, Coord y, Coord rx, Coord ry,
   if (slices > MAX_SLICES_PER_ARC)
     slices = MAX_SLICES_PER_ARC;
 
-  hidgl_ensure_triangle_space (&buffer, 2 * slices);
+  hidgl_ensure_triangle_space (gc, 2 * slices);
 
   angle_incr_rad = delta_angle_rad / (float)slices;
 
@@ -520,12 +533,12 @@ hidgl_draw_arc (Coord width, Coord x, Coord y, Coord rx, Coord ry,
     sin_ang = sinf (start_angle_rad + ((float)(i)) * angle_incr_rad);
     inner_x = -inner_r * cos_ang + x;  inner_y = inner_r * sin_ang + y;
     outer_x = -outer_r * cos_ang + x;  outer_y = outer_r * sin_ang + y;
-    hidgl_add_triangle (&buffer, last_inner_x, last_inner_y,
-                                 last_outer_x, last_outer_y,
-                                 outer_x, outer_y);
-    hidgl_add_triangle (&buffer, last_inner_x, last_inner_y,
-                                 inner_x, inner_y,
-                                 outer_x, outer_y);
+    hidgl_add_triangle (gc, last_inner_x, last_inner_y,
+                            last_outer_x, last_outer_y,
+                            outer_x, outer_y);
+    hidgl_add_triangle (gc, last_inner_x, last_inner_y,
+                            inner_x, inner_y,
+                            outer_x, outer_y);
     last_inner_x = inner_x;  last_inner_y = inner_y;
     last_outer_x = outer_x;  last_outer_y = outer_y;
   }
@@ -534,41 +547,43 @@ hidgl_draw_arc (Coord width, Coord x, Coord y, Coord rx, Coord ry,
   if (hairline)
     return;
 
-  draw_cap (width, x + rx * -cosf (start_angle_rad),
-                   y + rx *  sinf (start_angle_rad),
-                   start_angle);
-  draw_cap (width, x + rx * -cosf (start_angle_rad + delta_angle_rad),
-                   y + rx *  sinf (start_angle_rad + delta_angle_rad),
-                   start_angle + delta_angle + 180.);
+  draw_cap (gc, width, x + rx * -cosf (start_angle_rad),
+                       y + rx *  sinf (start_angle_rad),
+                       start_angle);
+  draw_cap (gc, width, x + rx * -cosf (start_angle_rad + delta_angle_rad),
+                       y + rx *  sinf (start_angle_rad + delta_angle_rad),
+                       start_angle + delta_angle + 180.);
 }
 
 void
-hidgl_draw_rect (Coord x1, Coord y1, Coord x2, Coord y2)
+hidgl_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
+  hidglGC hidgl_gc = (hidglGC)gc;
+
   CHECK_IS_IN_CONTEXT ();
   glBegin (GL_LINE_LOOP);
-  glVertex3f (x1, y1, global_depth);
-  glVertex3f (x1, y2, global_depth);
-  glVertex3f (x2, y2, global_depth);
-  glVertex3f (x2, y1, global_depth);
+  glVertex3f (x1, y1, hidgl_gc->depth);
+  glVertex3f (x1, y2, hidgl_gc->depth);
+  glVertex3f (x2, y2, hidgl_gc->depth);
+  glVertex3f (x2, y1, hidgl_gc->depth);
   glEnd ();
 }
 
 
 void
-hidgl_fill_circle (Coord x, Coord y, Coord radius)
+hidgl_fill_circle (hidGC gc, Coord x, Coord y, Coord radius)
 {
   CHECK_IS_IN_CONTEXT ();
 
-  hidgl_ensure_vertex_space (&buffer, 6);
+  hidgl_ensure_vertex_space (gc, 6);
 
   /* NB: Repeated first virtex to separate from other tri-strip */
-  hidgl_add_vertex_tex (&buffer, x - radius, y - radius, -1.0, -1.0);
-  hidgl_add_vertex_tex (&buffer, x - radius, y - radius, -1.0, -1.0);
-  hidgl_add_vertex_tex (&buffer, x - radius, y + radius, -1.0,  1.0);
-  hidgl_add_vertex_tex (&buffer, x + radius, y - radius,  1.0, -1.0);
-  hidgl_add_vertex_tex (&buffer, x + radius, y + radius,  1.0,  1.0);
-  hidgl_add_vertex_tex (&buffer, x + radius, y + radius,  1.0,  1.0);
+  hidgl_add_vertex_tex (gc, x - radius, y - radius, -1.0, -1.0);
+  hidgl_add_vertex_tex (gc, x - radius, y - radius, -1.0, -1.0);
+  hidgl_add_vertex_tex (gc, x - radius, y + radius, -1.0,  1.0);
+  hidgl_add_vertex_tex (gc, x + radius, y - radius,  1.0, -1.0);
+  hidgl_add_vertex_tex (gc, x + radius, y + radius,  1.0,  1.0);
+  hidgl_add_vertex_tex (gc, x + radius, y + radius,  1.0,  1.0);
   /* NB: Repeated last virtex to separate from other tri-strip */
 }
 
@@ -629,10 +644,13 @@ myBegin (GLenum type)
   triangle_comp_idx = 0;
 }
 
+static hidGC nasty_tesselator_gc = NULL;
+
 static void CALLBACK
 myVertex (GLdouble *vertex_data)
 {
   static GLfloat triangle_vertices [2 * 3];
+  hidGC gc = nasty_tesselator_gc;
 
   if (tessVertexType == GL_TRIANGLE_STRIP ||
       tessVertexType == GL_TRIANGLE_FAN)
@@ -645,8 +663,8 @@ myVertex (GLdouble *vertex_data)
         }
       else
         {
-          hidgl_ensure_triangle_space (&buffer, 1);
-          hidgl_add_triangle (&buffer,
+          hidgl_ensure_triangle_space (gc, 1);
+          hidgl_add_triangle (gc,
                               triangle_vertices [0], triangle_vertices [1],
                               triangle_vertices [2], triangle_vertices [3],
                               vertex_data [0], vertex_data [1]);
@@ -669,8 +687,8 @@ myVertex (GLdouble *vertex_data)
       stashed_vertices ++;
       if (stashed_vertices == 3)
         {
-          hidgl_ensure_triangle_space (&buffer, 1);
-          hidgl_add_triangle (&buffer,
+          hidgl_ensure_triangle_space (gc, 1);
+          hidgl_add_triangle (gc,
                               triangle_vertices [0], triangle_vertices [1],
                               triangle_vertices [2], triangle_vertices [3],
                               triangle_vertices [4], triangle_vertices [5]);
@@ -690,7 +708,7 @@ myFreeCombined ()
 }
 
 void
-hidgl_fill_polygon (int n_coords, Coord *x, Coord *y)
+hidgl_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
 {
   int i;
   GLUtesselator *tobj;
@@ -702,6 +720,8 @@ hidgl_fill_polygon (int n_coords, Coord *x, Coord *y)
 
   vertices = malloc (sizeof(GLdouble) * n_coords * 3);
 
+  nasty_tesselator_gc = gc;
+
   tobj = gluNewTess ();
   gluTessCallback(tobj, GLU_TESS_BEGIN,   (_GLUfuncptr)myBegin);
   gluTessCallback(tobj, GLU_TESS_VERTEX,  (_GLUfuncptr)myVertex);
@@ -725,6 +745,7 @@ hidgl_fill_polygon (int n_coords, Coord *x, Coord *y)
 
   myFreeCombined ();
   free (vertices);
+  nasty_tesselator_gc = NULL;
 }
 
 static inline void
@@ -742,15 +763,16 @@ stash_vertex (PLINE *contour, int *vertex_comp,
 }
 
 static void
-fill_contour (PLINE *contour)
+fill_contour (hidGC gc, PLINE *contour)
 {
+  hidglGC hidgl_gc = (hidglGC)gc;
   int i;
   int vertex_comp;
   borast_traps_t traps;
 
   /* If the contour is round, then call hidgl_fill_circle to draw it. */
   if (contour->is_round) {
-    hidgl_fill_circle (contour->cx, contour->cy, contour->radius);
+    hidgl_fill_circle (gc, contour->cx, contour->cy, contour->radius);
     return;
   }
 
@@ -760,7 +782,7 @@ fill_contour (PLINE *contour)
     int x1, x2, x3, x4, y_top, y_bot;
 
     _borast_traps_init (&traps);
-    bo_contour_to_traps_no_draw (contour, &traps);
+    bo_contour_to_traps_no_draw (gc, contour, &traps);
 
     tristrip_space = 0;
 
@@ -805,28 +827,28 @@ fill_contour (PLINE *contour)
 
       if (x1 == x2) {
         /* NB: Repeated first virtex to separate from other tri-strip */
-        stash_vertex (contour, &vertex_comp, x1, y_top, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x1, y_top, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x3, y_bot, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x4, y_bot, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x4, y_bot, global_depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x1, y_top, hidgl_gc->depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x1, y_top, hidgl_gc->depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x3, y_bot, hidgl_gc->depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x4, y_bot, hidgl_gc->depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x4, y_bot, hidgl_gc->depth, 0.0, 0.0);
         /* NB: Repeated last virtex to separate from other tri-strip */
       } else if (x3 == x4) {
         /* NB: Repeated first virtex to separate from other tri-strip */
-        stash_vertex (contour, &vertex_comp, x1, y_top, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x1, y_top, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x2, y_top, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x3, y_bot, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x3, y_bot, global_depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x1, y_top, hidgl_gc->depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x1, y_top, hidgl_gc->depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x2, y_top, hidgl_gc->depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x3, y_bot, hidgl_gc->depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x3, y_bot, hidgl_gc->depth, 0.0, 0.0);
         /* NB: Repeated last virtex to separate from other tri-strip */
       } else {
         /* NB: Repeated first virtex to separate from other tri-strip */
-        stash_vertex (contour, &vertex_comp, x2, y_top, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x2, y_top, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x3, y_bot, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x1, y_top, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x4, y_bot, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x4, y_bot, global_depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x2, y_top, hidgl_gc->depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x2, y_top, hidgl_gc->depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x3, y_bot, hidgl_gc->depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x1, y_top, hidgl_gc->depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x4, y_bot, hidgl_gc->depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x4, y_bot, hidgl_gc->depth, 0.0, 0.0);
         /* NB: Repeated last virtex to separate from other tri-strip */
       }
     }
@@ -837,14 +859,14 @@ fill_contour (PLINE *contour)
   if (contour->tristrip_num_vertices == 0)
     return;
 
-  hidgl_ensure_vertex_space (&buffer, contour->tristrip_num_vertices);
+  hidgl_ensure_vertex_space (gc, contour->tristrip_num_vertices);
 
 #if MEMCPY_VERTEX_DATA
-  memcpy (&buffer.triangle_array[buffer.coord_comp_count],
+  memcpy (&hidgl_gc->buffer.triangle_array[buffer.coord_comp_count],
           contour->tristrip_vertices,
           sizeof (float) * 5 * contour->tristrip_num_vertices);
-  buffer.coord_comp_count += 5 * contour->tristrip_num_vertices;
-  buffer.vertex_count += contour->tristrip_num_vertices;
+  hidgl_gc->buffer.coord_comp_count += 5 * contour->tristrip_num_vertices;
+  hidgl_gc->buffer.vertex_count += contour->tristrip_num_vertices;
 
 #else
   vertex_comp = 0;
@@ -852,7 +874,7 @@ fill_contour (PLINE *contour)
     int x, y;
     x = contour->tristrip_vertices[vertex_comp++];
     y = contour->tristrip_vertices[vertex_comp++];
-    hidgl_add_vertex_tex (&buffer, x, y, 0.0, 0.0);
+    hidgl_add_vertex_tex (gc, x, y, 0.0, 0.0);
   }
 #endif
 
@@ -862,13 +884,14 @@ static int
 do_hole (const BoxType *b, void *cl)
 {
   PLINE *curc = (PLINE *) b;
+  hidGC gc = cl;
 
   /* Ignore the outer contour - we draw it first explicitly*/
   if (curc->Flags.orient == PLF_DIR) {
     return 0;
   }
 
-  fill_contour (curc);
+  fill_contour (gc, curc);
   return 1;
 }
 
@@ -878,21 +901,17 @@ polygon_contains_user_holes (PolygonType *polygon)
   return (polygon->HoleIndexN > 0);
 }
 
-
-static GLint stencil_bits;
-static int dirty_bits = 0;
-static int assigned_bits = 0;
-
 static void
-fill_polyarea (POLYAREA *pa, const BoxType *clip_box, bool use_new_stencil)
+fill_polyarea (hidGC gc, POLYAREA *pa, bool use_new_stencil)
 {
-  int stencil_bit;
+  hidglGC hidgl_gc = (hidglGC)gc;
+  int stencil_bit = -1; /* XXX: Compiler thinks we might be using this uninitialised */
 
   CHECK_IS_IN_CONTEXT ();
 
   /* Special case non-holed polygons which don't require a stencil bit */
   if (pa->contour_tree->size == 1) {
-    fill_contour (pa->contours);
+    fill_contour (gc, pa->contours);
     return;
   }
 
@@ -901,7 +920,7 @@ fill_polyarea (POLYAREA *pa, const BoxType *clip_box, bool use_new_stencil)
    */
   if (use_new_stencil)
     {
-      stencil_bit = hidgl_assign_clear_stencil_bit ();
+      stencil_bit = hidgl_assign_clear_stencil_bit (gc);
       if (!stencil_bit)
         {
           printf ("hidgl_fill_pcb_polygon: No free stencil bits, aborting polygon\n");
@@ -911,7 +930,7 @@ fill_polyarea (POLYAREA *pa, const BoxType *clip_box, bool use_new_stencil)
     }
 
   /* Flush out any existing geoemtry to be rendered */
-  hidgl_flush_triangles (&buffer);
+  hidgl_flush_triangles (gc);
 
   glPushAttrib (GL_STENCIL_BUFFER_BIT |                 /* Resave the stencil write-mask etc.., and */
                 GL_COLOR_BUFFER_BIT |                   /* the colour buffer write mask etc.. for part way restore */
@@ -938,35 +957,35 @@ fill_polyarea (POLYAREA *pa, const BoxType *clip_box, bool use_new_stencil)
 
   /* Drawing operations now set our reference bit in the stencil buffer */
 
-  r_search (pa->contour_tree, clip_box, NULL, do_hole, NULL);
-  hidgl_flush_triangles (&buffer);
+  r_search (pa->contour_tree, gc->clip_box, NULL, do_hole, gc);
+  hidgl_flush_triangles (gc);
 
-  glPopAttrib ();                               /* Restore the colour and stencil buffer write-mask etc.. */
-  glPushAttrib (GL_STENCIL_BUFFER_BIT);         /* Save the stencil op and function */
-  glEnable (GL_STENCIL_TEST);                   /* Enable the stencil test, just in case it wasn't already on */
+  glPopAttrib ();                                   /* Restore the colour and stencil buffer write-mask etc.. */
+  glPushAttrib (GL_STENCIL_BUFFER_BIT);             /* Save the stencil op and function */
+  glEnable (GL_STENCIL_TEST);                       /* Enable the stencil test, just in case it wasn't already on */
 
-  glStencilOp (GL_KEEP, GL_KEEP, GL_INVERT);    /* This allows us to toggle the bit on the subcompositing bitplane */
-                                                /* If the stencil test has passed, we know that bit is 0, so we're */
-                                                /* effectively just setting it to 1. */
-  glStencilFunc (GL_GEQUAL, 0, assigned_bits);  /* Pass stencil test if all assigned bits clear, */
-                                                /* reference is all assigned bits so we set */
-                                                /* any bits permitted by the stencil writemask */
+  glStencilOp (GL_KEEP, GL_KEEP, GL_INVERT);        /* This allows us to toggle the bit on the subcompositing bitplane */
+                                                    /* If the stencil test has passed, we know that bit is 0, so we're */
+                                                    /* effectively just setting it to 1. */
+  glStencilFunc (GL_GEQUAL, 0, hidgl_gc->assigned_bits);  /* Pass stencil test if all assigned bits clear, */
+                                                    /* reference is all assigned bits so we set */
+                                                    /* any bits permitted by the stencil writemask */
 
   /* Drawing operations as masked to areas where the stencil buffer is '0' */
 
   /* Draw the polygon outer */
-  fill_contour (pa->contours);
-  hidgl_flush_triangles (&buffer);
+  fill_contour (gc, pa->contours);
+  hidgl_flush_triangles (gc);
 
   /* Unassign our stencil buffer bit */
   if (use_new_stencil)
-    hidgl_return_stencil_bit (stencil_bit);
+    hidgl_return_stencil_bit (gc, stencil_bit);
 
   glPopAttrib ();                               /* Restore the stencil buffer op and function */
 }
 
 void
-hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box)
+hidgl_fill_pcb_polygon (hidGC gc, PolygonType *poly)
 {
   bool use_new_stencil;
 
@@ -976,30 +995,30 @@ hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box)
   use_new_stencil = polygon_contains_user_holes (poly) ||
                     TEST_FLAG (FULLPOLYFLAG, poly);
 
-  fill_polyarea (poly->Clipped, clip_box, use_new_stencil);
+  fill_polyarea (gc, poly->Clipped, use_new_stencil);
 
   if (TEST_FLAG (FULLPOLYFLAG, poly))
     {
       POLYAREA *pa;
 
       for (pa = poly->Clipped->f; pa != poly->Clipped; pa = pa->f)
-        fill_polyarea (pa, clip_box, use_new_stencil);
+        fill_polyarea (gc, pa, use_new_stencil);
     }
 }
 
 void
-hidgl_fill_rect (Coord x1, Coord y1, Coord x2, Coord y2)
+hidgl_fill_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
   CHECK_IS_IN_CONTEXT ();
-  hidgl_ensure_vertex_space (&buffer, 6);
+  hidgl_ensure_vertex_space (gc, 6);
 
   /* NB: Repeated first virtex to separate from other tri-strip */
-  hidgl_add_vertex_tex (&buffer, x1, y1, 0.0, 0.0);
-  hidgl_add_vertex_tex (&buffer, x1, y1, 0.0, 0.0);
-  hidgl_add_vertex_tex (&buffer, x1, y2, 0.0, 0.0);
-  hidgl_add_vertex_tex (&buffer, x2, y1, 0.0, 0.0);
-  hidgl_add_vertex_tex (&buffer, x2, y2, 0.0, 0.0);
-  hidgl_add_vertex_tex (&buffer, x2, y2, 0.0, 0.0);
+  hidgl_add_vertex_tex (gc, x1, y1, 0.0, 0.0);
+  hidgl_add_vertex_tex (gc, x1, y1, 0.0, 0.0);
+  hidgl_add_vertex_tex (gc, x1, y2, 0.0, 0.0);
+  hidgl_add_vertex_tex (gc, x2, y1, 0.0, 0.0);
+  hidgl_add_vertex_tex (gc, x2, y2, 0.0, 0.0);
+  hidgl_add_vertex_tex (gc, x2, y2, 0.0, 0.0);
   /* NB: Repeated last virtex to separate from other tri-strip */
 }
 
@@ -1087,22 +1106,23 @@ hidgl_init (void)
 
 #endif
 
-
   CHECK_IS_IN_CONTEXT ();
-  glGetIntegerv (GL_STENCIL_BITS, &stencil_bits);
+#if 0
+  glGetIntegerv (GL_STENCIL_BITS, &hidgl_gc->stencil_bits);
 
-  if (stencil_bits == 0)
+  if (hidgl_gc->stencil_bits == 0)
     {
       printf ("No stencil bits available.\n"
               "Cannot mask polygon holes or subcomposite layers\n");
       /* TODO: Flag this to the HID so it can revert to the dicer? */
     }
-  else if (stencil_bits == 1)
+  else if (hidgl_gc->stencil_bits == 1)
     {
       printf ("Only one stencil bitplane avilable\n"
               "Cannot use stencil buffer to sub-composite layers.\n");
       /* Do we need to disable that somewhere? */
     }
+#endif
 
   if (!hidgl_shader_init_shaders ()) {
     printf ("Failed to initialise shader support\n");
@@ -1116,6 +1136,38 @@ done:
 }
 
 void
+hidgl_init_gc (hidGC gc)
+{
+  hidglGC hidgl_gc = (hidglGC)gc;
+
+  hidgl_gc->depth = 0.0;
+  hidgl_reset_stencil_usage (gc);
+  hidgl_init_triangle_array (gc);
+
+  CHECK_IS_IN_CONTEXT ();
+#if 1
+  glGetIntegerv (GL_STENCIL_BITS, &hidgl_gc->stencil_bits);
+
+  if (hidgl_gc->stencil_bits == 0)
+    {
+      printf ("No stencil bits available.\n"
+              "Cannot mask polygon holes or subcomposite layers\n");
+      /* TODO: Flag this to the HID so it can revert to the dicer? */
+    }
+  else if (hidgl_gc->stencil_bits == 1)
+    {
+      printf ("Only one stencil bitplane avilable\n"
+              "Cannot use stencil buffer to sub-composite layers.\n");
+      /* Do we need to disable that somewhere? */
+    }
+#endif
+
+//  hidgl_gc->depth = 0.0;
+//  hidgl_reset_stencil_usage (gc);
+//  hidgl_init_triangle_array (gc);
+}
+
+void
 hidgl_start_render (void)
 {
   if (in_context)
@@ -1123,84 +1175,100 @@ hidgl_start_render (void)
 
   in_context = true;
   hidgl_init ();
-  hidgl_init_triangle_array (&buffer);
+
+#if 0
+#warning FUBAR NULL gc
+  gc = NULL;
+
+  hidgl_init_triangle_array (gc);
+#endif
   hidgl_shader_activate (circular_program);
 }
 
 void
-hidgl_finish_render (void)
+hidgl_finish_render (hidGC gc)
 {
   if (!in_context)
     fprintf (stderr, "hidgl: hidgl_finish_render() - Not currently in rendering context!\n");
 
-  hidgl_finish_triangle_array (&buffer);
+  hidgl_finish_triangle_array (gc);
   hidgl_shader_activate (NULL);
   in_context = false;
 }
 
 int
-hidgl_stencil_bits (void)
+hidgl_stencil_bits (hidGC gc)
 {
-  return stencil_bits;
+  hidglGC hidgl_gc = (hidglGC)gc;
+
+  return hidgl_gc->stencil_bits;
 }
 
 static void
-hidgl_clean_unassigned_stencil (void)
+hidgl_clean_unassigned_stencil (hidGC gc)
 {
+  hidglGC hidgl_gc = (hidglGC)gc;
+
   CHECK_IS_IN_CONTEXT ();
   glPushAttrib (GL_STENCIL_BUFFER_BIT);
-  glStencilMask (~assigned_bits);
+  glStencilMask (~hidgl_gc->assigned_bits);
   glClearStencil (0);
   glClear (GL_STENCIL_BUFFER_BIT);
   glPopAttrib ();
 }
 
 int
-hidgl_assign_clear_stencil_bit (void)
+hidgl_assign_clear_stencil_bit (hidGC gc)
 {
-  int stencil_bitmask = (1 << stencil_bits) - 1;
+  hidglGC hidgl_gc = (hidglGC)gc;
+
+  int stencil_bitmask = (1 << hidgl_gc->stencil_bits) - 1;
   int test;
   int first_dirty = 0;
 
-  if (assigned_bits == stencil_bitmask)
+  if (hidgl_gc->assigned_bits == stencil_bitmask)
     {
       printf ("No more stencil bits available, total of %i already assigned\n",
-              stencil_bits);
+              hidgl_gc->stencil_bits);
       return 0;
     }
 
   /* Look for a bitplane we don't have to clear */
   for (test = 1; test & stencil_bitmask; test <<= 1)
     {
-      if (!(test & dirty_bits))
+      if (!(test & hidgl_gc->dirty_bits))
         {
-          assigned_bits |= test;
-          dirty_bits |= test;
+          hidgl_gc->assigned_bits |= test;
+          hidgl_gc->dirty_bits |= test;
           return test;
         }
-      else if (!first_dirty && !(test & assigned_bits))
+      else if (!first_dirty && !(test & hidgl_gc->assigned_bits))
         {
           first_dirty = test;
         }
     }
 
   /* Didn't find any non dirty planes. Clear those dirty ones which aren't in use */
-  hidgl_clean_unassigned_stencil ();
-  assigned_bits |= first_dirty;
-  dirty_bits = assigned_bits;
+  hidgl_clean_unassigned_stencil (gc);
+  hidgl_gc->assigned_bits |= first_dirty;
+  hidgl_gc->dirty_bits = hidgl_gc->assigned_bits;
 
   return first_dirty;
 }
 
 void
-hidgl_return_stencil_bit (int bit)
+hidgl_return_stencil_bit (hidGC gc, int bit)
 {
-  assigned_bits &= ~bit;
+  hidglGC hidgl_gc = (hidglGC)gc;
+
+  hidgl_gc->assigned_bits &= ~bit;
 }
 
 void
-hidgl_reset_stencil_usage (void)
+hidgl_reset_stencil_usage (hidGC gc)
 {
-  assigned_bits = 0;
-  dirty_bits = 0;
+  hidglGC hidgl_gc = (hidglGC)gc;
+
+  hidgl_gc->assigned_bits = 0;
+  hidgl_gc->dirty_bits = 0;
 }
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index 235b0f9..e70e3d3 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -36,103 +36,124 @@ typedef struct {
   bool use_map;
 } triangle_buffer;
 
-extern triangle_buffer buffer;
-extern float global_depth;
+typedef struct hidgl_gc_struct {
+  struct hid_gc_struct gc; /* Parent */
+
+  /* Triangle management */
+  triangle_buffer buffer;
+
+  /* Stencil management */
+  GLint stencil_bits;
+  int dirty_bits;
+  int assigned_bits;
+
+  float depth;
+
+} *hidglGC;
 
 extern hidgl_shader *circular_program;
 extern hidgl_shader *resistor_program;
 
-void hidgl_flush_triangles (triangle_buffer *buffer);
-void hidgl_ensure_vertex_space (triangle_buffer *buffer, int count);
-void hidgl_ensure_triangle_space (triangle_buffer *buffer, int count);
+void hidgl_flush_triangles (hidGC gc);
+void hidgl_ensure_vertex_space (hidGC gc, int count);
+void hidgl_ensure_triangle_space (hidGC gc, int count);
 
 static inline void
-hidgl_add_vertex_3D_tex (triangle_buffer *buffer,
+hidgl_add_vertex_3D_tex (hidGC gc,
                          GLfloat x, GLfloat y, GLfloat z,
                          GLfloat s, GLfloat t)
 {
-  buffer->triangle_array [buffer->coord_comp_count++] = x;
-  buffer->triangle_array [buffer->coord_comp_count++] = y;
-  buffer->triangle_array [buffer->coord_comp_count++] = z;
-  buffer->triangle_array [buffer->coord_comp_count++] = s;
-  buffer->triangle_array [buffer->coord_comp_count++] = t;
-  buffer->vertex_count++;
+  hidglGC hidgl_gc = (hidglGC)gc;
+
+  hidgl_gc->buffer.triangle_array [hidgl_gc->buffer.coord_comp_count++] = x;
+  hidgl_gc->buffer.triangle_array [hidgl_gc->buffer.coord_comp_count++] = y;
+  hidgl_gc->buffer.triangle_array [hidgl_gc->buffer.coord_comp_count++] = z;
+  hidgl_gc->buffer.triangle_array [hidgl_gc->buffer.coord_comp_count++] = s;
+  hidgl_gc->buffer.triangle_array [hidgl_gc->buffer.coord_comp_count++] = t;
+  hidgl_gc->buffer.vertex_count++;
 }
 
 static inline void
-hidgl_add_vertex_tex (triangle_buffer *buffer,
+hidgl_add_vertex_tex (hidGC gc,
                       GLfloat x, GLfloat y,
                       GLfloat s, GLfloat t)
 {
-  hidgl_add_vertex_3D_tex (buffer, x, y, global_depth, s, t);
+  hidglGC hidgl_gc = (hidglGC)gc;
+
+  hidgl_add_vertex_3D_tex (gc, x, y, hidgl_gc->depth, s, t);
 }
 
 
 static inline void
-hidgl_add_triangle_3D_tex (triangle_buffer *buffer,
+hidgl_add_triangle_3D_tex (hidGC gc,
                            GLfloat x1, GLfloat y1, GLfloat z1, GLfloat s1, GLfloat t1,
                            GLfloat x2, GLfloat y2, GLfloat z2, GLfloat s2, GLfloat t2,
                            GLfloat x3, GLfloat y3, GLfloat z3, GLfloat s3, GLfloat t3)
 {
   /* NB: Repeated first virtex to separate from other tri-strip */
-  hidgl_add_vertex_3D_tex (buffer, x1, y1, z1, s1, t1);
-  hidgl_add_vertex_3D_tex (buffer, x1, y1, z1, s1, t1);
-  hidgl_add_vertex_3D_tex (buffer, x2, y2, z2, s2, t2);
-  hidgl_add_vertex_3D_tex (buffer, x3, y3, z3, s3, t3);
-  hidgl_add_vertex_3D_tex (buffer, x3, y3, z3, s3, t3);
+  hidgl_add_vertex_3D_tex (gc, x1, y1, z1, s1, t1);
+  hidgl_add_vertex_3D_tex (gc, x1, y1, z1, s1, t1);
+  hidgl_add_vertex_3D_tex (gc, x2, y2, z2, s2, t2);
+  hidgl_add_vertex_3D_tex (gc, x3, y3, z3, s3, t3);
+  hidgl_add_vertex_3D_tex (gc, x3, y3, z3, s3, t3);
   /* NB: Repeated last virtex to separate from other tri-strip */
 }
 
 static inline void
-hidgl_add_triangle_3D (triangle_buffer *buffer,
+hidgl_add_triangle_3D (hidGC gc,
                        GLfloat x1, GLfloat y1, GLfloat z1,
                        GLfloat x2, GLfloat y2, GLfloat z2,
                        GLfloat x3, GLfloat y3, GLfloat z3)
 {
-  hidgl_add_triangle_3D_tex (buffer, x1, y1, z1, 0., 0.,
-                                     x2, y2, z2, 0., 0.,
-                                     x3, y3, z3, 0., 0.);
+  hidgl_add_triangle_3D_tex (gc, x1, y1, z1, 0., 0.,
+                                 x2, y2, z2, 0., 0.,
+                                 x3, y3, z3, 0., 0.);
 }
 
 static inline void
-hidgl_add_triangle_tex (triangle_buffer *buffer,
+hidgl_add_triangle_tex (hidGC gc,
                         GLfloat x1, GLfloat y1, GLfloat s1, GLfloat t1,
                         GLfloat x2, GLfloat y2, GLfloat s2, GLfloat t2,
                         GLfloat x3, GLfloat y3, GLfloat s3, GLfloat t3)
 {
-  hidgl_add_triangle_3D_tex (buffer, x1, y1, global_depth, s1, t1,
-                                     x2, y2, global_depth, s2, t2,
-                                     x3, y3, global_depth, s3, t3);
+  hidglGC hidgl_gc = (hidglGC)gc;
+
+  hidgl_add_triangle_3D_tex (gc, x1, y1, hidgl_gc->depth, s1, t1,
+                                 x2, y2, hidgl_gc->depth, s2, t2,
+                                 x3, y3, hidgl_gc->depth, s3, t3);
 }
 
 static inline void
-hidgl_add_triangle (triangle_buffer *buffer,
+hidgl_add_triangle (hidGC gc,
                     GLfloat x1, GLfloat y1,
                     GLfloat x2, GLfloat y2,
                     GLfloat x3, GLfloat y3)
 {
-  hidgl_add_triangle_3D (buffer, x1, y1, global_depth,
-                                 x2, y2, global_depth,
-                                 x3, y3, global_depth);
+  hidglGC hidgl_gc = (hidglGC)gc;
+
+  hidgl_add_triangle_3D (gc, x1, y1, hidgl_gc->depth,
+                             x2, y2, hidgl_gc->depth,
+                             x3, y3, hidgl_gc->depth);
 }
 
-void hidgl_draw_grid (BoxType *drawn_area);
-void hidgl_set_depth (float depth);
-void hidgl_draw_line (int cap, Coord width, Coord x1, Coord y1, Coord x2, Coord y2, double scale);
-void hidgl_draw_arc (Coord width, Coord vx, Coord vy, Coord vrx, Coord vry, Angle start_angle, Angle delta_angle, double scale);
-void hidgl_draw_rect (Coord x1, Coord y1, Coord x2, Coord y2);
-void hidgl_fill_circle (Coord vx, Coord vy, Coord vr);
-void hidgl_fill_polygon (int n_coords, Coord *x, Coord *y);
-void hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box);
-void hidgl_fill_rect (Coord x1, Coord y1, Coord x2, Coord y2);
+void hidgl_draw_grid (hidGC gc);
+void hidgl_set_depth (hidGC gc, float depth);
+void hidgl_draw_line (hidGC gc, int cap, Coord width, Coord x1, Coord y1, Coord x2, Coord y2, double scale);
+void hidgl_draw_arc (hidGC gc, Coord width, Coord vx, Coord vy, Coord vrx, Coord vry, Angle start_angle, Angle delta_angle, double scale);
+void hidgl_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2);
+void hidgl_fill_circle (hidGC gc, Coord vx, Coord vy, Coord vr);
+void hidgl_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y);
+void hidgl_fill_pcb_polygon (hidGC gc, PolygonType *poly);
+void hidgl_fill_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2);
 
 void hidgl_init (void);
+void hidgl_init_gc (hidGC gc);
 void hidgl_start_render (void);
-void hidgl_finish_render (void);
-int hidgl_stencil_bits (void);
-int hidgl_assign_clear_stencil_bit (void);
-void hidgl_return_stencil_bit (int bit);
-void hidgl_reset_stencil_usage (void);
+void hidgl_finish_render (hidGC gc);
+int hidgl_stencil_bits (hidGC gc);
+int hidgl_assign_clear_stencil_bit (hidGC gc);
+void hidgl_return_stencil_bit (hidGC gc, int bit);
+void hidgl_reset_stencil_usage (hidGC gc);
 
 /* hidgl_pacakge_acy_resistor.c */
 void hidgl_draw_acy_resistor (ElementType *element, float surface_depth, float board_thickness);
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index fabbc5b..f0f52f9 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -97,7 +97,7 @@ typedef struct render_priv {
 
 typedef struct gtk_gc_struct
 {
-  struct hid_gc_struct hid_gc; /* Parent */
+  struct hidgl_gc_struct hidgl_gc; /* Parent */
 
   const char *colorname;
   double alpha_mult;
@@ -232,18 +232,18 @@ compute_depth (int group)
 }
 
 static void
-start_subcomposite (void)
+start_subcomposite (hidGC gc)
 {
   render_priv *priv = gport->render_priv;
   int stencil_bit;
 
   /* Flush out any existing geoemtry to be rendered */
-  hidgl_flush_triangles (&buffer);
+  hidgl_flush_triangles (gc);
 
   glEnable (GL_STENCIL_TEST);                                 /* Enable Stencil test */
   glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);                 /* Stencil pass => replace stencil value (with 1) */
 
-  stencil_bit = hidgl_assign_clear_stencil_bit();             /* Get a new (clean) bitplane to stencil with */
+  stencil_bit = hidgl_assign_clear_stencil_bit(gc);           /* Get a new (clean) bitplane to stencil with */
   glStencilMask (stencil_bit);                                /* Only write to our subcompositing stencil bitplane */
   glStencilFunc (GL_GREATER, stencil_bit, stencil_bit);       /* Pass stencil test if our assigned bit is clear */
 
@@ -251,14 +251,14 @@ start_subcomposite (void)
 }
 
 static void
-end_subcomposite (void)
+end_subcomposite (hidGC gc)
 {
   render_priv *priv = gport->render_priv;
 
   /* Flush out any existing geoemtry to be rendered */
-  hidgl_flush_triangles (&buffer);
+  hidgl_flush_triangles (gc);
 
-  hidgl_return_stencil_bit (priv->subcomposite_stencil_bit);  /* Relinquish any bitplane we previously used */
+  hidgl_return_stencil_bit (gc, priv->subcomposite_stencil_bit);  /* Relinquish any bitplane we previously used */
 
   glStencilMask (0);
   glStencilFunc (GL_ALWAYS, 0, 0);                            /* Always pass stencil test */
@@ -283,7 +283,7 @@ is_layer_group_visible (int group)
 }
 
 int
-ghid_set_layer (const char *name, int group, int empty)
+ghid_set_layer (hidGC gc, const char *name, int group, int empty)
 {
   render_priv *priv = gport->render_priv;
   bool group_visible = false;
@@ -330,21 +330,21 @@ ghid_set_layer (const char *name, int group, int empty)
 	}
     }
 
-  end_subcomposite ();
+  end_subcomposite (gc);
 
   if (group_visible && subcomposite)
-    start_subcomposite ();
+    start_subcomposite (gc);
 
   /* Drawing is already flushed by {start,end}_subcomposite */
-  hidgl_set_depth (compute_depth (group));
+  hidgl_set_depth (gc, compute_depth (group));
 
   return group_visible;
 }
 
 static void
-ghid_end_layer (void)
+ghid_end_layer (hidGC gc)
 {
-  end_subcomposite ();
+  end_subcomposite (gc);
 }
 
 void
@@ -362,6 +362,8 @@ ghid_make_gc (void)
   gc->hid = &ghid_hid;
   gc->hid_draw = &ghid_graphics;
 
+  hidgl_init_gc (gc);
+
   gtk_gc->colorname = Settings.BackgroundColor;
   gtk_gc->alpha_mult = 1.0;
   gtk_gc->brightness = 1.0;
@@ -371,7 +373,7 @@ ghid_make_gc (void)
 }
 
 static void
-ghid_draw_grid (BoxType *drawn_area)
+ghid_draw_grid (hidGC gc)
 {
   if (Vz (PCB->Grid) < MIN_GRID_DISTANCE)
     return;
@@ -393,7 +395,7 @@ ghid_draw_grid (BoxType *drawn_area)
              gport->grid_color.green / 65535.,
              gport->grid_color.blue / 65535.);
 
-  hidgl_draw_grid (drawn_area);
+  hidgl_draw_grid (gc);
 
   glDisable (GL_COLOR_LOGIC_OP);
   glEnable (GL_STENCIL_TEST);
@@ -514,7 +516,7 @@ ghid_use_mask (hidGC gc, enum mask_mode mode)
     return;
 
   /* Flush out any existing geoemtry to be rendered */
-  hidgl_flush_triangles (&buffer);
+  hidgl_flush_triangles (gc);
 
   switch (mode)
     {
@@ -527,7 +529,7 @@ ghid_use_mask (hidGC gc, enum mask_mode mode)
       glColorMask (0, 0, 0, 0);                             /* Disable writting in color buffer */
       glDepthMask (GL_FALSE);
       glEnable (GL_STENCIL_TEST);                           /* Enable Stencil test */
-      stencil_bit = hidgl_assign_clear_stencil_bit();       /* Get a new (clean) bitplane to stencil with */
+      stencil_bit = hidgl_assign_clear_stencil_bit (gc);    /* Get a new (clean) bitplane to stencil with */
       glStencilFunc (GL_ALWAYS, stencil_bit, stencil_bit);  /* Always pass stencil test, write stencil_bit */
       glStencilMask (stencil_bit);                          /* Only write to our subcompositing stencil bitplane */
       glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);           /* Stencil pass => replace stencil value (with 1) */
@@ -543,7 +545,7 @@ ghid_use_mask (hidGC gc, enum mask_mode mode)
 
     case HID_MASK_OFF:
       /* Disable stenciling */
-      hidgl_return_stencil_bit (stencil_bit);     /* Relinquish any bitplane we previously used */
+      hidgl_return_stencil_bit (gc, stencil_bit); /* Relinquish any bitplane we previously used */
       glDisable (GL_STENCIL_TEST);                /* Disable Stencil test */
       break;
     }
@@ -699,7 +701,7 @@ set_gl_color_for_gc (hidGC gc)
   g = g * gtk_gc->saturation + luminance * (1.0 - gtk_gc->saturation);
   b = b * gtk_gc->saturation + luminance * (1.0 - gtk_gc->saturation);
 
-  hidgl_flush_triangles (&buffer);
+  hidgl_flush_triangles (gc);
   glColor4d (r, g, b, a);
 }
 
@@ -807,7 +809,7 @@ ghid_draw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
   gtkGC gtk_gc = (gtkGC)gc;
   USE_GC (gc);
 
-  hidgl_draw_line (gtk_gc->cap, gtk_gc->width, x1, y1, x2, y2, gport->view.coord_per_px);
+  hidgl_draw_line (gc, gtk_gc->cap, gtk_gc->width, x1, y1, x2, y2, gport->view.coord_per_px);
 }
 
 void
@@ -817,7 +819,7 @@ ghid_draw_arc (hidGC gc, Coord cx, Coord cy, Coord xradius, Coord yradius,
   gtkGC gtk_gc = (gtkGC)gc;
   USE_GC (gc);
 
-  hidgl_draw_arc (gtk_gc->width, cx, cy, xradius, yradius,
+  hidgl_draw_arc (gc, gtk_gc->width, cx, cy, xradius, yradius,
                   start_angle, delta_angle, gport->view.coord_per_px);
 }
 
@@ -826,7 +828,7 @@ ghid_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
   USE_GC (gc);
 
-  hidgl_draw_rect (x1, y1, x2, y2);
+  hidgl_draw_rect (gc, x1, y1, x2, y2);
 }
 
 
@@ -835,7 +837,7 @@ ghid_fill_circle (hidGC gc, Coord cx, Coord cy, Coord radius)
 {
   USE_GC (gc);
 
-  hidgl_fill_circle (cx, cy, radius);
+  hidgl_fill_circle (gc, cx, cy, radius);
 }
 
 
@@ -844,15 +846,15 @@ ghid_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
 {
   USE_GC (gc);
 
-  hidgl_fill_polygon (n_coords, x, y);
+  hidgl_fill_polygon (gc, n_coords, x, y);
 }
 
 void
-ghid_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+ghid_fill_pcb_polygon (hidGC gc, PolygonType *poly)
 {
   USE_GC (gc);
 
-  hidgl_fill_pcb_polygon (poly, clip_box);
+  hidgl_fill_pcb_polygon (gc, poly);
 }
 
 void
@@ -872,7 +874,7 @@ ghid_fill_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
   USE_GC (gc);
 
-  hidgl_fill_rect (x1, y1, x2, y2);
+  hidgl_fill_rect (gc, x1, y1, x2, y2);
 }
 
 void
@@ -1164,42 +1166,42 @@ set_object_color (AnyObjectType *obj, char *warn_color, char *selected_color,
   else if (found_color     != NULL && TEST_FLAG (FOUNDFLAG,     obj)) color = found_color;
   else                                                                color = normal_color;
 
-  ghid_set_lock_effects (Output.fgGC, obj);
-  hid_draw_set_color (Output.fgGC, color);
+  ghid_set_lock_effects (gc, obj);
+  hid_draw_set_color (gc, color);
 }
 
 static void
-set_layer_object_color (LayerType *layer, AnyObjectType *obj)
+set_layer_object_color (hidGC gc, LayerType *layer, AnyObjectType *obj)
 {
-  set_object_color (obj, NULL, layer->SelectedColor, PCB->ConnectedColor, PCB->FoundColor, layer->Color);
+  set_object_color (gc, obj, NULL, layer->SelectedColor, PCB->ConnectedColor, PCB->FoundColor, layer->Color);
 }
 
 static void
-set_pv_inlayer_color (PinType *pv, LayerType *layer, int type)
+set_pv_inlayer_color (hidGC gc, PinType *pv, LayerType *layer, int type)
 {
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *) pv);
+  ghid_set_lock_effects (gc, (AnyObjectType *) pv);
 
-  if (TEST_FLAG (WARNFLAG, pv))           hid_draw_set_color (Output.fgGC, PCB->WarnColor);
-  else if (TEST_FLAG (SELECTEDFLAG, pv))  hid_draw_set_color (Output.fgGC, (type == VIA_TYPE) ? PCB->ViaSelectedColor
-                                                                                              : PCB->PinSelectedColor);
-  else if (TEST_FLAG (CONNECTEDFLAG, pv)) hid_draw_set_color (Output.fgGC, PCB->ConnectedColor);
-  else if (TEST_FLAG (FOUNDFLAG, pv))     hid_draw_set_color (Output.fgGC, PCB->FoundColor);
+  if (TEST_FLAG (WARNFLAG, pv))           hid_draw_set_color (gc, PCB->WarnColor);
+  else if (TEST_FLAG (SELECTEDFLAG, pv))  hid_draw_set_color (gc, (type == VIA_TYPE) ? PCB->ViaSelectedColor
+                                                                                     : PCB->PinSelectedColor);
+  else if (TEST_FLAG (CONNECTEDFLAG, pv)) hid_draw_set_color (gc, PCB->ConnectedColor);
+  else if (TEST_FLAG (FOUNDFLAG, pv))     hid_draw_set_color (gc, PCB->FoundColor);
   else
     {
-      int top_group = GetLayerGroupNumberBySide (TOP_SIDE);
+      int top_group    = GetLayerGroupNumberBySide (TOP_SIDE);
       int bottom_group = GetLayerGroupNumberBySide (BOTTOM_SIDE);
-      int this_group      = GetLayerGroupNumberByPointer (layer);
+      int this_group   = GetLayerGroupNumberByPointer (layer);
 
       if (this_group == top_group || this_group == bottom_group)
-        hid_draw_set_color (Output.fgGC, (SWAP_IDENT == (this_group == bottom_group)) ?
-                                         PCB->ViaColor : PCB->InvisibleObjectsColor);
+        hid_draw_set_color (gc, (SWAP_IDENT == (this_group == bottom_group)) ?
+                                PCB->ViaColor : PCB->InvisibleObjectsColor);
       else
-        hid_draw_set_color (Output.fgGC, layer->Color);
+        hid_draw_set_color (gc, layer->Color);
     }
 }
 
 static void
-_draw_pv_name (PinType *pv)
+_draw_pv_name (hidGC gc, PinType *pv)
 {
   BoxType box;
   bool vert;
@@ -1223,8 +1225,8 @@ _draw_pv_name (PinType *pv)
       box.Y1 = pv->Y - pv->Thickness    / 2 + Settings.PinoutTextOffsetY;
     }
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pv);
-  hid_draw_set_color (Output.fgGC, PCB->PinNameColor);
+  ghid_set_lock_effects (gc, (AnyObjectType *)pv);
+  hid_draw_set_color (gc, PCB->PinNameColor);
 
   text.Flags = NoFlags ();
   /* Set font height to approx 56% of pin thickness */
@@ -1233,46 +1235,47 @@ _draw_pv_name (PinType *pv)
   text.Y = box.Y1;
   text.Direction = vert ? 1 : 0;
 
-  hid_draw_pcb_text (Output.fgGC, &text, 0);
+  hid_draw_pcb_text (gc, &text, 0);
 }
 
 static void
-_draw_pv (PinType *pv, bool draw_hole)
+_draw_pv (hidGC gc, PinType *pv, bool draw_hole)
 {
   if (TEST_FLAG (THINDRAWFLAG, PCB))
     {
-      hid_draw__thin_pcb_pv (Output.fgGC, pv, false);
+      hid_draw__thin_pcb_pv (gc, pv, false);
       if (draw_hole)
-        hid_draw__thin_pcb_pv_hole (Output.fgGC, pv);
+        hid_draw__thin_pcb_pv_hole (gc, pv);
     }
   else
     {
-      hid_draw__fill_pcb_pv (Output.fgGC, pv, false);
+      hid_draw__fill_pcb_pv (gc, pv, false);
       if (draw_hole)
         hid_draw__fill_pcb_pv_hole (Output.bgGC, pv);
     }
 
   if (!TEST_FLAG (HOLEFLAG, pv) && TEST_FLAG (DISPLAYNAMEFLAG, pv))
-    _draw_pv_name (pv);
+    _draw_pv_name (gc, pv);
 }
 
 static void
-draw_pin (PinType *pin, bool draw_hole)
+draw_pin (hidGC gc, PinType *pin, bool draw_hole)
 {
-  set_object_color ((AnyObjectType *) pin, PCB->WarnColor, PCB->PinSelectedColor,
+  set_object_color (gc, (AnyObjectType *) pin, PCB->WarnColor, PCB->PinSelectedColor,
                     PCB->ConnectedColor, PCB->FoundColor, PCB->PinColor);
 
-  _draw_pv (pin, draw_hole);
+  _draw_pv (gc, pin, draw_hole);
 }
 
 static int
 pin_callback (const BoxType * b, void *cl)
 {
   PinType *pin = (PinType *) b;
+  hidGC gc = cl;
 
   if (!TEST_FLAG (HOLEFLAG, pin) && TEST_FLAG (DISPLAYNAMEFLAG, pin))
-    _draw_pv_name (pin);
-  draw_pin (pin, TEST_FLAG (THINDRAWFLAG, PCB));
+    _draw_pv_name (gc, pin);
+  draw_pin (gc, pin, TEST_FLAG (THINDRAWFLAG, PCB));
   return 1;
 }
 
@@ -1280,46 +1283,59 @@ static int
 pin_name_callback (const BoxType * b, void *cl)
 {
   PinType *pin = (PinType *) b;
+  hidGC gc = cl;
 
   if (!TEST_FLAG (HOLEFLAG, pin) && TEST_FLAG (DISPLAYNAMEFLAG, pin))
-    _draw_pv_name (pin);
+    _draw_pv_name (gc, pin);
   return 1;
 }
 
+struct layer_info
+{
+  hidGC gc;
+  LayerType *layer;
+};
+
 static int
 pin_inlayer_callback (const BoxType * b, void *cl)
 {
-  set_pv_inlayer_color ((PinType *) b, cl, PIN_TYPE);
-  _draw_pv ((PinType *) b, false);
+  struct layer_info *info = cl;
+
+  set_pv_inlayer_color (info->gc, (PinType *) b, info->layer, PIN_TYPE);
+  _draw_pv (info->gc, (PinType *) b, false);
   return 1;
 }
 
 static void
-draw_via (PinType *via, bool draw_hole)
+draw_via (hidGC gc, PinType *via, bool draw_hole)
 {
-  set_object_color ((AnyObjectType *) via, PCB->WarnColor, PCB->ViaSelectedColor,
+  set_object_color (gc, (AnyObjectType *) via, PCB->WarnColor, PCB->ViaSelectedColor,
                     PCB->ConnectedColor, PCB->FoundColor, PCB->ViaColor);
 
-  _draw_pv (via, draw_hole);
+  _draw_pv (gc, via, draw_hole);
 }
 
 static int
 via_callback (const BoxType * b, void *cl)
 {
-  draw_via ((PinType *)b, TEST_FLAG (THINDRAWFLAG, PCB));
+  hidGC gc = cl;
+
+  draw_via (gc, (PinType *)b, TEST_FLAG (THINDRAWFLAG, PCB));
   return 1;
 }
 
 static int
 via_inlayer_callback (const BoxType * b, void *cl)
 {
-  set_pv_inlayer_color ((PinType *) b, cl, VIA_TYPE);
-  _draw_pv ((PinType *) b, TEST_FLAG (THINDRAWFLAG, PCB));
+  struct layer_info *info = cl;
+
+  set_pv_inlayer_color (info->gc, (PinType *) b, info->layer, VIA_TYPE);
+  _draw_pv (info->gc, (PinType *) b, TEST_FLAG (THINDRAWFLAG, PCB));
   return 1;
 }
 
 static void
-draw_pad_name (PadType *pad)
+draw_pad_name (hidGC gc, PadType *pad)
 {
   BoxType box;
   bool vert;
@@ -1348,8 +1364,8 @@ draw_pad_name (PadType *pad)
       box.Y1 += Settings.PinoutTextOffsetY;
     }
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pad);
-  hid_draw_set_color (Output.fgGC, PCB->PinNameColor);
+  ghid_set_lock_effects (gc, (AnyObjectType *)pad);
+  hid_draw_set_color (gc, PCB->PinNameColor);
 
   text.Flags = NoFlags ();
   /* Set font height to approx 90% of pad thickness */
@@ -1358,7 +1374,7 @@ draw_pad_name (PadType *pad)
   text.Y = box.Y1;
   text.Direction = vert ? 1 : 0;
 
-  hid_draw_pcb_text (Output.fgGC, &text, 0);
+  hid_draw_pcb_text (gc, &text, 0);
 }
 
 static void
@@ -1375,29 +1391,34 @@ _draw_pad (hidGC gc, PadType *pad, bool clear, bool mask)
 }
 
 static void
-draw_pad (PadType *pad)
+draw_pad (hidGC gc, PadType *pad)
 {
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pad);
-  set_object_color ((AnyObjectType *)pad, PCB->WarnColor,
+  ghid_set_lock_effects (gc, (AnyObjectType *)pad);
+  set_object_color (gc, (AnyObjectType *)pad, PCB->WarnColor,
                     PCB->PinSelectedColor, PCB->ConnectedColor, PCB->FoundColor,
                     FRONT (pad) ? PCB->PinColor : PCB->InvisibleObjectsColor);
 
-  _draw_pad (Output.fgGC, pad, false, false);
+  _draw_pad (gc, pad, false, false);
 
   if (TEST_FLAG (DISPLAYNAMEFLAG, pad))
-    draw_pad_name (pad);
+    draw_pad_name (gc, pad);
 }
 
+struct side_info {
+  hidGC gc;
+  int side;
+};
+
 static int
 pad_callback (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *) b;
-  int *side = cl;
+  struct side_info *info = cl;
 
-  if (ON_SIDE (pad, *side)) {
+  if (ON_SIDE (pad, info->side)) {
     if (TEST_FLAG (DISPLAYNAMEFLAG, pad))
-      draw_pad_name (pad);
-    draw_pad (pad);
+      draw_pad_name (info->gc, pad);
+    draw_pad (info->gc, pad);
   }
   return 1;
 }
@@ -1407,7 +1428,9 @@ static int
 hole_callback (const BoxType * b, void *cl)
 {
   PinType *pv = (PinType *) b;
-  int plated = cl ? *(int *) cl : -1;
+  hidGC gc = cl;
+//  int plated = cl ? *(int *) cl : -1;
+  int plated = -1;
 
   if ((plated == 0 && !TEST_FLAG (HOLEFLAG, pv)) ||
       (plated == 1 &&  TEST_FLAG (HOLEFLAG, pv)))
@@ -1417,10 +1440,9 @@ hole_callback (const BoxType * b, void *cl)
     {
       if (!TEST_FLAG (HOLEFLAG, pv))
         {
-          hid_draw_set_line_cap (Output.fgGC, Round_Cap);
-          hid_draw_set_line_width (Output.fgGC, 0);
-          hid_draw_arc (Output.fgGC, pv->X, pv->Y,
-                        pv->DrillingHole / 2, pv->DrillingHole / 2, 0, 360);
+          hid_draw_set_line_cap (gc, Round_Cap);
+          hid_draw_set_line_width (gc, 0);
+          hid_draw_arc (gc, pv->X, pv->Y, pv->DrillingHole / 2, pv->DrillingHole / 2, 0, 360);
         }
     }
   else
@@ -1428,14 +1450,13 @@ hole_callback (const BoxType * b, void *cl)
 
   if (TEST_FLAG (HOLEFLAG, pv))
     {
-      ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pv);
-      set_object_color ((AnyObjectType *) pv, PCB->WarnColor,
+      ghid_set_lock_effects (gc, (AnyObjectType *)pv);
+      set_object_color (gc, (AnyObjectType *) pv, PCB->WarnColor,
                         PCB->ViaSelectedColor, NULL, NULL, Settings.BlackColor);
 
-      hid_draw_set_line_cap (Output.fgGC, Round_Cap);
-      hid_draw_set_line_width (Output.fgGC, 0);
-      hid_draw_arc (Output.fgGC, pv->X, pv->Y,
-                    pv->DrillingHole / 2, pv->DrillingHole / 2, 0, 360);
+      hid_draw_set_line_cap (gc, Round_Cap);
+      hid_draw_set_line_width (gc, 0);
+      hid_draw_arc (gc, pv->X, pv->Y, pv->DrillingHole / 2, pv->DrillingHole / 2, 0, 360);
     }
   return 1;
 }
@@ -1443,92 +1464,86 @@ hole_callback (const BoxType * b, void *cl)
 static int
 line_callback (const BoxType * b, void *cl)
 {
-  LayerType *layer = cl;
   LineType *line = (LineType *)b;
+  struct layer_info *info = cl;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *) line);
-  set_layer_object_color (layer, (AnyObjectType *) line);
-  hid_draw_pcb_line (Output.fgGC, line);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *) line);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) line);
+  hid_draw_pcb_line (info->gc, line);
   return 1;
 }
 
 static int
 arc_callback (const BoxType * b, void *cl)
 {
-  LayerType *layer = cl;
   ArcType *arc = (ArcType *)b;
+  struct layer_info *info = cl;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *) arc);
-  set_layer_object_color (layer, (AnyObjectType *) arc);
-  hid_draw_pcb_arc (Output.fgGC, arc);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *) arc);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) arc);
+  hid_draw_pcb_arc (info->gc, arc);
   return 1;
 }
 
 static int
 text_callback (const BoxType * b, void *cl)
 {
-  LayerType *layer = cl;
   TextType *text = (TextType *)b;
+  struct layer_info *info = cl;
   int min_silk_line;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)text);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *)text);
   if (TEST_FLAG (SELECTEDFLAG, text))
-    hid_draw_set_color (Output.fgGC, layer->SelectedColor);
+    hid_draw_set_color (info->gc, info->layer->SelectedColor);
   else
-    hid_draw_set_color (Output.fgGC, layer->Color);
-  if (layer == &PCB->Data->SILKLAYER ||
-      layer == &PCB->Data->BACKSILKLAYER)
+    hid_draw_set_color (info->gc, info->layer->Color);
+  if (info->layer == &PCB->Data->SILKLAYER ||
+      info->layer == &PCB->Data->BACKSILKLAYER)
     min_silk_line = PCB->minSlk;
   else
     min_silk_line = PCB->minWid;
-  hid_draw_pcb_text (Output.fgGC, text, min_silk_line);
+  hid_draw_pcb_text (info->gc, text, min_silk_line);
   return 1;
 }
 
-struct poly_info
-{
-  LayerType *layer;
-  const BoxType *drawn_area;
-};
-
 static int
 poly_callback (const BoxType * b, void *cl)
 {
-  struct poly_info *i = (struct poly_info *) cl;
   PolygonType *polygon = (PolygonType *) b;
+  struct layer_info *info = cl;
 
-  set_layer_object_color (i->layer, (AnyObjectType *) polygon);
-  hid_draw_pcb_polygon (Output.fgGC, polygon, i->drawn_area);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) polygon);
+  hid_draw_pcb_polygon (info->gc, polygon);
   return 1;
 }
 
 static int
 poly_callback_no_clear (const BoxType * b, void *cl)
 {
-  struct poly_info *i = (struct poly_info *) cl;
   PolygonType *polygon = (PolygonType *) b;
+  struct layer_info *info = cl;
 
   if (TEST_FLAG (CLEARPOLYFLAG, polygon))
     return 0;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *) polygon);
-  set_layer_object_color (i->layer, (AnyObjectType *) polygon);
-  hid_draw_pcb_polygon (Output.fgGC, polygon, i->drawn_area);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *) polygon);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) polygon);
+  hid_draw_pcb_polygon (info->gc, polygon);
   return 1;
 }
 
 static int
 poly_callback_clearing (const BoxType * b, void *cl)
 {
-  struct poly_info *i = (struct poly_info *) cl;
   PolygonType *polygon = (PolygonType *) b;
+  struct layer_info *info = cl;
 
   if (!TEST_FLAG (CLEARPOLYFLAG, polygon))
     return 0;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *) polygon);
-  set_layer_object_color (i->layer, (AnyObjectType *) polygon);
-  hid_draw_pcb_polygon (Output.fgGC, polygon, i->drawn_area);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *) polygon);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) polygon);
+  hid_draw_pcb_polygon (info->gc, polygon);
   return 1;
 }
 
@@ -1547,8 +1562,9 @@ static int
 clearPad_callback (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *) b;
-  int *side = cl;
-  if (ON_SIDE (pad, *side) && pad->Mask)
+  struct side_info *info = cl;
+
+  if (ON_SIDE (pad, info->side) && pad->Mask)
     _draw_pad (Output.pmGC, pad, true, true);
   return 1;
 }
@@ -1565,8 +1581,9 @@ static int
 clearPad_callback_solid (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *) b;
-  int *side = cl;
-  if (ON_SIDE (pad, *side) && pad->Mask)
+  struct side_info *info = cl;
+
+  if (ON_SIDE (pad, info->side) && pad->Mask)
     hid_draw__fill_pcb_pad (Output.pmGC, pad, true, true);
   return 1;
 }
@@ -1585,7 +1602,7 @@ ensure_board_outline (void)
 }
 
 static void
-fill_board_outline (hidGC gc, const BoxType *drawn_area)
+fill_board_outline (hidGC gc)
 {
   PolygonType polygon;
 
@@ -1593,11 +1610,11 @@ fill_board_outline (hidGC gc, const BoxType *drawn_area)
 
   memset (&polygon, 0, sizeof (polygon));
   polygon.Clipped = PCB->Data->outline;
-  if (drawn_area)
-    polygon.BoundingBox = *drawn_area;
+  if (gc->clip_box)
+    polygon.BoundingBox = *gc->clip_box;
   polygon.Flags = NoFlags ();
   SET_FLAG (FULLPOLYFLAG, &polygon);
-  hid_draw__fill_pcb_polygon (gc, &polygon, drawn_area);
+  hid_draw__fill_pcb_polygon (gc, &polygon);
   poly_FreeContours (&polygon.NoHoles);
 }
 
@@ -1628,8 +1645,8 @@ fill_outline_hole_cb (PLINE *pl, void *user_data)
   SET_FLAG (FULLPOLYFLAG, &polygon);
 
   /* XXX: For some reason, common_fill_pcb_polygon doesn't work for all contours here.. not sure why */
-//  common_fill_pcb_polygon (info->gc, &polygon, NULL);
-  hid_draw__fill_pcb_polygon (info->gc, &polygon, NULL);
+//  common_fill_pcb_polygon (info->gc, &polygon);
+  hid_draw__fill_pcb_polygon (info->gc, &polygon);
 
   poly_FreeContours (&polygon.NoHoles);
 
@@ -1639,7 +1656,7 @@ fill_outline_hole_cb (PLINE *pl, void *user_data)
 }
 
 static void
-fill_board_outline_holes (hidGC gc, const BoxType *drawn_area)
+fill_board_outline_holes (hidGC gc)
 {
   PolygonType polygon, p;
   struct outline_info info;
@@ -1648,64 +1665,65 @@ fill_board_outline_holes (hidGC gc, const BoxType *drawn_area)
 
   memset (&polygon, 0, sizeof (polygon));
   polygon.Clipped = PCB->Data->outline;
-  if (drawn_area)
-    polygon.BoundingBox = *drawn_area;
+  if (gc->clip_box)
+    polygon.BoundingBox = *gc->clip_box;
   polygon.Flags = NoFlags ();
   SET_FLAG (FULLPOLYFLAG, &polygon);
 
   info.gc = gc;
 
-  PolygonHoles (&polygon, drawn_area, fill_outline_hole_cb, &info);
+  PolygonHoles (&polygon, gc->clip_box, fill_outline_hole_cb, &info);
 
   p = polygon;
   for (p.Clipped = polygon.Clipped->f;
        p.Clipped != polygon.Clipped;
        p.Clipped = p.Clipped->f) {
-    PolygonHoles (&p, drawn_area, fill_outline_hole_cb, &info);
+    PolygonHoles (&p, gc->clip_box, fill_outline_hole_cb, &info);
   }
 
 //  poly_FreeContours (&polygon.NoHoles);
 
-  hidgl_flush_triangles (&buffer);
 }
 
 static void
-GhidDrawMask (int side, BoxType * screen)
+GhidDrawMask (hidGC gc, int side)
 {
 //  static bool first_run = true;
 //  static GLuint texture;
   int thin = TEST_FLAG(THINDRAWFLAG, PCB) || TEST_FLAG(THINDRAWPOLYFLAG, PCB);
   LayerType *Layer = LAYER_PTR (side == TOP_SIDE ? top_soldermask_layer : bottom_soldermask_layer);
-  struct poly_info info;
+  struct layer_info l_info;
+  struct side_info s_info;
 
-  OutputType *out = &Output;
+  l_info.gc = gc;
+  l_info.layer = Layer;
+  s_info.gc = gc;
+  s_info.side = side;
 
   if (thin)
     {
       hid_draw_set_line_width (Output.pmGC, 0);
       hid_draw_set_color (Output.pmGC, PCB->MaskColor);
-      r_search (PCB->Data->pin_tree, screen, NULL, clearPin_callback, NULL);
-      r_search (PCB->Data->via_tree, screen, NULL, clearPin_callback, NULL);
-      r_search (PCB->Data->pad_tree, screen, NULL, clearPad_callback, &side);
+      r_search (PCB->Data->pin_tree, gc->clip_box, NULL, clearPin_callback, NULL);
+      r_search (PCB->Data->via_tree, gc->clip_box, NULL, clearPin_callback, NULL);
+      r_search (PCB->Data->pad_tree, gc->clip_box, NULL, clearPad_callback, &s_info);
       hid_draw_set_color (Output.pmGC, "erase");
     }
 
-  hid_draw_use_mask (Output.fgGC, HID_MASK_CLEAR);
+  hid_draw_use_mask (gc, HID_MASK_CLEAR);
 
-  info.layer = Layer;
-  info.drawn_area = screen;
-  r_search (Layer->polygon_tree, screen, NULL, poly_callback, &info);
-  r_search (Layer->line_tree, screen, NULL, line_callback, Layer);
-  r_search (Layer->arc_tree, screen, NULL, arc_callback, Layer);
-  r_search (Layer->text_tree, screen, NULL, text_callback, Layer);
+  r_search (Layer->polygon_tree, gc->clip_box, NULL, poly_callback, &s_info);
+  r_search (Layer->line_tree, gc->clip_box, NULL, line_callback, &l_info);
+  r_search (Layer->arc_tree, gc->clip_box, NULL, arc_callback, &l_info);
+  r_search (Layer->text_tree, gc->clip_box, NULL, text_callback, &l_info);
 
-  r_search (PCB->Data->pin_tree, screen, NULL, clearPin_callback_solid, NULL);
-  r_search (PCB->Data->via_tree, screen, NULL, clearPin_callback_solid, NULL);
-  r_search (PCB->Data->pad_tree, screen, NULL, clearPad_callback_solid, &side);
+  r_search (PCB->Data->pin_tree, gc->clip_box, NULL, clearPin_callback_solid, NULL);
+  r_search (PCB->Data->via_tree, gc->clip_box, NULL, clearPin_callback_solid, NULL);
+  r_search (PCB->Data->pad_tree, gc->clip_box, NULL, clearPad_callback_solid, &s_info);
 
-  hid_draw_use_mask (Output.fgGC, HID_MASK_AFTER);
-  hid_draw_set_color (out->fgGC, PCB->MaskColor);
-  ghid_set_alpha_mult (out->fgGC, thin ? 0.35 : 1.0);
+  hid_draw_use_mask (gc, HID_MASK_AFTER);
+  hid_draw_set_color (gc, PCB->MaskColor);
+  ghid_set_alpha_mult (gc, thin ? 0.35 : 1.0);
 
 #if 0
   if (first_run) {
@@ -1742,18 +1760,18 @@ GhidDrawMask (int side, BoxType * screen)
 
   memset (&polygon, 0, sizeof (polygon));
   polygon.Clipped = PCB->Data->outline;
-  if (screen)
-    polygon.BoundingBox = *screen;
+  if (gc->clip_box)
+    polygon.BoundingBox = *gc->clip_box;
   polygon.Flags = NoFlags ();
   SET_FLAG (FULLPOLYFLAG, &polygon);
-  hid_draw__fill_pcb_polygon (out->fgGC, &polygon, screen);
+  hid_draw__fill_pcb_polygon (gc, &polygon);
   poly_FreeContours (&polygon.NoHoles);
 #endif
 
-  fill_board_outline (out->fgGC, screen);
+  fill_board_outline (gc);
 
-  ghid_set_alpha_mult (out->fgGC, 1.0);
-//  hidgl_flush_triangles (&buffer);
+  ghid_set_alpha_mult (gc, 1.0);
+//  hidgl_flush_triangles (gc);
 #if 0
   glDisable (GL_TEXTURE_GEN_S);
   glDisable (GL_TEXTURE_GEN_T);
@@ -1762,7 +1780,7 @@ GhidDrawMask (int side, BoxType * screen)
 #endif
   hidgl_shader_activate (circular_program);
 
-  hid_draw_use_mask (out->fgGC, HID_MASK_OFF);
+  hid_draw_use_mask (gc, HID_MASK_OFF);
 
 //  first_run = false;
 }
@@ -1773,16 +1791,16 @@ draw_outline_contour (hidGC gc, PLINE *pl, float z1, float z2)
   VNODE *v;
   GLfloat x, y;
 
-  hidgl_ensure_vertex_space (&buffer, 2 * pl->Count + 2 + 2);
+  hidgl_ensure_vertex_space (gc, 2 * pl->Count + 2 + 2);
 
   /* NB: Repeated first virtex to separate from other tri-strip */
 
   x = pl->head.point[0];
   y = pl->head.point[1];
 
-  hidgl_add_vertex_3D_tex (&buffer, x, y, z1, 0.0, 0.0);
-  hidgl_add_vertex_3D_tex (&buffer, x, y, z1, 0.0, 0.0);
-  hidgl_add_vertex_3D_tex (&buffer, x, y, z2, 0.0, 0.0);
+  hidgl_add_vertex_3D_tex (gc, x, y, z1, 0.0, 0.0);
+  hidgl_add_vertex_3D_tex (gc, x, y, z1, 0.0, 0.0);
+  hidgl_add_vertex_3D_tex (gc, x, y, z2, 0.0, 0.0);
 
   v = pl->head.next;
 
@@ -1791,13 +1809,13 @@ draw_outline_contour (hidGC gc, PLINE *pl, float z1, float z2)
       x = v->point[0];
       y = v->point[1];
 
-      hidgl_add_vertex_3D_tex (&buffer, x, y, z1, 0.0, 0.0);
-      hidgl_add_vertex_3D_tex (&buffer, x, y, z2, 0.0, 0.0);
+      hidgl_add_vertex_3D_tex (gc, x, y, z1, 0.0, 0.0);
+      hidgl_add_vertex_3D_tex (gc, x, y, z2, 0.0, 0.0);
     }
   while ((v = v->next) != pl->head.next);
 
   /* NB: Repeated last virtex to separate from other tri-strip */
-  hidgl_add_vertex_3D_tex (&buffer, x, y, z2, 0.0, 0.0);
+  hidgl_add_vertex_3D_tex (gc, x, y, z2, 0.0, 0.0);
 }
 
 static int
@@ -1810,7 +1828,7 @@ outline_hole_cb (PLINE *pl, void *user_data)
 }
 
 static void
-ghid_draw_outline_between_layers (int from_layer, int to_layer, BoxType *drawn_area)
+ghid_draw_outline_between_layers (hidGC gc, int from_layer, int to_layer)
 {
   PolygonType polygon, p;
   struct outline_info info;
@@ -1819,38 +1837,36 @@ ghid_draw_outline_between_layers (int from_layer, int to_layer, BoxType *drawn_a
 
   memset (&polygon, 0, sizeof (polygon));
   polygon.Clipped = PCB->Data->outline;
-  if (drawn_area)
-    polygon.BoundingBox = *drawn_area;
+  if (gc->clip_box)
+    polygon.BoundingBox = *gc->clip_box;
   polygon.Flags = NoFlags ();
   SET_FLAG (FULLPOLYFLAG, &polygon);
 
-  info.gc = Output.fgGC;
+  info.gc = gc;
   info.z1 = compute_depth (from_layer);
   info.z2 = compute_depth (to_layer);
 
   draw_outline_contour (info.gc, polygon.Clipped->contours, info.z1, info.z2);
-  PolygonHoles (&polygon, drawn_area, outline_hole_cb, &info);
+  PolygonHoles (&polygon, gc->clip_box, outline_hole_cb, &info);
 
   p = polygon;
   for (p.Clipped = polygon.Clipped->f;
        p.Clipped != polygon.Clipped;
        p.Clipped = p.Clipped->f) {
     draw_outline_contour (info.gc, p.Clipped->contours, info.z1, info.z2);
-    PolygonHoles (&p, drawn_area, outline_hole_cb, &info);
+    PolygonHoles (&p, gc->clip_box, outline_hole_cb, &info);
   }
 
   poly_FreeContours (&polygon.NoHoles);
 
-  hidgl_flush_triangles (&buffer);
+  hidgl_flush_triangles (gc);
 }
 
 static int
-GhidDrawLayerGroup (int group, const BoxType * screen)
+GhidDrawLayerGroup (hidGC gc, int group)
 {
   int i;
   int layernum;
-  int side;
-  struct poly_info info;
   LayerType *Layer;
   int n_entries = PCB->LayerGroups.Number[group];
   Cardinal *layers = PCB->LayerGroups.Entries[group];
@@ -1858,8 +1874,13 @@ GhidDrawLayerGroup (int group, const BoxType * screen)
   int top_group = GetLayerGroupNumberBySide (TOP_SIDE);
   int bottom_group = GetLayerGroupNumberBySide (BOTTOM_SIDE);
   bool is_outline;
+  struct layer_info l_info;
+  struct side_info s_info;
+
+  l_info.gc = gc;
+  s_info.gc = gc;
 
-  if (!gui->set_layer (0, group, 0))
+  if (!gui->set_layer (gc, 0, group, 0))
     return 0;
 
   /* HACK: Subcomposite each layer in a layer group separately */
@@ -1870,49 +1891,51 @@ GhidDrawLayerGroup (int group, const BoxType * screen)
     is_outline = strcmp (Layer->Name, "outline") == 0 ||
                  strcmp (Layer->Name, "route") == 0;
 
+    l_info.layer = Layer;
+
+
     if (layernum < max_copper_layer && Layer->On) {
 
       if (!first_run)
-        gui->set_layer (0, group, 0);
+        gui->set_layer (gc, 0, group, 0);
 
       first_run = 0;
 
       if (!is_outline && !TEST_FLAG (THINDRAWFLAG, PCB)) {
         /* Mask out drilled holes on this layer */
-        hidgl_flush_triangles (&buffer);
+        hidgl_flush_triangles (gc);
         glPushAttrib (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
         glColorMask (0, 0, 0, 0);
         glDepthMask (GL_FALSE);
         hid_draw_set_color (Output.bgGC, PCB->MaskColor);
-        if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
-        if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
-        fill_board_outline_holes (Output.bgGC, screen);
-        hidgl_flush_triangles (&buffer);
+        if (PCB->PinOn) r_search (PCB->Data->pin_tree, gc->clip_box, NULL, hole_callback, gc);
+        if (PCB->ViaOn) r_search (PCB->Data->via_tree, gc->clip_box, NULL, hole_callback, gc);
+        fill_board_outline_holes (Output.bgGC);
+        hidgl_flush_triangles (gc);
         glPopAttrib ();
       }
 
       /* draw all polygons on this layer */
       if (Layer->PolygonN) {
-        info.layer = Layer;
-        info.drawn_area = screen;
-        r_search (Layer->polygon_tree, screen, NULL, poly_callback_no_clear, &info);
-        r_search (Layer->polygon_tree, screen, NULL, poly_callback_clearing, &info);
+        l_info.layer = Layer;
+        r_search (Layer->polygon_tree, gc->clip_box, NULL, poly_callback_no_clear, &l_info);
+        r_search (Layer->polygon_tree, gc->clip_box, NULL, poly_callback_clearing, &l_info);
 
         /* HACK: Subcomposite polygons separately from other layer primitives */
         /* Reset the compositing */
-        gui->end_layer ();
-        gui->set_layer (0, group, 0);
+        gui->end_layer (gc);
+        gui->set_layer (gc, 0, group, 0);
 
         if (!is_outline && !TEST_FLAG (THINDRAWFLAG, PCB)) {
-          hidgl_flush_triangles (&buffer);
+          hidgl_flush_triangles (gc);
           glPushAttrib (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
           glColorMask (0, 0, 0, 0);
           glDepthMask (GL_FALSE);
           /* Mask out drilled holes on this layer */
-          if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
-          if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
-          fill_board_outline_holes (Output.bgGC, screen);
-          hidgl_flush_triangles (&buffer);
+          if (PCB->PinOn) r_search (PCB->Data->pin_tree, gc->clip_box, NULL, hole_callback, gc);
+          if (PCB->ViaOn) r_search (PCB->Data->via_tree, gc->clip_box, NULL, hole_callback, gc);
+          fill_board_outline_holes (Output.bgGC);
+          hidgl_flush_triangles (gc);
           glPopAttrib ();
         }
       }
@@ -1921,37 +1944,37 @@ GhidDrawLayerGroup (int group, const BoxType * screen)
       if (!global_view_2d && !is_outline) {
         if (PCB->PinOn &&
             (group == bottom_group || group == top_group))
-          r_search (PCB->Data->pin_tree, screen, NULL, pin_name_callback, Layer);
-        if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, pin_inlayer_callback, Layer);
-        if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, via_inlayer_callback, Layer);
+          r_search (PCB->Data->pin_tree, gc->clip_box, NULL, pin_name_callback, gc);
+        if (PCB->PinOn) r_search (PCB->Data->pin_tree, gc->clip_box, NULL, pin_inlayer_callback, &l_info);
+        if (PCB->ViaOn) r_search (PCB->Data->via_tree, gc->clip_box, NULL, via_inlayer_callback, &l_info);
         if (PCB->PinOn && group == top_group)
           {
-            side = TOP_SIDE;
-            r_search (PCB->Data->pad_tree, screen, NULL, pad_callback, &side);
+            s_info.side = TOP_SIDE;
+            r_search (PCB->Data->pad_tree, gc->clip_box, NULL, pad_callback, &s_info);
           }
         if (PCB->PinOn && group == bottom_group)
           {
-            side = BOTTOM_SIDE;
-            r_search (PCB->Data->pad_tree, screen, NULL, pad_callback, &side);
+            s_info.side = BOTTOM_SIDE;
+            r_search (PCB->Data->pad_tree, gc->clip_box, NULL, pad_callback, &s_info);
           }
       }
 
       if (TEST_FLAG (CHECKPLANESFLAG, PCB))
         continue;
 
-      r_search (Layer->line_tree, screen, NULL, line_callback, Layer);
-      r_search (Layer->arc_tree, screen, NULL, arc_callback, Layer);
-      r_search (Layer->text_tree, screen, NULL, text_callback, Layer);
+      r_search (Layer->line_tree, gc->clip_box, NULL, line_callback, &l_info);
+      r_search (Layer->arc_tree, gc->clip_box, NULL, arc_callback, &l_info);
+      r_search (Layer->text_tree, gc->clip_box, NULL, text_callback, &l_info);
     }
   }
 
-  gui->end_layer ();
+  gui->end_layer (gc);
 
   return (n_entries > 1);
 }
 
 static void
-DrawDrillChannel (int vx, int vy, int vr, int from_layer, int to_layer, double scale)
+DrawDrillChannel (hidGC gc, int vx, int vy, int vr, int from_layer, int to_layer, double scale)
 {
 #define PIXELS_PER_CIRCLINE 5.
 #define MIN_FACES_PER_CYL 6
@@ -1975,27 +1998,28 @@ DrawDrillChannel (int vx, int vy, int vr, int from_layer, int to_layer, double s
   x = vx + vr;
   y = vy;
 
-  hidgl_ensure_vertex_space (&buffer, 2 * slices + 2 + 2);
+  hidgl_ensure_vertex_space (gc, 2 * slices + 2 + 2);
 
   /* NB: Repeated first virtex to separate from other tri-strip */
-  hidgl_add_vertex_3D_tex (&buffer, x, y, z1, 0.0, 0.0);
-  hidgl_add_vertex_3D_tex (&buffer, x, y, z1, 0.0, 0.0);
-  hidgl_add_vertex_3D_tex (&buffer, x, y, z2, 0.0, 0.0);
+  hidgl_add_vertex_3D_tex (gc, x, y, z1, 0.0, 0.0);
+  hidgl_add_vertex_3D_tex (gc, x, y, z1, 0.0, 0.0);
+  hidgl_add_vertex_3D_tex (gc, x, y, z2, 0.0, 0.0);
 
   for (i = 0; i < slices; i++)
     {
       x = radius * cosf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vx;
       y = radius * sinf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vy;
 
-      hidgl_add_vertex_3D_tex (&buffer, x, y, z1, 0.0, 0.0);
-      hidgl_add_vertex_3D_tex (&buffer, x, y, z2, 0.0, 0.0);
+      hidgl_add_vertex_3D_tex (gc, x, y, z1, 0.0, 0.0);
+      hidgl_add_vertex_3D_tex (gc, x, y, z2, 0.0, 0.0);
     }
 
   /* NB: Repeated last virtex to separate from other tri-strip */
-  hidgl_add_vertex_3D_tex (&buffer, x, y, z2, 0.0, 0.0);
+  hidgl_add_vertex_3D_tex (gc, x, y, z2, 0.0, 0.0);
 }
 
 struct cyl_info {
+  hidGC gc;
   int from_layer;
   int to_layer;
   double scale;
@@ -2017,9 +2041,9 @@ draw_hole_cyl (PinType *Pin, struct cyl_info *info, int Type)
   else
     color = "drill";
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)Pin);
-  hid_draw_set_color (Output.fgGC, color);
-  DrawDrillChannel (Pin->X, Pin->Y, Pin->DrillingHole / 2, info->from_layer, info->to_layer, info->scale);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *)Pin);
+  hid_draw_set_color (info->gc, color);
+  DrawDrillChannel (info->gc, Pin->X, Pin->Y, Pin->DrillingHole / 2, info->from_layer, info->to_layer, info->scale);
   return 0;
 }
 
@@ -2152,23 +2176,23 @@ ghid_draw_everything (BoxType *drawn_area)
   /*
    * first draw all 'invisible' stuff
    */
-  side = SWAP_IDENT ? TOP_SIDE : BOTTOM_SIDE;
+  info.side = SWAP_IDENT ? TOP_SIDE : BOTTOM_SIDE;
 
   if (!TEST_FLAG (CHECKPLANESFLAG, PCB) &&
-      gui->set_layer ("invisible", SL (INVISIBLE, 0), 0)) {
-    DrawSilk (side, drawn_area);
+      gui->set_layer (gc, "invisible", SL (INVISIBLE, 0), 0)) {
+    DrawSilk (gc, info.side);
 
     if (global_view_2d)
-      r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, &side);
+      r_search (PCB->Data->pad_tree, gc->clip_box, NULL, pad_callback, &info);
 
-    gui->end_layer ();
+    gui->end_layer (gc);
 
     /* Draw the reverse-side solder mask if turned on */
     if (!global_view_2d &&
-        gui->set_layer (SWAP_IDENT ? "componentmask" : "soldermask",
-                        SWAP_IDENT ? SL (MASK, TOP) : SL (MASK, BOTTOM), 0)) {
-        GhidDrawMask (side, drawn_area);
-        gui->end_layer ();
+        gui->set_layer (gc, SWAP_IDENT ? "componentmask" : "soldermask",
+                            SWAP_IDENT ? SL (MASK, TOP) : SL (MASK, BOTTOM), 0)) {
+        GhidDrawMask (gc, info.side);
+        gui->end_layer (gc);
       }
   }
 
@@ -2188,76 +2212,76 @@ ghid_draw_everything (BoxType *drawn_area)
     if (is_this_physical)
       number_phys_on_top --;
 
-    ghid_set_alpha_mult (Output.fgGC, alpha_mult);
-    GhidDrawLayerGroup (drawn_groups [i], drawn_area);
+    ghid_set_alpha_mult (gc, alpha_mult);
+    GhidDrawLayerGroup (gc, drawn_groups [i]);
 
 #if 1
     if (!global_view_2d && is_this_physical && is_next_physical) {
       cyl_info.from_layer = drawn_groups[i];
       cyl_info.to_layer = drawn_groups[i - 1];
       cyl_info.scale = gport->view.coord_per_px;
-      hid_draw_set_color (Output.fgGC, "drill");
-      ghid_set_alpha_mult (Output.fgGC, alpha_mult * 0.75);
-      ghid_draw_outline_between_layers (cyl_info.from_layer, cyl_info.to_layer, drawn_area);
-      if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_hole_cyl_callback, &cyl_info);
-      if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, via_hole_cyl_callback, &cyl_info);
+      hid_draw_set_color (gc, "drill");
+      ghid_set_alpha_mult (gc, alpha_mult * 0.75);
+      ghid_draw_outline_between_layers (gc, cyl_info.from_layer, cyl_info.to_layer);
+      if (PCB->PinOn) r_search (PCB->Data->pin_tree, gc->clip_box, NULL, pin_hole_cyl_callback, &cyl_info);
+      if (PCB->ViaOn) r_search (PCB->Data->via_tree, gc->clip_box, NULL, via_hole_cyl_callback, &cyl_info);
     }
 #endif
   }
 #undef FADE_FACTOR
 
-  ghid_set_alpha_mult (Output.fgGC, 1.0);
+  ghid_set_alpha_mult (gc, 1.0);
 
   if (TEST_FLAG (CHECKPLANESFLAG, PCB))
     return;
 
-  side = SWAP_IDENT ? BOTTOM_SIDE : TOP_SIDE;
+  info.side = SWAP_IDENT ? BOTTOM_SIDE : TOP_SIDE;
 
   /* Draw pins, pads, vias below silk */
   if (global_view_2d) {
-    start_subcomposite ();
+    start_subcomposite (gc);
 
     if (!TEST_FLAG (THINDRAWFLAG, PCB)) {
       /* Mask out drilled holes */
-      hidgl_flush_triangles (&buffer);
+      hidgl_flush_triangles (gc);
       glPushAttrib (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
       glColorMask (0, 0, 0, 0);
       glDepthMask (GL_FALSE);
-      if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, hole_callback, NULL);
-      if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, hole_callback, NULL);
-      fill_board_outline_holes (Output.bgGC, drawn_area);
-      hidgl_flush_triangles (&buffer);
+      if (PCB->PinOn) r_search (PCB->Data->pin_tree, gc->clip_box, NULL, hole_callback, gc);
+      if (PCB->ViaOn) r_search (PCB->Data->via_tree, gc->clip_box, NULL, hole_callback, gc);
+      fill_board_outline_holes (Output.bgGC);
+      hidgl_flush_triangles (gc);
       glPopAttrib ();
     }
 
-    if (PCB->PinOn) r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, &side);
-    if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_callback, NULL);
-    if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, via_callback, NULL);
+    if (PCB->PinOn) r_search (PCB->Data->pad_tree, gc->clip_box, NULL, pad_callback, &info);
+    if (PCB->PinOn) r_search (PCB->Data->pin_tree, gc->clip_box, NULL, pin_callback, gc);
+    if (PCB->ViaOn) r_search (PCB->Data->via_tree, gc->clip_box, NULL, via_callback, gc);
 
-    end_subcomposite ();
+    end_subcomposite (gc);
   }
 
   /* Draw the solder mask if turned on */
-  if (gui->set_layer (SWAP_IDENT ? "soldermask" : "componentmask",
-                      SWAP_IDENT ? SL (MASK, BOTTOM) : SL (MASK, TOP), 0)) {
-    GhidDrawMask (side, drawn_area);
-    gui->end_layer ();
+  if (gui->set_layer (gc, SWAP_IDENT ? "soldermask" : "componentmask",
+                          SWAP_IDENT ? SL (MASK, BOTTOM) : SL (MASK, TOP), 0)) {
+    GhidDrawMask (gc, info.side);
+    gui->end_layer (gc);
   }
 
-  if (gui->set_layer (SWAP_IDENT ? "bottomsilk" : "topsilk",
-                      SWAP_IDENT ? SL (SILK, BOTTOM) : SL (SILK, TOP), 0)) {
-      DrawSilk (side, drawn_area);
-      gui->end_layer ();
+  if (gui->set_layer (gc, SWAP_IDENT ? "bottomsilk" : "topsilk",
+                          SWAP_IDENT ? SL (SILK, BOTTOM) : SL (SILK, TOP), 0)) {
+      DrawSilk (gc, info.side);
+      gui->end_layer (gc);
   }
 
   /* Draw element Marks */
   if (PCB->PinOn)
-    r_search (PCB->Data->element_tree, drawn_area, NULL, EMark_callback, NULL);
+    r_search (PCB->Data->element_tree, gc->clip_box, NULL, EMark_callback, gc);
 
   /* Draw rat lines on top */
-  if (PCB->RatOn && gui->set_layer ("rats", SL (RATS, 0), 0)) {
-    DrawRats(drawn_area);
-    gui->end_layer ();
+  if (PCB->RatOn && gui->set_layer (gc, "rats", SL (RATS, 0), 0)) {
+    DrawRats(gc);
+    gui->end_layer (gc);
   }
 
   Settings.ShowBottomSide = save_show_solder;
@@ -2302,7 +2326,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   /* If we don't have any stencil bits available,
      we can't use the hidgl polygon drawing routine */
   /* TODO: We could use the GLU tessellator though */
-  if (hidgl_stencil_bits() == 0)
+  if (hidgl_stencil_bits (gc) == 0)
     ghid_graphics._fill_pcb_polygon = common_fill_pcb_polygon;
 
   glEnable (GL_BLEND);
@@ -2388,7 +2412,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glStencilMask (~0);
   glClearStencil (0);
   glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-  hidgl_reset_stencil_usage ();
+  hidgl_reset_stencil_usage (gc);
 
   /* Disable the stencil test until we need it - otherwise it gets dirty */
   glDisable (GL_STENCIL_TEST);
@@ -2531,9 +2555,9 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   ghid_draw_bg_image ();
 
-  /* hid_expose_callback (&ghid_hid, &region, 0); */
-  ghid_draw_everything (&region);
-  hidgl_flush_triangles (&buffer);
+  /* hid_expose_callback (&ghid_hid, 0); */
+  ghid_draw_everything (gc);
+  hidgl_flush_triangles (gc);
 
   glTexCoord2f (0., 0.);
   glColor3f (1., 1., 1.);
@@ -2576,15 +2600,15 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   }
 
   /* Set the current depth to the right value for the layer we are editing */
-  hidgl_set_depth (compute_depth (GetLayerGroupNumberByNumber (INDEXOFCURRENT)));
+  hidgl_set_depth (gc, compute_depth (GetLayerGroupNumberByNumber (INDEXOFCURRENT)));
 
-  ghid_draw_grid (&region);
+  ghid_draw_grid (gc);
 
   ghid_invalidate_current_gc ();
 
-  DrawAttached (Output.fgGC);
-  DrawMark (Output.fgGC);
-  hidgl_flush_triangles (&buffer);
+  DrawAttached (gc);
+  DrawMark (gc);
+  hidgl_flush_triangles (gc);
 
   glEnable (GL_LIGHTING);
 
@@ -2636,7 +2660,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   }
 
   if (!global_view_2d)
-    ghid_draw_packages (&region);
+    ghid_draw_packages (gc);
 
   glDisable (GL_CULL_FACE);
   glDisable (GL_DEPTH_TEST);
@@ -2644,14 +2668,14 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glDisable (GL_COLOR_MATERIAL);
   glDisable (GL_LIGHTING);
 
-  draw_crosshair (priv);
+  draw_crosshair (gc, priv);
   object3d_draw_debug ();
 
-  hidgl_flush_triangles (&buffer);
+  hidgl_flush_triangles (gc);
 
-  draw_lead_user (priv);
+  draw_lead_user (gc, priv);
 
-  hidgl_finish_render ();
+  hidgl_finish_render (gc);
   ghid_end_drawing (port, widget);
 
   hid_draw_destroy_gc (Output.fgGC);
@@ -2779,7 +2803,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   glStencilMask (~0);
   glClearStencil (0);
   glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-  hidgl_reset_stencil_usage ();
+  hidgl_reset_stencil_usage (gc);
 
   /* Disable the stencil test until we need it - otherwise it gets dirty */
   glDisable (GL_STENCIL_TEST);
@@ -2797,12 +2821,12 @@ ghid_pinout_preview_expose (GtkWidget *widget,
                 gport->view.flip_y ? gport->view.y0 - PCB->MaxHeight :
                                     -gport->view.y0, 0);
 
-  hidgl_set_depth (0.);
+  hidgl_set_depth (gc, 0.);
   hid_expose_callback (&ghid_hid, NULL, pinout->element);
-  hidgl_flush_triangles (&buffer);
+  hidgl_flush_triangles (gc);
   glPopMatrix ();
 
-  hidgl_finish_render ();
+  hidgl_finish_render (gc);
   ghid_end_drawing (gport, widget);
 
   gport->view = save_view;
@@ -2892,7 +2916,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   glStencilMask (~0);
   glClearStencil (0);
   glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-  hidgl_reset_stencil_usage ();
+  hidgl_reset_stencil_usage (gc);
 
   /* Disable the stencil test until we need it - otherwise it gets dirty */
   glDisable (GL_STENCIL_TEST);
@@ -2921,12 +2945,12 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   region.Y2 = MAX (0, MIN (PCB->MaxHeight, region.Y2));
 
   hid_expose_callback (&ghid_hid, &region, NULL);
-  hidgl_flush_triangles (&buffer);
+  hidgl_flush_triangles (gc);
   glPopMatrix ();
 
   glFlush ();
 
-  hidgl_finish_render ();
+  hidgl_finish_render (gc);
 
   /* end drawing to current GL-context */
   gport->render_priv->in_context = false;
@@ -2983,12 +3007,12 @@ ghid_request_debug_draw (void)
 }
 
 void
-ghid_flush_debug_draw (void)
+ghid_flush_debug_draw (hidGC gc)
 {
   GtkWidget *widget = gport->drawing_area;
   GdkGLDrawable *pGlDrawable = gtk_widget_get_gl_drawable (widget);
 
-  hidgl_flush_triangles (&buffer);
+  hidgl_flush_triangles (gc);
 
   if (gdk_gl_drawable_is_double_buffered (pGlDrawable))
     gdk_gl_drawable_swap_buffers (pGlDrawable);
@@ -2997,12 +3021,12 @@ ghid_flush_debug_draw (void)
 }
 
 void
-ghid_finish_debug_draw (void)
+ghid_finish_debug_draw (hidGC gc)
 {
-  hidgl_flush_triangles (&buffer);
+  hidgl_flush_triangles (gc);
   glPopMatrix ();
 
-  hidgl_finish_render ();
+  hidgl_finish_render (gc);
   ghid_end_drawing (gport, gport->drawing_area);
 }
 
@@ -3358,7 +3382,7 @@ ghid_port_rotate (void *ball, float *quarternion, gpointer userdata)
 #define LEAD_USER_COLOR_B         0.
 
 static void
-draw_lead_user (render_priv *priv)
+draw_lead_user (hidGC gc, render_priv *priv)
 {
   int i;
   double radius = priv->lead_user_radius;
@@ -3382,11 +3406,11 @@ draw_lead_user (render_priv *priv)
         radius += MM_TO_COORD (LEAD_USER_INITIAL_RADIUS);
 
       /* Draw an arc at radius */
-      hidgl_draw_arc (width, priv->lead_user_x, priv->lead_user_y,
+      hidgl_draw_arc (gc, width, priv->lead_user_x, priv->lead_user_y,
                       radius, radius, 0, 360, gport->view.coord_per_px);
     }
 
-  hidgl_flush_triangles (&buffer);
+  hidgl_flush_triangles (gc);
   glPopAttrib ();
 }
 
diff --git a/src/sweep.h b/src/sweep.h
index d54c6b7..836a751 100644
--- a/src/sweep.h
+++ b/src/sweep.h
@@ -1,6 +1,6 @@
 #include "borast/borast-traps-private.h"
 
-borast_status_t bo_poly_to_traps (POLYAREA *poly, borast_traps_t *traps);
-borast_status_t bo_contour_to_traps (PLINE *contour, borast_traps_t *traps);
-borast_status_t bo_contour_to_traps_no_draw (PLINE *contour, borast_traps_t *traps);
+borast_status_t bo_poly_to_traps (hidGC gc, POLYAREA *poly, borast_traps_t *traps);
+borast_status_t bo_contour_to_traps (hidGC gc, PLINE *contour, borast_traps_t *traps);
+borast_status_t bo_contour_to_traps_no_draw (hidGC gc, PLINE *contour, borast_traps_t *traps);
 borast_fixed_t _line_compute_intersection_x_for_y (const borast_line_t *line, borast_fixed_t y);

Bottom: 6b961dfd86ce25e88b660646bdebe5828309f6e0
Top:    2be8b6c550b06f1ce5706871391e2bae3159cfbc
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-11-06 16:35:18 +0000

GL: Use a VBO to avoid data-copying

BUGS: Breakage due to graphics operations being called outside the
      expose handler, and causing invalid memory accesses.

      Leaking of some GL / GPU objects?







---

diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index cb53763..ebc2ce5 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -59,10 +59,28 @@ hidgl_new_triangle_array (void)
 void
 hidgl_init_triangle_array (triangle_buffer *buffer)
 {
-  glEnableClientState (GL_VERTEX_ARRAY);
-  glVertexPointer (3, GL_FLOAT, 0, buffer->triangle_array);
+  GLenum errCode;
+  const GLubyte *errString;
+
   buffer->triangle_count = 0;
   buffer->coord_comp_count = 0;
+
+  glEnableClientState (GL_VERTEX_ARRAY);
+  glGenBuffers (1, &buffer->vbo_name);
+  glBindBuffer (GL_ARRAY_BUFFER, buffer->vbo_name);
+  glBufferData (GL_ARRAY_BUFFER, TRIANGLE_ARRAY_BYTES, NULL, GL_STATIC_DRAW);
+
+  buffer->triangle_array = glMapBuffer (GL_ARRAY_BUFFER, GL_WRITE_ONLY);
+
+  if ((errCode = glGetError()) != GL_NO_ERROR) {
+      errString = gluErrorString(errCode);
+     fprintf (stderr, "OpenGL Error: %s\n", errString);
+  }
+
+  if (buffer->triangle_array == NULL) {
+    printf ("Couldn't map VBO.. sorry, don't know how best to handle this gracefully\n");
+    exit (1);
+  }
 }
 
 void
@@ -71,9 +89,20 @@ hidgl_flush_triangles (triangle_buffer *buffer)
   if (buffer->triangle_count == 0)
     return;
 
+  glUnmapBuffer (GL_ARRAY_BUFFER);
+
+  glEnableClientState (GL_VERTEX_ARRAY);
+  glVertexPointer (3, GL_FLOAT, 0, NULL); // buffer->triangle_array);
   glDrawArrays (GL_TRIANGLES, 0, buffer->triangle_count * 3);
-  buffer->triangle_count = 0;
-  buffer->coord_comp_count = 0;
+  glDisableClientState (GL_VERTEX_ARRAY);
+
+//  buffer->triangle_count = 0;
+//  buffer->coord_comp_count = 0;
+
+  glBindBuffer(GL_ARRAY_BUFFER, 0);
+  glDeleteBuffers (1, &buffer->vbo_name);
+
+  hidgl_init_triangle_array (buffer);
 }
 
 void
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index aa2985e..1005235 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -24,10 +24,13 @@
 #define __HIDGL_INCLUDED__
 
 #define TRIANGLE_ARRAY_SIZE 5461
+#define TRIANGLE_ARRAY_BYTES (3 * 3 * sizeof (GLfloat) * TRIANGLE_ARRAY_SIZE)
 typedef struct {
-  GLfloat triangle_array [3 * 3 * TRIANGLE_ARRAY_SIZE];
+//  GLfloat triangle_array [3 * 3 * TRIANGLE_ARRAY_SIZE];
+  GLfloat *triangle_array;
   unsigned int triangle_count;
   unsigned int coord_comp_count;
+  GLuint vbo_name;
 } triangle_buffer;
 
 extern triangle_buffer buffer;
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index 0598ef9..a0ea452 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -1828,6 +1828,10 @@ ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
   gui->set_layer (NULL, INDEXOFCURRENT, 0);
   gui->set_layer (NULL, SL_FINISHED, 0);
 
+  glUnmapBuffer (GL_ARRAY_BUFFER);
+  glBindBuffer(GL_ARRAY_BUFFER, 0);
+  glDeleteBuffers (1, &buffer.vbo_name);
+
   draw_grid (&region);
 
   hidgl_init_triangle_array (&buffer);
@@ -1848,6 +1852,9 @@ ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
 
   hidgl_flush_triangles (&buffer);
 
+  glUnmapBuffer (GL_ARRAY_BUFFER);
+  glBindBuffer(GL_ARRAY_BUFFER, 0);
+  glDeleteBuffers (1, &buffer.vbo_name);
 
   if (gdk_gl_drawable_is_double_buffered (pGlDrawable))
     gdk_gl_drawable_swap_buffers (pGlDrawable);
diff --git a/src/hid/gtk/gui-pinout-preview.c b/src/hid/gtk/gui-pinout-preview.c
index 89a3563..c0814e9 100644
--- a/src/hid/gtk/gui-pinout-preview.c
+++ b/src/hid/gtk/gui-pinout-preview.c
@@ -237,6 +237,10 @@ ghid_pinout_preview_expose (GtkWidget * widget, GdkEventExpose * ev)
   hidgl_flush_triangles (&buffer);
   glPopMatrix ();
 
+  glUnmapBuffer (GL_ARRAY_BUFFER);
+  glBindBuffer(GL_ARRAY_BUFFER, 0);
+  glDeleteBuffers (1, &buffer.vbo_name);
+
   if (gdk_gl_drawable_is_double_buffered (pGlDrawable))
     gdk_gl_drawable_swap_buffers (pGlDrawable);
   else

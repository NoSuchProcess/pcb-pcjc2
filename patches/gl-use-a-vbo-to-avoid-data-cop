Bottom: 1d142e573ff7f89e2346fdf8c072aba31634035e
Top:    60997a85c95af7a79d7af7feae405eea0d1f3032
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-11-12 14:10:57 +0000

GL: Use a VBO to avoid data-copying

BUGS: Breakage due to graphics operations being called outside the
      expose handler, and causing invalid memory accesses.

      Leaking of some GL / GPU objects?







---

diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index 9f04f5c..8d54196 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -47,6 +47,10 @@ RCSID ("$Id: $");
 
 triangle_buffer buffer;
 float global_depth = 0;
+GLfloat cur_r = 1.;
+GLfloat cur_g = 1.;
+GLfloat cur_b = 1.;
+GLfloat cur_a = 1.;
 
 #if 0
 triangle_array *
@@ -59,10 +63,29 @@ hidgl_new_triangle_array (void)
 void
 hidgl_init_triangle_array (triangle_buffer *buffer)
 {
-  glEnableClientState (GL_VERTEX_ARRAY);
-  glVertexPointer (3, GL_FLOAT, 0, buffer->triangle_array);
+  GLenum errCode;
+  const GLubyte *errString;
+
   buffer->triangle_count = 0;
-  buffer->coord_comp_count = 0;
+//  buffer->coord_comp_count = 0;
+  buffer->array_size = TRIANGLE_ARRAY_BYTES / (3 * sizeof (tri_array_element));
+
+  glEnableClientState (GL_VERTEX_ARRAY);
+  glGenBuffers (1, &buffer->vbo_name);
+  glBindBuffer (GL_ARRAY_BUFFER, buffer->vbo_name);
+  glBufferData (GL_ARRAY_BUFFER, TRIANGLE_ARRAY_BYTES, NULL, GL_STATIC_DRAW);
+
+  buffer->triangle_array = glMapBuffer (GL_ARRAY_BUFFER, GL_WRITE_ONLY);
+
+  if ((errCode = glGetError()) != GL_NO_ERROR) {
+      errString = gluErrorString(errCode);
+     fprintf (stderr, "OpenGL Error: %s\n", errString);
+  }
+
+  if (buffer->triangle_array == NULL) {
+    printf ("Couldn't map VBO.. sorry, don't know how best to handle this gracefully\n");
+    exit (1);
+  }
 }
 
 void
@@ -71,25 +94,52 @@ hidgl_flush_triangles (triangle_buffer *buffer)
   if (buffer->triangle_count == 0)
     return;
 
+  glUnmapBuffer (GL_ARRAY_BUFFER);
+
+  glEnableClientState (GL_VERTEX_ARRAY);
+  glEnableClientState (GL_COLOR_ARRAY);
+  glVertexPointer (3, GL_FLOAT, sizeof (tri_array_element), &((tri_array_element *)NULL)->x);
+  glColorPointer (4, GL_FLOAT, sizeof (tri_array_element), &((tri_array_element *)NULL)->r );
   glDrawArrays (GL_TRIANGLES, 0, buffer->triangle_count * 3);
-  buffer->triangle_count = 0;
-  buffer->coord_comp_count = 0;
+  glDisableClientState (GL_VERTEX_ARRAY);
+  glDisableClientState (GL_COLOR_ARRAY);
+
+//  buffer->triangle_count = 0;
+//  buffer->coord_comp_count = 0;
+
+  glBindBuffer(GL_ARRAY_BUFFER, 0);
+  glDeleteBuffers (1, &buffer->vbo_name);
+
+  hidgl_init_triangle_array (buffer);
 }
 
 void
 hidgl_ensure_triangle_space (triangle_buffer *buffer, int count)
 {
-  if (count > TRIANGLE_ARRAY_SIZE)
+  if (count > buffer->array_size)
     {
       fprintf (stderr, "Not enough space in vertex buffer\n");
       fprintf (stderr, "Requested %i triangles, %i available\n",
-                       count, TRIANGLE_ARRAY_SIZE);
+                       count, buffer->array_size);
       exit (1);
     }
-  if (count > TRIANGLE_ARRAY_SIZE - buffer->triangle_count)
+  if (count > buffer->array_size - buffer->triangle_count)
     hidgl_flush_triangles (buffer);
 }
 
+
+void
+hidgl_color (GLfloat r, GLfloat g, GLfloat b, GLfloat a)
+{
+  cur_r = r;
+  cur_g = g;
+  cur_b = b;
+  cur_a = a;
+
+  /* We still draw non-filled rectangles in immediate mode */
+  glColor4f (r, g, b, a);
+}
+
 //static int cur_mask = -1;
 
 
@@ -215,7 +265,7 @@ static void draw_cap (double width, int x, int y, double angle, double scale)
   for (i = 0; i < slices; i++) {
     capx =  radius * cosf (angle * M_PI / 180. + ((float)(i + 1)) * M_PI / (float)slices) + x;
     capy = -radius * sinf (angle * M_PI / 180. + ((float)(i + 1)) * M_PI / (float)slices) + y;
-    hidgl_add_triangle (&buffer, last_capx, last_capy, capx, capy, x, y);
+    hidgl_add_triangle (&buffer, last_capx, last_capy, capx, capy, x, y, cur_r, cur_g, cur_b, cur_a);
     last_capx = capx;
     last_capy = capy;
   }
@@ -280,10 +330,10 @@ hidgl_draw_line (int cap, double width, int x1, int y1, int x2, int y2, double s
   hidgl_ensure_triangle_space (&buffer, 2);
   hidgl_add_triangle (&buffer, x1 - wdx, y1 - wdy,
                                x2 - wdx, y2 - wdy,
-                               x2 + wdx, y2 + wdy);
+                               x2 + wdx, y2 + wdy, cur_r, cur_g, cur_b, cur_a);
   hidgl_add_triangle (&buffer, x1 - wdx, y1 - wdy,
                                x2 + wdx, y2 + wdy,
-                               x1 + wdx, y1 + wdy);
+                               x1 + wdx, y1 + wdy, cur_r, cur_g, cur_b, cur_a);
 
   /* Don't bother capping hairlines */
   if (circular_caps && !hairline)
@@ -353,10 +403,10 @@ hidgl_draw_arc (double width, int x, int y, int rx, int ry,
     outer_x = -outer_r * cos_ang + x;  outer_y = outer_r * sin_ang + y;
     hidgl_add_triangle (&buffer, last_inner_x, last_inner_y,
                                  last_outer_x, last_outer_y,
-                                 outer_x, outer_y);
+                                 outer_x, outer_y, cur_r, cur_g, cur_b, cur_a);
     hidgl_add_triangle (&buffer, last_inner_x, last_inner_y,
                                  inner_x, inner_y,
-                                 outer_x, outer_y);
+                                 outer_x, outer_y, cur_r, cur_g, cur_b, cur_a);
     last_inner_x = inner_x;  last_inner_y = inner_y;
     last_outer_x = outer_x;  last_outer_y = outer_y;
   }
@@ -412,7 +462,7 @@ hidgl_fill_circle (int vx, int vy, int vr, double scale)
     float x, y;
     x = radius * cosf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vx;
     y = radius * sinf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vy;
-    hidgl_add_triangle (&buffer, vx, vy, last_x, last_y, x, y);
+    hidgl_add_triangle (&buffer, vx, vy, last_x, last_y, x, y, cur_r, cur_g, cur_b, cur_a);
     last_x = x;
     last_y = y;
   }
@@ -501,7 +551,7 @@ myVertex (GLdouble *vertex_data)
           hidgl_add_triangle (&buffer,
                               triangle_vertices [0], triangle_vertices [1],
                               triangle_vertices [2], triangle_vertices [3],
-                              vertex_data [0], vertex_data [1]);
+                              vertex_data [0], vertex_data [1], cur_r, cur_g, cur_b, cur_a);
 
           if (tessVertexType == GL_TRIANGLE_STRIP)
             {
@@ -525,7 +575,7 @@ myVertex (GLdouble *vertex_data)
           hidgl_add_triangle (&buffer,
                               triangle_vertices [0], triangle_vertices [1],
                               triangle_vertices [2], triangle_vertices [3],
-                              triangle_vertices [4], triangle_vertices [5]);
+                              triangle_vertices [4], triangle_vertices [5], cur_r, cur_g, cur_b, cur_a);
           triangle_comp_idx = 0;
           stashed_vertices = 0;
         }
@@ -684,8 +734,8 @@ void
 hidgl_fill_rect (int x1, int y1, int x2, int y2)
 {
   hidgl_ensure_triangle_space (&buffer, 2);
-  hidgl_add_triangle (&buffer, x1, y1, x1, y2, x2, y2);
-  hidgl_add_triangle (&buffer, x2, y1, x2, y2, x1, y1);
+  hidgl_add_triangle (&buffer, x1, y1, x1, y2, x2, y2, cur_r, cur_g, cur_b, cur_a);
+  hidgl_add_triangle (&buffer, x2, y1, x2, y2, x1, y1, cur_r, cur_g, cur_b, cur_a);
 }
 
 void
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index aa2985e..89ef8a5 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -23,11 +23,27 @@
 #ifndef __HIDGL_INCLUDED__
 #define __HIDGL_INCLUDED__
 
+typedef struct {
+  GLfloat x;
+  GLfloat y;
+  GLfloat z;
+  GLfloat r;
+  GLfloat g;
+  GLfloat b;
+  GLfloat a;
+} tri_array_element;
+
 #define TRIANGLE_ARRAY_SIZE 5461
+#define TRIANGLE_ARRAY_BYTES (3 * sizeof (tri_array_element) * TRIANGLE_ARRAY_SIZE)
+
 typedef struct {
-  GLfloat triangle_array [3 * 3 * TRIANGLE_ARRAY_SIZE];
+//  GLfloat triangle_array [3 * 3 * TRIANGLE_ARRAY_SIZE];
+//  GLfloat *triangle_array;
+  tri_array_element *triangle_array;
   unsigned int triangle_count;
-  unsigned int coord_comp_count;
+//  unsigned int coord_comp_count;
+  unsigned int array_size;
+  GLuint vbo_name;
 } triangle_buffer;
 
 extern triangle_buffer buffer;
@@ -36,22 +52,42 @@ extern float global_depth;
 void hidgl_init_triangle_array (triangle_buffer *buffer);
 void hidgl_flush_triangles (triangle_buffer *buffer);
 void hidgl_ensure_triangle_space (triangle_buffer *buffer, int count);
+void hidgl_color (GLfloat r, GLfloat g, GLfloat b, GLfloat a);
 
 static inline void
 hidgl_add_triangle_3D (triangle_buffer *buffer,
                        GLfloat x1, GLfloat y1, GLfloat z1,
                        GLfloat x2, GLfloat y2, GLfloat z2,
-                       GLfloat x3, GLfloat y3, GLfloat z3)
+                       GLfloat x3, GLfloat y3, GLfloat z3,
+                       GLfloat r, GLfloat g,
+                       GLfloat b, GLfloat a)
 {
-  buffer->triangle_array [buffer->coord_comp_count++] = x1;
-  buffer->triangle_array [buffer->coord_comp_count++] = y1;
-  buffer->triangle_array [buffer->coord_comp_count++] = z1;
-  buffer->triangle_array [buffer->coord_comp_count++] = x2;
-  buffer->triangle_array [buffer->coord_comp_count++] = y2;
-  buffer->triangle_array [buffer->coord_comp_count++] = z2;
-  buffer->triangle_array [buffer->coord_comp_count++] = x3;
-  buffer->triangle_array [buffer->coord_comp_count++] = y3;
-  buffer->triangle_array [buffer->coord_comp_count++] = z3;
+  int i = 0;
+
+  buffer->triangle_array[buffer->triangle_count * 3 + i].x = x1;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].y = y1;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].z = z1;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].r = r;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].g = g;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].b = b;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].a = a;
+  i++;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].x = x2;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].y = y2;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].z = z2;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].r = r;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].g = g;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].b = b;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].a = a;
+  i++;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].x = x3;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].y = y3;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].z = z3;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].r = r;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].g = g;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].b = b;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].a = a;
+
   buffer->triangle_count++;
 }
 
@@ -59,11 +95,14 @@ static inline void
 hidgl_add_triangle (triangle_buffer *buffer,
                     GLfloat x1, GLfloat y1,
                     GLfloat x2, GLfloat y2,
-                    GLfloat x3, GLfloat y3)
+                    GLfloat x3, GLfloat y3,
+                    GLfloat r, GLfloat g,
+                    GLfloat b, GLfloat a)
 {
   hidgl_add_triangle_3D (buffer, x1, y1, global_depth,
                                  x2, y2, global_depth,
-                                 x3, y3, global_depth);
+                                 x3, y3, global_depth,
+                                 r, g, b, a);
 }
 
 // void draw_grid ()
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 814c1ac..ae424d3 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -591,8 +591,7 @@ ghid_set_color (hidGC gc, const char *name)
   if( ! ghid_gui_is_up )
     return;
 
-  hidgl_flush_triangles (&buffer);
-  glColor4d (r, g, b, a);
+  hidgl_color (r, g, b, a);
 }
 
 static void
@@ -2019,6 +2018,10 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   gui->set_layer (NULL, GetLayerGroupNumberByNumber (INDEXOFCURRENT), 0);
   gui->set_layer (NULL, SL_FINISHED, 0);
 
+  glUnmapBuffer (GL_ARRAY_BUFFER);
+  glBindBuffer(GL_ARRAY_BUFFER, 0);
+  glDeleteBuffers (1, &buffer.vbo_name);
+
   ghid_draw_grid (&region);
 
   hidgl_init_triangle_array (&buffer);
@@ -2048,6 +2051,10 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   hidgl_flush_triangles (&buffer);
 
+  glUnmapBuffer (GL_ARRAY_BUFFER);
+  glBindBuffer(GL_ARRAY_BUFFER, 0);
+  glDeleteBuffers (1, &buffer.vbo_name);
+
   check_gl_drawing_ok_hack = false;
   ghid_end_drawing (port);
 
@@ -2155,6 +2162,10 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   hidgl_flush_triangles (&buffer);
   glPopMatrix ();
 
+  glUnmapBuffer (GL_ARRAY_BUFFER);
+  glBindBuffer(GL_ARRAY_BUFFER, 0);
+  glDeleteBuffers (1, &buffer.vbo_name);
+
   if (gdk_gl_drawable_is_double_buffered (pGlDrawable))
     gdk_gl_drawable_swap_buffers (pGlDrawable);
   else

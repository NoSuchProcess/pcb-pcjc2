Bottom: 3e40457ef4384160ad34f127ed8c1d56cd271c9c
Top:    3218ef931201536e9858184eff9a9300ee03dbc6
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-12-06 20:44:28 +0000

Use the stencil buffer more cleverly


---

diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index cf34132..3ca7387 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -869,51 +869,59 @@ hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box)
       return;
     }
 
-  stencil_bit = hidgl_assign_clear_stencil_bit ();
-  if (!stencil_bit)
-    {
-      printf ("hidgl_fill_pcb_polygon: No free stencil bits, aborting polygon\n");
-      return;
-    }
+  if (poly->Clipped->contour_tree->size > 1) {
+    /* Polygon has holes */
+
+    stencil_bit = hidgl_assign_clear_stencil_bit ();
+    if (!stencil_bit)
+      {
+        printf ("hidgl_fill_pcb_polygon: No free stencil bits, aborting polygon\n");
+        /* XXX: Could use the GLU tesselator or the full BO polygon tesselator */
+        return;
+      }
 
-  /* Flush out any existing geoemtry to be rendered */
-  hidgl_flush_triangles (&buffer);
+    /* Flush out any existing geoemtry to be rendered */
+    hidgl_flush_triangles (&buffer);
 
-  glPushAttrib (GL_STENCIL_BUFFER_BIT);                   // Save the write mask etc.. for final restore
-  glPushAttrib (GL_STENCIL_BUFFER_BIT |                   // Resave the stencil write-mask etc.., and
-                GL_COLOR_BUFFER_BIT);                     // the colour buffer write mask etc.. for part way restore
-  glStencilMask (stencil_bit);                            // Only write to our stencil bit
-  glStencilFunc (GL_ALWAYS, stencil_bit, stencil_bit);    // Always pass stencil test, ref value is our bit
-  glColorMask (0, 0, 0, 0);                               // Disable writting in color buffer
+    glPushAttrib (GL_STENCIL_BUFFER_BIT |                   // Resave the stencil write-mask etc.., and
+                  GL_COLOR_BUFFER_BIT);                     // the colour buffer write mask etc.. for part way restore
+    glStencilMask (stencil_bit);                            // Only write to our stencil bit
+    glStencilFunc (GL_ALWAYS, stencil_bit, stencil_bit);    // Always pass stencil test, ref value is our bit
+    glColorMask (0, 0, 0, 0);                               // Disable writting in color buffer
 
-  /* It will already be setup like this (so avoid prodding the state-machine):
-   * glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value
-   */
-  /* Drawing operations now set our reference bit in the stencil buffer */
+    /* It will already be setup like this (so avoid prodding the state-machine):
+     * glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value
+     */
+    /* Drawing operations now set our reference bit in the stencil buffer */
 
-  r_search (poly->Clipped->contour_tree, clip_box, NULL, do_hole, NULL);
-  hidgl_flush_triangles (&buffer);
+    r_search (poly->Clipped->contour_tree, clip_box, NULL, do_hole, NULL);
+    hidgl_flush_triangles (&buffer);
 
-  /* Drawing operations as masked to areas where the stencil buffer is '0' */
+    /* Drawing operations as masked to areas where the stencil buffer is '0' */
 
-  glPopAttrib ();                                             // Restore the colour and stencil buffer write-mask etc..
+    glPopAttrib ();                                             // Restore the colour and stencil buffer write-mask etc..
+    glPushAttrib (GL_STENCIL_BUFFER_BIT);                       // Save the stencil op and function
 
-  glStencilOp (GL_KEEP, GL_KEEP, GL_INVERT); // This allows us to toggle the bit on the subcompositing bitplane
-                                             // If the stencil test has passed, we know that bit is 0, so we're
-                                             // effectively just setting it to 1.
-  glStencilFunc (GL_GEQUAL, 0, assigned_bits);
-//  glStencilFunc (GL_GREATER, assigned_bits, assigned_bits);   // Pass stencil test if all assigned bits clear,
-                                                              // reference is all assigned bits so we set
-                                                              // any bits permitted by the stencil writemask
+    glStencilOp (GL_KEEP, GL_KEEP, GL_INVERT); // This allows us to toggle the bit on the subcompositing bitplane
+                                               // If the stencil test has passed, we know that bit is 0, so we're
+                                               // effectively just setting it to 1.
+    glStencilFunc (GL_GEQUAL, 0, assigned_bits);
+  //  glStencilFunc (GL_GREATER, assigned_bits, assigned_bits);   // Pass stencil test if all assigned bits clear,
+                                                                // reference is all assigned bits so we set
+                                                                // any bits permitted by the stencil writemask
+    /* Draw the polygon outer */
+    fill_contour (poly->Clipped->contours);
+    hidgl_flush_triangles (&buffer);
 
-  /* Draw the polygon outer */
-  fill_contour (poly->Clipped->contours);
-  hidgl_flush_triangles (&buffer);
+    /* Unassign our stencil buffer bit */
+    hidgl_return_stencil_bit (stencil_bit);
 
-  /* Unassign our stencil buffer bit */
-  hidgl_return_stencil_bit (stencil_bit);
+    glPopAttrib ();                                             // Restore the stencil buffer op and function
 
-  glPopAttrib ();                                             // Restore the stencil buffer write-mask etc..
+  } else {
+    /* Polygon does not have holes */
+    fill_contour (poly->Clipped->contours);
+  }
 }
 
 void
@@ -991,6 +999,8 @@ hidgl_stencil_bits (void)
   return stencil_bits;
 }
 
+int debug_stencil_clears = 0;
+
 static void
 hidgl_clean_unassigned_stencil (void)
 {
@@ -1000,6 +1010,7 @@ hidgl_clean_unassigned_stencil (void)
   glClearStencil (0);
   glClear (GL_STENCIL_BUFFER_BIT);
   glPopAttrib ();
+  debug_stencil_clears++;
 }
 
 int
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index c3429ec..4e38666 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -1840,6 +1840,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
                      0, 0, 1, 0,
                      0, 0, 0, 1};
   bool horizon_problem = false;
+  extern int debug_stencil_clears;
 
   buffer.total_triangles = 0;
   buffer.total_vertices = 0;
@@ -1849,6 +1850,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   hidgl_in_context (true);
   hidgl_init ();
   check_gl_drawing_ok_hack = true;
+  debug_stencil_clears = 0;
 
   /* If we don't have any stencil bits available,
      we can't use the hidgl polygon drawing routine */
@@ -2096,6 +2098,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
 //  printf ("Triangle count was %i\n", buffer.total_triangles);
 //  printf ("Vertex count was %i\n", buffer.total_vertices);
+//  printf ("Stencil clears in frame: %i\n", debug_stencil_clears);
 
   return FALSE;
 }

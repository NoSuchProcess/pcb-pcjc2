Bottom: 251d6c3eddbbecaffe60b46c30a70d7cc633c184
Top:    a20214d3445bbf8317348ef94837d63d391ab6ca
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-10-01 13:22:39 +0100

toporouter.c: Re-implement coord_move_towards_coord_values() with atan2


---

diff --git a/src/toporouter.c b/src/toporouter.c
index 61d94d5..300d2f7 100644
--- a/src/toporouter.c
+++ b/src/toporouter.c
@@ -783,112 +783,43 @@ sloppy_vertex_wind(GtsVertex *a, GtsVertex *b, GtsVertex *c)
 }
 
 /* moves vertex v d units in the direction of vertex p */
-void
-coord_move_towards_coord_values(gdouble ax, gdouble ay, gdouble px, gdouble py, gdouble d, gdouble *x, gdouble *y) 
+static void
+coord_move_towards_coord_values (double ax, double ay,
+                                 double px, double py,
+                                 double d,
+                                 double *x, double *y)
 {
-  gdouble dx = px - ax;
-  gdouble dy = py - ay;
-  gdouble theta = atan(fabs(dy/dx));
-
-
-  if(!finite(theta)) {
-    printf("!finite(theta) a = %f,%f p = %f,%f d = %f\n", 
-        ax, ay, px, py, d);
-
-  }
-
-  g_assert(finite(theta));
-
-  if( dx >= 0. ) {
-
-    if( dy >= 0. ) {
-      *x = ax + (d * cos(theta));
-      *y = ay + (d * sin(theta));
-    }else{
-      *x = ax + (d * cos(theta));
-      *y = ay - (d * sin(theta));
-    }
-
-  }else{
-    
-    if( dy >= 0. ) {
-      *x = ax - (d * cos(theta));
-      *y = ay + (d * sin(theta));
-    }else{
-      *x = ax - (d * cos(theta));
-      *y = ay - (d * sin(theta));
-    }
-
-  }
+  double theta = atan2 (py - ay, px - ax);
 
+  *x = ax + d * cos (theta);
+  *y = ay + d * sin (theta);
 }
 
 /* moves vertex v d units in the direction of vertex p */
-void
-vertex_move_towards_point_values(GtsVertex *v, gdouble px, gdouble py, gdouble d, gdouble *x, gdouble *y) 
+static void
+vertex_move_towards_point_values (GtsVertex *v,
+                                  double px, double py,
+                                  double d,
+                                  double *x, double *y)
 {
-  gdouble dx = px - GTS_POINT(v)->x;
-  gdouble dy = py - GTS_POINT(v)->y;
-  gdouble theta = atan(fabs(dy/dx));
-
-  g_assert(finite(theta));
-
-  if( dx >= 0. ) {
-
-    if( dy >= 0. ) {
-      *x = GTS_POINT(v)->x + (d * cos(theta));
-      *y = GTS_POINT(v)->y + (d * sin(theta));
-    }else{
-      *x = GTS_POINT(v)->x + (d * cos(theta));
-      *y = GTS_POINT(v)->y - (d * sin(theta));
-    }
-
-  }else{
-    
-    if( dy >= 0. ) {
-      *x = GTS_POINT(v)->x - (d * cos(theta));
-      *y = GTS_POINT(v)->y + (d * sin(theta));
-    }else{
-      *x = GTS_POINT(v)->x - (d * cos(theta));
-      *y = GTS_POINT(v)->y - (d * sin(theta));
-    }
-
-  }
+  double theta = atan2 (py - GTS_POINT(v)->y, px - GTS_POINT(v)->x);
 
+  *x = GTS_POINT(v)->x + d * cos(theta);
+  *y = GTS_POINT(v)->y + d * sin(theta);
 }
 
 /* moves vertex v d units in the direction of vertex p */
-void
-vertex_move_towards_vertex_values(GtsVertex *v, GtsVertex *p, gdouble d, gdouble *x, gdouble *y) 
+static void
+vertex_move_towards_vertex_values (GtsVertex *v,
+                                   GtsVertex *p,
+                                   double d,
+                                   double *x, double *y)
 {
-  gdouble dx = GTS_POINT(p)->x - GTS_POINT(v)->x;
-  gdouble dy = GTS_POINT(p)->y - GTS_POINT(v)->y;
-  gdouble theta = atan(fabs(dy/dx));
-
-  g_assert(finite(theta));
-
-  if( dx >= 0. ) {
-
-    if( dy >= 0. ) {
-      *x = GTS_POINT(v)->x + (d * cos(theta));
-      *y = GTS_POINT(v)->y + (d * sin(theta));
-    }else{
-      *x = GTS_POINT(v)->x + (d * cos(theta));
-      *y = GTS_POINT(v)->y - (d * sin(theta));
-    }
-
-  }else{
-    
-    if( dy >= 0. ) {
-      *x = GTS_POINT(v)->x - (d * cos(theta));
-      *y = GTS_POINT(v)->y + (d * sin(theta));
-    }else{
-      *x = GTS_POINT(v)->x - (d * cos(theta));
-      *y = GTS_POINT(v)->y - (d * sin(theta));
-    }
-
-  }
+  double theta = atan2 (GTS_POINT(p)->y - GTS_POINT(v)->y,
+                        GTS_POINT(p)->x - GTS_POINT(v)->x);
 
+  *x = GTS_POINT(v)->x + d * cos (theta);
+  *y = GTS_POINT(v)->y + d * sin (theta);
 }
 
 #define tv_on_layer(v,l) (l == TOPOROUTER_BBOX(TOPOROUTER_VERTEX(v)->boxes->data)->layer)
@@ -2605,48 +2536,17 @@ visited_cmp(gconstpointer a, gconstpointer b)
   return 0;
 }
 
-gdouble 
-coord_xangle(gdouble ax, gdouble ay, gdouble bx, gdouble by) 
+static double
+coord_xangle (double ax, double ay,
+              double bx, double by)
 {
-  gdouble dx, dy, theta;
-
-  dx = fabs(ax - bx);
-  dy = fabs(ay - by);
-  
-  if(dx < EPSILON) {
-    theta = M_PI / 2.;
-  } else theta = atan(dy/dx);
-
-  if(by <= ay) {
-    if(bx < ax) theta = M_PI - theta;
-  }else{
-    if(bx < ax) theta += M_PI;
-    else theta = (2 * M_PI) - theta;
-  }
-  
-  return theta;  
+  return atan2 (ay - by, ax - bx);
 }
 
-gdouble 
-point_xangle(GtsPoint *a, GtsPoint *b) 
+static double
+point_xangle (GtsPoint *a, GtsPoint *b)
 {
-  gdouble dx, dy, theta;
-
-  dx = fabs(a->x - b->x);
-  dy = fabs(a->y - b->y);
-  
-  if(dx < EPSILON) {
-    theta = M_PI / 2.;
-  } else theta = atan(dy/dx);
-
-  if(b->y >= a->y) {
-    if(b->x < a->x) theta = M_PI - theta;
-  }else{
-    if(b->x < a->x) theta += M_PI;
-    else theta = (2 * M_PI) - theta;
-  }
-
-  return theta;  
+  return atan2 (a->y - b->y, a->x - b->x);
 }
 
 
@@ -5163,71 +5063,28 @@ routing_return:
 }
 
 /* moves vertex v d units in the direction of vertex p */
-void
-vertex_move_towards_point(GtsVertex *v, gdouble px, gdouble py, gdouble d) 
+static void
+vertex_move_towards_point (GtsVertex *v,
+                           double px, double py,
+                           double d)
 {
-  gdouble dx = px - GTS_POINT(v)->x;
-  gdouble dy = py - GTS_POINT(v)->y;
-  gdouble theta = atan(fabs(dy/dx));
-
-  g_assert(finite(theta));
-
-  if( dx >= 0. ) {
-
-    if( dy >= 0. ) {
-      GTS_POINT(v)->x += d * cos(theta);
-      GTS_POINT(v)->y += d * sin(theta);
-    }else{
-      GTS_POINT(v)->x += d * cos(theta);
-      GTS_POINT(v)->y -= d * sin(theta);
-    }
-
-  }else{
-    
-    if( dy >= 0. ) {
-      GTS_POINT(v)->x -= d * cos(theta);
-      GTS_POINT(v)->y += d * sin(theta);
-    }else{
-      GTS_POINT(v)->x -= d * cos(theta);
-      GTS_POINT(v)->y -= d * sin(theta);
-    }
-
-  }
+  double theta = atan2 (py - GTS_POINT(v)->y, px - GTS_POINT(v)->x);
 
+  GTS_POINT(v)->x += d * cos (theta);
+  GTS_POINT(v)->y += d * sin (theta);
 }
 
 /* moves vertex v d units in the direction of vertex p */
 void
-vertex_move_towards_vertex(GtsVertex *v, GtsVertex *p, gdouble d) 
+vertex_move_towards_vertex (GtsVertex *v,
+                            GtsVertex *p,
+                            double d)
 {
-  gdouble dx = GTS_POINT(p)->x - GTS_POINT(v)->x;
-  gdouble dy = GTS_POINT(p)->y - GTS_POINT(v)->y;
-  gdouble theta = atan(fabs(dy/dx));
-
-  g_assert(finite(theta));
-
-  if( dx >= 0. ) {
-
-    if( dy >= 0. ) {
-      GTS_POINT(v)->x += d * cos(theta);
-      GTS_POINT(v)->y += d * sin(theta);
-    }else{
-      GTS_POINT(v)->x += d * cos(theta);
-      GTS_POINT(v)->y -= d * sin(theta);
-    }
-
-  }else{
-    
-    if( dy >= 0. ) {
-      GTS_POINT(v)->x -= d * cos(theta);
-      GTS_POINT(v)->y += d * sin(theta);
-    }else{
-      GTS_POINT(v)->x -= d * cos(theta);
-      GTS_POINT(v)->y -= d * sin(theta);
-    }
-
-  }
+  double theta = atan2 (GTS_POINT(p)->y - GTS_POINT(v)->y,
+                        GTS_POINT(p)->x - GTS_POINT(v)->x);
 
+  GTS_POINT(v)->x += d * cos (theta);
+  GTS_POINT(v)->y += d * sin (theta);
 }

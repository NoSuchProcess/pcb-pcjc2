Bottom: b37ee3e86ea47e2ea4e3994d123b6dac4c1a082d
Top:    366e41e56e97214cbb9559bf946c0761ee92df89
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-12-27 00:22:57 +0000

WOW.. TESTING


---

diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index 0a2cc59..916119c 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -70,10 +70,11 @@ ghid_draw_grid (void)
   static int npoints = 0;
   int x1, y1, x2, y2, n, i;
   double x, y;
+  return;
 
   if (!Settings.DrawGrid)
     return;
-  if (Vz (PCB->Grid) < MIN_GRID_DISTANCE)
+  if (SCREEN_R (PCB->Grid) < MIN_GRID_DISTANCE)
     return;
   if (!gport->grid_gc)
     {
@@ -88,11 +89,10 @@ ghid_draw_grid (void)
       gdk_gc_set_function (gport->grid_gc, GDK_XOR);
       gdk_gc_set_foreground (gport->grid_gc, &gport->grid_color);
     }
-  x1 = GRIDFIT_X (SIDE_X (gport->view_x0), PCB->Grid);
-  y1 = GRIDFIT_Y (SIDE_Y (gport->view_y0), PCB->Grid);
-  x2 = GRIDFIT_X (SIDE_X (gport->view_x0 + gport->view_width - 1), PCB->Grid);
-  y2 =
-    GRIDFIT_Y (SIDE_Y (gport->view_y0 + gport->view_height - 1), PCB->Grid);
+  x1 = GRIDFIT_X (gport->view_x0, PCB->Grid);
+  y1 = GRIDFIT_Y (gport->view_y0, PCB->Grid);
+  x2 = GRIDFIT_X (gport->view_x0 + FLIP_X (gport->view_width)  - 1, PCB->Grid);
+  y2 = GRIDFIT_Y (gport->view_y0 + FLIP_Y (gport->view_height) - 1, PCB->Grid);
   if (x1 > x2)
     {
       int tmp = x1;
@@ -105,13 +105,13 @@ ghid_draw_grid (void)
       y1 = y2;
       y2 = tmp;
     }
-  if (Vx (x1) < 0)
+  if (SCREEN_X (x1) < 0)
     x1 += PCB->Grid;
-  if (Vy (y1) < 0)
+  if (SCREEN_Y (y1) < 0)
     y1 += PCB->Grid;
-  if (Vx (x2) >= gport->width)
+  if (SCREEN_X (x2) >= gport->width)
     x2 -= PCB->Grid;
-  if (Vy (y2) >= gport->height)
+  if (SCREEN_Y (y2) >= gport->height)
     y2 -= PCB->Grid;
   n = (int) ((x2 - x1) / PCB->Grid + 0.5) + 1;
   if (n > npoints)
@@ -122,14 +122,14 @@ ghid_draw_grid (void)
   n = 0;
   for (x = x1; x <= x2; x += PCB->Grid)
     {
-      points[n].x = Vx (x);
+      points[n].x = SCREEN_X (x);
       n++;
     }
   if (n == 0)
     return;
   for (y = y1; y <= y2; y += PCB->Grid)
     {
-      int vy = Vy (y);
+      int vy = SCREEN_Y (y);
       for (i = 0; i < n; i++)
 	points[i].y = vy;
       gdk_draw_points (gport->drawable, gport->grid_gc, points, n);
@@ -386,7 +386,7 @@ ghid_set_line_cap (hidGC gc, EndCapStyle style)
     }
   if (gc->gc)
     gdk_gc_set_line_attributes (WHICH_GC (gc),
-				Vz (gc->width), GDK_LINE_SOLID,
+				SCREEN_R (gc->width), GDK_LINE_SOLID,
 				gc->cap, gc->join);
 }
 
@@ -397,7 +397,7 @@ ghid_set_line_width (hidGC gc, int width)
   gc->width = width;
   if (gc->gc)
     gdk_gc_set_line_attributes (WHICH_GC (gc),
-				Vz (gc->width), GDK_LINE_SOLID,
+				SCREEN_R (gc->width), GDK_LINE_SOLID,
 				gc->cap, gc->join);
 }
 
@@ -460,10 +460,10 @@ ghid_draw_line (hidGC gc, int x1, int y1, int x2, int y2)
 {
   double dx1, dy1, dx2, dy2;
 
-  dx1 = Vx ((double) x1);
-  dy1 = Vy ((double) y1);
-  dx2 = Vx ((double) x2);
-  dy2 = Vy ((double) y2);
+  dx1 = SCREEN_X ((double) x1);
+  dy1 = SCREEN_Y ((double) y1);
+  dx2 = SCREEN_X ((double) x2);
+  dy2 = SCREEN_Y ((double) y2);
 
   if (!ClipLine (0, 0, gport->width, gport->height,
 		 &dx1, &dy1, &dx2, &dy2, gc->width / gport->zoom))
@@ -483,15 +483,17 @@ ghid_draw_arc (hidGC gc, int cx, int cy,
   w = gport->width * gport->zoom;
   h = gport->height * gport->zoom;
   radius = (xradius > yradius) ? xradius : yradius;
+#if 0
   if (SIDE_X (cx) < gport->view_x0 - radius
       || SIDE_X (cx) > gport->view_x0 + w + radius
       || SIDE_Y (cy) < gport->view_y0 - radius
       || SIDE_Y (cy) > gport->view_y0 + h + radius)
     return;
+#endif
 
   USE_GC (gc);
-  vrx = Vz (xradius);
-  vry = Vz (yradius);
+  vrx = SCREEN_R (xradius);
+  vry = SCREEN_R (yradius);
 
   if (ghid_flip_x)
     {
@@ -507,7 +509,7 @@ ghid_draw_arc (hidGC gc, int cx, int cy,
   start_angle = (start_angle + 360 + 180) % 360 - 180;
 
   gdk_draw_arc (gport->drawable, gport->u_gc, 0,
-		Vx (cx) - vrx, Vy (cy) - vry,
+		SCREEN_X (cx) - vrx, SCREEN_Y (cy) - vry,
 		vrx * 2, vry * 2, (start_angle + 180) * 64, delta_angle * 64);
 }
 
@@ -520,6 +522,7 @@ ghid_draw_rect (hidGC gc, int x1, int y1, int x2, int y2)
   w = gport->width * gport->zoom;
   h = gport->height * gport->zoom;
 
+#if 0
   if ((SIDE_X (x1) < gport->view_x0 - lw
        && SIDE_X (x2) < gport->view_x0 - lw)
       || (SIDE_X (x1) > gport->view_x0 + w + lw
@@ -529,11 +532,12 @@ ghid_draw_rect (hidGC gc, int x1, int y1, int x2, int y2)
       || (SIDE_Y (y1) > gport->view_y0 + h + lw
 	  && SIDE_Y (y2) > gport->view_y0 + h + lw))
     return;
+#endif
 
-  x1 = Vx (x1);
-  y1 = Vy (y1);
-  x2 = Vx (x2);
-  y2 = Vy (y2);
+  x1 = SCREEN_X (x1);
+  y1 = SCREEN_Y (y1);
+  x2 = SCREEN_X (x2);
+  y2 = SCREEN_Y (y2);
 
   if (x1 > x2)
     {
@@ -561,16 +565,18 @@ ghid_fill_circle (hidGC gc, int cx, int cy, int radius)
 
   w = gport->width * gport->zoom;
   h = gport->height * gport->zoom;
+#if 0
   if (SIDE_X (cx) < gport->view_x0 - radius
       || SIDE_X (cx) > gport->view_x0 + w + radius
       || SIDE_Y (cy) < gport->view_y0 - radius
       || SIDE_Y (cy) > gport->view_y0 + h + radius)
     return;
+#endif
 
   USE_GC (gc);
-  vr = Vz (radius);
+  vr = SCREEN_R (radius);
   gdk_draw_arc (gport->drawable, gport->u_gc, TRUE,
-		Vx (cx) - vr, Vy (cy) - vr, vr * 2, vr * 2, 0, 360 * 64);
+		SCREEN_X (cx) - vr, SCREEN_Y (cy) - vr, vr * 2, vr * 2, 0, 360 * 64);
 }
 
 void
@@ -588,8 +594,8 @@ ghid_fill_polygon (hidGC gc, int n_coords, int *x, int *y)
     }
   for (i = 0; i < n_coords; i++)
     {
-      points[i].x = Vx (x[i]);
-      points[i].y = Vy (y[i]);
+      points[i].x = SCREEN_X (x[i]);
+      points[i].y = SCREEN_Y (y[i]);
     }
   gdk_draw_polygon (gport->drawable, gport->u_gc, 1, points, n_coords);
 }
@@ -603,6 +609,7 @@ ghid_fill_rect (hidGC gc, int x1, int y1, int x2, int y2)
   w = gport->width * gport->zoom;
   h = gport->height * gport->zoom;
 
+#if 0
   if ((SIDE_X (x1) < gport->view_x0 - lw
        && SIDE_X (x2) < gport->view_x0 - lw)
       || (SIDE_X (x1) > gport->view_x0 + w + lw
@@ -612,11 +619,12 @@ ghid_fill_rect (hidGC gc, int x1, int y1, int x2, int y2)
       || (SIDE_Y (y1) > gport->view_y0 + h + lw
 	  && SIDE_Y (y2) > gport->view_y0 + h + lw))
     return;
+#endif
 
-  x1 = Vx (x1);
-  y1 = Vy (y1);
-  x2 = Vx (x2);
-  y2 = Vy (y2);
+  x1 = SCREEN_X (x1);
+  y1 = SCREEN_Y (y1);
+  x2 = SCREEN_X (x2);
+  y2 = SCREEN_Y (y2);
   if (x2 < x1)
     {
       xx = x1;
@@ -649,15 +657,15 @@ ghid_invalidate_all ()
   if (!gport->pixmap)
     return;
 
-  region.X1 = MIN(Px(0), Px(gport->width + 1));
-  region.Y1 = MIN(Py(0), Py(gport->height + 1));
-  region.X2 = MAX(Px(0), Px(gport->width + 1));
-  region.Y2 = MAX(Py(0), Py(gport->height + 1));
+  region.X1 = MIN(PCB_X (0), PCB_X (gport->width  + 1));
+  region.Y1 = MIN(PCB_Y (0), PCB_Y (gport->height + 1));
+  region.X2 = MAX(PCB_X (0), PCB_X (gport->width  + 1));
+  region.Y2 = MAX(PCB_Y (0), PCB_Y (gport->height + 1));
 
-  eleft = Vx (0);
-  eright = Vx (PCB->MaxWidth);
-  etop = Vy (0);
-  ebottom = Vy (PCB->MaxHeight);
+  eleft =   SCREEN_X (0);
+  eright =  SCREEN_X (PCB->MaxWidth);
+  etop =    SCREEN_Y (0);
+  ebottom = SCREEN_Y (PCB->MaxHeight);
   if (eleft > eright)
     {
       int tmp = eleft;
@@ -822,8 +830,8 @@ ghid_show_crosshair (gboolean show)
       /* FIXME: when CrossColor changed from config */
       ghid_map_color_string (Settings.CrossColor, &cross_color);
     }
-  x = DRAW_X (gport->x_crosshair);
-  y = DRAW_Y (gport->y_crosshair);
+  x = SCREEN_X (gport->x_crosshair);
+  y = SCREEN_Y (gport->y_crosshair);
 
   gdk_gc_set_foreground (xor_gc, &cross_color);
 
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 8bbf3eb..d3fe183 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -42,30 +42,30 @@ ghid_pan_fixup ()
    * don't pan so far to the right that we see way past the right 
    * edge of the board.
    */
-  if (gport->view_x0 > PCB->MaxWidth - gport->view_width)
-    gport->view_x0 = PCB->MaxWidth - gport->view_width;
+//  if (gport->view_x0 > PCB->MaxWidth - gport->view_width)
+//    gport->view_x0 = PCB->MaxWidth - gport->view_width;
 
   /*
    * don't pan so far down that we see way past the bottom edge of
    * the board.
    */
-  if (gport->view_y0 > PCB->MaxHeight - gport->view_height)
-    gport->view_y0 = PCB->MaxHeight - gport->view_height;
+//  if (gport->view_y0 > PCB->MaxHeight - gport->view_height)
+//    gport->view_y0 = PCB->MaxHeight - gport->view_height;
 
   /* don't view above or to the left of the board... ever */
-  if (gport->view_x0 < 0)
-    gport->view_x0 = 0;
+//  if (gport->view_x0 < 0)
+//    gport->view_x0 = 0;
 
-   if (gport->view_y0 < 0)
-    gport->view_y0 = 0;
+//   if (gport->view_y0 < 0)
+//    gport->view_y0 = 0;
 
   /* if we can see the entire board and some, then zoom to fit */
-  if (gport->view_width > PCB->MaxWidth &&
-      gport->view_height > PCB->MaxHeight)
-    {
-      zoom_by (1, 0, 0);
-      return;
-    }
+//  if (gport->view_width > PCB->MaxWidth &&
+//      gport->view_height > PCB->MaxHeight)
+//    {
+//      zoom_by (1, 0, 0);
+//      return;
+//    }
 
   ghidgui->adjustment_changed_holdoff = TRUE;
   gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view_x0);
@@ -138,12 +138,6 @@ Zoom (int argc, char **argv, int x, int y)
       x = gport->view_width / 2;
       y = gport->view_height / 2;
     }
-  else
-    {
-      /* Px converts view->pcb, Vx converts pcb->view */
-      x = Vx (x);
-      y = Vy (y);
-    }
 
   if (argc < 1)
     {
@@ -182,8 +176,7 @@ Zoom (int argc, char **argv, int x, int y)
 static void
 zoom_to (double new_zoom, int x, int y)
 {
-  double max_zoom, xfrac, yfrac;
-  int cx, cy;
+//  double max_zoom;
 
   /* gport->zoom:
    * zoom value is PCB units per screen pixel.  Larger numbers mean zooming
@@ -194,85 +187,52 @@ zoom_to (double new_zoom, int x, int y)
    * gport->view_width and gport->view_height are in PCB coordinates
    */
 
-#ifdef DEBUG
-  printf ("\nzoom_to( %g, %d, %d)\n", new_zoom, x, y);
-#endif
-
-  xfrac = (double) x / (double) gport->view_width;
-  yfrac = (double) y / (double) gport->view_height;
-
-  if (ghid_flip_x)
-    xfrac = 1-xfrac;
-  if (ghid_flip_y)
-    yfrac = 1-yfrac;
-
   /* Find the zoom that would just make the entire board fit */
-  max_zoom = PCB->MaxWidth / gport->width;
-  if (max_zoom < PCB->MaxHeight / gport->height)
-    max_zoom = PCB->MaxHeight / gport->height;
-
-#ifdef DEBUG
-  printf ("zoom_to():  max_zoom = %g\n", max_zoom);
-#endif
+//  max_zoom = PCB->MaxWidth / gport->width;
+//  if (max_zoom < PCB->MaxHeight / gport->height)
+//    max_zoom = PCB->MaxHeight / gport->height;
 
-  /* 
+  /*
    * clip the zooming so we can never have more than 1 pixel per PCB
    * unit and never zoom out more than viewing the entire board
    */
-     
-  if (new_zoom < 1)
-    new_zoom = 1;
-  if (new_zoom > max_zoom)
-    new_zoom = max_zoom;
-
-#ifdef DEBUG
-  printf ("max_zoom = %g, xfrac = %g, yfrac = %g, new_zoom = %g\n", 
-	  max_zoom, xfrac, yfrac, new_zoom);
-#endif
-
-  /* find center x and y */
-  cx = gport->view_x0 + gport->view_width * xfrac * gport->zoom;
-  cy = gport->view_y0 + gport->view_height * yfrac * gport->zoom;
 
-#ifdef DEBUG
-  printf ("zoom_to():  x0 = %d, cx = %d\n", gport->view_x0, cx);
-  printf ("zoom_to():  y0 = %d, cy = %d\n", gport->view_y0, cy);
-#endif
+//  if (new_zoom < 1)
+//    new_zoom = 1;
+//  if (new_zoom > max_zoom)
+//    new_zoom = max_zoom;
 
-  if (gport->zoom != new_zoom)
+//  if (gport->zoom != new_zoom)
+  if (1)
     {
       gdouble xtmp, ytmp;
       gint x0, y0;
 
-      xtmp = (gport->view_x - gport->view_x0) / (gdouble) gport->view_width;
-      ytmp = (gport->view_y - gport->view_y0) / (gdouble) gport->view_height;
-      
+      xtmp = (x - gport->view_x0) / (double) gport->view_width;
+      ytmp = (y - gport->view_y0) / (double) gport->view_height;
+
       gport->zoom = new_zoom;
       pixel_slop = new_zoom;
       ghid_port_ranges_scale(FALSE);
 
       x0 = gport->view_x - xtmp * gport->view_width;
-      if (x0 < 0)
-	x0 = 0;
+//      if (x0 < 0)
+//	x0 = 0;
       gport->view_x0 = x0;
 
       y0 = gport->view_y - ytmp * gport->view_height;
-      if (y0 < 0)
-	y0 = 0;
+//      if (y0 < 0)
+//	y0 = 0;
       gport->view_y0 = y0;
-      
+
       ghidgui->adjustment_changed_holdoff = TRUE;
       gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view_x0);
       gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view_y0);
       ghidgui->adjustment_changed_holdoff = FALSE;
-      
+
       ghid_port_ranges_changed();
     }
 
-#ifdef DEBUG
-  printf ("zoom_to():  new x0 = %d\n", gport->view_x0);
-  printf ("zoom_to():  new y0 = %d\n", gport->view_y0);
-#endif
   ghid_set_status_line_label ();
 }
 
@@ -482,7 +442,8 @@ ghid_set_crosshair (int x, int y, int action)
        * but the value we've been given is relative to your drawing area
        */
       gdk_window_get_origin (gport->drawing_area->window, &xofs, &yofs);
-      gdk_display_warp_pointer (display, screen, xofs + Vx (x), yofs + Vy (y));
+      gdk_display_warp_pointer (display, screen, xofs + SCREEN_X (x),
+                                                 yofs + SCREEN_Y (y));
     }
 }
 
@@ -1645,25 +1606,25 @@ Center(int argc, char **argv, int x, int y)
   if (argc != 0)
     AFAIL (center);
 
-  x = GRIDFIT_X (SIDE_X (x), PCB->Grid);
-  y = GRIDFIT_Y (SIDE_Y (y), PCB->Grid);
+  x = GRIDFIT_X (x, PCB->Grid);
+  y = GRIDFIT_Y (y, PCB->Grid);
 
-  w2 = gport->view_width / 2;
-  h2 = gport->view_height / 2;
+  w2 = FLIP_X (gport->view_width) / 2;
+  h2 = FLIP_Y (gport->view_height) / 2;
   x0 = x - w2;
   y0 = y - h2;
 
-  if (x0 < 0)
-    {
-      x0 = 0;
-      x = x0 + w2;
-    }
+//  if (x0 < 0)
+//    {
+//      x0 = 0;
+//      x = x0 + w2;
+//    }
 
-  if (y0 < 0)
-    {
-      y0 = 0;
-      y = y0 + h2;
-    }
+//  if (y0 < 0)
+//    {
+//      y0 = 0;
+//      y = y0 + h2;
+//    }
 
   gport->view_x0 = x0;
   gport->view_y0 = y0;
@@ -1683,7 +1644,8 @@ Center(int argc, char **argv, int x, int y)
    * but the value we've been given is relative to your drawing area
    */
   gdk_window_get_origin (gport->drawing_area->window, &xofs, &yofs);
-  gdk_display_warp_pointer (display, screen, xofs + Vx (x), yofs + Vy (y));
+  gdk_display_warp_pointer (display, screen, xofs + SCREEN_X (x),
+                                             yofs + SCREEN_Y (y));
 
   return 0;
 }
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index e40f7d2..c19d433 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -143,10 +143,10 @@ ghid_port_ranges_scale (gboolean emit_changed)
   gport->view_width = gport->width * gport->zoom;
   gport->view_height = gport->height * gport->zoom;
 
-  if (gport->view_width >= PCB->MaxWidth)
-    gport->view_width = PCB->MaxWidth;
-  if (gport->view_height >= PCB->MaxHeight)
-    gport->view_height = PCB->MaxHeight;
+//  if (gport->view_width >= PCB->MaxWidth)
+//    gport->view_width = PCB->MaxWidth;
+//  if (gport->view_height >= PCB->MaxHeight)
+//    gport->view_height = PCB->MaxHeight;
 
   adj = gtk_range_get_adjustment (GTK_RANGE (ghidgui->h_range));
   adj->page_size = gport->view_width;
@@ -174,31 +174,31 @@ ghid_port_ranges_zoom (gdouble zoom)
   /* figure out zoom values in that would just make the width fit and
    * that would just make the height fit
    */
-  xtmp = (gdouble) PCB->MaxWidth / gport->width;
-  ytmp = (gdouble) PCB->MaxHeight / gport->height;
+//  xtmp = (gdouble) PCB->MaxWidth / gport->width;
+//  ytmp = (gdouble) PCB->MaxHeight / gport->height;
 
   /* if we've tried to zoom further out than what would make the
    * entire board fit or we passed 0, then pick a zoom that just makes
    * the board fit.
    */
-  if ((zoom > xtmp && zoom > ytmp) || zoom == 0.0)
-    zoom = (xtmp > ytmp) ? xtmp : ytmp;
+//  if ((zoom > xtmp && zoom > ytmp) || zoom == 0.0)
+//    zoom = (xtmp > ytmp) ? xtmp : ytmp;
 
-  xtmp = (gport->view_x - gport->view_x0) / (gdouble) gport->view_width;
-  ytmp = (gport->view_y - gport->view_y0) / (gdouble) gport->view_height;
+  xtmp = (gport->view_x - gport->view_x0) / (double) FLIP_X (gport->view_width);
+  ytmp = (gport->view_y - gport->view_y0) / (double) FLIP_Y (gport->view_height);
 
   gport->zoom = zoom;
   pixel_slop = zoom;
   ghid_port_ranges_scale(FALSE);
 
   x0 = gport->view_x - xtmp * gport->view_width;
-  if (x0 < 0)
-    x0 = 0;
+//  if (x0 < 0)
+//    x0 = 0;
   gport->view_x0 = x0;
 
   y0 = gport->view_y - ytmp * gport->view_height;
-  if (y0 < 0)
-    y0 = 0;
+//  if (y0 < 0)
+//    y0 = 0;
   gport->view_y0 = y0;
 
   ghidgui->adjustment_changed_holdoff = TRUE;
@@ -242,8 +242,8 @@ ghid_note_event_location (GdkEventButton * ev)
       event_x = ev->x;
       event_y = ev->y;
     }
-  gport->view_x = VIEW_X (event_x);
-  gport->view_y = VIEW_Y (event_y);
+  gport->view_x = PCB_X (event_x);
+  gport->view_y = PCB_Y (event_y);
 
   moved = MoveCrosshairAbsolute (gport->view_x, gport->view_y);
   if (moved)
@@ -818,8 +818,8 @@ ghid_port_window_leave_cb (GtkWidget * widget,
 	  w = ghid_port.width * gport->zoom;
 	  h = ghid_port.height * gport->zoom;
 
-	  x0 = VIEW_X (0);
-	  y0 = VIEW_Y (0);
+	  x0 = PCB_X (0);
+	  y0 = PCB_Y (0);
 	  ghid_get_coords (NULL, &x, &y);
 	  x -= x0;
 	  y -= y0;
diff --git a/src/hid/gtk/gui-render-pixmap.c b/src/hid/gtk/gui-render-pixmap.c
index b24e6c9..623dc5a 100644
--- a/src/hid/gtk/gui-render-pixmap.c
+++ b/src/hid/gtk/gui-render-pixmap.c
@@ -80,10 +80,10 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   gdk_draw_rectangle (pixmap, gport->bg_gc, TRUE, 0, 0, width, height);
 
   /* call the drawing routine */
-  region.X1 = MIN(Px(0), Px(gport->width + 1));
-  region.Y1 = MIN(Py(0), Py(gport->height + 1));
-  region.X2 = MAX(Px(0), Px(gport->width + 1));
-  region.Y2 = MAX(Py(0), Py(gport->height + 1));
+  region.X1 = MIN(PCB_X (0), PCB_X (gport->width + 1));
+  region.Y1 = MIN(PCB_Y (0), PCB_Y (gport->height + 1));
+  region.X2 = MAX(PCB_X (0), PCB_X (gport->width + 1));
+  region.Y2 = MAX(PCB_Y (0), PCB_Y (gport->height + 1));
   hid_expose_callback (&ghid_hid, &region, NULL);
 
   gport->drawable = save_drawable;
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index d2a76ce..43f7c2c 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -65,14 +65,15 @@
 								((v) / 0.000254 + 0.5) : ((v) * 100.0 + 0.5))
 
 extern int ghid_flip_x, ghid_flip_y;
-#define SIDE_X(x)   ((ghid_flip_x ? PCB->MaxWidth - (x) : (x)))
-#define SIDE_Y(y)   ((ghid_flip_y ? PCB->MaxHeight - (y) : (y)))
+#define FLIP_X(x) (ghid_flip_x ? -(x) : (x))
+#define FLIP_Y(y) (ghid_flip_y ? -(y) : (y))
 
-#define	DRAW_X(x)	(gint)((SIDE_X(x) - gport->view_x0) / gport->zoom)
-#define	DRAW_Y(y)	(gint)((SIDE_Y(y) - gport->view_y0) / gport->zoom)
+#define SCREEN_X(x) (int)((double)((x) - gport->view_x0) / FLIP_X (gport->zoom) + 0.5)
+#define SCREEN_Y(y) (int)((double)((y) - gport->view_y0) / FLIP_Y (gport->zoom) + 0.5)
+#define SCREEN_R(r) (int)((double)(r) / gport->zoom + 0.5)
 
-#define	VIEW_X(x)	SIDE_X((gint)((x) * gport->zoom + gport->view_x0))
-#define	VIEW_Y(y)	SIDE_Y((gint)((y) * gport->zoom + gport->view_y0))
+#define PCB_X(x) (int)((double)(x) * FLIP_X (gport->zoom) + gport->view_x0)
+#define PCB_Y(y) (int)((double)(y) * FLIP_Y (gport->zoom) + gport->view_y0)
 
 /*
  * Used to intercept "special" hotkeys that gtk doesn't usually pass
@@ -512,65 +513,8 @@ void ghid_get_coords (const char *msg, int *x, int *y);
 gint PCBChanged (int argc, char **argv, int x, int y);
 
 
-
-
 extern GdkPixmap *XC_hand_source, *XC_hand_mask;
 extern GdkPixmap *XC_lock_source, *XC_lock_mask;
 extern GdkPixmap *XC_clock_source, *XC_clock_mask;
 
-
-/* Coordinate conversions */
-/* Px converts view->pcb, Vx converts pcb->view */
-static inline int
-Vx (int x)
-{
-  int rv;
-  if (ghid_flip_x)
-    rv = (PCB->MaxWidth - x - gport->view_x0) / gport->zoom + 0.5;
-  else
-    rv = (x - gport->view_x0) / gport->zoom + 0.5;
-  return rv;
-}
-
-static inline int
-Vy (int y)
-{
-  int rv;
-  if (ghid_flip_y)
-    rv = (PCB->MaxHeight - y - gport->view_y0) / gport->zoom + 0.5;
-  else
-    rv = (y - gport->view_y0) / gport->zoom + 0.5;
-  return rv;
-}
-
-static inline int
-Vz (int z)
-{
-  return z / gport->zoom + 0.5;
-}
-
-static inline int
-Px (int x)
-{
-  int rv = x * gport->zoom + gport->view_x0;
-  if (ghid_flip_x)
-    rv = PCB->MaxWidth - (x * gport->zoom + gport->view_x0);
-  return  rv;
-}
-
-static inline int
-Py (int y)
-{
-  int rv = y * gport->zoom + gport->view_y0;
-  if (ghid_flip_y)
-    rv = PCB->MaxHeight - (y * gport->zoom + gport->view_y0);
-  return  rv;
-}
-
-static inline int
-Pz (int z)
-{
-  return (z * gport->zoom);
-}
-
 #endif /* __GHID_INCLUDED__  */

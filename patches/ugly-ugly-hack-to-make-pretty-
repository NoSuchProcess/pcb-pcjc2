Bottom: c5711fd220cdf6e782077a178b00635862672b1f
Top:    64532dacc1013a69c062f68a066e6994446d063b
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-02-09 04:53:03 +0000

UGLY UGLY hack to make pretty translucent polygons


---

diff --git a/src/draw.c b/src/draw.c
index c083871..47045c5 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -1727,6 +1727,35 @@ DrawTextLowLevel (TextTypePtr Text, int min_line_width)
  * lowlevel drawing routine for polygons
  */
 static void
+DrawPolygonFillLowLevel (PolygonTypePtr Polygon, void *data)
+{
+  int *x, *y, n, i = 0;
+  PLINE *pl;
+  VNODE *v;
+  if (!Polygon->Clipped)
+    return;
+  if (Gathering)
+    {
+      AddPart (Polygon);
+      return;
+    }
+  pl = Polygon->Clipped->contours;
+  n = pl->Count;
+  x = (int *) malloc (n * sizeof (int));
+  y = (int *) malloc (n * sizeof (int));
+  for (v = &pl->head; i < n; v = v->next)
+    {
+      x[i] = v->point[0];
+      y[i++] = v->point[1];
+    }
+  gui->fill_polygon (Output.fgGC, n, x, y);
+  free (x);
+  free (y);
+}
+/* ---------------------------------------------------------------------------
+ * lowlevel drawing routine for polygons
+ */
+static void
 DrawPolygonLowLevel (PolygonTypePtr Polygon, void *data)
 {
   int *x, *y, n, i = 0;
@@ -2088,6 +2117,8 @@ cp_callback (const BoxType * b, void *cl)
   return 1;
 }
 
+void hidgl_hack_poly_alpha (double alpha);
+
 /* ---------------------------------------------------------------------------
  * draws a polygon on a layer
  */
@@ -2096,6 +2127,7 @@ DrawPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon, int unused)
 {
   int layernum;
 
+  hidgl_hack_poly_alpha (0.7);
   if (TEST_FLAG (SELECTEDFLAG | FOUNDFLAG, Polygon))
     {
       if (TEST_FLAG (SELECTEDFLAG, Polygon))
@@ -2107,6 +2139,7 @@ DrawPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon, int unused)
     gui->set_color (Output.fgGC, Layer->Color);
   layernum = GetLayerNumber (PCB->Data, Layer);
   DrawPolygonLowLevel (Polygon, NULL);
+  hidgl_hack_poly_alpha (1.0);
   if (TEST_FLAG (CLEARPOLYFLAG, Polygon))
     {
       r_search (PCB->Data->pin_tree, &Polygon->BoundingBox, NULL,
@@ -2150,25 +2183,31 @@ thin_callback (PLINE * pl, LayerTypePtr lay, PolygonTypePtr poly)
 static void
 DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
 {
-  if (TEST_FLAG (SELECTEDFLAG | FOUNDFLAG, Polygon))
-    {
-      if (TEST_FLAG (SELECTEDFLAG, Polygon))
-	gui->set_color (Output.fgGC, Layer->SelectedColor);
-      else
-	gui->set_color (Output.fgGC, PCB->ConnectedColor);
+  char *color;
+
+  if (TEST_FLAG (SELECTEDFLAG | FOUNDFLAG, Polygon)) {
+    if (TEST_FLAG (SELECTEDFLAG, Polygon)) {
+      color = Layer->SelectedColor;
+    } else {
+      color = PCB->ConnectedColor;
     }
-  else
-    gui->set_color (Output.fgGC, Layer->Color);
+  } else {
+    color = Layer->Color;
+  }
+
   /* if the gui has the dicer flag set then it won't accept thin draw */
   if ((TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG (THINDRAWPOLYFLAG, PCB))
       && !gui->poly_dicer)
     {
+      hidgl_hack_poly_alpha (1.0);
+      gui->set_color (Output.fgGC, color);
       DrawPolygonLowLevel (Polygon, NULL);
       if (!Gathering)
 	PolygonHoles (clip_box, Layer, Polygon, thin_callback);
+      hidgl_hack_poly_alpha (0.25);
     }
-  else if (Polygon->Clipped)
     {
+      gui->set_color (Output.fgGC, color);
       if (!Polygon->NoHolesValid)
         {
           ComputeNoHoles (Polygon);
@@ -2178,7 +2217,7 @@ DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
           PolygonType poly = *Polygon;
           poly.Clipped = Polygon->NoHoles;
           do {
-            DrawPolygonLowLevel (&poly, NULL);
+            DrawPolygonFillLowLevel (&poly, NULL);
             poly.Clipped = poly.Clipped->f;
           } while (poly.Clipped != Polygon->NoHoles);
         }
@@ -2191,7 +2230,7 @@ DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
 	    {
 	      PolygonType poly;
 	      poly.Clipped = pg;
-	      NoHolesPolygonDicer (&poly, DrawPolygonLowLevel, NULL, clip_box);
+	      NoHolesPolygonDicer (&poly, DrawPolygonFillLowLevel, NULL, clip_box);
 	    }
 	}
     }
@@ -2225,6 +2264,7 @@ DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
 	  free (y);
 	}
     }
+  hidgl_hack_poly_alpha (1.0);
 }
 
 /* ---------------------------------------------------------------------------
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 3332d7e..d601224 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -704,6 +704,18 @@ ghid_set_special_colors (HID_Attribute * ha)
     }
 }
 
+static double global_alpha_mult = 1.0;
+static int alpha_changed = 0;
+
+void
+hidgl_hack_poly_alpha (double alpha_mult)
+{
+  if (alpha_mult != global_alpha_mult) {
+    global_alpha_mult = alpha_mult;
+    alpha_changed = 1;
+  }
+}
+
 
 void
 ghid_set_color (hidGC gc, const char *name)
@@ -716,13 +728,15 @@ ghid_set_color (hidGC gc, const char *name)
   double r, g, b, a;
   a = 1.0;
 
-  if (old_name != NULL)
+  if (!alpha_changed && old_name != NULL)
     {
       if (strcmp (name, old_name) == 0)
         return;
       free (old_name);
     }
 
+  alpha_changed = 0;
+
   old_name = strdup (name);
 
   if (name == NULL)
@@ -797,6 +811,7 @@ ghid_set_color (hidGC gc, const char *name)
     }
   if (1) {
     double maxi, mult;
+    alpha_mult *= global_alpha_mult;
     if (gport->trans_lines)
       a = a * alpha_mult;
     maxi = r;

Bottom: 73aecb4163c2f090a786f828d678ddb52f79b196
Top:    90d721accd7fb7176770f23c62f2e95a507a4ace
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-02-11 16:11:14 +0000

UGLY UGLY hack to make pretty translucent polygons






---

diff --git a/src/draw.c b/src/draw.c
index 960515d..fddcb90 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -1729,6 +1729,44 @@ DrawTextLowLevel (TextTypePtr Text, int min_line_width)
  * lowlevel drawing routine for polygons
  */
 static void
+DrawPolygonFillLowLevel (PolygonTypePtr Polygon, void *data)
+{
+  int *x, *y, n, i = 0;
+  PLINE *pl;
+  VNODE *v;
+  if (!Polygon->Clipped)
+    return;
+  if (Gathering)
+    {
+      AddPart (Polygon);
+      return;
+    }
+
+  if (gui->fill_pcb_polygon &&
+      !TEST_FLAG (THINDRAWFLAG, PCB) &&
+      !TEST_FLAG (THINDRAWPOLYFLAG, PCB) &&
+      !TEST_FLAG (CLEARLINEFLAG, Polygon)) {
+    gui->fill_pcb_polygon (Output.fgGC, Polygon);
+    return;
+  }
+
+  pl = Polygon->Clipped->contours;
+  n = pl->Count;
+  x = (int *) malloc (n * sizeof (int));
+  y = (int *) malloc (n * sizeof (int));
+  for (v = &pl->head; i < n; v = v->next)
+    {
+      x[i] = v->point[0];
+      y[i++] = v->point[1];
+    }
+  gui->fill_polygon (Output.fgGC, n, x, y);
+  free (x);
+  free (y);
+}
+/* ---------------------------------------------------------------------------
+ * lowlevel drawing routine for polygons
+ */
+static void
 DrawPolygonLowLevel (PolygonTypePtr Polygon, void *data)
 {
   int *x, *y, n, i = 0;
@@ -2099,6 +2137,8 @@ cp_callback (const BoxType * b, void *cl)
   return 1;
 }
 
+void hidgl_hack_poly_alpha (double alpha);
+
 /* ---------------------------------------------------------------------------
  * draws a polygon on a layer
  */
@@ -2107,6 +2147,7 @@ DrawPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon, int unused)
 {
   int layernum;
 
+  hidgl_hack_poly_alpha (0.7);
   if (TEST_FLAG (SELECTEDFLAG | FOUNDFLAG, Polygon))
     {
       if (TEST_FLAG (SELECTEDFLAG, Polygon))
@@ -2118,6 +2159,7 @@ DrawPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon, int unused)
     gui->set_color (Output.fgGC, Layer->Color);
   layernum = GetLayerNumber (PCB->Data, Layer);
   DrawPolygonLowLevel (Polygon, NULL);
+  hidgl_hack_poly_alpha (1.0);
   if (TEST_FLAG (CLEARPOLYFLAG, Polygon))
     {
       r_search (PCB->Data->pin_tree, &Polygon->BoundingBox, NULL,
@@ -2161,38 +2203,51 @@ thin_callback (PLINE * pl, LayerTypePtr lay, PolygonTypePtr poly)
 static void
 DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
 {
-  if (TEST_FLAG (SELECTEDFLAG | FOUNDFLAG, Polygon))
-    {
-      if (TEST_FLAG (SELECTEDFLAG, Polygon))
-	gui->set_color (Output.fgGC, Layer->SelectedColor);
-      else
-	gui->set_color (Output.fgGC, PCB->ConnectedColor);
+  char *color;
+
+  if (TEST_FLAG (SELECTEDFLAG | FOUNDFLAG, Polygon)) {
+    if (TEST_FLAG (SELECTEDFLAG, Polygon)) {
+      color = Layer->SelectedColor;
+    } else {
+      color = PCB->ConnectedColor;
     }
-  else
-    gui->set_color (Output.fgGC, Layer->Color);
+  } else {
+    color = Layer->Color;
+  }
+
   /* if the gui has the dicer flag set then it won't accept thin draw */
   if ((TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG (THINDRAWPOLYFLAG, PCB))
       && !gui->poly_dicer)
     {
+      hidgl_hack_poly_alpha (1.0);
+      gui->set_color (Output.fgGC, color);
       DrawPolygonLowLevel (Polygon, NULL);
       if (!Gathering)
 	PolygonHoles (clip_box, Layer, Polygon, thin_callback);
+      hidgl_hack_poly_alpha (0.25);
     }
-  else if (Polygon->Clipped)
     {
-      if (!Polygon->NoHolesValid)
-        {
-          ComputeNoHoles (Polygon);
-        }
-      if (Polygon->NoHoles)
+      gui->set_color (Output.fgGC, color);
+
+      if (gui->fill_pcb_polygon != NULL)
+        gui->fill_pcb_polygon (Output.fgGC, Polygon);
+      else
         {
-          PolygonType poly = *Polygon;
-          poly.Clipped = Polygon->NoHoles;
-          do {
-            DrawPolygonLowLevel (&poly, NULL);
-            poly.Clipped = poly.Clipped->f;
-          } while (poly.Clipped != Polygon->NoHoles);
+          if (!Polygon->NoHolesValid)
+            {
+              ComputeNoHoles (Polygon);
+            }
+          if (Polygon->NoHoles)
+            {
+              PolygonType poly = *Polygon;
+              poly.Clipped = Polygon->NoHoles;
+              do {
+                DrawPolygonFillLowLevel (&poly, NULL);
+                poly.Clipped = poly.Clipped->f;
+              } while (poly.Clipped != Polygon->NoHoles);
+            }
         }
+
       /* draw other parts of the polygon if fullpoly flag is set */
       /* NB: No "NoHoles" cache for these */
       if (TEST_FLAG (FULLPOLYFLAG, Polygon))
@@ -2202,7 +2257,7 @@ DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
 	    {
 	      PolygonType poly;
 	      poly.Clipped = pg;
-	      NoHolesPolygonDicer (&poly, DrawPolygonLowLevel, NULL, clip_box);
+	      NoHolesPolygonDicer (&poly, DrawPolygonFillLowLevel, NULL, clip_box);
 	    }
 	}
     }
@@ -2236,6 +2291,7 @@ DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
 	  free (y);
 	}
     }
+  hidgl_hack_poly_alpha (1.0);
 }
 
 /* ---------------------------------------------------------------------------
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 2590f29..148f5ae 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -704,6 +704,18 @@ ghid_set_special_colors (HID_Attribute * ha)
     }
 }
 
+static double global_alpha_mult = 1.0;
+static int alpha_changed = 0;
+
+void
+hidgl_hack_poly_alpha (double alpha_mult)
+{
+  if (alpha_mult != global_alpha_mult) {
+    global_alpha_mult = alpha_mult;
+    alpha_changed = 1;
+  }
+}
+
 
 void
 ghid_set_color (hidGC gc, const char *name)
@@ -716,13 +728,15 @@ ghid_set_color (hidGC gc, const char *name)
   double r, g, b, a;
   a = 1.0;
 
-  if (old_name != NULL)
+  if (!alpha_changed && old_name != NULL)
     {
       if (strcmp (name, old_name) == 0)
         return;
       free (old_name);
     }
 
+  alpha_changed = 0;
+
   old_name = strdup (name);
 
   if (name == NULL)
@@ -797,6 +811,7 @@ ghid_set_color (hidGC gc, const char *name)
     }
   if (1) {
     double maxi, mult;
+    alpha_mult *= global_alpha_mult;
     if (gport->trans_lines)
       a = a * alpha_mult;
     maxi = r;

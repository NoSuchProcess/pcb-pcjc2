Bottom: 010efd2fee18a7152e1d456d276e885d95a83a44
Top:    22586dd1636c8a416af9874989a3a7c1eed778e8
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-02-17 23:58:16 +0000

UGLY UGLY hack to make pretty translucent polygons



---

diff --git a/src/draw.c b/src/draw.c
index a2fbe7f..e67987a 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -1729,6 +1729,44 @@ DrawTextLowLevel (TextTypePtr Text, int min_line_width)
  * lowlevel drawing routine for polygons
  */
 static void
+DrawPolygonFillLowLevel (PolygonTypePtr Polygon, void *data)
+{
+  int *x, *y, n, i = 0;
+  PLINE *pl;
+  VNODE *v;
+  if (!Polygon->Clipped)
+    return;
+  if (Gathering)
+    {
+      AddPart (Polygon);
+      return;
+    }
+
+  if (gui->fill_pcb_polygon &&
+      !TEST_FLAG (THINDRAWFLAG, PCB) &&
+      !TEST_FLAG (THINDRAWPOLYFLAG, PCB) &&
+      !TEST_FLAG (CLEARLINEFLAG, Polygon)) {
+    gui->fill_pcb_polygon (Output.fgGC, Polygon);
+    return;
+  }
+
+  pl = Polygon->Clipped->contours;
+  n = pl->Count;
+  x = (int *) malloc (n * sizeof (int));
+  y = (int *) malloc (n * sizeof (int));
+  for (v = &pl->head; i < n; v = v->next)
+    {
+      x[i] = v->point[0];
+      y[i++] = v->point[1];
+    }
+  gui->fill_polygon (Output.fgGC, n, x, y);
+  free (x);
+  free (y);
+}
+/* ---------------------------------------------------------------------------
+ * lowlevel drawing routine for polygons
+ */
+static void
 DrawPolygonLowLevel (PolygonTypePtr Polygon, void *data)
 {
   int *x, *y, n, i = 0;
@@ -2154,6 +2192,7 @@ thin_callback (PLINE * pl, LayerTypePtr lay, PolygonTypePtr poly)
   return 0;
 }
 
+void hidgl_hack_poly_alpha (double alpha);
 
 /* ---------------------------------------------------------------------------
  * draws a polygon
@@ -2161,25 +2200,33 @@ thin_callback (PLINE * pl, LayerTypePtr lay, PolygonTypePtr poly)
 static void
 DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
 {
-  if (TEST_FLAG (SELECTEDFLAG | FOUNDFLAG, Polygon))
-    {
-      if (TEST_FLAG (SELECTEDFLAG, Polygon))
-	gui->set_color (Output.fgGC, Layer->SelectedColor);
-      else
-	gui->set_color (Output.fgGC, PCB->ConnectedColor);
+  char *color;
+
+  if (TEST_FLAG (SELECTEDFLAG | FOUNDFLAG, Polygon)) {
+    if (TEST_FLAG (SELECTEDFLAG, Polygon)) {
+      color = Layer->SelectedColor;
+    } else {
+      color = PCB->ConnectedColor;
     }
-  else
-    gui->set_color (Output.fgGC, Layer->Color);
+  } else {
+    color = Layer->Color;
+  }
+
   /* if the gui has the dicer flag set then it won't accept thin draw */
   if ((TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG (THINDRAWPOLYFLAG, PCB))
       && !gui->poly_dicer)
     {
+      hidgl_hack_poly_alpha (1.0);
+      gui->set_color (Output.fgGC, color);
       DrawPolygonLowLevel (Polygon, NULL);
       if (!Gathering)
 	PolygonHoles (clip_box, Layer, Polygon, thin_callback);
+      hidgl_hack_poly_alpha (0.25);
     }
-  else if (Polygon->Clipped)
+  if (Polygon->Clipped)
     {
+      gui->set_color (Output.fgGC, color);
+
       if (gui->fill_pcb_polygon != NULL)
         {
           gui->fill_pcb_polygon (Output.fgGC, Polygon);
@@ -2195,7 +2242,7 @@ DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
               PolygonType poly = *Polygon;
               poly.Clipped = Polygon->NoHoles;
               do {
-                DrawPolygonLowLevel (&poly, NULL);
+                DrawPolygonFillLowLevel (&poly, NULL);
                 poly.Clipped = poly.Clipped->f;
               } while (poly.Clipped != Polygon->NoHoles);
             }
@@ -2209,7 +2256,7 @@ DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
 	    {
 	      PolygonType poly;
 	      poly.Clipped = pg;
-	      NoHolesPolygonDicer (&poly, DrawPolygonLowLevel, NULL, clip_box);
+	      NoHolesPolygonDicer (&poly, DrawPolygonFillLowLevel, NULL, clip_box);
 	    }
 	}
     }
@@ -2243,6 +2290,7 @@ DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
 	  free (y);
 	}
     }
+  hidgl_hack_poly_alpha (1.0);
 }
 
 /* ---------------------------------------------------------------------------
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 274440b..96585ad 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -704,6 +704,18 @@ ghid_set_special_colors (HID_Attribute * ha)
     }
 }
 
+static double global_alpha_mult = 1.0;
+static int alpha_changed = 0;
+
+void
+hidgl_hack_poly_alpha (double alpha_mult)
+{
+  if (alpha_mult != global_alpha_mult) {
+    global_alpha_mult = alpha_mult;
+    alpha_changed = 1;
+  }
+}
+
 
 void
 ghid_set_color (hidGC gc, const char *name)
@@ -716,13 +728,15 @@ ghid_set_color (hidGC gc, const char *name)
   double r, g, b, a;
   a = 1.0;
 
-  if (old_name != NULL)
+  if (!alpha_changed && old_name != NULL)
     {
       if (strcmp (name, old_name) == 0)
         return;
       free (old_name);
     }
 
+  alpha_changed = 0;
+
   old_name = strdup (name);
 
   if (name == NULL)
@@ -797,6 +811,7 @@ ghid_set_color (hidGC gc, const char *name)
     }
   if (1) {
     double maxi, mult;
+    alpha_mult *= global_alpha_mult;
     if (gport->trans_lines)
       a = a * alpha_mult;
     maxi = r;

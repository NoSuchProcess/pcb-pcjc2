Bottom: c88643d73161fd843c0a773f44ce588ba0864d59
Top:    dd0769307a5275887ba11fbf498e243b8cbb0e3a
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-08-08 00:19:13 +0100

Refresh of hid-gtk-separate-out-board-fli

---

diff --git a/src/gpcb-menu.res.in b/src/gpcb-menu.res.in
index dc594c4..1bf95c0 100644
--- a/src/gpcb-menu.res.in
+++ b/src/gpcb-menu.res.in
@@ -168,8 +168,8 @@ MainMenu =
     {"Zoom to 10mil/px" Zoom(=1000)}
     {"Zoom In 20% and center" Zoom(-1.2) Center() m=Z }
     {"Zoom Out 20% and center" Zoom(+1.2) Center() m=O }
-    {"Flip up/down" checked=flip_y SwapSides(V) a={"Tab" "<Key>Tab"}}
-    {"Flip left/right" checked=flip_x SwapSides(H) a={"Shift-Tab" "Shift<Key>Tab"}}
+    {"Flip up/down" SwapSides(V) a={"Tab" "<Key>Tab"}}
+    {"Flip left/right" SwapSides(H) a={"Shift-Tab" "Shift<Key>Tab"}}
     {"Spin 180 degrees" SwapSides(R) a={"Ctrl-Tab" "Ctrl<Key>Tab"}}
     {"Swap Sides" SwapSides() a={"Ctrl-Shift-Tab" "Ctrl Shift<Key>Tab"}}
     {"Center cursor" Center() a={"C" "<Key>c"}}
diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index e9b5b3e..fb7d0e1 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -26,9 +26,17 @@ extern HID ghid_hid;
 */
 #define USE_GC(gc) if (!use_gc(gc)) return
 
+#define SIDE_X(x)   ((priv->view.flip_x ? PCB->MaxWidth  - (x) : (x)))
+#define SIDE_Y(y)   ((priv->view.flip_y ? PCB->MaxHeight - (y) : (y)))
+
 static int cur_mask = -1;
 static int mask_seq = 0;
 
+typedef struct view_data {
+  bool flip_x;
+  bool flip_y;
+} view_data;
+
 typedef struct render_priv {
   GdkGC *bg_gc;
   GdkGC *offlimits_gc;
@@ -39,6 +47,7 @@ typedef struct render_priv {
   GdkRectangle clip_rect;
   int attached_invalidate_depth;
   int mark_invalidate_depth;
+  view_data view;
 
   /* Feature for leading the user to a particular location */
   guint lead_user_timeout;
@@ -64,6 +73,52 @@ typedef struct hid_gc_struct
 }
 hid_gc_struct;
 
+/* Px converts view->pcb, Vx converts pcb->view */
+static inline int
+Vx (int x)
+{
+  render_priv *priv = gport->render_priv;
+  if (priv->view.flip_x)
+    return (PCB->MaxWidth - x - gport->view_x0) / gport->zoom + 0.5;
+  else
+    return (x - gport->view_x0) / gport->zoom + 0.5;
+}
+
+static inline int
+Vy (int y)
+{
+  render_priv *priv = gport->render_priv;
+  if (priv->view.flip_y)
+    return (PCB->MaxHeight - y - gport->view_y0) / gport->zoom + 0.5;
+  else
+    return (y - gport->view_y0) / gport->zoom + 0.5;
+}
+
+static inline int
+Vz (int z)
+{
+  return z / gport->zoom + 0.5;
+}
+
+static inline int
+Px (int x)
+{
+  render_priv *priv = gport->render_priv;
+  int rv = x * gport->zoom + gport->view_x0;
+  if (priv->view.flip_x)
+    rv = PCB->MaxWidth - (x * gport->zoom + gport->view_x0);
+  return  rv;
+}
+
+static inline int
+Py (int y)
+{
+  render_priv *priv = gport->render_priv;
+  int rv = y * gport->zoom + gport->view_y0;
+  if (priv->view.flip_y)
+    rv = PCB->MaxHeight - (y * gport->zoom + gport->view_y0);
+  return  rv;
+}
 
 static void draw_lead_user (render_priv *priv);
 
@@ -557,12 +612,12 @@ ghid_draw_arc (hidGC gc, int cx, int cy,
   vrx = Vz (xradius);
   vry = Vz (yradius);
 
-  if (ghid_flip_x)
+  if (priv->view.flip_x)
     {
       start_angle = 180 - start_angle;
       delta_angle = -delta_angle;
     }
-  if (ghid_flip_y)
+  if (priv->view.flip_y)
     {
       start_angle = -start_angle;
       delta_angle = -delta_angle;
@@ -1281,9 +1336,9 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   gport->height = height;
   gport->view_width = width * gport->zoom;
   gport->view_height = height * gport->zoom;
-  gport->view_x0 = ghid_flip_x ? PCB->MaxWidth - cx : cx;
+  gport->view_x0 = priv->view.flip_x ? PCB->MaxWidth - cx : cx;
   gport->view_x0 -= gport->view_height / 2;
-  gport->view_y0 = ghid_flip_y ? PCB->MaxHeight - cy : cy;
+  gport->view_y0 = priv->view.flip_y ? PCB->MaxHeight - cy : cy;
   gport->view_y0 -= gport->view_width  / 2;
 
   /* clear background */
@@ -1334,6 +1389,8 @@ ghid_finish_debug_draw (void)
 bool
 ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y)
 {
+  render_priv *priv = gport->render_priv;
+
   *pcb_x = EVENT_TO_PCB_X (event_x);
   *pcb_y = EVENT_TO_PCB_Y (event_y);
 
@@ -1343,12 +1400,120 @@ ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y)
 bool
 ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y)
 {
+  render_priv *priv = gport->render_priv;
+
   *event_x = DRAW_X (pcb_x);
   *event_y = DRAW_Y (pcb_y);
 
   return true;
 }
 
+void
+ghid_pan_view_abs (Coord pcb_x, Coord pcb_y, int widget_x, int widget_y)
+{
+  render_priv *priv = gport->render_priv;
+
+  gport->view_x0 = MAX (0, SIDE_X (pcb_x) - widget_x * gport->zoom);
+  gport->view_y0 = MAX (0, SIDE_Y (pcb_y) - widget_y * gport->zoom);
+
+  /* don't pan so far to the right that we see way past the right edge of the
+   * board, or so far down that we see way past the bottom edge of the board.
+   */
+  gport->view_x0 = MIN (gport->view_x0, PCB->MaxWidth  - gport->view_width);
+  gport->view_y0 = MIN (gport->view_y0, PCB->MaxHeight - gport->view_height);
+
+  /* don't view above or to the left of the board... ever */
+  gport->view_x0 = MAX (0, gport->view_x0);
+  gport->view_y0 = MAX (0, gport->view_y0);
+
+  /* if we can see the entire board and some, then zoom to fit */
+  if (gport->view_width  > PCB->MaxWidth  &&
+      gport->view_height > PCB->MaxHeight)
+    {
+      ghid_zoom_view_fit ();
+      return;
+    }
+
+  ghidgui->adjustment_changed_holdoff = TRUE;
+  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view_x0);
+  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view_y0);
+  ghidgui->adjustment_changed_holdoff = FALSE;
+
+  ghid_port_ranges_changed();
+}
+
+
+/* gport->zoom:
+ * zoom value is PCB units per screen pixel.  Larger numbers mean zooming
+ * out - the largest value means you are looking at the whole board.
+ *
+ * gport->view_width and gport->view_height are in PCB coordinates
+ */
+
+void
+ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
+{
+  render_priv *priv = gport->render_priv;
+  double min_zoom, max_zoom;
+  double xtmp, ytmp;
+
+  /* Limit the "minimum" zoom constant (maximum zoom), at 1 pixel per PCB
+   * unit, and set the "maximum" zoom constant (minimum zoom), such that
+   * the entire board just fits inside the viewport
+   */
+  min_zoom = 1;
+  max_zoom = MAX (PCB->MaxWidth  / gport->width,
+                  PCB->MaxHeight / gport->height);
+  new_zoom = MIN (MAX (min_zoom, new_zoom), max_zoom);
+
+  if (gport->zoom == new_zoom)
+    return;
+
+  xtmp = (SIDE_X (center_x) - gport->view_x0) / (double)gport->view_width;
+  ytmp = (SIDE_Y (center_y) - gport->view_y0) / (double)gport->view_height;
+
+  gport->zoom = new_zoom;
+  pixel_slop = new_zoom;
+  ghid_port_ranges_scale (FALSE);
+
+  gport->view_x0 = MAX (0, SIDE_X (center_x) - xtmp * gport->view_width);
+  gport->view_y0 = MAX (0, SIDE_Y (center_y) - ytmp * gport->view_height);
+
+  ghidgui->adjustment_changed_holdoff = TRUE;
+  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view_x0);
+  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view_y0);
+  ghidgui->adjustment_changed_holdoff = FALSE;
+
+  ghid_port_ranges_changed ();
+  ghid_set_status_line_label ();
+}
+
+void
+ghid_zoom_view_rel (Coord center_x, Coord center_y, double factor)
+{
+  ghid_zoom_view_abs (center_x, center_y, gport->zoom * factor);
+}
+
+void
+ghid_zoom_view_fit (void)
+{
+  ghid_zoom_view_abs (0, 0, MAX (PCB->MaxWidth  / gport->width,
+                                 PCB->MaxHeight / gport->height));
+}
+
+void
+ghid_flip_view (Coord center_x, Coord center_y, bool flip_x, bool flip_y)
+{
+  render_priv *priv = gport->render_priv;
+
+  priv->view.flip_x = flip_x ? ! priv->view.flip_x : priv->view.flip_x;
+  priv->view.flip_y = flip_y ? ! priv->view.flip_y : priv->view.flip_y;
+
+  /* XXX: PAN THE BOARD SO THE CENTER LOCATION REMAINS IN THE SAME PLACE */
+
+  ghid_invalidate_all ();
+}
+
 
 #define LEAD_USER_WIDTH           0.2          /* millimeters */
 #define LEAD_USER_PERIOD          (1000 / 5)   /* 5fps (in ms) */
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 5c554fa..b341d3f 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -38,8 +38,16 @@ static hidGC current_gc = NULL;
 */
 #define USE_GC(gc) if (!use_gc(gc)) return
 
+#define SIDE_X(x)   ((priv->view.flip_x ? PCB->MaxWidth  - (x) : (x)))
+#define SIDE_Y(y)   ((priv->view.flip_y ? PCB->MaxHeight - (y) : (y)))
+
 static int cur_mask = -1;
 
+typedef struct view_data {
+  bool flip_x;
+  bool flip_y;
+} view_data;
+
 typedef struct render_priv {
   GdkGLConfig *glconfig;
   bool trans_lines;
@@ -48,6 +56,8 @@ typedef struct render_priv {
   char *current_colorname;
   double current_alpha_mult;
 
+  view_data view;
+
   /* Feature for leading the user to a particular location */
   guint lead_user_timeout;
   GTimer *lead_user_timer;
@@ -71,9 +81,34 @@ typedef struct hid_gc_struct
 }
 hid_gc_struct;
 
-
 static void draw_lead_user (render_priv *priv);
 
+/* Px converts view->pcb, Vx converts pcb->view */
+static inline int
+Vz (int z)
+{
+  return z / gport->zoom + 0.5;
+}
+
+static inline int
+Px (int x)
+{
+  render_priv *priv = gport->render_priv;
+  int rv = x * gport->zoom + gport->view_x0;
+  if (priv->view.flip_x)
+    rv = PCB->MaxWidth - (x * gport->zoom + gport->view_x0);
+  return  rv;
+}
+
+static inline int
+Py (int y)
+{
+  render_priv *priv = gport->render_priv;
+  int rv = y * gport->zoom + gport->view_y0;
+  if (priv->view.flip_y)
+    rv = PCB->MaxHeight - (y * gport->zoom + gport->view_y0);
+  return  rv;
+}
 
 static void
 start_subcomposite (void)
@@ -743,6 +778,7 @@ draw_crosshair (gint x, gint y, gint z)
 void
 ghid_show_crosshair (gboolean paint_new_location)
 {
+  render_priv *priv = gport->render_priv;
   gint x, y, z;
   gboolean draw_markers;
   int vcw = VCW * gport->zoom;
@@ -933,13 +969,13 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glLoadIdentity ();
   glTranslatef (0.0f, 0.0f, -Z_NEAR);
 
-  glScalef ((ghid_flip_x ? -1. : 1.) / port->zoom,
-            (ghid_flip_y ? -1. : 1.) / port->zoom,
-            ((ghid_flip_x == ghid_flip_y) ? 1. : -1.) / port->zoom);
-  glTranslatef (ghid_flip_x ? port->view_x0 - PCB->MaxWidth  :
-                             -port->view_x0,
-                ghid_flip_y ? port->view_y0 - PCB->MaxHeight :
-                             -port->view_y0, 0);
+  glScalef ((priv->view.flip_x ? -1. : 1.) / port->zoom,
+            (priv->view.flip_y ? -1. : 1.) / port->zoom,
+            ((priv->view.flip_x == priv->view.flip_y) ? 1. : -1.) / port->zoom);
+  glTranslatef (priv->view.flip_x ?  port->view_x0 - PCB->MaxWidth  :
+                               -port->view_x0,
+                priv->view.flip_y ?  port->view_y0 - PCB->MaxHeight :
+                               -port->view_y0, 0);
 
   glEnable (GL_STENCIL_TEST);
   glClearColor (port->offlimits_color.red / 65535.,
@@ -1020,6 +1056,7 @@ gboolean
 ghid_pinout_preview_expose (GtkWidget *widget,
                             GdkEventExpose *ev)
 {
+  render_priv *priv = gport->render_priv;
   GdkGLContext* pGlContext = gtk_widget_get_gl_context (widget);
   GdkGLDrawable* pGlDrawable = gtk_widget_get_gl_drawable (widget);
   GhidPinoutPreview *pinout = GHID_PINOUT_PREVIEW (widget);
@@ -1092,12 +1129,12 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
   glPushMatrix ();
-  glScalef ((ghid_flip_x ? -1. : 1.) / gport->zoom,
-            (ghid_flip_y ? -1. : 1.) / gport->zoom, 1);
-  glTranslatef (ghid_flip_x ? gport->view_x0 - PCB->MaxWidth  :
-                             -gport->view_x0,
-                ghid_flip_y ? gport->view_y0 - PCB->MaxHeight :
-                             -gport->view_y0, 0);
+  glScalef ((priv->view.flip_x ? -1. : 1.) / gport->zoom,
+            (priv->view.flip_y ? -1. : 1.) / gport->zoom, 1);
+  glTranslatef (priv->view.flip_x ?  gport->view_x0 - PCB->MaxWidth  :
+                               -gport->view_x0,
+                priv->view.flip_y ?  gport->view_y0 - PCB->MaxHeight :
+                               -gport->view_y0, 0);
   hid_expose_callback (&ghid_hid, NULL, &pinout->element);
   hidgl_flush_triangles (&buffer);
   glPopMatrix ();
@@ -1126,6 +1163,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
 GdkPixmap *
 ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int depth)
 {
+  render_priv *priv = gport->render_priv;
   GdkGLConfig *glconfig;
   GdkPixmap *pixmap;
   GdkGLPixmap *glpixmap;
@@ -1164,9 +1202,9 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   gport->height = height;
   gport->view_width = width * gport->zoom;
   gport->view_height = height * gport->zoom;
-  gport->view_x0 = ghid_flip_x ? PCB->MaxWidth - cx : cx;
+  gport->view_x0 = priv->view.flip_x ? PCB->MaxWidth - cx : cx;
   gport->view_x0 -= gport->view_height / 2;
-  gport->view_y0 = ghid_flip_y ? PCB->MaxHeight - cy : cy;
+  gport->view_y0 = priv->view.flip_y ? PCB->MaxHeight - cy : cy;
   gport->view_y0 -= gport->view_width  / 2;
 
   /* make GL-context "current" */
@@ -1203,12 +1241,12 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
   glPushMatrix ();
-  glScalef ((ghid_flip_x ? -1. : 1.) / gport->zoom,
-            (ghid_flip_y ? -1. : 1.) / gport->zoom, 1);
-  glTranslatef (ghid_flip_x ? gport->view_x0 - PCB->MaxWidth  :
-                             -gport->view_x0,
-                ghid_flip_y ? gport->view_y0 - PCB->MaxHeight :
-                             -gport->view_y0, 0);
+  glScalef ((priv->view.flip_x ? -1. : 1.) / gport->zoom,
+            (priv->view.flip_y ? -1. : 1.) / gport->zoom, 1);
+  glTranslatef (priv->view.flip_x ?  gport->view_x0 - PCB->MaxWidth  :
+                               -gport->view_x0,
+                priv->view.flip_y ?  gport->view_y0 - PCB->MaxHeight :
+                               -gport->view_y0, 0);
   region.X1 = MIN(Px(0), Px(gport->width + 1));
   region.Y1 = MIN(Py(0), Py(gport->height + 1));
   region.X2 = MAX(Px(0), Px(gport->width + 1));
@@ -1243,6 +1281,7 @@ HID *
 ghid_request_debug_draw (void)
 {
   GHidPort *port = gport;
+  render_priv *priv = port->render_priv;
   GtkWidget *widget = port->drawing_area;
 
   ghid_start_drawing (port);
@@ -1263,13 +1302,13 @@ ghid_request_debug_draw (void)
   glDisable (GL_STENCIL_TEST);
 
   glPushMatrix ();
-  glScalef ((ghid_flip_x ? -1. : 1.) / port->zoom,
-            (ghid_flip_y ? -1. : 1.) / port->zoom,
-            (ghid_flip_x == ghid_flip_y) ? 1. : -1.);
-  glTranslatef (ghid_flip_x ? port->view_x0 - PCB->MaxWidth  :
-                             -port->view_x0,
-                ghid_flip_y ? port->view_y0 - PCB->MaxHeight :
-                             -port->view_y0, 0);
+  glScalef ((priv->view.flip_x ? -1. : 1.) / port->zoom,
+            (priv->view.flip_y ? -1. : 1.) / port->zoom,
+            (priv->view.flip_x == priv->view.flip_y) ? 1. : -1.);
+  glTranslatef (priv->view.flip_x ?  port->view_x0 - PCB->MaxWidth  :
+                               -port->view_x0,
+                priv->view.flip_y ?  port->view_y0 - PCB->MaxHeight :
+                               -port->view_y0, 0);
 
   return &ghid_hid;
 }
@@ -1300,6 +1339,8 @@ ghid_finish_debug_draw (void)
 bool
 ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y)
 {
+  render_priv *priv = gport->render_priv;
+
   *pcb_x = EVENT_TO_PCB_X (event_x);
   *pcb_y = EVENT_TO_PCB_Y (event_y);
 
@@ -1309,12 +1350,120 @@ ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y)
 bool
 ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y)
 {
+  render_priv *priv = gport->render_priv;
+
   *event_x = DRAW_X (pcb_x);
   *event_y = DRAW_Y (pcb_y);
 
   return true;
 }
 
+void
+ghid_pan_view_abs (Coord pcb_x, Coord pcb_y, int widget_x, int widget_y)
+{
+  render_priv *priv = gport->render_priv;
+
+  gport->view_x0 = MAX (0, SIDE_X (pcb_x) - widget_x * gport->zoom);
+  gport->view_y0 = MAX (0, SIDE_Y (pcb_y) - widget_y * gport->zoom);
+
+  /* don't pan so far to the right that we see way past the right edge of the
+   * board, or so far down that we see way past the bottom edge of the board.
+   */
+  gport->view_x0 = MIN (gport->view_x0, PCB->MaxWidth  - gport->view_width);
+  gport->view_y0 = MIN (gport->view_y0, PCB->MaxHeight - gport->view_height);
+
+  /* don't view above or to the left of the board... ever */
+  gport->view_x0 = MAX (0, gport->view_x0);
+  gport->view_y0 = MAX (0, gport->view_y0);
+
+  /* if we can see the entire board and some, then zoom to fit */
+  if (gport->view_width  > PCB->MaxWidth  &&
+      gport->view_height > PCB->MaxHeight)
+    {
+      ghid_zoom_view_fit ();
+      return;
+    }
+
+  ghidgui->adjustment_changed_holdoff = TRUE;
+  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view_x0);
+  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view_y0);
+  ghidgui->adjustment_changed_holdoff = FALSE;
+
+  ghid_port_ranges_changed();
+}
+
+
+/* gport->zoom:
+ * zoom value is PCB units per screen pixel.  Larger numbers mean zooming
+ * out - the largest value means you are looking at the whole board.
+ *
+ * gport->view_width and gport->view_height are in PCB coordinates
+ */
+
+void
+ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
+{
+  render_priv *priv = gport->render_priv;
+  double min_zoom, max_zoom;
+  double xtmp, ytmp;
+
+  /* Limit the "minimum" zoom constant (maximum zoom), at 1 pixel per PCB
+   * unit, and set the "maximum" zoom constant (minimum zoom), such that
+   * the entire board just fits inside the viewport
+   */
+  min_zoom = 1;
+  max_zoom = MAX (PCB->MaxWidth  / gport->width,
+                  PCB->MaxHeight / gport->height);
+  new_zoom = MIN (MAX (min_zoom, new_zoom), max_zoom);
+
+  if (gport->zoom == new_zoom)
+    return;
+
+  xtmp = (SIDE_X (center_x) - gport->view_x0) / (double)gport->view_width;
+  ytmp = (SIDE_Y (center_y) - gport->view_y0) / (double)gport->view_height;
+
+  gport->zoom = new_zoom;
+  pixel_slop = new_zoom;
+  ghid_port_ranges_scale (FALSE);
+
+  gport->view_x0 = MAX (0, SIDE_X (center_x) - xtmp * gport->view_width);
+  gport->view_y0 = MAX (0, SIDE_Y (center_y) - ytmp * gport->view_height);
+
+  ghidgui->adjustment_changed_holdoff = TRUE;
+  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view_x0);
+  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view_y0);
+  ghidgui->adjustment_changed_holdoff = FALSE;
+
+  ghid_port_ranges_changed ();
+  ghid_set_status_line_label ();
+}
+
+void
+ghid_zoom_view_rel (Coord center_x, Coord center_y, double factor)
+{
+  ghid_zoom_view_abs (center_x, center_y, gport->zoom * factor);
+}
+
+void
+ghid_zoom_view_fit (void)
+{
+  ghid_zoom_view_abs (0, 0, MAX (PCB->MaxWidth  / gport->width,
+                                 PCB->MaxHeight / gport->height));
+}
+
+void
+ghid_flip_view (Coord center_x, Coord center_y, bool flip_x, bool flip_y)
+{
+  render_priv *priv = gport->render_priv;
+
+  priv->view.flip_x = flip_x ? ! priv->view.flip_x : priv->view.flip_x;
+  priv->view.flip_y = flip_y ? ! priv->view.flip_y : priv->view.flip_y;
+
+  /* XXX: PAN THE BOARD SO THE CENTER LOCATION REMAINS IN THE SAME PLACE */
+
+  ghid_invalidate_all ();
+}
+
 
 #define LEAD_USER_WIDTH           0.2          /* millimeters */
 #define LEAD_USER_PERIOD          (1000 / 20)  /* 20fps (in ms) */
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 9e312e6..c106690 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -29,54 +29,6 @@
 RCSID ("$Id$");
 
 
-static void zoom_to (double factor, int x, int y);
-static void zoom_by (double factor, int x, int y);
-static void zoom_fit (void);
-
-int ghid_flip_x = 0, ghid_flip_y = 0;
-
-
-void
-ghid_pan_fixup ()
-{
-
-  /*
-   * don't pan so far to the right that we see way past the right 
-   * edge of the board.
-   */
-  if (gport->view_x0 > PCB->MaxWidth - gport->view_width)
-    gport->view_x0 = PCB->MaxWidth - gport->view_width;
-
-  /*
-   * don't pan so far down that we see way past the bottom edge of
-   * the board.
-   */
-  if (gport->view_y0 > PCB->MaxHeight - gport->view_height)
-    gport->view_y0 = PCB->MaxHeight - gport->view_height;
-
-  /* don't view above or to the left of the board... ever */
-  if (gport->view_x0 < 0)
-    gport->view_x0 = 0;
-
-   if (gport->view_y0 < 0)
-    gport->view_y0 = 0;
-
-  /* if we can see the entire board and some, then zoom to fit */
-  if (gport->view_width > PCB->MaxWidth &&
-      gport->view_height > PCB->MaxHeight)
-    {
-      zoom_fit ();
-      return;
-    }
-
-  ghidgui->adjustment_changed_holdoff = TRUE;
-  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view_x0);
-  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view_y0);
-  ghidgui->adjustment_changed_holdoff = FALSE;
-
-  ghid_port_ranges_changed();
-}
-
 /* ------------------------------------------------------------ */
 
 static const char zoom_syntax[] =
@@ -136,7 +88,7 @@ Zoom (int argc, char **argv, int x, int y)
 
   if (argc < 1)
     {
-      zoom_fit ();
+      ghid_zoom_view_fit ();
       return 0;
     }
 
@@ -149,81 +101,20 @@ Zoom (int argc, char **argv, int x, int y)
   switch (argv[0][0])
     {
     case '-':
-      zoom_by (1 / v, x, y);
+      ghid_zoom_view_rel (x, y, 1 / v);
       break;
     default:
     case '+':
-      zoom_by (v, x, y);
+      ghid_zoom_view_rel (x, y, v);
       break;
     case '=':
-      /* this needs to set the scale factor absolutely*/
-      zoom_to (v, x, y);
+      ghid_zoom_view_abs (x, y, v);
       break;
     }
 
   return 0;
 }
 
-
-static void
-zoom_to (double new_zoom, int x, int y)
-{
-  double min_zoom, max_zoom;
-  double xtmp, ytmp;
-
-  /* gport->zoom:
-   * zoom value is PCB units per screen pixel.  Larger numbers mean zooming
-   * out - the largest value means you are looking at the whole board.
-   *
-   * gport->view_width and gport->view_height are in PCB coordinates
-   */
-
-  /* Set the "minimum" zoom constant (maximum zoom),
-   * at 1 pixel per PCB unit */
-  min_zoom = 1;
-
-  /* Set the "maximum" zoom constant (minimum zoom),
-   * to make the entire board just fit inside the viewport */
-  max_zoom = MAX (PCB->MaxWidth  / gport->width,
-                  PCB->MaxHeight / gport->height);
-
-  new_zoom = MIN (MAX (min_zoom, new_zoom), max_zoom);
-
-  if (gport->zoom == new_zoom)
-    return;
-
-  xtmp = (SIDE_X (x) - gport->view_x0) / (double)gport->view_width;
-  ytmp = (SIDE_Y (y) - gport->view_y0) / (double)gport->view_height;
-
-  gport->zoom = new_zoom;
-  pixel_slop = new_zoom;
-  ghid_port_ranges_scale (FALSE);
-
-  gport->view_x0 = MAX (0, SIDE_X (x) - xtmp * gport->view_width);
-  gport->view_y0 = MAX (0, SIDE_Y (y) - ytmp * gport->view_height);
-
-  ghidgui->adjustment_changed_holdoff = TRUE;
-  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view_x0);
-  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view_y0);
-  ghidgui->adjustment_changed_holdoff = FALSE;
-
-  ghid_port_ranges_changed ();
-  ghid_set_status_line_label ();
-}
-
-static void
-zoom_by (double factor, int x, int y)
-{
-  zoom_to (gport->zoom * factor, x, y);
-}
-
-static void
-zoom_fit (void)
-{
-  zoom_to (MAX (PCB->MaxWidth  / gport->width,
-                PCB->MaxHeight / gport->height), 0, 0);
-}
-
 /* ------------------------------------------------------------ */
 
 void
@@ -1153,7 +1044,7 @@ PCBChanged (int argc, char **argv, int x, int y)
   RouteStylesChanged (0, NULL, 0, 0);
   ghid_port_ranges_scale (TRUE);
   ghid_port_ranges_pan (0, 0, FALSE);
-  zoom_fit ();
+  ghid_zoom_view_fit ();
   ghid_port_ranges_changed ();
   ghid_sync_with_new_layout ();
   return 0;
@@ -1366,84 +1257,48 @@ side'' of the board.
 static int
 SwapSides (int argc, char **argv, int x, int y)
 {
-  gint flipd;
-  int do_flip_x = 0;
-  int do_flip_y = 0;
-  int comp_group = GetLayerGroupNumberByNumber (component_silk_layer);
-  int solder_group = GetLayerGroupNumberByNumber (solder_silk_layer);
   int active_group = GetLayerGroupNumberByNumber (LayerStack[0]);
-  int comp_showing =
-    PCB->Data->Layer[PCB->LayerGroups.Entries[comp_group][0]].On;
-  int solder_showing =
-    PCB->Data->Layer[PCB->LayerGroups.Entries[solder_group][0]].On;
+  int comp_group =   GetLayerGroupNumberByNumber (component_silk_layer);
+  int solder_group = GetLayerGroupNumberByNumber (solder_silk_layer);
+  int comp_showing =   LAYER_PTR (PCB->LayerGroups.Entries[comp_group][0])->On;
+  int solder_showing = LAYER_PTR (PCB->LayerGroups.Entries[solder_group][0])->On;
 
 
   if (argc > 0)
     {
       switch (argv[0][0]) {
-      case 'h':
-      case 'H':
-	ghid_flip_x = ! ghid_flip_x;
-	do_flip_x = 1;
-	break;
-      case 'v':
-      case 'V':
-	ghid_flip_y = ! ghid_flip_y;
-	do_flip_y = 1;
-	break;
-      case 'r':
-      case 'R':
-	ghid_flip_x = ! ghid_flip_x;
-	ghid_flip_y = ! ghid_flip_y;
-	do_flip_x = 1;
-	do_flip_y = 1;
-	break;
-      default:
-	return 1;
+        case 'h':
+        case 'H':
+          ghid_flip_view (x, y, true, false);
+          break;
+        case 'v':
+        case 'V':
+          ghid_flip_view (x, y, false, true);
+          break;
+        case 'r':
+        case 'R':
+          ghid_flip_view (x, y, true, true);
+          Settings.ShowSolderSide = !Settings.ShowSolderSide; /* Swapped back below */
+          break;
+        default:
+          return 1;
       }
-      /* SwapSides will swap this */
-      Settings.ShowSolderSide = (ghid_flip_x == ghid_flip_y);
     }
 
   Settings.ShowSolderSide = !Settings.ShowSolderSide;
-  if (Settings.ShowSolderSide)
-    {
-      if (active_group == comp_group && comp_showing && !solder_showing)
-	{
-	  ChangeGroupVisibility (PCB->LayerGroups.Entries[comp_group][0], 0,
-				 0);
-	  ChangeGroupVisibility (PCB->LayerGroups.Entries[solder_group][0], 1,
-				 1);
-	}
-    }
-  else
-    {
-      if (active_group == solder_group && solder_showing && !comp_showing)
-	{
-	  ChangeGroupVisibility (PCB->LayerGroups.Entries[solder_group][0], 0,
-				 0);
-	  ChangeGroupVisibility (PCB->LayerGroups.Entries[comp_group][0], 1,
-				 1);
-	}
-    }
 
-  /* Update coordinates so that the current location stays where it was on the
-     other side; we need to do this since the actual flip center is the
-     center of the board while the user expect the center would be the current
-     location */
-  if (do_flip_x)
+  if ((active_group == comp_group   && comp_showing   && !solder_showing) ||
+      (active_group == solder_group && solder_showing && !comp_showing))
     {
-	flipd = PCB->MaxWidth / 2 - SIDE_X (gport->pcb_x);
-	ghid_port_ranges_pan (-2 * flipd, 0, TRUE);
-    }
-  if (do_flip_y)
-    {
-	flipd = PCB->MaxHeight / 2 - SIDE_Y (gport->pcb_y);
-	ghid_port_ranges_pan (0, -2 * flipd, TRUE);
+      bool new_comp_vis = Settings.ShowSolderSide && active_group == comp_group;
+
+      ChangeGroupVisibility (PCB->LayerGroups.Entries[comp_group][0],
+                             new_comp_vis, new_comp_vis);
+      ChangeGroupVisibility (PCB->LayerGroups.Entries[solder_group][0],
+                             !new_comp_vis, !new_comp_vis);
     }
 
-  ghid_invalidate_all ();
-  return 0;
+   return 0;
 }
 
 /* ------------------------------------------------------------ */
@@ -1702,11 +1557,12 @@ CursorAction(int argc, char **argv, int x, int y)
     AFAIL (cursor);
 
   dx = GetValueEx (argv[1], argv[3], NULL, extra_units_x, "");
-  if (ghid_flip_x)
-    dx = -dx;
   dy = GetValueEx (argv[2], argv[3], NULL, extra_units_y, "");
-  if (!ghid_flip_y)
-    dy = -dy;
+
+#if 0 /* We cannot know this sensibly from the renderer, so we have to remove it */
+  if (ghid_flip_x) dx = -dx;
+  if (!ghid_flip_y) dy = -dy;
+#endif
 
   EventMoveCrosshair (Crosshair.X + dx, Crosshair.Y + dy);
   gui->set_crosshair (Crosshair.X, Crosshair.Y, pan_warp);
@@ -2086,24 +1942,6 @@ HID_Action ghid_main_action_list[] = {
 REGISTER_ACTIONS (ghid_main_action_list)
 
 
-static int
-flag_flipx (int x)
-{ 
-  return ghid_flip_x;
-} 
-static int  
-flag_flipy (int x)
-{ 
-  return ghid_flip_y;
-} 
-
-HID_Flag ghid_main_flag_list[] = {
-  {"flip_x", flag_flipx, 0},
-  {"flip_y", flag_flipy, 0}
-};  
-
-REGISTER_FLAGS (ghid_main_flag_list)
-
 #include "dolists.h"
 
 /*
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index bc47214..7e3891d 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -52,7 +52,7 @@
 
 #define TOOLTIP_UPDATE_DELAY 200
 
-static gint x_pan_speed, y_pan_speed;
+// static gint x_pan_speed, y_pan_speed;
 void
 ghid_port_ranges_changed (void)
 {
@@ -647,6 +647,7 @@ ghid_port_window_enter_cb (GtkWidget * widget,
   return FALSE;
 }
 
+#if 0
 static gboolean
 ghid_pan_idle_cb (gpointer data)
 {
@@ -658,12 +659,13 @@ ghid_pan_idle_cb (gpointer data)
   dx = gport->zoom * x_pan_speed;
   return (ghid_port_ranges_pan (dx, dy, TRUE));
 }
+#endif
 
 gint
 ghid_port_window_leave_cb (GtkWidget * widget, 
                            GdkEventCrossing * ev, GHidPort * out)
 {
-  gint x0, y0, x, y, dx, dy, w, h;
+  // gint x0, y0, x, y, dx, dy, w, h;
   
   /* printf("leave mode: %d detail: %d\n", ev->mode, ev->detail); */
 
@@ -679,6 +681,7 @@ ghid_port_window_leave_cb (GtkWidget * widget,
       return FALSE;
     }
 
+#if 0
   if(out->has_entered && !ghidgui->in_popup)
     {
       /* if actively drawing, start scrolling */
@@ -734,6 +737,7 @@ ghid_port_window_leave_cb (GtkWidget * widget,
 	  g_idle_add (ghid_pan_idle_cb, NULL);
 	}
     }
+#endif
 
   out->has_entered = FALSE;
 
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index c52fb65..ba19d66 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -61,10 +61,6 @@
 #define	FROM_PCB_UNITS(v)	(Settings.grid_units_mm ? COORD_TO_MM(v) : COORD_TO_MIL(v))
 #define	TO_PCB_UNITS(v)		(Settings.grid_units_mm ? MM_TO_COORD(v) : MIL_TO_COORD(v))
 
-extern int ghid_flip_x, ghid_flip_y;
-#define SIDE_X(x)   ((ghid_flip_x ? PCB->MaxWidth - (x) : (x)))
-#define SIDE_Y(y)   ((ghid_flip_y ? PCB->MaxHeight - (y) : (y)))
-
 #define	DRAW_X(x)	(gint)((SIDE_X(x) - gport->view_x0) / gport->zoom)
 #define	DRAW_Y(y)	(gint)((SIDE_Y(y) - gport->view_y0) / gport->zoom)
 
@@ -505,12 +501,16 @@ void ghid_flush_debug_draw (void);
 void ghid_finish_debug_draw (void);
 bool ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y);
 bool ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y);
+void ghid_pan_view_abs (Coord pcb_x, Coord pcb_y, int widget_x, int widget_y);
+void ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom);
+void ghid_zoom_view_rel (Coord center_x, Coord center_y, double factor);
+void ghid_zoom_view_fit (void);
+void ghid_flip_view (Coord center_x, Coord center_y, bool flip_x, bool flip_y);
 
 void ghid_lead_user_to_location (Coord x, Coord y);
 void ghid_cancel_lead_user (void);
 
 /* gtkhid-main.c */
-void ghid_pan_fixup (void);
 void ghid_get_coords (const char *msg, int *x, int *y);
 gint PCBChanged (int argc, char **argv, int x, int y);
 
@@ -522,58 +522,4 @@ extern GdkPixmap *XC_lock_source, *XC_lock_mask;
 extern GdkPixmap *XC_clock_source, *XC_clock_mask;
 
 
-/* Coordinate conversions */
-/* Px converts view->pcb, Vx converts pcb->view */
-static inline int
-Vx (int x)
-{
-  int rv;
-  if (ghid_flip_x)
-    rv = (PCB->MaxWidth - x - gport->view_x0) / gport->zoom + 0.5;
-  else
-    rv = (x - gport->view_x0) / gport->zoom + 0.5;
-  return rv;
-}
-
-static inline int
-Vy (int y)
-{
-  int rv;
-  if (ghid_flip_y)
-    rv = (PCB->MaxHeight - y - gport->view_y0) / gport->zoom + 0.5;
-  else
-    rv = (y - gport->view_y0) / gport->zoom + 0.5;
-  return rv;
-}
-
-static inline int
-Vz (int z)
-{
-  return z / gport->zoom + 0.5;
-}
-
-static inline int
-Px (int x)
-{
-  int rv = x * gport->zoom + gport->view_x0;
-  if (ghid_flip_x)
-    rv = PCB->MaxWidth - (x * gport->zoom + gport->view_x0);
-  return  rv;
-}
-
-static inline int
-Py (int y)
-{
-  int rv = y * gport->zoom + gport->view_y0;
-  if (ghid_flip_y)
-    rv = PCB->MaxHeight - (y * gport->zoom + gport->view_y0);
-  return  rv;
-}
-
-static inline int
-Pz (int z)
-{
-  return (z * gport->zoom);
-}
-
 #endif /* __GHID_INCLUDED__  */

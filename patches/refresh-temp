Bottom: 54c20b84519429afbf61c963d0cd7aed0872625f
Top:    8009e4f2fbaea4a869cb63b4a2bf37f4aadbe2e5
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2012-01-21 14:26:22 +0000

Refresh of butcher-the-xor-crosshair-draw

---

diff --git a/src/Makefile.am b/src/Makefile.am
index 47035f6..2fd7d9a 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -61,6 +61,9 @@ PCB_SRCS = \
 	dolists.h \
 	draw.c \
 	draw.h \
+	draw_api.h \
+	outline_draw.c \
+	outline_draw.h \
 	drill.c \
 	drill.h \
 	edif.y \
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index f79aee1..2f6ad95 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -9,6 +9,7 @@
 #include "../hidint.h"
 #include "gui.h"
 #include "gui-pinout-preview.h"
+#include "outline_draw.h"
 
 /* The Linux OpenGL ABI 1.0 spec requires that we define
  * GL_GLEXT_PROTOTYPES before including gl.h or glx.h for extensions
@@ -851,6 +852,12 @@ ghid_screen_update (void)
 {
 }
 
+static void
+hidgl_set_draw_offset (DrawAPI *dapi, Coord x, Coord y)
+{
+  /* TODO: Fiddle with transformation matrix! */
+}
+
 #define Z_NEAR 3.0
 gboolean
 ghid_drawing_area_expose_cb (GtkWidget *widget,
@@ -945,8 +952,14 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   ghid_invalidate_current_gc ();
 
-  DrawAttached (NULL);
-  DrawMark (NULL);
+  {
+    DrawAPI *dapi;
+    dapi = outline_draw_new (gui);
+    dapi->set_draw_offset = hidgl_set_draw_offset;
+
+    DrawAttached (dapi);
+    DrawMark (dapi);
+  }
   hidgl_flush_triangles (&buffer);
 
   draw_crosshair (priv);
diff --git a/src/outline_draw.c b/src/outline_draw.c
index f8bed53..6da1b82 100644
--- a/src/outline_draw.c
+++ b/src/outline_draw.c
@@ -44,29 +44,32 @@
 #include <dmalloc.h>
 #endif
 
-
+/* FIXME: I THINK THIS IS THE SAME AS THE COMMON THINDRAW ROUTINE:
+ *        OK, NO.. IT ISN'T, THAT ONE RENDERS THE CLIPPED POLYGON.
+ *        SPEAKING OF WHICH.. I WONDER IF THIS ONE SHOULD TO!
+ */
 static void
-thindraw_pcb_polygon (PolygonType *polygon)
+outline_draw_pcb_polygon (DrawAPI *dapi, LayerType *layer, PolygonType *polygon)
 {
   Cardinal i;
   for (i = 0; i < polygon->PointN; i++)
     {
       Cardinal next = next_contour_point (polygon, i);
-      gui->draw_line (Crosshair.GC,
-                      polygon->Points[   i].X, polygon->Points[   i].Y,
-                      polygon->Points[next].X, polygon->Points[next].Y);
+      dapi->gapi->draw_line (dapi->gc,
+                             polygon->Points[   i].X, polygon->Points[   i].Y,
+                             polygon->Points[next].X, polygon->Points[next].Y);
     }
 }
 
 static void
-thindraw_pcb_line (LineType *line)
+outline_draw_pcb_line (DrawAPI *dapi, LayerType *layer, LineType *line)
 {
   Coord dx, dy, ox, oy;
   Coord thick;
   double h;
 
-  dx = line->Point2.X - line->Pointt1.X;
-  dx = line->Point2.Y - line->Pointt1.Y;
+  dx = line->Point2.X - line->Point1.X;
+  dy = line->Point2.Y - line->Point1.Y;
   thick = line->Thickness;
 
   if (dx != 0 || dy != 0)
@@ -76,82 +79,83 @@ thindraw_pcb_line (LineType *line)
 
   ox =   dy * h + 0.5 * SGN (dy);
   oy = -(dx * h + 0.5 * SGN (dx));
-  gui->draw_line (Crosshair.GC, line->Point1.X + ox, line->Point1.Y + oy,
-                                line->Point2.X + ox, line->Point2.Y + oy);
+  dapi->gapi->draw_line (dapi->gc, line->Point1.X + ox, line->Point1.Y + oy,
+                                   line->Point2.X + ox, line->Point2.Y + oy);
 
   if (abs (ox) >= pixel_slop || abs (oy) >= pixel_slop)
     {
       Angle angle = atan2 (dx, dy) * 57.295779;
-      gui->draw_line (Crosshair.GC, line->Point1.X - ox, line->Point1.Y - oy,
-                                    line->Point2.X - ox, line->Point2.Y - oy);
-      gui->draw_arc (Crosshair.GC, line->Point1.X, line->Point1.Y,
-                                   thick / 2, thick / 2, angle - 180, 180);
-      gui->draw_arc (Crosshair.GC, line->Point2.X, line->Point2.Y,
-                                   thick / 2, thick / 2, angle, 180);
+      dapi->gapi->draw_line (dapi->gc, line->Point1.X - ox, line->Point1.Y - oy,
+                                       line->Point2.X - ox, line->Point2.Y - oy);
+      dapi->gapi->draw_arc (dapi->gc, line->Point1.X, line->Point1.Y,
+                                      thick / 2, thick / 2, angle - 180, 180);
+      dapi->gapi->draw_arc (dapi->gc, line->Point2.X, line->Point2.Y,
+                                      thick / 2, thick / 2, angle, 180);
     }
 }
 
 static void
-thindraw_pcb_arc (ArcType *arc)
+outline_draw_pcb_arc (DrawAPI *dapi, LayerType *layer, ArcType *arc)
 {
-  if (wid > pixel_slop)
+  if (arc->Width > pixel_slop)
     {
       BoxType *bx = GetArcEnds (arc);
-      gui->draw_arc (Crosshair.GC, arc->X, arc->Y,
-                    arc->Width + arc->Thickness, arc->Height + arc->Thickness,
-                     arc->StartAngle, arc->Delta);
+      dapi->gapi->draw_arc (dapi->gc, arc->X, arc->Y,
+                            arc->Width + arc->Thickness, arc->Height + arc->Thickness,
+                            arc->StartAngle, arc->Delta);
 
-      gui->draw_arc (Crosshair.GC, arc->X, arc->Y,
-                     arc->Width - arc->Thickness, arc->Height - arc->Thickness,
-                     arc->StartAngle, arc->Delta);
+      dapi->gapi->draw_arc (dapi->gc, arc->X, arc->Y,
+                            arc->Width - arc->Thickness, arc->Height - arc->Thickness,
+                            arc->StartAngle, arc->Delta);
 
-      gui->draw_arc (Crosshair.GC, bx->X1, bx->Y1,
-                     arc->Thickness, arc->Thickness,
-                     arc->StartAngle, -180 * SGN (arc->Delta));
+      dapi->gapi->draw_arc (dapi->gc, bx->X1, bx->Y1,
+                            arc->Thickness, arc->Thickness,
+                            arc->StartAngle, -180 * SGN (arc->Delta));
 
-      gui->draw_arc (Crosshair.GC, bx->X2, bx->Y2,
-                     arc->Thickness, arc->Thickness,
-                     arc->StartAngle + arc->Delta, 180 * SGN (arc->Delta));
+      dapi->gapi->draw_arc (dapi->gc, bx->X2, bx->Y2,
+                            arc->Thickness, arc->Thickness,
+                            arc->StartAngle + arc->Delta, 180 * SGN (arc->Delta));
     }
   else
-    gui->draw_arc (Crosshair.GC, arc->X, arc->Y, arc->Width, arc->Height, arc->StartAngle, arc->Delta);
+    dapi->gapi->draw_arc (dapi->gc, arc->X, arc->Y,
+                          arc->Width, arc->Height, arc->StartAngle, arc->Delta);
 }
 
 /* ---------------------------------------------------------------------------
  * draws the elements of a loaded circuit which is to be merged in
  */
 static void
-thindraw_pcb_element (ElementType *Element)
+outline_draw_pcb_element (DrawAPI *dapi, ElementType *Element)
 {
   /* if no silkscreen, draw the bounding box */
   if (Element->ArcN == 0 && Element->LineN == 0)
     {
-      gui->draw_line (Crosshair.GC, Element->BoundingBox.X1, Element->BoundingBox.Y1,
+      dapi->gapi->draw_line (dapi->gc, Element->BoundingBox.X1, Element->BoundingBox.Y1,
                                     Element->BoundingBox.X1, Element->BoundingBox.Y2);
-      gui->draw_line (Crosshair.GC, Element->BoundingBox.X1, Element->BoundingBox.Y2,
+      dapi->gapi->draw_line (dapi->gc, Element->BoundingBox.X1, Element->BoundingBox.Y2,
                                     Element->BoundingBox.X2, Element->BoundingBox.Y2);
-      gui->draw_line (Crosshair.GC, Element->BoundingBox.X2, Element->BoundingBox.Y2,
+      dapi->gapi->draw_line (dapi->gc, Element->BoundingBox.X2, Element->BoundingBox.Y2,
                                     Element->BoundingBox.X2, Element->BoundingBox.Y1);
-      gui->draw_line (Crosshair.GC, Element->BoundingBox.X2, Element->BoundingBox.Y1,
+      dapi->gapi->draw_line (dapi->gc, Element->BoundingBox.X2, Element->BoundingBox.Y1,
                                     Element->BoundingBox.X1, Element->BoundingBox.Y1);
     }
   else
     {
       ELEMENTLINE_LOOP (Element);
       {
-        thindraw_pcb_line (line);
+        dapi->draw_pcb_line (dapi, NULL, line);
       }
       END_LOOP;
       ARC_LOOP (Element);
       {
-        thindraw_pcb_arc (arc);
+        dapi->draw_pcb_arc (dapi, NULL, arc);
       }
       END_LOOP;
     }
 
   PIN_LOOP (Element);
   {
-    thindraw_moved_pv (pin, DX, DY);
+    dapi->draw_pcb_pin (dapi, pin);
   }
   END_LOOP;
 
@@ -161,27 +165,27 @@ thindraw_pcb_element (ElementType *Element)
     if (PCB->InvisibleObjectsOn ||
         (TEST_FLAG (ONSOLDERFLAG, pad) != 0) == Settings.ShowSolderSide)
       {
-        thindraw_pcb_pad (Crosshair.GC, pad, false, false);
+        dapi->draw_pcb_pad (dapi, NULL, pad);
       }
   }
   END_LOOP;
 
   /* Element mark */
-  gui->draw_line (Crosshair.GC, Element->MarkX - EMARK_SIZE, Element->MarkY,
-                                Element->MarkX,              Element->MarkY - EMARK_SIZE);
-  gui->draw_line (Crosshair.GC, Element->MarkX + EMARK_SIZE, Element->MarkY,
-                                Element->MarkX,              Element->MarkY - EMARK_SIZE);
-  gui->draw_line (Crosshair.GC, Element->MarkX - EMARK_SIZE, Element->MarkY,
-                                Element->MarkX,              Element->MarkY + EMARK_SIZE);
-  gui->draw_line (Crosshair.GC, Element->MarkX + EMARK_SIZE, Element->MarkY,
-                                Element->MarkX,              Element->MarkY + EMARK_SIZE);
+  dapi->gapi->draw_line (dapi->gc, Element->MarkX - EMARK_SIZE, Element->MarkY,
+                                   Element->MarkX,              Element->MarkY - EMARK_SIZE);
+  dapi->gapi->draw_line (dapi->gc, Element->MarkX + EMARK_SIZE, Element->MarkY,
+                                   Element->MarkX,              Element->MarkY - EMARK_SIZE);
+  dapi->gapi->draw_line (dapi->gc, Element->MarkX - EMARK_SIZE, Element->MarkY,
+                                   Element->MarkX,              Element->MarkY + EMARK_SIZE);
+  dapi->gapi->draw_line (dapi->gc, Element->MarkX + EMARK_SIZE, Element->MarkY,
+                                   Element->MarkX,              Element->MarkY + EMARK_SIZE);
 }
 
 /* ---------------------------------------------------------------------------
  * draws all visible and attached objects of the pastebuffer
  */
 static void
-thindraw_pcb_buffer (BufferType *Buffer)
+outline_draw_pcb_buffer (DrawAPI *dapi, BufferType *Buffer)
 {
   Cardinal i;
 
@@ -193,22 +197,22 @@ thindraw_pcb_buffer (BufferType *Buffer)
 
         LINE_LOOP (layer);
         {
-          thindraw_pcb_line (line);
+          dapi->draw_pcb_line (dapi, layer, line);
         }
         END_LOOP;
         ARC_LOOP (layer);
         {
-          thindraw_pcb_arc (arc);
+          dapi->draw_pcb_arc (dapi, layer, arc);
         }
         END_LOOP;
         TEXT_LOOP (layer);
         {
-          thindraw_pcb_text (text);
+          dapi->draw_pcb_text (dapi, layer, text);
         }
         END_LOOP;
         POLYGON_LOOP (layer);
         {
-          thindraw_pcb_polygon (polygon);
+          dapi->draw_pcb_polygon (dapi, layer, polygon);
         }
         END_LOOP;
       }
@@ -219,7 +223,7 @@ thindraw_pcb_buffer (BufferType *Buffer)
       ELEMENT_LOOP (Buffer->Data);
       {
         if (FRONT (element) || PCB->InvisibleObjectsOn)
-          thindraw_pcb_element (element);
+          dapi->draw_pcb_element (dapi, element);
       }
       END_LOOP;
     }
@@ -229,8 +233,56 @@ thindraw_pcb_buffer (BufferType *Buffer)
     {
       VIA_LOOP (Buffer->Data);
       {
-        thindraw_pcb_pv (via);
+        dapi->draw_pcb_via (dapi, via);
       }
       END_LOOP;
     }
 }
+
+static void
+outline_draw_pcb_pv (DrawAPI *dapi, PinType *pin)
+{
+  dapi->gapi->thindraw_pcb_pv (dapi->gc, dapi->gc, pin, true, false);
+}
+
+static void
+outline_draw_pcb_pv_mask (DrawAPI *dapi, PinType *pin)
+{
+  dapi->gapi->thindraw_pcb_pv (dapi->gc, dapi->gc, pin, true, true);
+}
+
+static void
+outline_draw_pcb_pad (DrawAPI *dapi, LayerType *layer, PadType *pad)
+{
+  dapi->gapi->thindraw_pcb_pad (dapi->gc, pad, false, false);
+}
+
+DrawAPI *outline_draw_new (HID *gapi)
+{
+  DrawAPI *dapi;
+
+  dapi = g_new0 (DrawAPI, 1);
+  dapi->gapi = gapi;
+
+  dapi->draw_pcb_pin          = outline_draw_pcb_pv;
+  dapi->draw_pcb_pin_mask     = outline_draw_pcb_pv_mask;
+  dapi->draw_pcb_pin_hole     = NULL;
+  dapi->draw_pcb_via          = outline_draw_pcb_pv;
+  dapi->draw_pcb_via_mask     = outline_draw_pcb_pv_mask;
+  dapi->draw_pcb_via_hole     = NULL;
+  dapi->draw_pcb_pad          = outline_draw_pcb_pad;
+  dapi->draw_pcb_pad_mask     = NULL;
+  dapi->draw_pcb_pad_paste    = NULL;
+  dapi->draw_pcb_line         = outline_draw_pcb_line;
+  dapi->draw_pcb_arc          = outline_draw_pcb_arc;
+  dapi->draw_pcb_polygon      = outline_draw_pcb_polygon;
+
+  dapi->draw_pcb_element      = outline_draw_pcb_element;
+  dapi->draw_pcb_layer        = NULL;
+  dapi->draw_pcb_layer_group  = NULL;
+  dapi->draw_pcb_buffer       = outline_draw_pcb_buffer;
+  dapi->set_draw_offset       = NULL;
+  dapi->set_clip_box          = NULL;
+
+  return dapi;
+}

Bottom: 4bc3442d80fe36ba7e33548fe714bdb755e6efaf
Top:    3ed3c668718c7b226cc9f3afd807dbbec91b93f0
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-12-27 15:55:43 +0000

Refresh of wow-testing

---

diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index bb00996..916119c 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -70,10 +70,11 @@ ghid_draw_grid (void)
   static int npoints = 0;
   int x1, y1, x2, y2, n, i;
   double x, y;
+  return;
 
   if (!Settings.DrawGrid)
     return;
-  if (Vz (PCB->Grid) < MIN_GRID_DISTANCE)
+  if (SCREEN_R (PCB->Grid) < MIN_GRID_DISTANCE)
     return;
   if (!gport->grid_gc)
     {
@@ -104,13 +105,13 @@ ghid_draw_grid (void)
       y1 = y2;
       y2 = tmp;
     }
-  if (Vx (x1) < 0)
+  if (SCREEN_X (x1) < 0)
     x1 += PCB->Grid;
-  if (Vy (y1) < 0)
+  if (SCREEN_Y (y1) < 0)
     y1 += PCB->Grid;
-  if (Vx (x2) >= gport->width)
+  if (SCREEN_X (x2) >= gport->width)
     x2 -= PCB->Grid;
-  if (Vy (y2) >= gport->height)
+  if (SCREEN_Y (y2) >= gport->height)
     y2 -= PCB->Grid;
   n = (int) ((x2 - x1) / PCB->Grid + 0.5) + 1;
   if (n > npoints)
@@ -121,14 +122,14 @@ ghid_draw_grid (void)
   n = 0;
   for (x = x1; x <= x2; x += PCB->Grid)
     {
-      points[n].x = Vx (x);
+      points[n].x = SCREEN_X (x);
       n++;
     }
   if (n == 0)
     return;
   for (y = y1; y <= y2; y += PCB->Grid)
     {
-      int vy = Vy (y);
+      int vy = SCREEN_Y (y);
       for (i = 0; i < n; i++)
 	points[i].y = vy;
       gdk_draw_points (gport->drawable, gport->grid_gc, points, n);
@@ -385,7 +386,7 @@ ghid_set_line_cap (hidGC gc, EndCapStyle style)
     }
   if (gc->gc)
     gdk_gc_set_line_attributes (WHICH_GC (gc),
-				Vz (gc->width), GDK_LINE_SOLID,
+				SCREEN_R (gc->width), GDK_LINE_SOLID,
 				gc->cap, gc->join);
 }
 
@@ -396,7 +397,7 @@ ghid_set_line_width (hidGC gc, int width)
   gc->width = width;
   if (gc->gc)
     gdk_gc_set_line_attributes (WHICH_GC (gc),
-				Vz (gc->width), GDK_LINE_SOLID,
+				SCREEN_R (gc->width), GDK_LINE_SOLID,
 				gc->cap, gc->join);
 }
 
@@ -459,10 +460,10 @@ ghid_draw_line (hidGC gc, int x1, int y1, int x2, int y2)
 {
   double dx1, dy1, dx2, dy2;
 
-  dx1 = Vx ((double) x1);
-  dy1 = Vy ((double) y1);
-  dx2 = Vx ((double) x2);
-  dy2 = Vy ((double) y2);
+  dx1 = SCREEN_X ((double) x1);
+  dy1 = SCREEN_Y ((double) y1);
+  dx2 = SCREEN_X ((double) x2);
+  dy2 = SCREEN_Y ((double) y2);
 
   if (!ClipLine (0, 0, gport->width, gport->height,
 		 &dx1, &dy1, &dx2, &dy2, gc->width / gport->zoom))
@@ -491,8 +492,8 @@ ghid_draw_arc (hidGC gc, int cx, int cy,
 #endif
 
   USE_GC (gc);
-  vrx = Vz (xradius);
-  vry = Vz (yradius);
+  vrx = SCREEN_R (xradius);
+  vry = SCREEN_R (yradius);
 
   if (ghid_flip_x)
     {
@@ -508,7 +509,7 @@ ghid_draw_arc (hidGC gc, int cx, int cy,
   start_angle = (start_angle + 360 + 180) % 360 - 180;
 
   gdk_draw_arc (gport->drawable, gport->u_gc, 0,
-		Vx (cx) - vrx, Vy (cy) - vry,
+		SCREEN_X (cx) - vrx, SCREEN_Y (cy) - vry,
 		vrx * 2, vry * 2, (start_angle + 180) * 64, delta_angle * 64);
 }
 
@@ -533,10 +534,10 @@ ghid_draw_rect (hidGC gc, int x1, int y1, int x2, int y2)
     return;
 #endif
 
-  x1 = Vx (x1);
-  y1 = Vy (y1);
-  x2 = Vx (x2);
-  y2 = Vy (y2);
+  x1 = SCREEN_X (x1);
+  y1 = SCREEN_Y (y1);
+  x2 = SCREEN_X (x2);
+  y2 = SCREEN_Y (y2);
 
   if (x1 > x2)
     {
@@ -573,9 +574,9 @@ ghid_fill_circle (hidGC gc, int cx, int cy, int radius)
 #endif
 
   USE_GC (gc);
-  vr = Vz (radius);
+  vr = SCREEN_R (radius);
   gdk_draw_arc (gport->drawable, gport->u_gc, TRUE,
-		Vx (cx) - vr, Vy (cy) - vr, vr * 2, vr * 2, 0, 360 * 64);
+		SCREEN_X (cx) - vr, SCREEN_Y (cy) - vr, vr * 2, vr * 2, 0, 360 * 64);
 }
 
 void
@@ -593,8 +594,8 @@ ghid_fill_polygon (hidGC gc, int n_coords, int *x, int *y)
     }
   for (i = 0; i < n_coords; i++)
     {
-      points[i].x = Vx (x[i]);
-      points[i].y = Vy (y[i]);
+      points[i].x = SCREEN_X (x[i]);
+      points[i].y = SCREEN_Y (y[i]);
     }
   gdk_draw_polygon (gport->drawable, gport->u_gc, 1, points, n_coords);
 }
@@ -620,10 +621,10 @@ ghid_fill_rect (hidGC gc, int x1, int y1, int x2, int y2)
     return;
 #endif
 
-  x1 = Vx (x1);
-  y1 = Vy (y1);
-  x2 = Vx (x2);
-  y2 = Vy (y2);
+  x1 = SCREEN_X (x1);
+  y1 = SCREEN_Y (y1);
+  x2 = SCREEN_X (x2);
+  y2 = SCREEN_Y (y2);
   if (x2 < x1)
     {
       xx = x1;
@@ -656,15 +657,15 @@ ghid_invalidate_all ()
   if (!gport->pixmap)
     return;
 
-  region.X1 = MIN(Px(0), Px(gport->width + 1));
-  region.Y1 = MIN(Py(0), Py(gport->height + 1));
-  region.X2 = MAX(Px(0), Px(gport->width + 1));
-  region.Y2 = MAX(Py(0), Py(gport->height + 1));
+  region.X1 = MIN(PCB_X (0), PCB_X (gport->width  + 1));
+  region.Y1 = MIN(PCB_Y (0), PCB_Y (gport->height + 1));
+  region.X2 = MAX(PCB_X (0), PCB_X (gport->width  + 1));
+  region.Y2 = MAX(PCB_Y (0), PCB_Y (gport->height + 1));
 
-  eleft = Vx (0);
-  eright = Vx (PCB->MaxWidth);
-  etop = Vy (0);
-  ebottom = Vy (PCB->MaxHeight);
+  eleft =   SCREEN_X (0);
+  eright =  SCREEN_X (PCB->MaxWidth);
+  etop =    SCREEN_Y (0);
+  ebottom = SCREEN_Y (PCB->MaxHeight);
   if (eleft > eright)
     {
       int tmp = eleft;
@@ -829,8 +830,8 @@ ghid_show_crosshair (gboolean show)
       /* FIXME: when CrossColor changed from config */
       ghid_map_color_string (Settings.CrossColor, &cross_color);
     }
-  x = DRAW_X (gport->x_crosshair);
-  y = DRAW_Y (gport->y_crosshair);
+  x = SCREEN_X (gport->x_crosshair);
+  y = SCREEN_Y (gport->y_crosshair);
 
   gdk_gc_set_foreground (xor_gc, &cross_color);
 
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index cba96f7..24c237c 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -38,21 +38,6 @@ static void zoom_by (double factor, int x, int y);
 
 int ghid_flip_x = 0, ghid_flip_y = 0;
 
-/* ------------------------------------------------------------ */
-
-static inline int 
-Vx2 (int x)
-{     
-  return (x - gport->view_x0) / gport->zoom + 0.5;
-}       
-        
-static inline int 
-Vy2 (int y)
-{     
-  return (y - gport->view_y0) / gport->zoom + 0.5;
-}       
-
-/* ------------------------------------------------------------ */
 
 static void
 ghid_pan_fixup ()
@@ -62,31 +47,31 @@ ghid_pan_fixup ()
    * don't pan so far to the right that we see way past the right 
    * edge of the board.
    */
-  if (gport->view_x0 > PCB->MaxWidth - gport->view_width)
-    gport->view_x0 = PCB->MaxWidth - gport->view_width;
+//  if (gport->view_x0 > PCB->MaxWidth - gport->view_width)
+//    gport->view_x0 = PCB->MaxWidth - gport->view_width;
 
   /* 
    * don't pan so far down that we see way past the bottom edge of
    * the board.
    */
-  if (gport->view_y0 > PCB->MaxHeight - gport->view_height)
-    gport->view_y0 = PCB->MaxHeight - gport->view_height;
+//  if (gport->view_y0 > PCB->MaxHeight - gport->view_height)
+//    gport->view_y0 = PCB->MaxHeight - gport->view_height;
 
   /* don't view above or to the left of the board... ever */
-  if (gport->view_x0 < 0)
-    gport->view_x0 = 0;
+//  if (gport->view_x0 < 0)
+//    gport->view_x0 = 0;
 
-   if (gport->view_y0 < 0)
-    gport->view_y0 = 0;
+//   if (gport->view_y0 < 0)
+//    gport->view_y0 = 0;
 
 
    /* if we can see the entire board and some, then zoom to fit */
-   if (gport->view_width > PCB->MaxWidth &&
-       gport->view_height > PCB->MaxHeight)
-     {
-       zoom_by (1, 0, 0);
-       return;
-     }
+//   if (gport->view_width > PCB->MaxWidth &&
+//       gport->view_height > PCB->MaxHeight)
+//     {
+//       zoom_by (1, 0, 0);
+//       return;
+//     }
 
    gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view_x0);
    gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view_y0);
@@ -158,12 +143,6 @@ Zoom (int argc, char **argv, int x, int y)
       x = gport->view_width / 2;
       y = gport->view_height / 2;
     }
-  else
-    {
-      /* Px converts view->pcb, Vx converts pcb->view */
-      x = Vx (x);
-      y = Vy (y);
-    }
 
   if (argc < 1)
     {
@@ -202,8 +181,7 @@ Zoom (int argc, char **argv, int x, int y)
 static void
 zoom_to (double new_zoom, int x, int y)
 {
-  double max_zoom, xfrac, yfrac;
-  int cx, cy;
+//  double max_zoom;
 
   /* gport->zoom:
    * zoom value is PCB units per screen pixel.  Larger numbers mean zooming
@@ -214,85 +192,52 @@ zoom_to (double new_zoom, int x, int y)
    * gport->view_width and gport->view_height are in PCB coordinates
    */
 
-#ifdef DEBUG
-  printf ("\nzoom_to( %g, %d, %d)\n", new_zoom, x, y);
-#endif
-
-  xfrac = (double) x / (double) gport->view_width;
-  yfrac = (double) y / (double) gport->view_height;
-
-  if (ghid_flip_x)
-    xfrac = 1-xfrac;
-  if (ghid_flip_y)
-    yfrac = 1-yfrac;
-
   /* Find the zoom that would just make the entire board fit */
-  max_zoom = PCB->MaxWidth / gport->width;
-  if (max_zoom < PCB->MaxHeight / gport->height)
-    max_zoom = PCB->MaxHeight / gport->height;
+//  max_zoom = PCB->MaxWidth / gport->width;
+//  if (max_zoom < PCB->MaxHeight / gport->height)
+//    max_zoom = PCB->MaxHeight / gport->height;
 
-#ifdef DEBUG
-  printf ("zoom_to():  max_zoom = %g\n", max_zoom);
-#endif
-
-  /* 
+  /*
    * clip the zooming so we can never have more than 1 pixel per PCB
    * unit and never zoom out more than viewing the entire board
    */
-     
-  if (new_zoom < 1)
-    new_zoom = 1;
-  if (new_zoom > max_zoom)
-    new_zoom = max_zoom;
 
-#ifdef DEBUG
-  printf ("max_zoom = %g, xfrac = %g, yfrac = %g, new_zoom = %g\n", 
-	  max_zoom, xfrac, yfrac, new_zoom);
-#endif
-
-  /* find center x and y */
-  cx = gport->view_x0 + gport->view_width * xfrac * gport->zoom;
-  cy = gport->view_y0 + gport->view_height * yfrac * gport->zoom;
+//  if (new_zoom < 1)
+//    new_zoom = 1;
+//  if (new_zoom > max_zoom)
+//    new_zoom = max_zoom;
 
-#ifdef DEBUG
-  printf ("zoom_to():  x0 = %d, cx = %d\n", gport->view_x0, cx);
-  printf ("zoom_to():  y0 = %d, cy = %d\n", gport->view_y0, cy);
-#endif
-
-  if (gport->zoom != new_zoom)
+//  if (gport->zoom != new_zoom)
+  if (1)
     {
       gdouble xtmp, ytmp;
       gint x0, y0;
 
-      xtmp = (gport->view_x - gport->view_x0) / (gdouble) gport->view_width;
-      ytmp = (gport->view_y - gport->view_y0) / (gdouble) gport->view_height;
-      
+      xtmp = (x - gport->view_x0) / (double) gport->view_width;
+      ytmp = (y - gport->view_y0) / (double) gport->view_height;
+
       gport->zoom = new_zoom;
       pixel_slop = new_zoom;
       ghid_port_ranges_scale(FALSE);
 
       x0 = gport->view_x - xtmp * gport->view_width;
-      if (x0 < 0)
-	x0 = 0;
+//      if (x0 < 0)
+//	x0 = 0;
       gport->view_x0 = x0;
 
       y0 = gport->view_y - ytmp * gport->view_height;
-      if (y0 < 0)
-	y0 = 0;
+//      if (y0 < 0)
+//	y0 = 0;
       gport->view_y0 = y0;
-      
+
       ghidgui->adjustment_changed_holdoff = TRUE;
       gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view_x0);
       gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view_y0);
       ghidgui->adjustment_changed_holdoff = FALSE;
-      
+
       ghid_port_ranges_changed();
     }
 
-#ifdef DEBUG
-  printf ("zoom_to():  new x0 = %d\n", gport->view_x0);
-  printf ("zoom_to():  new y0 = %d\n", gport->view_y0);
-#endif
   ghid_set_status_line_label ();
 }
 
@@ -509,7 +454,7 @@ ghid_set_crosshair (int x, int y, int action)
      * hopefully by avoiding the direct call to an X function we might still work under windows
      * and other non-X11 based gdk's
      */
-    gdk_display_warp_pointer (display, screen, xofs + Vx (x), yofs + Vy (y));
+    gdk_display_warp_pointer (display, screen, xofs + SCREEN_X (x), yofs + SCREEN_Y (y));
 
 
 #else
@@ -519,7 +464,7 @@ ghid_set_crosshair (int x, int y, int action)
     XWarpPointer (GDK_DRAWABLE_XDISPLAY (gport->drawing_area->window),
 		  None, GDK_WINDOW_XID (gport->drawing_area->window),
 		  0, 0, 0, 0,
-		  xofs + Vx (x), yofs + Vy (y));
+		  xofs + SCREEN_X (x), yofs + SCREEN_Y (y));
 #  else
 #    error  "sorry.  You need gtk+>=2.8.0 unless you are on X windows"
 #  endif
@@ -1686,22 +1631,22 @@ Center(int argc, char **argv, int x, int y)
   x = GRIDFIT_X (x, PCB->Grid);
   y = GRIDFIT_Y (y, PCB->Grid);
 
-  w2 = gport->view_width / 2;
-  h2 = gport->view_height / 2;
+  w2 = FLIP_X (gport->view_width) / 2;
+  h2 = FLIP_Y (gport->view_height) / 2;
   x0 = x - w2;
   y0 = y - h2;
 
-  if (x0 < 0) 
-    {
-      x0 = 0;
-      x = x0 + w2;
-    }
+//  if (x0 < 0) 
+//    {
+//      x0 = 0;
+//      x = x0 + w2;
+//    }
 
-  if (y0 < 0)
-    {
-      y0 = 0;
-      y = y0 + w2;
-    }
+//  if (y0 < 0)
+//    {
+//      y0 = 0;
+//      y = y0 + w2;
+//    }
 
   dx = (x0 - gport->view_x0) / FLIP_X (gport->zoom);
   dy = (y0 - gport->view_y0) / FLIP_Y (gport->zoom);
@@ -1750,7 +1695,7 @@ Center(int argc, char **argv, int x, int y)
     XWarpPointer (GDK_DRAWABLE_XDISPLAY (gport->drawing_area->window),
 		 w_src, w_dst,
 		 0, 0, 0, 0,
-		 Vx2 (x), Vy2 (y));
+		 SCREEN_X (x), SCREEN_Y (y));
     
     /* XWarpPointer creates Motion events normally bound to
      *  EventMoveCrosshair.
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index e40f7d2..c19d433 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -143,10 +143,10 @@ ghid_port_ranges_scale (gboolean emit_changed)
   gport->view_width = gport->width * gport->zoom;
   gport->view_height = gport->height * gport->zoom;
 
-  if (gport->view_width >= PCB->MaxWidth)
-    gport->view_width = PCB->MaxWidth;
-  if (gport->view_height >= PCB->MaxHeight)
-    gport->view_height = PCB->MaxHeight;
+//  if (gport->view_width >= PCB->MaxWidth)
+//    gport->view_width = PCB->MaxWidth;
+//  if (gport->view_height >= PCB->MaxHeight)
+//    gport->view_height = PCB->MaxHeight;
 
   adj = gtk_range_get_adjustment (GTK_RANGE (ghidgui->h_range));
   adj->page_size = gport->view_width;
@@ -174,31 +174,31 @@ ghid_port_ranges_zoom (gdouble zoom)
   /* figure out zoom values in that would just make the width fit and
    * that would just make the height fit
    */
-  xtmp = (gdouble) PCB->MaxWidth / gport->width;
-  ytmp = (gdouble) PCB->MaxHeight / gport->height;
+//  xtmp = (gdouble) PCB->MaxWidth / gport->width;
+//  ytmp = (gdouble) PCB->MaxHeight / gport->height;
 
   /* if we've tried to zoom further out than what would make the
    * entire board fit or we passed 0, then pick a zoom that just makes
    * the board fit.
    */
-  if ((zoom > xtmp && zoom > ytmp) || zoom == 0.0)
-    zoom = (xtmp > ytmp) ? xtmp : ytmp;
+//  if ((zoom > xtmp && zoom > ytmp) || zoom == 0.0)
+//    zoom = (xtmp > ytmp) ? xtmp : ytmp;
 
-  xtmp = (gport->view_x - gport->view_x0) / (gdouble) gport->view_width;
-  ytmp = (gport->view_y - gport->view_y0) / (gdouble) gport->view_height;
+  xtmp = (gport->view_x - gport->view_x0) / (double) FLIP_X (gport->view_width);
+  ytmp = (gport->view_y - gport->view_y0) / (double) FLIP_Y (gport->view_height);
 
   gport->zoom = zoom;
   pixel_slop = zoom;
   ghid_port_ranges_scale(FALSE);
 
   x0 = gport->view_x - xtmp * gport->view_width;
-  if (x0 < 0)
-    x0 = 0;
+//  if (x0 < 0)
+//    x0 = 0;
   gport->view_x0 = x0;
 
   y0 = gport->view_y - ytmp * gport->view_height;
-  if (y0 < 0)
-    y0 = 0;
+//  if (y0 < 0)
+//    y0 = 0;
   gport->view_y0 = y0;
 
   ghidgui->adjustment_changed_holdoff = TRUE;
@@ -242,8 +242,8 @@ ghid_note_event_location (GdkEventButton * ev)
       event_x = ev->x;
       event_y = ev->y;
     }
-  gport->view_x = VIEW_X (event_x);
-  gport->view_y = VIEW_Y (event_y);
+  gport->view_x = PCB_X (event_x);
+  gport->view_y = PCB_Y (event_y);
 
   moved = MoveCrosshairAbsolute (gport->view_x, gport->view_y);
   if (moved)
@@ -818,8 +818,8 @@ ghid_port_window_leave_cb (GtkWidget * widget,
 	  w = ghid_port.width * gport->zoom;
 	  h = ghid_port.height * gport->zoom;
 
-	  x0 = VIEW_X (0);
-	  y0 = VIEW_Y (0);
+	  x0 = PCB_X (0);
+	  y0 = PCB_Y (0);
 	  ghid_get_coords (NULL, &x, &y);
 	  x -= x0;
 	  y -= y0;
diff --git a/src/hid/gtk/gui-render-pixmap.c b/src/hid/gtk/gui-render-pixmap.c
index b24e6c9..623dc5a 100644
--- a/src/hid/gtk/gui-render-pixmap.c
+++ b/src/hid/gtk/gui-render-pixmap.c
@@ -80,10 +80,10 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   gdk_draw_rectangle (pixmap, gport->bg_gc, TRUE, 0, 0, width, height);
 
   /* call the drawing routine */
-  region.X1 = MIN(Px(0), Px(gport->width + 1));
-  region.Y1 = MIN(Py(0), Py(gport->height + 1));
-  region.X2 = MAX(Px(0), Px(gport->width + 1));
-  region.Y2 = MAX(Py(0), Py(gport->height + 1));
+  region.X1 = MIN(PCB_X (0), PCB_X (gport->width + 1));
+  region.Y1 = MIN(PCB_Y (0), PCB_Y (gport->height + 1));
+  region.X2 = MAX(PCB_X (0), PCB_X (gport->width + 1));
+  region.Y2 = MAX(PCB_Y (0), PCB_Y (gport->height + 1));
   hid_expose_callback (&ghid_hid, &region, NULL);
 
   gport->drawable = save_drawable;
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index d369623..06a31ff 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -68,12 +68,12 @@ extern int ghid_flip_x, ghid_flip_y;
 #define FLIP_X(x) (ghid_flip_x ? -(x) : (x))
 #define FLIP_Y(y) (ghid_flip_y ? -(y) : (y))
 
-#define DRAW_X(x) (int)((double)((x) - gport->view_x0) / FLIP_X (gport->zoom) + 0.5)
-#define DRAW_Y(y) (int)((double)((y) - gport->view_y0) / FLIP_Y (gport->zoom) + 0.5)
-#define DRAW_R(r) (int)((double)(r) * gport->zoom + 0.5)
+#define SCREEN_X(x) (int)((double)((x) - gport->view_x0) / FLIP_X (gport->zoom) + 0.5)
+#define SCREEN_Y(y) (int)((double)((y) - gport->view_y0) / FLIP_Y (gport->zoom) + 0.5)
+#define SCREEN_R(r) (int)((double)(r) / gport->zoom + 0.5)
 
-#define VIEW_X(x) (int)((double)(x) * FLIP_X (gport->zoom) + gport->view_x0)
-#define VIEW_Y(y) (int)((double)(y) * FLIP_Y (gport->zoom) + gport->view_y0)
+#define PCB_X(x) (int)((double)(x) * FLIP_X (gport->zoom) + gport->view_x0)
+#define PCB_Y(y) (int)((double)(y) * FLIP_Y (gport->zoom) + gport->view_y0)
 
 /*
  * Used to intercept "special" hotkeys that gtk doesn't usually pass

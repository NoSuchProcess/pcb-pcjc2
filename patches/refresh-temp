Bottom: 09c25b35fa2f074f625efc0a3686ffc6babdf877
Top:    41fd749e9c5efea53662aba37825da69b4e51f00
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-11-01 14:02:54 +0000

Refresh of bentley-ottann-test-implementa

---

diff --git a/src/Makefile.am b/src/Makefile.am
index 5003dea..55d14c7 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -157,7 +157,6 @@ PCB_SRCS = \
 	set.h \
 	strflags.c \
 	strflags.h \
-	sweep.c \
 	sweep.h \
 	thermal.c \
 	thermal.h \
diff --git a/src/cairo/cairo-bentley-ottmann.c b/src/cairo/cairo-bentley-ottmann.c
index 3835399..079cf7c 100644
--- a/src/cairo/cairo-bentley-ottmann.c
+++ b/src/cairo/cairo-bentley-ottmann.c
@@ -1752,362 +1752,6 @@ _cairo_bentley_ottmann_tessellate_polygon (cairo_traps_t         *traps,
     return status;
 }
 
-#if 0
-cairo_status_t
-_cairo_bentley_ottmann_tessellate_traps (cairo_traps_t *traps,
-                                         cairo_fill_rule_t fill_rule)
-{
-    cairo_status_t status;
-    cairo_polygon_t polygon;
-    int i;
-
-    if (unlikely (0 == traps->num_traps))
-        return CAIRO_STATUS_SUCCESS;
-
-#if DEBUG_TRAPS
-    dump_traps (traps, "bo-traps-in.txt");
-#endif
-
-    _cairo_polygon_init (&polygon);
-    _cairo_polygon_limit (&polygon, traps->limits, traps->num_limits);
-
-    for (i = 0; i < traps->num_traps; i++) {
-        status = _cairo_polygon_add_line (&polygon,
-                                          &traps->traps[i].left,
-                                          traps->traps[i].top,
-                                          traps->traps[i].bottom,
-                                          1);
-        if (unlikely (status))
-            goto CLEANUP;
-
-        status = _cairo_polygon_add_line (&polygon,
-                                          &traps->traps[i].right,
-                                          traps->traps[i].top,
-                                          traps->traps[i].bottom,
-                                          -1);
-        if (unlikely (status))
-            goto CLEANUP;
-    }
-
-    _cairo_traps_clear (traps);
-    status = _cairo_bentley_ottmann_tessellate_polygon (traps,
-                                                        &polygon,
-                                                        fill_rule);
-
-#if DEBUG_TRAPS
-    dump_traps (traps, "bo-traps-out.txt");
-#endif
-
-  CLEANUP:
-    _cairo_polygon_fini (&polygon);
-
-    return status;
-}
-#endif
-
-#if 0
-static cairo_bool_t
-edges_have_an_intersection_quadratic (cairo_bo_edge_t        *edges,
-                                      int                 num_edges)
-
-{
-    int i, j;
-    cairo_bo_edge_t *a, *b;
-    cairo_bo_point32_t intersection;
-
-    /* We must not be given any upside-down edges. */
-    for (i = 0; i < num_edges; i++) {
-        assert (_cairo_bo_point32_compare (&edges[i].top, &edges[i].bottom) < 0);
-        edges[i].edge.line.p1.x <<= CAIRO_BO_GUARD_BITS;
-        edges[i].edge.line.p1.y <<= CAIRO_BO_GUARD_BITS;
-        edges[i].edge.line.p2.x <<= CAIRO_BO_GUARD_BITS;
-        edges[i].edge.line.p2.y <<= CAIRO_BO_GUARD_BITS;
-    }
-
-    for (i = 0; i < num_edges; i++) {
-        for (j = 0; j < num_edges; j++) {
-            if (i == j)
-                continue;
-
-            a = &edges[i];
-            b = &edges[j];
-
-            if (! _cairo_bo_edge_intersect (a, b, &intersection))
-                continue;
-
-            printf ("Found intersection (%d,%d) between (%d,%d)-(%d,%d) and (%d,%d)-(%d,%d)\n",
-                    intersection.x,
-                    intersection.y,
-                    a->edge.line.p1.x, a->edge.line.p1.y,
-                    a->edge.line.p2.x, a->edge.line.p2.y,
-                    b->edge.line.p1.x, b->edge.line.p1.y,
-                    b->edge.line.p2.x, b->edge.line.p2.y);
-
-            return TRUE;
-        }
-    }
-    return FALSE;
-}
-
-#define TEST_MAX_EDGES 10
-
-typedef struct test {
-    const char *name;
-    const char *description;
-    int num_edges;
-    cairo_bo_edge_t edges[TEST_MAX_EDGES];
-} test_t;
-
-static test_t
-tests[] = {
-    {
-        "3 near misses",
-        "3 edges all intersecting very close to each other",
-        3,
-        {
-            { { 4, 2}, {0, 0}, { 9, 9}, NULL, NULL },
-            { { 7, 2}, {0, 0}, { 2, 3}, NULL, NULL },
-            { { 5, 2}, {0, 0}, { 1, 7}, NULL, NULL }
-        }
-    },
-    {
-        "inconsistent data",
-        "Derived from random testing---was leading to skip list and edge list disagreeing.",
-        2,
-        {
-            { { 2, 3}, {0, 0}, { 8, 9}, NULL, NULL },
-            { { 2, 3}, {0, 0}, { 6, 7}, NULL, NULL }
-        }
-    },
-    {
-        "failed sort",
-        "A test derived from random testing that leads to an inconsistent sort --- looks like we just can't attempt to validate the sweep line with edge_compare?",
-        3,
-        {
-            { { 6, 2}, {0, 0}, { 6, 5}, NULL, NULL },
-            { { 3, 5}, {0, 0}, { 5, 6}, NULL, NULL },
-            { { 9, 2}, {0, 0}, { 5, 6}, NULL, NULL },
-        }
-    },
-    {
-        "minimal-intersection",
-        "Intersection of a two from among the smallest possible edges.",
-        2,
-        {
-            { { 0, 0}, {0, 0}, { 1, 1}, NULL, NULL },
-            { { 1, 0}, {0, 0}, { 0, 1}, NULL, NULL }
-        }
-    },
-    {
-        "simple",
-        "A simple intersection of two edges at an integer (2,2).",
-        2,
-        {
-            { { 1, 1}, {0, 0}, { 3, 3}, NULL, NULL },
-            { { 2, 1}, {0, 0}, { 2, 3}, NULL, NULL }
-        }
-    },
-    {
-        "bend-to-horizontal",
-        "With intersection truncation one edge bends to horizontal",
-        2,
-        {
-            { { 9, 1}, {0, 0}, {3, 7}, NULL, NULL },
-            { { 3, 5}, {0, 0}, {9, 9}, NULL, NULL }
-        }
-    }
-};
-
-/*
-    {
-        "endpoint",
-        "An intersection that occurs at the endpoint of a segment.",
-        {
-            { { 4, 6}, { 5, 6}, NULL, { { NULL }} },
-            { { 4, 5}, { 5, 7}, NULL, { { NULL }} },
-            { { 0, 0}, { 0, 0}, NULL, { { NULL }} },
-        }
-    }
-    {
-        name = "overlapping",
-        desc = "Parallel segments that share an endpoint, with different slopes.",
-        edges = {
-            { top = { x = 2, y = 0}, bottom = { x = 1, y = 1}},
-            { top = { x = 2, y = 0}, bottom = { x = 0, y = 2}},
-            { top = { x = 0, y = 3}, bottom = { x = 1, y = 3}},
-            { top = { x = 0, y = 3}, bottom = { x = 2, y = 3}},
-            { top = { x = 0, y = 4}, bottom = { x = 0, y = 6}},
-            { top = { x = 0, y = 5}, bottom = { x = 0, y = 6}}
-        }
-    },
-    {
-        name = "hobby_stage_3",
-        desc = "A particularly tricky part of the 3rd stage of the 'hobby' test below.",
-        edges = {
-            { top = { x = -1, y = -2}, bottom = { x =  4, y = 2}},
-            { top = { x =  5, y =  3}, bottom = { x =  9, y = 5}},
-            { top = { x =  5, y =  3}, bottom = { x =  6, y = 3}},
-        }
-    },
-    {
-        name = "hobby",
-        desc = "Example from John Hobby's paper. Requires 3 passes of the iterative algorithm.",
-        edges = {
-            { top = { x =   0, y =   0}, bottom = { x =   9, y =   5}},
-            { top = { x =   0, y =   0}, bottom = { x =  13, y =   6}},
-            { top = { x =  -1, y =  -2}, bottom = { x =   9, y =   5}}
-        }
-    },
-    {
-        name = "slope",
-        desc = "Edges with same start/stop points but different slopes",
-        edges = {
-            { top = { x = 4, y = 1}, bottom = { x = 6, y = 3}},
-            { top = { x = 4, y = 1}, bottom = { x = 2, y = 3}},
-            { top = { x = 2, y = 4}, bottom = { x = 4, y = 6}},
-            { top = { x = 6, y = 4}, bottom = { x = 4, y = 6}}
-        }
-    },
-    {
-        name = "horizontal",
-        desc = "Test of a horizontal edge",
-        edges = {
-            { top = { x = 1, y = 1}, bottom = { x = 6, y = 6}},
-            { top = { x = 2, y = 3}, bottom = { x = 5, y = 3}}
-        }
-    },
-    {
-        name = "vertical",
-        desc = "Test of a vertical edge",
-        edges = {
-            { top = { x = 5, y = 1}, bottom = { x = 5, y = 7}},
-            { top = { x = 2, y = 4}, bottom = { x = 8, y = 5}}
-        }
-    },
-    {
-        name = "congruent",
-        desc = "Two overlapping edges with the same slope",
-        edges = {
-            { top = { x = 5, y = 1}, bottom = { x = 5, y = 7}},
-            { top = { x = 5, y = 2}, bottom = { x = 5, y = 6}},
-            { top = { x = 2, y = 4}, bottom = { x = 8, y = 5}}
-        }
-    },
-    {
-        name = "multi",
-        desc = "Several segments with a common intersection point",
-        edges = {
-            { top = { x = 1, y = 2}, bottom = { x = 5, y = 4} },
-            { top = { x = 1, y = 1}, bottom = { x = 5, y = 5} },
-            { top = { x = 2, y = 1}, bottom = { x = 4, y = 5} },
-            { top = { x = 4, y = 1}, bottom = { x = 2, y = 5} },
-            { top = { x = 5, y = 1}, bottom = { x = 1, y = 5} },
-            { top = { x = 5, y = 2}, bottom = { x = 1, y = 4} }
-        }
-    }
-};
-*/
-
-static int
-run_test (const char                *test_name,
-          cairo_bo_edge_t        *test_edges,
-          int                         num_edges)
-{
-    int i, intersections, passes;
-    cairo_bo_edge_t *edges;
-    cairo_array_t intersected_edges;
-
-    printf ("Testing: %s\n", test_name);
-
-    _cairo_array_init (&intersected_edges, sizeof (cairo_bo_edge_t));
-
-//    intersections = _cairo_bentley_ottmann_intersect_edges (test_edges, num_edges, &intersected_edges);
-
-      _cairo_bentley_ottmann_tessellate_bo_edges (cairo_bo_event_t   **start_events,
-                                            int                         num_events,
-                                            cairo_fill_rule_t         fill_rule,
-                                            cairo_traps_t        *traps,
-                                            int                        *num_intersections)
-
-    if (intersections)
-        printf ("Pass 1 found %d intersections:\n", intersections);
-
-
-    /* XXX: Multi-pass Bentley-Ottmmann. Preferable would be to add a
-     * pass of Hobby's tolerance-square algorithm instead. */
-    passes = 1;
-    while (intersections) {
-        int num_edges = _cairo_array_num_elements (&intersected_edges);
-        passes++;
-        edges = _cairo_malloc_ab (num_edges, sizeof (cairo_bo_edge_t));
-        assert (edges != NULL);
-        memcpy (edges, _cairo_array_index (&intersected_edges, 0), num_edges * sizeof (cairo_bo_edge_t));
-        _cairo_array_fini (&intersected_edges);
-        _cairo_array_init (&intersected_edges, sizeof (cairo_bo_edge_t));
-        intersections = _cairo_bentley_ottmann_intersect_edges (edges, num_edges, &intersected_edges);
-        free (edges);
-
-        if (intersections){
-            printf ("Pass %d found %d remaining intersections:\n", passes, intersections);
-        } else {
-            if (passes > 3)
-                for (i = 0; i < passes; i++)
-                    printf ("*");
-            printf ("No remainining intersections found after pass %d\n", passes);
-        }
-    }
-
-    if (edges_have_an_intersection_quadratic (_cairo_array_index (&intersected_edges, 0),
-                                              _cairo_array_num_elements (&intersected_edges)))
-        printf ("*** FAIL ***\n");
-    else
-        printf ("PASS\n");
-
-    _cairo_array_fini (&intersected_edges);
-
-    return 0;
-}
-
-#define MAX_RANDOM 300
-
-int
-main (void)
-{
-    char random_name[] = "random-XX";
-    cairo_bo_edge_t random_edges[MAX_RANDOM], *edge;
-    unsigned int i, num_random;
-    test_t *test;
-
-    for (i = 0; i < ARRAY_LENGTH (tests); i++) {
-        test = &tests[i];
-        run_test (test->name, test->edges, test->num_edges);
-    }
-
-    for (num_random = 0; num_random < MAX_RANDOM; num_random++) {
-        srand (0);
-        for (i = 0; i < num_random; i++) {
-            do {
-                edge = &random_edges[i];
-                edge->edge.line.p1.x = (int32_t) (10.0 * (rand() / (RAND_MAX + 1.0)));
-                edge->edge.line.p1.y = (int32_t) (10.0 * (rand() / (RAND_MAX + 1.0)));
-                edge->edge.line.p2.x = (int32_t) (10.0 * (rand() / (RAND_MAX + 1.0)));
-                edge->edge.line.p2.y = (int32_t) (10.0 * (rand() / (RAND_MAX + 1.0)));
-                if (edge->edge.line.p1.y > edge->edge.line.p2.y) {
-                    int32_t tmp = edge->edge.line.p1.y;
-                    edge->edge.line.p1.y = edge->edge.line.p2.y;
-                    edge->edge.line.p2.y = tmp;
-                }
-            } while (edge->edge.line.p1.y == edge->edge.line.p2.y);
-        }
-
-        sprintf (random_name, "random-%02d", num_random);
-
-        run_test (random_name, random_edges, num_random);
-    }
-
-    return 0;
-}
-#endif
 
 typedef struct {
   int x;
@@ -2195,46 +1839,3 @@ bentley_ottmann_intersect_segments (GList *data)
     return status;
 }
 
-void
-my_cairo_test (void)
-{
-  bos_line *points;
-  GList *data = NULL;
-  int i = 0;
-
-  printf ("Cairo bentley ottmann test\n");
-
-  points = g_new0 (bos_line, 4);
-
-  /* Line from (10,10)-(20,20) */
-  points[i].a.x = 10; points[i].a.y = 10;
-  points[i].b.x = 20; points[i].b.y = 20;
-  points[i].num = i;
-  data = g_list_prepend (data, &points[i]);
-  i++;
-
-  /* Line from (10,20)-(20,10) */
-  points[i].a.x = 20; points[i].a.y = 10;
-  points[i].b.x = 10; points[i].b.y = 20;
-  points[i].num = i;
-  data = g_list_prepend (data, &points[i]);
-  i++;
-
-#if 0
-  /* Line from (14,10)-(16,20) */
-  points[i].a.x = 14; points[i].a.y = 10;
-  points[i].b.x = 16; points[i].b.y = 20;
-  points[i].num = i;
-  data = g_list_prepend (data, &points[i]);
-  i++;
-
-  /* Line from (16,10)-(18,20) */
-  points[i].a.x = 16; points[i].a.y = 10;
-  points[i].b.x = 18; points[i].b.y = 20;
-  points[i].num = i;
-  data = g_list_prepend (data, &points[i]);
-  i++;
-#endif
-
-  bentley_ottmann_intersect_segments (data);
-}
diff --git a/src/main.c b/src/main.c
index 06dfdcf..a72dad4 100644
--- a/src/main.c
+++ b/src/main.c
@@ -40,6 +40,7 @@
 #include <signal.h>
 #include <unistd.h>
 #include <sys/stat.h>
+#include <setjmp.h>
 
 #include "global.h"
 #include "data.h"
@@ -831,7 +832,6 @@ char *program_directory = 0;
 
 #include "dolists.h"
 
-#if 1
 int
 main (int argc, char *argv[])
 {
@@ -1042,5 +1042,4 @@ main (int argc, char *argv[])
 
   return (0);
 }
-#endif

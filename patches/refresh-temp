Bottom: 489ba01dfcf32c202baeebf94f4cc2f8d52ef4a9
Top:    4ee08e3b132ac0409929120840a8633a47568461
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-09-29 18:23:42 +0100

Refresh of hid-gtk-move-viewport-view-dat

---

diff --git a/src/gpcb-menu.res.in b/src/gpcb-menu.res.in
index de533de..187835a 100644
--- a/src/gpcb-menu.res.in
+++ b/src/gpcb-menu.res.in
@@ -168,8 +168,8 @@ MainMenu =
     {"Zoom to 10mil/px" Zoom(=10mil)}
     {"Zoom In 20% and center" Zoom(-1.2) Center() m=Z }
     {"Zoom Out 20% and center" Zoom(+1.2) Center() m=O }
-    {"Flip up/down" checked=flip_y SwapSides(V) a={"Tab" "<Key>Tab"}}
-    {"Flip left/right" checked=flip_x SwapSides(H) a={"Shift-Tab" "Shift<Key>Tab"}}
+    {"Flip up/down" SwapSides(V) a={"Tab" "<Key>Tab"}}
+    {"Flip left/right" SwapSides(H) a={"Shift-Tab" "Shift<Key>Tab"}}
     {"Spin 180 degrees" SwapSides(R) a={"Ctrl-Tab" "Ctrl<Key>Tab"}}
     {"Swap Sides" SwapSides() a={"Ctrl-Shift-Tab" "Ctrl Shift<Key>Tab"}}
     {"Center cursor" Center() a={"C" "<Key>c"}}
diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index 1710000..9501128 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -26,9 +26,30 @@ extern HID ghid_hid;
 */
 #define USE_GC(gc) if (!use_gc(gc)) return
 
+#define SIDE_X(x)   ((priv->view.flip_x ? PCB->MaxWidth  - (x) : (x)))
+#define SIDE_Y(y)   ((priv->view.flip_y ? PCB->MaxHeight - (y) : (y)))
+
+#define DRAW_X(x)         (int)((SIDE_X(x) - priv->view.x0) / priv->view.coord_per_px)
+#define DRAW_Y(y)         (int)((SIDE_Y(y) - priv->view.y0) / priv->view.coord_per_px)
+
+#define EVENT_TO_PCB_X(x) SIDE_X((int)((x) * priv->view.coord_per_px + priv->view.x0))
+#define EVENT_TO_PCB_Y(y) SIDE_Y((int)((y) * priv->view.coord_per_px + priv->view.y0))
+
 static int cur_mask = -1;
 static int mask_seq = 0;
 
+typedef struct view_data {
+  double coord_per_px;
+
+  Coord x0;
+  Coord y0;
+  Coord width;
+  Coord height;
+
+  bool flip_x;
+  bool flip_y;
+} view_data;
+
 typedef struct render_priv {
   GdkGC *bg_gc;
   GdkGC *offlimits_gc;
@@ -39,6 +60,7 @@ typedef struct render_priv {
   GdkRectangle clip_rect;
   int attached_invalidate_depth;
   int mark_invalidate_depth;
+  view_data view;
 
   /* Feature for leading the user to a particular location */
   guint lead_user_timeout;
@@ -64,6 +86,58 @@ typedef struct hid_gc_struct
 }
 hid_gc_struct;
 
+/* Px converts view->pcb, Vx converts pcb->view */
+static inline int
+Vx (Coord x)
+{
+  render_priv *priv = gport->render_priv;
+
+  if (priv->view.flip_x)
+    return (PCB->MaxWidth - x - priv->view.x0) / priv->view.coord_per_px + 0.5;
+  else
+    return (x - priv->view.x0) / priv->view.coord_per_px + 0.5;
+}
+
+static inline int
+Vy (Coord y)
+{
+  render_priv *priv = gport->render_priv;
+
+  if (priv->view.flip_y)
+    return (PCB->MaxHeight - y - priv->view.y0) / priv->view.coord_per_px + 0.5;
+  else
+    return (y - priv->view.y0) / priv->view.coord_per_px + 0.5;
+}
+
+static inline int
+Vz (Coord z)
+{
+  render_priv *priv = gport->render_priv;
+
+  return z / priv->view.coord_per_px + 0.5;
+}
+
+static inline Coord
+Px (int x)
+{
+  render_priv *priv = gport->render_priv;
+
+  Coord rv = x * priv->view.coord_per_px + priv->view.x0;
+  if (priv->view.flip_x)
+    rv = PCB->MaxWidth - (x * priv->view.coord_per_px + priv->view.x0);
+  return  rv;
+}
+
+static inline Coord
+Py (int y)
+{
+  render_priv *priv = gport->render_priv;
+  Coord rv = y * priv->view.coord_per_px + priv->view.y0;
+
+  if (priv->view.flip_y)
+    rv = PCB->MaxHeight - (y * priv->view.coord_per_px + priv->view.y0);
+  return  rv;
+}
 
 static void draw_lead_user (render_priv *priv);
 
@@ -172,11 +246,11 @@ ghid_draw_grid (void)
       gdk_gc_set_clip_origin (priv->grid_gc, 0, 0);
       set_clip (priv, priv->grid_gc);
     }
-  x1 = GridFit (SIDE_X (gport->view.x0), PCB->Grid, PCB->GridOffsetX);
-  y1 = GridFit (SIDE_Y (gport->view.y0), PCB->Grid, PCB->GridOffsetY);
-  x2 = GridFit (SIDE_X (gport->view.x0 + gport->view.width - 1),
+  x1 = GridFit (SIDE_X (priv->view.x0), PCB->Grid, PCB->GridOffsetX);
+  y1 = GridFit (SIDE_Y (priv->view.y0), PCB->Grid, PCB->GridOffsetY);
+  x2 = GridFit (SIDE_X (priv->view.x0 + priv->view.width - 1),
                 PCB->Grid, PCB->GridOffsetX);
-  y2 = GridFit (SIDE_Y (gport->view.y0 + gport->view.height - 1),
+  y2 = GridFit (SIDE_Y (priv->view.y0 + priv->view.height - 1),
                 PCB->Grid, PCB->GridOffsetY);
   if (x1 > x2)
     {
@@ -233,10 +307,10 @@ ghid_draw_bg_image (void)
   if (!ghidgui->bg_pixbuf)
     return;
 
-  w = PCB->MaxWidth / gport->view.coord_per_px;
-  h = PCB->MaxHeight / gport->view.coord_per_px;
-  x = gport->view.x0 / gport->view.coord_per_px;
-  y = gport->view.y0 / gport->view.coord_per_px;
+  w = PCB->MaxWidth / priv->view.coord_per_px;
+  h = PCB->MaxHeight / priv->view.coord_per_px;
+  x = priv->view.x0 / priv->view.coord_per_px;
+  y = priv->view.y0 / priv->view.coord_per_px;
 
   if (w_scaled != w || h_scaled != h)
     {
@@ -530,7 +604,7 @@ ghid_draw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
   dy2 = Vy ((double) y2);
 
   if (!ClipLine (0, 0, gport->width, gport->height,
-		 &dx1, &dy1, &dx2, &dy2, gc->width / gport->view.coord_per_px))
+		 &dx1, &dy1, &dx2, &dy2, gc->width / priv->view.coord_per_px))
     return;
 
   USE_GC (gc);
@@ -545,25 +619,25 @@ ghid_draw_arc (hidGC gc, Coord cx, Coord cy,
   gint w, h, radius;
   render_priv *priv = gport->render_priv;
 
-  w = gport->width * gport->view.coord_per_px;
-  h = gport->height * gport->view.coord_per_px;
+  w = gport->width * priv->view.coord_per_px;
+  h = gport->height * priv->view.coord_per_px;
   radius = (xradius > yradius) ? xradius : yradius;
-  if (SIDE_X (cx) < gport->view.x0 - radius
-      || SIDE_X (cx) > gport->view.x0 + w + radius
-      || SIDE_Y (cy) < gport->view.y0 - radius
-      || SIDE_Y (cy) > gport->view.y0 + h + radius)
+  if (SIDE_X (cx) < priv->view.x0 - radius
+      || SIDE_X (cx) > priv->view.x0 + w + radius
+      || SIDE_Y (cy) < priv->view.y0 - radius
+      || SIDE_Y (cy) > priv->view.y0 + h + radius)
     return;
 
   USE_GC (gc);
   vrx = Vz (xradius);
   vry = Vz (yradius);
 
-  if (gport->view.flip_x)
+  if (priv->view.flip_x)
     {
       start_angle = 180 - start_angle;
       delta_angle = -delta_angle;
     }
-  if (gport->view.flip_y)
+  if (priv->view.flip_y)
     {
       start_angle = -start_angle;
       delta_angle = -delta_angle;
@@ -584,17 +658,17 @@ ghid_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
   render_priv *priv = gport->render_priv;
 
   lw = gc->width;
-  w = gport->width * gport->view.coord_per_px;
-  h = gport->height * gport->view.coord_per_px;
-
-  if ((SIDE_X (x1) < gport->view.x0 - lw
-       && SIDE_X (x2) < gport->view.x0 - lw)
-      || (SIDE_X (x1) > gport->view.x0 + w + lw
-	  && SIDE_X (x2) > gport->view.x0 + w + lw)
-      || (SIDE_Y (y1) < gport->view.y0 - lw
-	  && SIDE_Y (y2) < gport->view.y0 - lw)
-      || (SIDE_Y (y1) > gport->view.y0 + h + lw
-	  && SIDE_Y (y2) > gport->view.y0 + h + lw))
+  w = gport->width * priv->view.coord_per_px;
+  h = gport->height * priv->view.coord_per_px;
+
+  if ((SIDE_X (x1) < priv->view.x0 - lw
+       && SIDE_X (x2) < priv->view.x0 - lw)
+      || (SIDE_X (x1) > priv->view.x0 + w + lw
+	  && SIDE_X (x2) > priv->view.x0 + w + lw)
+      || (SIDE_Y (y1) < priv->view.y0 - lw
+	  && SIDE_Y (y2) < priv->view.y0 - lw)
+      || (SIDE_Y (y1) > priv->view.y0 + h + lw
+	  && SIDE_Y (y2) > priv->view.y0 + h + lw))
     return;
 
   x1 = Vx (x1);
@@ -627,12 +701,12 @@ ghid_fill_circle (hidGC gc, Coord cx, Coord cy, Coord radius)
   gint w, h, vr;
   render_priv *priv = gport->render_priv;
 
-  w = gport->width * gport->view.coord_per_px;
-  h = gport->height * gport->view.coord_per_px;
-  if (SIDE_X (cx) < gport->view.x0 - radius
-      || SIDE_X (cx) > gport->view.x0 + w + radius
-      || SIDE_Y (cy) < gport->view.y0 - radius
-      || SIDE_Y (cy) > gport->view.y0 + h + radius)
+  w = gport->width * priv->view.coord_per_px;
+  h = gport->height * priv->view.coord_per_px;
+  if (SIDE_X (cx) < priv->view.x0 - radius
+      || SIDE_X (cx) > priv->view.x0 + w + radius
+      || SIDE_Y (cy) < priv->view.y0 - radius
+      || SIDE_Y (cy) > priv->view.y0 + h + radius)
     return;
 
   USE_GC (gc);
@@ -670,17 +744,17 @@ ghid_fill_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
   render_priv *priv = gport->render_priv;
 
   lw = gc->width;
-  w = gport->width * gport->view.coord_per_px;
-  h = gport->height * gport->view.coord_per_px;
-
-  if ((SIDE_X (x1) < gport->view.x0 - lw
-       && SIDE_X (x2) < gport->view.x0 - lw)
-      || (SIDE_X (x1) > gport->view.x0 + w + lw
-	  && SIDE_X (x2) > gport->view.x0 + w + lw)
-      || (SIDE_Y (y1) < gport->view.y0 - lw
-	  && SIDE_Y (y2) < gport->view.y0 - lw)
-      || (SIDE_Y (y1) > gport->view.y0 + h + lw
-	  && SIDE_Y (y2) > gport->view.y0 + h + lw))
+  w = gport->width * priv->view.coord_per_px;
+  h = gport->height * priv->view.coord_per_px;
+
+  if ((SIDE_X (x1) < priv->view.x0 - lw
+       && SIDE_X (x2) < priv->view.x0 - lw)
+      || (SIDE_X (x1) > priv->view.x0 + w + lw
+	  && SIDE_X (x2) > priv->view.x0 + w + lw)
+      || (SIDE_Y (y1) < priv->view.y0 - lw
+	  && SIDE_Y (y2) < priv->view.y0 - lw)
+      || (SIDE_Y (y1) > priv->view.y0 + h + lw
+	  && SIDE_Y (y2) > priv->view.y0 + h + lw))
     return;
 
   x1 = Vx (x1);
@@ -1127,32 +1201,29 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   GdkDrawable *save_drawable;
   GtkAllocation allocation;
   view_data save_view;
-  int save_width, save_height;
   double xz, yz;
   render_priv *priv = gport->render_priv;
 
   /* Setup drawable and zoom factor for drawing routines
    */
   save_drawable = gport->drawable;
-  save_view = gport->view;
-  save_width = gport->width;
-  save_height = gport->height;
+  save_view = priv->view;
 
   gtk_widget_get_allocation (widget, &allocation);
   xz = (double) pinout->x_max / allocation.width;
   yz = (double) pinout->y_max / allocation.height;
   if (xz > yz)
-    gport->view.coord_per_px = xz;
+    priv->view.coord_per_px = xz;
   else
-    gport->view.coord_per_px = yz;
+    priv->view.coord_per_px = yz;
 
-  gport->drawable = window;
+  gport->drawable = widget->window;
   gport->width = allocation.width;
   gport->height = allocation.height;
-  gport->view.width = allocation.width * gport->view.coord_per_px;
-  gport->view.height = allocation.height * gport->view.coord_per_px;
-  gport->view.x0 = (pinout->x_max - gport->view.width) / 2;
-  gport->view.y0 = (pinout->y_max - gport->view.height) / 2;
+  priv->view.width = allocation.width * priv->view.coord_per_px;
+  priv->view.height = allocation.height * priv->view.coord_per_px;
+  priv->view.x0 = (pinout->x_max - priv->view.width) / 2;
+  priv->view.y0 = (pinout->y_max - priv->view.height) / 2;
 
   /* clear background */
   gdk_draw_rectangle (window, priv->bg_gc, TRUE,
@@ -1162,9 +1233,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   hid_expose_callback (&ghid_hid, NULL, &pinout->element);
 
   gport->drawable = save_drawable;
-  gport->view = save_view;
-  gport->width = save_width;
-  gport->height = save_height;
+  priv->view = save_view;
 
   return FALSE;
 }
@@ -1175,14 +1244,11 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   GdkPixmap *pixmap;
   GdkDrawable *save_drawable;
   view_data save_view;
-  int save_width, save_height;
   BoxType region;
   render_priv *priv = gport->render_priv;
 
   save_drawable = gport->drawable;
-  save_view = gport->view;
-  save_width = gport->width;
-  save_height = gport->height;
+  save_view = priv->view;
 
   pixmap = gdk_pixmap_new (NULL, width, height, depth);
 
@@ -1190,15 +1256,15 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
    */
 
   gport->drawable = pixmap;
-  gport->view.coord_per_px = zoom;
+  priv->view.coord_per_px = zoom;
   gport->width = width;
   gport->height = height;
-  gport->view.width = width * gport->view.coord_per_px;
-  gport->view.height = height * gport->view.coord_per_px;
-  gport->view.x0 = gport->view.flip_x ? PCB->MaxWidth - cx : cx;
-  gport->view.x0 -= gport->view.height / 2;
-  gport->view.y0 = gport->view.flip_y ? PCB->MaxHeight - cy : cy;
-  gport->view.y0 -= gport->view.width  / 2;
+  priv->view.width = width * priv->view.coord_per_px;
+  priv->view.height = height * priv->view.coord_per_px;
+  priv->view.x0 = priv->view.flip_x ? PCB->MaxWidth - cx : cx;
+  priv->view.x0 -= priv->view.height / 2;
+  priv->view.y0 = priv->view.flip_y ? PCB->MaxHeight - cy : cy;
+  priv->view.y0 -= priv->view.width  / 2;
 
   /* clear background */
   gdk_draw_rectangle (pixmap, priv->bg_gc, TRUE, 0, 0, width, height);
@@ -1217,9 +1283,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   hid_expose_callback (&ghid_hid, &region, NULL);
 
   gport->drawable = save_drawable;
-  gport->view = save_view;
-  gport->width = save_width;
-  gport->height = save_height;
+  priv->view = save_view;
 
   return pixmap;
 }
@@ -1250,6 +1314,8 @@ ghid_finish_debug_draw (void)
 bool
 ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y)
 {
+  render_priv *priv = gport->render_priv;
+
   *pcb_x = EVENT_TO_PCB_X (event_x);
   *pcb_y = EVENT_TO_PCB_Y (event_y);
 
@@ -1259,6 +1325,8 @@ ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y)
 bool
 ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y)
 {
+  render_priv *priv = gport->render_priv;
+
   *event_x = DRAW_X (pcb_x);
   *event_y = DRAW_Y (pcb_y);
 
@@ -1268,6 +1336,7 @@ ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y)
 static void
 pan_common (GHidPort *port)
 {
+  render_priv *priv = gport->render_priv;
   int event_x, event_y;
 
   /* We need to fix up the PCB coordinates corresponding to the last
@@ -1275,10 +1344,10 @@ pan_common (GHidPort *port)
   ghid_pcb_to_event_coords (gport->pcb_x, gport->pcb_y, &event_x, &event_y);
 
   /* Don't pan so far the board is completely off the screen */
-  port->view.x0 = MAX (-port->view.width,  port->view.x0);
-  port->view.y0 = MAX (-port->view.height, port->view.y0);
-  port->view.x0 = MIN ( port->view.x0, PCB->MaxWidth);
-  port->view.y0 = MIN ( port->view.y0, PCB->MaxHeight);
+  priv->view.x0 = MAX (-priv->view.width,  priv->view.x0);
+  priv->view.y0 = MAX (-priv->view.height, priv->view.y0);
+  priv->view.x0 = MIN ( priv->view.x0, PCB->MaxWidth);
+  priv->view.y0 = MIN ( priv->view.y0, PCB->MaxHeight);
 
   /* Fix up noted event coordinates to match where we clamped. Alternatively
    * we could call ghid_note_event_location (NULL); to get a new pointer
@@ -1287,8 +1356,8 @@ pan_common (GHidPort *port)
   ghid_event_to_pcb_coords (event_x, event_y, &gport->pcb_x, &gport->pcb_y);
 
   ghidgui->adjustment_changed_holdoff = TRUE;
-  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view.x0);
-  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view.y0);
+  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), priv->view.x0);
+  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), priv->view.y0);
   ghidgui->adjustment_changed_holdoff = FALSE;
 
   ghid_port_ranges_changed();
@@ -1297,8 +1366,10 @@ pan_common (GHidPort *port)
 void
 ghid_pan_view_abs (Coord pcb_x, Coord pcb_y, int widget_x, int widget_y)
 {
-  gport->view.x0 = SIDE_X (pcb_x) - widget_x * gport->view.coord_per_px;
-  gport->view.y0 = SIDE_Y (pcb_y) - widget_y * gport->view.coord_per_px;
+  render_priv *priv = gport->render_priv;
+
+  priv->view.x0 = SIDE_X (pcb_x) - widget_x * priv->view.coord_per_px;
+  priv->view.y0 = SIDE_Y (pcb_y) - widget_y * priv->view.coord_per_px;
 
   pan_common (gport);
 }
@@ -1306,24 +1377,27 @@ ghid_pan_view_abs (Coord pcb_x, Coord pcb_y, int widget_x, int widget_y)
 void
 ghid_pan_view_rel (Coord dx, Coord dy)
 {
-  gport->view.x0 += dx;
-  gport->view.y0 += dy;
+  render_priv *priv = gport->render_priv;
+
+  priv->view.x0 += dx;
+  priv->view.y0 += dy;
 
   pan_common (gport);
 }
 
 
-/* gport->view.coord_per_px:
+/* priv->view.coord_per_px:
  * zoom value is PCB units per screen pixel.  Larger numbers mean zooming
  * out - the largest value means you are looking at the whole board.
  *
- * gport->view_width and gport->view_height are in PCB coordinates
+ * priv->view_width and priv->view_height are in PCB coordinates
  */
 
 #define ALLOW_ZOOM_OUT_BY 10 /* Arbitrary, and same as the lesstif HID */
 void
 ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
 {
+  render_priv *priv = gport->render_priv;
   double min_zoom, max_zoom;
   double xtmp, ytmp;
 
@@ -1336,18 +1410,18 @@ ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
                   PCB->MaxHeight / gport->height) * ALLOW_ZOOM_OUT_BY;
   new_zoom = MIN (MAX (min_zoom, new_zoom), max_zoom);
 
-  if (gport->view.coord_per_px == new_zoom)
+  if (priv->view.coord_per_px == new_zoom)
     return;
 
-  xtmp = (SIDE_X (center_x) - gport->view.x0) / (double)gport->view.width;
-  ytmp = (SIDE_Y (center_y) - gport->view.y0) / (double)gport->view.height;
+  xtmp = (SIDE_X (center_x) - priv->view.x0) / (double)priv->view.width;
+  ytmp = (SIDE_Y (center_y) - priv->view.y0) / (double)priv->view.height;
 
-  gport->view.coord_per_px = new_zoom;
+  priv->view.coord_per_px = new_zoom;
   pixel_slop = new_zoom;
   ghid_port_ranges_scale ();
 
-  gport->view.x0 = SIDE_X (center_x) - xtmp * gport->view.width;
-  gport->view.y0 = SIDE_Y (center_y) - ytmp * gport->view.height;
+  priv->view.x0 = SIDE_X (center_x) - xtmp * priv->view.width;
+  priv->view.y0 = SIDE_Y (center_y) - ytmp * priv->view.height;
 
   pan_common (gport);
 
@@ -1357,7 +1431,9 @@ ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
 void
 ghid_zoom_view_rel (Coord center_x, Coord center_y, double factor)
 {
-  ghid_zoom_view_abs (center_x, center_y, gport->view.coord_per_px * factor);
+  render_priv *priv = gport->render_priv;
+
+  ghid_zoom_view_abs (center_x, center_y, priv->view.coord_per_px * factor);
 }
 
 void
@@ -1372,13 +1448,14 @@ ghid_zoom_view_fit (void)
 void
 ghid_flip_view (Coord center_x, Coord center_y, bool flip_x, bool flip_y)
 {
+  render_priv *priv = gport->render_priv;
   int widget_x, widget_y;
 
   /* Work out where on the screen the flip point is */
   ghid_pcb_to_event_coords (center_x, center_y, &widget_x, &widget_y);
 
-  gport->view.flip_x = gport->view.flip_x != flip_x;
-  gport->view.flip_y = gport->view.flip_y != flip_y;
+  priv->view.flip_x = priv->view.flip_x != flip_x;
+  priv->view.flip_y = priv->view.flip_y != flip_y;
 
   /* Pan the board so the center location remains in the same place */
   ghid_pan_view_abs (center_x, center_y, widget_x, widget_y);
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index e192725..e3b6ab5 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -44,8 +44,36 @@ static hidGC current_gc = NULL;
 */
 #define USE_GC(gc) if (!use_gc(gc)) return
 
+#define FLIP_X(x)         ((priv->view.flip_x ? -(x) : (x)))
+#define FLIP_Y(y)         ((priv->view.flip_y ? -(y) : (y)))
+
+#define SIDE_X(x)         ((priv->view.flip_x ? PCB->MaxWidth  - (x) : (x)))
+#define SIDE_Y(y)         ((priv->view.flip_y ? PCB->MaxHeight - (y) : (y)))
+
+#define DRAW_X(x)         (int)((SIDE_X(x) - priv->view.x0) / priv->view.coord_per_px)
+#define DRAW_Y(y)         (int)((SIDE_Y(y) - priv->view.y0) / priv->view.coord_per_px)
+
+#define EVENT_TO_PCB_X(x) SIDE_X((int)((x) * priv->view.coord_per_px + priv->view.x0))
+#define EVENT_TO_PCB_Y(y) SIDE_Y((int)((y) * priv->view.coord_per_px + priv->view.y0))
+
+
 static int cur_mask = -1;
 
+typedef struct view_data {
+  double coord_per_px;
+  Coord center_x;
+  Coord center_y;
+
+  Coord x0; /* XXX */
+  Coord y0; /* XXX */
+  Coord width;  /* XXX */
+  Coord height; /* XXX */
+
+  bool flip_x;
+  bool flip_y;
+  /* TODO: Rotation matrix ? */
+} view_data;
+
 typedef struct render_priv {
   GdkGLConfig *glconfig;
   bool trans_lines;
@@ -54,6 +82,8 @@ typedef struct render_priv {
   char *current_colorname;
   double current_alpha_mult;
 
+  view_data view;
+
   /* Feature for leading the user to a particular location */
   guint lead_user_timeout;
   GTimer *lead_user_timer;
@@ -80,6 +110,36 @@ hid_gc_struct;
 
 static void draw_lead_user (render_priv *priv);
 
+/* Px converts view->pcb, Vx converts pcb->view */
+static inline int
+Vz (Coord z)
+{
+  render_priv *priv = gport->render_priv;
+
+  return z / priv->view.coord_per_px + 0.5;
+}
+
+static inline Coord
+Px (int x)
+{
+  render_priv *priv = gport->render_priv;
+  Coord rv = x * priv->view.coord_per_px + priv->view.x0;
+
+  if (priv->view.flip_x)
+    rv = PCB->MaxWidth - (x * priv->view.coord_per_px + priv->view.x0);
+  return  rv;
+}
+
+static inline Coord
+Py (int y)
+{
+  render_priv *priv = gport->render_priv;
+  Coord rv = y * priv->view.coord_per_px + priv->view.y0;
+
+  if (priv->view.flip_y)
+    rv = PCB->MaxHeight - (y * priv->view.coord_per_px + priv->view.y0);
+  return  rv;
+}
 
 static void
 start_subcomposite (void)
@@ -542,19 +602,21 @@ use_gc (hidGC gc)
 void
 ghid_draw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
+  render_priv *priv = gport->render_priv;
   USE_GC (gc);
 
-  hidgl_draw_line (gc->cap, gc->width, x1, y1, x2, y2, gport->view.coord_per_px);
+  hidgl_draw_line (gc->cap, gc->width, x1, y1, x2, y2, priv->view.coord_per_px);
 }
 
 void
 ghid_draw_arc (hidGC gc, Coord cx, Coord cy, Coord xradius, Coord yradius,
                          Angle start_angle, Angle delta_angle)
 {
+  render_priv *priv = gport->render_priv;
   USE_GC (gc);
 
   hidgl_draw_arc (gc->width, cx, cy, xradius, yradius,
-                  start_angle, delta_angle, gport->view.coord_per_px);
+                  start_angle, delta_angle, priv->view.coord_per_px);
 }
 
 void
@@ -569,9 +631,10 @@ ghid_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 void
 ghid_fill_circle (hidGC gc, Coord cx, Coord cy, Coord radius)
 {
+  render_priv *priv = gport->render_priv;
   USE_GC (gc);
 
-  hidgl_fill_circle (cx, cy, radius, gport->view.coord_per_px);
+  hidgl_fill_circle (cx, cy, radius, priv->view.coord_per_px);
 }
 
 
@@ -762,6 +825,7 @@ draw_dozen_cross (gint x, gint y, gint z)
 static void
 draw_crosshair (render_priv *priv)
 {
+  render_priv *priv = gport->render_priv;
   gint x, y, z;
   static int done_once = 0;
   static GdkColor cross_color;
@@ -844,6 +908,11 @@ ghid_init_drawing_widget (GtkWidget *widget, GHidPort *port)
 void
 ghid_drawing_area_configure_hook (GHidPort *port)
 {
+  render_priv *priv = port->render_priv;
+  GtkWidget *widget = port->drawing_area;
+
+  priv->view.width =  widget->allocation.width  * priv->view.coord_per_px;
+  priv->view.height = widget->allocation.height * priv->view.coord_per_px;
 }
 
 gboolean
@@ -923,13 +992,13 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glLoadIdentity ();
   glTranslatef (0.0f, 0.0f, -Z_NEAR);
 
-  glScalef ((port->view.flip_x ? -1. : 1.) / port->view.coord_per_px,
-            (port->view.flip_y ? -1. : 1.) / port->view.coord_per_px,
-            ((port->view.flip_x == port->view.flip_y) ? 1. : -1.) / port->view.coord_per_px);
-  glTranslatef (port->view.flip_x ? port->view.x0 - PCB->MaxWidth  :
-                             -port->view.x0,
-                port->view.flip_y ? port->view.y0 - PCB->MaxHeight :
-                             -port->view.y0, 0);
+  glScalef ((priv->view.flip_x ? -1. : 1.) / priv->view.coord_per_px,
+            (priv->view.flip_y ? -1. : 1.) / priv->view.coord_per_px,
+            ((priv->view.flip_x == priv->view.flip_y) ? 1. : -1.) / priv->view.coord_per_px);
+  glTranslatef (priv->view.flip_x ? priv->view.x0 - PCB->MaxWidth  :
+                             -priv->view.x0,
+                priv->view.flip_y ? priv->view.y0 - PCB->MaxHeight :
+                             -priv->view.y0, 0);
 
   glEnable (GL_STENCIL_TEST);
   glClearColor (port->offlimits_color.red / 65535.,
@@ -1014,17 +1083,15 @@ gboolean
 ghid_pinout_preview_expose (GtkWidget *widget,
                             GdkEventExpose *ev)
 {
+  render_priv *priv = gport->render_priv;
   GdkGLContext* pGlContext = gtk_widget_get_gl_context (widget);
   GdkGLDrawable* pGlDrawable = gtk_widget_get_gl_drawable (widget);
   GhidPinoutPreview *pinout = GHID_PINOUT_PREVIEW (widget);
   GtkAllocation allocation;
   view_data save_view;
-  int save_width, save_height;
   double xz, yz;
 
-  save_view = gport->view;
-  save_width = gport->width;
-  save_height = gport->height;
+  save_view = priv->view;
 
   /* Setup zoom factor for drawing routines */
 
@@ -1032,16 +1099,14 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   xz = (double) pinout->x_max / allocation.width;
   yz = (double) pinout->y_max / allocation.height;
   if (xz > yz)
-    gport->view.coord_per_px = xz;
+    priv->view.coord_per_px = xz;
   else
-    gport->view.coord_per_px = yz;
+    priv->view.coord_per_px = yz;
 
-  gport->width = allocation.width;
-  gport->height = allocation.height;
-  gport->view.width = allocation.width * gport->view.coord_per_px;
-  gport->view.height = allocation.height * gport->view.coord_per_px;
-  gport->view.x0 = (pinout->x_max - gport->view.width) / 2;
-  gport->view.y0 = (pinout->y_max - gport->view.height) / 2;
+  priv->view.width = allocation.width  * priv->view.coord_per_px;
+  priv->view.height = allocation.height * priv->view.coord_per_px;
+  priv->view.x0 = (pinout->x_max - priv->view.width) / 2;
+  priv->view.y0 = (pinout->y_max - priv->view.height) / 2;
 
   /* make GL-context "current" */
   if (!gdk_gl_drawable_gl_begin (pGlDrawable, pGlContext)) {
@@ -1080,14 +1145,13 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
   glPushMatrix ();
-  glScalef ((gport->view.flip_x ? -1. : 1.) / gport->view.coord_per_px,
-            (gport->view.flip_y ? -1. : 1.) / gport->view.coord_per_px,
-            ((gport->view.flip_x == gport->view.flip_y) ? 1. : -1.) / gport->view.coord_per_px);
-  glTranslatef (gport->view.flip_x ? gport->view.x0 - PCB->MaxWidth  :
-                                    -gport->view.x0,
-                gport->view.flip_y ? gport->view.y0 - PCB->MaxHeight :
-                                    -gport->view.y0, 0);
-
+  glScalef ((priv->view.flip_x ? -1. : 1.) / priv->view.coord_per_px,
+            (priv->view.flip_y ? -1. : 1.) / priv->view.coord_per_px,
+            ((priv->view.flip_x == priv->view.flip_y) ? 1. : -1.) / priv->view.coord_per_px);
+  glTranslatef (priv->view.flip_x ? priv->view.x0 - PCB->MaxWidth  :
+                                   -priv->view.x0,
+                priv->view.flip_y ? priv->view.y0 - PCB->MaxHeight :
+                                   -priv->view.y0, 0);
   hid_expose_callback (&ghid_hid, NULL, &pinout->element);
   hidgl_flush_triangles (&buffer);
   glPopMatrix ();
@@ -1101,9 +1165,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   gport->render_priv->in_context = false;
   gdk_gl_drawable_gl_end (pGlDrawable);
 
-  gport->view = save_view;
-  gport->width = save_width;
-  gport->height = save_height;
+  priv->view = save_view;
 
   return FALSE;
 }
@@ -1112,18 +1174,16 @@ ghid_pinout_preview_expose (GtkWidget *widget,
 GdkPixmap *
 ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int depth)
 {
+  render_priv *priv = gport->render_priv;
   GdkGLConfig *glconfig;
   GdkPixmap *pixmap;
   GdkGLPixmap *glpixmap;
   GdkGLContext* glcontext;
   GdkGLDrawable* gldrawable;
   view_data save_view;
-  int save_width, save_height;
   BoxType region;
 
-  save_view = gport->view;
-  save_width = gport->width;
-  save_height = gport->height;
+  save_view = priv->view;
 
   /* Setup rendering context for drawing routines
    */
@@ -1139,15 +1199,13 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
 
   /* Setup zoom factor for drawing routines */
 
-  gport->view.coord_per_px = zoom;
-  gport->width = width;
-  gport->height = height;
-  gport->view.width = width * gport->view.coord_per_px;
-  gport->view.height = height * gport->view.coord_per_px;
-  gport->view.x0 = gport->view.flip_x ? PCB->MaxWidth - cx : cx;
-  gport->view.x0 -= gport->view.height / 2;
-  gport->view.y0 = gport->view.flip_y ? PCB->MaxHeight - cy : cy;
-  gport->view.y0 -= gport->view.width / 2;
+  priv->view.coord_per_px = zoom;
+  priv->view.width = width   * priv->view.coord_per_px;
+  priv->view.height = height * priv->view.coord_per_px;
+  priv->view.x0 = priv->view.flip_x ? PCB->MaxWidth - cx : cx;
+  priv->view.x0 -= priv->view.height / 2;
+  priv->view.y0 = priv->view.flip_y ? PCB->MaxHeight - cy : cy;
+  priv->view.y0 -= priv->view.width  / 2;
 
   /* make GL-context "current" */
   if (!gdk_gl_drawable_gl_begin (gldrawable, glcontext)) {
@@ -1183,18 +1241,18 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
   glPushMatrix ();
-  glScalef ((gport->view.flip_x ? -1. : 1.) / gport->view.coord_per_px,
-            (gport->view.flip_y ? -1. : 1.) / gport->view.coord_per_px,
-            ((gport->view.flip_x == gport->view.flip_y) ? 1. : -1.) / gport->view.coord_per_px);
-  glTranslatef (gport->view.flip_x ? gport->view.x0 - PCB->MaxWidth  :
-                                    -gport->view.x0,
-                gport->view.flip_y ? gport->view.y0 - PCB->MaxHeight :
-                                    -gport->view.y0, 0);
-
-  region.X1 = MIN(Px(0), Px(gport->width + 1));
-  region.Y1 = MIN(Py(0), Py(gport->height + 1));
-  region.X2 = MAX(Px(0), Px(gport->width + 1));
-  region.Y2 = MAX(Py(0), Py(gport->height + 1));
+  glScalef ((priv->view.flip_x ? -1. : 1.) / priv->view.coord_per_px,
+            (priv->view.flip_y ? -1. : 1.) / priv->view.coord_per_px,
+            ((priv->view.flip_x == priv->view.flip_y) ? 1. : -1.) / priv->view.coord_per_px);
+  glTranslatef (priv->view.flip_x ? priv->view.x0 - PCB->MaxWidth  :
+                                   -priv->view.x0,
+                priv->view.flip_y ? priv->view.y0 - PCB->MaxHeight :
+                                   -priv->view.y0, 0);
+
+  region.X1 = MIN (Px(0), Px(width + 1));
+  region.Y1 = MIN (Py(0), Py(height + 1));
+  region.X2 = MAX (Px(0), Px(width + 1));
+  region.Y2 = MAX (Py(0), Py(height + 1));
 
   region.X1 = MAX (0, MIN (PCB->MaxWidth,  region.X1));
   region.X2 = MAX (0, MIN (PCB->MaxWidth,  region.X2));
@@ -1216,9 +1274,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   g_object_unref (glconfig);
   g_object_unref (glcontext);
 
-  gport->view = save_view;
-  gport->width = save_width;
-  gport->height = save_height;
+  priv->view = save_view;
 
   return pixmap;
 }
@@ -1227,6 +1283,7 @@ HID *
 ghid_request_debug_draw (void)
 {
   GHidPort *port = gport;
+  render_priv *priv = port->render_priv;
   GtkWidget *widget = port->drawing_area;
   GtkAllocation allocation;
 
@@ -1250,13 +1307,13 @@ ghid_request_debug_draw (void)
   glDisable (GL_STENCIL_TEST);
 
   glPushMatrix ();
-  glScalef ((port->view.flip_x ? -1. : 1.) / port->view.coord_per_px,
-            (port->view.flip_y ? -1. : 1.) / port->view.coord_per_px,
-            ((gport->view.flip_x == port->view.flip_y) ? 1. : -1.) / gport->view.coord_per_px);
-  glTranslatef (port->view.flip_x ? port->view.x0 - PCB->MaxWidth  :
-                             -port->view.x0,
-                port->view.flip_y ? port->view.y0 - PCB->MaxHeight :
-                             -port->view.y0, 0);
+  glScalef ((priv->view.flip_x ? -1. : 1.) / priv->view.coord_per_px,
+            (priv->view.flip_y ? -1. : 1.) / priv->view.coord_per_px,
+            ((priv->view.flip_x == priv->view.flip_y) ? 1. : -1.) / priv->view.coord_per_px);
+  glTranslatef (priv->view.flip_x ? priv->view.x0 - PCB->MaxWidth  :
+                             -priv->view.x0,
+                priv->view.flip_y ? priv->view.y0 - PCB->MaxHeight :
+                             -priv->view.y0, 0);
 
   return &ghid_hid;
 }
@@ -1287,6 +1344,8 @@ ghid_finish_debug_draw (void)
 bool
 ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y)
 {
+  render_priv *priv = gport->render_priv;
+
   *pcb_x = EVENT_TO_PCB_X (event_x);
   *pcb_y = EVENT_TO_PCB_Y (event_y);
 
@@ -1296,6 +1355,8 @@ ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y)
 bool
 ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y)
 {
+  render_priv *priv = gport->render_priv;
+
   *event_x = DRAW_X (pcb_x);
   *event_y = DRAW_Y (pcb_y);
 
@@ -1303,7 +1364,7 @@ ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y)
 }
 
 static void
-pan_common (GHidPort *port)
+pan_common (render_priv *priv)
 {
   int event_x, event_y;
 
@@ -1312,10 +1373,10 @@ pan_common (GHidPort *port)
   ghid_pcb_to_event_coords (gport->pcb_x, gport->pcb_y, &event_x, &event_y);
 
   /* Don't pan so far the board is completely off the screen */
-  port->view.x0 = MAX (-port->view.width,  port->view.x0);
-  port->view.y0 = MAX (-port->view.height, port->view.y0);
-  port->view.x0 = MIN ( port->view.x0, PCB->MaxWidth);
-  port->view.y0 = MIN ( port->view.y0, PCB->MaxHeight);
+  priv->view.x0 = MAX (-priv->view.width,  priv->view.x0);
+  priv->view.y0 = MAX (-priv->view.height, priv->view.y0);
+  priv->view.x0 = MIN ( priv->view.x0, PCB->MaxWidth);
+  priv->view.y0 = MIN ( priv->view.y0, PCB->MaxHeight);
 
   /* Fix up noted event coordinates to match where we clamped. Alternatively
    * we could call ghid_note_event_location (NULL); to get a new pointer
@@ -1324,8 +1385,8 @@ pan_common (GHidPort *port)
   ghid_event_to_pcb_coords (event_x, event_y, &gport->pcb_x, &gport->pcb_y);
 
   ghidgui->adjustment_changed_holdoff = TRUE;
-  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view.x0);
-  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view.y0);
+  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), priv->view.x0);
+  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), priv->view.y0);
   ghidgui->adjustment_changed_holdoff = FALSE;
 
   ghid_port_ranges_changed();
@@ -1334,33 +1395,49 @@ pan_common (GHidPort *port)
 void
 ghid_pan_view_abs (Coord pcb_x, Coord pcb_y, int widget_x, int widget_y)
 {
-  gport->view.x0 = SIDE_X (pcb_x) - widget_x * gport->view.coord_per_px;
-  gport->view.y0 = SIDE_Y (pcb_y) - widget_y * gport->view.coord_per_px;
+  render_priv *priv = gport->render_priv;
+
+  priv->view.x0 = SIDE_X (pcb_x) - widget_x * priv->view.coord_per_px;
+  priv->view.y0 = SIDE_Y (pcb_y) - widget_y * priv->view.coord_per_px;
 
-  pan_common (gport);
+  pan_common (priv);
 }
 
 void
 ghid_pan_view_rel (Coord dx, Coord dy)
 {
-  gport->view.x0 += dx;
-  gport->view.y0 += dy;
+  render_priv *priv = gport->render_priv;
+
+  priv->view.x0 += dx;
+  priv->view.y0 += dy;
 
-  pan_common (gport);
+  pan_common (priv);
 }
 
+void
+ghid_pan_view_rel_to_visible (double fraction_x, double fraction_y)
+{
+  render_priv *priv = gport->render_priv;
+
+  priv->view.x0 = MAX (0, priv->view.x0 + FLIP_X (priv->view.width)  * fraction_x);
+  priv->view.y0 = MAX (0, priv->view.y0 + FLIP_Y (priv->view.height) * fraction_y);
 
-/* gport->view.coord_per_px:
+  pan_common (priv);
+}
+
+
+/* priv->view.coord_per_px:
  * zoom value is PCB units per screen pixel.  Larger numbers mean zooming
  * out - the largest value means you are looking at the whole board.
  *
- * gport->view_width and gport->view_height are in PCB coordinates
+ * priv->view.width and priv->view.height are in PCB coordinates
  */
 
 #define ALLOW_ZOOM_OUT_BY 10 /* Arbitrary, and same as the lesstif HID */
 void
 ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
 {
+  render_priv *priv = gport->render_priv;
   double min_zoom, max_zoom;
   double xtmp, ytmp;
 
@@ -1369,24 +1446,24 @@ ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
    * the entire board just fits inside the viewport
    */
   min_zoom = 1;
-  max_zoom = MAX (PCB->MaxWidth  / gport->width,
-                  PCB->MaxHeight / gport->height) * ALLOW_ZOOM_OUT_BY;
+  max_zoom = MAX (PCB->MaxWidth  / gport->drawing_area->allocation.width,
+                  PCB->MaxHeight / gport->drawing_area->allocation.height) * ALLOW_ZOOM_OUT_BY;
   new_zoom = MIN (MAX (min_zoom, new_zoom), max_zoom);
 
-  if (gport->view.coord_per_px == new_zoom)
+  if (priv->view.coord_per_px == new_zoom)
     return;
 
-  xtmp = (SIDE_X (center_x) - gport->view.x0) / (double)gport->view.width;
-  ytmp = (SIDE_Y (center_y) - gport->view.y0) / (double)gport->view.height;
+  xtmp = (SIDE_X (center_x) - priv->view.x0) / (double)priv->view.width;
+  ytmp = (SIDE_Y (center_y) - priv->view.y0) / (double)priv->view.height;
 
-  gport->view.coord_per_px = new_zoom;
+  priv->view.coord_per_px = new_zoom;
   pixel_slop = new_zoom;
   ghid_port_ranges_scale ();
 
-  gport->view.x0 = SIDE_X (center_x) - xtmp * gport->view.width;
-  gport->view.y0 = SIDE_Y (center_y) - ytmp * gport->view.height;
+  priv->view.x0 = SIDE_X (center_x) - xtmp * priv->view.width;
+  priv->view.y0 = SIDE_Y (center_y) - ytmp * priv->view.height;
 
-  pan_common (gport);
+  pan_common (priv);
 
   ghid_set_status_line_label ();
 }
@@ -1394,7 +1471,9 @@ ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
 void
 ghid_zoom_view_rel (Coord center_x, Coord center_y, double factor)
 {
-  ghid_zoom_view_abs (center_x, center_y, gport->view.coord_per_px * factor);
+  render_priv *priv = gport->render_priv;
+
+  ghid_zoom_view_abs (center_x, center_y, priv->view.coord_per_px * factor);
 }
 
 void
@@ -1402,20 +1481,21 @@ ghid_zoom_view_fit (void)
 {
   ghid_pan_view_abs (SIDE_X (0), SIDE_Y (0), 0, 0);
   ghid_zoom_view_abs (SIDE_X (0), SIDE_Y (0),
-                      MAX (PCB->MaxWidth  / gport->width,
-                           PCB->MaxHeight / gport->height));
+                      MAX (PCB->MaxWidth  / gport->drawing_area->allocation.width,
+                           PCB->MaxHeight / gport->drawing_area->allocation.height));
 }
 
 void
 ghid_flip_view (Coord center_x, Coord center_y, bool flip_x, bool flip_y)
 {
+  render_priv *priv = gport->render_priv;
   int widget_x, widget_y;
 
   /* Work out where on the screen the flip point is */
   ghid_pcb_to_event_coords (center_x, center_y, &widget_x, &widget_y);
 
-  gport->view.flip_x = gport->view.flip_x != flip_x;
-  gport->view.flip_y = gport->view.flip_y != flip_y;
+  priv->view.flip_x = priv->view.flip_x != flip_x;
+  priv->view.flip_y = priv->view.flip_y != flip_y;
 
   /* Pan the board so the center location remains in the same place */
   ghid_pan_view_abs (center_x, center_y, widget_x, widget_y);
@@ -1460,7 +1540,7 @@ draw_lead_user (render_priv *priv)
 
       /* Draw an arc at radius */
       hidgl_draw_arc (width, priv->lead_user_x, priv->lead_user_y,
-                      radius, radius, 0, 360, gport->view.coord_per_px);
+                      radius, radius, 0, 360, priv->view.coord_per_px);
     }
 
   hidgl_flush_triangles (&buffer);
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index c20fff7..7529d84 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -1480,8 +1480,8 @@ Center(int argc, char **argv, Coord pcb_x, Coord pcb_y)
     AFAIL (center);
 
   /* Aim to put the given x, y PCB coordinates in the center of the widget */
-  widget_x = gport->width / 2;
-  widget_y = gport->height / 2;
+  widget_x = gport->drawing_area->allocation.width / 2;
+  widget_y = gport->drawing_area->allocation.height / 2;
 
   ghid_pan_view_abs (pcb_x, pcb_y, widget_x, widget_y);
 
@@ -1552,13 +1552,13 @@ CursorAction(int argc, char **argv, Coord x, Coord y)
 {
   UnitList extra_units_x = {
     { "grid",  PCB->Grid, 0 },
-    { "view",  gport->view.width, UNIT_PERCENT },
+//    { "view",  gport->view_width, UNIT_PERCENT },
     { "board", PCB->MaxWidth, UNIT_PERCENT },
     { "", 0, 0 }
   };
   UnitList extra_units_y = {
     { "grid",  PCB->Grid, 0 },
-    { "view",  gport->view.height, UNIT_PERCENT },
+//    { "view",  gport->view_height, UNIT_PERCENT },
     { "board", PCB->MaxHeight, UNIT_PERCENT },
     { "", 0, 0 }
   };
@@ -1576,11 +1576,12 @@ CursorAction(int argc, char **argv, Coord x, Coord y)
     AFAIL (cursor);
 
   dx = GetValueEx (argv[1], argv[3], NULL, extra_units_x, "");
-  if (gport->view.flip_x)
-    dx = -dx;
   dy = GetValueEx (argv[2], argv[3], NULL, extra_units_y, "");
-  if (!gport->view.flip_y)
-    dy = -dy;
+
+#if 0 /* We cannot know this sensibly from the renderer, so we have to remove it */
+  if (gport->view.flip_x) dx = -dx;
+  if (gport->view.flip_x) dy = -dy;
+#endif
 
   EventMoveCrosshair (Crosshair.X + dx, Crosshair.Y + dy);
   gui->set_crosshair (Crosshair.X, Crosshair.Y, pan_warp);
@@ -1734,8 +1735,9 @@ default is given, div=40.
 static int
 ScrollAction (int argc, char **argv, Coord x, Coord y)
 {
-  gdouble dx = 0.0, dy = 0.0;
-  int div = 40;
+  double dx = 0.;
+  double dy = 0.;
+  double fraction = 1. / 40.;
 
   if (!ghidgui)
     return 0;
@@ -1744,20 +1746,20 @@ ScrollAction (int argc, char **argv, Coord x, Coord y)
     AFAIL (scroll);
 
   if (argc == 2)
-    div = atoi(argv[1]);
+    fraction = 1. / (double) atoi(argv[1]);
 
   if (strcasecmp (argv[0], "up") == 0)
-    dy = -gport->view.height / div;
-  else if (strcasecmp (argv[0], "down") == 0)
-    dy = gport->view.height / div;
+    dy = -fraction;
+  else if (strcasecmp (argv[0], "down")  == 0)
+    dy =  fraction;
   else if (strcasecmp (argv[0], "right") == 0)
-    dx = gport->view.width / div;
-  else if (strcasecmp (argv[0], "left") == 0)
-    dx = -gport->view.width / div;
+    dx =  fraction;
+  else if (strcasecmp (argv[0], "left")  == 0)
+    dx = -fraction;
   else
     AFAIL (scroll);
 
-  ghid_pan_view_rel (dx, dy);
+  ghid_pan_view_rel_to_visible (dx, dy);
 
   return 0;
 }
@@ -1929,25 +1931,6 @@ HID_Action ghid_main_action_list[] = {
 REGISTER_ACTIONS (ghid_main_action_list)
 
 
-static int
-flag_flipx (int x)
-{
-  return gport->view.flip_x;
-}
-
-static int
-flag_flipy (int x)
-{
-  return gport->view.flip_y;
-}
-
-HID_Flag ghid_main_flag_list[] = {
-  {"flip_x", flag_flipx, 0},
-  {"flip_y", flag_flipy, 0}
-};
-
-REGISTER_FLAGS (ghid_main_flag_list)
-
 #include "dolists.h"
 
 /*
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index 20e8e03..19ecbfb 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -55,12 +55,14 @@
 void
 ghid_port_ranges_changed (void)
 {
+#if 0
   GtkAdjustment *h_adj, *v_adj;
 
   h_adj = gtk_range_get_adjustment (GTK_RANGE (ghidgui->h_range));
   v_adj = gtk_range_get_adjustment (GTK_RANGE (ghidgui->v_range));
   gport->view.x0 = gtk_adjustment_get_value (h_adj);
   gport->view.y0 = gtk_adjustment_get_value (v_adj);
+#endif
 
   ghid_invalidate_all ();
 }
@@ -71,6 +73,7 @@ ghid_port_ranges_changed (void)
 void
 ghid_port_ranges_scale (void)
 {
+#if 0
   GtkAdjustment *adj;
   gdouble page_size;
 
@@ -100,6 +103,7 @@ ghid_port_ranges_scale (void)
                             page_size / 100.0,              /* step_increment */
                             page_size / 10.0,               /* page_increment */
                             page_size);                     /* page_size      */
+#endif
 }
 
 
@@ -352,14 +356,11 @@ ghid_port_drawing_area_configure_event_cb (GtkWidget * widget,
 {
   static gboolean first_time_done;
 
-  gport->width = ev->width;
-  gport->height = ev->height;
-
   if (gport->pixmap)
     gdk_pixmap_unref (gport->pixmap);
 
   gport->pixmap = gdk_pixmap_new (gtk_widget_get_window (widget),
-				  gport->width, gport->height, -1);
+				  ev->width, ev->height, -1);
   gport->drawable = gport->pixmap;
 
   if (!first_time_done)
@@ -507,24 +508,20 @@ gint
 ghid_port_window_motion_cb (GtkWidget * widget,
 			    GdkEventMotion * ev, GHidPort * out)
 {
-  gdouble dx, dy;
-  static gint x_prev = -1, y_prev = -1;
-
   gdk_event_request_motions (ev);
 
   if (out->panning)
     {
-      dx = gport->view.coord_per_px * (x_prev - ev->x);
-      dy = gport->view.coord_per_px * (y_prev - ev->y);
-      if (x_prev > 0)
-        ghid_pan_view_rel (dx, dy);
-      x_prev = ev->x;
-      y_prev = ev->y;
+      /* gport->pcb_x and gport->pcb_y will correspond to where the user
+       * grabbed the board. Move the board so that location lands where
+       * the mouse pointer now is, as indicated by the event.
+       */
+      ghid_pan_view_abs (gport->pcb_x, gport->pcb_y, ev->x, ev->y);
+
       return FALSE;
     }
-  x_prev = y_prev = -1;
-  ghid_note_event_location ((GdkEventButton *)ev);
 
+  ghid_note_event_location ((GdkEventButton *)ev);
   queue_tooltip_update (out);
 
   return FALSE;
@@ -577,9 +574,7 @@ ghid_port_window_leave_cb (GtkWidget * widget,
    */
 
   if(ev->mode != GDK_CROSSING_NORMAL)
-    {
-      return FALSE;
-    }
+    return FALSE;
 
   out->has_entered = FALSE;
 
diff --git a/src/hid/gtk/gui-top-window.c b/src/hid/gtk/gui-top-window.c
index 98bfcfe..31d8c72 100644
--- a/src/hid/gtk/gui-top-window.c
+++ b/src/hid/gtk/gui-top-window.c
@@ -1713,7 +1713,6 @@ ghid_parse_arguments (int *argc, char ***argv)
   gtk_init (argc, argv);
 
   gport = &ghid_port;
-  gport->view.coord_per_px = 300.0;
   pixel_slop = 300;
 
   ghid_init_renderer (argc, argv, gport);
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index 341b284..dc5f32c 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -63,15 +63,6 @@
 #define	FROM_PCB_UNITS(v)	coord_to_unit (Settings.grid_unit, v)
 #define	TO_PCB_UNITS(v)		unit_to_coord (Settings.grid_unit, v)
 
-#define SIDE_X(x)         ((gport->view.flip_x ? PCB->MaxWidth - (x) : (x)))
-#define SIDE_Y(y)         ((gport->view.flip_y ? PCB->MaxHeight - (y) : (y)))
-
-#define	DRAW_X(x)         (gint)((SIDE_X(x) - gport->view.x0) / gport->view.coord_per_px)
-#define	DRAW_Y(y)         (gint)((SIDE_Y(y) - gport->view.y0) / gport->view.coord_per_px)
-
-#define	EVENT_TO_PCB_X(x) SIDE_X((gint)((x) * gport->view.coord_per_px + gport->view.x0))
-#define	EVENT_TO_PCB_Y(y) SIDE_Y((gint)((y) * gport->view.coord_per_px + gport->view.y0))
-
 /*
  * Used to intercept "special" hotkeys that gtk doesn't usually pass
  * on to the menu hotkeys.  We catch them and put them back where we
@@ -153,20 +144,6 @@ GhidGui;
 
 extern GhidGui _ghidgui, *ghidgui;
 
-typedef struct
-{
-  double coord_per_px; /* Zoom level described as PCB units per screen pixel */
-
-  Coord x0;
-  Coord y0;
-  Coord width;
-  Coord height;
-
-  bool flip_x;
-  bool flip_y;
-
-} view_data;
-
   /* The output viewport
    */
 typedef struct
@@ -175,7 +152,6 @@ typedef struct
    *drawing_area;		/* and its drawing area */
   GdkPixmap *pixmap, *mask;
   GdkDrawable *drawable;	/* Current drawable for drawing routines */
-  gint width, height;
 
   struct render_priv *render_priv;
 
@@ -189,7 +165,6 @@ typedef struct
   gboolean has_entered;
   gboolean panning;
 
-  view_data view;
   Coord pcb_x, pcb_y;             /* PCB coordinates of the mouse pointer */
   Coord crosshair_x, crosshair_y; /* PCB coordinates of the crosshair     */
 }
@@ -505,6 +480,7 @@ void ghid_finish_debug_draw (void);
 bool ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y);
 bool ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y);
 void ghid_pan_view_abs (Coord pcb_x, Coord pcb_y, int widget_x, int widget_y);
+void ghid_pan_view_rel_to_visible (double fraction_x, double fraction_y);
 void ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom);
 void ghid_zoom_view_rel (Coord center_x, Coord center_y, double factor);
 void ghid_zoom_view_fit (void);
@@ -526,58 +502,4 @@ extern GdkPixmap *XC_lock_source, *XC_lock_mask;
 extern GdkPixmap *XC_clock_source, *XC_clock_mask;
 
 
-/* Coordinate conversions */
-/* Px converts view->pcb, Vx converts pcb->view */
-static inline int
-Vx (Coord x)
-{
-  int rv;
-  if (gport->view.flip_x)
-    rv = (PCB->MaxWidth - x - gport->view.x0) / gport->view.coord_per_px + 0.5;
-  else
-    rv = (x - gport->view.x0) / gport->view.coord_per_px + 0.5;
-  return rv;
-}
-
-static inline int
-Vy (Coord y)
-{
-  int rv;
-  if (gport->view.flip_y)
-    rv = (PCB->MaxHeight - y - gport->view.y0) / gport->view.coord_per_px + 0.5;
-  else
-    rv = (y - gport->view.y0) / gport->view.coord_per_px + 0.5;
-  return rv;
-}
-
-static inline int
-Vz (Coord z)
-{
-  return z / gport->view.coord_per_px + 0.5;
-}
-
-static inline Coord
-Px (int x)
-{
-  Coord rv = x * gport->view.coord_per_px + gport->view.x0;
-  if (gport->view.flip_x)
-    rv = PCB->MaxWidth - (x * gport->view.coord_per_px + gport->view.x0);
-  return  rv;
-}
-
-static inline Coord
-Py (int y)
-{
-  Coord rv = y * gport->view.coord_per_px + gport->view.y0;
-  if (gport->view.flip_y)
-    rv = PCB->MaxHeight - (y * gport->view.coord_per_px + gport->view.y0);
-  return  rv;
-}
-
-static inline Coord
-Pz (int z)
-{
-  return (z * gport->view.coord_per_px);
-}
-
 #endif /* PCB_HID_GTK_GHID_H */

Bottom: a4b80c19d5401828470ec1dbf211eefa558433ec
Top:    3e2c7ff05811d24fc42df098e7361994a9746200
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-10-05 23:51:27 +0100

Refresh of play-with-glsl-shader-for-rend

---

diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index 238e61d..82f6df1 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -80,7 +80,13 @@ hidgl_init_triangle_array (triangle_buffer *buffer)
 {
   CHECK_IS_IN_CONTEXT ();
   glEnableClientState (GL_VERTEX_ARRAY);
-  glVertexPointer (3, GL_FLOAT, 0, buffer->triangle_array);
+  glVertexPointer (3, GL_FLOAT, 5 * sizeof (GLfloat),
+                   buffer->triangle_array);
+
+  glEnableClientState (GL_TEXTURE_COORD_ARRAY);
+  glTexCoordPointer (2, GL_FLOAT, 5 * sizeof (GLfloat),
+                     buffer->triangle_array + 3);
+
   buffer->triangle_count = 0;
   buffer->coord_comp_count = 0;
 }
@@ -215,34 +221,25 @@ int calc_slices (float pix_radius, float sweep_angle)
   return (int)ceilf (slices);
 }
 
-#define MIN_TRIANGLES_PER_CAP 3
-#define MAX_TRIANGLES_PER_CAP 90
-static void draw_cap (double width, int x, int y, double angle, double scale)
+static void draw_cap (double width, int x, int y, double angle)
 {
-  float last_capx, last_capy;
-  float capx, capy;
   float radius = width / 2.;
-  int slices = calc_slices (radius / scale, M_PI);
-  int i;
 
   CHECK_IS_IN_CONTEXT ();
-  if (slices < MIN_TRIANGLES_PER_CAP)
-    slices = MIN_TRIANGLES_PER_CAP;
-
-  if (slices > MAX_TRIANGLES_PER_CAP)
-    slices = MAX_TRIANGLES_PER_CAP;
-
-  hidgl_ensure_triangle_space (&buffer, slices);
-
-  last_capx =  radius * cosf (angle * M_PI / 180.) + x;
-  last_capy = -radius * sinf (angle * M_PI / 180.) + y;
-  for (i = 0; i < slices; i++) {
-    capx =  radius * cosf (angle * M_PI / 180. + ((float)(i + 1)) * M_PI / (float)slices) + x;
-    capy = -radius * sinf (angle * M_PI / 180. + ((float)(i + 1)) * M_PI / (float)slices) + y;
-    hidgl_add_triangle (&buffer, last_capx, last_capy, capx, capy, x, y);
-    last_capx = capx;
-    last_capy = capy;
-  }
+
+  hidgl_ensure_triangle_space (&buffer, 2);
+
+  /* FIXME: Should draw an offset rectangle at the appropriate angle,
+   *        avoiding relying on the subcompositing between layers to
+   *        stop us creatign an artaefact by drawing a full circle.
+   */
+  hidgl_add_triangle_tex (&buffer, x - radius, y - radius, -1., -1.,
+                                   x - radius, y + radius, -1.,  1.,
+                                   x + radius, y + radius,  1.,  1.);
+
+  hidgl_add_triangle_tex (&buffer, x + radius, y - radius,  1., -1.,
+                                   x + radius, y + radius,  1.,  1.,
+                                   x - radius, y - radius, -1., -1.);
 }
 
 void
@@ -313,8 +310,8 @@ hidgl_draw_line (int cap, double width, int x1, int y1, int x2, int y2, double s
   /* Don't bother capping hairlines */
   if (circular_caps && !hairline)
     {
-      draw_cap (width, x1, y1, angle, scale);
-      draw_cap (width, x2, y2, angle + 180., scale);
+      draw_cap (width, x1, y1, angle);
+      draw_cap (width, x2, y2, angle + 180.);
     }
 }
 
@@ -393,10 +390,10 @@ hidgl_draw_arc (double width, int x, int y, int rx, int ry,
 
   draw_cap (width, x + rx * -cosf (start_angle_rad),
                    y + rx *  sinf (start_angle_rad),
-                   start_angle, scale);
+                   start_angle);
   draw_cap (width, x + rx * -cosf (start_angle_rad + delta_angle_rad),
                    y + rx *  sinf (start_angle_rad + delta_angle_rad),
-                   start_angle + delta_angle + 180., scale);
+                   start_angle + delta_angle + 180.);
 }
 
 void
@@ -413,37 +410,24 @@ hidgl_draw_rect (int x1, int y1, int x2, int y2)
 
 
 void
-hidgl_fill_circle (int vx, int vy, int vr, double scale)
+hidgl_fill_circle (int vx, int vy, int vr)
 {
-#define MIN_TRIANGLES_PER_CIRCLE 6
-#define MAX_TRIANGLES_PER_CIRCLE 360
   float last_x, last_y;
   float radius = vr;
   int slices;
   int i;
 
   CHECK_IS_IN_CONTEXT ();
-  slices = calc_slices (vr / scale, 2 * M_PI);
-
-  if (slices < MIN_TRIANGLES_PER_CIRCLE)
-    slices = MIN_TRIANGLES_PER_CIRCLE;
 
-  if (slices > MAX_TRIANGLES_PER_CIRCLE)
-    slices = MAX_TRIANGLES_PER_CIRCLE;
-
-  hidgl_ensure_triangle_space (&buffer, slices);
+  hidgl_ensure_triangle_space (&buffer, 2);
 
-  last_x = vx + vr;
-  last_y = vy;
+  hidgl_add_triangle_tex (&buffer, vx - radius, vy - radius, -1., -1.,
+                                   vx - radius, vy + radius, -1.,  1.,
+                                   vx + radius, vy + radius,  1.,  1.);
 
-  for (i = 0; i < slices; i++) {
-    float x, y;
-    x = radius * cosf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vx;
-    y = radius * sinf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vy;
-    hidgl_add_triangle (&buffer, vx, vy, last_x, last_y, x, y);
-    last_x = x;
-    last_y = y;
-  }
+  hidgl_add_triangle_tex (&buffer, vx + radius, vy - radius,  1., -1.,
+                                   vx + radius, vy + radius,  1.,  1.,
+                                   vx - radius, vy - radius, -1., -1.);
 }
 
 #define MAX_COMBINED_MALLOCS 2500
@@ -629,16 +613,12 @@ do_hole (const BoxType *b, void *cl)
     return 0;
   }
 
-  /* If the contour is round, and hidgl_fill_circle would use
-   * less slices than we have vertices to draw it, then call
+  /* If the contour is round, then call
    * hidgl_fill_circle to draw this contour.
    */
   if (curc->is_round) {
-    double slices = calc_slices (curc->radius / info->scale, 2 * M_PI);
-    if (slices < curc->Count) {
-      hidgl_fill_circle (curc->cx, curc->cy, curc->radius, info->scale);
-      return 1;
-    }
+    hidgl_fill_circle (curc->cx, curc->cy, curc->radius);
+    return 1;
   }
 
   _cairo_traps_init (&traps);
@@ -654,15 +634,13 @@ static int assigned_bits = 0;
 
 /* FIXME: JUST DRAWS THE FIRST PIECE.. TODO: SUPPORT FOR FULLPOLY POLYGONS */
 void
-hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale)
+hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box)
 {
   struct do_hole_info info;
   int stencil_bit;
   cairo_traps_t traps;
 
   CHECK_IS_IN_CONTEXT ();
-  info.scale = scale;
-  global_scale = scale;
 
   if (poly->Clipped == NULL)
     {
@@ -728,9 +706,127 @@ hidgl_fill_rect (int x1, int y1, int x2, int y2)
   hidgl_add_triangle (&buffer, x2, y1, x2, y2, x1, y1);
 }
 
+/* From http://gpwiki.org/index.php/OpenGL:Codes:Simple_GLSL_example */
+static void
+printLog(GLuint obj)
+{
+  int infologLength = 0;
+  int maxLength;
+  char infoLog[maxLength];
+
+  if (glIsShader (obj))
+    glGetShaderiv (obj, GL_INFO_LOG_LENGTH, &maxLength);
+  else
+    glGetProgramiv (obj, GL_INFO_LOG_LENGTH, &maxLength);
+
+  if (glIsShader (obj))
+    glGetShaderInfoLog (obj, maxLength, &infologLength, infoLog);
+  else
+    glGetProgramInfoLog (obj, maxLength, &infologLength, infoLog);
+
+  if (infologLength > 0)
+    printf ("%s\n", infoLog);
+}
+
+/* From http://gpwiki.org/index.php/OpenGL:Codes:Simple_GLSL_example */
+char *
+file2string (const char *path)
+{
+  FILE *fd;
+  long len, r;
+  char *str;
+
+  if (!(fd = fopen (path, "r")))
+    {
+      fprintf (stderr, "Can't open file '%s' for reading\n", path);
+      return NULL;
+    }
+
+  fseek (fd, 0, SEEK_END);
+  len = ftell(fd);
+
+  printf ("File '%s' is %ld long\n", path, len);
+
+  fseek (fd, 0, SEEK_SET);
+
+  if (!(str = malloc (len * sizeof(char))))
+    {
+      fprintf (stderr, "Can't malloc space for '%s'\n", path);
+      return NULL;
+    }
+
+  r = fread (str, sizeof(char), len, fd);
+
+  str[r - 1] = '\0'; /* Shader sources have to term with null */
+
+  fclose (fd);
+
+  return str;
+}
+
+GLuint sp;
+
+void
+hidgl_load_frag_shader (void)
+{
+  char *vs_source;
+  char *fs_source;
+
+  /* Compile and load the program */
+
+  GLuint vs; /* Vertex Shader */
+  GLuint fs; /* Fragment Shader */
+//  GLuint sp; /* Shader Program */
+
+#if 0
+  vs_source = file2string ("circular.vert");
+  vs = glCreateShader (GL_VERTEX_SHADER);
+  glShaderSource (vs, 1, &vs_source, NULL);
+  glCompileShader (vs);
+//  printLog (vs);
+  free (vs_source);
+#endif
+
+  fs_source = file2string ("circular.frag");
+  if (fs_source == NULL)
+    return;
+  fs = glCreateShader (GL_FRAGMENT_SHADER);
+  glShaderSource (fs, 1, &fs_source, NULL);
+  glCompileShader (fs);
+//  printLog (fs);
+  free (fs_source);
+
+  sp = glCreateProgram ();
+//  glAttachShader (sp, vs);
+  glAttachShader (sp, fs);
+  glLinkProgram (sp);
+//  printLog (sp);
+
+  glUseProgram (sp);
+
+  {
+  GLfloat waveTime = 0,
+          waveWidth = 0.00001,
+          waveHeight = 10;
+  GLint waveTimeLoc = glGetUniformLocation(sp, "waveTime");
+  GLint waveWidthLoc = glGetUniformLocation(sp, "waveWidth");
+  GLint waveHeightLoc = glGetUniformLocation(sp, "waveHeight");
+  /* Change time */
+  glUniform1f(waveTimeLoc, waveTime);
+  glUniform1f(waveWidthLoc, waveWidth);
+  glUniform1f(waveHeightLoc, waveHeight);
+
+  }
+}
+
 void
 hidgl_init (void)
 {
+  static bool done_once = false;
+
+  if (done_once)
+    return;
+
   CHECK_IS_IN_CONTEXT ();
   glGetIntegerv (GL_STENCIL_BITS, &stencil_bits);
 
@@ -746,6 +842,9 @@ hidgl_init (void)
               "Cannot use stencil buffer to sub-composite layers.\n");
       /* Do we need to disable that somewhere? */
     }
+
+  hidgl_load_frag_shader ();
+  done_once = true;
 }
 
 int
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index 1ed8eb3..b2bfbd4 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -23,9 +23,10 @@
 #ifndef __HIDGL_INCLUDED__
 #define __HIDGL_INCLUDED__
 
-#define TRIANGLE_ARRAY_SIZE 5461
+//#define TRIANGLE_ARRAY_SIZE 5461
+#define TRIANGLE_ARRAY_SIZE 2740
 typedef struct {
-  GLfloat triangle_array [3 * 3 * TRIANGLE_ARRAY_SIZE];
+  GLfloat triangle_array [3 * (3 + 2) * TRIANGLE_ARRAY_SIZE];
   unsigned int triangle_count;
   unsigned int coord_comp_count;
 } triangle_buffer;
@@ -39,24 +40,55 @@ void hidgl_flush_triangles (triangle_buffer *buffer);
 void hidgl_ensure_triangle_space (triangle_buffer *buffer, int count);
 
 static inline void
-hidgl_add_triangle_3D (triangle_buffer *buffer,
-                       GLfloat x1, GLfloat y1, GLfloat z1,
-                       GLfloat x2, GLfloat y2, GLfloat z2,
-                       GLfloat x3, GLfloat y3, GLfloat z3)
+hidgl_add_triangle_3D_tex (triangle_buffer *buffer,
+                           GLfloat x1, GLfloat y1, GLfloat z1, GLfloat u1, GLfloat v1,
+                           GLfloat x2, GLfloat y2, GLfloat z2, GLfloat u2, GLfloat v2,
+                           GLfloat x3, GLfloat y3, GLfloat z3, GLfloat u3, GLfloat v3)
 {
   buffer->triangle_array [buffer->coord_comp_count++] = x1;
   buffer->triangle_array [buffer->coord_comp_count++] = y1;
   buffer->triangle_array [buffer->coord_comp_count++] = z1;
+  buffer->triangle_array [buffer->coord_comp_count++] = u1;
+  buffer->triangle_array [buffer->coord_comp_count++] = v1;
+
   buffer->triangle_array [buffer->coord_comp_count++] = x2;
   buffer->triangle_array [buffer->coord_comp_count++] = y2;
   buffer->triangle_array [buffer->coord_comp_count++] = z2;
+  buffer->triangle_array [buffer->coord_comp_count++] = u2;
+  buffer->triangle_array [buffer->coord_comp_count++] = v2;
+
   buffer->triangle_array [buffer->coord_comp_count++] = x3;
   buffer->triangle_array [buffer->coord_comp_count++] = y3;
   buffer->triangle_array [buffer->coord_comp_count++] = z3;
+  buffer->triangle_array [buffer->coord_comp_count++] = u3;
+  buffer->triangle_array [buffer->coord_comp_count++] = v3;
+
   buffer->triangle_count++;
 }
 
 static inline void
+hidgl_add_triangle_3D (triangle_buffer *buffer,
+                       GLfloat x1, GLfloat y1, GLfloat z1,
+                       GLfloat x2, GLfloat y2, GLfloat z2,
+                       GLfloat x3, GLfloat y3, GLfloat z3)
+{
+  hidgl_add_triangle_3D_tex (buffer, x1, y1, z1, 0., 0.,
+                                     x2, y2, z2, 0., 0.,
+                                     x3, y3, z3, 0., 0.);
+}
+
+static inline void
+hidgl_add_triangle_tex (triangle_buffer *buffer,
+                        GLfloat x1, GLfloat y1, GLfloat u1, GLfloat v1,
+                        GLfloat x2, GLfloat y2, GLfloat u2, GLfloat v2,
+                        GLfloat x3, GLfloat y3, GLfloat u3, GLfloat v3)
+{
+  hidgl_add_triangle_3D_tex (buffer, x1, y1, global_depth, u1, v1,
+                                     x2, y2, global_depth, u2, v2,
+                                     x3, y3, global_depth, u3, v3);
+}
+
+static inline void
 hidgl_add_triangle (triangle_buffer *buffer,
                     GLfloat x1, GLfloat y1,
                     GLfloat x2, GLfloat y2,
@@ -71,9 +103,9 @@ hidgl_add_triangle (triangle_buffer *buffer,
 void hidgl_draw_line (int cap, double width, int x1, int y1, int x2, int y2, double scale);
 void hidgl_draw_arc (double width, int vx, int vy, int vrx, int vry, int start_angle, int delta_angle, double scale);
 void hidgl_draw_rect (int x1, int y1, int x2, int y2);
-void hidgl_fill_circle (int vx, int vy, int vr, double scale);
+void hidgl_fill_circle (int vx, int vy, int vr);
 void hidgl_fill_polygon (int n_coords, int *x, int *y);
-void hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale);
+void hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box);
 void hidgl_fill_rect (int x1, int y1, int x2, int y2);
 
 void hidgl_init (void);
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 81c684f..3375f95 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -697,7 +697,7 @@ ghid_fill_circle (hidGC gc, int cx, int cy, int radius)
 {
   USE_GC (gc);
 
-  hidgl_fill_circle (cx, cy, radius, gport->zoom);
+  hidgl_fill_circle (cx, cy, radius);
 }
 
 
@@ -714,7 +714,7 @@ ghid_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
 {
   USE_GC (gc);
 
-  hidgl_fill_pcb_polygon (poly, clip_box, gport->zoom);
+  hidgl_fill_pcb_polygon (poly, clip_box);
 }
 
 void
@@ -1015,6 +1015,8 @@ ghid_start_drawing (GHidPort *port)
   if (!gdk_gl_drawable_gl_begin (pGlDrawable, pGlContext))
     return FALSE;
 
+//  hidgl_load_frag_shader ();
+
   return TRUE;
 }
 
@@ -1786,6 +1788,9 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   int new_x, new_y;
   int min_depth;
   int max_depth;
+  static float wavetime = 0;
+  extern GLuint sp;
+  GLint waveTimeLoc = glGetUniformLocation (sp, "waveTime");
 
   ghid_start_drawing (port);
 
@@ -1793,6 +1798,9 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   hidgl_init ();
   check_gl_drawing_ok_hack = true;
 
+  wavetime += 0.1;
+  glUniform1f (waveTimeLoc, wavetime);
+
   /* If we don't have any stencil bits available,
      we can't use the hidgl polygon drawing routine */
   /* TODO: We could use the GLU tessellator though */

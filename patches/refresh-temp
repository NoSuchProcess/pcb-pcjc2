Bottom: 551be10c085f3b44e5a965bf11baf7e1cacba35d
Top:    9d5a42bffb936f64c6920365dfb2f2af1aa3f567
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2012-01-22 01:42:56 +0000

Refresh of other-drawing-api-changes

---

diff --git a/src/draw.c b/src/draw.c
index 7a01fc0..050a15f 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -359,17 +359,12 @@ draw_element_name (DrawAPI *dapi, ElementType *element)
   DrawTextLowLevel (dapi, &ELEMENT_TEXT (PCB, element), PCB->minSlk);
 }
 
-struct name_info {
-  DrawAPI *dapi;
-  int side;
-};
-
 static int
 name_callback (const BoxType * b, void *cl)
 {
   TextType *text = (TextType *) b;
   ElementType *element = (ElementType *) text->Element;
-  struct name_info *info = cl;
+  struct side_info *info = cl;
   DrawAPI *dapi = info->dapi;
 
   if (TEST_FLAG (HIDENAMEFLAG, element))
@@ -567,7 +562,7 @@ arc_callback (const BoxType * b, void *cl)
   struct layer_info *info = cl;
   DrawAPI *dapi = info->dapi;
 
-  draw_arc (dapi, (LayerType *) cl, (ArcType *) b);
+  draw_arc (dapi, info->layer, (ArcType *) b);
   return 1;
 }
 
@@ -624,7 +619,7 @@ PrintAssembly (DrawAPI *dapi, int side)
   dapi->gapi->set_draw_faded (dapi->fg_gc, 0);
 
   /* draw package */
-  DrawSilk (dapi, side);
+  dapi->draw_silk_layer (dapi, side);
   doing_assy = false;
 }
 
@@ -667,21 +662,18 @@ DrawEverything (DrawAPI *dapi)
   if (!TEST_FLAG (CHECKPLANESFLAG, PCB)
       && gui->set_layer ("invisible", SL (INVISIBLE, 0), 0))
     {
-      struct side_info info;
+      struct side_info side_info;
 
-      info.dapi = dapi;
-      info.side = SWAP_IDENT ? COMPONENT_LAYER : SOLDER_LAYER;
+      side_info.dapi = dapi;
+      side_info.side = SWAP_IDENT ? COMPONENT_LAYER : SOLDER_LAYER;
 
       if (PCB->ElementOn)
 	{
-          struct name_info name_info;
-          info.dapi = dapi;
-          info.side = SWAP_IDENT ? COMPONENT_LAYER : SOLDER_LAYER;
-	  r_search (PCB->Data->element_tree, dapi->clip_box, NULL, element_callback, &name_info);
-	  r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], dapi->clip_box, NULL, name_callback, &name_info);
-	  dapi->draw_pcb_layer (dapi, &(PCB->Data->Layer[max_copper_layer + info.side]));
+	  r_search (PCB->Data->element_tree, dapi->clip_box, NULL, element_callback, &side_info);
+	  r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], dapi->clip_box, NULL, name_callback, &side_info);
+	  dapi->draw_pcb_layer (dapi, &(PCB->Data->Layer[max_copper_layer + side_info.side]));
 	}
-      r_search (PCB->Data->pad_tree, dapi->clip_box, NULL, pad_callback, &info);
+      r_search (PCB->Data->pad_tree, dapi->clip_box, NULL, pad_callback, &side_info);
       gui->end_layer ();
     }
 
@@ -723,25 +715,25 @@ DrawEverything (DrawAPI *dapi)
   /* Draw the solder mask if turned on */
   if (gui->set_layer ("componentmask", SL (MASK, TOP), 0))
     {
-      DrawMask (dapi, COMPONENT_LAYER);
+      dapi->draw_solder_mask (dapi, COMPONENT_LAYER);
       gui->end_layer ();
     }
 
   if (gui->set_layer ("soldermask", SL (MASK, BOTTOM), 0))
     {
-      DrawMask (dapi, SOLDER_LAYER);
+      dapi->draw_solder_mask (dapi, SOLDER_LAYER);
       gui->end_layer ();
     }
 
   if (gui->set_layer ("topsilk", SL (SILK, TOP), 0))
     {
-      DrawSilk (dapi, COMPONENT_LAYER);
+      dapi->draw_silk_layer (dapi, COMPONENT_LAYER);
       gui->end_layer ();
     }
 
   if (gui->set_layer ("bottomsilk", SL (SILK, BOTTOM), 0))
     {
-      DrawSilk (dapi, SOLDER_LAYER);
+      dapi->draw_silk_layer (dapi, SOLDER_LAYER);
       gui->end_layer ();
     }
 
@@ -953,12 +945,12 @@ clearPad_callback (const BoxType * b, void *cl)
  */
 
 void
-DrawSilk (DrawAPI *dapi, int side)
+draw_silk_layer (DrawAPI *dapi, int side)
 {
-  struct name_info name_info;
+  struct side_info side_info;
 
-  name_info.dapi = dapi;
-  name_info.side = side;
+  side_info.dapi = dapi;
+  side_info.side = side;
 
 #if 0
   /* This code is used when you want to mask silk to avoid exposed
@@ -973,8 +965,8 @@ DrawSilk (DrawAPI *dapi, int side)
 #endif
       dapi->draw_pcb_layer (dapi, LAYER_PTR (max_copper_layer + side));
       /* draw package */
-      r_search (PCB->Data->element_tree, dapi->clip_box, NULL, element_callback, &side);
-      r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], dapi->clip_box, NULL, name_callback, &name_info);
+      r_search (PCB->Data->element_tree, dapi->clip_box, NULL, element_callback, &side_info);
+      r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], dapi->clip_box, NULL, name_callback, &side_info);
 #if 0
     }
 
@@ -989,7 +981,7 @@ DrawSilk (DrawAPI *dapi, int side)
       DrawLayer (dapi, LAYER_PTR (max_copper_layer + layer), drawn_area);
       /* draw package */
       r_search (PCB->Data->element_tree, drawn_area, NULL, element_callback, &side);
-      r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], drawn_area, NULL, name_callback, &side);
+      r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], drawn_area, NULL, name_callback, &side_info);
     }
   dapi->gapi->use_mask (HID_MASK_OFF);
 #endif
@@ -1016,8 +1008,8 @@ DrawMaskBoardArea (DrawAPI *dapi, int mask_type)
 /* ---------------------------------------------------------------------------
  * draws solder mask layer - this will cover nearly everything
  */
-void
-DrawMask (DrawAPI *dapi, int side)
+static void
+draw_solder_mask (DrawAPI *dapi, int side)
 {
   int thin = TEST_FLAG(THINDRAWFLAG, PCB) || TEST_FLAG(THINDRAWPOLYFLAG, PCB);
   struct side_info info;
@@ -1771,8 +1763,8 @@ draw_pcb_element (DrawAPI *dapi, ElementType *element)
  * HID drawing callback.
  */
 
-void
-hid_expose_callback (DrawAPI *dapi, BoxType * region, void *item)
+static void
+draw_everything (DrawAPI *dapi)
 {
   dapi->fg_gc = dapi->gapi->make_gc ();
   dapi->bg_gc = dapi->gapi->make_gc ();
@@ -1781,25 +1773,45 @@ hid_expose_callback (DrawAPI *dapi, BoxType * region, void *item)
   dapi->gapi->set_color (dapi->pm_gc, "erase");
   dapi->gapi->set_color (dapi->bg_gc, "drill");
 
-  dapi->set_clip_box (dapi, region);
+  DrawEverything (dapi);
 
-  if (item)
-    {
-      doing_pinout = true;
-      dapi->draw_pcb_element (dapi, (ElementType *)item);
-      doing_pinout = false;
-    }
-  else
-    DrawEverything (dapi);
+  dapi->gapi->destroy_gc (dapi->fg_gc);
+  dapi->gapi->destroy_gc (dapi->bg_gc);
+  dapi->gapi->destroy_gc (dapi->pm_gc);
+}
+
+static void
+draw_pinout_preview (DrawAPI *dapi, ElementType *element)
+{
+  dapi->fg_gc = dapi->gapi->make_gc ();
+  dapi->bg_gc = dapi->gapi->make_gc ();
+  dapi->pm_gc = dapi->gapi->make_gc ();
+
+  dapi->gapi->set_color (dapi->pm_gc, "erase");
+  dapi->gapi->set_color (dapi->bg_gc, "drill");
+
+  doing_pinout = true;
+  dapi->draw_pcb_element (dapi, element);
+  doing_pinout = false;
 
   dapi->gapi->destroy_gc (dapi->fg_gc);
   dapi->gapi->destroy_gc (dapi->bg_gc);
   dapi->gapi->destroy_gc (dapi->pm_gc);
 }
 
-void
-draw_dapi_init (DrawAPI *dapi)
+static void
+set_clip_box (DrawAPI *dapi, const BoxType *clip_box)
 {
+  dapi->clip_box = clip_box;
+}
+
+DrawAPI *
+draw_api_new (void)
+{
+  DrawAPI *dapi;
+
+  dapi = g_new0 (DrawAPI, 1);
+
 #if 0
   dapi->draw_pcb_pin         =
   dapi->draw_pcb_pin_mask    =
@@ -1819,9 +1831,19 @@ draw_dapi_init (DrawAPI *dapi)
   dapi->draw_pcb_element     = draw_pcb_element;
   dapi->draw_pcb_layer       = draw_pcb_layer;
   dapi->draw_pcb_layer_group = draw_pcb_layer_group;
+  dapi->draw_solder_mask     = draw_solder_mask;
+#if 0
+  dapi->draw_solder_paste    =
+#endif
+  dapi->draw_silk_layer      = draw_silk_layer; /* Hmm - should be able to do this by layer number, even if not layer group */
+  /* But it would mean special casing diving into element silk from teh draw_pcb_layer function */
+  dapi->draw_everything      = draw_everything;
+  dapi->draw_pinout_preview  = draw_pinout_preview;
 #if 0
   dapi->draw_pcb_buffer      =
   dapi->set_draw_offset      =
-  dapi->set_clip_box         =
 #endif
+  dapi->set_clip_box         = set_clip_box;
+
+  return dapi;
 }
diff --git a/src/draw.h b/src/draw.h
index e053d2a..97d182a 100644
--- a/src/draw.h
+++ b/src/draw.h
@@ -75,4 +75,6 @@ void DrawSilk (DrawAPI *dapi, int side);
 void DrawMask (DrawAPI *dapi, int side);
 void DrawHoles (DrawAPI *dapi, bool draw_plated, bool draw_unplated);
 
+DrawAPI *draw_api_new (void);
+
 #endif
diff --git a/src/draw_api.h b/src/draw_api.h
index 2959e73..901f27f 100644
--- a/src/draw_api.h
+++ b/src/draw_api.h
@@ -48,7 +48,14 @@ struct DrawAPI {
   void (*draw_pcb_element)     (DrawAPI *, ElementType *);
   void (*draw_pcb_layer)       (DrawAPI *, LayerType *);
   void (*draw_pcb_layer_group) (DrawAPI *, int);
+  void (*draw_solder_mask)     (DrawAPI *, int);
+  void (*draw_solder_paste)    (DrawAPI *, int);
+  void (*draw_silk_layer)      (DrawAPI *, int);
+
   void (*draw_pcb_buffer)      (DrawAPI *, BufferType *);
+  void (*draw_everything)      (DrawAPI *);
+
+  void (*draw_pinout_preview)  (DrawAPI *, ElementType *);
   void (*set_draw_offset)      (DrawAPI *, Coord, Coord);
   void (*set_clip_box)         (DrawAPI *, const BoxType *);
 
@@ -58,7 +65,7 @@ struct DrawAPI {
   hidGC fg_gc;
   hidGC bg_gc;
   hidGC pm_gc;
-  BoxType *clip_box;
+  const BoxType *clip_box;
 };
 
 enum mask_mode {
diff --git a/src/hid/common/extents.c b/src/hid/common/extents.c
index 564436b..e6c1671 100644
--- a/src/hid/common/extents.c
+++ b/src/hid/common/extents.c
@@ -205,7 +205,7 @@ hid_get_extents (void *item)
   region.Y1 = -MAXINT;
   region.X2 = MAXINT;
   region.Y2 = MAXINT;
-  hid_expose_callback (&extents_hid, &region, item);
+//  hid_expose_callback (&extents_hid, &region, item);
 
   return &box;
 }
diff --git a/src/hid/gcode/gcode.c b/src/hid/gcode/gcode.c
index 32f6350..ef682d8 100644
--- a/src/hid/gcode/gcode.c
+++ b/src/hid/gcode/gcode.c
@@ -420,7 +420,7 @@ gcode_start_png_export ()
   linewidth = -1;
   lastbrush = (gdImagePtr)((void *) -1);
 
-  hid_expose_callback (&gcode_hid, &region, 0);
+//  hid_expose_callback (&gcode_hid, &region, 0);
 }
 
 static void
diff --git a/src/hid/gerber/gerber.c b/src/hid/gerber/gerber.c
index 034d21a..8ba3515 100644
--- a/src/hid/gerber/gerber.c
+++ b/src/hid/gerber/gerber.c
@@ -594,11 +594,11 @@ gerber_do_export (HID_Attr_Val * options)
   lastgroup = -1;
   layer_list_idx = 0;
   finding_apertures = 1;
-  hid_expose_callback (&gerber_hid, &region, 0);
+//  hid_expose_callback (&gerber_hid, &region, 0);
 
   layer_list_idx = 0;
   finding_apertures = 0;
-  hid_expose_callback (&gerber_hid, &region, 0);
+//  hid_expose_callback (&gerber_hid, &region, 0);
 
   memcpy (LayerStack, saved_layer_stack, sizeof (LayerStack));
 
diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index 8e6cf22..6ab0254 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -785,7 +785,7 @@ redraw_region (GdkRectangle *rect)
 
   ghid_draw_bg_image();
 
-  hid_expose_callback (&ghid_hid, &region, 0);
+//  hid_expose_callback (&ghid_hid, &region, 0);
   ghid_draw_grid ();
 
   /* In some cases we are called with the crosshair still off */
@@ -1159,7 +1159,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
                       0, 0, allocation.width, allocation.height);
 
   /* call the drawing routine */
-  hid_expose_callback (&ghid_hid, NULL, &pinout->element);
+//  hid_expose_callback (&ghid_hid, NULL, &pinout->element);
 
   gport->drawable = save_drawable;
   gport->view = save_view;
@@ -1216,7 +1216,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   region.Y1 = MAX (0, MIN (PCB->MaxHeight, region.Y1));
   region.Y2 = MAX (0, MIN (PCB->MaxHeight, region.Y2));
 
-  hid_expose_callback (&ghid_hid, &region, NULL);
+//  hid_expose_callback (&ghid_hid, &region, NULL);
 
   gport->drawable = save_drawable;
   gport->view = save_view;
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index bbf99b1..977f042 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -32,6 +32,7 @@
 #include <dmalloc.h>
 #endif
 
+extern GraphicsAPI ghid_gapi;
 extern HID ghid_hid;
 
 static hidGC current_gc = NULL;
@@ -840,6 +841,12 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   render_priv *priv = port->render_priv;
   GtkAllocation allocation;
   BoxType region;
+  DrawAPI *dapi;
+
+  dapi = draw_api_new ();
+  dapi->gapi = &ghid_gapi;
+  dapi->gc = dapi->gapi->make_gc ();
+  common_draw_helpers_init (dapi);
 
   gtk_widget_get_allocation (widget, &allocation);
 
@@ -918,6 +925,8 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
+  dapi->set_clip_box (dapi, &region);
+  dapi->draw_everything (dapi);
 //  hid_expose_callback (&ghid_hid, &region, 0);
   hidgl_flush_triangles (&buffer);
 
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 587d91a..d4a0ccc 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -2073,6 +2073,7 @@ REGISTER_FLAGS (ghid_main_flag_list)
 #include <winreg.h>
 #endif
 
+GraphicsAPI ghid_gapi;
 HID ghid_hid;
 
 void
@@ -2131,20 +2132,20 @@ hid_gtk_init ()
   ghid_hid.notify_crosshair_change  = ghid_notify_crosshair_change;
   ghid_hid.notify_mark_change       = ghid_notify_mark_change;
   ghid_hid.set_layer                = ghid_set_layer;
-#if 0
-  ghid_hid.make_gc                  = ghid_make_gc;
-  ghid_hid.destroy_gc               = ghid_destroy_gc;
-  ghid_hid.use_mask                 = ghid_use_mask;
-  ghid_hid.set_color                = ghid_set_color;
-  ghid_hid.set_line_cap             = ghid_set_line_cap;
-  ghid_hid.set_line_width           = ghid_set_line_width;
-  ghid_hid.draw_line                = ghid_draw_line;
-  ghid_hid.draw_arc                 = ghid_draw_arc;
-  ghid_hid.draw_rect                = ghid_draw_rect;
-  ghid_hid.fill_circle              = ghid_fill_circle;
-  ghid_hid.fill_polygon             = ghid_fill_polygon;
-  ghid_hid.fill_rect                = ghid_fill_rect;
-#endif
+
+  ghid_gapi.make_gc                  = ghid_make_gc;
+  ghid_gapi.destroy_gc               = ghid_destroy_gc;
+  ghid_gapi.use_mask                 = ghid_use_mask;
+  ghid_gapi.set_color                = ghid_set_color;
+  ghid_gapi.set_line_cap             = ghid_set_line_cap;
+  ghid_gapi.set_line_width           = ghid_set_line_width;
+  ghid_gapi.draw_line                = ghid_draw_line;
+  ghid_gapi.draw_arc                 = ghid_draw_arc;
+  ghid_gapi.draw_rect                = ghid_draw_rect;
+  ghid_gapi.fill_circle              = ghid_fill_circle;
+  ghid_gapi.fill_polygon             = ghid_fill_polygon;
+  ghid_gapi.fill_rect                = ghid_fill_rect;
+
   ghid_hid.calibrate                = ghid_calibrate;
   ghid_hid.shift_is_pressed         = ghid_shift_is_pressed;
   ghid_hid.control_is_pressed       = ghid_control_is_pressed;
diff --git a/src/hid/lesstif/main.c b/src/hid/lesstif/main.c
index 99b3058..3cf390e 100644
--- a/src/hid/lesstif/main.c
+++ b/src/hid/lesstif/main.c
@@ -821,7 +821,7 @@ Benchmark (int argc, char **argv, Coord x, Coord y)
   do
     {
       XFillRectangle (display, pixmap, bg_gc, 0, 0, view_width, view_height);
-      hid_expose_callback (&lesstif_hid, &region, 0);
+//      hid_expose_callback (&lesstif_hid, &region, 0);
       XSync (display, 0);
       time (&end);
       i++;
@@ -2572,7 +2572,7 @@ idle_proc (XtPointer dummy)
 	    }
 	}
       DrawBackgroundImage();
-      hid_expose_callback (&lesstif_hid, &region, 0);
+//      hid_expose_callback (&lesstif_hid, &region, 0);
       draw_grid ();
       lesstif_use_mask (0);
       show_crosshair (0); /* To keep the drawn / not drawn info correct */
@@ -3779,7 +3779,7 @@ pinout_callback (Widget da, PinoutData * pd,
   region.Y2 = PCB->MaxHeight;
 
   XFillRectangle (display, pixmap, bg_gc, 0, 0, pd->v_width, pd->v_height);
-  hid_expose_callback (&lesstif_hid, &region, pd->item);
+//  hid_expose_callback (&lesstif_hid, &region, pd->item);
 
   pinout = 0;
   view_left_x = save_vx;
diff --git a/src/hid/nelma/nelma.c b/src/hid/nelma/nelma.c
index c0618ed..c8266ce 100644
--- a/src/hid/nelma/nelma.c
+++ b/src/hid/nelma/nelma.c
@@ -645,7 +645,7 @@ nelma_start_png_export()
 	linewidth = -1;
 	lastbrush = (gdImagePtr)((void *) -1);
 
-	hid_expose_callback(&nelma_hid, &region, 0);
+//	hid_expose_callback(&nelma_hid, &region, 0);
 }
 
 static void 
diff --git a/src/hid/png/png.c b/src/hid/png/png.c
index 9e95ae3..3b0ae8c 100644
--- a/src/hid/png/png.c
+++ b/src/hid/png/png.c
@@ -543,7 +543,7 @@ png_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
 	}
     }
 
-  hid_expose_callback (&png_hid, bounds, 0);
+//  hid_expose_callback (&png_hid, bounds, 0);
 
   memcpy (LayerStack, saved_layer_stack, sizeof (LayerStack));
   PCB->Flags = save_flags;
diff --git a/src/hid/ps/eps.c b/src/hid/ps/eps.c
index a977545..9e0e2b5 100644
--- a/src/hid/ps/eps.c
+++ b/src/hid/ps/eps.c
@@ -305,7 +305,7 @@ eps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
   fprintf (f,
 	   "/a { gsave setlinewidth translate scale 0 0 1 5 3 roll arc stroke grestore} bind def\n");
 
-  hid_expose_callback (&eps_hid, bounds, 0);
+//  hid_expose_callback (&eps_hid, bounds, 0);
 
   fprintf (f, "showpage\n");
 
diff --git a/src/hid/ps/ps.c b/src/hid/ps/ps.c
index 624eb7c..441c85c 100644
--- a/src/hid/ps/ps.c
+++ b/src/hid/ps/ps.c
@@ -689,13 +689,13 @@ ps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
 
       global.doing_toc = 1;
       global.pagecount = 1;  /* 'pagecount' is modified by hid_expose_callback() call */
-      hid_expose_callback (&ps_hid, &global.region, 0);
+//      hid_expose_callback (&ps_hid, &global.region, 0);
     }
 
   global.pagecount = 1; /* Reset 'pagecount' if single file */
   global.doing_toc = 0;
   ps_set_layer (NULL, 0, -1);  /* reset static vars */
-  hid_expose_callback (&ps_hid, &global.region, 0);
+//  hid_expose_callback (&ps_hid, &global.region, 0);
 
   if (the_file)
     fprintf (the_file, "showpage\n");

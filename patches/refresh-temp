Bottom: bae8a576cac7ccfc3e41e0f43f939e0793c30c3e
Top:    1e273401724f9d7bffb2ba3318e170a4946ac9a8
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-06-05 12:37:02 +0100

Refresh of debug-self-touching-contour-st

---

diff --git a/src/hid/common/draw_helpers.c b/src/hid/common/draw_helpers.c
index 76dcccf..10dbb7f 100644
--- a/src/hid/common/draw_helpers.c
+++ b/src/hid/common/draw_helpers.c
@@ -161,12 +161,16 @@ void common_fill_pcb_polygon (hidGC gc, PolygonType *poly,
       PLINE *pl;
 
       for (pl = poly->NoHoles; pl != NULL; pl = pl->next)
+#if 1
+        thindraw_contour (gc, pl);
+#else
         {
           if (clip_box == NULL)
             fill_contour (gc, pl);
           else
             fill_clipped_contour (gc, pl, clip_box);
         }
+#endif
     }
 #endif
 
diff --git a/src/polygon.c b/src/polygon.c
index 6b46915..adf6995 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -120,7 +120,7 @@ RCSID ("$Id$");
 #define CIRC_SEGS 40
 static double circleVerticies[] = {
   1.0, 0.0,
-  0.98768834059513777, 0.15643446504023087,
+  cos(2. * M_PI / CIRC_SEGS), sin (2. * M_PI / CIRC_SEGS),
 };
 
 static void
@@ -786,8 +786,16 @@ struct cpInfo
 static void
 subtract_accumulated (struct cpInfo *info, PolygonTypePtr polygon)
 {
+  POLYAREA *curp;
   if (info->accumulate == NULL)
     return;
+  printf ("Subtracting accumulated polygons\n");
+
+  curp = info->accumulate;
+  do {
+    printf ("Polygon\n");
+  } while ((curp = curp->f) != info->accumulate);
+  printf ("--------------\n");
   Subtract (info->accumulate, polygon, true);
   info->accumulate = NULL;
   info->batch_size = 0;
@@ -824,7 +832,9 @@ pin_sub_callback (const BoxType * b, void *cl)
         longjmp (info->env, 1);
     }
 
+  printf (" -- Appending pin / via to accumulated poly\n");
   poly_Boolean_free (info->accumulate, np, &merged, PBO_UNITE);
+  printf (" -- Done\n");
   info->accumulate = merged;
 
   info->batch_size ++;
diff --git a/src/polygon1.c b/src/polygon1.c
index 03b02cd..82cb08b 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -1921,6 +1921,9 @@ M_POLYAREA_separate_isected (jmp_buf * e, POLYAREA ** pieces,
 	  int is_last = contour_is_last (curc);
 	  int isect_contour = (curc->Flags.status == ISECTED);
 
+          if (isect_contour)
+            printf ("Contour intersected\n");
+
 	  next = curc->next;
 
 	  if (isect_contour || hole_contour)
@@ -2386,12 +2389,31 @@ poly_Boolean_free (POLYAREA * ai, POLYAREA * bi, POLYAREA ** res, int action)
       *res = a;
       M_POLYAREA_update_primary (&e, res, &holes, action, b);
       M_POLYAREA_separate_isected (&e, res, &holes, &a_isected);
+      {
+        POLYAREA *curp = *res;
+        int count = 0;
+        if (*res != NULL) do {count++;} while ((curp = curp->f) != *res);
+        printf ("%i Polygons after separate_isected\n", count);
+      }
       M_POLYAREA_label_separated (a_isected, b, FALSE);
       M_POLYAREA_Collect_separated (&e, a_isected, res, &holes, action,
 				    FALSE);
+      {
+        POLYAREA *curp = *res;
+        int count = 0;
+        if (*res != NULL) do {count++;} while ((curp = curp->f) != *res);
+        printf ("%i Polygons after Collect_separated\n", count);
+      }
       M_B_AREA_Collect (&e, b, res, &holes, action);
       poly_Free (&b);
 
+      {
+        POLYAREA *curp = *res;
+        int count = 0;
+        if (*res != NULL) do {count++;} while ((curp = curp->f) != *res);
+        printf ("%i Polygons after M_B_AREA_Collect\n", count);
+      }
+
       /* free a_isected */
       while ((p = a_isected) != NULL)
 	{

Bottom: 3c13f87a268727826f7b32a853ca99f133361946
Top:    bbb51197d6f982348c1cb9a4e34ca51b18f7a092
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2015-01-11 23:23:24 +0000

Refresh of attempt-at-re-writing-drawing

---

diff --git a/src/draw.c b/src/draw.c
index c49bc84..c9fbe2b 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -162,7 +162,9 @@ pad_callback (const BoxType * b, void *cl)
 static void
 draw_element_name (hidGC gc, ElementType *element)
 {
-  if ((TEST_FLAG (HIDENAMESFLAG, PCB) && hid_draw_is_gui (gc->hid_draw)) ||
+  HID_DRAW *hid_draw = gc->hid_draw;
+
+  if ((TEST_FLAG (HIDENAMESFLAG, PCB) && hid_draw_is_gui (hid_draw)) ||
       TEST_FLAG (HIDENAMEFLAG, element))
     return;
   ghid_set_lock_effects (gc, (AnyObjectType *)element);
@@ -350,11 +352,11 @@ DrawEverything (hidGC gc)
       info.side = SWAP_IDENT ? TOP_SIDE : BOTTOM_SIDE;
       if (PCB->ElementOn)
 	{
-	  r_search (PCB->Data->element_tree, gc->clip_box, NULL, element_callback, &info);
-	  r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], gc->clip_box, NULL, name_callback, &info);
+	  r_search (PCB->Data->element_tree, hid_draw->clip_box, NULL, element_callback, &info);
+	  r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], hid_draw->clip_box, NULL, name_callback, &info);
 	  dapi->draw_layer (gc, &(PCB->Data->Layer[max_copper_layer + info.side]), NULL);
 	}
-      r_search (PCB->Data->pad_tree, gc->clip_box, NULL, pad_callback, &info);
+      r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_callback, &info);
       hid_draw_end_layer (hid_draw);
     }
 
@@ -378,7 +380,7 @@ DrawEverything (hidGC gc)
     dapi->draw_ppv (gc, SWAP_IDENT ? bottom_group : top_group, NULL);
   else
     {
-      CountHoles (&plated, &unplated, gc->clip_box);
+      CountHoles (&plated, &unplated, hid_draw->clip_box);
 
       if (plated && hid_draw_set_layer (hid_draw, "plated-drill", SL (PDRILL, 0), 0))
         {
@@ -422,7 +424,7 @@ DrawEverything (hidGC gc)
     {
       /* Draw element Marks */
       if (PCB->PinOn)
-	r_search (PCB->Data->element_tree, gc->clip_box, NULL, EMark_callback, gc);
+	r_search (PCB->Data->element_tree, hid_draw->clip_box, NULL, EMark_callback, gc);
       /* Draw rat lines on top */
       if (hid_draw_set_layer (hid_draw, "rats", SL (RATS, 0), 0))
         {
@@ -544,6 +546,7 @@ void
 DrawSilk (hidGC gc, int side)
 {
   struct side_info info;
+  HID_DRAW *hid_draw = gc->hid_draw;
 
   info.gc = gc;
   info.side = side;
@@ -557,29 +560,29 @@ DrawSilk (hidGC gc, int side)
 #if 0
   if (hid_draw->poly_before)
     {
-      hid_draw_use_mask (gc->hid_draw, HID_MASK_BEFORE);
+      hid_draw_use_mask (hid_draw, HID_MASK_BEFORE);
 #endif
       dapi->draw_layer (gc, LAYER_PTR (max_copper_layer + side), NULL);
       /* draw package */
-      r_search (PCB->Data->element_tree, gc->clip_box, NULL, element_callback, &info);
-      r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], gc->clip_box, NULL, name_callback, &info);
+      r_search (PCB->Data->element_tree, hid_draw->clip_box, NULL, element_callback, &info);
+      r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], hid_draw->clip_box, NULL, name_callback, &info);
 #if 0
     }
 
-  hid_draw_use_mask (gc->hid_draw, HID_MASK_CLEAR);
-  r_search (PCB->Data->pin_tree, gc->clip_box, NULL, pin_mask_callback, gc);
-  r_search (PCB->Data->via_tree, gc->clip_box, NULL, via_mask_callback, gc);
-  r_search (PCB->Data->pad_tree, gc->clip_box, NULL, pad_mask_callback, &info);
+  hid_draw_use_mask (hid_draw, HID_MASK_CLEAR);
+  r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_mask_callback, gc);
+  r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, via_mask_callback, gc);
+  r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_mask_callback, &info);
 
   if (hid_draw->poly_after)
     {
       hid_draw_use_mask (gc, hid_draw, HID_MASK_AFTER);
       dapi->draw_layer (gc, LAYER_PTR (max_copper_layer + layer), NULL);
       /* draw package */
-      r_search (PCB->Data->element_tree, gc->clip_box, NULL, element_callback, &side);
-      r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], gc->clip_box, NULL, name_callback, &info);
+      r_search (PCB->Data->element_tree, hid_draw->clip_box, NULL, element_callback, &side);
+      r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], hid_draw->clip_box, NULL, name_callback, &info);
     }
-  hid_draw_use_mask (gc->hid_draw, HID_MASK_OFF);
+  hid_draw_use_mask (hid_draw, HID_MASK_OFF);
 #endif
 }
 
@@ -587,18 +590,20 @@ DrawSilk (hidGC gc, int side)
 static void
 DrawMaskBoardArea (hidGC gc, int mask_type)
 {
+  HID_DRAW *hid_draw = gc->hid_draw;
+
   /* Skip the mask drawing if the GUI doesn't want this type */
-  if ((mask_type == HID_MASK_BEFORE && !gc->hid_draw->poly_before) ||
-      (mask_type == HID_MASK_AFTER  && !gc->hid_draw->poly_after))
+  if ((mask_type == HID_MASK_BEFORE && !hid_draw->poly_before) ||
+      (mask_type == HID_MASK_AFTER  && !hid_draw->poly_after))
     return;
 
-  hid_draw_use_mask (gc->hid_draw, mask_type);
+  hid_draw_use_mask (hid_draw, mask_type);
   hid_draw_set_color (gc, PCB->MaskColor);
-  if (gc->clip_box == NULL)
+  if (hid_draw->clip_box == NULL)
     hid_draw_fill_rect (gc, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
   else
-    hid_draw_fill_rect (gc, gc->clip_box->X1, gc->clip_box->Y1,
-                            gc->clip_box->X2, gc->clip_box->Y2);
+    hid_draw_fill_rect (gc, hid_draw->clip_box->X1, hid_draw->clip_box->Y1,
+                            hid_draw->clip_box->X2, hid_draw->clip_box->Y2);
 }
 
 static int
@@ -653,6 +658,7 @@ DrawMask (hidGC gc, int side)
   int thin = TEST_FLAG(THINDRAWFLAG, PCB) || TEST_FLAG(THINDRAWPOLYFLAG, PCB);
   LayerType *Layer = LAYER_PTR (side == TOP_SIDE ? top_soldermask_layer : bottom_soldermask_layer);
   struct side_info info;
+  HID_DRAW *hid_draw = gc->hid_draw;
 
   info.gc = gc;
   info.side = side;
@@ -662,24 +668,24 @@ DrawMask (hidGC gc, int side)
   else
     {
       DrawMaskBoardArea (gc, HID_MASK_BEFORE);
-      hid_draw_use_mask (gc->hid_draw, HID_MASK_CLEAR);
+      hid_draw_use_mask (hid_draw, HID_MASK_CLEAR);
     }
 
-  r_search (Layer->polygon_tree, gc->clip_box, NULL, mask_poly_callback, gc);
-  r_search (Layer->line_tree,    gc->clip_box, NULL, mask_line_callback, gc);
-  r_search (Layer->arc_tree,     gc->clip_box, NULL, mask_arc_callback,  gc);
-  r_search (Layer->text_tree,    gc->clip_box, NULL, mask_text_callback, gc);
+  r_search (Layer->polygon_tree, hid_draw->clip_box, NULL, mask_poly_callback, gc);
+  r_search (Layer->line_tree,    hid_draw->clip_box, NULL, mask_line_callback, gc);
+  r_search (Layer->arc_tree,     hid_draw->clip_box, NULL, mask_arc_callback,  gc);
+  r_search (Layer->text_tree,    hid_draw->clip_box, NULL, mask_text_callback, gc);
 
-  r_search (PCB->Data->pin_tree, gc->clip_box, NULL, pin_mask_callback, gc);
-  r_search (PCB->Data->via_tree, gc->clip_box, NULL, via_mask_callback, gc);
-  r_search (PCB->Data->pad_tree, gc->clip_box, NULL, pad_mask_callback, &info);
+  r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_mask_callback, gc);
+  r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, via_mask_callback, gc);
+  r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_mask_callback, &info);
 
   if (thin)
     hid_draw_set_color (Output.pmGC, "erase");
   else
     {
       DrawMaskBoardArea (gc, HID_MASK_AFTER);
-      hid_draw_use_mask (gc->hid_draw, HID_MASK_OFF);
+      hid_draw_use_mask (hid_draw, HID_MASK_OFF);
     }
 }
 
@@ -701,17 +707,19 @@ DrawPaste (hidGC gc, int side)
 /* static */ void
 DrawRats (hidGC gc)
 {
+  HID_DRAW *hid_draw = gc->hid_draw;
+
   /*
    * XXX lesstif allows positive AND negative drawing in HID_MASK_CLEAR.
    * XXX gtk only allows negative drawing.
    * XXX using the mask here is to get rat transparency
    */
 
-  if (hid_draw_can_draw_in_mask_clear (gc->hid_draw))
-    hid_draw_use_mask (gc->hid_draw, HID_MASK_CLEAR);
-  r_search (PCB->Data->rat_tree, gc->clip_box, NULL, rat_callback, gc);
-  if (hid_draw_can_draw_in_mask_clear (gc->hid_draw))
-    hid_draw_use_mask (gc->hid_draw, HID_MASK_OFF);
+  if (hid_draw_can_draw_in_mask_clear (hid_draw))
+    hid_draw_use_mask (hid_draw, HID_MASK_CLEAR);
+  r_search (PCB->Data->rat_tree, hid_draw->clip_box, NULL, rat_callback, gc);
+  if (hid_draw_can_draw_in_mask_clear (hid_draw))
+    hid_draw_use_mask (hid_draw, HID_MASK_OFF);
 }
 
 /* ---------------------------------------------------------------------------
@@ -726,6 +734,7 @@ DrawLayerGroup (hidGC gc, int group)
   LayerType *Layer;
   int n_entries = PCB->LayerGroups.Number[group];
   Cardinal *layers = PCB->LayerGroups.Entries[group];
+  HID_DRAW *hid_draw = gc->hid_draw;
 
   for (i = n_entries - 1; i >= 0; i--)
     {
@@ -740,7 +749,7 @@ DrawLayerGroup (hidGC gc, int group)
   if (n_entries > 1)
     rv = 1;
 
-  if (rv && !hid_draw_is_gui (gc->hid_draw))
+  if (rv && !hid_draw_is_gui (hid_draw))
     dapi->draw_ppv (gc, group, NULL);
 }
 
diff --git a/src/draw_funcs.c b/src/draw_funcs.c
index b47e1ff..41cb651 100644
--- a/src/draw_funcs.c
+++ b/src/draw_funcs.c
@@ -351,6 +351,7 @@ pad_callback (const BoxType * b, void *cl)
 static void
 draw_ppv (hidGC gc, int group, void *userdata)
 {
+  HID_DRAW *hid_draw = gc->hid_draw;
   int top_group = GetLayerGroupNumberBySide (TOP_SIDE);
   int bottom_group = GetLayerGroupNumberBySide (BOTTOM_SIDE);
 
@@ -359,7 +360,7 @@ draw_ppv (hidGC gc, int group, void *userdata)
       struct side_info info;
 
       /* draw element pins */
-      r_search (PCB->Data->pin_tree, gc->clip_box, NULL, pin_callback, gc);
+      r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_callback, gc);
 
       info.gc = gc;
       info.layer = NULL; /* Nasty, but saves creating a load of different info types */
@@ -368,19 +369,19 @@ draw_ppv (hidGC gc, int group, void *userdata)
       if (group == top_group)
         {
           info.side = TOP_SIDE;
-          r_search (PCB->Data->pad_tree, gc->clip_box, NULL, pad_callback, &info);
+          r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_callback, &info);
         }
 
       if (group == bottom_group)
         {
           info.side = BOTTOM_SIDE;
-          r_search (PCB->Data->pad_tree, gc->clip_box, NULL, pad_callback, &info);
+          r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_callback, &info);
         }
     }
 
   /* draw vias */
   if (PCB->ViaOn)
-    r_search (PCB->Data->via_tree, gc->clip_box, NULL, via_callback, gc);
+    r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, via_callback, gc);
 
   dapi->draw_holes (gc, -1, NULL);
 }
@@ -388,20 +389,22 @@ draw_ppv (hidGC gc, int group, void *userdata)
 static void
 draw_holes (hidGC gc, int plated, void *userdata)
 {
+  HID_DRAW *hid_draw = gc->hid_draw;
   struct hole_info info;
 
   info.gc = gc;
   info.plated = plated;
 
   if (PCB->PinOn)
-    r_search (PCB->Data->pin_tree, gc->clip_box, NULL, pin_hole_callback, &info);
+    r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_hole_callback, &info);
   if (PCB->ViaOn)
-    r_search (PCB->Data->via_tree, gc->clip_box, NULL, via_hole_callback, &info);
+    r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, via_hole_callback, &info);
 }
 
 static void
 draw_layer (hidGC gc, LayerType *layer, void *userdata)
 {
+  HID_DRAW *hid_draw = gc->hid_draw;
   int top_group = GetLayerGroupNumberBySide (TOP_SIDE);
   int bottom_group = GetLayerGroupNumberBySide (BOTTOM_SIDE);
   int layer_num = GetLayerNumber (PCB->Data, layer);
@@ -420,20 +423,20 @@ draw_layer (hidGC gc, LayerType *layer, void *userdata)
 
   if (layer_num < max_copper_layer && !is_outline)
     {
-      r_search (PCB->Data->pin_tree, gc->clip_box, NULL, pin_hole_callback, &h_info);
-      r_search (PCB->Data->via_tree, gc->clip_box, NULL, via_hole_callback, &h_info);
+      r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_hole_callback, &h_info);
+      r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, via_hole_callback, &h_info);
     }
 
   /* print the non-clearing polys */
-  r_search (layer->polygon_tree, gc->clip_box, NULL, poly_callback, &l_info);
+  r_search (layer->polygon_tree, hid_draw->clip_box, NULL, poly_callback, &l_info);
 
   if (TEST_FLAG (CHECKPLANESFLAG, PCB))
     return;
 
   /* draw all visible lines this layer */
-  r_search (layer->line_tree, gc->clip_box, NULL, line_callback, &l_info);
-  r_search (layer->arc_tree,  gc->clip_box, NULL, arc_callback,  &l_info);
-  r_search (layer->text_tree, gc->clip_box, NULL, text_callback, &l_info);
+  r_search (layer->line_tree, hid_draw->clip_box, NULL, line_callback, &l_info);
+  r_search (layer->arc_tree,  hid_draw->clip_box, NULL, arc_callback,  &l_info);
+  r_search (layer->text_tree, hid_draw->clip_box, NULL, text_callback, &l_info);
 
   /* We should check for gui->gui here, but it's kinda cool seeing the
      auto-outline magically disappear when you first add something to
@@ -458,7 +461,7 @@ draw_layer (hidGC gc, LayerType *layer, void *userdata)
   if (!gui->gui)
     return;
 
-  r_search (PCB->Data->pin_tree, gc->clip_box, NULL, pin_inlayer_callback, &l_info);
+  r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_inlayer_callback, &l_info);
 
   /* draw element pads */
   if (group == top_group ||
@@ -469,11 +472,11 @@ draw_layer (hidGC gc, LayerType *layer, void *userdata)
       s_info.gc = gc;
       s_info.layer = layer;
       s_info.side = (group == bottom_group) ? BOTTOM_SIDE : TOP_SIDE;
-      r_search (PCB->Data->pad_tree, gc->clip_box, NULL, pad_inlayer_callback, &s_info);
+      r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_inlayer_callback, &s_info);
     }
 
   /* draw vias */
-  r_search (PCB->Data->via_tree, gc->clip_box, NULL, via_inlayer_callback, &l_info);
+  r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, via_inlayer_callback, &l_info);
 }
 
 struct draw_funcs d_f = {
diff --git a/src/hid/common/draw_helpers.c b/src/hid/common/draw_helpers.c
index 4a3952c..1be2d15 100644
--- a/src/hid/common/draw_helpers.c
+++ b/src/hid/common/draw_helpers.c
@@ -9,16 +9,16 @@
 
 /* Takes a copy of clip_box so we own it */
 void
-common_set_clip_box (HID_DRAW *graphics, BoxType *clip_box)
+common_set_clip_box (HID_DRAW *hid_draw, BoxType *clip_box)
 {
-  free (graphics->clip_box);
-  graphics->clip_box = NULL;
+  free (hid_draw->clip_box);
+  hid_draw->clip_box = NULL;
 
   if (clip_box == NULL)
     return;
 
-  graphics->clip_box = malloc (sizeof (BoxType));
-  *graphics->clip_box = *clip_box;
+  hid_draw->clip_box = malloc (sizeof (BoxType));
+  *hid_draw->clip_box = *clip_box;
 }
 
 static void
@@ -205,6 +205,7 @@ fill_contour_cb (PLINE *pl, void *user_data)
 static void
 fill_clipped_contour (hidGC gc, PLINE *pl)
 {
+  HID_DRAW *hid_draw = gc->hid_draw;
   PLINE *pl_copy;
   POLYAREA *clip_poly;
   POLYAREA *piece_poly;
@@ -212,8 +213,8 @@ fill_clipped_contour (hidGC gc, PLINE *pl)
   POLYAREA *draw_piece;
   int x;
 
-  clip_poly = RectPoly (gc->clip_box->X1, gc->clip_box->X2,
-                        gc->clip_box->Y1, gc->clip_box->Y2);
+  clip_poly = RectPoly (hid_draw->clip_box->X1, hid_draw->clip_box->X2,
+                        hid_draw->clip_box->Y1, hid_draw->clip_box->Y2);
   poly_CopyContour (&pl_copy, pl);
   piece_poly = poly_Create ();
   poly_InclContour (piece_poly, pl_copy);
@@ -239,18 +240,19 @@ fill_clipped_contour (hidGC gc, PLINE *pl)
 static int
 should_compute_no_holes (hidGC gc, PolygonType *poly)
 {
+  HID_DRAW *hid_draw = gc->hid_draw;
   Coord x1, x2, y1, y2;
   double poly_bounding_area;
   double clipped_poly_area;
 
   /* If there is no passed clip box, compute the whole thing */
-  if (gc->clip_box == NULL)
+  if (hid_draw->clip_box == NULL)
     return 1;
 
-  x1 = MAX (poly->BoundingBox.X1, gc->clip_box->X1);
-  x2 = MIN (poly->BoundingBox.X2, gc->clip_box->X2);
-  y1 = MAX (poly->BoundingBox.Y1, gc->clip_box->Y1);
-  y2 = MIN (poly->BoundingBox.Y2, gc->clip_box->Y2);
+  x1 = MAX (poly->BoundingBox.X1, hid_draw->clip_box->X1);
+  x2 = MIN (poly->BoundingBox.X2, hid_draw->clip_box->X2);
+  y1 = MAX (poly->BoundingBox.Y1, hid_draw->clip_box->Y1);
+  y2 = MIN (poly->BoundingBox.Y2, hid_draw->clip_box->Y2);
 
   /* Check if the polygon is outside the clip box */
   if ((x2 <= x1) || (y2 <= y1))
@@ -294,6 +296,8 @@ common_gui_draw_pcb_polygon (hidGC gc, PolygonType *polygon)
 void
 common_fill_pcb_polygon (hidGC gc, PolygonType *poly)
 {
+  HID_DRAW *hid_draw = gc->hid_draw;
+
   if (poly->Clipped == NULL)
     return;
 
@@ -306,7 +310,7 @@ common_fill_pcb_polygon (hidGC gc, PolygonType *poly)
       if (should_compute_no_holes (gc, poly))
         ComputeNoHoles (poly);
       else
-        NoHolesPolygonDicer (poly, gc->clip_box, fill_contour_cb, gc);
+        NoHolesPolygonDicer (poly, hid_draw->clip_box, fill_contour_cb, gc);
     }
   if (poly->NoHolesValid && poly->NoHoles)
     {
@@ -314,7 +318,7 @@ common_fill_pcb_polygon (hidGC gc, PolygonType *poly)
 
       for (pl = poly->NoHoles; pl != NULL; pl = pl->next)
         {
-          if (gc->clip_box == NULL)
+          if (hid_draw->clip_box == NULL)
             fill_contour (gc, pl);
           else
             fill_clipped_contour (gc, pl);
@@ -330,7 +334,7 @@ common_fill_pcb_polygon (hidGC gc, PolygonType *poly)
       for (p.Clipped = poly->Clipped->f;
            p.Clipped != poly->Clipped;
            p.Clipped = p.Clipped->f)
-        NoHolesPolygonDicer (&p, gc->clip_box, fill_contour_cb, gc);
+        NoHolesPolygonDicer (&p, hid_draw->clip_box, fill_contour_cb, gc);
     }
 }
 
@@ -345,11 +349,13 @@ thindraw_hole_cb (PLINE *pl, void *user_data)
 void
 common_thindraw_pcb_polygon (hidGC gc, PolygonType *poly)
 {
+  HID_DRAW *hid_draw = gc->hid_draw;
+
   if (poly->Clipped == NULL)
     return;
 
   thindraw_contour (gc, poly->Clipped->contours);
-  PolygonHoles (poly, gc->clip_box, thindraw_hole_cb, gc);
+  PolygonHoles (poly, hid_draw->clip_box, thindraw_hole_cb, gc);
 
   /* Draw other parts of the polygon if fullpoly flag is set */
   if (TEST_FLAG (FULLPOLYFLAG, poly))
@@ -361,7 +367,7 @@ common_thindraw_pcb_polygon (hidGC gc, PolygonType *poly)
            p.Clipped = p.Clipped->f)
         {
           thindraw_contour (gc, p.Clipped->contours);
-          PolygonHoles (&p, gc->clip_box, thindraw_hole_cb, gc);
+          PolygonHoles (&p, hid_draw->clip_box, thindraw_hole_cb, gc);
         }
     }
 }
@@ -688,6 +694,6 @@ common_draw_helpers_class_init (HID_DRAW_CLASS *klass)
 }
 
 void
-common_draw_helpers_init (HID_DRAW *graphics)
+common_draw_helpers_init (HID_DRAW *hid_draw)
 {
 }
diff --git a/src/hid/common/draw_helpers.h b/src/hid/common/draw_helpers.h
index 1c13d34..ea5c880 100644
--- a/src/hid/common/draw_helpers.h
+++ b/src/hid/common/draw_helpers.h
@@ -11,5 +11,5 @@ void common_fill_pcb_pv_hole (hidGC gc, PinType *pv);
 void common_thindraw_pcb_pv (hidGC gc, PinType *pv, bool mask);
 void common_thindraw_pcb_pv_hole (hidGC gc, PinType *pv);
 void common_draw_helpers_class_init (HID_DRAW_CLASS *klass);
-void common_draw_helpers_init (HID_DRAW *graphics);
-void common_set_clip_box (HID_DRAW *graphics, BoxType *clip_box);
+void common_draw_helpers_init (HID_DRAW *hid_draw);
+void common_set_clip_box (HID_DRAW *hid_draw, BoxType *clip_box);
diff --git a/src/hid/common/extents.c b/src/hid/common/extents.c
index 7927e76..58949c4 100644
--- a/src/hid/common/extents.c
+++ b/src/hid/common/extents.c
@@ -210,15 +210,11 @@ hid_extents_init (void)
 BoxType *
 hid_get_extents (void *item)
 {
-  hidGC gc;
   BoxType region;
 
   /* As this isn't a real "HID", we need to ensure we are initialised. */
   hid_extents_init ();
 
-#warning NULL gc
-  gc = NULL;
-
   box.X1 = COORD_MAX;
   box.Y1 = COORD_MAX;
   box.X2 = -COORD_MAX - 1;
diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index ca0bcc7..f65293a 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -189,7 +189,7 @@ hidgl_init_triangle_array (HID_DRAW *hid_draw)
   priv->buffer.use_map = false;
 
   priv->buffer.triangle_array = NULL;
-  hidgl_reset_triangle_array (hidgl);
+  hidgl_reset_triangle_array (hid_draw);
 }
 
 static void
@@ -253,13 +253,12 @@ hidgl_flush_triangles (HID_DRAW *hid_draw)
   glDisableClientState (GL_VERTEX_ARRAY);
   glDisableClientState (GL_TEXTURE_COORD_ARRAY);
 
-  hidgl_reset_triangle_array (hidgl);
+  hidgl_reset_triangle_array (hid_draw);
 }
 
 void
 hidgl_ensure_vertex_space (hidGC gc, int count)
 {
-  hidglGC hidgl_gc = (hidglGC)gc;
   HID_DRAW *hid_draw = gc->hid_draw;
   hidgl_priv *priv = hid_draw->priv;
 
@@ -273,7 +272,7 @@ hidgl_ensure_vertex_space (hidGC gc, int count)
       exit (1);
     }
   if (count > 3 * TRIANGLE_ARRAY_SIZE - priv->buffer.vertex_count)
-    hidgl_flush_triangles (hidgl);
+    hidgl_flush_triangles (hid_draw);
 }
 
 void
@@ -286,7 +285,7 @@ hidgl_ensure_triangle_space (hidGC gc, int count)
 }
 
 void
-hidgl_set_depth (HID_DRAW *hid_draw, float depth)
+hidgl_set_depth (hidGC gc, float depth)
 {
   hidglGC hidgl_gc = (hidglGC)gc;
 
@@ -297,6 +296,7 @@ void
 hidgl_draw_grid (hidGC gc)
 {
   hidglGC hidgl_gc = (hidglGC)gc;
+  HID_DRAW *hid_draw = gc->hid_draw;
 
   static GLfloat *points = 0;
   static int npoints = 0;
@@ -306,10 +306,10 @@ hidgl_draw_grid (hidGC gc)
   if (!Settings.DrawGrid)
     return;
 
-  x1 = GridFit (MAX (0, gc->clip_box->X1), PCB->Grid, PCB->GridOffsetX);
-  y1 = GridFit (MAX (0, gc->clip_box->Y1), PCB->Grid, PCB->GridOffsetY);
-  x2 = GridFit (MIN (PCB->MaxWidth,  gc->clip_box->X2), PCB->Grid, PCB->GridOffsetX);
-  y2 = GridFit (MIN (PCB->MaxHeight, gc->clip_box->Y2), PCB->Grid, PCB->GridOffsetY);
+  x1 = GridFit (MAX (0, hid_draw->clip_box->X1), PCB->Grid, PCB->GridOffsetX);
+  y1 = GridFit (MAX (0, hid_draw->clip_box->Y1), PCB->Grid, PCB->GridOffsetY);
+  x2 = GridFit (MIN (PCB->MaxWidth,  hid_draw->clip_box->X2), PCB->Grid, PCB->GridOffsetX);
+  y2 = GridFit (MIN (PCB->MaxHeight, hid_draw->clip_box->Y2), PCB->Grid, PCB->GridOffsetY);
 
   if (x1 > x2)
     {
@@ -916,7 +916,6 @@ polygon_contains_user_holes (PolygonType *polygon)
 static void
 fill_polyarea (hidGC gc, POLYAREA *pa, bool use_new_stencil)
 {
-  hidglGC hidgl_gc = (hidglGC)gc;
   HID_DRAW *hid_draw = gc->hid_draw;
   hidgl_priv *priv = hid_draw->priv;
   int stencil_bit;
@@ -934,7 +933,7 @@ fill_polyarea (hidGC gc, POLYAREA *pa, bool use_new_stencil)
    */
   if (use_new_stencil)
     {
-      stencil_bit = hidgl_assign_clear_stencil_bit (hidgl);
+      stencil_bit = hidgl_assign_clear_stencil_bit (hid_draw);
       if (!stencil_bit)
         {
           printf ("hidgl_fill_pcb_polygon: No free stencil bits, aborting polygon\n");
@@ -944,7 +943,7 @@ fill_polyarea (hidGC gc, POLYAREA *pa, bool use_new_stencil)
     }
 
   /* Flush out any existing geoemtry to be rendered */
-  hidgl_flush_triangles (hidgl);
+  hidgl_flush_triangles (hid_draw);
 
   glPushAttrib (GL_STENCIL_BUFFER_BIT |                 /* Resave the stencil write-mask etc.., and */
                 GL_COLOR_BUFFER_BIT |                   /* the colour buffer write mask etc.. for part way restore */
@@ -971,8 +970,8 @@ fill_polyarea (hidGC gc, POLYAREA *pa, bool use_new_stencil)
 
   /* Drawing operations now set our reference bit in the stencil buffer */
 
-  r_search (pa->contour_tree, gc->clip_box, NULL, do_hole, gc);
-  hidgl_flush_triangles (hidgl);
+  r_search (pa->contour_tree, hid_draw->clip_box, NULL, do_hole, gc);
+  hidgl_flush_triangles (hid_draw);
 
   glPopAttrib ();                                   /* Restore the colour and stencil buffer write-mask etc.. */
   glPushAttrib (GL_STENCIL_BUFFER_BIT);             /* Save the stencil op and function */
@@ -989,11 +988,11 @@ fill_polyarea (hidGC gc, POLYAREA *pa, bool use_new_stencil)
 
   /* Draw the polygon outer */
   fill_contour (gc, pa->contours);
-  hidgl_flush_triangles (hidgl);
+  hidgl_flush_triangles (hid_draw);
 
   /* Unassign our stencil buffer bit */
   if (use_new_stencil)
-    hidgl_return_stencil_bit (hidgl, stencil_bit);
+    hidgl_return_stencil_bit (hid_draw, stencil_bit);
 
   glPopAttrib ();                               /* Restore the stencil buffer op and function */
 }
@@ -1136,13 +1135,17 @@ hidgl_init (void)
   called = true;
 }
 
-HID_DRAW *
-hidgl_new_instance (void)
+void
+hidgl_class_init (HID_DRAW_CLASS *klass)
+{
+  /* XXX: For now, our sub-classes have all the v-func methods, and they call us as required */
+}
+
+void
+hidgl_instance_init (HID_DRAW *hid_draw)
 {
-  HID_DRAW *hid_draw;
   hidgl_priv *priv;
 
-  hid_draw = calloc (1, sizeof (*hid_draw));
   priv = calloc (1, sizeof (hidgl_priv));
   hid_draw->priv = priv;
 
@@ -1162,11 +1165,9 @@ hidgl_new_instance (void)
       /* Do we need to disable that somewhere? */
     }
 
-  hidgl_reset_stencil_usage (hidgl);
+  hidgl_reset_stencil_usage (hid_draw);
 #endif
-//  hidgl_init_triangle_array (hidgl);
-
-  return hid_draw;
+//  hidgl_init_triangle_array (hid_draw);
 }
 
 void
@@ -1229,7 +1230,7 @@ hidgl_start_render (HID_DRAW *hid_draw)
     }
 #endif
 
-  hidgl_init_triangle_array (hidgl);
+  hidgl_init_triangle_array (hid_draw);
   hidgl_shader_activate (/*priv->*/circular_program);
 }
 
@@ -1298,7 +1299,7 @@ hidgl_assign_clear_stencil_bit (HID_DRAW *hid_draw)
     }
 
   /* Didn't find any non dirty planes. Clear those dirty ones which aren't in use */
-  hidgl_clean_unassigned_stencil (hidgl);
+  hidgl_clean_unassigned_stencil (hid_draw);
   priv->assigned_bits |= first_dirty;
   priv->dirty_bits = priv->assigned_bits;
 
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index 8f353f2..042476b 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -148,7 +148,7 @@ hidgl_add_triangle (hidGC gc,
 }
 
 void hidgl_draw_grid (hidGC gc);
-void hidgl_set_depth (HID_DRAW *hid_draw, float depth);
+void hidgl_set_depth (hidGC gc, float depth);
 void hidgl_draw_line (hidGC gc, int cap, Coord width, Coord x1, Coord y1, Coord x2, Coord y2, double scale);
 void hidgl_draw_arc (hidGC gc, Coord width, Coord vx, Coord vy, Coord vrx, Coord vry, Angle start_angle, Angle delta_angle, double scale);
 void hidgl_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2);
@@ -159,6 +159,8 @@ void hidgl_fill_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2);
 
 void hidgl_init (void);
 HID_DRAW *hidgl_new_instance (void);
+void hidgl_class_init (HID_DRAW_CLASS *klass);
+void hidgl_instance_init (HID_DRAW *hid_draw);
 void hidgl_free_instance (HID_DRAW *hid_draw);
 void hidgl_init_gc (HID_DRAW *hid_draw, hidGC gc);
 void hidgl_finish_gc (hidGC gc);
diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index d29a634..1606466 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -15,7 +15,8 @@
 #endif
 
 extern HID ghid_hid;
-extern HID_DRAW ghid_graphics;
+HID_DRAW ghid_graphics;
+extern HID_DRAW_CLASS ghid_graphics_class;
 
 /* Sets priv->u_gc to the "right" GC to use (wrt mask or window)
 */
@@ -1114,9 +1115,18 @@ draw_crosshair (render_priv *priv)
 void
 ghid_init_renderer (int *argc, char ***argv, GHidPort *port)
 {
+  /* Init ghid_graphics HID_DRAW instance */
+  memset (&ghid_graphics, 0, sizeof (HID_DRAW));
+
+  ghid_graphics.klass = &ghid_graphics_class;
+  ghid_graphics.poly_after = true;
+  common_draw_helpers_init (&ghid_graphics);
+
   /* Init any GC's required */
   port->render_priv = g_new0 (render_priv, 1);
   port->render_priv->crosshair_gc = hid_draw_make_gc (&ghid_graphics);
+
+  ghid_graphics .
 }
 
 void
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 862db7f..3a8ac0e 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -52,7 +52,7 @@ extern PFNGLUSEPROGRAMPROC         glUseProgram;
 //#define VIEW_ORTHO
 
 extern HID ghid_hid;
-extern HID_DRAW ghid_graphics;
+static HID_DRAW ghid_graphics;
 extern HID_DRAW_CLASS ghid_graphics_class;
 
 /* Sets gport->u_gc to the "right" GC to use (wrt mask or window)
@@ -271,6 +271,21 @@ end_subcomposite (HID_DRAW *hid_draw)
   priv->subcomposite_stencil_bit = 0;
 }
 
+static void
+set_depth_on_all_active_gc (render_priv *priv, float depth)
+{
+  GList *iter;
+
+  for (iter = priv->active_gc_list;
+       iter != NULL;
+       iter = g_list_next (iter))
+    {
+      hidGC gc = iter->data;
+
+      hidgl_set_depth (gc, depth);
+    }
+}
+
 /* Compute group visibility based upon on copper layers only */
 static bool
 is_layer_group_visible (int group)
@@ -340,7 +355,7 @@ ghid_set_layer (HID_DRAW *hid_draw, const char *name, int group, int empty)
     start_subcomposite (hid_draw);
 
   /* Drawing is already flushed by {start,end}_subcomposite */
-  hidgl_set_depth (hid_draw, compute_depth (group));
+  set_depth_on_all_active_gc (priv, compute_depth (group));
 
   return group_visible;
 }
@@ -370,7 +385,7 @@ ghid_make_gc (HID_DRAW *hid_draw)
   gtkGC gtk_gc = (gtkGC)gc;
 
   gc->hid = &ghid_hid;
-  gc->hid_draw = &ghid_graphics;
+  gc->hid_draw = hid_draw;
 
   hidgl_init_gc (hid_draw, gc);
 
@@ -1078,12 +1093,23 @@ ghid_init_renderer (int *argc, char ***argv, GHidPort *port)
     }
 
   hidgl_init ();
-  priv->hid_draw = hidgl_new_instance ();
 
   /* Setup HID function pointers specific to the GL renderer*/
+  hidgl_class_init (&ghid_graphics_class);
+
   ghid_graphics_class.end_layer = ghid_end_layer;
   ghid_graphics_class._fill_pcb_polygon = ghid_fill_pcb_polygon;
   ghid_graphics_class._thindraw_pcb_polygon = ghid_thindraw_pcb_polygon;
+
+  /* Init ghid_graphics HID_DRAW instance */
+  memset (&ghid_graphics, 0, sizeof (HID_DRAW));
+
+  ghid_graphics.klass = &ghid_graphics_class;
+  ghid_graphics.poly_after = true;
+  common_draw_helpers_init (&ghid_graphics);
+  hidgl_instance_init (&ghid_graphics);
+
+  priv->hid_draw = &ghid_graphics;
 }
 
 void
@@ -1630,8 +1656,8 @@ fill_board_outline (hidGC gc)
 
   memset (&polygon, 0, sizeof (polygon));
   polygon.Clipped = PCB->Data->outline;
-  if (gc->clip_box)
-    polygon.BoundingBox = *gc->clip_box;
+  if (gc->hid_draw->clip_box)
+    polygon.BoundingBox = *gc->hid_draw->clip_box;
   polygon.Flags = NoFlags ();
   SET_FLAG (FULLPOLYFLAG, &polygon);
   hid_draw__fill_pcb_polygon (gc, &polygon);
@@ -1686,20 +1712,20 @@ fill_board_outline_holes (hidGC gc)
 
   memset (&polygon, 0, sizeof (polygon));
   polygon.Clipped = PCB->Data->outline;
-  if (gc->clip_box)
-    polygon.BoundingBox = *gc->clip_box;
+  if (gc->hid_draw->clip_box)
+    polygon.BoundingBox = *gc->hid_draw->clip_box;
   polygon.Flags = NoFlags ();
   SET_FLAG (FULLPOLYFLAG, &polygon);
 
   info.gc = gc;
 
-  PolygonHoles (&polygon, gc->clip_box, fill_outline_hole_cb, &info);
+  PolygonHoles (&polygon, gc->hid_draw->clip_box, fill_outline_hole_cb, &info);
 
   p = polygon;
   for (p.Clipped = polygon.Clipped->f;
        p.Clipped != polygon.Clipped;
        p.Clipped = p.Clipped->f) {
-    PolygonHoles (&p, gc->clip_box, fill_outline_hole_cb, &info);
+    PolygonHoles (&p, gc->hid_draw->clip_box, fill_outline_hole_cb, &info);
   }
 
 //  poly_FreeContours (&polygon.NoHoles);
@@ -1716,6 +1742,7 @@ GhidDrawMask (hidGC gc, int side)
   LayerType *Layer = LAYER_PTR (side == TOP_SIDE ? top_soldermask_layer : bottom_soldermask_layer);
   struct layer_info l_info;
   struct side_info s_info;
+  HID_DRAW *hid_draw = gc->hid_draw;
 
   l_info.gc = gc;
   l_info.layer = Layer;
@@ -1726,24 +1753,24 @@ GhidDrawMask (hidGC gc, int side)
     {
       hid_draw_set_line_width (Output.pmGC, 0);
       hid_draw_set_color (Output.pmGC, PCB->MaskColor);
-      r_search (PCB->Data->pin_tree, gc->clip_box, NULL, clearPin_callback, NULL);
-      r_search (PCB->Data->via_tree, gc->clip_box, NULL, clearPin_callback, NULL);
-      r_search (PCB->Data->pad_tree, gc->clip_box, NULL, clearPad_callback, &s_info);
+      r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, clearPin_callback, NULL);
+      r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, clearPin_callback, NULL);
+      r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, clearPad_callback, &s_info);
       hid_draw_set_color (Output.pmGC, "erase");
     }
 
-  hid_draw_use_mask (gc->hid_draw, HID_MASK_CLEAR);
+  hid_draw_use_mask (hid_draw, HID_MASK_CLEAR);
 
-  r_search (Layer->polygon_tree, gc->clip_box, NULL, poly_callback, &s_info);
-  r_search (Layer->line_tree, gc->clip_box, NULL, line_callback, &l_info);
-  r_search (Layer->arc_tree, gc->clip_box, NULL, arc_callback, &l_info);
-  r_search (Layer->text_tree, gc->clip_box, NULL, text_callback, &l_info);
+  r_search (Layer->polygon_tree, hid_draw->clip_box, NULL, poly_callback, &s_info);
+  r_search (Layer->line_tree, hid_draw->clip_box, NULL, line_callback, &l_info);
+  r_search (Layer->arc_tree, hid_draw->clip_box, NULL, arc_callback, &l_info);
+  r_search (Layer->text_tree, hid_draw->clip_box, NULL, text_callback, &l_info);
 
-  r_search (PCB->Data->pin_tree, gc->clip_box, NULL, clearPin_callback_solid, NULL);
-  r_search (PCB->Data->via_tree, gc->clip_box, NULL, clearPin_callback_solid, NULL);
-  r_search (PCB->Data->pad_tree, gc->clip_box, NULL, clearPad_callback_solid, &s_info);
+  r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, clearPin_callback_solid, NULL);
+  r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, clearPin_callback_solid, NULL);
+  r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, clearPad_callback_solid, &s_info);
 
-  hid_draw_use_mask (gc->hid_draw, HID_MASK_AFTER);
+  hid_draw_use_mask (hid_draw, HID_MASK_AFTER);
   hid_draw_set_color (gc, PCB->MaskColor);
   ghid_set_alpha_mult (gc, thin ? 0.35 : 1.0);
 
@@ -1782,8 +1809,8 @@ GhidDrawMask (hidGC gc, int side)
 
   memset (&polygon, 0, sizeof (polygon));
   polygon.Clipped = PCB->Data->outline;
-  if (gc->clip_box)
-    polygon.BoundingBox = *gc->clip_box;
+  if (hid_draw->clip_box)
+    polygon.BoundingBox = *hid_draw->clip_box;
   polygon.Flags = NoFlags ();
   SET_FLAG (FULLPOLYFLAG, &polygon);
   hid_draw__fill_pcb_polygon (gc, &polygon);
@@ -1802,7 +1829,7 @@ GhidDrawMask (hidGC gc, int side)
 #endif
   hidgl_shader_activate (circular_program);
 
-  hid_draw_use_mask (gc->hid_draw, HID_MASK_OFF);
+  hid_draw_use_mask (hid_draw, HID_MASK_OFF);
 
 //  first_run = false;
 }
@@ -1860,8 +1887,8 @@ ghid_draw_outline_between_layers (hidGC gc, int from_layer, int to_layer)
 
   memset (&polygon, 0, sizeof (polygon));
   polygon.Clipped = PCB->Data->outline;
-  if (gc->clip_box)
-    polygon.BoundingBox = *gc->clip_box;
+  if (gc->hid_draw->clip_box)
+    polygon.BoundingBox = *gc->hid_draw->clip_box;
   polygon.Flags = NoFlags ();
   SET_FLAG (FULLPOLYFLAG, &polygon);
 
@@ -1870,14 +1897,14 @@ ghid_draw_outline_between_layers (hidGC gc, int from_layer, int to_layer)
   info.z2 = compute_depth (to_layer);
 
   draw_outline_contour (info.gc, polygon.Clipped->contours, info.z1, info.z2);
-  PolygonHoles (&polygon, gc->clip_box, outline_hole_cb, &info);
+  PolygonHoles (&polygon, gc->hid_draw->clip_box, outline_hole_cb, &info);
 
   p = polygon;
   for (p.Clipped = polygon.Clipped->f;
        p.Clipped != polygon.Clipped;
        p.Clipped = p.Clipped->f) {
     draw_outline_contour (info.gc, p.Clipped->contours, info.z1, info.z2);
-    PolygonHoles (&p, gc->clip_box, outline_hole_cb, &info);
+    PolygonHoles (&p, gc->hid_draw->clip_box, outline_hole_cb, &info);
   }
 
   poly_FreeContours (&polygon.NoHoles);
@@ -1900,11 +1927,12 @@ GhidDrawLayerGroup (hidGC gc, int group)
   bool is_outline;
   struct layer_info l_info;
   struct side_info s_info;
+  HID_DRAW *hid_draw = gc->hid_draw;
 
   l_info.gc = gc;
   s_info.gc = gc;
 
-  if (!hid_draw_set_layer (&ghid_graphics, 0, group, 0))
+  if (!hid_draw_set_layer (hid_draw, 0, group, 0))
     return 0;
 
   /* HACK: Subcomposite each layer in a layer group separately */
@@ -1921,7 +1949,7 @@ GhidDrawLayerGroup (hidGC gc, int group)
     if (layernum < max_copper_layer && Layer->On) {
 
       if (!first_run)
-        hid_draw_set_layer (&ghid_graphics, 0, group, 0);
+        hid_draw_set_layer (hid_draw, 0, group, 0);
 
       first_run = 0;
 
@@ -1932,8 +1960,8 @@ GhidDrawLayerGroup (hidGC gc, int group)
         glColorMask (0, 0, 0, 0);
         glDepthMask (GL_FALSE);
         hid_draw_set_color (Output.bgGC, PCB->MaskColor);
-        if (PCB->PinOn) r_search (PCB->Data->pin_tree, gc->clip_box, NULL, hole_callback, gc);
-        if (PCB->ViaOn) r_search (PCB->Data->via_tree, gc->clip_box, NULL, hole_callback, gc);
+        if (PCB->PinOn) r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, hole_callback, gc);
+        if (PCB->ViaOn) r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, hole_callback, gc);
         fill_board_outline_holes (Output.bgGC);
         hidgl_flush_triangles (priv->hid_draw);
         glPopAttrib ();
@@ -1942,13 +1970,13 @@ GhidDrawLayerGroup (hidGC gc, int group)
       /* draw all polygons on this layer */
       if (Layer->PolygonN) {
         l_info.layer = Layer;
-        r_search (Layer->polygon_tree, gc->clip_box, NULL, poly_callback_no_clear, &l_info);
-        r_search (Layer->polygon_tree, gc->clip_box, NULL, poly_callback_clearing, &l_info);
+        r_search (Layer->polygon_tree, hid_draw->clip_box, NULL, poly_callback_no_clear, &l_info);
+        r_search (Layer->polygon_tree, hid_draw->clip_box, NULL, poly_callback_clearing, &l_info);
 
         /* HACK: Subcomposite polygons separately from other layer primitives */
         /* Reset the compositing */
-        hid_draw_end_layer (&ghid_graphics);
-        hid_draw_set_layer (&ghid_graphics, 0, group, 0);
+        hid_draw_end_layer (hid_draw);
+        hid_draw_set_layer (hid_draw, 0, group, 0);
 
         if (!is_outline && !TEST_FLAG (THINDRAWFLAG, PCB)) {
           hidgl_flush_triangles (priv->hid_draw);
@@ -1956,8 +1984,8 @@ GhidDrawLayerGroup (hidGC gc, int group)
           glColorMask (0, 0, 0, 0);
           glDepthMask (GL_FALSE);
           /* Mask out drilled holes on this layer */
-          if (PCB->PinOn) r_search (PCB->Data->pin_tree, gc->clip_box, NULL, hole_callback, gc);
-          if (PCB->ViaOn) r_search (PCB->Data->via_tree, gc->clip_box, NULL, hole_callback, gc);
+          if (PCB->PinOn) r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, hole_callback, gc);
+          if (PCB->ViaOn) r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, hole_callback, gc);
           fill_board_outline_holes (Output.bgGC);
           hidgl_flush_triangles (priv->hid_draw);
           glPopAttrib ();
@@ -1968,31 +1996,31 @@ GhidDrawLayerGroup (hidGC gc, int group)
       if (!global_view_2d && !is_outline) {
         if (PCB->PinOn &&
             (group == bottom_group || group == top_group))
-          r_search (PCB->Data->pin_tree, gc->clip_box, NULL, pin_name_callback, gc);
-        if (PCB->PinOn) r_search (PCB->Data->pin_tree, gc->clip_box, NULL, pin_inlayer_callback, &l_info);
-        if (PCB->ViaOn) r_search (PCB->Data->via_tree, gc->clip_box, NULL, via_inlayer_callback, &l_info);
+          r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_name_callback, gc);
+        if (PCB->PinOn) r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_inlayer_callback, &l_info);
+        if (PCB->ViaOn) r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, via_inlayer_callback, &l_info);
         if (PCB->PinOn && group == top_group)
           {
             s_info.side = TOP_SIDE;
-            r_search (PCB->Data->pad_tree, gc->clip_box, NULL, pad_callback, &s_info);
+            r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_callback, &s_info);
           }
         if (PCB->PinOn && group == bottom_group)
           {
             s_info.side = BOTTOM_SIDE;
-            r_search (PCB->Data->pad_tree, gc->clip_box, NULL, pad_callback, &s_info);
+            r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_callback, &s_info);
           }
       }
 
       if (TEST_FLAG (CHECKPLANESFLAG, PCB))
         continue;
 
-      r_search (Layer->line_tree, gc->clip_box, NULL, line_callback, &l_info);
-      r_search (Layer->arc_tree, gc->clip_box, NULL, arc_callback, &l_info);
-      r_search (Layer->text_tree, gc->clip_box, NULL, text_callback, &l_info);
+      r_search (Layer->line_tree, hid_draw->clip_box, NULL, line_callback, &l_info);
+      r_search (Layer->arc_tree, hid_draw->clip_box, NULL, arc_callback, &l_info);
+      r_search (Layer->text_tree, hid_draw->clip_box, NULL, text_callback, &l_info);
     }
   }
 
-  hid_draw_end_layer (&ghid_graphics);
+  hid_draw_end_layer (hid_draw);
 
   return (n_entries > 1);
 }
@@ -2130,7 +2158,7 @@ static void
 ghid_draw_packages (hidGC gc)
 {
   /* XXX: Just the front elements for now */
-  r_search (PCB->Data->element_tree, gc->clip_box, NULL, frontE_package_callback, NULL);
+  r_search (PCB->Data->element_tree, gc->hid_draw->clip_box, NULL, frontE_package_callback, NULL);
 }
 
 void
@@ -2151,6 +2179,7 @@ ghid_draw_everything (hidGC gc)
   int min_phys_group;
   int max_phys_group;
   struct side_info info;
+  HID_DRAW *hid_draw = gc->hid_draw;
 
   cyl_info.gc = gc;
   info.gc = gc;
@@ -2206,20 +2235,20 @@ ghid_draw_everything (hidGC gc)
   info.side = SWAP_IDENT ? TOP_SIDE : BOTTOM_SIDE;
 
   if (!TEST_FLAG (CHECKPLANESFLAG, PCB) &&
-      hid_draw_set_layer (&ghid_graphics, "invisible", SL (INVISIBLE, 0), 0)) {
+      hid_draw_set_layer (hid_draw, "invisible", SL (INVISIBLE, 0), 0)) {
     DrawSilk (gc, info.side);
 
     if (global_view_2d)
-      r_search (PCB->Data->pad_tree, gc->clip_box, NULL, pad_callback, &info);
+      r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_callback, &info);
 
-    hid_draw_end_layer (&ghid_graphics);
+    hid_draw_end_layer (hid_draw);
 
     /* Draw the reverse-side solder mask if turned on */
     if (!global_view_2d &&
-        hid_draw_set_layer (&ghid_graphics, SWAP_IDENT ? "componentmask" : "soldermask",
-                        SWAP_IDENT ? SL (MASK, TOP) : SL (MASK, BOTTOM), 0)) {
+        hid_draw_set_layer (hid_draw, SWAP_IDENT ? "componentmask" : "soldermask",
+                            SWAP_IDENT ? SL (MASK, TOP) : SL (MASK, BOTTOM), 0)) {
         GhidDrawMask (gc, info.side);
-        hid_draw_end_layer (&ghid_graphics);
+        hid_draw_end_layer (hid_draw);
       }
   }
 
@@ -2250,8 +2279,8 @@ ghid_draw_everything (hidGC gc)
       hid_draw_set_color (gc, "drill");
       ghid_set_alpha_mult (gc, alpha_mult * 0.75);
       ghid_draw_outline_between_layers (gc, cyl_info.from_layer, cyl_info.to_layer);
-      if (PCB->PinOn) r_search (PCB->Data->pin_tree, gc->clip_box, NULL, pin_hole_cyl_callback, &cyl_info);
-      if (PCB->ViaOn) r_search (PCB->Data->via_tree, gc->clip_box, NULL, via_hole_cyl_callback, &cyl_info);
+      if (PCB->PinOn) r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_hole_cyl_callback, &cyl_info);
+      if (PCB->ViaOn) r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, via_hole_cyl_callback, &cyl_info);
     }
 #endif
   }
@@ -2266,7 +2295,7 @@ ghid_draw_everything (hidGC gc)
 
   /* Draw pins, pads, vias below silk */
   if (global_view_2d) {
-    start_subcomposite (gc->hid_draw);
+    start_subcomposite (hid_draw);
 
     if (!TEST_FLAG (THINDRAWFLAG, PCB)) {
       /* Mask out drilled holes */
@@ -2274,41 +2303,41 @@ ghid_draw_everything (hidGC gc)
       glPushAttrib (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
       glColorMask (0, 0, 0, 0);
       glDepthMask (GL_FALSE);
-      if (PCB->PinOn) r_search (PCB->Data->pin_tree, gc->clip_box, NULL, hole_callback, gc);
-      if (PCB->ViaOn) r_search (PCB->Data->via_tree, gc->clip_box, NULL, hole_callback, gc);
+      if (PCB->PinOn) r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, hole_callback, gc);
+      if (PCB->ViaOn) r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, hole_callback, gc);
       fill_board_outline_holes (Output.bgGC);
       hidgl_flush_triangles (priv->hid_draw);
       glPopAttrib ();
     }
 
-    if (PCB->PinOn) r_search (PCB->Data->pad_tree, gc->clip_box, NULL, pad_callback, &info);
-    if (PCB->PinOn) r_search (PCB->Data->pin_tree, gc->clip_box, NULL, pin_callback, gc);
-    if (PCB->ViaOn) r_search (PCB->Data->via_tree, gc->clip_box, NULL, via_callback, gc);
+    if (PCB->PinOn) r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_callback, &info);
+    if (PCB->PinOn) r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_callback, gc);
+    if (PCB->ViaOn) r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, via_callback, gc);
 
-    end_subcomposite (gc->hid_draw);
+    end_subcomposite (hid_draw);
   }
 
   /* Draw the solder mask if turned on */
-  if (hid_draw_set_layer (&ghid_graphics, SWAP_IDENT ? "soldermask" : "componentmask",
-                      SWAP_IDENT ? SL (MASK, BOTTOM) : SL (MASK, TOP), 0)) {
+  if (hid_draw_set_layer (hid_draw, SWAP_IDENT ? "soldermask" : "componentmask",
+                          SWAP_IDENT ? SL (MASK, BOTTOM) : SL (MASK, TOP), 0)) {
     GhidDrawMask (gc, info.side);
-    hid_draw_end_layer (&ghid_graphics);
+    hid_draw_end_layer (hid_draw);
   }
 
-  if (hid_draw_set_layer (&ghid_graphics, SWAP_IDENT ? "bottomsilk" : "topsilk",
-                      SWAP_IDENT ? SL (SILK, BOTTOM) : SL (SILK, TOP), 0)) {
+  if (hid_draw_set_layer (hid_draw, SWAP_IDENT ? "bottomsilk" : "topsilk",
+                          SWAP_IDENT ? SL (SILK, BOTTOM) : SL (SILK, TOP), 0)) {
       DrawSilk (gc, info.side);
-      hid_draw_end_layer (&ghid_graphics);
+      hid_draw_end_layer (hid_draw);
   }
 
   /* Draw element Marks */
   if (PCB->PinOn)
-    r_search (PCB->Data->element_tree, gc->clip_box, NULL, EMark_callback, gc);
+    r_search (PCB->Data->element_tree, hid_draw->clip_box, NULL, EMark_callback, gc);
 
   /* Draw rat lines on top */
-  if (PCB->RatOn && hid_draw_set_layer (&ghid_graphics, "rats", SL (RATS, 0), 0)) {
+  if (PCB->RatOn && hid_draw_set_layer (hid_draw, "rats", SL (RATS, 0), 0)) {
     DrawRats (gc);
-    hid_draw_end_layer (&ghid_graphics);
+    hid_draw_end_layer (hid_draw);
   }
 
   Settings.ShowBottomSide = save_show_solder;
@@ -2335,6 +2364,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
                      0, 0, 0, 1};
   bool horizon_problem = false;
   static bool do_once = true;
+  HID_DRAW *hid_draw = priv->hid_draw;
   hidGC gc;
 
   if (do_once) {
@@ -2346,9 +2376,9 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   ghid_start_drawing (port, widget);
 
-  gc = hid_draw_make_gc (&ghid_graphics);
-  Output.bgGC = hid_draw_make_gc (&ghid_graphics);
-  Output.pmGC = hid_draw_make_gc (&ghid_graphics);
+  gc = hid_draw_make_gc (hid_draw);
+  Output.bgGC = hid_draw_make_gc (hid_draw);
+  Output.pmGC = hid_draw_make_gc (hid_draw);
 
   /* If we don't have any stencil bits available,
      we can't use the hidgl polygon drawing routine */
@@ -2580,8 +2610,8 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   ghid_draw_bg_image ();
 
-  common_set_clip_box (&ghid_graphics, &region);
-  /* hid_expose_callback (&ghid_graphics, 0); */
+  common_set_clip_box (hid_draw, &region);
+  /* hid_expose_callback (hid_draw, 0); */
   ghid_draw_everything (gc);
   hidgl_flush_triangles (priv->hid_draw);
 
@@ -2627,7 +2657,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   /* Set the current depth to the right value for the layer we are editing */
   priv->edit_depth = compute_depth (GetLayerGroupNumberByNumber (INDEXOFCURRENT));
-  hidgl_set_depth (&ghid_graphics, priv->edit_depth);
+  hidgl_set_depth (gc, priv->edit_depth);
 
   ghid_draw_grid (gc);
 
@@ -2743,6 +2773,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   Coord save_max_width;
   Coord save_max_height;
   double xz, yz;
+  HID_DRAW *hid_draw = priv->hid_draw;
 
   save_view = gport->view;
   save_width = gport->width;
@@ -2843,8 +2874,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
                 gport->view.flip_y ? gport->view.y0 - PCB->MaxHeight :
                                     -gport->view.y0, 0);
 
-  hidgl_set_depth (&ghid_graphics, 0.);
-  hid_expose_callback (&ghid_graphics, pinout->element);
+  hid_expose_callback (hid_draw, pinout->element);
   hidgl_flush_triangles (priv->hid_draw);
   glPopMatrix ();
 
@@ -2873,6 +2903,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   view_data save_view;
   int save_width, save_height;
   BoxType region;
+  HID_DRAW *hid_draw = priv->hid_draw;
 
   save_view = gport->view;
   save_width = gport->width;
@@ -2965,8 +2996,8 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   region.Y1 = MAX (0, MIN (PCB->MaxHeight, region.Y1));
   region.Y2 = MAX (0, MIN (PCB->MaxHeight, region.Y2));
 
-  common_set_clip_box (&ghid_graphics, &region);
-  hid_expose_callback (&ghid_graphics, NULL);
+  common_set_clip_box (hid_draw, &region);
+  hid_expose_callback (hid_draw, NULL);
   hidgl_flush_triangles (priv->hid_draw);
   glPopMatrix ();
 
@@ -2994,6 +3025,7 @@ HID_DRAW *
 ghid_request_debug_draw (void)
 {
   GHidPort *port = gport;
+  render_priv *priv = port->render_priv;
   GtkWidget *widget = port->drawing_area;
   GtkAllocation allocation;
 
@@ -3022,7 +3054,7 @@ ghid_request_debug_draw (void)
                 port->view.flip_y ? port->view.y0 - PCB->MaxHeight :
                              -port->view.y0, 0);
 
-  return &ghid_graphics;
+  return priv->hid_draw;
 }
 
 void
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 6ef26eb..15854d9 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -2097,8 +2097,7 @@ REGISTER_FLAGS (ghid_main_flag_list)
 #endif
 
 HID ghid_hid;
-HID_DRAW ghid_graphics;
-struct hid_draw_class_st ghid_graphics_class;
+HID_DRAW_CLASS ghid_graphics_class;
 
 void
 hid_gtk_init ()
@@ -2138,7 +2137,6 @@ hid_gtk_init ()
 #endif
 
   memset (&ghid_hid, 0, sizeof (HID));
-  memset (&ghid_graphics, 0, sizeof (HID_DRAW));
   memset (&ghid_graphics_class, 0, sizeof (HID_DRAW_CLASS));
 
   common_nogui_init (&ghid_hid);
@@ -2215,13 +2213,8 @@ hid_gtk_init ()
   ghid_graphics_class.draw_pcb_pad     = common_gui_draw_pcb_pad;
   ghid_graphics_class.draw_pcb_pv      = common_gui_draw_pcb_pv;
 
-
   ghid_graphics_class.gui = true;
 
-  ghid_graphics.klass = &ghid_graphics_class;
-  ghid_graphics.poly_after = true;
-  common_draw_helpers_init (&ghid_graphics);
-
   hid_register_hid (&ghid_hid);
 #include "gtk_lists.h"
 }
diff --git a/src/hid/png/png.c b/src/hid/png/png.c
index c1aff5f..cc05bb8 100644
--- a/src/hid/png/png.c
+++ b/src/hid/png/png.c
@@ -550,10 +550,6 @@ png_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
   int saved_show_bottom_side;
   BoxType region;
   FlagType save_flags;
-  hidGC gc;
-
-#warning NULL gc
-  gc = NULL;
 
   f = the_file;
 
@@ -567,8 +563,6 @@ png_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
   else
     bounds = &region;
 
-  common_set_clip_box (gc, bounds);
-
   memset (print_group, 0, sizeof (print_group));
   memset (print_layer, 0, sizeof (print_layer));
 
@@ -661,6 +655,7 @@ png_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
 	}
     }
 
+  common_set_clip_box (&png_graphics, bounds);
   hid_expose_callback (&png_graphics, 0);
 
   memcpy (LayerStack, saved_layer_stack, sizeof (LayerStack));
diff --git a/src/hid/ps/ps.c b/src/hid/ps/ps.c
index a7fd17c..f15f9e3 100644
--- a/src/hid/ps/ps.c
+++ b/src/hid/ps/ps.c
@@ -1009,7 +1009,11 @@ ps_set_layer (HID_DRAW *hid_draw, const char *name, int group, int empty)
       strcmp (name, "route") != 0
       )
     {
+      hidGC gc;
+
+      gc = hid_draw_make_gc (hid_draw);
       dapi->draw_layer (gc, global.outline_layer, NULL);
+      hid_draw_destroy_gc (gc);
     }
 
   return 1;
diff --git a/src/hid_draw.h b/src/hid_draw.h
index 57a4275..dce9e92 100644
--- a/src/hid_draw.h
+++ b/src/hid_draw.h
@@ -102,6 +102,8 @@ struct hid_draw_st
   bool poly_before; /* If set, the redraw code will draw polygons before erasing the clearances. */
   bool poly_after;  /* If set, the redraw code will draw polygons after  erasing the clearances. */
 
+  BoxType *clip_box; /* Used by HIDs and draw.c to restrict rendering to a given region */
+
   void *priv; /* XXX: TEMPORARY */
 };
 
@@ -109,7 +111,6 @@ struct hid_draw_st
 struct hid_gc_struct {
   HID *hid;   /* Used by HIDs to validate the GCs passed belong to them */
   HID_DRAW *hid_draw;
-  BoxType *clip_box; /* Used by HIDs and draw.c to restrict rendering to a given region */
 };

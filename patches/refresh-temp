Bottom: 72201536adf1651e111a60e6cb0ce96f44a7fbc6
Top:    e9605b6c819cf84b8267b3ab4daab69c84d2c6d6
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-04-21 02:41:18 +0100

Refresh of demo-of-exporter-specific-expo

---

diff --git a/src/hid/common/draw_helpers.c b/src/hid/common/draw_helpers.c
index b043d92..32e2fca 100644
--- a/src/hid/common/draw_helpers.c
+++ b/src/hid/common/draw_helpers.c
@@ -475,3 +475,226 @@ common_draw_helpers_init (HID *hid)
   hid->fill_pcb_pv          = common_fill_pcb_pv;
   hid->thindraw_pcb_pv      = common_thindraw_pcb_pv;
 }
+
+void
+exporter_board (HID * hid, BoxType * region)
+{
+  HID *old_gui = gui;
+  hidGC savebg = Output.bgGC;
+  hidGC savefg = Output.fgGC;
+  hidGC savepm = Output.pmGC;
+
+  gui = hid;
+  Output.fgGC = gui->make_gc ();
+  Output.bgGC = gui->make_gc ();
+  Output.pmGC = gui->make_gc ();
+
+  Gathering = false;
+
+  hid->set_color (Output.pmGC, "erase");
+  hid->set_color (Output.bgGC, "drill");
+
+    int i, ngroups, side;
+  int plated;
+  int component, solder;
+  /* This is the list of layer groups we will draw.  */
+  int do_group[MAX_LAYER];
+  /* This is the reverse of the order in which we draw them.  */
+  int drawn_groups[MAX_LAYER];
+
+  PCB->Data->SILKLAYER.Color = PCB->ElementColor;
+  PCB->Data->BACKSILKLAYER.Color = PCB->InvisibleObjectsColor;
+
+  memset (do_group, 0, sizeof (do_group));
+  for (ngroups = 0, i = 0; i < max_copper_layer; i++)
+    {
+      LayerType *l = LAYER_ON_STACK (i);
+      int group = GetLayerGroupNumberByNumber (LayerStack[i]);
+      if (l->On && !do_group[group])
+        {
+          do_group[group] = 1;
+          drawn_groups[ngroups++] = group;
+        }
+    }
+
+  component = GetLayerGroupNumberByNumber (component_silk_layer);
+  solder = GetLayerGroupNumberByNumber (solder_silk_layer);
+
+  /*
+   * first draw all 'invisible' stuff
+   */
+  if (!TEST_FLAG (CHECKPLANESFLAG, PCB)
+      && gui->set_layer ("invisible", SL (INVISIBLE, 0), 0))
+    {
+      r_search (PCB->Data->pad_tree, drawn_area, NULL, backPad_callback,
+                NULL);
+      if (PCB->ElementOn)
+        {
+          r_search (PCB->Data->element_tree, drawn_area, NULL, backE_callback,
+                    NULL);
+          r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], drawn_area, NULL,
+                    backN_callback, NULL);
+          DrawLayer (&(PCB->Data->BACKSILKLAYER), drawn_area);
+        }
+    }
+
+  /* draw all layers in layerstack order */
+  for (i = ngroups - 1; i >= 0; i--)
+    {
+      int group = drawn_groups[i];
+
+      if (gui->set_layer (0, group, 0))
+        {
+          if (DrawLayerGroup (group, drawn_area) && !gui->gui)
+            {
+              int save_swap = SWAP_IDENT;
+
+              if (TEST_FLAG (CHECKPLANESFLAG, PCB) && gui->gui)
+                continue;
+              r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_callback,
+                        NULL);
+              r_search (PCB->Data->via_tree, drawn_area, NULL, pin_callback,
+                        NULL);
+              /* draw element pads */
+              if (group == component || group == solder)
+                {
+                  SWAP_IDENT = (group == solder);
+                  r_search (PCB->Data->pad_tree, drawn_area, NULL,
+                            pad_callback, NULL);
+                }
+              SWAP_IDENT = save_swap;
+
+              if (!gui->gui)
+                {
+                  /* draw holes */
+                  plated = -1;
+                  r_search (PCB->Data->pin_tree, drawn_area, NULL, hole_callback,
+                            &plated);
+                  r_search (PCB->Data->via_tree, drawn_area, NULL, hole_callback,
+                            &plated);
+                }
+            }
+        }
+    }
+  if (TEST_FLAG (CHECKPLANESFLAG, PCB) && gui->gui)
+    return;
+
+  /* Draw pins, pads, vias below silk */
+  if (gui->gui)
+    DrawTop (drawn_area);
+  else
+    {
+      HoleCountStruct hcs;
+      hcs.nplated = hcs.nunplated = 0;
+      r_search (PCB->Data->pin_tree, drawn_area, NULL, hole_counting_callback,
+                &hcs);
+      r_search (PCB->Data->via_tree, drawn_area, NULL, hole_counting_callback,
+                &hcs);
+      if (hcs.nplated && gui->set_layer ("plated-drill", SL (PDRILL, 0), 0))
+        {
+          plated = 1;
+          r_search (PCB->Data->pin_tree, drawn_area, NULL, hole_callback,
+                    &plated);
+          r_search (PCB->Data->via_tree, drawn_area, NULL, hole_callback,
+                    &plated);
+        }
+      if (hcs.nunplated && gui->set_layer ("unplated-drill", SL (UDRILL, 0), 0))
+        {
+          plated = 0;
+          r_search (PCB->Data->pin_tree, drawn_area, NULL, hole_callback,
+                    &plated);
+          r_search (PCB->Data->via_tree, drawn_area, NULL, hole_callback,
+                    &plated);
+        }
+    }
+  /* Draw the solder mask if turned on */
+  if (gui->set_layer ("componentmask", SL (MASK, TOP), 0))
+    {
+      int save_swap = SWAP_IDENT;
+      SWAP_IDENT = 0;
+      DrawMask (drawn_area);
+      SWAP_IDENT = save_swap;
+    }
+  if (gui->set_layer ("soldermask", SL (MASK, BOTTOM), 0))
+    {
+      int save_swap = SWAP_IDENT;
+      SWAP_IDENT = 1;
+      DrawMask (drawn_area);
+      SWAP_IDENT = save_swap;
+    }
+  /* Draw top silkscreen */
+  if (gui->set_layer ("topsilk", SL (SILK, TOP), 0))
+    DrawSilk (0, component_silk_layer, drawn_area);
+  if (gui->set_layer ("bottomsilk", SL (SILK, BOTTOM), 0))
+    DrawSilk (1, solder_silk_layer, drawn_area);
+  if (gui->gui)
+    {
+      /* Draw element Marks */
+      if (PCB->PinOn)
+        r_search (PCB->Data->element_tree, drawn_area, NULL, EMark_callback,
+                  NULL);
+      /* Draw rat lines on top */
+      if (gui->set_layer ("rats", SL (RATS, 0), 0))
+        DrawRats(drawn_area);
+    }
+
+  for (side = 0; side <= 1; side++)
+    {
+      int doit;
+      bool NoData = true;
+      ALLPAD_LOOP (PCB->Data);
+      {
+        if ((TEST_FLAG (ONSOLDERFLAG, pad) && side == SOLDER_LAYER)
+            || (!TEST_FLAG (ONSOLDERFLAG, pad) && side == COMPONENT_LAYER))
+          {
+            NoData = false;
+            break;
+          }
+      }
+      ENDALL_LOOP;
+
+      if (side == SOLDER_LAYER)
+        doit = gui->set_layer ("bottompaste", SL (PASTE, BOTTOM), NoData);
+      else
+        doit = gui->set_layer ("toppaste", SL (PASTE, TOP), NoData);
+      if (doit)
+        {
+          gui->set_color (Output.fgGC, PCB->ElementColor);
+          ALLPAD_LOOP (PCB->Data);
+          {
+            if ((TEST_FLAG (ONSOLDERFLAG, pad) && side == SOLDER_LAYER)
+                || (!TEST_FLAG (ONSOLDERFLAG, pad)
+                    && side == COMPONENT_LAYER))
+              if (!TEST_FLAG (NOPASTEFLAG, pad) && pad->Mask > 0)
+                {
+                  if (pad->Mask < pad->Thickness)
+                    DrawPadLowLevel (Output.fgGC, pad, true, true);
+                  else
+                    DrawPadLowLevel (Output.fgGC, pad, false, false);
+                }
+          }
+          ENDALL_LOOP;
+        }
+    }
+
+  doing_assy = true;
+  if (gui->set_layer ("topassembly", SL (ASSY, TOP), 0))
+    PrintAssembly (drawn_area, component, 0);
+
+  if (gui->set_layer ("bottomassembly", SL (ASSY, BOTTOM), 0))
+    PrintAssembly (drawn_area, solder, 1);
+  doing_assy = false;
+
+  if (gui->set_layer ("fab", SL (FAB, 0), 0))
+    PrintFab ();
+
+  gui->destroy_gc (Output.fgGC);
+  gui->destroy_gc (Output.bgGC);
+  gui->destroy_gc (Output.pmGC);
+  gui = old_gui;
+  Output.fgGC = savefg;
+  Output.bgGC = savebg;
+  Output.pmGC = savepm;
+
+  Gathering = true;
+}

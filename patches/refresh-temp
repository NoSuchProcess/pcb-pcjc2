Bottom: 5e1e768028f6099cc01d50067a256a2640617cb6
Top:    6fc681c4f2a937b94f63ef7f3aee5d1f71cede79
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-09-07 20:31:48 +0100

Refresh of hid-gtk-connect-up-the-file-ch

---

diff --git a/src/file.c b/src/file.c
index d31b157..be7f6a5 100644
--- a/src/file.c
+++ b/src/file.c
@@ -358,7 +358,6 @@ SavePCB (char *file)
 
   gui->notify_save_pcb (file, false);
   retcode = WritePipe (file, true);
-  printf ("File changes hitting disk now\n");
   gui->notify_save_pcb (file, true);
 
   return retcode;
diff --git a/src/hid/gtk/gui-top-window.c b/src/hid/gtk/gui-top-window.c
index 1277da0..5f3d53e 100644
--- a/src/hid/gtk/gui-top-window.c
+++ b/src/hid/gtk/gui-top-window.c
@@ -211,57 +211,6 @@ top_window_configure_event_cb (GtkWidget * widget, GdkEventConfigure * ev,
   return FALSE;
 }
 
-
-/*! \brief Menu action callback function
- *  \par Function Description
- *  This is the main menu callback function.  The callback receives
- *  the original Resource pointer containing the HID actions to be
- *  executed.
- *
- *  All hotkeys go through the menus which means they go through here.
- *  Some, such as tab, are caught by Gtk instead of passed here, so
- *  pcb calls this function directly through ghid_hotkey_cb() for them.
- *
- *  \param [in]   The action that was activated
- *  \param [in]   The menu resource associated with the action
- */
-
-static void
-ghid_menu_cb (GtkAction *action, const Resource *node)
-{
-  int i;
-
-  if (action == NULL || node == NULL) 
-    return;
-
-  for (i = 1; i < node->c; i++)
-    if (resource_type (node->v[i]) == 10)
-      {
-#ifdef DEBUG_MENUS
-        printf ("    %s\n", node->v[i].value);
-#endif
-        hid_parse_actions (node->v[i].value);
-      }
-
-  /* Sync gui widgets with pcb state */
-  ghid_update_toggle_flags ();
-  ghid_mode_buttons_update ();
-
-  /* Sync gui status display with pcb state */
-  AdjustAttachedObjects ();
-  ghid_invalidate_all ();
-  ghid_window_set_name_label (PCB->Name);
-  ghid_set_status_line_label ();
-}
-
-/* \brief Accelerator callback for accelerators gtk tries to hide from us */
-void ghid_hotkey_cb (int which)
-{
-  if (ghid_hotkey_actions[which].action != NULL)
-    ghid_menu_cb (ghid_hotkey_actions[which].action,
-                  (gpointer) ghid_hotkey_actions[which].node);
-}
-
 static void
 info_bar_response_cb (GtkInfoBar *info_bar,
                       gint        response_id,
@@ -277,25 +226,15 @@ info_bar_response_cb (GtkInfoBar *info_bar,
 }
 
 static void
-file_changed_cb (GFileMonitor     *monitor,
-                 GFile            *file,
-                 GFile            *other_file,
-                 GFileMonitorEvent event_type,
-                 gpointer          user_data)
+prompt_file_modified_externally (void)
 {
-  GhidGui *_gui = (GhidGui *)user_data;
+  GhidGui *_gui = ghidgui;
   GtkWidget *icon;
   GtkWidget *label;
   GtkWidget *content_area;
-  char *file_path;
   char *file_path_utf8;
   char *markup;
 
-  if (event_type != G_FILE_MONITOR_EVENT_CHANGED)
-    return;
-
-  /* File has changed on disk */
-
   if (_gui->info_bar)
     gtk_widget_destroy (_gui->info_bar);
 
@@ -314,10 +253,7 @@ file_changed_cb (GFileMonitor     *monitor,
   g_signal_connect (_gui->info_bar, "response",
                     G_CALLBACK (info_bar_response_cb), _gui);
 
-  file_path = g_file_get_path (file);
-  printf ("File %s has changed on disk (monitor %p)\n", file_path, monitor);
-  file_path_utf8 = g_filename_to_utf8 (file_path, -1, NULL, NULL, NULL);
-  g_free (file_path);
+  file_path_utf8 = g_filename_to_utf8 (PCB->Filename, -1, NULL, NULL, NULL);
   markup =
     g_markup_printf_escaped (_("<b>The file %s has changed on disk</b>\n"
                                "\n"
@@ -346,44 +282,118 @@ file_changed_cb (GFileMonitor     *monitor,
   gtk_widget_show_all (_gui->info_bar);
 }
 
+static bool
+check_externally_modified (void)
+{
+  GFile *file;
+  GFileInfo *info;
+  GTimeVal timeval;
+
+  /* Treat zero time as a flag to indicate we've not got an mtime yet */
+  if (PCB->Filename == NULL ||
+      (ghidgui->mtime.tv_sec == 0 &&
+       ghidgui->mtime.tv_usec == 0))
+    return false;
+
+  file = g_file_new_for_path (PCB->Filename);
+  info = g_file_query_info (file, G_FILE_ATTRIBUTE_TIME_MODIFIED,
+                            G_FILE_QUERY_INFO_NONE, NULL, NULL);
+  g_object_unref (file);
+
+  if (info == NULL ||
+      !g_file_info_has_attribute (info, G_FILE_ATTRIBUTE_TIME_MODIFIED))
+    return false;
+
+  g_file_info_get_modification_time (info, &timeval);
+  g_object_unref (info);
+
+  return (timeval.tv_sec > ghidgui->mtime.tv_sec) ||
+         (timeval.tv_sec == ghidgui->mtime.tv_sec &&
+         timeval.tv_usec > ghidgui->mtime.tv_usec);
+}
+
+static gboolean
+top_window_enter_cb (GtkWidget *widget, GdkEvent  *event, GHidPort *port)
+{
+  if (check_externally_modified ())
+    prompt_file_modified_externally ();
+
+  return FALSE;
+}
+
+/*! \brief Menu action callback function
+ *  \par Function Description
+ *  This is the main menu callback function.  The callback receives
+ *  the original Resource pointer containing the HID actions to be
+ *  executed.
+ *
+ *  All hotkeys go through the menus which means they go through here.
+ *  Some, such as tab, are caught by Gtk instead of passed here, so
+ *  pcb calls this function directly through ghid_hotkey_cb() for them.
+ *
+ *  \param [in]   The action that was activated
+ *  \param [in]   The menu resource associated with the action
+ */
+
 static void
-disconnect_file_change_monitor (GhidGui *_gui)
+ghid_menu_cb (GtkAction *action, const Resource *node)
 {
-  printf ("Disconnect monitor %p\n", _gui->file_monitor);
+  int i;
 
-  if (_gui->file_monitor != NULL)
-    g_object_unref (_gui->file_monitor);
-  _gui->file_monitor = NULL;
+  if (action == NULL || node == NULL) 
+    return;
 
-  if (_gui->info_bar != NULL)
-    gtk_widget_destroy (_gui->info_bar);
-  _gui->info_bar = NULL;
+  for (i = 1; i < node->c; i++)
+    if (resource_type (node->v[i]) == 10)
+      {
+#ifdef DEBUG_MENUS
+        printf ("    %s\n", node->v[i].value);
+#endif
+        hid_parse_actions (node->v[i].value);
+      }
+
+  /* Sync gui widgets with pcb state */
+  ghid_update_toggle_flags ();
+  ghid_mode_buttons_update ();
+
+  /* Sync gui status display with pcb state */
+  AdjustAttachedObjects ();
+  ghid_invalidate_all ();
+  ghid_window_set_name_label (PCB->Name);
+  ghid_set_status_line_label ();
+}
+
+/* \brief Accelerator callback for accelerators gtk tries to hide from us */
+void ghid_hotkey_cb (int which)
+{
+  if (ghid_hotkey_actions[which].action != NULL)
+    ghid_menu_cb (ghid_hotkey_actions[which].action,
+                  (gpointer) ghid_hotkey_actions[which].node);
 }
 
 static void
-connect_file_change_monitor (GhidGui *_gui)
+update_board_mtime_from_disk (void)
 {
   GFile *file;
+  GFileInfo *info;
 
-  /* Ensure any existing monitor is disconnected */
-  disconnect_file_change_monitor (_gui);
+  ghidgui->mtime.tv_sec = 0;
+  ghidgui->mtime.tv_usec = 0;
 
-  if (PCB->Filename == NULL ||
-      *PCB->Filename == '\0')
+  if (PCB->Filename == NULL)
     return;
 
   file = g_file_new_for_path (PCB->Filename);
-
-  /* XXX: Could hook up more error handling for g_file_monitor_file */
-  _gui->file_monitor = g_file_monitor_file (file,
-                                            G_FILE_MONITOR_NONE,
-                                            NULL,
-                                            NULL);
+  info = g_file_query_info (file, G_FILE_ATTRIBUTE_TIME_MODIFIED,
+                            G_FILE_QUERY_INFO_NONE, NULL, NULL);
   g_object_unref (file);
 
-  printf ("Connecting for %s new monitor is %p\n", PCB->Filename, _gui->file_monitor);
-  g_signal_connect (_gui->file_monitor, "changed",
-                    G_CALLBACK (file_changed_cb), _gui);
+  if (info == NULL ||
+      !g_file_info_has_attribute (info, G_FILE_ATTRIBUTE_TIME_MODIFIED))
+    return;
+
+  g_file_info_get_modification_time (info, &ghidgui->mtime);
+  g_object_unref (info);
 }
 
   /* Sync toggle states that were saved with the layout and notify the
@@ -401,35 +411,26 @@ ghid_sync_with_new_layout (void)
 
   ghid_window_set_name_label (PCB->Name);
   ghid_set_status_line_label ();
-  connect_file_change_monitor (ghidgui);
+  update_board_mtime_from_disk ();
 }
 
 void
 ghid_notify_save_pcb (const char *filename, bool done)
 {
-  /* Do nothing if it is not the active PCB file we're watching
-   * that is being saved.
+  /* Do nothing if it is not the active PCB file that is being saved.
    */
-  if (strcmp (filename, PCB->Filename) != 0)
-    {
-      printf ("Being notified about save - ignoring save to %s\n", filename);
-      return;
-    }
-
-  printf ("Being notified about save to %s\n", filename);
+  if (PCB->Filename == NULL || strcmp (filename, PCB->Filename) != 0)
+    return;
 
-  if (!done)
-    disconnect_file_change_monitor (ghidgui);
-  else
-    connect_file_change_monitor (ghidgui);
+  if (done)
+    update_board_mtime_from_disk ();
 }
 
 void
 ghid_notify_filename_changed (void)
 {
-  printf ("Notified the PCB file is now under a new name\n");
-  disconnect_file_change_monitor (ghidgui);
-  connect_file_change_monitor (ghidgui);
+  /* Pick up the mtime of the new PCB file */
+  update_board_mtime_from_disk ();
 }
 
 /* ---------------------------------------------------------------------------
@@ -1354,6 +1355,8 @@ ghid_build_pcb_top_window (void)
 		    port);
   g_signal_connect (G_OBJECT (gport->top_window), "configure_event",
 		    G_CALLBACK (top_window_configure_event_cb), port);
+  g_signal_connect (gport->top_window, "enter-notify-event",
+                    G_CALLBACK (top_window_enter_cb), port);
   g_signal_connect (G_OBJECT (gport->drawing_area), "configure_event",
 		    G_CALLBACK (ghid_port_drawing_area_configure_event_cb),
 		    port);
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index af59121..3d47a84 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -115,7 +115,7 @@ typedef struct
   GtkWidget *vbox_middle;
 
   GtkWidget *info_bar;
-  GFileMonitor *file_monitor;
+  GTimeVal mtime;
 
   GtkWidget *h_range, *v_range;
   GtkObject *h_adjustment, *v_adjustment;

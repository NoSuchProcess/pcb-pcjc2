Bottom: 53290aee0eb185a09579f53b06db6795c02fa801
Top:    fae668b99a9acf4cc478a2c5ed12cc0bf6fe5d26
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2008-10-11 05:57:22 +0100

Refresh of add_pours

---

diff --git a/src/action.c b/src/action.c
index 1999831..6b2dc76 100644
--- a/src/action.c
+++ b/src/action.c
@@ -4431,6 +4431,9 @@ off are automatically deleted.
 static int
 ActionMorphPolygon (int argc, char **argv, int x, int y)
 {
+#warning FIXME Later
+  Message ("Morph polygon not implemented. Pours are nice though!\n");
+#if 0
   char *function = ARG (0);
   if (function)
     {
@@ -4466,6 +4469,7 @@ ActionMorphPolygon (int argc, char **argv, int x, int y)
 	}
     }
   return 0;
+#endif
 }
 
 /* --------------------------------------------------------------------------- */
diff --git a/src/autoroute.c b/src/autoroute.c
index f769d83..585c3de 100644
--- a/src/autoroute.c
+++ b/src/autoroute.c
@@ -1069,12 +1069,16 @@ CreateRouteData ()
       }
       END_LOOP;
       /* add all polygons */
-      POLYGON_LOOP (LAYER_PTR (i));
+      POUR_LOOP (LAYER_PTR (i));
       {
-        if (TEST_FLAG (DRCFLAG, polygon))
-          CLEAR_FLAG (DRCFLAG, polygon);
-        else
-          AddPolygon (layergroupboxes, i, polygon);
+        POURPOLYGON_LOOP (pour);
+        {
+          if (TEST_FLAG (DRCFLAG, polygon))
+            CLEAR_FLAG (DRCFLAG, polygon);
+          else
+            AddPolygon (layergroupboxes, i, polygon);
+        }
+        END_LOOP;
       }
       END_LOOP;
       /* add all copper text */
@@ -2974,7 +2978,7 @@ do_via_search (edge_t * search, struct routeone_state *s,
         {
           BoxType cliparea;
           BoxType *area = vector_remove_last (v);
-          assert (box_intersect (area, &region));
+//          assert (box_intersect (area, &region));
           if (!(i == NO_CONFLICT || AutoRouteParameters.with_conflicts))
             {
               free (area);
diff --git a/src/buffer.c b/src/buffer.c
index 2405e75..909bac3 100644
--- a/src/buffer.c
+++ b/src/buffer.c
@@ -81,7 +81,7 @@ static void *MoveLineToBuffer (LayerTypePtr, LineTypePtr);
 static void *MoveArcToBuffer (LayerTypePtr, ArcTypePtr);
 static void *MoveRatToBuffer (RatTypePtr);
 static void *MoveTextToBuffer (LayerTypePtr, TextTypePtr);
-static void *MovePolygonToBuffer (LayerTypePtr, PolygonTypePtr);
+//static void *MovePolygonToBuffer (LayerTypePtr, PolygonTypePtr);
 static void *MovePourToBuffer (LayerTypePtr, PourTypePtr);
 static void *MoveElementToBuffer (ElementTypePtr);
 static void SwapBuffer (BufferTypePtr);
@@ -112,7 +112,7 @@ static ObjectFunctionType AddBufferFunctions = {
 {
 MoveLineToBuffer,
     MoveTextToBuffer,
-    MovePolygonToBuffer,
+    NULL, // MovePolygonToBuffer,
     MovePourToBuffer,
     MoveViaToBuffer,
     MoveElementToBuffer,
@@ -270,7 +270,7 @@ MoveViaToBuffer (PinTypePtr Via)
 {
   PinTypePtr via;
 
-  RestoreToPour (Source, VIA_TYPE, Via, Via);
+  RestoreToPours (Source, VIA_TYPE, Via, Via);
   r_delete_entry (Source->via_tree, (BoxType *) Via);
   via = GetViaMemory (Dest);
   *via = *Via;
@@ -282,7 +282,7 @@ MoveViaToBuffer (PinTypePtr Via)
   if (!Dest->via_tree)
     Dest->via_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (Dest->via_tree, (BoxType *) via, 0);
-  ClearFromPour (Dest, VIA_TYPE, via, via);
+  ClearFromPours (Dest, VIA_TYPE, via, via);
   return (via);
 }
 
@@ -317,7 +317,7 @@ MoveLineToBuffer (LayerTypePtr Layer, LineTypePtr Line)
   LayerTypePtr lay;
   LineTypePtr line;
 
-  RestoreToPour (Source, LINE_TYPE, Layer, Line);
+  RestoreToPours (Source, LINE_TYPE, Layer, Line);
   r_delete_entry (Layer->line_tree, (BoxTypePtr) Line);
   lay = &Dest->Layer[GetLayerNumber (Source, Layer)];
   line = GetLineMemory (lay);
@@ -331,7 +331,7 @@ MoveLineToBuffer (LayerTypePtr Layer, LineTypePtr Line)
   if (!lay->line_tree)
     lay->line_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (lay->line_tree, (BoxTypePtr) line, 0);
-  ClearFromPour (Dest, LINE_TYPE, lay, line);
+  ClearFromPours (Dest, LINE_TYPE, lay, line);
   return (line);
 }
 
@@ -344,7 +344,7 @@ MoveArcToBuffer (LayerTypePtr Layer, ArcTypePtr Arc)
   LayerTypePtr lay;
   ArcTypePtr arc;
 
-  RestoreToPour (Source, ARC_TYPE, Layer, Arc);
+  RestoreToPours (Source, ARC_TYPE, Layer, Arc);
   r_delete_entry (Layer->arc_tree, (BoxTypePtr) Arc);
   lay = &Dest->Layer[GetLayerNumber (Source, Layer)];
   arc = GetArcMemory (lay);
@@ -358,7 +358,7 @@ MoveArcToBuffer (LayerTypePtr Layer, ArcTypePtr Arc)
   if (!lay->arc_tree)
     lay->arc_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (lay->arc_tree, (BoxTypePtr) arc, 0);
-  ClearFromPour (Dest, ARC_TYPE, lay, arc);
+  ClearFromPours (Dest, ARC_TYPE, lay, arc);
   return (arc);
 }
 
@@ -372,7 +372,7 @@ MoveTextToBuffer (LayerTypePtr Layer, TextTypePtr Text)
   LayerTypePtr lay;
 
   r_delete_entry (Layer->text_tree, (BoxTypePtr) Text);
-  RestoreToPour (Source, TEXT_TYPE, Layer, Text);
+  RestoreToPours (Source, TEXT_TYPE, Layer, Text);
   lay = &Dest->Layer[GetLayerNumber (Source, Layer)];
   text = GetTextMemory (lay);
   *text = *Text;
@@ -383,10 +383,12 @@ MoveTextToBuffer (LayerTypePtr Layer, TextTypePtr Text)
   if (!lay->text_tree)
     lay->text_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (lay->text_tree, (BoxTypePtr) text, 0);
-  ClearFromPour (Dest, TEXT_TYPE, lay, text);
+  ClearFromPours (Dest, TEXT_TYPE, lay, text);
   return (text);
 }
 
+#warning FIXME Later
+#if 0
 /* ---------------------------------------------------------------------------
  * moves a polygon to buffer. Doesn't allocate memory for the points
  */
@@ -396,7 +398,7 @@ MovePolygonToBuffer (LayerTypePtr Layer, PolygonTypePtr Polygon)
   LayerTypePtr lay;
   PolygonTypePtr polygon;
 
-  RestoreToPour (Source, POLYGON_TYPE, Layer, Polygon);
+  RestoreToPours (Source, POLYGON_TYPE, Layer, Polygon);
   r_delete_entry (Layer->polygon_tree, (BoxTypePtr) Polygon);
   lay = &Dest->Layer[GetLayerNumber (Source, Layer)];
   polygon = GetPolygonMemory (lay);
@@ -410,9 +412,10 @@ MovePolygonToBuffer (LayerTypePtr Layer, PolygonTypePtr Polygon)
   if (!lay->polygon_tree)
     lay->polygon_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (lay->polygon_tree, (BoxTypePtr) polygon, 0);
-  ClearFromPour (Source, POLYGON_TYPE, Layer, Polygon);
+  ClearFromPours (Source, POLYGON_TYPE, Layer, Polygon);
   return (polygon);
 }
+#endif
 
 /* ---------------------------------------------------------------------------
  * moves a pour to buffer. Doesn't allocate memory for the points
@@ -423,7 +426,7 @@ MovePourToBuffer (LayerTypePtr Layer, PourTypePtr Pour)
   LayerTypePtr lay;
   PourTypePtr pour;
 
-  RestoreToPour (Source, POLYGON_TYPE, Layer, Pour);
+  RestoreToPours (Source, POLYGON_TYPE, Layer, Pour);
   r_delete_entry (Layer->pour_tree, (BoxTypePtr) Pour);
   lay = &Dest->Layer[GetLayerNumber (Source, Layer)];
   pour = GetPourMemory (lay);
@@ -437,7 +440,7 @@ MovePourToBuffer (LayerTypePtr Layer, PourTypePtr Pour)
   if (!lay->pour_tree)
     lay->pour_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (lay->pour_tree, (BoxTypePtr) pour, 0);
-  ClearFromPour (Source, POLYGON_TYPE, Layer, Pour);
+  ClearFromPours (Source, POLYGON_TYPE, Layer, Pour);
   return (pour);
 }
 
@@ -460,14 +463,14 @@ MoveElementToBuffer (ElementTypePtr Element)
   *element = *Element;
   PIN_LOOP (element);
   {
-    RestoreToPour(Source, PIN_TYPE, Element, pin);
+    RestoreToPours(Source, PIN_TYPE, Element, pin);
     CLEAR_FLAG (WARNFLAG | FOUNDFLAG, pin);
     pin->Element = element;
   }
   END_LOOP;
   PAD_LOOP (element);
   {
-    RestoreToPour(Source, PAD_TYPE, Element, pad);
+    RestoreToPours(Source, PAD_TYPE, Element, pad);
     CLEAR_FLAG (WARNFLAG | FOUNDFLAG, pad);
     pad->Element = element;
   }
@@ -483,12 +486,12 @@ MoveElementToBuffer (ElementTypePtr Element)
    */
   PIN_LOOP (element);
   {
-    ClearFromPour (Dest, PIN_TYPE, element, pin);
+    ClearFromPours (Dest, PIN_TYPE, element, pin);
   }
   END_LOOP;
   PAD_LOOP (element);
   {
-    ClearFromPour (Dest, PAD_TYPE, element, pad);
+    ClearFromPours (Dest, PAD_TYPE, element, pad);
   }
   END_LOOP;
 
@@ -824,32 +827,35 @@ ConvertBufferToElement (BufferTypePtr Buffer)
     END_LOOP;
 #warning FIXME Later
 #if 0
-    POLYGON_LOOP (layer);
+    POUR_LOOP (layer);
     {
-      int x1, y1, x2, y2, w, h, t;
-
-      if (! polygon_is_rectangle (polygon))
-        {
-          crooked = True;
-	  continue;
-        }
-
-      w = polygon->Points[2].X - polygon->Points[0].X;
-      h = polygon->Points[1].Y - polygon->Points[0].Y;
-      t = (w < h) ? w : h;
-      x1 = polygon->Points[0].X + t/2;
-      y1 = polygon->Points[0].Y + t/2;
-      x2 = x1 + (w-t);
-      y2 = y1 + (h-t);
-
-      sprintf (num, "%d", pin_n++);
-      CreateNewPad (Element,
-		    x1, y1, x2, y2, t,
-		    2 * Settings.Keepaway,
-		    t + Settings.Keepaway,
-		    NULL, num,
-		    MakeFlags (SQUAREFLAG | (SWAP_IDENT ? ONSOLDERFLAG : NOFLAG)));
-      hasParts = True;
+      POURPOLYGON_LOOP (pour);
+      {
+        int x1, y1, x2, y2, w, h, t;
+
+        if (! polygon_is_rectangle (polygon))
+          {
+            crooked = True;
+            continue;
+          }
+
+        w = polygon->Points[2].X - polygon->Points[0].X;
+        h = polygon->Points[1].Y - polygon->Points[0].Y;
+        t = (w < h) ? w : h;
+        x1 = polygon->Points[0].X + t/2;
+        y1 = polygon->Points[0].Y + t/2;
+        x2 = x1 + (w-t);
+        y2 = y1 + (h-t);
+
+        sprintf (num, "%d", pin_n++);
+        CreateNewPad (Element, x1, y1, x2, y2, t,
+                      2 * Settings.Keepaway,
+                      t + Settings.Keepaway,
+                      NULL, num,
+                      MakeFlags (SQUAREFLAG | (SWAP_IDENT ? ONSOLDERFLAG : NOFLAG)));
+        hasParts = True;
+      }
+      END_LOOP;
     }
     END_LOOP;
 #endif
@@ -1005,6 +1011,8 @@ RotateBuffer (BufferTypePtr Buffer, BYTE Number)
     r_insert_entry (layer->text_tree, (BoxTypePtr) text, 0);
   }
   ENDALL_LOOP;
+#warning FIXME Later
+#if 0
   ALLPOLYGON_LOOP (Buffer->Data);
   {
     r_delete_entry (layer->polygon_tree, (BoxTypePtr) polygon);
@@ -1012,6 +1020,7 @@ RotateBuffer (BufferTypePtr Buffer, BYTE Number)
     r_insert_entry (layer->polygon_tree, (BoxTypePtr) polygon, 0);
   }
   ENDALL_LOOP;
+#endif
   ALLPOUR_LOOP (Buffer->Data);
   {
     r_delete_entry (layer->pour_tree, (BoxTypePtr) pour);
@@ -1070,7 +1079,7 @@ FreeRotateElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
     /* pre-delete the pins from the pin-tree before their coordinates change */
     if (Data)
       r_delete_entry (Data->pin_tree, (BoxType *) pin);
-    RestoreToPour (Data, PIN_TYPE, Element, pin);
+    RestoreToPours (Data, PIN_TYPE, Element, pin);
     free_rotate (&pin->X, &pin->Y, X, Y, cosa, sina);
     SetPinBoundingBox (pin);
   }
@@ -1080,7 +1089,7 @@ FreeRotateElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
     /* pre-delete the pads before their coordinates change */
     if (Data)
       r_delete_entry (Data->pad_tree, (BoxType *) pad);
-    RestoreToPour (Data, PAD_TYPE, Element, pad);
+    RestoreToPours (Data, PAD_TYPE, Element, pad);
     free_rotate (&pad->Point1.X, &pad->Point1.Y, X, Y, cosa, sina);
     free_rotate (&pad->Point2.X, &pad->Point2.Y, X, Y, cosa, sina);
     SetLineBoundingBox ((LineType *) pad);
@@ -1096,7 +1105,7 @@ FreeRotateElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
 
   free_rotate (&Element->MarkX, &Element->MarkY, X, Y, cosa, sina);
   SetElementBoundingBox (Data, Element, &PCB->Font);
-  ClearFromPour (Data, ELEMENT_TYPE, Element, Element);
+  ClearFromPours (Data, ELEMENT_TYPE, Element, Element);
 }
 
 void
diff --git a/src/change.c b/src/change.c
index e567eec..17f8693 100644
--- a/src/change.c
+++ b/src/change.c
@@ -391,14 +391,14 @@ static void *
 ChangeViaThermal (PinTypePtr Via)
 {
   AddObjectToClearPolyUndoList (VIA_TYPE, Via, Via, Via, False);
-  RestoreToPour (PCB->Data, VIA_TYPE, CURRENT, Via);
+  RestoreToPours (PCB->Data, VIA_TYPE, CURRENT, Via);
   AddObjectToFlagUndoList (VIA_TYPE, Via, Via, Via);
   if (!Delta)			/* remove the thermals */
     CLEAR_THERM (INDEXOFCURRENT, Via);
   else
     ASSIGN_THERM (INDEXOFCURRENT, Delta, Via);
   AddObjectToClearPolyUndoList (VIA_TYPE, Via, Via, Via, True);
-  ClearFromPour (PCB->Data, VIA_TYPE, CURRENT, Via);
+  ClearFromPours (PCB->Data, VIA_TYPE, CURRENT, Via);
   DrawVia (Via, 0);
   return Via;
 }
@@ -411,14 +411,14 @@ static void *
 ChangePinThermal (ElementTypePtr element, PinTypePtr Pin)
 {
   AddObjectToClearPolyUndoList (PIN_TYPE, element, Pin, Pin, False);
-  RestoreToPour (PCB->Data, VIA_TYPE, CURRENT, Pin);
+  RestoreToPours (PCB->Data, VIA_TYPE, CURRENT, Pin);
   AddObjectToFlagUndoList (PIN_TYPE, element, Pin, Pin);
   if (!Delta)			/* remove the thermals */
     CLEAR_THERM (INDEXOFCURRENT, Pin);
   else
     ASSIGN_THERM (INDEXOFCURRENT, Delta, Pin);
   AddObjectToClearPolyUndoList (PIN_TYPE, element, Pin, Pin, True);
-  ClearFromPour (PCB->Data, VIA_TYPE, CURRENT, Pin);
+  ClearFromPours (PCB->Data, VIA_TYPE, CURRENT, Pin);
   DrawPin (Pin, 0);
   return Pin;
 }
@@ -442,7 +442,7 @@ ChangeViaSize (PinTypePtr Via)
       AddObjectToSizeUndoList (VIA_TYPE, Via, Via, Via);
       EraseVia (Via);
       r_delete_entry (PCB->Data->via_tree, (BoxType *) Via);
-      RestoreToPour (PCB->Data, PIN_TYPE, Via, Via);
+      RestoreToPours (PCB->Data, PIN_TYPE, Via, Via);
       if (Via->Mask)
 	{
 	  AddObjectToMaskSizeUndoList (VIA_TYPE, Via, Via, Via);
@@ -451,7 +451,7 @@ ChangeViaSize (PinTypePtr Via)
       Via->Thickness = value;
       SetPinBoundingBox (Via);
       r_insert_entry (PCB->Data->via_tree, (BoxType *) Via, 0);
-      ClearFromPour (PCB->Data, VIA_TYPE, Via, Via);
+      ClearFromPours (PCB->Data, VIA_TYPE, Via, Via);
       DrawVia (Via, 0);
       return (Via);
     }
@@ -480,10 +480,10 @@ ChangeVia2ndSize (PinTypePtr Via)
       Via->DrillingHole = value;
       if (TEST_FLAG (HOLEFLAG, Via))
 	{
-	  RestoreToPour (PCB->Data, VIA_TYPE, Via, Via);
+	  RestoreToPours (PCB->Data, VIA_TYPE, Via, Via);
 	  AddObjectToSizeUndoList (VIA_TYPE, Via, Via, Via);
 	  Via->Thickness = value;
-	  ClearFromPour (PCB->Data, VIA_TYPE, Via, Via);
+	  ClearFromPours (PCB->Data, VIA_TYPE, Via, Via);
 	}
       DrawVia (Via, 0);
       return (Via);
@@ -512,14 +512,14 @@ ChangeViaClearSize (PinTypePtr Via)
     value = PCB->Bloat * 2 + 2;
   if (Via->Clearance == value)
     return NULL;
-  RestoreToPour (PCB->Data, VIA_TYPE, Via, Via);
+  RestoreToPours (PCB->Data, VIA_TYPE, Via, Via);
   AddObjectToClearSizeUndoList (VIA_TYPE, Via, Via, Via);
   EraseVia (Via);
   r_delete_entry (PCB->Data->via_tree, (BoxType *) Via);
   Via->Clearance = value;
   SetPinBoundingBox (Via);
   r_insert_entry (PCB->Data->via_tree, (BoxType *) Via, 0);
-  ClearFromPour (PCB->Data, VIA_TYPE, Via, Via);
+  ClearFromPours (PCB->Data, VIA_TYPE, Via, Via);
   DrawVia (Via, 0);
   Via->Element = NULL;
   return (Via);
@@ -546,12 +546,12 @@ ChangePinSize (ElementTypePtr Element, PinTypePtr Pin)
       AddObjectToMaskSizeUndoList (PIN_TYPE, Element, Pin, Pin);
       ErasePin (Pin);
       r_delete_entry (PCB->Data->pin_tree, &Pin->BoundingBox);
-      RestoreToPour (PCB->Data, PIN_TYPE, Element, Pin);
+      RestoreToPours (PCB->Data, PIN_TYPE, Element, Pin);
       Pin->Mask += value - Pin->Thickness;
       Pin->Thickness = value;
       /* SetElementBB updates all associated rtrees */
       SetElementBoundingBox (PCB->Data, Element, &PCB->Font);
-      ClearFromPour (PCB->Data, PIN_TYPE, Element, Pin);
+      ClearFromPours (PCB->Data, PIN_TYPE, Element, Pin);
       DrawPin (Pin, 0);
       return (Pin);
     }
@@ -572,14 +572,14 @@ ChangePinClearSize (ElementTypePtr Element, PinTypePtr Pin)
   value = MIN (MAX_LINESIZE, MAX (value, PCB->Bloat * 2 + 2));
   if (Pin->Clearance == value)
     return NULL;
-  RestoreToPour (PCB->Data, PIN_TYPE, Element, Pin);
+  RestoreToPours (PCB->Data, PIN_TYPE, Element, Pin);
   AddObjectToClearSizeUndoList (PIN_TYPE, Element, Pin, Pin);
   ErasePin (Pin);
   r_delete_entry (PCB->Data->pin_tree, &Pin->BoundingBox);
   Pin->Clearance = value;
   /* SetElementBB updates all associated rtrees */
   SetElementBoundingBox (PCB->Data, Element, &PCB->Font);
-  ClearFromPour (PCB->Data, PIN_TYPE, Element, Pin);
+  ClearFromPours (PCB->Data, PIN_TYPE, Element, Pin);
   DrawPin (Pin, 0);
   return (Pin);
 }
@@ -599,14 +599,14 @@ ChangePadSize (ElementTypePtr Element, PadTypePtr Pad)
     {
       AddObjectToSizeUndoList (PAD_TYPE, Element, Pad, Pad);
       AddObjectToMaskSizeUndoList (PAD_TYPE, Element, Pad, Pad);
-      RestoreToPour (PCB->Data, PAD_TYPE, Element, Pad);
+      RestoreToPours (PCB->Data, PAD_TYPE, Element, Pad);
       ErasePad (Pad);
       r_delete_entry (PCB->Data->pad_tree, &Pad->BoundingBox);
       Pad->Mask += value - Pad->Thickness;
       Pad->Thickness = value;
       /* SetElementBB updates all associated rtrees */
       SetElementBoundingBox (PCB->Data, Element, &PCB->Font);
-      ClearFromPour (PCB->Data, PAD_TYPE, Element, Pad);
+      ClearFromPours (PCB->Data, PAD_TYPE, Element, Pad);
       DrawPad (Pad, 0);
       return (Pad);
     }
@@ -628,13 +628,13 @@ ChangePadClearSize (ElementTypePtr Element, PadTypePtr Pad)
   if (value <= MAX_PADSIZE && value >= MIN_PADSIZE && value != Pad->Clearance)
     {
       AddObjectToClearSizeUndoList (PAD_TYPE, Element, Pad, Pad);
-      RestoreToPour (PCB->Data, PAD_TYPE, Element, Pad);
+      RestoreToPours (PCB->Data, PAD_TYPE, Element, Pad);
       ErasePad (Pad);
       r_delete_entry (PCB->Data->pad_tree, &Pad->BoundingBox);
       Pad->Clearance = value;
       /* SetElementBB updates all associated rtrees */
       SetElementBoundingBox (PCB->Data, Element, &PCB->Font);
-      ClearFromPour (PCB->Data, PAD_TYPE, Element, Pad);
+      ClearFromPours (PCB->Data, PAD_TYPE, Element, Pad);
       DrawPad (Pad, 0);
       return (Pad);
     }
@@ -670,10 +670,10 @@ ChangeElement2ndSize (ElementTypePtr Element)
 	DrawPin (pin, 0);
 	if (TEST_FLAG (HOLEFLAG, pin))
 	  {
-	    RestoreToPour (PCB->Data, PIN_TYPE, Element, pin);
+	    RestoreToPours (PCB->Data, PIN_TYPE, Element, pin);
 	    AddObjectToSizeUndoList (PIN_TYPE, Element, pin, pin);
 	    pin->Thickness = value;
-	    ClearFromPour (PCB->Data, PIN_TYPE, Element, pin);
+	    ClearFromPours (PCB->Data, PIN_TYPE, Element, pin);
 	  }
       }
   }
@@ -707,10 +707,10 @@ ChangePin2ndSize (ElementTypePtr Element, PinTypePtr Pin)
       DrawPin (Pin, 0);
       if (TEST_FLAG (HOLEFLAG, Pin))
 	{
-	  RestoreToPour (PCB->Data, PIN_TYPE, Element, Pin);
+	  RestoreToPours (PCB->Data, PIN_TYPE, Element, Pin);
 	  AddObjectToSizeUndoList (PIN_TYPE, Element, Pin, Pin);
 	  Pin->Thickness = value;
-	  ClearFromPour (PCB->Data, PIN_TYPE, Element, Pin);
+	  ClearFromPours (PCB->Data, PIN_TYPE, Element, Pin);
 	}
       return (Pin);
     }
@@ -734,11 +734,11 @@ ChangeLineSize (LayerTypePtr Layer, LineTypePtr Line)
       AddObjectToSizeUndoList (LINE_TYPE, Layer, Line, Line);
       EraseLine (Line);
       r_delete_entry (Layer->line_tree, (BoxTypePtr) Line);
-      RestoreToPour (PCB->Data, LINE_TYPE, Layer, Line);
+      RestoreToPours (PCB->Data, LINE_TYPE, Layer, Line);
       Line->Thickness = value;
       SetLineBoundingBox (Line);
       r_insert_entry (Layer->line_tree, (BoxTypePtr) Line, 0);
-      ClearFromPour (PCB->Data, LINE_TYPE, Layer, Line);
+      ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
       DrawLine (Layer, Line, 0);
       return (Line);
     }
@@ -760,7 +760,7 @@ ChangeLineClearSize (LayerTypePtr Layer, LineTypePtr Line)
   if (value != Line->Clearance)
     {
       AddObjectToClearSizeUndoList (LINE_TYPE, Layer, Line, Line);
-      RestoreToPour (PCB->Data, LINE_TYPE, Layer, Line);
+      RestoreToPours (PCB->Data, LINE_TYPE, Layer, Line);
       EraseLine (Line);
       r_delete_entry (Layer->line_tree, (BoxTypePtr) Line);
       Line->Clearance = value;
@@ -771,7 +771,7 @@ ChangeLineClearSize (LayerTypePtr Layer, LineTypePtr Line)
 	}
       SetLineBoundingBox (Line);
       r_insert_entry (Layer->line_tree, (BoxTypePtr) Line, 0);
-      ClearFromPour (PCB->Data, LINE_TYPE, Layer, Line);
+      ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
       DrawLine (Layer, Line, 0);
       return (Line);
     }
@@ -795,11 +795,11 @@ ChangeArcSize (LayerTypePtr Layer, ArcTypePtr Arc)
       AddObjectToSizeUndoList (ARC_TYPE, Layer, Arc, Arc);
       EraseArc (Arc);
       r_delete_entry (Layer->arc_tree, (BoxTypePtr) Arc);
-      RestoreToPour (PCB->Data, ARC_TYPE, Layer, Arc);
+      RestoreToPours (PCB->Data, ARC_TYPE, Layer, Arc);
       Arc->Thickness = value;
       SetArcBoundingBox (Arc);
       r_insert_entry (Layer->arc_tree, (BoxTypePtr) Arc, 0);
-      ClearFromPour (PCB->Data, ARC_TYPE, Layer, Arc);
+      ClearFromPours (PCB->Data, ARC_TYPE, Layer, Arc);
       DrawArc (Layer, Arc, 0);
       return (Arc);
     }
@@ -823,7 +823,7 @@ ChangeArcClearSize (LayerTypePtr Layer, ArcTypePtr Arc)
       AddObjectToClearSizeUndoList (ARC_TYPE, Layer, Arc, Arc);
       EraseArc (Arc);
       r_delete_entry (Layer->arc_tree, (BoxTypePtr) Arc);
-      RestoreToPour (PCB->Data, ARC_TYPE, Layer, Arc);
+      RestoreToPours (PCB->Data, ARC_TYPE, Layer, Arc);
       Arc->Clearance = value;
       if (Arc->Clearance == 0)
 	{
@@ -832,7 +832,7 @@ ChangeArcClearSize (LayerTypePtr Layer, ArcTypePtr Arc)
 	}
       SetArcBoundingBox (Arc);
       r_insert_entry (Layer->arc_tree, (BoxTypePtr) Arc, 0);
-      ClearFromPour (PCB->Data, ARC_TYPE, Layer, Arc);
+      ClearFromPours (PCB->Data, ARC_TYPE, Layer, Arc);
       DrawArc (Layer, Arc, 0);
       return (Arc);
     }
@@ -856,11 +856,11 @@ ChangeTextSize (LayerTypePtr Layer, TextTypePtr Text)
       AddObjectToSizeUndoList (TEXT_TYPE, Layer, Text, Text);
       EraseText (Layer, Text);
       r_delete_entry (Layer->text_tree, (BoxTypePtr) Text);
-      RestoreToPour (PCB->Data, TEXT_TYPE, Layer, Text);
+      RestoreToPours (PCB->Data, TEXT_TYPE, Layer, Text);
       Text->Scale = value;
       SetTextBoundingBox (&PCB->Font, Text);
       r_insert_entry (Layer->text_tree, (BoxTypePtr) Text, 0);
-      ClearFromPour (PCB->Data, TEXT_TYPE, Layer, Text);
+      ClearFromPours (PCB->Data, TEXT_TYPE, Layer, Text);
       DrawText (Layer, Text, 0);
       return (Text);
     }
@@ -1061,12 +1061,12 @@ ChangeTextName (LayerTypePtr Layer, TextTypePtr Text)
   if (TEST_FLAG (LOCKFLAG, Text))
     return (NULL);
   EraseText (Layer, Text);
-  RestoreToPour (PCB->Data, TEXT_TYPE, Layer, Text);
+  RestoreToPours (PCB->Data, TEXT_TYPE, Layer, Text);
   Text->TextString = NewName;
 
   /* calculate size of the bounding box */
   SetTextBoundingBox (&PCB->Font, Text);
-  ClearFromPour (PCB->Data, TEXT_TYPE, Layer, Text);
+  ClearFromPours (PCB->Data, TEXT_TYPE, Layer, Text);
   DrawText (Layer, Text, 0);
   return (old);
 }
@@ -1121,14 +1121,14 @@ ChangeLineJoin (LayerTypePtr Layer, LineTypePtr Line)
   if (TEST_FLAG(CLEARLINEFLAG, Line))
   {
   AddObjectToClearPolyUndoList (LINE_TYPE, Layer, Line, Line, False);
-  RestoreToPour (PCB->Data, LINE_TYPE, Layer, Line);
+  RestoreToPours (PCB->Data, LINE_TYPE, Layer, Line);
   }
   AddObjectToFlagUndoList (LINE_TYPE, Layer, Line, Line);
   TOGGLE_FLAG (CLEARLINEFLAG, Line);
   if (TEST_FLAG(CLEARLINEFLAG, Line))
   {
   AddObjectToClearPolyUndoList (LINE_TYPE, Layer, Line, Line, True);
-  ClearFromPour (PCB->Data, LINE_TYPE, Layer, Line);
+  ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
   }
   DrawLine (Layer, Line, 0);
   return (Line);
@@ -1167,14 +1167,14 @@ ChangeArcJoin (LayerTypePtr Layer, ArcTypePtr Arc)
   EraseArc (Arc);
   if (TEST_FLAG (CLEARLINEFLAG, Arc))
   {
-    RestoreToPour (PCB->Data, ARC_TYPE, Layer, Arc);
+    RestoreToPours (PCB->Data, ARC_TYPE, Layer, Arc);
     AddObjectToClearPolyUndoList (ARC_TYPE, Layer, Arc, Arc, False);
     }
   AddObjectToFlagUndoList (ARC_TYPE, Layer, Arc, Arc);
   TOGGLE_FLAG (CLEARLINEFLAG, Arc);
   if (TEST_FLAG (CLEARLINEFLAG, Arc))
   {
-    ClearFromPour (PCB->Data, ARC_TYPE, Layer, Arc);
+    ClearFromPours (PCB->Data, ARC_TYPE, Layer, Arc);
   AddObjectToClearPolyUndoList (ARC_TYPE, Layer, Arc, Arc, True);
   }
   DrawArc (Layer, Arc, 0);
@@ -1215,14 +1215,14 @@ ChangeTextJoin (LayerTypePtr Layer, TextTypePtr Text)
   if (TEST_FLAG(CLEARLINEFLAG, Text))
   {
   AddObjectToClearPolyUndoList (TEXT_TYPE, Layer, Text, Text, False);
-  RestoreToPour (PCB->Data, TEXT_TYPE, Layer, Text);
+  RestoreToPours (PCB->Data, TEXT_TYPE, Layer, Text);
   }
   AddObjectToFlagUndoList (LINE_TYPE, Layer, Text, Text);
   TOGGLE_FLAG (CLEARLINEFLAG, Text);
   if (TEST_FLAG(CLEARLINEFLAG, Text))
   {
   AddObjectToClearPolyUndoList (TEXT_TYPE, Layer, Text, Text, True);
-  ClearFromPour (PCB->Data, TEXT_TYPE, Layer, Text);
+  ClearFromPours (PCB->Data, TEXT_TYPE, Layer, Text);
   }
   DrawText (Layer, Text, 0);
   return (Text);
@@ -1240,14 +1240,14 @@ ChangePolyJoin (LayerTypePtr Layer, PolygonTypePtr poly)
   if (TEST_FLAG(CLEARLINEFLAG, poly))
   {
   AddObjectToClearPolyUndoList (POLYGON_TYPE, Layer, poly, poly, False);
-  RestoreToPour (PCB->Data, POLYGON_TYPE, Layer, poly);
+  RestoreToPours (PCB->Data, POLYGON_TYPE, Layer, poly);
   }
   AddObjectToFlagUndoList (LINE_TYPE, Layer, poly, poly);
   TOGGLE_FLAG (CLEARLINEFLAG, poly);
   if (TEST_FLAG(CLEARLINEFLAG, poly))
   {
   AddObjectToClearPolyUndoList (POLYGON_TYPE, Layer, poly, poly, True);
-  ClearFromPour (PCB->Data, POLYGON_TYPE, Layer, poly);
+  ClearFromPours (PCB->Data, POLYGON_TYPE, Layer, poly);
   }
   DrawPolygon (Layer, poly, 0);
   return (poly);
@@ -1265,14 +1265,14 @@ ChangePourJoin (LayerTypePtr Layer, PourTypePtr pour)
   if (TEST_FLAG(CLEARLINEFLAG, pour))
   {
   AddObjectToClearPourUndoList (POLYGON_TYPE, Layer, pour, pour, False);
-  RestoreToPour (PCB->Data, POLYGON_TYPE, Layer, pour);
+  RestoreToPours (PCB->Data, POLYGON_TYPE, Layer, pour);
   }
   AddObjectToFlagUndoList (LINE_TYPE, Layer, pour, pour);
   TOGGLE_FLAG (CLEARLINEFLAG, pour);
   if (TEST_FLAG(CLEARLINEFLAG, pour))
   {
   AddObjectToClearPourUndoList (POLYGON_TYPE, Layer, pour, pour, True);
-  ClearFromPour (PCB->Data, POLYGON_TYPE, Layer, pour);
+  ClearFromPours (PCB->Data, POLYGON_TYPE, Layer, pour);
   }
   DrawPour (Layer, pour, 0);
   return (pour);
@@ -1480,11 +1480,11 @@ ChangePadSquare (ElementTypePtr Element, PadTypePtr Pad)
     return (NULL);
   ErasePad (Pad);
   AddObjectToClearPolyUndoList (PAD_TYPE, Element, Pad, Pad, False);
-  RestoreToPour (PCB->Data, PAD_TYPE, Element, Pad);
+  RestoreToPours (PCB->Data, PAD_TYPE, Element, Pad);
   AddObjectToFlagUndoList (PAD_TYPE, Element, Pad, Pad);
   TOGGLE_FLAG (SQUAREFLAG, Pad);
   AddObjectToClearPolyUndoList (PAD_TYPE, Element, Pad, Pad, True);
-  ClearFromPour (PCB->Data, PAD_TYPE, Element, Pad);
+  ClearFromPours (PCB->Data, PAD_TYPE, Element, Pad);
   DrawPad (Pad, 0);
   return (Pad);
 }
@@ -1527,11 +1527,11 @@ ChangePinSquare (ElementTypePtr Element, PinTypePtr Pin)
     return (NULL);
   ErasePin (Pin);
   AddObjectToClearPolyUndoList (PIN_TYPE, Element, Pin, Pin, False);
-  RestoreToPour (PCB->Data, PIN_TYPE, Element, Pin);
+  RestoreToPours (PCB->Data, PIN_TYPE, Element, Pin);
   AddObjectToFlagUndoList (PIN_TYPE, Element, Pin, Pin);
   TOGGLE_FLAG (SQUAREFLAG, Pin);
   AddObjectToClearPolyUndoList (PIN_TYPE, Element, Pin, Pin, True);
-  ClearFromPour (PCB->Data, PIN_TYPE, Element, Pin);
+  ClearFromPours (PCB->Data, PIN_TYPE, Element, Pin);
   DrawPin (Pin, 0);
   return (Pin);
 }
@@ -1570,11 +1570,11 @@ ChangeViaOctagon (PinTypePtr Via)
     return (NULL);
   EraseVia (Via);
   AddObjectToClearPolyUndoList (VIA_TYPE, Via, Via, Via, False);
-  RestoreToPour (PCB->Data, VIA_TYPE, Via, Via);
+  RestoreToPours (PCB->Data, VIA_TYPE, Via, Via);
   AddObjectToFlagUndoList (VIA_TYPE, Via, Via, Via);
   TOGGLE_FLAG (OCTAGONFLAG, Via);
   AddObjectToClearPolyUndoList (VIA_TYPE, Via, Via, Via, True);
-  ClearFromPour (PCB->Data, VIA_TYPE, Via, Via);
+  ClearFromPours (PCB->Data, VIA_TYPE, Via, Via);
   DrawVia (Via, 0);
   return (Via);
 }
@@ -1613,11 +1613,11 @@ ChangePinOctagon (ElementTypePtr Element, PinTypePtr Pin)
     return (NULL);
   ErasePin (Pin);
   AddObjectToClearPolyUndoList (PIN_TYPE, Element, Pin, Pin, False);
-  RestoreToPour (PCB->Data, PIN_TYPE, Element, Pin);
+  RestoreToPours (PCB->Data, PIN_TYPE, Element, Pin);
   AddObjectToFlagUndoList (PIN_TYPE, Element, Pin, Pin);
   TOGGLE_FLAG (OCTAGONFLAG, Pin);
   AddObjectToClearPolyUndoList (PIN_TYPE, Element, Pin, Pin, True);
-  ClearFromPour (PCB->Data, PIN_TYPE, Element, Pin);
+  ClearFromPours (PCB->Data, PIN_TYPE, Element, Pin);
   DrawPin (Pin, 0);
   return (Pin);
 }
@@ -1659,10 +1659,10 @@ ChangeHole (PinTypePtr Via)
   TOGGLE_FLAG (HOLEFLAG, Via);
   if (TEST_FLAG (HOLEFLAG, Via))
     {
-      RestoreToPour (PCB->Data, VIA_TYPE, Via, Via);
+      RestoreToPours (PCB->Data, VIA_TYPE, Via, Via);
       AddObjectToSizeUndoList (VIA_TYPE, Via, Via, Via);
       Via->Thickness = Via->Mask = Via->DrillingHole;
-      ClearFromPour (PCB->Data, VIA_TYPE, Via, Via);
+      ClearFromPours (PCB->Data, VIA_TYPE, Via, Via);
     }
   else
     {
diff --git a/src/copy.c b/src/copy.c
index c315d68..f9c2dfa 100644
--- a/src/copy.c
+++ b/src/copy.c
@@ -378,7 +378,7 @@ CopyPastebufferToLayout (LocationType X, LocationType Y)
 	  changed = changed ||
 	    (sourcelayer->LineN != 0) ||
 	    (sourcelayer->ArcN != 0) ||
-	    (sourcelayer->PolygonN != 0) || (sourcelayer->TextN != 0);
+	    (sourcelayer->PourN != 0) || (sourcelayer->TextN != 0);
 	  LINE_LOOP (sourcelayer);
 	  {
 	    CopyLine (destlayer, line);
diff --git a/src/create.c b/src/create.c
index 8830d41..e6a0abd 100644
--- a/src/create.c
+++ b/src/create.c
@@ -594,9 +594,9 @@ CreateNewText (LayerTypePtr Layer, FontTypePtr PCBFont,
  * creates a new polygon on a layer
  */
 PolygonTypePtr
-CreateNewPolygon (LayerTypePtr Layer, FlagType Flags)
+CreateNewPolygonInPour (PourType *pour, FlagType Flags)
 {
-  PolygonTypePtr polygon = GetPolygonMemory (Layer);
+  PolygonTypePtr polygon = GetPolygonMemoryInPour (pour);
 
   /* copy values */
   polygon->Flags = Flags;
@@ -604,7 +604,7 @@ CreateNewPolygon (LayerTypePtr Layer, FlagType Flags)
   polygon->Clipped = NULL;
   polygon->NoHoles = NULL;
   polygon->NoHolesValid = 0;
-  polygon->ParentPour = NULL;
+  polygon->ParentPour = pour;
   return (polygon);
 }
 
@@ -619,6 +619,14 @@ CreateNewPour (LayerTypePtr Layer, FlagType Flags)
   /* copy values */
   pour->Flags = Flags;
   pour->ID = ID++;
+
+  pour->PointN = 0;
+  pour->PointMax = 0;
+  pour->Points = NULL;
+  pour->PolygonN = 0;
+  pour->PolygonMax = 0;
+  pour->Polygons = NULL;
+
   return (pour);
 }
 
diff --git a/src/create.h b/src/create.h
index 7d5116e..644b53e 100644
--- a/src/create.h
+++ b/src/create.h
@@ -59,7 +59,7 @@ PourTypePtr CreateNewPourFromRectangle (LayerTypePtr, LocationType,
 					      LocationType, FlagType);
 TextTypePtr CreateNewText (LayerTypePtr, FontTypePtr, LocationType,
 			   LocationType, BYTE, int, char *, FlagType);
-PolygonTypePtr CreateNewPolygon (LayerTypePtr, FlagType);
+PolygonTypePtr CreateNewPolygonInPour (PourType *pour, FlagType);
 PourTypePtr CreateNewPour (LayerTypePtr, FlagType);
 PointTypePtr CreateNewPointInPour (PourTypePtr,
 				      LocationType, LocationType);
diff --git a/src/crosshair.c b/src/crosshair.c
index a34c86a..2cf6824 100644
--- a/src/crosshair.c
+++ b/src/crosshair.c
@@ -370,9 +370,11 @@ XORDrawBuffer (BufferTypePtr Buffer)
 	/* the tmp polygon has n+1 points because the first
 	 * and the last one are set to the same coordinates
 	 */
-	POLYGON_LOOP (layer);
+	POUR_LOOP (layer);
 	{
-	  XORPolygon (polygon, x, y);
+	  XORPour (pour, x, y);
+#warning FIXME Later
+//	  XORPolygon (polygon, x, y);
 	}
 	END_LOOP;
       }
diff --git a/src/draw.c b/src/draw.c
index 9868c95..c796c29 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -958,7 +958,7 @@ DrawLayerGroup (int group, const BoxType * screen)
 #endif
 
 	  /* draw all polygons on this layer */
-	  if (Layer->PolygonN)
+	  if (Layer->polygon_tree)
 	    {
 	      info.Layer = Layer;
 	      info.arg = True;
diff --git a/src/file.c b/src/file.c
index 1072005..57d8b48 100644
--- a/src/file.c
+++ b/src/file.c
@@ -778,7 +778,7 @@ WriteLayerData (FILE * FP, Cardinal Number, LayerTypePtr layer)
 {
   int n;
   /* write information about non empty layers */
-  if (layer->LineN || layer->ArcN || layer->TextN || layer->PolygonN ||
+  if (layer->LineN || layer->ArcN || layer->TextN || layer->PourN ||
       (layer->Name && *layer->Name))
     {
       fprintf (FP, "Layer(%i ", (int) Number + 1);
diff --git a/src/find.c b/src/find.c
index edf2f7e..ee40a96 100644
--- a/src/find.c
+++ b/src/find.c
@@ -540,6 +540,7 @@ void
 InitLayoutLookup (void)
 {
   Cardinal i;
+  int polycount;
 
   /* initialize line arc and polygon data */
   for (i = 0; i < max_layer; i++)
@@ -564,12 +565,18 @@ InitLayoutLookup (void)
 
 
       /* allocate memory for polygon list */
-      if (layer->PolygonN)
+      polycount = 0;
+      POUR_LOOP (layer);
+      {
+        polycount += pour->PolygonN;
+      }
+      END_LOOP;
+      if (polycount)
         {
-          PolygonList[i].Data = (void **) MyCalloc (layer->PolygonN,
+          PolygonList[i].Data = (void **) MyCalloc (polycount,
                                                     sizeof (PolygonTypePtr),
                                                     "InitLayoutLookup()");
-          PolygonList[i].Size = layer->PolygonN;
+          PolygonList[i].Size = polycount;
         }
 
       /* clear some struct members */
@@ -1777,15 +1784,13 @@ LookupLOConnectionsToArc (ArcTypePtr Arc, Cardinal LayerGroup)
   /* loop over all layers of the group */
   for (entry = 0; entry < PCB->LayerGroups.Number[LayerGroup]; entry++)
     {
-      Cardinal layer, i;
+      Cardinal layer;
 
       layer = PCB->LayerGroups.Entries[LayerGroup][entry];
 
       /* handle normal layers */
       if (layer < max_layer)
         {
-          PolygonTypePtr polygon;
-
           info.layer = layer;
           /* add arcs */
           if (setjmp (info.env) == 0)
@@ -1801,12 +1806,18 @@ LookupLOConnectionsToArc (ArcTypePtr Arc, Cardinal LayerGroup)
             return True;
 
           /* now check all polygons */
-          i = 0;
-          polygon = PCB->Data->Layer[layer].Polygon;
-          for (; i < PCB->Data->Layer[layer].PolygonN; i++, polygon++)
-            if (!TEST_FLAG (TheFlag, polygon) && IsArcInPolygon (Arc, polygon)
-                && ADD_POLYGON_TO_LIST (layer, polygon))
-              return True;
+          POUR_LOOP (LAYER_PTR (layer));
+          {
+            POURPOLYGON_LOOP (pour);
+            {
+              if (!TEST_FLAG (TheFlag, polygon) &&
+                  IsArcInPolygon (Arc, polygon) &&
+                  ADD_POLYGON_TO_LIST (layer, polygon))
+                return True;
+            }
+            END_LOOP;
+          }
+          END_LOOP;
         }
       else
         {
@@ -1922,8 +1933,6 @@ LookupLOConnectionsToLine (LineTypePtr Line, Cardinal LayerGroup,
       /* handle normal layers */
       if (layer < max_layer)
         {
-          PolygonTypePtr polygon;
-
           info.layer = layer;
           /* add lines */
           if (setjmp (info.env) == 0)
@@ -1940,13 +1949,18 @@ LookupLOConnectionsToLine (LineTypePtr Line, Cardinal LayerGroup,
           /* now check all polygons */
           if (PolysTo)
             {
-              Cardinal i = 0;
-              polygon = PCB->Data->Layer[layer].Polygon;
-              for (; i < PCB->Data->Layer[layer].PolygonN; i++, polygon++)
-                if (!TEST_FLAG
-                    (TheFlag, polygon) && IsLineInPolygon (Line, polygon)
-                    && ADD_POLYGON_TO_LIST (layer, polygon))
-                  return True;
+              POUR_LOOP (LAYER_PTR (layer));
+              {
+                POURPOLYGON_LOOP (pour);
+                {
+                  if (!TEST_FLAG (TheFlag, polygon) &&
+                      IsLineInPolygon (Line, polygon) &&
+                      ADD_POLYGON_TO_LIST (layer, polygon))
+                    return True;
+                }
+                END_LOOP;
+              }
+              END_LOOP;
             }
         }
       else
@@ -2004,7 +2018,6 @@ static Boolean
 LOTouchesLine (LineTypePtr Line, Cardinal LayerGroup)
 {
   Cardinal entry;
-  Cardinal i;
   struct lo_info info;
 
 
@@ -2021,8 +2034,6 @@ LOTouchesLine (LineTypePtr Line, Cardinal LayerGroup)
       /* handle normal layers */
       if (layer < max_layer)
         {
-          PolygonTypePtr polygon;
-
           /* find the first line that touches coordinates */
 
           if (setjmp (info.env) == 0)
@@ -2037,12 +2048,17 @@ LOTouchesLine (LineTypePtr Line, Cardinal LayerGroup)
             return (True);
 
           /* now check all polygons */
-          i = 0;
-          polygon = PCB->Data->Layer[layer].Polygon;
-          for (; i < PCB->Data->Layer[layer].PolygonN; i++, polygon++)
-            if (!TEST_FLAG (TheFlag, polygon)
-                && IsLineInPolygon (Line, polygon))
-              return (True);
+          POUR_LOOP (LAYER_PTR (layer));
+          {
+            POURPOLYGON_LOOP (pour);
+            {
+              if (!TEST_FLAG (TheFlag, polygon) &&
+                  IsLineInPolygon (Line, polygon))
+                return (True);
+            }
+            END_LOOP;
+          }
+          END_LOOP;
         }
       else
         {
@@ -2406,23 +2422,27 @@ LookupLOConnectionsToPolygon (PolygonTypePtr Polygon, Cardinal LayerGroup)
 /* loop over all layers of the group */
   for (entry = 0; entry < PCB->LayerGroups.Number[LayerGroup]; entry++)
     {
-      Cardinal layer, i;
+      Cardinal layer;
 
       layer = PCB->LayerGroups.Entries[LayerGroup][entry];
 
       /* handle normal layers */
       if (layer < max_layer)
         {
-          PolygonTypePtr polygon;
-
           /* check all polygons */
 
-          polygon = PCB->Data->Layer[layer].Polygon;
-          for (i = 0; i < PCB->Data->Layer[layer].PolygonN; i++, polygon++)
-            if (!TEST_FLAG (TheFlag, polygon)
-                && IsPolygonInPolygon (polygon, Polygon)
-                && ADD_POLYGON_TO_LIST (layer, polygon))
-              return True;
+          POUR_LOOP (LAYER_PTR (layer));
+          {
+            POURPOLYGON_LOOP (pour);
+            {
+              if (!TEST_FLAG (TheFlag, polygon) &&
+                  IsPolygonInPolygon (polygon, Polygon) &&
+                  ADD_POLYGON_TO_LIST (layer, polygon))
+                return True;
+            }
+            END_LOOP;
+          }
+          END_LOOP;
 
           info.layer = layer;
           /* check all lines */
@@ -3387,17 +3407,21 @@ ResetFoundLinesAndPolygons (Boolean AndDraw)
       }
   }
   ENDALL_LOOP;
-  COPPERPOLYGON_LOOP (PCB->Data);
+  COPPERPOUR_LOOP (PCB->Data);
   {
-    if (TEST_FLAG (TheFlag, polygon))
-      {
-        if (AndDraw)
-          AddObjectToFlagUndoList (POLYGON_TYPE, layer, polygon, polygon);
-        CLEAR_FLAG (TheFlag, polygon);
-        if (AndDraw)
-          DrawPolygon (layer, polygon, 0);
-        change = True;
-      }
+    POURPOLYGON_LOOP (pour);
+    {
+      if (TEST_FLAG (TheFlag, polygon))
+        {
+          if (AndDraw)
+            AddObjectToFlagUndoList (POLYGON_TYPE, layer, polygon, polygon);
+          CLEAR_FLAG (TheFlag, polygon);
+          if (AndDraw)
+            DrawPolygon (layer, polygon, 0);
+          change = True;
+        }
+    }
+    END_LOOP;
   }
   ENDALL_LOOP;
   if (change)
diff --git a/src/global.h b/src/global.h
index a4b2415..29e1ae9 100644
--- a/src/global.h
+++ b/src/global.h
@@ -210,7 +210,7 @@ typedef struct			/* holds information about a poured area */
 
   Cardinal PolygonN;		/* number of polygons this pour has */
   Cardinal PolygonMax;		/* max number from malloc() */
-  PolygonTypePtr polygons;	/* pour polygons */
+  PolygonTypePtr Polygons;	/* pour polygons */
 
   /* r_tree? */
 
@@ -222,7 +222,7 @@ struct polygon_st		/* holds information about a polygon */
 
 //  Cardinal PointN,		/* number of points in polygon */
 //  Cardinal PointMax;		/* max number from malloc() */
-  PointTypePtr Points;		/* data */
+//  PointTypePtr Points;		/* data */
 
   POLYAREA *Clipped;		/* the clipped region of this polygon */
 
@@ -254,14 +254,17 @@ typedef struct			/* holds information about one layer */
   char *Name;			/* layer name */
   Cardinal LineN,		/* number of lines */
     TextN,			/* labels */
-    PolygonN,			/* polygons */
+//    PolygonN,			/* polygons */
     PourN,			/* poured areas */
     ArcN,			/* and arcs */
     LineMax,			/* max number from malloc() */
-    TextMax, PolygonMax, PourMax, ArcMax;
+    TextMax,
+//    PolygonMax,
+    PourMax,
+    ArcMax;
   LineTypePtr Line;		/* pointer to additional structures */
   TextTypePtr Text;
-  PolygonTypePtr Polygon;
+//  PolygonTypePtr Polygon;
   PourTypePtr Pour;
   ArcTypePtr Arc;
   rtree_t *line_tree, *text_tree, *polygon_tree, *pour_tree, *arc_tree;
diff --git a/src/hid/gerber/gerber.c b/src/hid/gerber/gerber.c
index e506876..54c010f 100644
--- a/src/hid/gerber/gerber.c
+++ b/src/hid/gerber/gerber.c
@@ -362,7 +362,7 @@ gerber_do_export (HID_Attr_Val * options)
   for (i = 0; i < max_layer; i++)
     {
       LayerType *layer = PCB->Data->Layer + i;
-      if (layer->LineN || layer->TextN || layer->ArcN || layer->PolygonN)
+      if (layer->LineN || layer->TextN || layer->ArcN || layer->PourN)
 	print_group[GetLayerGroupNumberByNumber (i)] = 1;
     }
   print_group[GetLayerGroupNumberByNumber (max_layer)] = 1;
diff --git a/src/hid/nelma/nelma.c b/src/hid/nelma/nelma.c
index e7d0f9f..1fd0993 100644
--- a/src/hid/nelma/nelma.c
+++ b/src/hid/nelma/nelma.c
@@ -525,7 +525,7 @@ nelma_choose_groups()
 		layer = &PCB->Data->Layer[n];
 
 		if (layer->LineN || layer->TextN || layer->ArcN ||
-		    layer->PolygonN) {
+		    layer->PourN) {
 			/* layer isn't empty */
 
 			/*
diff --git a/src/hid/png/png.c b/src/hid/png/png.c
index 5b924c5..82ba1e7 100644
--- a/src/hid/png/png.c
+++ b/src/hid/png/png.c
@@ -286,7 +286,7 @@ png_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
   for (i = 0; i < max_layer; i++)
     {
       LayerType *layer = PCB->Data->Layer + i;
-      if (layer->LineN || layer->TextN || layer->ArcN || layer->PolygonN)
+      if (layer->LineN || layer->TextN || layer->ArcN || layer->PourN)
 	print_group[GetLayerGroupNumberByNumber (i)] = 1;
     }
   print_group[GetLayerGroupNumberByNumber (max_layer)] = 1;
diff --git a/src/hid/ps/eps.c b/src/hid/ps/eps.c
index 0759a88..a129b3b 100644
--- a/src/hid/ps/eps.c
+++ b/src/hid/ps/eps.c
@@ -149,7 +149,7 @@ eps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
     {
       LayerType *layer = PCB->Data->Layer + i;
       if (layer->On)
-	if (layer->LineN || layer->TextN || layer->ArcN || layer->PolygonN)
+	if (layer->LineN || layer->TextN || layer->ArcN || layer->PourN)
 	  print_group[GetLayerGroupNumberByNumber (i)] = 1;
     }
 
diff --git a/src/hid/ps/ps.c b/src/hid/ps/ps.c
index 5c59bb9..d698af9 100644
--- a/src/hid/ps/ps.c
+++ b/src/hid/ps/ps.c
@@ -362,7 +362,7 @@ ps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
   for (i = 0; i < max_layer; i++)
     {
       LayerType *layer = PCB->Data->Layer + i;
-      if (layer->LineN || layer->TextN || layer->ArcN || layer->PolygonN)
+      if (layer->LineN || layer->TextN || layer->ArcN || layer->PourN)
 	print_group[GetLayerGroupNumberByNumber (i)] = 1;
 
       if (strcmp (layer->Name, "outline") == 0
diff --git a/src/macro.h b/src/macro.h
index ea605a4..8b9696b 100644
--- a/src/macro.h
+++ b/src/macro.h
@@ -391,12 +391,14 @@ extern int mem_any_set (unsigned char *, int);
 	{						\
 		text = &(layer)->Text[n]
 
+#if 0
 #define	POLYGON_LOOP(layer) do {			\
 	Cardinal		n;			\
 	PolygonTypePtr	polygon;			\
 	for (n = (layer)->PolygonN-1; n != -1; n--)	\
 	{						\
 		polygon = &(layer)->Polygon[n]
+#endif
 
 #define	POLYGONPOINT_LOOP(polygon) do	{	\
 	Cardinal			n;		\
@@ -419,6 +421,13 @@ extern int mem_any_set (unsigned char *, int);
 	{						\
 		point = &(pour)->Points[n]
 
+#define	POURPOLYGON_LOOP(pour) do	{	\
+	Cardinal			n;		\
+	PolygonTypePtr	polygon;				\
+	for (n = (pour)->PolygonN-1; n != -1; n--)	\
+	{						\
+		polygon = &(pour)->Polygons[n]
+
 #define ENDALL_LOOP }} while (0);  }} while (0)
 
 #define	ALLPIN_LOOP(top)	\
@@ -443,12 +452,14 @@ extern int mem_any_set (unsigned char *, int);
 	{ \
 		ARC_LOOP(layer)
 
+#if 0
 #define	ALLPOLYGON_LOOP(top)	do {		\
 	Cardinal		l;			\
 	LayerTypePtr	layer = (top)->Layer;		\
 	for (l = 0; l < max_layer + 2; l++, layer++)	\
 	{ \
 		POLYGON_LOOP(layer)
+#endif
 
 #define	ALLPOUR_LOOP(top)	do {		\
 	Cardinal		l;			\
@@ -471,12 +482,21 @@ extern int mem_any_set (unsigned char *, int);
 	{ \
 		ARC_LOOP(layer)
 
+#if 0
 #define	COPPERPOLYGON_LOOP(top) do	{		\
 	Cardinal		l;			\
 	LayerTypePtr	layer = (top)->Layer;		\
 	for (l = 0; l < max_layer; l++, layer++)	\
 	{ \
 		POLYGON_LOOP(layer)
+#endif
+
+#define	COPPERPOUR_LOOP(top) do	{		\
+	Cardinal		l;			\
+	LayerTypePtr	layer = (top)->Layer;		\
+	for (l = 0; l < max_layer; l++, layer++)	\
+	{ \
+		POUR_LOOP(layer)
 
 #define	SILKLINE_LOOP(top) do	{		\
 	Cardinal		l;			\
@@ -494,6 +514,7 @@ extern int mem_any_set (unsigned char *, int);
 	{ \
 		ARC_LOOP(layer)
 
+#if 0
 #define	SILKPOLYGON_LOOP(top) do	{		\
 	Cardinal		l;			\
 	LayerTypePtr	layer = (top)->Layer;		\
@@ -501,6 +522,15 @@ extern int mem_any_set (unsigned char *, int);
 	for (l = 0; l < 2; l++, layer++)		\
 	{ \
 		POLYGON_LOOP(layer)
+#endif
+
+#define	SILKPOUR_LOOP(top) do	{		\
+	Cardinal		l;			\
+	LayerTypePtr	layer = (top)->Layer;		\
+	layer += max_layer;				\
+	for (l = 0; l < 2; l++, layer++)		\
+	{ \
+		POUR_LOOP(layer)
 
 #define	ALLTEXT_LOOP(top)	do {		\
 	Cardinal		l;			\
@@ -533,6 +563,7 @@ extern int mem_any_set (unsigned char *, int);
                 TEXT_LOOP(layer);                                      \
                   if (TEXT_IS_VISIBLE((board), layer, text))
 
+#if 0
 #define	VISIBLEPOLYGON_LOOP(top) do	{	\
 	Cardinal		l;			\
 	LayerTypePtr	layer = (top)->Layer;		\
@@ -540,6 +571,15 @@ extern int mem_any_set (unsigned char *, int);
 	{ \
 		if (layer->On)				\
 			POLYGON_LOOP(layer)
+#endif
+
+#define	VISIBLEPOUR_LOOP(top) do	{	\
+	Cardinal		l;			\
+	LayerTypePtr	layer = (top)->Layer;		\
+	for (l = 0; l < max_layer + 2; l++, layer++)	\
+	{ \
+		if (layer->On)				\
+			POUR_LOOP(layer)
 
 #define POINTER_LOOP(top) do	{	\
 	Cardinal	n;			\
diff --git a/src/mirror.c b/src/mirror.c
index 4ba63aa..1b76e88 100644
--- a/src/mirror.c
+++ b/src/mirror.c
@@ -79,14 +79,14 @@ MirrorElementCoordinates (DataTypePtr Data, ElementTypePtr Element,
   END_LOOP;
   PIN_LOOP (Element);
   {
-    RestoreToPour (Data, PIN_TYPE, Element, pin);
+    RestoreToPours (Data, PIN_TYPE, Element, pin);
     pin->X = SWAP_X (pin->X);
     pin->Y = SWAP_Y (pin->Y) + yoff;
   }
   END_LOOP;
   PAD_LOOP (Element);
   {
-    RestoreToPour (Data, PAD_TYPE, Element, pad);
+    RestoreToPours (Data, PAD_TYPE, Element, pad);
     pad->Point1.X = SWAP_X (pad->Point1.X);
     pad->Point1.Y = SWAP_Y (pad->Point1.Y) + yoff;
     pad->Point2.X = SWAP_X (pad->Point2.X);
@@ -116,5 +116,5 @@ MirrorElementCoordinates (DataTypePtr Data, ElementTypePtr Element,
   TOGGLE_FLAG (ONSOLDERFLAG, Element);
   /* this inserts all of the rtree data too */
   SetElementBoundingBox (Data, Element, &PCB->Font);
-  ClearFromPour (Data, ELEMENT_TYPE, Element, Element);
+  ClearFromPours (Data, ELEMENT_TYPE, Element, Element);
 }
diff --git a/src/misc.c b/src/misc.c
index fb620d0..ce44f58 100644
--- a/src/misc.c
+++ b/src/misc.c
@@ -239,24 +239,16 @@ SetLineBoundingBox (LineTypePtr Line)
 }
 
 /* ---------------------------------------------------------------------------
- * sets the bounding box of a polygons
+ * sets the bounding box of a polygon
  */
 void
 SetPolygonBoundingBox (PolygonTypePtr Polygon)
 {
-  Polygon->BoundingBox.X1 = Polygon->BoundingBox.Y1 = MAX_COORD;
-  Polygon->BoundingBox.X2 = Polygon->BoundingBox.Y2 = 0;
-#define FIXME Later
-#if 0
-  POLYGONPOINT_LOOP (Polygon);
-  {
-    MAKEMIN (Polygon->BoundingBox.X1, point->X);
-    MAKEMIN (Polygon->BoundingBox.Y1, point->Y);
-    MAKEMAX (Polygon->BoundingBox.X2, point->X);
-    MAKEMAX (Polygon->BoundingBox.Y2, point->Y);
-  }
-  END_LOOP;
-#endif
+  PLINE *outer = Polygon->Clipped->contours;
+  Polygon->BoundingBox.X1 = outer->xmin;
+  Polygon->BoundingBox.Y1 = outer->ymin;
+  Polygon->BoundingBox.X2 = outer->xmax;
+  Polygon->BoundingBox.Y2 = outer->ymax;
 }
 
 /* ---------------------------------------------------------------------------
@@ -512,7 +504,9 @@ IsDataEmpty (DataTypePtr Data)
     hasNoObjects = hasNoObjects &&
       Data->Layer[i].LineN == 0 &&
       Data->Layer[i].ArcN == 0 &&
-      Data->Layer[i].TextN == 0 && Data->Layer[i].PolygonN == 0;
+      Data->Layer[i].TextN == 0 &&
+      Data->Layer[i].PourN == 0;
+
   return (hasNoObjects);
 }
 
@@ -591,13 +585,17 @@ GetDataBoundingBox (DataTypePtr Data)
     box.Y2 = MAX (box.Y2, text->BoundingBox.Y2);
   }
   ENDALL_LOOP;
-  ALLPOLYGON_LOOP (Data);
-  {
-    box.X1 = MIN (box.X1, polygon->BoundingBox.X1);
-    box.Y1 = MIN (box.Y1, polygon->BoundingBox.Y1);
-    box.X2 = MAX (box.X2, polygon->BoundingBox.X2);
-    box.Y2 = MAX (box.Y2, polygon->BoundingBox.Y2);
-  }
+  ALLPOUR_LOOP (Data);
+    {
+      POURPOLYGON_LOOP (pour);
+      {
+        box.X1 = MIN (box.X1, polygon->BoundingBox.X1);
+        box.Y1 = MIN (box.Y1, polygon->BoundingBox.Y1);
+        box.X2 = MAX (box.X2, polygon->BoundingBox.X2);
+        box.Y2 = MAX (box.Y2, polygon->BoundingBox.Y2);
+      }
+      END_LOOP;
+    }
   ENDALL_LOOP;
   return (IsDataEmpty (Data) ? NULL : &box);
 }
@@ -1600,14 +1598,14 @@ ChangeArcAngles (LayerTypePtr Layer, ArcTypePtr a,
       new_da = 360;
       new_sa = 0;
     }
-  RestoreToPour (PCB->Data, ARC_TYPE, Layer, a);
+  RestoreToPours (PCB->Data, ARC_TYPE, Layer, a);
   r_delete_entry (Layer->arc_tree, (BoxTypePtr) a);
   AddObjectToChangeAnglesUndoList (ARC_TYPE, a, a, a);
   a->StartAngle = new_sa;
   a->Delta = new_da;
   SetArcBoundingBox (a);
   r_insert_entry (Layer->arc_tree, (BoxTypePtr) a, 0);
-  ClearFromPour (PCB->Data, ARC_TYPE, Layer, a);
+  ClearFromPours (PCB->Data, ARC_TYPE, Layer, a);
 }
 
 static char *
@@ -1693,8 +1691,13 @@ GetGridLockCoordinates (int type, void *ptr1,
       *y = ((ElementTypePtr) ptr2)->MarkY;
       break;
     case POLYGON_TYPE:
+#warning FIXME Later
+      *x = 1000;
+      *y = 1000;
+#if 0
       *x = ((PolygonTypePtr) ptr2)->Points[0].X;
       *y = ((PolygonTypePtr) ptr2)->Points[0].Y;
+#endif
       break;
 
     case LINEPOINT_TYPE:
diff --git a/src/move.c b/src/move.c
index 53faba3..b2704ad 100644
--- a/src/move.c
+++ b/src/move.c
@@ -73,7 +73,7 @@ static void *MoveVia (PinTypePtr);
 static void *MoveLine (LayerTypePtr, LineTypePtr);
 static void *MoveArc (LayerTypePtr, ArcTypePtr);
 static void *MoveText (LayerTypePtr, TextTypePtr);
-static void *MovePolygon (LayerTypePtr, PolygonTypePtr);
+//static void *MovePolygon (LayerTypePtr, PolygonTypePtr);
 static void *MovePour (LayerTypePtr, PourTypePtr);
 static void *MoveLinePoint (LayerTypePtr, LineTypePtr, PointTypePtr);
 static void *MovePourPoint (LayerTypePtr, PourTypePtr, PointTypePtr);
@@ -81,7 +81,7 @@ static void *MoveLineToLayer (LayerTypePtr, LineTypePtr);
 static void *MoveArcToLayer (LayerTypePtr, ArcTypePtr);
 static void *MoveRatToLayer (RatTypePtr);
 static void *MoveTextToLayer (LayerTypePtr, TextTypePtr);
-static void *MovePolygonToLayer (LayerTypePtr, PolygonTypePtr);
+//static void *MovePolygonToLayer (LayerTypePtr, PolygonTypePtr);
 static void *MovePourToLayer (LayerTypePtr, PourTypePtr);
 
 /* ---------------------------------------------------------------------------
@@ -94,7 +94,7 @@ static Boolean MoreToCome;
 static ObjectFunctionType MoveFunctions = {
   MoveLine,
   MoveText,
-  MovePolygon,
+  NULL, // MovePolygon,
   MovePour,
   MoveVia,
   MoveElement,
@@ -111,7 +111,7 @@ static ObjectFunctionType MoveFunctions = {
 {
 MoveLineToLayer,
     MoveTextToLayer,
-    MovePolygonToLayer,
+    NULL, //MovePolygonToLayer,
     MovePourToLayer,
     NULL,
     NULL,
@@ -143,13 +143,13 @@ MoveElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
     if (Data)
       {
 	r_delete_entry (Data->pin_tree, (BoxType *) pin);
-	RestoreToPour (Data, PIN_TYPE, Element, pin);
+	RestoreToPours (Data, PIN_TYPE, Element, pin);
       }
     MOVE_PIN_LOWLEVEL (pin, DX, DY);
     if (Data)
       {
 	r_insert_entry (Data->pin_tree, (BoxType *) pin, 0);
-	ClearFromPour (Data, PIN_TYPE, Element, pin);
+	ClearFromPours (Data, PIN_TYPE, Element, pin);
       }
   }
   END_LOOP;
@@ -158,13 +158,13 @@ MoveElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
     if (Data)
       {
 	r_delete_entry (Data->pad_tree, (BoxType *) pad);
-	RestoreToPour (Data, PAD_TYPE, Element, pad);
+	RestoreToPours (Data, PAD_TYPE, Element, pad);
       }
     MOVE_PAD_LOWLEVEL (pad, DX, DY);
     if (Data)
       {
 	r_insert_entry (Data->pad_tree, (BoxType *) pad, 0);
-	ClearFromPour (Data, PAD_TYPE, Element, pad);
+	ClearFromPours (Data, PAD_TYPE, Element, pad);
       }
   }
   END_LOOP;
@@ -264,12 +264,12 @@ static void *
 MoveVia (PinTypePtr Via)
 {
   r_delete_entry (PCB->Data->via_tree, (BoxTypePtr) Via);
-  RestoreToPour (PCB->Data, VIA_TYPE, Via, Via);
+  RestoreToPours (PCB->Data, VIA_TYPE, Via, Via);
   MOVE_VIA_LOWLEVEL (Via, DeltaX, DeltaY);
   if (PCB->ViaOn)
     EraseVia (Via);
   r_insert_entry (PCB->Data->via_tree, (BoxTypePtr) Via, 0);
-  ClearFromPour (PCB->Data, VIA_TYPE, Via, Via);
+  ClearFromPours (PCB->Data, VIA_TYPE, Via, Via);
   if (PCB->ViaOn)
     {
       DrawVia (Via, 0);
@@ -286,11 +286,11 @@ MoveLine (LayerTypePtr Layer, LineTypePtr Line)
 {
   if (Layer->On)
     EraseLine (Line);
-  RestoreToPour (PCB->Data, LINE_TYPE, Layer, Line);
+  RestoreToPours (PCB->Data, LINE_TYPE, Layer, Line);
   r_delete_entry (Layer->line_tree, (BoxTypePtr) Line);
   MOVE_LINE_LOWLEVEL (Line, DeltaX, DeltaY);
   r_insert_entry (Layer->line_tree, (BoxTypePtr) Line, 0);
-  ClearFromPour (PCB->Data, LINE_TYPE, Layer, Line);
+  ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
   if (Layer->On)
     {
       DrawLine (Layer, Line, 0);
@@ -305,7 +305,7 @@ MoveLine (LayerTypePtr Layer, LineTypePtr Line)
 static void *
 MoveArc (LayerTypePtr Layer, ArcTypePtr Arc)
 {
-  RestoreToPour (PCB->Data, ARC_TYPE, Layer, Arc);
+  RestoreToPours (PCB->Data, ARC_TYPE, Layer, Arc);
   r_delete_entry (Layer->arc_tree, (BoxTypePtr) Arc);
   if (Layer->On)
     {
@@ -319,7 +319,7 @@ MoveArc (LayerTypePtr Layer, ArcTypePtr Arc)
       MOVE_ARC_LOWLEVEL (Arc, DeltaX, DeltaY);
     }
   r_insert_entry (Layer->arc_tree, (BoxTypePtr) Arc, 0);
-  ClearFromPour (PCB->Data, ARC_TYPE, Layer, Arc);
+  ClearFromPours (PCB->Data, ARC_TYPE, Layer, Arc);
   return (Arc);
 }
 
@@ -329,7 +329,7 @@ MoveArc (LayerTypePtr Layer, ArcTypePtr Arc)
 static void *
 MoveText (LayerTypePtr Layer, TextTypePtr Text)
 {
-  RestoreToPour (PCB->Data, TEXT_TYPE, Layer, Text);
+  RestoreToPours (PCB->Data, TEXT_TYPE, Layer, Text);
   r_delete_entry (Layer->text_tree, (BoxTypePtr) Text);
   if (Layer->On)
     {
@@ -341,7 +341,7 @@ MoveText (LayerTypePtr Layer, TextTypePtr Text)
   else
     MOVE_TEXT_LOWLEVEL (Text, DeltaX, DeltaY);
   r_insert_entry (Layer->text_tree, (BoxTypePtr) Text, 0);
-  ClearFromPour (PCB->Data, TEXT_TYPE, Layer, Text);
+  ClearFromPours (PCB->Data, TEXT_TYPE, Layer, Text);
   return (Text);
 }
 
@@ -378,6 +378,8 @@ MovePourLowLevel (PourTypePtr Pour, LocationType DeltaX,
   MOVE_BOX_LOWLEVEL (&Pour->BoundingBox, DeltaX, DeltaY);
 }
 
+#warning FIXME Later
+#if 0
 /* ---------------------------------------------------------------------------
  * moves a polygon
  */
@@ -388,12 +390,12 @@ MovePolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
     {
       ErasePolygon (Polygon);
     }
-  RestoreToPour (PCB->Data, POLYGON_TYPE, Layer, Polygon);
+  RestoreToPours (PCB->Data, POLYGON_TYPE, Layer, Polygon);
   r_delete_entry (Layer->polygon_tree, (BoxType *) Polygon);
   MovePolygonLowLevel (Polygon, DeltaX, DeltaY);
   r_insert_entry (Layer->polygon_tree, (BoxType *) Polygon, 0);
   InitClip (PCB->Data, Layer, Polygon);
-  ClearFromPour (PCB->Data, POLYGON_TYPE, Layer, Polygon);
+  ClearFromPours (PCB->Data, POLYGON_TYPE, Layer, Polygon);
   if (Layer->On)
     {
       DrawPolygon (Layer, Polygon, 0);
@@ -401,6 +403,7 @@ MovePolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
     }
   return (Polygon);
 }
+#endif
 
 /* ---------------------------------------------------------------------------
  * moves a pour
@@ -412,12 +415,12 @@ MovePour (LayerTypePtr Layer, PourTypePtr Pour)
     {
       ErasePour (Pour);
     }
-//  RestoreToPour (PCB->Data, POLYGON_TYPE, Layer, Pour);
+//  RestoreToPours (PCB->Data, POLYGON_TYPE, Layer, Pour);
   r_delete_entry (Layer->pour_tree, (BoxType *) Pour);
   MovePourLowLevel (Pour, DeltaX, DeltaY);
   r_insert_entry (Layer->pour_tree, (BoxType *) Pour, 0);
   InitPourClip (PCB->Data, Layer, Pour);
-//  ClearFromPour (PCB->Data, POLYGON_TYPE, Layer, Polygon);
+//  ClearFromPours (PCB->Data, POLYGON_TYPE, Layer, Polygon);
   if (Layer->On)
     {
       DrawPour (Layer, Pour, 0);
@@ -436,12 +439,12 @@ MoveLinePoint (LayerTypePtr Layer, LineTypePtr Line, PointTypePtr Point)
     {
       if (Layer->On)
 	EraseLine (Line);
-      RestoreToPour (PCB->Data, LINE_TYPE, Layer, Line);
+      RestoreToPours (PCB->Data, LINE_TYPE, Layer, Line);
       r_delete_entry (Layer->line_tree, &Line->BoundingBox);
       MOVE (Point->X, Point->Y, DeltaX, DeltaY);
       SetLineBoundingBox (Line);
       r_insert_entry (Layer->line_tree, &Line->BoundingBox, 0);
-      ClearFromPour (PCB->Data, LINE_TYPE, Layer, Line);
+      ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
       if (Layer->On)
 	{
 	  DrawLine (Layer, Line, 0);
@@ -476,14 +479,14 @@ MovePourPoint (LayerTypePtr Layer, PourTypePtr Pour, PointTypePtr Point)
     {
       ErasePour (Pour);
     }
-//  RestoreToPour (PCB->Data, POLYGON_TYPE, Layer, Polygon);
+//  RestoreToPours (PCB->Data, POLYGON_TYPE, Layer, Polygon);
   r_delete_entry (Layer->pour_tree, (BoxType *) Pour);
   MOVE (Point->X, Point->Y, DeltaX, DeltaY);
   SetPourBoundingBox (Pour);
   r_insert_entry (Layer->pour_tree, (BoxType *) Pour, 0);
   RemoveExcessPourPoints (Layer, Pour);
   InitPourClip (PCB->Data, Layer, Pour);
-//  ClearFromPour (PCB->Data, POLYGON_TYPE, Layer, Polygon);
+//  ClearFromPours (PCB->Data, POLYGON_TYPE, Layer, Polygon);
   if (Layer->On)
     {
       DrawPour (Layer, Pour, 0);
@@ -558,11 +561,11 @@ MoveArcToLayer (LayerTypePtr Layer, ArcTypePtr Arc)
   if (((long int) Dest == -1) || Dest == Layer)
     return (Arc);
   AddObjectToMoveToLayerUndoList (ARC_TYPE, Layer, Arc, Arc);
-  RestoreToPour (PCB->Data, ARC_TYPE, Layer, Arc);
+  RestoreToPours (PCB->Data, ARC_TYPE, Layer, Arc);
   if (Layer->On)
     EraseArc (Arc);
   new = MoveArcToLayerLowLevel (Layer, Arc, Dest);
-  ClearFromPour (PCB->Data, ARC_TYPE, Dest, Arc);
+  ClearFromPours (PCB->Data, ARC_TYPE, Dest, Arc);
   if (Dest->On)
     DrawArc (Dest, new, 0);
   Draw ();
@@ -652,10 +655,10 @@ MoveLineToLayer (LayerTypePtr Layer, LineTypePtr Line)
   AddObjectToMoveToLayerUndoList (LINE_TYPE, Layer, Line, Line);
   if (Layer->On)
     EraseLine (Line);
-  RestoreToPour (PCB->Data, LINE_TYPE, Layer, Line);
+  RestoreToPours (PCB->Data, LINE_TYPE, Layer, Line);
   new = MoveLineToLayerLowLevel (Layer, Line, Dest);
   Line = NULL;
-  ClearFromPour (PCB->Data, LINE_TYPE, Dest, new);
+  ClearFromPours (PCB->Data, LINE_TYPE, Dest, new);
   if (Dest->On)
     DrawLine (Dest, new, 0);
   Draw ();
@@ -706,7 +709,7 @@ MoveTextToLayerLowLevel (LayerTypePtr Source, TextTypePtr Text,
 {
   TextTypePtr new = GetTextMemory (Destination);
 
-  RestoreToPour (PCB->Data, TEXT_TYPE, Source, Text);
+  RestoreToPours (PCB->Data, TEXT_TYPE, Source, Text);
   r_delete_entry (Source->text_tree, (BoxTypePtr) Text);
   /* copy the data and remove it from the former layer */
   *new = *Text;
@@ -724,7 +727,7 @@ MoveTextToLayerLowLevel (LayerTypePtr Source, TextTypePtr Text,
   if (!Destination->text_tree)
     Destination->text_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (Destination->text_tree, (BoxTypePtr) new, 0);
-  ClearFromPour (PCB->Data, TEXT_TYPE, Destination, new);
+  ClearFromPours (PCB->Data, TEXT_TYPE, Destination, new);
   return (new);
 }
 
@@ -756,6 +759,8 @@ MoveTextToLayer (LayerTypePtr Layer, TextTypePtr Text)
   return (Text);
 }
 
+#warning FIXME Later
+#if 0
 /* ---------------------------------------------------------------------------
  * moves a polygon between layers; lowlevel routines
  */
@@ -778,6 +783,7 @@ MovePolygonToLayerLowLevel (LayerTypePtr Source, PolygonTypePtr Polygon,
   r_insert_entry (Destination->polygon_tree, (BoxType *) new, 0);
   return (new);
 }
+#endif
 
 /* ---------------------------------------------------------------------------
  * moves a pour between layers; lowlevel routines
@@ -827,6 +833,8 @@ mptl_pin_callback (const BoxType *b, void *cl)
   return 1;
 }
 
+#warning FIXME Later
+#if 0
 /* ---------------------------------------------------------------------------
  * moves a polygon between layers
  */
@@ -863,6 +871,7 @@ MovePolygonToLayer (LayerTypePtr Layer, PolygonTypePtr Polygon)
     }
   return (new);
 }
+#endif
 
 /* ---------------------------------------------------------------------------
  * moves a pour between layers
diff --git a/src/mtspace.c b/src/mtspace.c
index ee098de..fe5e374 100644
--- a/src/mtspace.c
+++ b/src/mtspace.c
@@ -380,7 +380,7 @@ mtspace_query_rect (mtspace_t * mtspace, const BoxType * region,
   assert (free_space_vec && vector_is_empty (free_space_vec));
   assert (lo_conflict_space_vec && vector_is_empty (lo_conflict_space_vec));
   assert (hi_conflict_space_vec && vector_is_empty (hi_conflict_space_vec));
-  assert (untested && no_fix && no_hi && hi_candidate);
+//  assert (untested && no_fix && no_hi && hi_candidate);
   /* search out to anything that might matter */
   if (region)
     {
diff --git a/src/mymem.c b/src/mymem.c
index 1458fc6..6c81603 100644
--- a/src/mymem.c
+++ b/src/mymem.c
@@ -431,29 +431,33 @@ GetPourMemory (LayerTypePtr Layer)
  * get next slot for a polygon object, allocates memory if necessary
  */
 PolygonTypePtr
-GetPolygonMemory (LayerTypePtr Layer)
+GetPolygonMemoryInPour (PourTypePtr Pour)
 {
-  PolygonTypePtr polygon = Layer->Polygon;
+  PolygonTypePtr polygon = Pour->Polygons;
 
   /* realloc new memory if necessary and clear it */
-  if (Layer->PolygonN >= Layer->PolygonMax)
+  if (Pour->PolygonN >= Pour->PolygonMax)
     {
-      Layer->PolygonMax += STEP_POLYGON;
-      if (Layer->polygon_tree)
-	r_destroy_tree (&Layer->polygon_tree);
-      polygon = MyRealloc (polygon, Layer->PolygonMax * sizeof (PolygonType),
-			   "GetPolygonMemory()");
-      Layer->Polygon = polygon;
-      memset (polygon + Layer->PolygonN, 0,
+      Pour->PolygonMax += STEP_POLYGON;
+#warning FIXME Later: r-tree polygons in a pour
+//      if (Pour->polygon_tree)
+//	r_destroy_tree (&Layer->polygon_tree);
+      polygon = MyRealloc (polygon, Pour->PolygonMax * sizeof (PolygonType),
+			   "GetPolygonMemoryInPour()");
+      Pour->Polygons = polygon;
+      memset (polygon + Pour->PolygonN, 0,
 	      STEP_POLYGON * sizeof (PolygonType));
-      Layer->polygon_tree = r_create_tree (NULL, 0, 0);
-      POLYGON_LOOP (Layer);
+#warning FIXME Later: r-tree polygons in a pour
+#if 0
+      Pour->polygon_tree = r_create_tree (NULL, 0, 0);
+      POURPOLYGON_LOOP (Pour);
       {
-	r_insert_entry (Layer->polygon_tree, (BoxType *) polygon, 0);
+	r_insert_entry (Pour->polygon_tree, (BoxType *) polygon, 0);
       }
       END_LOOP;
+#endif
     }
-  return (polygon + Layer->PolygonN++);
+  return (polygon + Pour->PolygonN++);
 }
 
 /* ---------------------------------------------------------------------------
@@ -779,13 +783,14 @@ FreePolygonMemory (PolygonTypePtr Polygon)
 {
   if (Polygon)
     {
-      MYFREE (Polygon->Points);
+//      MYFREE (Polygon->Points);
       if (Polygon->Clipped)
 	poly_Free (&Polygon->Clipped);
       if (Polygon->NoHoles)
 	poly_Free (&Polygon->NoHoles);
       memset (Polygon, 0, sizeof (PolygonType));
     }
+#warning FIXME Later: Need to ensure the pour structures are fixed up
 }
 
 /* ---------------------------------------------------------------------------
@@ -972,12 +977,15 @@ FreeDataMemory (DataTypePtr Data)
 	  MYFREE (layer->Line);
 	  MYFREE (layer->Arc);
 	  MYFREE (layer->Text);
+#warning FIXME Later
+#if 0
 	  POLYGON_LOOP (layer);
 	  {
 	    FreePolygonMemory (polygon);
 	  }
 	  END_LOOP;
-	  MYFREE (layer->Polygon);
+#endif
+//	  MYFREE (layer->Polygon);
 	  POUR_LOOP (layer);
 	  {
 	    FreePourMemory (pour);
diff --git a/src/mymem.h b/src/mymem.h
index 1863ee5..2732539 100644
--- a/src/mymem.h
+++ b/src/mymem.h
@@ -81,7 +81,7 @@ LineTypePtr GetLineMemory (LayerTypePtr);
 ArcTypePtr GetArcMemory (LayerTypePtr);
 RatTypePtr GetRatMemory (DataTypePtr);
 TextTypePtr GetTextMemory (LayerTypePtr);
-PolygonTypePtr GetPolygonMemory (LayerTypePtr);
+PolygonTypePtr GetPolygonMemoryInPour (PourTypePtr);
 PourTypePtr GetPourMemory (LayerTypePtr);
 PointTypePtr GetPointMemoryInPolygon (PolygonTypePtr);
 PointTypePtr GetPointMemoryInPour (PourTypePtr);
diff --git a/src/polygon.c b/src/polygon.c
index 8d14c27..72ba2f9 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -65,8 +65,6 @@ RCSID ("$Id$");
 
 #define ROUND(x) ((long)(((x) >= 0 ? (x) + 0.5  : (x) - 0.5)))
 
-#define UNSUBTRACT_BLOAT 10
-
 /* ---------------------------------------------------------------------------
  * local prototypes
  */
@@ -173,6 +171,7 @@ ContourToPoly (PLINE * contour)
 {
   POLYAREA *p;
   poly_PreContour (contour, TRUE);
+  poly_ChkContour (contour);
   assert (contour->Flags.orient == PLF_DIR);
   if (!(p = poly_Create ()))
     return NULL;
@@ -181,17 +180,17 @@ ContourToPoly (PLINE * contour)
   return p;
 }
 
+#warning FIXME Later
+#if 0
 static POLYAREA *
-original_poly (PolygonType * p)
+original_poly (PourType * p)
 {
   return NULL;
-#warning FIXME Later
-#if 0
   PLINE *contour = NULL;
   POLYAREA *np = NULL;
   Vector v;
 
-  /* first make initial polygon contour */
+  /* first make initial pour contour */
   POLYGONPOINT_LOOP (p);
   {
     v[0] = point->X;
@@ -227,11 +226,12 @@ original_poly (PolygonType * p)
   poly_InclContour (np, contour);
   assert (poly_Valid (np));
   return biggest (np);
-#endif
 }
+#endif
 
+#if 0
 static int
-ClipOriginal (PolygonType * poly)
+ClipOriginal (PourType * poly)
 {
   POLYAREA *p, *result;
   int r;
@@ -252,6 +252,7 @@ ClipOriginal (PolygonType * poly)
   assert (!poly->Clipped || poly_Valid (poly->Clipped));
   return 1;
 }
+#endif
 
 POLYAREA *
 RectPoly (LocationType x1, LocationType x2, LocationType y1, LocationType y2)
@@ -590,6 +591,8 @@ SquarePadPoly (PadType * pad, BDimension clear)
   return np;
 }
 
+#warning FIXME Later
+#if 0
 /* clear np1 from the polygon */
 static int
 Subtract (POLYAREA * np1, PolygonType * p, Boolean fnp)
@@ -633,6 +636,7 @@ Subtract (POLYAREA * np1, PolygonType * p, Boolean fnp)
              (p->BoundingBox.Y1 + p->BoundingBox.Y2) / 2);
   return 1;
 }
+#endif
 
 /* create a polygon of the pin clearance */
 POLYAREA *
@@ -664,418 +668,17 @@ BoxPolyBloated (BoxType *box, BDimension bloat)
                    box->Y1 - bloat, box->Y2 + bloat);
 }
 
-/* remove the pin clearance from the polygon */
-static int
-SubtractPin (DataType * d, PinType * pin, LayerType * l, PolygonType * p)
-{
-  POLYAREA *np;
-  Cardinal i;
-
-  if (pin->Clearance == 0)
-    return 0;
-  i = GetLayerNumber (d, l);
-  if (TEST_THERM (i, pin))
-    {
-      np = ThermPoly ((PCBTypePtr) (d->pcb), pin, i);
-      if (!np)
-        return 0;
-    }
-  else
-    {
-      np = PinPoly (pin, pin->Thickness, pin->Clearance);
-      if (!np)
-        return -1;
-    }
-  return Subtract (np, p, TRUE);
-}
-
-static int
-SubtractLine (LineType * line, PolygonType * p)
-{
-  POLYAREA *np;
-
-  if (!TEST_FLAG (CLEARLINEFLAG, line))
-    return 0;
-  if (!(np = LinePoly (line, line->Thickness + line->Clearance)))
-    return -1;
-  return Subtract (np, p, True);
-}
-
-static int
-SubtractArc (ArcType * arc, PolygonType * p)
-{
-  POLYAREA *np;
-
-  if (!TEST_FLAG (CLEARLINEFLAG, arc))
-    return 0;
-  if (!(np = ArcPoly (arc, arc->Thickness + arc->Clearance)))
-    return -1;
-  return Subtract (np, p, True);
-}
-
-static int
-SubtractText (TextType * text, PolygonType * p)
-{
-  POLYAREA *np;
-  const BoxType *b = &text->BoundingBox;
-
-  if (!TEST_FLAG (CLEARLINEFLAG, text))
-    return 0;
-  if (!(np = RoundRect (b->X1 + PCB->Bloat, b->X2 - PCB->Bloat,
-                        b->Y1 + PCB->Bloat, b->Y2 - PCB->Bloat, PCB->Bloat)))
-    return -1;
-  return Subtract (np, p, True);
-}
-
-static int
-SubtractPad (PadType * pad, PolygonType * p)
-{
-  POLYAREA *np = NULL;
-
-  if (TEST_FLAG (SQUAREFLAG, pad))
-    {
-      if (!
-          (np = SquarePadPoly (pad, pad->Thickness + pad->Clearance)))
-        return -1;
-    }
-  else
-    {
-      if (!
-          (np = LinePoly ((LineType *) pad, pad->Thickness + pad->Clearance)))
-        return -1;
-    }
-  return Subtract (np, p, True);
-}
-
-static int
-SubtractPolygon (PolygonType * poly, PolygonType * p)
-{
-  POLYAREA *np;
-
-  /* Don't subtract from ourselves! */
-  if (poly == p || !TEST_FLAG (CLEARLINEFLAG, poly))
-    return 0;
-
-  np = original_poly (poly);
-
-  return Subtract (np, p, True);
-}
-
-struct cpInfo
-{
-  const BoxType *other;
-  DataType *data;
-  LayerType *layer;
-  PolygonType *polygon;
-  Boolean solder;
-  jmp_buf env;
-};
-
-static int
-pin_sub_callback (const BoxType * b, void *cl)
-{
-  PinTypePtr pin = (PinTypePtr) b;
-  struct cpInfo *info = (struct cpInfo *) cl;
-  PolygonTypePtr polygon;
-
-  /* don't subtract the object that was put back! */
-  if (b == info->other)
-    return 0;
-  polygon = info->polygon;
-  if (SubtractPin (info->data, pin, info->layer, polygon) < 0)
-    longjmp (info->env, 1);
-  return 1;
-}
-
-static int
-arc_sub_callback (const BoxType * b, void *cl)
-{
-  ArcTypePtr arc = (ArcTypePtr) b;
-  struct cpInfo *info = (struct cpInfo *) cl;
-  PolygonTypePtr polygon;
-
-  /* don't subtract the object that was put back! */
-  if (b == info->other)
-    return 0;
-  if (!TEST_FLAG (CLEARLINEFLAG, arc))
-    return 0;
-  polygon = info->polygon;
-  if (SubtractArc (arc, polygon) < 0)
-    longjmp (info->env, 1);
-  return 1;
-}
-
-static int
-pad_sub_callback (const BoxType * b, void *cl)
-{
-  PadTypePtr pad = (PadTypePtr) b;
-  struct cpInfo *info = (struct cpInfo *) cl;
-  PolygonTypePtr polygon;
-
-  /* don't subtract the object that was put back! */
-  if (b == info->other)
-    return 0;
-  polygon = info->polygon;
-  if (XOR (TEST_FLAG (ONSOLDERFLAG, pad), !info->solder))
-    {
-      if (SubtractPad (pad, polygon) < 0)
-        longjmp (info->env, 1);
-      return 1;
-    }
-  return 0;
-}
-
-static int
-line_sub_callback (const BoxType * b, void *cl)
-{
-  LineTypePtr line = (LineTypePtr) b;
-  struct cpInfo *info = (struct cpInfo *) cl;
-  PolygonTypePtr polygon;
-
-  /* don't subtract the object that was put back! */
-  if (b == info->other)
-    return 0;
-  if (!TEST_FLAG (CLEARLINEFLAG, line))
-    return 0;
-  polygon = info->polygon;
-  if (SubtractLine (line, polygon) < 0)
-    longjmp (info->env, 1);
-  return 1;
-}
-
-static int
-text_sub_callback (const BoxType * b, void *cl)
-{
-  TextTypePtr text = (TextTypePtr) b;
-  struct cpInfo *info = (struct cpInfo *) cl;
-  PolygonTypePtr polygon;
-
-  /* don't subtract the object that was put back! */
-  if (b == info->other)
-    return 0;
-  if (!TEST_FLAG (CLEARLINEFLAG, text))
-    return 0;
-  polygon = info->polygon;
-  if (SubtractText (text, polygon) < 0)
-    longjmp (info->env, 1);
-  return 1;
-}
-
-static int
-poly_sub_callback (const BoxType * b, void *cl)
-{
-  PolygonTypePtr poly = (PolygonTypePtr) b;
-  struct cpInfo *info = (struct cpInfo *) cl;
-  PolygonTypePtr polygon;
-
-  /* don't subtract the object that was put back! */
-  if (b == info->other)
-    return 0;
-  if (!TEST_FLAG (CLEARLINEFLAG, poly))
-    return 0;
-  polygon = info->polygon;
-  if (SubtractPolygon (poly, polygon) < 0)
-    longjmp (info->env, 1);
-  return 1;
-}
-
-static int
-Group (DataTypePtr Data, Cardinal layer)
-{
-  Cardinal i, j;
-  for (i = 0; i < max_layer; i++)
-    for (j = 0; j < ((PCBType *) (Data->pcb))->LayerGroups.Number[i]; j++)
-      if (layer == ((PCBType *) (Data->pcb))->LayerGroups.Entries[i][j])
-        return i;
-  return i;
-}
-
-static int
-clearPoly (DataTypePtr Data, LayerTypePtr Layer, PolygonType * polygon,
-           const BoxType * here, BDimension expand)
-{
-  int r = 0;
-  BoxType region;
-  struct cpInfo info;
-  Cardinal group;
-
-  if (!TEST_FLAG (CLEARPOLYFLAG, polygon)
-      || GetLayerNumber (Data, Layer) >= max_layer)
-    return 0;
-  group = Group (Data, GetLayerNumber (Data, Layer));
-  info.solder = (group == Group (Data, max_layer + SOLDER_LAYER));
-  info.data = Data;
-  info.other = here;
-  info.layer = Layer;
-  info.polygon = polygon;
-  if (here)
-    region = clip_box (here, &polygon->BoundingBox);
-  else
-    region = polygon->BoundingBox;
-  region = bloat_box (&region, expand);
-
-  if (setjmp (info.env) == 0)
-    {
-      r = r_search (Data->via_tree, &region, NULL, pin_sub_callback, &info);
-      r += r_search (Data->pin_tree, &region, NULL, pin_sub_callback, &info);
-      GROUP_LOOP (Data, group);
-      {
-        r +=
-          r_search (layer->line_tree, &region, NULL, line_sub_callback,
-                    &info);
-        r +=
-          r_search (layer->arc_tree, &region, NULL, arc_sub_callback, &info);
-	r +=
-          r_search (layer->text_tree, &region, NULL, text_sub_callback, &info);
-        r +=
-          r_search (layer->polygon_tree, &region, NULL, poly_sub_callback, &info);
-      }
-      END_LOOP;
-      if (info.solder || group == Group (Data, max_layer + COMPONENT_LAYER))
-	r += r_search (Data->pad_tree, &region, NULL, pad_sub_callback, &info);
-    }
-  polygon->NoHolesValid = 0;
-  return r;
-}
-
-static int
-Unsubtract (POLYAREA * np1, PolygonType * p)
-{
-  POLYAREA *merged = NULL, *np = np1;
-  int x;
-  assert (np);
-  assert (p && p->Clipped);
-  x = poly_Boolean_free (p->Clipped, np, &merged, PBO_UNITE);
-  if (x != err_ok)
-    {
-      fprintf (stderr, "Error while clipping PBO_UNITE: %d\n", x);
-      poly_Free (&merged);
-      p->Clipped = NULL;
-      if (p->NoHoles) printf ("Just leaked in Unsubtract\n");
-      p->NoHoles = NULL;
-      return 0;
-    }
 #warning FIXME Later
-//  p->Clipped = biggest (merged);
-  p->Clipped = merged;
-  assert (!p->Clipped || poly_Valid (p->Clipped));
-  return ClipOriginal (p);
-}
-
-static int
-UnsubtractPin (PinType * pin, LayerType * l, PolygonType * p)
-{
-  POLYAREA *np;
-
-  /* overlap a bit to prevent gaps from rounding errors */
-  np = BoxPolyBloated (&pin->BoundingBox, UNSUBTRACT_BLOAT);
-
-  if (!np)
-    return 0;
-  if (!Unsubtract (np, p))
-    return 0;
-  clearPoly (PCB->Data, l, p, (const BoxType *) pin, 2 * UNSUBTRACT_BLOAT);
-  return 1;
-}
-
-static int
-UnsubtractArc (ArcType * arc, LayerType * l, PolygonType * p)
-{
-  POLYAREA *np;
-
-  if (!TEST_FLAG (CLEARLINEFLAG, arc))
-    return 0;
-
-  /* overlap a bit to prevent gaps from rounding errors */
-  np = BoxPolyBloated (&arc->BoundingBox, UNSUBTRACT_BLOAT);
-
-  if (!np)
-    return 0;
-  if (!Unsubtract (np, p))
-    return 0;
-  clearPoly (PCB->Data, l, p, (const BoxType *) arc, 2 * UNSUBTRACT_BLOAT);
-  return 1;
-}
-
-static int
-UnsubtractLine (LineType * line, LayerType * l, PolygonType * p)
-{
-  POLYAREA *np;
-
-  if (!TEST_FLAG (CLEARLINEFLAG, line))
-    return 0;
-
-  /* overlap a bit to prevent notches from rounding errors */
-  np = BoxPolyBloated (&line->BoundingBox, UNSUBTRACT_BLOAT);
-
-  if (!np)
-    return 0;
-  if (!Unsubtract (np, p))
-    return 0;
-  clearPoly (PCB->Data, l, p, (const BoxType *) line, 2 * UNSUBTRACT_BLOAT);
-  return 1;
-}
-
-static int
-UnsubtractText (TextType * text, LayerType * l, PolygonType * p)
-{
-  POLYAREA *np;
-
-  if (!TEST_FLAG (CLEARLINEFLAG, text))
-    return 0;
-
-  /* overlap a bit to prevent notches from rounding errors */
-  np = BoxPolyBloated (&text->BoundingBox, UNSUBTRACT_BLOAT);
-
-  if (!np)
-    return -1;
-  if (!Unsubtract (np, p))
-    return 0;
-  clearPoly (PCB->Data, l, p, (const BoxType *) text, 2 * UNSUBTRACT_BLOAT);
-  return 1;
-}
-
-static int
-UnsubtractPad (PadType * pad, LayerType * l, PolygonType * p)
-{
-  POLYAREA *np;
-
-  /* overlap a bit to prevent notches from rounding errors */
-  np = BoxPolyBloated (&pad->BoundingBox, UNSUBTRACT_BLOAT);
-
-  if (!np)
-    return 0;
-  if (!Unsubtract (np, p))
-    return 0;
-  clearPoly (PCB->Data, l, p, (const BoxType *) pad, 2 * UNSUBTRACT_BLOAT);
-  return 1;
-}
-
-static int
-UnsubtractPolygon (PolygonType * poly, LayerType * l, PolygonType * p)
-{
-  POLYAREA *np;
-
-  /* Don't subtract from ourselves! */
-  if (poly == p || !TEST_FLAG (CLEARLINEFLAG, poly))
-    return 0;
-
-  /* overlap a bit to prevent notches from rounding errors */
-  np = BoxPolyBloated (&poly->BoundingBox, UNSUBTRACT_BLOAT);
-
-  if (!np)
-    return 0;
-  if (!Unsubtract (np, p))
-    return 0;
-  clearPoly (PCB->Data, l, p, (const BoxType *) poly, 2 * UNSUBTRACT_BLOAT);
-  return 1;
-}
-
-static Boolean inhibit = False;
+//static Boolean inhibit = False;
 
 int
 InitClip (DataTypePtr Data, LayerTypePtr layer, PolygonType * p)
 {
+  /* NOP */
+  printf ("Someone called InitClip, bad someone.\n");
+  return 0;
+#warning FIXME Later
+#if 0
   if (inhibit)
     return 0;
   if (p->Clipped)
@@ -1092,6 +695,7 @@ InitClip (DataTypePtr Data, LayerTypePtr layer, PolygonType * p)
   else
     p->NoHolesValid = 0;
   return 1;
+#endif
 }
 
 /* find polygon holes in range, then call the callback function for
@@ -1135,72 +739,6 @@ struct plow_info
 };
 
 static int
-subtract_plow (DataTypePtr Data, LayerTypePtr Layer, PolygonTypePtr Polygon,
-               int type, void *ptr1, void *ptr2)
-{
-  if (!Polygon->Clipped)
-    return 0;
-  switch (type)
-    {
-    case PIN_TYPE:
-    case VIA_TYPE:
-      SubtractPin (Data, (PinTypePtr) ptr2, Layer, Polygon);
-      Polygon->NoHolesValid = 0;
-      return 1;
-    case LINE_TYPE:
-      SubtractLine ((LineTypePtr) ptr2, Polygon);
-      Polygon->NoHolesValid = 0;
-      return 1;
-    case ARC_TYPE:
-      SubtractArc ((ArcTypePtr) ptr2, Polygon);
-      Polygon->NoHolesValid = 0;
-      return 1;
-    case PAD_TYPE:
-      SubtractPad ((PadTypePtr) ptr2, Polygon);
-      Polygon->NoHolesValid = 0;
-      return 1;
-    case POLYGON_TYPE:
-      SubtractPolygon ((PolygonTypePtr) ptr2, Polygon);
-      Polygon->NoHolesValid = 0;
-      return 1;
-    case TEXT_TYPE:
-      SubtractText ((TextTypePtr) ptr2, Polygon);
-      Polygon->NoHolesValid = 0;
-      return 1;
-    }
-  return 0;
-}
-
-static int
-add_plow (DataTypePtr Data, LayerTypePtr Layer, PolygonTypePtr Polygon,
-          int type, void *ptr1, void *ptr2)
-{
-  switch (type)
-    {
-    case PIN_TYPE:
-    case VIA_TYPE:
-      UnsubtractPin ((PinTypePtr) ptr2, Layer, Polygon);
-      return 1;
-    case LINE_TYPE:
-      UnsubtractLine ((LineTypePtr) ptr2, Layer, Polygon);
-      return 1;
-    case ARC_TYPE:
-      UnsubtractArc ((ArcTypePtr) ptr2, Layer, Polygon);
-      return 1;
-    case PAD_TYPE:
-      UnsubtractPad ((PadTypePtr) ptr2, Layer, Polygon);
-      return 1;
-    case POLYGON_TYPE:
-      UnsubtractPolygon ((PolygonTypePtr) ptr2, Layer, Polygon);
-      return 1;
-    case TEXT_TYPE:
-      UnsubtractText ((TextTypePtr) ptr2, Layer, Polygon);
-      return 1;
-    }
-  return 0;
-}
-
-static int
 plow_callback (const BoxType * b, void *cl)
 {
   struct plow_info *plow = (struct plow_info *) cl;
@@ -1236,8 +774,7 @@ PlowsPolygon (DataType * Data, int type, void *ptr1, void *ptr2,
           LAYER_LOOP (Data, max_layer);
           {
             info.layer = layer;
-            r +=
-              r_search (layer->polygon_tree, &sb, NULL, plow_callback, &info);
+            r += r_search (layer->polygon_tree, &sb, NULL, plow_callback, &info);
           }
           END_LOOP;
         }
@@ -1247,8 +784,7 @@ PlowsPolygon (DataType * Data, int type, void *ptr1, void *ptr2,
                                                                          ((LayerTypePtr) ptr1))));
           {
             info.layer = layer;
-            r +=
-              r_search (layer->polygon_tree, &sb, NULL, plow_callback, &info);
+            r += r_search (layer->polygon_tree, &sb, NULL, plow_callback, &info);
           }
           END_LOOP;
         }
@@ -1305,21 +841,29 @@ PlowsPolygon (DataType * Data, int type, void *ptr1, void *ptr2,
   return r;
 }
 
+#if 0
 void
 RestoreToPolygon (DataType * Data, int type, void *ptr1, void *ptr2)
 {
   if (type == POLYGON_TYPE)
-    InitClip (PCB->Data, (LayerTypePtr) ptr1, (PolygonTypePtr) ptr2);
-  PlowsPolygon (Data, type, ptr1, ptr2, add_plow);
+    {
+      printf ("Calling InitClip from RestoreToPolygon\n");
+      InitClip (PCB->Data, (LayerTypePtr) ptr1, (PolygonTypePtr) ptr2);
+    }
+//  PlowsPolygon (Data, type, ptr1, ptr2, add_plow);
 }
 
 void
 ClearFromPolygon (DataType * Data, int type, void *ptr1, void *ptr2)
 {
   if (type == POLYGON_TYPE)
-    InitClip (PCB->Data, (LayerTypePtr) ptr1, (PolygonTypePtr) ptr2);
-  PlowsPolygon (Data, type, ptr1, ptr2, subtract_plow);
+    {
+      printf ("Calling InitClip from ClearFromPolygon\n");
+      InitClip (PCB->Data, (LayerTypePtr) ptr1, (PolygonTypePtr) ptr2);
+    }
+//  PlowsPolygon (Data, type, ptr1, ptr2, subtract_plow);
 }
+#endif
 
 Boolean
 isects (POLYAREA * a, PolygonTypePtr p, Boolean fr)
diff --git a/src/polygon.h b/src/polygon.h
index aec45ae..e203d07 100644
--- a/src/polygon.h
+++ b/src/polygon.h
@@ -38,15 +38,20 @@ int PolygonHoles (const BoxType * range, LayerTypePtr, PolygonTypePtr,
 int PlowsPolygon (DataType *, int, void *, void *,
 		  int (*callback) (DataTypePtr, LayerTypePtr, PolygonTypePtr, int, void *, void *));
 void ComputeNoHoles (PolygonType *poly);
+
 POLYAREA * ContourToPoly (PLINE *);
 POLYAREA * RectPoly (LocationType x1, LocationType x2, LocationType y1, LocationType y2);
-POLYAREA * CirclePoly(LocationType x, LocationType y, BDimension radius);
 POLYAREA * OctagonPoly(LocationType x, LocationType y, BDimension radius);
-POLYAREA * LinePoly(LineType *l, BDimension thick);
+void frac_circle (PLINE *, LocationType, LocationType, Vector, int);
+POLYAREA * CirclePoly(LocationType x, LocationType y, BDimension radius);
+POLYAREA * RoundRect (LocationType x1, LocationType x2, LocationType y1, LocationType y2, BDimension t);
 POLYAREA * ArcPoly(ArcType *l, BDimension thick);
+POLYAREA * LinePoly(LineType *l, BDimension thick);
+POLYAREA * SquarePadPoly (PadType * pad, BDimension clear);
+
 POLYAREA * PinPoly(PinType *l, BDimension thick, BDimension clear);
 POLYAREA * BoxPolyBloated (BoxType *box, BDimension radius);
-void frac_circle (PLINE *, LocationType, LocationType, Vector, int);
+
 int InitClip(DataType *d, LayerType *l, PolygonType *p);
 void RestoreToPolygon(DataType *, int, void *, void *);
 void ClearFromPolygon(DataType *, int, void *, void *);
diff --git a/src/polygon1.c b/src/polygon1.c
index 82adaf5..606eb9a 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -2427,15 +2427,18 @@ inside_sector (VNODE * pn, Vector p2)
 BOOLp
 poly_ChkContour (PLINE * a)
 {
-  VNODE *a1, *a2, *hit1, *hit2;
+#warning FIXME Later: Deliberately disabled this test - seems something strange is going on
+  return FALSE;
+  VNODE *a1, *a2, *a2_start, *hit1, *hit2;
   Vector i1, i2;
   int icnt;
+  double d1,d2;
 
   assert (a != NULL);
   a1 = &a->head;
   do
     {
-      a2 = a1;
+      a2_start = a2 = a1;
       do
 	{
 	  if (!node_neighbours (a1, a2) &&
@@ -2443,21 +2446,36 @@ poly_ChkContour (PLINE * a)
 				    a2->point, a2->next->point, i1, i2)) > 0)
 	    {
 	      if (icnt > 1)
-		return TRUE;
+                {
+                  printf ("Returning true 1\n");
+		  return TRUE;
+                }
 
-	      if (vect_dist2 (i1, a1->point) < EPSILON)
+              d1 = -1; d2 = -1;
+	      if ((d1=vect_dist2 (i1, a1->point)) < EPSILON)
 		hit1 = a1;
-	      else if (vect_dist2 (i1, a1->next->point) < EPSILON)
+	      else if ((d2=vect_dist2 (i1, a1->next->point)) < EPSILON)
 		hit1 = a1->next;
 	      else
-		return TRUE;
+                {
+                  printf ("Returning true 2, %f, %f, %f\n", EPSILON, d1, d2);
+                  printf ("a1->point: (%i,%i)\n", a1->point[0], a1->point[1]);
+                  printf ("a1->next->point: (%i,%i)\n", a1->next->point[0], a1->next->point[1]);
+                  printf ("a2->point: (%i,%i)\n", a2->point[0], a2->point[1]);
+                  printf ("a2->next->point: (%i,%i)\n", a2->next->point[0], a2->next->point[1]);
+                  printf ("Intersection: (%i, %i)\n", i1[0], i1[1]);
+		  return TRUE;
+                }
 
 	      if (vect_dist2 (i1, a2->point) < EPSILON)
 		hit2 = a2;
 	      else if (vect_dist2 (i1, a2->next->point) < EPSILON)
 		hit2 = a2->next;
 	      else
-		return TRUE;
+                {
+                  printf ("Returning true 3\n");
+		  return TRUE;
+                }
 
 #if 1
 	      /* now check if they are inside each other */
@@ -2465,13 +2483,17 @@ poly_ChkContour (PLINE * a)
 		  inside_sector (hit1, hit2->next->point) ||
 		  inside_sector (hit2, hit1->prev->point) ||
 		  inside_sector (hit2, hit1->next->point))
-		return TRUE;
+                {
+                  printf ("Returning true 4\n");
+		  return TRUE;
+                }
 #endif
 	    }
 	}
-      while ((a2 = a2->next) != &a->head);
+      while ((a2 = a2->next) != a2_start);
     }
   while ((a1 = a1->next) != &a->head);
+  printf ("Fell out the bottom, returning false\n");
   return FALSE;
 }
 
@@ -2482,7 +2504,10 @@ poly_Valid (POLYAREA * p)
   PLINE *c;
 
   if ((p == NULL) || (p->contours == NULL))
-    return FALSE;
+    {
+      printf ("Polyarea %p, contours=%p\n", p, p ? p->contours : NULL);
+      return FALSE;
+    }
 
   if (p->contours->Flags.orient == PLF_INV || poly_ChkContour (p->contours))
     {
diff --git a/src/pour.c b/src/pour.c
index edd6be7..45e6a01 100644
--- a/src/pour.c
+++ b/src/pour.c
@@ -216,7 +216,7 @@ CopyAttachedPourToLayer (void)
   if (!CURRENT->pour_tree)
     CURRENT->pour_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (CURRENT->pour_tree, (BoxType *) pour, 0);
-//  InitClip (PCB->Data, CURRENT, pour);
+  InitPourClip (PCB->Data, CURRENT, pour);
 //  DrawPolygon (CURRENT, polygon, 0);
   DrawPour (CURRENT, pour, 0);
   SetChangedFlag (True);
@@ -230,8 +230,631 @@ CopyAttachedPourToLayer (void)
   IncrementUndoSerialNumber ();
 }
 
+/*---------------------------------------- END OF NICE GENTLE UI DRIVEN PIECES OF THE POUR CODE --------------*/
+
+/*---------------------------------------- THIS CODE BELOW WILL MURDER SMALL ANIMALS THEN LAUGH --------------*/
+
+/* ---------------------------------------------------------------------------
+ * destroys a polygon from a pour
+ */
+static void *
+DestroyPolygonInPour (LayerTypePtr layer, PourTypePtr pour, PolygonTypePtr polygon)
+{
+  r_delete_entry (layer->polygon_tree, (BoxTypePtr) polygon);
+
+  FreePolygonMemory (polygon);
+  *polygon = pour->Polygons[ --pour->PolygonN ];
+  r_substitute (layer->polygon_tree,
+                (BoxType *) & pour->Polygons[ pour->PolygonN ],
+                (BoxType *) polygon);
+  memset (&pour->Polygons[ pour->PolygonN ], 0, sizeof (PolygonType));
+  return (NULL);
+}
+
+static int
+subtract_poly (POLYAREA * np1, POLYAREA **pg)
+{
+  POLYAREA *merged = NULL, *np = np1;
+  int x;
+
+  assert (np);
+  assert (pg);
+  assert (*pg);
+
+  if (pg == NULL)
+    {
+      printf ("Hmm, got pg == NULL in subtract_poly\n");
+      poly_Free (&np);
+      return -1;
+    }
+
+  assert (poly_Valid (*pg));
+  assert (poly_Valid (np));
+  x = poly_Boolean_free (*pg, np, &merged, PBO_SUB);
+  if (x != err_ok)
+    {
+      fprintf (stderr, "Error while clipping PBO_SUB: %d\n", x);
+      poly_Free (&merged);
+      return -1;
+    }
+
+  assert (!merged || poly_Valid (merged));
+
+  *pg = merged;
+  return 1;
+}
+
+  static int
+unite_poly (POLYAREA * np, POLYAREA ** pg)
+{
+  POLYAREA *merged = NULL;
+  int x;
+  assert (np);
+  assert (pg);
+  assert (*pg);
+  x = poly_Boolean_free (*pg, np, &merged, PBO_UNITE);
+  if (x != err_ok)
+    {
+      fprintf (stderr, "Error while clipping PBO_UNITE: %d\n", x);
+      poly_Free (&merged);
+      return 0;
+    }
+  assert (!merged || poly_Valid (merged));
+  *pg = merged;
+  return 1;
+}
+
+static int
+intersect_poly (POLYAREA * np, POLYAREA ** pg)
+{
+  POLYAREA *merged;
+  int x;
+  assert (np);
+  assert (pg);
+  assert (*pg);
+  x = poly_Boolean_free (*pg, np, &merged, PBO_ISECT);
+  if (x != err_ok)
+    {
+      fprintf (stderr, "Error while clipping PBO_ISECT: %d\n", x);
+      poly_Free (&merged);
+      return 0;
+    }
+  assert (!merged || poly_Valid (merged));
+  *pg = merged;
+  return 1;
+}
+
+
+/* remove the pin clearance from the polygon */
+static POLYAREA *
+get_subtract_pin_poly (DataType * d, PinType * pin, LayerType * l, PourType *pour)
+{
+  POLYAREA *np;
+  Cardinal i;
+
+  if (pin->Clearance == 0)
+    return NULL;
+
+  i = GetLayerNumber (d, l);
+  if (TEST_THERM (i, pin))
+    {
+      np = ThermPoly ((PCBTypePtr) (d->pcb), pin, i);
+      if (!np)
+        printf ("Got np=NULL from ThermPoly, is this bad?\n");
+    }
+  else
+    {
+      np = PinPoly (pin, pin->Thickness, pin->Clearance);
+      if (!np)
+        printf ("Got np=NULL from PinPoly, is this bad?\n");
+    }
+
+  return np;
+}
+
+static POLYAREA *
+get_subtract_line_poly (LineType *line, PourType *pour)
+{
+  POLYAREA *np;
+
+  if (!TEST_FLAG (CLEARLINEFLAG, line))
+    return NULL;
+
+  np = LinePoly (line, line->Thickness + line->Clearance);
+  if (np == NULL)
+    printf ("Got np=NULL from LinePoly, is this bad?\n");
+
+  return np;
+}
+
+static POLYAREA *
+get_subtract_arc_poly (ArcType * arc, PourType * pour)
+{
+  POLYAREA *np;
+
+  if (!TEST_FLAG (CLEARLINEFLAG, arc))
+    return NULL;
+
+  np = ArcPoly (arc, arc->Thickness + arc->Clearance);
+  if (np == NULL)
+    printf ("Got np=NULL from ArcPoly, is this bad?\n");
+
+  return np;
+}
+
+static POLYAREA *
+get_subtract_text_poly (TextType * text, PourType * pour)
+{
+  POLYAREA *np;
+  const BoxType *b = &text->BoundingBox;
+
+  if (!TEST_FLAG (CLEARLINEFLAG, text))
+    return NULL;
+
+  np = RoundRect (b->X1 + PCB->Bloat, b->X2 - PCB->Bloat,
+                        b->Y1 + PCB->Bloat, b->Y2 - PCB->Bloat, PCB->Bloat);
+  if (np == NULL)
+    printf ("Got np=NULL from RoundRect, is this bad?\n");
+
+  return np;
+}
+
+static POLYAREA *
+get_subtract_pad_poly (PadType * pad, PourType * pour)
+{
+  POLYAREA *np;
+
+  if (TEST_FLAG (SQUAREFLAG, pad))
+    {
+      np = SquarePadPoly (pad, pad->Thickness + pad->Clearance);
+      if (np == NULL)
+        printf ("Got np==NULL from SquarePadPoly, is this bad?\n");
+    }
+  else
+    {
+      np = LinePoly ((LineType *) pad, pad->Thickness + pad->Clearance);
+      if (np == NULL)
+        printf ("Got np=NULL from LinePoly, is this bad?\n");
+    }
+
+  return np;
+}
+
+static POLYAREA *
+get_subtract_polygon_poly (PolygonType * polygon, PourType * pour)
+{
+  POLYAREA *np;
+
+  /* Don't subtract from ourselves! */
+  if (polygon->ParentPour == pour || !TEST_FLAG (CLEARLINEFLAG, polygon))
+    return NULL;
+
+  poly_Copy0 (&np, polygon->Clipped);
+  if (np == NULL)
+    printf ("Got np=NULL from poly_Copy0, is this bad?\n");
+
+  return np;
+}
+
+struct cpInfo
+{
+  const BoxType *other;
+  DataType *data;
+  LayerType *layer;
+  PourType *pour;
+  Boolean solder;
+  POLYAREA *pg;
+  jmp_buf env;
+};
+
+static int
+pin_sub_callback (const BoxType * b, void *cl)
+{
+  PinTypePtr pin = (PinTypePtr) b;
+  struct cpInfo *info = (struct cpInfo *) cl;
+  POLYAREA *np;
+
+  /* don't subtract the object that was put back! */
+  if (b == info->other)
+    return 0;
+
+  np = get_subtract_pin_poly (info->data, pin, info->layer, info->pour);
+  if (np == NULL)
+    {
+      printf ("Got np=NULL from get_subtract_pin_poly, is this bad?\n");
+//      longjmp (info->env, 1);
+      return 0;
+    }
+  if (subtract_poly (np, &info->pg) < 0)
+    longjmp (info->env, 1);
+  return 1;
+}
+
+static int
+arc_sub_callback (const BoxType * b, void *cl)
+{
+  ArcTypePtr arc = (ArcTypePtr) b;
+  struct cpInfo *info = (struct cpInfo *) cl;
+  POLYAREA *np;
+
+  /* don't subtract the object that was put back! */
+  if (b == info->other)
+    return 0;
+  if (!TEST_FLAG (CLEARLINEFLAG, arc))
+    return 0;
+
+  np = get_subtract_arc_poly (arc, info->pour);
+  if (np == NULL)
+    {
+      printf ("Got np=NULL from get_subtract_arc_poly, is this bad?\n");
+      longjmp (info->env, 1);
+    }
+  if (subtract_poly (np, &info->pg) < 0)
+    longjmp (info->env, 1);
+  return 1;
+}
+
+static int
+pad_sub_callback (const BoxType * b, void *cl)
+{
+  PadTypePtr pad = (PadTypePtr) b;
+  struct cpInfo *info = (struct cpInfo *) cl;
+  POLYAREA *np;
+
+  /* don't subtract the object that was put back! */
+  if (b == info->other)
+    return 0;
+  if (XOR (TEST_FLAG (ONSOLDERFLAG, pad), info->solder))
+    return 0;
+
+  np = get_subtract_pad_poly (pad, info->pour);
+  if (np == NULL)
+    {
+      printf ("Got np=NULL from get_subtract_pad_poly, is this bad?\n");
+      longjmp (info->env, 1);
+    }
+  if (subtract_poly (np, &info->pg) < 0)
+    longjmp (info->env, 1);
+  return 1;
+}
+
+static int
+line_sub_callback (const BoxType * b, void *cl)
+{
+  LineTypePtr line = (LineTypePtr) b;
+  struct cpInfo *info = (struct cpInfo *) cl;
+  POLYAREA *np;
+
+  /* don't subtract the object that was put back! */
+  if (b == info->other)
+    return 0;
+  if (!TEST_FLAG (CLEARLINEFLAG, line))
+    return 0;
+
+  np = get_subtract_line_poly (line, info->pour);
+  if (np == NULL)
+    {
+      printf ("Got np=NULL from get_subtract_line_poly, is this bad?\n");
+      longjmp (info->env, 1);
+    }
+  if (subtract_poly (np, &info->pg) < 0)
+    longjmp (info->env, 1);
+  return 1;
+}
+
+
+static int
+text_sub_callback (const BoxType * b, void *cl)
+{
+  TextTypePtr text = (TextTypePtr) b;
+  struct cpInfo *info = (struct cpInfo *) cl;
+  POLYAREA *np;
+
+  /* don't subtract the object that was put back! */
+  if (b == info->other)
+    return 0;
+  if (!TEST_FLAG (CLEARLINEFLAG, text))
+    return 0;
+
+  np = get_subtract_text_poly (text, info->pour);
+  if (np == NULL)
+    {
+      printf ("Got np=NULL from get_subtract_text_poly, is this bad?\n");
+      longjmp (info->env, 1);
+    }
+  if (subtract_poly (np, &info->pg) < 0)
+    longjmp (info->env, 1);
+  return 1;
+}
+
+static int
+poly_sub_callback (const BoxType * b, void *cl)
+{
+  PolygonTypePtr poly = (PolygonTypePtr) b;
+  struct cpInfo *info = (struct cpInfo *) cl;
+  POLYAREA *np;
+
+  /* don't subtract the object that was put back! */
+  if (b == info->other)
+    return 0;
+  if (!TEST_FLAG (CLEARLINEFLAG, poly))
+    return 0;
+
+  np = get_subtract_polygon_poly (poly, info->pour);
+  if (np == NULL)
+    {
+      printf ("Got np=NULL from LinePoly, is this bad?\n");
+      longjmp (info->env, 1);
+    }
+  if (subtract_poly (np, &info->pg) < 0)
+    longjmp (info->env, 1);
+  return 1;
+}
+
+static int
+Group (DataTypePtr Data, Cardinal layer)
+{
+  Cardinal i, j;
+  for (i = 0; i < max_layer; i++)
+    for (j = 0; j < ((PCBType *) (Data->pcb))->LayerGroups.Number[i]; j++)
+      if (layer == ((PCBType *) (Data->pcb))->LayerGroups.Entries[i][j])
+        return i;
+  return i;
+}
+
+/* NB: For convenience, we're passing the defined POLYAREA in here */
+static int
+ClearPour (DataTypePtr Data, LayerTypePtr Layer, PourType * pour,
+           POLYAREA *clipped, const BoxType * here, BDimension expand)
+{
+  POLYAREA *tmp, *pg;
+  int r = 0;
+  BoxType region;
+  struct cpInfo info;
+  Cardinal group;
+
+  if (!TEST_FLAG (CLEARPOLYFLAG, pour)
+      || GetLayerNumber (Data, Layer) >= max_layer)
+    return 0;
+  group = Group (Data, GetLayerNumber (Data, Layer));
+  info.solder = (group == Group (Data, max_layer + SOLDER_LAYER));
+  info.data = Data;
+  info.other = here;
+  info.layer = Layer;
+  info.pour = pour;
+  info.pg = clipped;
+  if (here)
+    region = clip_box (here, &pour->BoundingBox);
+  else
+    region = pour->BoundingBox;
+  region = bloat_box (&region, expand);
+
+  if (setjmp (info.env) == 0)
+    {
+      r  = r_search (Data->via_tree, &region, NULL, pin_sub_callback, &info);
+      r += r_search (Data->pin_tree, &region, NULL, pin_sub_callback, &info);
+      GROUP_LOOP (Data, group);
+      {
+        r += r_search (layer->line_tree,    &region, NULL, line_sub_callback, &info);
+        r += r_search (layer->arc_tree,     &region, NULL, arc_sub_callback,  &info);
+        r += r_search (layer->text_tree,    &region, NULL, text_sub_callback, &info);
+        r += r_search (layer->polygon_tree, &region, NULL, poly_sub_callback, &info);
+      }
+      END_LOOP;
+      if (info.solder || group == Group (Data, max_layer + COMPONENT_LAYER))
+        r += r_search (Data->pad_tree, &region, NULL, pad_sub_callback, &info);
+    }
+
+  /* TODO: Check r to work of it we need to do this? */
+
+  /* For each piece of the clipped up polygon, create a new child */
+  pg = info.pg;
+  do
+    {
+      PolygonType *poly;
+
+      tmp = pg->f;
+      pg->f = pg;
+      pg->b = pg;
+
+      poly = CreateNewPolygonInPour (pour, pour->Flags);
+      poly->Clipped = pg;
+
+      SetPolygonBoundingBox (poly);
+
+      if (Layer->polygon_tree == NULL)
+        Layer->polygon_tree = r_create_tree (NULL, 0, 0);
+      r_insert_entry (Layer->polygon_tree, (BoxType *) poly, 0);
+      printf ("Inserting one polygon into the layer's tree\n");
+    }
+  while ((pg = tmp) != info.pg);
+
+  return r;
+}
+
+static int
+subtract_plow (DataTypePtr Data, LayerTypePtr Layer, PourTypePtr pour,
+              int type, void *ptr1, void *ptr2)
+{
+  POLYAREA *np = NULL, *pg = NULL, *start_pg, *tmp;
+  PolygonType **delete_children;
+  int number_deleted = 0;
+
+  switch (type)
+    {
+    case PIN_TYPE:
+    case VIA_TYPE:
+      np = get_subtract_pin_poly (Data, (PinTypePtr) ptr2, Layer, pour);
+      break;
+    case LINE_TYPE:
+      np = get_subtract_line_poly ((LineTypePtr) ptr2, pour);
+      break;
+    case ARC_TYPE:
+      np = get_subtract_arc_poly ((ArcTypePtr) ptr2, pour);
+      break;
+    case PAD_TYPE:
+      np = get_subtract_pad_poly ((PadTypePtr) ptr2, pour);
+      break;
+    case POLYGON_TYPE:
+      np = get_subtract_polygon_poly ((PolygonTypePtr) ptr2, pour);
+      break;
+    case TEXT_TYPE:
+      np = get_subtract_text_poly ((TextTypePtr) ptr2, pour);
+      break;
+    }
+
+  if (np == NULL)
+    {
+      printf ("Didn't get a POLYAREA to subtract, so bailing\n");
+      return 0;
+    }
+
+  assert (poly_Valid (np));
+
+  /* Make pg contain the polygons we're going to fiddle with */
+
+  delete_children = calloc (pour->PolygonN, sizeof (PolygonType *));
+  POURPOLYGON_LOOP (pour);
+  {
+    /* Gather up children which are touched by np */
+    if (isects (np, polygon, False))
+      {
+        /* Steal their clipped contours, then delete them */
+        /* Add contour to local list to fiddle about with */
+        delete_children[ number_deleted++ ] = polygon;
+        assert (poly_Valid (polygon->Clipped));
+        if (polygon->Clipped == NULL)
+          {
+            printf ("Got polygon->clipped == NULL!\n");
+            continue;
+          }
+        if (pg == NULL)
+          {
+            pg = polygon->Clipped;
+            polygon->Clipped = NULL;
+          }
+        else
+          {
+            /* Link the _single_ polygon->Clipped into our circular pg list. */
+            polygon->Clipped->f = pg;
+            polygon->Clipped->b = pg->b;
+            pg->b->f = polygon->Clipped;
+            pg->b = polygon->Clipped;
+            polygon->Clipped = NULL;
+          }
+      }
+  }
+  END_LOOP;
+  for (; number_deleted ;)
+    DestroyPolygonInPour (Layer, pour, delete_children[ --number_deleted ]);
+  free (delete_children);
+
+  if (pg == NULL)
+    {
+      printf ("Hmm, got pg == NULL in subtract_plow\n");
+      poly_Free (&np);
+      return -1;
+    }
+
+  assert (poly_Valid (pg));
+
+  /* Perform the subtract operation */
+
+  /* NB: Old *pg is freed inside subtract_poly */
+  subtract_poly (np, &pg);
+
+  if (pg == NULL)
+    {
+      printf ("Poly killed to death by subtracting\n");
+      return -1;
+    }
+
+
+  /* For each piece of the clipped up polygon, create a new child */
+  start_pg = pg;
+  do
+    {
+      PolygonType *poly;
+
+      tmp = pg->f;
+      pg->f = pg;
+      pg->b = pg;
+
+      poly = CreateNewPolygonInPour (pour, pour->Flags);
+      poly->Clipped = pg;
+
+      SetPolygonBoundingBox (poly);
+
+      if (Layer->polygon_tree == NULL)
+        Layer->polygon_tree = r_create_tree (NULL, 0, 0);
+      r_insert_entry (Layer->polygon_tree, (BoxType *) poly, 0);
+      printf ("Inserting one polygon into the layer's tree\n");
+    }
+  while ((pg = tmp) != start_pg);
+
+
+
+  /* TODO: Need to put the modified polygons in pg into children */
+  return 0;
+}
+
+static POLYAREA *
+get_unsubtract_pin_poly (PinType * pin, LayerType * l, PourType * pour)
+{
+  /* overlap a bit to prevent gaps from rounding errors */
+  return BoxPolyBloated (&pin->BoundingBox, UNSUBTRACT_BLOAT);
+}
+
+static POLYAREA *
+get_unsubtract_arc_poly (ArcType * arc, LayerType * l, PourType * pour)
+{
+  if (!TEST_FLAG (CLEARLINEFLAG, arc))
+    return NULL;
+
+  /* overlap a bit to prevent gaps from rounding errors */
+  return BoxPolyBloated (&arc->BoundingBox, UNSUBTRACT_BLOAT);
+}
+
 static POLYAREA *
-original_pour (PourType * p)
+get_unsubtract_line_poly (LineType * line, LayerType * l, PourType * pour)
+{
+  if (!TEST_FLAG (CLEARLINEFLAG, line))
+    return NULL;
+
+  /* overlap a bit to prevent notches from rounding errors */
+  return BoxPolyBloated (&line->BoundingBox, UNSUBTRACT_BLOAT);
+}
+
+static POLYAREA *
+get_unsubtract_text_poly (TextType * text, LayerType * l, PourType * pour)
+{
+  if (!TEST_FLAG (CLEARLINEFLAG, text))
+    return NULL;
+
+  /* overlap a bit to prevent notches from rounding errors */
+  return BoxPolyBloated (&text->BoundingBox, UNSUBTRACT_BLOAT);
+}
+
+static POLYAREA *
+get_unsubtract_pad_poly (PadType * pad, LayerType * l, PourType * pour)
+{
+  /* overlap a bit to prevent notches from rounding errors */
+  return BoxPolyBloated (&pad->BoundingBox, UNSUBTRACT_BLOAT);
+}
+
+static POLYAREA *
+get_unsubtract_polygon_poly (PolygonType * poly, LayerType * l, PourType * pour)
+{
+  /* Don't subtract from ourselves, or if CLEARLINEFLAG isn't set */
+  if (poly->ParentPour == pour || !TEST_FLAG (CLEARLINEFLAG, poly))
+    return NULL;
+
+  /* overlap a bit to prevent notches from rounding errors */
+  return BoxPolyBloated (&poly->BoundingBox, UNSUBTRACT_BLOAT);
+}
+
+static POLYAREA *
+original_pour_poly (PourType * p)
 {
   PLINE *contour = NULL;
   POLYAREA *np = NULL;
@@ -270,37 +893,180 @@ original_pour (PourType * p)
     return NULL;
   poly_InclContour (np, contour);
   assert (poly_Valid (np));
-#warning FIXME Later
-//  return biggest (np);
   return np;
 }
 
+static int
+add_plow (DataTypePtr Data, LayerTypePtr Layer, PourTypePtr pour,
+          int type, void *ptr1, void *ptr2)
+{
+  POLYAREA *np = NULL, *pg = NULL; //, *start_pg, *tmp;
+  PolygonType **delete_children;
+  int number_deleted = 0;
+
+  switch (type)
+    {
+    case PIN_TYPE:
+    case VIA_TYPE:
+      np = get_unsubtract_pin_poly ((PinTypePtr) ptr2, Layer, pour);
+      break;
+    case LINE_TYPE:
+      np = get_unsubtract_line_poly ((LineTypePtr) ptr2, Layer, pour);
+      break;
+    case ARC_TYPE:
+      np = get_unsubtract_arc_poly ((ArcTypePtr) ptr2, Layer, pour);
+      break;
+    case PAD_TYPE:
+      np = get_unsubtract_pad_poly ((PadTypePtr) ptr2, Layer, pour);
+      break;
+    case POLYGON_TYPE:
+      np = get_unsubtract_polygon_poly ((PolygonTypePtr) ptr2, Layer, pour);
+      break;
+    case TEXT_TYPE:
+      np = get_unsubtract_text_poly ((TextTypePtr) ptr2, Layer, pour);
+      break;
+    }
+
+  if (np == NULL)
+    {
+      printf ("Didn't get a POLYAREA to add, so bailing\n");
+      return 0;
+    }
+
+  assert (poly_Valid (np));
+
+  /* Make pg contain the polygons we're going to fiddle with */
+
+  delete_children = calloc (pour->PolygonN, sizeof (PolygonType *));
+  POURPOLYGON_LOOP (pour);
+  {
+    /* Gather up children which are touched by np */
+    if (isects (np, polygon, False))
+      {
+        /* Steal their clipped contours, then delete them */
+        /* Add contour to local list to fiddle about with */
+        delete_children[ number_deleted++ ] = polygon;
+        assert (poly_Valid (polygon->Clipped));
+        if (polygon->Clipped == NULL)
+          {
+            printf ("Got polygon->clipped == NULL!\n");
+            continue;
+          }
+        if (pg == NULL)
+          {
+            pg = polygon->Clipped;
+            polygon->Clipped = NULL;
+          }
+        else
+          {
+            /* Link the _single_ polygon->Clipped into our circular pg list. */
+            polygon->Clipped->f = pg;
+            polygon->Clipped->b = pg->b;
+            pg->b->f = polygon->Clipped;
+            pg->b = polygon->Clipped;
+            polygon->Clipped = NULL;
+          }
+      }
+  }
+  END_LOOP;
+  for (; number_deleted ;)
+    DestroyPolygonInPour (Layer, pour, delete_children[ --number_deleted ]);
+  free (delete_children);
+
+  if (pg == NULL)
+    {
+      printf ("Hmm, got pg == NULL in subtract_plow\n");
+      poly_Free (&np);
+      return -1;
+    }
+
+  assert (poly_Valid (pg));
+
+  /* Perform the union operation */
+
+  /* NB: np and old *pg are freed inside union_poly() */
+  unite_poly (np, &pg);
+
+  np = original_pour_poly (pour);
+  /* NB: np and old *pg are freed inside intersect_poly() */
+  intersect_poly (np, &pg);
+
+#warning FIXME Later: ClearPour does the adding of Polygon objects for us
+  ClearPour (PCB->Data, Layer, pour, pg, (const BoxType *) ptr2, 2 * UNSUBTRACT_BLOAT);
+
+#if 0
+  if (pg == NULL)
+    {
+      printf ("Poly killed to death somehow\n");
+      return -1;
+    }
+
+
+  /* For each piece of the clipped up polygon, create a new child */
+  start_pg = pg;
+  do
+    {
+      PolygonType *poly;
+
+      tmp = pg->f;
+      pg->f = pg;
+      pg->b = pg;
+
+      poly = CreateNewPolygonInPour (pour, pour->Flags);
+      poly->Clipped = pg;
+
+      SetPolygonBoundingBox (poly);
+
+      if (Layer->polygon_tree == NULL)
+        Layer->polygon_tree = r_create_tree (NULL, 0, 0);
+      r_insert_entry (Layer->polygon_tree, (BoxType *) poly, 0);
+      printf ("Inserting one polygon into the layer's tree\n");
+    }
+  while ((pg = tmp) != start_pg);
+#endif
+
+  return 0;
+}
+
+/* ---------------------------------------------------------------------------------------------------------- */
+
 int
-InitPourClip (DataTypePtr Data, LayerTypePtr layer, PourType * p)
+InitPourClip (DataTypePtr Data, LayerTypePtr layer, PourType * pour)
 {
-  POLYAREA *clipped, *pg;
+  POLYAREA *clipped;
+  PolygonType **delete_children;
+  int number_deleted = 0;
 
   printf ("InitPourClip\n");
-  /* Free any children? */
-  if (p->PolygonN)
+
+  /* Free any children we might have */
+  if (pour->PolygonN)
     {
       printf ("We already had children. Killing them now.\n");
-      /* TODO: Free existing children, remove them from whatever r_tree etc.. */
+      delete_children = calloc (pour->PolygonN, sizeof (PolygonType *));
+      POURPOLYGON_LOOP (pour);
+      {
+        delete_children[ number_deleted++ ] = polygon;
+      }
+      END_LOOP;
+      for (; number_deleted ;)
+        DestroyPolygonInPour (layer, pour, delete_children[ --number_deleted ]);
     }
 
-  clipped = original_pour (p);
+  clipped = original_pour_poly (pour);
   if (!clipped)
     {
       printf ("Clipping returned NULL - can that be good?\n");
       return 0;
     }
   assert (poly_Valid (clipped));
-  if (TEST_FLAG (CLEARPOLYFLAG, p))
+  if (TEST_FLAG (CLEARPOLYFLAG, pour))
     {
       /* Clip the pour against anything we can find in this layer */
       /* TODO: Clear up API so the resulting areas are in "clipped" */
-      // e.g.: clearPour (Data, layer, p, NULL, 0);
+      ClearPour (Data, layer, pour, clipped, NULL, 0);
     }
+#if 0
   pg = clipped;
   do
     {
@@ -309,18 +1075,144 @@ InitPourClip (DataTypePtr Data, LayerTypePtr layer, PourType * p)
   while ((pg = pg->f) != clipped);
 
   poly_Free (&clipped);
+#endif
   return 1;
 }
 
+struct plow_info
+{
+  int type;
+  void *ptr1, *ptr2;
+  LayerTypePtr layer;
+  DataTypePtr data;
+  int (*callback) (DataTypePtr, LayerTypePtr,
+                   PourTypePtr, int, void *, void *);
+};
+
+static int
+plow_callback (const BoxType * b, void *cl)
+{
+  struct plow_info *plow = (struct plow_info *) cl;
+  PourTypePtr pour = (PourTypePtr) b;
+
+  if (TEST_FLAG (CLEARPOLYFLAG, pour))
+    return plow->callback (plow->data, plow->layer, pour,
+                           plow->type, plow->ptr1, plow->ptr2);
+  return 0;
+}
+
+int
+PlowPours (DataType * Data, int type, void *ptr1, void *ptr2,
+           int (*call_back) (DataTypePtr data, LayerTypePtr lay,
+                             PourTypePtr poly, int type,
+                             void *ptr1, void *ptr2))
+{
+  BoxType sb = ((PinTypePtr) ptr2)->BoundingBox;
+  int r = 0;
+  struct plow_info info;
+
+  printf ("Hello world, this is PlowPours\n");
+
+  info.type = type;
+  info.ptr1 = ptr1;
+  info.ptr2 = ptr2;
+  info.data = Data;
+  info.callback = call_back;
+  switch (type)
+    {
+    case PIN_TYPE:
+    case VIA_TYPE:
+      if (type == PIN_TYPE || ptr1 == ptr2 || ptr1 == NULL)
+        {
+          LAYER_LOOP (Data, max_layer);
+          {
+            info.layer = layer;
+            r += r_search (layer->pour_tree, &sb, NULL, plow_callback, &info);
+          }
+          END_LOOP;
+        }
+      else
+        {
+          int layer_no = GetLayerNumber (Data, ((LayerTypePtr) ptr1));
+          int group_no = GetLayerGroupNumberByNumber (layer_no);
+          GROUP_LOOP (Data, group_no);
+          {
+            info.layer = layer;
+            r += r_search (layer->pour_tree, &sb, NULL, plow_callback, &info);
+          }
+          END_LOOP;
+        }
+      break;
+    case LINE_TYPE:
+    case ARC_TYPE:
+    case TEXT_TYPE:
+    case POLYGON_TYPE:
+      /* the cast works equally well for lines and arcs */
+      if (!TEST_FLAG (CLEARLINEFLAG, (LineTypePtr) ptr2))
+        return 0;
+      /* silk doesn't plow */
+      if (GetLayerNumber (Data, ptr1) >= max_layer)
+        return 0;
+      GROUP_LOOP (Data, GetLayerGroupNumberByNumber (GetLayerNumber (Data,
+                                                                     ((LayerTypePtr) ptr1))));
+      {
+        info.layer = layer;
+        r += r_search (layer->pour_tree, &sb, NULL, plow_callback, &info);
+      }
+      END_LOOP;
+      break;
+    case PAD_TYPE:
+      {
+        Cardinal group = TEST_FLAG (ONSOLDERFLAG,
+                                    (PadType *) ptr2) ? SOLDER_LAYER :
+          COMPONENT_LAYER;
+        group = GetLayerGroupNumberByNumber (max_layer + group);
+        GROUP_LOOP (Data, group);
+        {
+          info.layer = layer;
+          r += r_search (layer->pour_tree, &sb, NULL, plow_callback, &info);
+        }
+        END_LOOP;
+      }
+      break;
+
+    case ELEMENT_TYPE:
+      {
+        PIN_LOOP ((ElementType *) ptr1);
+        {
+          PlowPours (Data, PIN_TYPE, ptr1, pin, call_back);
+        }
+        END_LOOP;
+        PAD_LOOP ((ElementType *) ptr1);
+        {
+          PlowPours (Data, PAD_TYPE, ptr1, pad, call_back);
+        }
+        END_LOOP;
+      }
+      break;
+    }
+  return r;
+}
+
 void
-RestoreToPour (DataType * Data, int type, void *ptr1, void *ptr2)
+RestoreToPours (DataType * Data, int type, void *ptr1, void *ptr2)
 {
-  printf ("FIXME Later\n");
+  if (type == POUR_TYPE)
+    {
+      printf ("Calling InitPourClip from RestoreToPour\n");
+      InitPourClip (PCB->Data, (LayerTypePtr) ptr1, (PourTypePtr) ptr2);
+    }
+  PlowPours (Data, type, ptr1, ptr2, add_plow);
 }
 
 void
-ClearFromPour (DataType * Data, int type, void *ptr1, void *ptr2)
+ClearFromPours (DataType * Data, int type, void *ptr1, void *ptr2)
 {
-  printf ("FIXME Later\n");
+  if (type == POUR_TYPE)
+    {
+      printf ("Calling InitPourClip from ClearFromPour\n");
+      InitPourClip (PCB->Data, (LayerTypePtr) ptr1, (PourTypePtr) ptr2);
+    }
+  PlowPours (Data, type, ptr1, ptr2, subtract_plow);
 }
 
diff --git a/src/pour.h b/src/pour.h
index 2232df4..f04e342 100644
--- a/src/pour.h
+++ b/src/pour.h
@@ -41,7 +41,7 @@ void ClosePour (void);
 void CopyAttachedPourToLayer (void);
 
 int InitPourClip(DataType *d, LayerType *l, PourType *p);
-void RestoreToPour(DataType *, int, void *, void *);
-void ClearFromPour(DataType *, int, void *, void *);
+void RestoreToPours(DataType *, int, void *, void *);
+void ClearFromPours(DataType *, int, void *, void *);
 
 #endif /* __POUR_INCLUDED__ */
diff --git a/src/rats.c b/src/rats.c
index f381c1c..e1f67e6 100644
--- a/src/rats.c
+++ b/src/rats.c
@@ -505,20 +505,24 @@ GatherSubnets (NetListTypePtr Netl, Boolean NoWarn, Boolean AndRats)
       }
       ENDALL_LOOP;
       /* add polygons so the auto-router can see them as targets */
-      ALLPOLYGON_LOOP (PCB->Data);
+      ALLPOUR_LOOP (PCB->Data);
       {
-	if (TEST_FLAG (DRCFLAG, polygon))
-	  {
-	    conn = GetConnectionMemory (a);
-	    /* make point on a vertex */
-	    conn->X = polygon->Clipped->contours->head.point[0];
-	    conn->Y = polygon->Clipped->contours->head.point[1];
-	    conn->type = POLYGON_TYPE;
-	    conn->ptr1 = layer;
-	    conn->ptr2 = polygon;
-	    conn->group = GetLayerGroupNumberByPointer (layer);
-	    conn->menu = NULL;	/* agnostic view of where it belongs */
-	  }
+        POURPOLYGON_LOOP (pour);
+        {
+          if (TEST_FLAG (DRCFLAG, polygon))
+            {
+              conn = GetConnectionMemory (a);
+              /* make point on a vertex */
+              conn->X = polygon->Clipped->contours->head.point[0];
+              conn->Y = polygon->Clipped->contours->head.point[1];
+              conn->type = POLYGON_TYPE;
+              conn->ptr1 = layer;
+              conn->ptr2 = polygon;
+              conn->group = GetLayerGroupNumberByPointer (layer);
+              conn->menu = NULL;	/* agnostic view of where it belongs */
+            }
+        }
+        END_LOOP;
       }
       ENDALL_LOOP;
       VIA_LOOP (PCB->Data);
diff --git a/src/remove.c b/src/remove.c
index 1164fa3..24b23a8 100644
--- a/src/remove.c
+++ b/src/remove.c
@@ -70,12 +70,12 @@ static void *DestroyRat (RatTypePtr);
 static void *DestroyLine (LayerTypePtr, LineTypePtr);
 static void *DestroyArc (LayerTypePtr, ArcTypePtr);
 static void *DestroyText (LayerTypePtr, TextTypePtr);
-static void *DestroyPolygon (LayerTypePtr, PolygonTypePtr);
+//static void *DestroyPolygon (LayerTypePtr, PolygonTypePtr);
 static void *DestroyPour (LayerTypePtr, PourTypePtr);
 static void *DestroyElement (ElementTypePtr);
 static void *RemoveVia (PinTypePtr);
 static void *RemoveRat (RatTypePtr);
-static void *DestroyPolygonPoint (LayerTypePtr, PolygonTypePtr, PointTypePtr);
+//static void *DestroyPolygonPoint (LayerTypePtr, PolygonTypePtr, PointTypePtr);
 static void *DestroyPourPoint (LayerTypePtr, PourTypePtr, PointTypePtr);
 static void *RemovePourPoint (LayerTypePtr, PourTypePtr, PointTypePtr);
 static void *RemoveLinePoint (LayerTypePtr, LineTypePtr, PointTypePtr);
@@ -102,7 +102,7 @@ static ObjectFunctionType RemoveFunctions = {
 static ObjectFunctionType DestroyFunctions = {
   DestroyLine,
   DestroyText,
-  DestroyPolygon,
+  NULL, //DestroyPolygon,
   DestroyPour,
   DestroyVia,
   DestroyElement,
@@ -110,7 +110,7 @@ static ObjectFunctionType DestroyFunctions = {
   NULL,
   NULL,
   NULL,
-  DestroyPolygonPoint,
+  NULL, //DestroyPolygonPoint,
   DestroyPourPoint,
   DestroyArc,
   DestroyRat
@@ -176,22 +176,6 @@ DestroyArc (LayerTypePtr Layer, ArcTypePtr Arc)
 }
 
 /* ---------------------------------------------------------------------------
- * destroys a polygon from a layer
- */
-static void *
-DestroyPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
-{
-  r_delete_entry (Layer->polygon_tree, (BoxTypePtr) Polygon);
-  FreePolygonMemory (Polygon);
-  *Polygon = Layer->Polygon[--Layer->PolygonN];
-  r_substitute (Layer->polygon_tree,
-                (BoxType *) & Layer->Polygon[Layer->PolygonN],
-                (BoxType *) Polygon);
-  memset (&Layer->Polygon[Layer->PolygonN], 0, sizeof (PolygonType));
-  return (NULL);
-}
-
-/* ---------------------------------------------------------------------------
  * destroys a pour from a layer
  */
 static void *
@@ -208,6 +192,8 @@ DestroyPour (LayerTypePtr Layer, PourTypePtr Pour)
   return (NULL);
 }
 
+#warning FIXME Later
+#if 0
 /* ---------------------------------------------------------------------------
  * removes a polygon-point from a polygon and destroys the data
  */
@@ -215,8 +201,6 @@ static void *
 DestroyPolygonPoint (LayerTypePtr Layer,
                      PolygonTypePtr Polygon, PointTypePtr Point)
 {
-#warning FIXME Later
-#if 0
   PointTypePtr ptr;
 
   if (Polygon->PointN <= 3)
@@ -231,9 +215,9 @@ DestroyPolygonPoint (LayerTypePtr Layer,
   SetPolygonBoundingBox (Polygon);
   r_insert_entry (Layer->polygon_tree, (BoxType *) Polygon, 0);
   InitClip (PCB->Data, Layer, Polygon);
-#endif
   return (Polygon);
 }
+#endif
 
 /* ---------------------------------------------------------------------------
  * removes a polygon-point from a polygon and destroys the data
diff --git a/src/rotate.c b/src/rotate.c
index 27f5a84..5049afa 100644
--- a/src/rotate.c
+++ b/src/rotate.c
@@ -200,11 +200,11 @@ static void *
 RotateText (LayerTypePtr Layer, TextTypePtr Text)
 {
   EraseText (Layer, Text);
-  RestoreToPour (PCB->Data, TEXT_TYPE, Layer, Text);
+  RestoreToPours (PCB->Data, TEXT_TYPE, Layer, Text);
   r_delete_entry (Layer->text_tree, (BoxTypePtr) Text);
   RotateTextLowLevel (Text, CenterX, CenterY, Number);
   r_insert_entry (Layer->text_tree, (BoxTypePtr) Text, 0);
-  ClearFromPour (PCB->Data, TEXT_TYPE, Layer, Text);
+  ClearFromPours (PCB->Data, TEXT_TYPE, Layer, Text);
   DrawText (Layer, Text, 0);
   Draw ();
   return (Text);
@@ -262,7 +262,7 @@ RotateElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
     /* pre-delete the pins from the pin-tree before their coordinates change */
     if (Data)
       r_delete_entry (Data->pin_tree, (BoxType *) pin);
-    RestoreToPour (Data, PIN_TYPE, Element, pin);
+    RestoreToPours (Data, PIN_TYPE, Element, pin);
     ROTATE_PIN_LOWLEVEL (pin, X, Y, Number);
   }
   END_LOOP;
@@ -271,7 +271,7 @@ RotateElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
     /* pre-delete the pads before their coordinates change */
     if (Data)
       r_delete_entry (Data->pad_tree, (BoxType *) pad);
-    RestoreToPour (Data, PAD_TYPE, Element, pad);
+    RestoreToPours (Data, PAD_TYPE, Element, pad);
     ROTATE_PAD_LOWLEVEL (pad, X, Y, Number);
   }
   END_LOOP;
@@ -283,7 +283,7 @@ RotateElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
   ROTATE (Element->MarkX, Element->MarkY, X, Y, Number);
   /* SetElementBoundingBox reenters the rtree data */
   SetElementBoundingBox (Data, Element, &PCB->Font);
-  ClearFromPour (Data, ELEMENT_TYPE, Element, Element);
+  ClearFromPours (Data, ELEMENT_TYPE, Element, Element);
 }
 
 /* ---------------------------------------------------------------------------
@@ -295,7 +295,7 @@ RotateLinePoint (LayerTypePtr Layer, LineTypePtr Line, PointTypePtr Point)
   EraseLine (Line);
   if (Layer)
     {
-      RestoreToPour (PCB->Data, LINE_TYPE, Layer, Line);
+      RestoreToPours (PCB->Data, LINE_TYPE, Layer, Line);
       r_delete_entry (Layer->line_tree, (BoxTypePtr) Line);
     }
   else
@@ -305,7 +305,7 @@ RotateLinePoint (LayerTypePtr Layer, LineTypePtr Line, PointTypePtr Point)
   if (Layer)
     {
       r_insert_entry (Layer->line_tree, (BoxTypePtr) Line, 0);
-      ClearFromPour (PCB->Data, LINE_TYPE, Layer, Line);
+      ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
       DrawLine (Layer, Line, 0);
     }
   else
@@ -409,7 +409,7 @@ RotateObject (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
       EraseLine (ptr->Line);
       if (ptr->Layer)
 	{
-	  RestoreToPour (PCB->Data, LINE_TYPE, ptr->Layer, ptr->Line);
+	  RestoreToPours (PCB->Data, LINE_TYPE, ptr->Layer, ptr->Line);
 	  r_delete_entry (ptr->Layer->line_tree, (BoxType *) ptr->Line);
 	}
       else
@@ -419,7 +419,7 @@ RotateObject (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
       if (ptr->Layer)
 	{
 	  r_insert_entry (ptr->Layer->line_tree, (BoxType *) ptr->Line, 0);
-	  ClearFromPour (PCB->Data, LINE_TYPE, ptr->Layer, ptr->Line);
+	  ClearFromPours (PCB->Data, LINE_TYPE, ptr->Layer, ptr->Line);
 	  DrawLine (ptr->Layer, ptr->Line, 0);
 	}
       else
diff --git a/src/rtree.c b/src/rtree.c
index fec72bc..c2220a3 100644
--- a/src/rtree.c
+++ b/src/rtree.c
@@ -520,7 +520,7 @@ __r_search (struct rtree_node *node, const BoxType * query, r_arg * arg)
   /** assert that starting_region is well formed */
   assert (query->X1 <= query->X2 && query->Y1 <= query->Y2);
   assert (node->box.X1 < query->X2 && node->box.X2 > query->X1 &&
-          node->box.Y1 < query->Y2 && node->box.Y2 > query->X1);
+          node->box.Y1 < query->Y2 && node->box.Y2 > query->Y1);
 #ifdef SLOW_ASSERTS
   /** assert that node is well formed */
   assert (__r_node_is_good (node));
diff --git a/src/search.h b/src/search.h
index 3164605..a073f6c 100644
--- a/src/search.h
+++ b/src/search.h
@@ -59,8 +59,13 @@
 #define	TEXT_IN_BOX(t,b)	\
 	(BOX_IN_BOX(&((t)->BoundingBox), (b)))
 
+#if 0 // NOT USED
 #define	POLYGON_IN_BOX(p,b)	\
 	(BOX_IN_BOX(&((p)->BoundingBox), (b)))
+#endif
+
+#define	POUR_IN_BOX(p,b)	\
+	(BOX_IN_BOX(&((p)->BoundingBox), (b)))
 
 #define	ELEMENT_IN_BOX(e,b)	\
 	(BOX_IN_BOX(&((e)->BoundingBox), (b)))
diff --git a/src/select.c b/src/select.c
index 51cc458..49d7535 100644
--- a/src/select.c
+++ b/src/select.c
@@ -340,8 +340,20 @@ SelectBlock (BoxTypePtr Box, Boolean Flag)
 	}
     }
     END_LOOP;
-    POLYGON_LOOP (layer);
+    POUR_LOOP (layer);
     {
+#warning FIXME Later: Do we want to be able to select the polygon pieces?
+      if (POUR_IN_BOX (pour, Box)
+	  && !TEST_FLAG (LOCKFLAG, pour)
+	  && TEST_FLAG (SELECTEDFLAG, pour) != Flag)
+	{
+	  AddObjectToFlagUndoList (POUR_TYPE, layer, pour, pour);
+	  ASSIGN_FLAG (SELECTEDFLAG, Flag, pour);
+	  if (layer->On)
+	    DrawPour (layer, pour, 0);
+	  changed = True;
+	}
+#if 0
       if (POLYGON_IN_BOX (polygon, Box)
 	  && !TEST_FLAG (LOCKFLAG, polygon)
 	  && TEST_FLAG (SELECTEDFLAG, polygon) != Flag)
@@ -352,6 +364,7 @@ SelectBlock (BoxTypePtr Box, Boolean Flag)
 	    DrawPolygon (layer, polygon, 0);
 	  changed = True;
 	}
+#endif
     }
     END_LOOP;
   }
@@ -626,19 +639,40 @@ SelectedOperation (ObjectFunctionTypePtr F, Boolean Reset, int type)
 
   /* check polygons */
   if (type & POLYGON_TYPE && F->Polygon)
-    VISIBLEPOLYGON_LOOP (PCB->Data);
-  {
-    if (TEST_FLAG (SELECTEDFLAG, polygon))
+    VISIBLEPOUR_LOOP (PCB->Data);
+    {
+      POURPOLYGON_LOOP (pour);
       {
-	if (Reset)
-	  {
-	    AddObjectToFlagUndoList (POLYGON_TYPE, layer, polygon, polygon);
-	    CLEAR_FLAG (SELECTEDFLAG, polygon);
-	  }
-	F->Polygon (layer, polygon);
-	changed = True;
+        if (TEST_FLAG (SELECTEDFLAG, polygon))
+          {
+            if (Reset)
+              {
+                AddObjectToFlagUndoList (POLYGON_TYPE, layer, polygon, polygon);
+                CLEAR_FLAG (SELECTEDFLAG, polygon);
+              }
+            F->Polygon (layer, polygon);
+            changed = True;
+          }
       }
-  }
+      END_LOOP;
+    }
+  ENDALL_LOOP;
+
+  /* check pours */
+  if (type & POUR_TYPE && F->Pour)
+    VISIBLEPOUR_LOOP (PCB->Data);
+    {
+      if (TEST_FLAG (SELECTEDFLAG, pour))
+        {
+          if (Reset)
+            {
+              AddObjectToFlagUndoList (POUR_TYPE, layer, pour, pour);
+              CLEAR_FLAG (SELECTEDFLAG, pour);
+            }
+          F->Pour (layer, pour);
+          changed = True;
+        }
+    }
   ENDALL_LOOP;
 
   /* elements silkscreen */
@@ -800,15 +834,19 @@ SelectConnection (Boolean Flag)
       }
   }
   ENDALL_LOOP;
-  VISIBLEPOLYGON_LOOP (PCB->Data);
+  VISIBLEPOUR_LOOP (PCB->Data);
   {
-    if (TEST_FLAG (FOUNDFLAG, polygon) && !TEST_FLAG (LOCKFLAG, polygon))
-      {
-	AddObjectToFlagUndoList (POLYGON_TYPE, layer, polygon, polygon);
-	ASSIGN_FLAG (SELECTEDFLAG, Flag, polygon);
-	DrawPolygon (layer, polygon, 0);
-	changed = True;
-      }
+    POURPOLYGON_LOOP (pour);
+    {
+      if (TEST_FLAG (FOUNDFLAG, polygon) && !TEST_FLAG (LOCKFLAG, polygon))
+        {
+          AddObjectToFlagUndoList (POLYGON_TYPE, layer, polygon, polygon);
+          ASSIGN_FLAG (SELECTEDFLAG, Flag, polygon);
+          DrawPolygon (layer, polygon, 0);
+          changed = True;
+        }
+    }
+    END_LOOP;
   }
   ENDALL_LOOP;
 
diff --git a/src/select.h b/src/select.h
index 7a48dae..373510e 100644
--- a/src/select.h
+++ b/src/select.h
@@ -33,8 +33,9 @@
 
 #include "global.h"
 
+#warning FIXME Later: Do we want pours / polygons selectable?
 #define SELECT_TYPES	\
-	(VIA_TYPE | LINE_TYPE | TEXT_TYPE | POLYGON_TYPE | ELEMENT_TYPE |	\
+	(VIA_TYPE | LINE_TYPE | TEXT_TYPE | POLYGON_TYPE | POUR_TYPE | ELEMENT_TYPE |	\
 	 PIN_TYPE | PAD_TYPE | ELEMENTNAME_TYPE | RATLINE_TYPE | ARC_TYPE)
 
 void SelectPin (LibraryEntryTypePtr entry, Boolean toggle);
diff --git a/src/undo.c b/src/undo.c
index 983eaf2..1d28386 100644
--- a/src/undo.c
+++ b/src/undo.c
@@ -321,9 +321,9 @@ UndoClearPoly (UndoListTypePtr Entry)
   if (type != NO_TYPE)
     {
       if (Entry->Data.ClearPoly.Clear)
-	RestoreToPour (PCB->Data, type, Entry->Data.ClearPoly.Layer, ptr3);
+	RestoreToPours (PCB->Data, type, Entry->Data.ClearPoly.Layer, ptr3);
       else
-	ClearFromPour (PCB->Data, type, Entry->Data.ClearPoly.Layer, ptr3);
+	ClearFromPours (PCB->Data, type, Entry->Data.ClearPoly.Layer, ptr3);
       Entry->Data.ClearPoly.Clear = !Entry->Data.ClearPoly.Clear;
       return True;
     }
@@ -437,11 +437,11 @@ UndoChangeClearSize (UndoListTypePtr Entry)
       if (TEST_FLAG (LOCKFLAG, (LineTypePtr) ptr2))
 	return (False);
       swap = ((PinTypePtr) ptr2)->Clearance;
-      RestoreToPour (PCB->Data, type, ptr1, ptr2);
+      RestoreToPours (PCB->Data, type, ptr1, ptr2);
       if (andDraw)
 	EraseObject (type, ptr1, ptr2);
       ((PinTypePtr) ptr2)->Clearance = Entry->Data.Size;
-      ClearFromPour (PCB->Data, type, ptr1, ptr2);
+      ClearFromPours (PCB->Data, type, ptr1, ptr2);
       Entry->Data.Size = swap;
       if (andDraw)
 	DrawObject (type, ptr1, ptr2, 0);
@@ -505,12 +505,12 @@ UndoChangeSize (UndoListTypePtr Entry)
       /* Wow! can any object be treated as a pin type for size change?? */
       /* pins, vias, lines, and arcs can. Text can't but it has it's own mechanism */
       swap = ((PinTypePtr) ptr2)->Thickness;
-      RestoreToPour (PCB->Data, type, ptr1, ptr2);
+      RestoreToPours (PCB->Data, type, ptr1, ptr2);
       if (andDraw)
 	EraseObject (type, ptr1, ptr2);
       ((PinTypePtr) ptr2)->Thickness = Entry->Data.Size;
       Entry->Data.Size = swap;
-      ClearFromPour (PCB->Data, type, ptr1, ptr2);
+      ClearFromPours (PCB->Data, type, ptr1, ptr2);
       if (andDraw)
 	DrawObject (type, ptr1, ptr2, 0);
       return (True);
@@ -711,35 +711,35 @@ static Boolean
 UndoRemovePoint (UndoListTypePtr Entry)
 {
   LayerTypePtr layer;
-  PolygonTypePtr polygon;
+  PourTypePtr pour;
   void *ptr3;
   int type;
 
   /* lookup entry (polygon not point was saved) by it's ID */
-  assert (Entry->Kind == POLYGON_TYPE);
+  assert (Entry->Kind == POUR_TYPE);
   type =
-    SearchObjectByID (PCB->Data, (void *) &layer, (void *) &polygon, &ptr3,
+    SearchObjectByID (PCB->Data, (void *) &layer, (void *) &pour, &ptr3,
 		      Entry->ID, Entry->Kind);
   switch (type)
     {
-    case POLYGON_TYPE:		/* restore the removed point */
+    case POUR_TYPE:		/* restore the removed point */
       {
-	if (TEST_FLAG (LOCKFLAG, polygon))
+	if (TEST_FLAG (LOCKFLAG, pour))
 	  return (False);
 	/* recover the point */
 	if (andDraw && layer->On)
-	  ErasePolygon (polygon);
-	InsertPointIntoObject (POLYGON_TYPE, layer, polygon,
+	  ErasePour (pour);
+	InsertPointIntoObject (POUR_TYPE, layer, pour,
 			       &Entry->Data.RemovedPoint.Index,
 			       Entry->Data.RemovedPoint.X,
 			       Entry->Data.RemovedPoint.Y, True);
-	polygon->Points[Entry->Data.RemovedPoint.Index].ID =
+	pour->Points[Entry->Data.RemovedPoint.Index].ID =
 	  Entry->Data.RemovedPoint.ID;
 	if (andDraw && layer->On)
-	  DrawPolygon (layer, polygon, 0);
+	  DrawPour (layer, pour, 0);
 	Entry->Type = UNDO_INSERT_POINT;
 	Entry->ID = Entry->Data.RemovedPoint.ID;
-	Entry->Kind = POLYGONPOINT_TYPE;
+	Entry->Kind = POURPOINT_TYPE;
 	return (True);
       }
 
@@ -1233,23 +1233,23 @@ AddObjectToRemovePointUndoList (int Type,
 				void *Ptr1, void *Ptr2, Cardinal index)
 {
   UndoListTypePtr undo;
-  PolygonTypePtr polygon = (PolygonTypePtr) Ptr2;
+  PourTypePtr pour = (PourTypePtr) Ptr2;
 
   if (!Locked)
     {
       switch (Type)
 	{
-	case POLYGONPOINT_TYPE:
+	case POURPOINT_TYPE:
 	  {
 	    /* save the ID of the parent object; else it will be
 	     * impossible to recover the point
 	     */
 	    undo =
-	      GetUndoSlot (UNDO_REMOVE_POINT, OBJECT_ID (polygon),
-			   POLYGON_TYPE);
-	    undo->Data.RemovedPoint.X = polygon->Points[index].X;
-	    undo->Data.RemovedPoint.Y = polygon->Points[index].Y;
-	    undo->Data.RemovedPoint.ID = polygon->Points[index].ID;
+	      GetUndoSlot (UNDO_REMOVE_POINT, OBJECT_ID (pour),
+			   POUR_TYPE);
+	    undo->Data.RemovedPoint.X = pour->Points[index].X;
+	    undo->Data.RemovedPoint.Y = pour->Points[index].Y;
+	    undo->Data.RemovedPoint.ID = pour->Points[index].ID;
 	    undo->Data.RemovedPoint.Index = index;
 	  }
 	  break;
@@ -1328,7 +1328,7 @@ AddObjectToCreateUndoList (int Type, void *Ptr1, void *Ptr2, void *Ptr3)
 
   if (!Locked)
     undo = GetUndoSlot (UNDO_CREATE, OBJECT_ID (Ptr3), Type);
-  ClearFromPour (PCB->Data, Type, Ptr1, Ptr2);
+  ClearFromPours (PCB->Data, Type, Ptr1, Ptr2);
 }
 
 /* ---------------------------------------------------------------------------

Bottom: eaf20b7cfdc6eb74ff5b96d635cbb7b23616ca39
Top:    3c225ba09afc7892212755fe59eaa3c81def128d
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2008-10-15 16:28:22 +0100

Refresh of try-something-with-the-rtrees

---

diff --git a/src/polygon.c b/src/polygon.c
index 28adb08..e36d7be 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -83,10 +83,12 @@ add_noholes_polyarea (PolygonType *noholes_poly, void *user_data)
   POLYAREA *new_area;
 
   new_area = malloc (sizeof (POLYAREA) * 1);
+  new_area->contour_tree = r_create_tree (NULL, 0, 0);
 
   /* Allocate a new PLINE, COPY the PLINE from the passed polygon */
   poly_CopyContour (&pline, noholes_poly->Clipped->contours);
   new_area->contours = pline;
+  r_insert_entry (new_area->contour_tree, (BoxType *)pline, 0);
 
   /* Link the new POLYAREA into the NoHoles circularaly linked list */
   if (poly->NoHoles)
@@ -955,6 +957,11 @@ r_NoHolesPolygonDicer (POLYAREA * pa, void (*emit) (PolygonTypePtr, void *), voi
       POLYAREA *poly2, *left, *right;
 
       /* make a rectangle of the left region slicing through the middle of the first hole */
+      if (p->next->xmin == p->next->xmax)
+        printf ("Problem..\n");
+      if (p->next->xmin > p->next->xmax)
+        printf ("Problem2\n");
+      printf ("p->xmin=%i, p->next->xmin=%i p->next->max=%i\n", p->xmin, p->next->xmin, p->next->xmax);
       poly2 =
         RectPoly (p->xmin, (p->next->xmin + p->next->xmax) / 2, p->ymin,
                   p->ymax);
@@ -965,7 +972,7 @@ r_NoHolesPolygonDicer (POLYAREA * pa, void (*emit) (PolygonTypePtr, void *), voi
           cur = left;
           do
             {
-              next = left->f;
+              next = cur->f;
 //              PLINE *pl = x->contours;
               r_NoHolesPolygonDicer (cur, emit, user_data);
 //              y = x->f;
diff --git a/src/polygon1.c b/src/polygon1.c
index a7977a5..30d6e12 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -38,7 +38,7 @@
       all cases where original (Klamer Schutte) code is present
       are marked
 */
-
+#define NDEBUG
 #include	<assert.h>
 #include	<stdlib.h>
 #include	<stdio.h>
@@ -810,18 +810,12 @@ intersect (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
 {
   POLYAREA *t;
   PLINE *pa, *pb;
-  int ca = 0, cb = 0;
   contour_info c_info;
 
-  /* count the contours in a and b */
-#warning Can we steal this info from the r-tree structure, rather than iterating?
-  for (pa = a->contours; pa; pa = pa->next, ca++);
-  for (pb = b->contours; pb; pb = pb->next, cb++);
-
   /* Search the r-tree of the object with most contours
    * We loop over the contours of "a". Swap if necessary.
    */
-  if (ca > cb)
+  if (((rtree_t *)a->contour_tree)->size > ((rtree_t *)b->contour_tree)->size)
     {
       t = b;
       b = a;
@@ -869,8 +863,10 @@ M_POLYAREA_intersect2 (jmp_buf * e, POLYAREA * afst, POLYAREA * bfst, int add)
   PLINE *curcA, *curcB;
   CVCList *the_list = NULL;
 
-  if (a == NULL || b == NULL)
+  if (a == NULL || b == NULL) {
+    printf ("a or b is null in M_POLYAREA_intersect2\n");
     error (err_bad_parm);
+  }
   do
     {
       do
@@ -914,8 +910,10 @@ M_POLYAREA_intersect (jmp_buf * e, POLYAREA * afst, POLYAREA * bfst, int add)
   PLINE *curcA, *curcB;
   CVCList *the_list = NULL;
 
-  if (a == NULL || b == NULL)
+  if (a == NULL || b == NULL) {
+    printf ("a or b is null in M_POLYAREA_intersect\n");
     error (err_bad_parm);
+  }
   do
     {
       do
@@ -1206,8 +1204,10 @@ InsertHoles (jmp_buf * e, POLYAREA * dest, PLINE ** src)
 
   if (*src == NULL)
     return;			/* empty hole list */
-  if (dest == NULL)
+  if (dest == NULL) {
+    printf ("dest is null un InsertHoles\n");
     error (err_bad_parm);	/* empty contour list */
+  }
 
 #warning IF Passed a PourType, we would get this r-tree for free??
   /* make an rtree of contours */
@@ -1235,6 +1235,7 @@ InsertHoles (jmp_buf * e, POLYAREA * dest, PLINE ** src)
 #endif
 #endif
 	  poly_DelContour (&curh);
+    printf ("Badparm hi there\n");
 	  error (err_bad_parm);
 	}
       /* Now search the heap for the container. If there was only one item
@@ -1273,6 +1274,7 @@ InsertHoles (jmp_buf * e, POLYAREA * dest, PLINE ** src)
 #endif
 	  curh->next = NULL;
 	  poly_DelContour (&curh);
+    printf ("Howdy\n");
 	  error (err_bad_parm);
 	}
       else
@@ -1547,7 +1549,7 @@ Collect (jmp_buf * e, PLINE * a, POLYAREA ** contours, PLINE ** holes,
 	 S_Rule s_rule, J_Rule j_rule)
 {
   VNODE *cur, *other;
-  DIRECTION dir;
+  DIRECTION dir = FORW; /* Not sure, but stops valgrind complaining */
 
   cur = &a->head;
   do
@@ -1707,13 +1709,19 @@ M_POLYAREA_Collect (jmp_buf * e, POLYAREA * afst, POLYAREA ** contours,
 	parent = NULL;
       for (cur = &a->contours; *cur != NULL; cur = next)
 	{
+          POLYAREA *tmp;
+          tmp = *cur;
 	  next = &((*cur)->next);
 #warning PERHAPS WE NEED TO REMOVE THE CONTOUR FROM THE RTREE BECORE CALLING THIS?
 	  /* if we disappear a contour, don't advance twice */
 	  if (cntr_Collect
 	      (e, cur, contours, holes, action,
 	       *cur == parent ? NULL : parent))
-	    next = cur;
+            {
+              next = cur;
+#warning SHOULD BE IN cntr_Collect??
+              r_delete_entry ((rtree_t *)a->contour_tree, (BoxType *)tmp);
+            }
 	}
     }
   while ((a = a->f) != afst);
@@ -2219,6 +2227,7 @@ poly_Copy0 (POLYAREA ** dst, const POLYAREA * src)
     *dst = calloc (1, sizeof (POLYAREA));
   if (*dst == NULL)
     return FALSE;
+  (*dst)->contour_tree = r_create_tree (NULL, 0, 0);
 
   return poly_Copy1 (*dst, src);
 }
@@ -2230,7 +2239,6 @@ poly_Copy1 (POLYAREA * dst, const POLYAREA * src)
 
   *last = NULL;
   dst->f = dst->b = dst;
-  dst->contour_tree = r_create_tree (NULL, 0, 0);
 
   for (cur = src->contours; cur != NULL; cur = cur->next)
     {
@@ -2447,7 +2455,6 @@ poly_Clear (POLYAREA * P)
       P->contours = p->next;
       poly_DelContour (&p);
     }
-  printf ("Destroying %p contour rtree %p\n", P, P->contour_tree);
   r_destroy_tree ((rtree_t **)&P->contour_tree);
 }
 
@@ -2455,7 +2462,6 @@ void
 poly_Free (POLYAREA ** p)
 {
   POLYAREA *cur;
-printf ("Going to free %p and its linked friends\n", *p);
   if (*p == NULL)
     return;
   for (cur = (*p)->f; cur != *p; cur = (*p)->f)
diff --git a/src/pour.c b/src/pour.c
index 8cda8f0..bf56de4 100644
--- a/src/pour.c
+++ b/src/pour.c
@@ -311,8 +311,6 @@ subtract_poly (POLYAREA * np1, POLYAREA **pg)
       return -1;
     }
 
-  printf ("np1->contour_tree=%p *pg->contour_tree=%p\n",
-          np1->contour_tree, (*pg)->contour_tree);
   assert (poly_Valid (*pg));
   assert (poly_Valid (np));
   x = poly_Boolean_free (*pg, np, &merged, PBO_SUB);
@@ -320,10 +318,9 @@ subtract_poly (POLYAREA * np1, POLYAREA **pg)
     {
       fprintf (stderr, "Error while clipping PBO_SUB: %d\n", x);
       poly_Free (&merged);
+      *pg = NULL;
       return -1;
     }
-  printf ("merged->contour_tree=%p\n",
-          merged->contour_tree);
 
   assert (!merged || poly_Valid (merged));
 
@@ -344,10 +341,9 @@ unite_poly (POLYAREA * np, POLYAREA ** pg)
     {
       fprintf (stderr, "Error while clipping PBO_UNITE: %d\n", x);
       poly_Free (&merged);
+      *pg = NULL;
       return 0;
     }
-  printf ("unite merged->contour_tree=%p\n",
-          merged->contour_tree);
   assert (!merged || poly_Valid (merged));
   *pg = merged;
   return 1;
@@ -366,10 +362,9 @@ intersect_poly (POLYAREA * np, POLYAREA ** pg)
     {
       fprintf (stderr, "Error while clipping PBO_ISECT: %d\n", x);
       poly_Free (&merged);
+      *pg = NULL;
       return 0;
     }
-  printf ("intersect merged->contour_tree=%p\n",
-          merged->contour_tree);
   assert (!merged || poly_Valid (merged));
   *pg = merged;
   return 1;
@@ -1184,13 +1179,19 @@ InitPourClip (DataTypePtr Data, LayerTypePtr layer, PourType * pour)
       printf ("Clipping returned NULL - can that be good?\n");
       return 0;
     }
-  assert (poly_Valid (clipped));
+//  assert (poly_Valid (clipped));
   if (TEST_FLAG (CLEARPOLYFLAG, pour))
     {
       /* Clip the pour against anything we can find in this layer */
       ClearPour (Data, layer, pour, &pg, NULL, UNSUBTRACT_BLOAT);
     }
 
+  if (pg == NULL)
+    {
+      printf ("Got pg == NULL for some reason\n");
+      return;
+    }
+
   count_all = count_added = 0;
   /* For each piece of the clipped up polygon, create a new child */
   start_pg = pg;
diff --git a/src/report.c b/src/report.c
index af1b67d..7c9011b 100644
--- a/src/report.c
+++ b/src/report.c
@@ -315,7 +315,7 @@ ReportDialog (int argc, char **argv, int x, int y)
 	if (gui->shift_is_pressed ())
 	  {
 	    LayerTypePtr layer = (LayerTypePtr) ptr1;
-	    __r_dump_tree (layer->polygon_tree->root, 0);
+//	    __r_dump_tree (layer->polygon_tree->root, 0);
 	    return;
 	  }
 #endif

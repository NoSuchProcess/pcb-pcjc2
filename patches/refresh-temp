Bottom: 06a848bff30b298733030cc7eef88c6745b20d25
Top:    460c86bf6e9e259889586ab1090fbff5d9a323a5
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-09-10 17:21:54 +0100

Refresh of crazy-stuff

---

diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index 4ae8242..f83b3d0 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -71,44 +71,46 @@ hid_gc_struct;
 int
 ghid_set_layer (const char *name, int group, int empty)
 {
-  int idx = group;
-  if (idx >= 0 && idx < max_group)
+  if (group >= 0 && group < max_group)
     {
-      int n = PCB->LayerGroups.Number[group];
-      for (idx = 0; idx < n-1; idx ++)
+      int layer_idx;
+      int entry;
+      for (entry = 0; entry < PCB->LayerGroups.Number[group]; entry ++)
 	{
-	  int ni = PCB->LayerGroups.Entries[group][idx];
-	  if (ni >= 0 && ni < max_copper_layer + 2
-	      && PCB->Data->Layer[ni].On)
-	    break;
+	  layer_idx = PCB->LayerGroups.Entries[group][entry];
+	  /* Only return TRUE for visible non-silk layers.
+	   * NB: Silk layers ocupy layer_idx
+	   * max_copper_layer and max_copper_layer + 1
+	   */
+	  if (layer_idx >= 0 && layer_idx < max_copper_layer &&
+	      PCB->Data->Layer[layer_idx].On)
+	    return TRUE;
 	}
-      idx = PCB->LayerGroups.Entries[group][idx];
+      return FALSE;
     }
 
-  if (idx >= 0 && idx < max_copper_layer + 2)
-    return /*pinout ? 1 : */ PCB->Data->Layer[idx].On;
-  if (idx < 0)
+  /* If we didn't hit a match above, group is being used as a
+     special symbolic layer type, and will be negative. */
+
+  switch (SL_TYPE (group))
     {
-      switch (SL_TYPE (idx))
-	{
-	case SL_INVISIBLE:
-	  return /* pinout ? 0 : */ PCB->InvisibleObjectsOn;
-	case SL_MASK:
-	  if (SL_MYSIDE (idx) /*&& !pinout */ )
-	    return TEST_FLAG (SHOWMASKFLAG, PCB);
-	  return 0;
-	case SL_SILK:
-	  if (SL_MYSIDE (idx) /*|| pinout */ )
-	    return PCB->ElementOn;
-	  return 0;
-	case SL_ASSY:
-	  return 0;
-	case SL_PDRILL:
-	case SL_UDRILL:
-	  return 1;
-	case SL_RATS:
-	  return PCB->RatOn;
-	}
+    case SL_INVISIBLE:
+      return /* pinout ? 0 : */ PCB->InvisibleObjectsOn;
+    case SL_MASK:
+      if (SL_MYSIDE (idx) /*&& !pinout */ )
+        return TEST_FLAG (SHOWMASKFLAG, PCB);
+      return 0;
+    case SL_SILK:
+      if (SL_MYSIDE (idx) /*|| pinout */ )
+        return PCB->ElementOn;
+      return 0;
+    case SL_ASSY:
+      return 0;
+    case SL_PDRILL:
+    case SL_UDRILL:
+      return 1;
+    case SL_RATS:
+      return PCB->RatOn;
     }
   return 0;
 }
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index fef348d..ae391be 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -1635,7 +1635,6 @@ ghid_draw_everything (BoxTypePtr drawn_area)
         drawn_groups[ngroups++] = group;
       }
     }
-  }
 
   /*
    * first draw all 'invisible' stuff

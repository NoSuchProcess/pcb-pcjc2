Bottom: 6d6cb91a3db2b8f3b9bd82d3b3f01b8482a04310
Top:    3a44edcae1d59a9d89e7ed3bb7435d5b972c2479
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2015-01-04 21:56:24 +0000

Refresh of play-with-render-to-texture-st

---

diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 74b0d10..3a75c5c 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -98,6 +98,7 @@ typedef struct render_priv {
   GLuint depth_stencil_buffer;
   GLuint fbo_no_stencil;
   GLuint fbo_with_stencil;
+  int fbo_width;
   int fbo_height;
   int textures_ok;
   hidgl_shader *stack_program;
@@ -596,13 +597,13 @@ set_gl_color_for_gc (hidGC gc)
       g = gport->offlimits_color.green / 65535.;
       b = gport->offlimits_color.blue  / 65535.;
 //      a = 0.85;
-      gc->alpha_mult = 1.;
+      gtk_gc->alpha_mult = 1.;
     }
   else
     {
-//      gc->alpha_mult = 0.7;
-      gc->alpha_mult = 1.;
-      if (hid_cache_color (0, gc->colorname, &cval, &cache))
+//      gtk_gc->alpha_mult = 0.7;
+      gtk_gc->alpha_mult = 1.;
+      if (hid_cache_color (0, gtk_gc->colorname, &cval, &cache))
         cc = (ColorCache *) cval.ptr;
       else
         {
@@ -1537,8 +1538,8 @@ clearPad_callback_solid (const BoxType * b, void *cl)
 static void
 GhidDrawMask (int side, BoxType * screen)
 {
-  static bool first_run = true;
-  static GLuint texture;
+//  static bool first_run = true;
+//  static GLuint texture;
   int thin = TEST_FLAG(THINDRAWFLAG, PCB) || TEST_FLAG(THINDRAWPOLYFLAG, PCB);
   LayerType *Layer = LAYER_PTR (side == TOP_SIDE ? top_soldermask_layer : bottom_soldermask_layer);
   struct poly_info info;
@@ -1632,7 +1633,7 @@ GhidDrawMask (int side, BoxType * screen)
 
   hid_draw_use_mask (&ghid_graphics, HID_MASK_OFF);
 
-  first_run = false;
+//  first_run = false;
 }
 
 static int
@@ -1723,16 +1724,16 @@ GhidDrawLayerGroup (int group, const BoxType * screen)
       if (rv) {
         if (!global_view_2d) {
           if (PCB->PinOn &&
-              (group == solder_group || group == component_group))
+              (group == bottom_group || group == top_group))
             r_search (PCB->Data->pin_tree, screen, NULL, pin_name_callback, Layer);
           if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, pin_inlayer_callback, Layer);
           if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, via_inlayer_callback, Layer);
-          if ((group == component_group && !SWAP_IDENT) ||
-              (group == solder_group    &&  SWAP_IDENT))
+          if ((group == top_group    && !SWAP_IDENT) ||
+              (group == bottom_group &&  SWAP_IDENT))
             if (PCB->PinOn)
               r_search (PCB->Data->pad_tree, screen, NULL, pad_callback, Layer);
-          if ((group == solder_group    && !SWAP_IDENT) ||
-              (group == component_group &&  SWAP_IDENT))
+          if ((group == bottom_group && !SWAP_IDENT) ||
+              (group == top_group    &&  SWAP_IDENT))
             if (PCB->PinOn)
               r_search (PCB->Data->pad_tree, screen, NULL, backPad_callback, Layer);
         }
@@ -2147,14 +2148,14 @@ ghid_draw_everything (BoxType *drawn_area)
     double alpha_mult = global_view_2d ? pow (FADE_FACTOR, i) :
       (is_this_physical ? pow (FADE_FACTOR, number_phys_on_top) : 1.);
 
+    //int depth = compute_depth (i);
+    //int layer_visible;
+
     if (is_this_physical)
       number_phys_on_top --;
 
     //ghid_set_alpha_mult (Output.fgGC, alpha_mult);
 
-    int depth = compute_depth (i);
-    int layer_visible;
-
     /* TODO: Cache these textures between frames to avoid the overhead of recomputing */
     if (!priv->textures_ok) {
       /* Draw the layer into a texture */
@@ -2167,6 +2168,7 @@ ghid_draw_everything (BoxType *drawn_area)
 
     hidgl_set_depth (0);
 
+#if 0
     {
       int group = drawn_groups [i];
       int idx;
@@ -2183,6 +2185,7 @@ ghid_draw_everything (BoxType *drawn_area)
       else
         layer_visible = 0;
     }
+#endif
 
 #if 0
     if (priv->layer_rendered[i] && layer_visible) {
@@ -2411,12 +2414,12 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
     old_no_layers = no_layers;
   }
 
-  hidgl_in_context (true);
+  //hidgl_in_context (true);
   hidgl_init ();
   if (one_shot)
     ghid_init_gl (port);
 
-  check_gl_drawing_ok_hack = true;
+  //check_gl_drawing_ok_hack = true;
   debug_stencil_clears = 0;
 
   /* If we don't have any stencil bits available,

Bottom: bfdc1ec4c279e4f5265f88ab467e5a0aa52119f3
Top:    ed0a81fab518089627f1e45b9d395ce333fc28a9
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-05-08 21:14:48 +0100

Refresh of draw-polygons-in-a-more-intell

---

diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index 1f4bc43..75eff4b 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -120,7 +120,7 @@ hidgl_init_triangle_array (triangle_buffer *buffer)
   CHECK_IS_IN_CONTEXT ();
 
   buffer->use_vbo = true;
-  // buffer->use_vbo = false;
+  /* buffer->use_vbo = false; */
 
   if (buffer->use_vbo) {
     glGenBuffers (1, &buffer->vbo_id);
@@ -831,14 +831,23 @@ do_hole (const BoxType *b, void *cl)
   return 1;
 }
 
+static bool
+polygon_contains_user_holes (PolygonType *polygon)
+{
+  return (polygon->HoleIndexN > 0);
+}
+
+
 static GLint stencil_bits;
 static int dirty_bits = 0;
 static int assigned_bits = 0;
 
 /* FIXME: JUST DRAWS THE FIRST PIECE.. TODO: SUPPORT FOR FULLPOLY POLYGONS */
 void
-hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box)
+hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box /*, bool force_new_stencil */)
 {
+  bool force_new_stencil = false;
+  bool use_new_stencil;
   int stencil_bit;
 
   CHECK_IS_IN_CONTEXT ();
@@ -855,14 +864,20 @@ hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box)
     return;
   }
 
-  /* Polygon has holes */
+  /* Polygon has holes.. does it have any user-drawn holes?
+   * If so, it must be masked with a _new_ stencil bit.
+   */
+  use_new_stencil = force_new_stencil | polygon_contains_user_holes (poly);
 
-  stencil_bit = hidgl_assign_clear_stencil_bit ();
-  if (!stencil_bit)
+  if (use_new_stencil)
     {
-      printf ("hidgl_fill_pcb_polygon: No free stencil bits, aborting polygon\n");
-      /* XXX: Could use the GLU tesselator or the full BO polygon tesselator */
-      return;
+      stencil_bit = hidgl_assign_clear_stencil_bit ();
+      if (!stencil_bit)
+        {
+          printf ("hidgl_fill_pcb_polygon: No free stencil bits, aborting polygon\n");
+          /* XXX: Could use the GLU tesselator or the full BO polygon tesselator */
+          return;
+        }
     }
 
   /* Flush out any existing geoemtry to be rendered */
@@ -870,11 +885,14 @@ hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box)
 
   glPushAttrib (GL_STENCIL_BUFFER_BIT |                 /* Resave the stencil write-mask etc.., and */
                 GL_COLOR_BUFFER_BIT);                   /* the colour buffer write mask etc.. for part way restore */
-  glStencilMask (stencil_bit);                          /* Only write to our stencil bit */
-  glStencilFunc (GL_ALWAYS, stencil_bit, stencil_bit);  /* Always pass stencil test, ref value is our bit */
   glColorMask (0, 0, 0, 0);                             /* Disable writting in color buffer */
 
-  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);           /* Stencil pass => replace stencil value */
+  if (use_new_stencil)
+    {
+      glStencilMask (stencil_bit);                            /* Only write to our stencil bit */
+      glStencilFunc (GL_ALWAYS, stencil_bit, stencil_bit);    /* Always pass stencil test, ref value is our bit */
+      glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);             /* Stencil pass => replace stencil value */
+    }
 
   /* Drawing operations now set our reference bit in the stencil buffer */
 
@@ -898,7 +916,8 @@ hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box)
   hidgl_flush_triangles (&buffer);
 
   /* Unassign our stencil buffer bit */
-  hidgl_return_stencil_bit (stencil_bit);
+  if (use_new_stencil)
+    hidgl_return_stencil_bit (stencil_bit);
 
   glPopAttrib ();                               /* Restore the stencil buffer op and function */
 }
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 0d1c633..26d411e 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -1480,11 +1480,28 @@ struct poly_info
 };
 
 static int
-poly_callback (const BoxType * b, void *cl)
+poly_callback_no_clear (const BoxType * b, void *cl)
 {
   struct poly_info *i = (struct poly_info *) cl;
+  PolygonType *polygon = (PolygonType *) b;
 
-  DrawPlainPolygon (i->Layer, (PolygonTypePtr) b, i->drawn_area);
+  if (TEST_FLAG (CLEARPOLYFLAG, polygon))
+    return 0;
+
+  DrawPlainPolygon (i->Layer, polygon, i->drawn_area);
+  return 1;
+}
+
+static int
+poly_callback_clearing (const BoxType * b, void *cl)
+{
+  struct poly_info *i = (struct poly_info *) cl;
+  PolygonType *polygon = (PolygonType *) b;
+
+  if (!TEST_FLAG (CLEARPOLYFLAG, polygon))
+    return 0;
+
+  DrawPlainPolygon (i->Layer, polygon, i->drawn_area);
   return 1;
 }
 
@@ -1620,7 +1637,8 @@ DrawLayerGroup (int group, const BoxType * screen)
       if (Layer->PolygonN) {
         info.Layer = Layer;
         info.drawn_area = screen;
-        r_search (Layer->polygon_tree, screen, NULL, poly_callback, &info);
+        r_search (Layer->polygon_tree, screen, NULL, poly_callback_no_clear, &info);
+        r_search (Layer->polygon_tree, screen, NULL, poly_callback_clearing, &info);
 
         /* HACK: Subcomposite polygons separately from other layer primitives */
         /* Reset the compositing */

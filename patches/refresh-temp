Bottom: cd42a89f8676bf5c35444455da14076d1def9901
Top:    a9de85b504dec1809ebc490fea6680507097b070
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-02-08 18:23:21 +0000

Refresh of more-work-on-trying-to-speed-u

---

diff --git a/src/draw.c b/src/draw.c
index 98264d6..08fa910 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -441,6 +441,55 @@ DrawEverything (BoxTypePtr drawn_area)
 
       if (gui->set_layer (0, group, 0))
 	{
+    static int once = 1;
+
+	  gui->set_color (Output.fgGC, PCB->ElementColor);
+
+    if (group == 0) {
+      static PolygonType Polygon;
+
+      POLYAREA *m;
+      POLYAREA *pa;
+      POLYAREA *arc;
+
+      if (once) {
+        BDimension t = 5000;
+        BDimension w = 1000;
+        BDimension X = 200000;
+        BDimension Y = 200000;
+        int style = 2;
+        pa = CirclePoly (X, Y, t);
+#if 0
+        arc = CirclePoly (X, Y, 4000);
+        /* create a thin ring */
+        poly_Boolean_free (pa, arc, &m, PBO_SUB);
+        Polygon.Clipped = m;
+#else
+        m = pa;
+#endif
+
+        /* fix me needs error checking */
+        if (1)
+          {
+            printf ("Ok, do the first part of the cross\n");
+            pa = RectPoly (X - t, X + t, Y - w, Y + w);
+            Polygon.Clipped = pa;
+            poly_Boolean_free (m, pa, &arc, PBO_SUB);
+            Polygon.Clipped = arc;
+            printf ("Ok, clipped once.. now the second part of the cross\n");
+#if 1
+            pa = RectPoly (X - w, X + w, Y - t, Y + t);
+            Polygon.Clipped = pa;
+            poly_Boolean_free (arc, pa, &m, PBO_SUB);
+            Polygon.Clipped = m;
+#endif
+          }
+        once = 0;
+      }
+
+      gui->fill_pcb_polygon (Output.fgGC, &Polygon);
+    }
+
 	  if (DrawLayerGroup (group, drawn_area) && !gui->gui)
 	    {
 	      int save_swap = SWAP_IDENT;
diff --git a/src/polygon1.c b/src/polygon1.c
index 3479ab7..aec637c 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -2051,7 +2051,7 @@ M_POLYAREA_update_primary (jmp_buf * e, POLYAREA ** pieces,
 
   /* now the non-intersect parts are collected in temp/holes */
   do {
-    int move_kept_to_holes = 0;
+    int hole_contour = 0;
 
     prev = NULL;
     for (curc = (*a)->contours; curc != NULL; curc = next) {
@@ -2066,9 +2066,7 @@ M_POLYAREA_update_primary (jmp_buf * e, POLYAREA ** pieces,
 
       switch (curc->Flags.status) {
         case ISECTED:
-//          printf ("M_POLYAREA_update_primary: Encountered intersected, separating\n");
           isect_contour = 1;
-          move_kept_to_holes = is_first;
           break;
         case INSIDE:
           if (del_inside) del_contour = 1;
@@ -2079,20 +2077,27 @@ M_POLYAREA_update_primary (jmp_buf * e, POLYAREA ** pieces,
           break;
       }
 
-      if (del_contour || isect_contour || move_kept_to_holes) {
+      /* Reset the intersection flags, since we keep these pieces */
+      if (curc->Flags.status != NULL)
+        curc->Flags.status == UNKNWN;
+
+      if (del_contour || isect_contour || hole_contour) {
 
         remove_contour (*a, prev, curc, !(is_first && is_last));
 
         if (del_contour) {
           /* Delete the contour */
           poly_DelContour (&curc); /* Sets curc to NULL */
+          printf ("Deleting contour we don't want in the result\n");
         } else if (isect_contour) { /* Overrides move_to_holes */
           /* Link into the list of intersected contours */
           curc->next = *isected;
           *isected = curc;
-        } else if (move_kept_to_holes) {
+          printf ("Separating intersected contour.\n");
+        } else if (hole_contour) {
           curc->next = *holes;
           *holes = curc;
+          printf ("Separating a hole (belonging to a moved contour)\n");
         } else {
           assert (0);
         }
@@ -2108,6 +2113,11 @@ M_POLYAREA_update_primary (jmp_buf * e, POLYAREA ** pieces,
            "next" pointer adjusted. Saves walking the contour list when we delete one. */
         prev = curc;
       }
+
+      /* If we move or delete an outer contour, we need to move any holes
+         we wish to keep within that contour to the holes list. */
+      if (is_first && (del_contour || isect_contour))
+        hole_contour = 1;
     }
 
     if (*a == NULL) {

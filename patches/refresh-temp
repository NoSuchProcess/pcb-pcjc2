Bottom: dddf84bb9cd49a0d6c0269c008c61ce01590710a
Top:    63a9c2f9d4c63946be0ddd282d1d240cef9f4f86
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2015-01-10 13:13:59 +0000

Refresh of draw-polygons-in-a-more-intell

---

diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index 66586f1..f1a9ffa 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -858,8 +858,14 @@ do_hole (const BoxType *b, void *cl)
   return 1;
 }
 
+static bool
+polygon_contains_user_holes (PolygonType *polygon)
+{
+  return (polygon->HoleIndexN > 0);
+}
+
 static void
-fill_polyarea (hidGC gc, POLYAREA *pa, const BoxType *clip_box)
+fill_polyarea (hidGC gc, POLYAREA *pa, const BoxType *clip_box, bool use_new_stencil)
 {
   hidglGC hidgl_gc = (hidglGC)gc;
   hidgl_instance *hidgl = hidgl_gc->hidgl;
@@ -874,14 +880,18 @@ fill_polyarea (hidGC gc, POLYAREA *pa, const BoxType *clip_box)
     return;
   }
 
-  /* Polygon has holes */
-
-  stencil_bit = hidgl_assign_clear_stencil_bit (hidgl);
-  if (!stencil_bit)
+  /* Polygon has holes.. does it have any user-drawn holes? (caller tells us)
+   * If so, it must be masked with a _new_ stencil bit.
+   */
+  if (use_new_stencil)
     {
-      printf ("hidgl_fill_pcb_polygon: No free stencil bits, aborting polygon\n");
-      /* XXX: Could use the GLU tesselator or the full BO polygon tesselator */
-      return;
+      stencil_bit = hidgl_assign_clear_stencil_bit (hidgl);
+      if (!stencil_bit)
+        {
+          printf ("hidgl_fill_pcb_polygon: No free stencil bits, aborting polygon\n");
+          /* XXX: Could use the GLU tesselator or the full BO polygon tesselator */
+          return;
+        }
     }
 
   /* Flush out any existing geoemtry to be rendered */
@@ -889,12 +899,15 @@ fill_polyarea (hidGC gc, POLYAREA *pa, const BoxType *clip_box)
 
   glPushAttrib (GL_STENCIL_BUFFER_BIT |                 /* Resave the stencil write-mask etc.., and */
                 GL_COLOR_BUFFER_BIT);                   /* the colour buffer write mask etc.. for part way restore */
-  glStencilMask (stencil_bit);                          /* Only write to our stencil bit */
-  glStencilFunc (GL_ALWAYS, stencil_bit, stencil_bit);  /* Always pass stencil test, ref value is our bit */
   glEnable (GL_STENCIL_TEST);                           /* Enable the stencil test, just in case it wasn't already on */
   glColorMask (0, 0, 0, 0);                             /* Disable writting in color buffer */
 
-  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);           /* Stencil pass => replace stencil value */
+  if (use_new_stencil)
+    {
+      glStencilMask (stencil_bit);                            /* Only write to our stencil bit */
+      glStencilFunc (GL_ALWAYS, stencil_bit, stencil_bit);    /* Always pass stencil test, ref value is our bit */
+      glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);             /* Stencil pass => replace stencil value */
+    }
 
   /* Drawing operations now set our reference bit in the stencil buffer */
 
@@ -920,7 +933,8 @@ fill_polyarea (hidGC gc, POLYAREA *pa, const BoxType *clip_box)
   hidgl_flush_triangles (hidgl);
 
   /* Unassign our stencil buffer bit */
-  hidgl_return_stencil_bit (hidgl, stencil_bit);
+  if (use_new_stencil)
+    hidgl_return_stencil_bit (hidgl, stencil_bit);
 
   glPopAttrib ();                               /* Restore the stencil buffer op and function */
 }
@@ -928,17 +942,22 @@ fill_polyarea (hidGC gc, POLYAREA *pa, const BoxType *clip_box)
 void
 hidgl_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
 {
+  bool use_new_stencil;
+
   if (poly->Clipped == NULL)
     return;
 
-  fill_polyarea (gc, poly->Clipped, clip_box);
+  use_new_stencil = polygon_contains_user_holes (poly) ||
+                    TEST_FLAG (FULLPOLYFLAG, poly);
+
+  fill_polyarea (gc, poly->Clipped, clip_box, use_new_stencil);
 
   if (TEST_FLAG (FULLPOLYFLAG, poly))
     {
       POLYAREA *pa;
 
       for (pa = poly->Clipped->f; pa != poly->Clipped; pa = pa->f)
-        fill_polyarea (gc, pa, clip_box);
+        fill_polyarea (gc, pa, clip_box, use_new_stencil);
     }
 }
 
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 7d8ce0a..7591bc4 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -1375,7 +1375,35 @@ static int
 poly_callback (const BoxType * b, void *cl)
 {
   struct poly_info *i = (struct poly_info *) cl;
-  PolygonType *polygon = (PolygonType *)b;
+  PolygonType *polygon = (PolygonType *) b;
+
+  set_layer_object_color (i->layer, (AnyObjectType *) polygon);
+  hid_draw_pcb_polygon (Output.fgGC, polygon, i->drawn_area);
+  return 1;
+}
+
+static int
+poly_callback_no_clear (const BoxType * b, void *cl)
+{
+  struct poly_info *i = (struct poly_info *) cl;
+  PolygonType *polygon = (PolygonType *) b;
+
+  if (TEST_FLAG (CLEARPOLYFLAG, polygon))
+    return 0;
+
+  set_layer_object_color (i->layer, (AnyObjectType *) polygon);
+  hid_draw_pcb_polygon (Output.fgGC, polygon, i->drawn_area);
+  return 1;
+}
+
+static int
+poly_callback_clearing (const BoxType * b, void *cl)
+{
+  struct poly_info *i = (struct poly_info *) cl;
+  PolygonType *polygon = (PolygonType *) b;
+
+  if (!TEST_FLAG (CLEARPOLYFLAG, polygon))
+    return 0;
 
   set_layer_object_color (i->layer, (AnyObjectType *) polygon);
   hid_draw_pcb_polygon (Output.fgGC, polygon, i->drawn_area);
@@ -1529,7 +1557,8 @@ GhidDrawLayerGroup (int group, const BoxType * screen)
       if (Layer->PolygonN) {
         info.layer = Layer;
         info.drawn_area = screen;
-        r_search (Layer->polygon_tree, screen, NULL, poly_callback, &info);
+        r_search (Layer->polygon_tree, screen, NULL, poly_callback_no_clear, &info);
+        r_search (Layer->polygon_tree, screen, NULL, poly_callback_clearing, &info);
 
         /* HACK: Subcomposite polygons separately from other layer primitives */
         /* Reset the compositing */

Bottom: 867712ea8853622f71c69e8c4c77d7060e806b05
Top:    c7ecb7d17248bc0acf69413f1fe71d5c43273229
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-11-26 01:28:31 +0000

Refresh of patch

---

diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 9c55b3a..14a5278 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -56,6 +56,9 @@ static bool check_gl_drawing_ok_hack = false;
 */
 #define USE_GC(gc) if (!use_gc(gc)) return
 
+#define NO_SAMPLERS      9
+#define NO_SAMPLERS_STR "9"
+
 static int cur_mask = -1;
 static GLfloat view_matrix[4][4] = {{1.0, 0.0, 0.0, 0.0},
                                     {0.0, 1.0, 0.0, 0.0},
@@ -1027,26 +1030,29 @@ ghid_init_gl (GHidPort *port)
 {
   render_priv *priv = port->render_priv;
   char *stack_fs_source =
-           "sampler2D foobar;\n"
-           "sampler2D layer_texture[16];\n"
+           "uniform float layer_alpha;\n"
+           "uniform sampler2D layer_texture[" NO_SAMPLERS_STR "];\n"
            "\n"
            "void main()\n"
            "{\n"
            "  vec4 layer_value[16];\n"
            "  int layer_num;\n"
            "\n"
-           "  for (layer_num = 0; layer_num < 16; layer_num++) {\n"
-           //"    layer_value[ layer_num ] = texture2D (layer_texture[ layer_num ], gl_TexCoord[0].st);\n"
-           "    layer_value[ layer_num ] = texture2D (foobar, gl_TexCoord[0].st);\n"
+           "  for (layer_num = 0; layer_num < " NO_SAMPLERS_STR "; layer_num++) {\n"
+           "    layer_value[layer_num] = texture2D (layer_texture[layer_num], gl_TexCoord[0].st);\n"
            "  }\n"
            "\n"
-           "  vec4 accum = layer_value[0] * layer_value[0].a;\n"
+           "  vec4 accum = layer_value[0] * layer_value[0].a * layer_alpha;\n"
            "\n"
-           "  for (layer_num = 1; layer_num < 16; layer_num++) {\n"
-           "    float one_minus_sa = 1. - layer_value[ layer_num ].a;\n"
-           "    accum = accum * one_minus_sa + layer_value[ layer_num ] * layer_value[0].a;\n"
+#if 1
+           "  for (layer_num = 1; layer_num < " NO_SAMPLERS_STR "; layer_num++) {\n"
+           "    float sa = layer_value[layer_num].a * layer_alpha;\n"
+           "    float one_minus_sa = 1. - sa;\n"
+           "    vec4 addition = layer_value[layer_num] * sa;\n"
+           "    accum = accum * one_minus_sa + addition;\n"
            "  }\n"
            "\n"
+#endif
            "  gl_FragColor = accum;\n"
            "}\n";
 
@@ -1706,10 +1712,15 @@ setup_fbo (GHidPort *port, int width, int height, int no_layers)
     glGenTextures (1, &priv->layer_texture[layer]);
     glBindTexture (GL_TEXTURE_2D, priv->layer_texture[layer]);
 
+//    glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
+//    glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
+//    glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+//    glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR_MIPMAP_LINEAR);
+
     glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
     glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
-    glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-    glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR_MIPMAP_LINEAR);
+    glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+    glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
 
     /* Allocate storage for each texture. The texels are undefined. */
     glTexImage2D (GL_TEXTURE_2D, 0, GL_RGBA8,
@@ -1936,8 +1947,8 @@ ghid_draw_everything (BoxTypePtr drawn_area)
     /* TODO: Cache these textures between frames to avoid the overhead of recomputing */
     if (!priv->textures_ok) {
       /* Draw the layer into a texture */
-      setup_fbo_layer (gport, drawn_groups [i], TRUE); /* TRUE is for yes, we want a stencil buffer */
-      //setup_fbo_layer (gport, drawn_groups [i], false);
+      //setup_fbo_layer (gport, drawn_groups [i], TRUE); /* TRUE is for yes, we want a stencil buffer */
+      setup_fbo_layer (gport, drawn_groups [i], false);
       DrawLayerGroup (drawn_groups [i], drawn_area);
       cleanup_fbo_layer (gport);
       priv->layer_rendered[i] = TRUE;
@@ -2011,31 +2022,48 @@ ghid_draw_everything (BoxTypePtr drawn_area)
 // HELLO
   hidgl_shader_activate (priv->stack_program);
   {
-#define NO_SAMPLERS 16
     GLint tex_ids[NO_SAMPLERS];
     GLuint sp = hidgl_shader_get_program (priv->stack_program);
-    //GLint loc = glGetUniformLocation (sp, "layer_texture");
-    GLint loc = glGetUniformLocation (sp, "foobar");
-    int layer;
+    GLint loc = glGetUniformLocation (sp, "layer_texture");
+    int sampler;
 
-    for (layer = 0; layer < NO_SAMPLERS; layer++) {
-      glActiveTexture (GL_TEXTURE0 + layer);
-      if (layer < priv->no_layers)
+    for (sampler = 0; sampler < NO_SAMPLERS; sampler++) {
+      glActiveTexture (GL_TEXTURE0 + sampler);
+#if 1
+      glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
+      glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
+      glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+      glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+#endif
+      if (sampler < 9 /*priv->no_layers*/) {
+        int layer = /*priv->no_layers -*/ 8 - sampler;
         glBindTexture (GL_TEXTURE_2D, priv->layer_texture [layer]);
-      else
+      } else {
         glBindTexture (GL_TEXTURE_2D, 0);
-      tex_ids [layer] = layer;
+      }
+      tex_ids [sampler] = sampler;
     }
-//    glUniform1iv (loc, NO_SAMPLERS, tex_ids);
-    glUniform1i (loc, 0);
-#undef NO_SAMPLERS
+    glUniform1iv (loc, NO_SAMPLERS, tex_ids);
     glActiveTexture (GL_TEXTURE0);
+
+    loc = glGetUniformLocation (sp, "layer_alpha");
+    glUniform1f (loc, 0.8);
   }
   glPushMatrix ();
   glLoadIdentity ();
-//  glEnable (GL_TEXTURE_2D);
-  glColor4f (1., 1., 1., 0.7);
 
+  {
+    float aspect = (float)priv->fbo_width / (float)priv->fbo_height;
+
+    glBegin (GL_QUADS);
+    glTexCoord2d (0.0, 1.0); glVertex3f (-aspect, -1.0, -1.);
+    glTexCoord2d (1.0, 1.0); glVertex3f ( aspect, -1.0, -1.);
+    glTexCoord2d (1.0, 0.0); glVertex3f ( aspect,  1.0, -1.);
+    glTexCoord2d (0.0, 0.0); glVertex3f (-aspect,  1.0, -1.);
+    glEnd ();
+  }
+
+#if 0
   /* draw all layers in layerstack order */
   for (i = ngroups - 1; i >= 0; i--) {
     int layer_visible;
@@ -2055,20 +2083,10 @@ ghid_draw_everything (BoxTypePtr drawn_area)
       layer_visible = 0;
 
     if (priv->layer_rendered[i] && layer_visible) {
-      float aspect = (float)priv->fbo_width / (float)priv->fbo_height;
-
-      glBindTexture (GL_TEXTURE_2D, priv->layer_texture[drawn_groups [i]]);
-      glBegin (GL_QUADS);
-      glTexCoord2d (0.0, 1.0); glVertex3f (-aspect, -1.0, -1.);
-      glTexCoord2d (1.0, 1.0); glVertex3f ( aspect, -1.0, -1.);
-      glTexCoord2d (1.0, 0.0); glVertex3f ( aspect,  1.0, -1.);
-      glTexCoord2d (0.0, 0.0); glVertex3f (-aspect,  1.0, -1.);
-      glEnd ();
     }
   }
+#endif
 
-  glBindTexture (GL_TEXTURE_2D, 0);
-  glDisable (GL_TEXTURE_2D);
   glPopMatrix ();
   hidgl_shader_activate (circular_program);
 // GOODBYE

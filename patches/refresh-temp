Bottom: 23c02e1301b95d2ba4f4274a6021f50178fdf67c
Top:    3d0733487ee2214cf3fc212cf2e9f221ea6abe1f
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2015-02-15 20:01:15 +0000

Refresh of 0002-Fix-poly-contours.patch

---

diff --git a/src/polygon.c b/src/polygon.c
index 60a13d4..c4599fa 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -419,6 +419,37 @@ frac_circle (PLINE * c, Coord X, Coord Y, Vector v, int fraction)
     }
 }
 
+/* add verticies in a fractional-circle starting from v
+ * centered at X, Y and going counter-clockwise
+ * does not include the first point
+ * last argument is 1 for a full circle
+ * 2 for a half circle
+ * or 4 for a quarter circle
+ */
+static void
+frac_circle2 (PLINE * c, Coord X, Coord Y, Vector v, int fraction)
+{
+  double e1, e2, t1;
+  int i, range;
+
+  /* move vector to origin */
+  e1 = (v[0] - X) * POLY_CIRC_RADIUS_ADJ;
+  e2 = (v[1] - Y) * POLY_CIRC_RADIUS_ADJ;
+
+  /* XXX */ /* NB: the caller adds the last vertex, hence the -1 */
+  range = POLY_CIRC_SEGS / fraction;
+  for (i = 0; i < range; i++)
+    {
+      /* rotate the vector */
+      t1 = rotate_circle_seg[0] * e1 + rotate_circle_seg[1] * e2;
+      e2 = rotate_circle_seg[2] * e1 + rotate_circle_seg[3] * e2;
+      e1 = t1;
+      v[0] = X + ROUND (e1);
+      v[1] = Y + ROUND (e2);
+      poly_InclVertex (c->head.prev, poly_CreateNode (v));
+    }
+}
+
 /* create a circle approximation from lines */
 /* NB: Name can be NULL, but once passed is owned by the contour.
  *     It will be free'd with free() when no longer required, so
@@ -437,7 +468,7 @@ CirclePoly (Coord x, Coord y, Coord radius, char *name)
   v[1] = y;
   if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
     return NULL;
-  frac_circle (contour, x, y, v, 1);
+  frac_circle2 (contour, x, y, v, 1);
   contour->is_round = TRUE;
   contour->cx = x;
   contour->cy = y;
@@ -617,30 +648,39 @@ LinePoly (LineType * L, Coord thick, char *name)
       l->Point2.X += dy;
       l->Point2.Y -= dx;
     }
-  v[0] = l->Point1.X - dx;
-  v[1] = l->Point1.Y - dy;
+
+  v[0] = l->Point2.X - dx;
+  v[1] = l->Point2.Y - dy;
   if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
     return 0;
   contour->name = name;
 
-  v[0] = l->Point2.X - dx;
-  v[1] = l->Point2.Y - dy;
   if (TEST_FLAG (SQUAREFLAG,l))
-    poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+    {
+      v[0] = l->Point2.X + dx;
+      v[1] = l->Point2.Y + dy;
+      poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+    }
   else
-    frac_circle (contour, l->Point2.X, l->Point2.Y, v, 2);
-  v[0] = l->Point2.X + dx;
-  v[1] = l->Point2.Y + dy;
-  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+    frac_circle2 (contour, l->Point2.X, l->Point2.Y, v, 2);
+
   v[0] = l->Point1.X + dx;
   v[1] = l->Point1.Y + dy;
+  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+
   if (TEST_FLAG (SQUAREFLAG,l))
-    poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+    {
+      v[0] = l->Point1.X - dx;
+      v[1] = l->Point1.Y - dy;
+      poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+    }
   else
-    frac_circle (contour, l->Point1.X, l->Point1.Y, v, 2);
+    frac_circle2 (contour, l->Point1.X, l->Point1.Y, v, 2);
+
   /* now we have the line contour */
   if (!(np = ContourToPoly (contour)))
     return NULL;
+
   return np;
 }

Bottom: 6d52c7fd1e8cfb16bd126fbb6c08f88042363b2c
Top:    0f5160d414d90df0679ab60b932904a1657b6081
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-04-26 21:06:55 +0100

Refresh of give-the-hids-control-over-att

---

diff --git a/src/action.c b/src/action.c
index 5dc544e..7744cd1 100644
--- a/src/action.c
+++ b/src/action.c
@@ -607,7 +607,7 @@ click_cb (hidval hv)
 {
   if (Note.Click)
     {
-      HideCrosshair ();
+      notify_crosshair_change (false);
       Note.Click = false;
       if (Note.Moving && !gui->shift_is_pressed ())
 	{
@@ -650,7 +650,7 @@ click_cb (hidval hv)
 	  Crosshair.AttachedBox.Point1.X = Note.X;
 	  Crosshair.AttachedBox.Point1.Y = Note.Y;
 	}
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
     }
 }
 
@@ -945,7 +945,7 @@ NotifyLine (void)
 static void
 NotifyBlock (void)
 {
-  HideCrosshair ();
+  notify_crosshair_change (false);
   switch (Crosshair.AttachedBox.State)
     {
     case STATE_FIRST:		/* setup first point */
@@ -960,7 +960,7 @@ NotifyBlock (void)
       Crosshair.AttachedBox.State = STATE_THIRD;
       break;
     }
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
 }
 
 
@@ -2122,11 +2122,11 @@ ActionMovePointer (char *deltax, char *deltay)
   /* restore crosshair for erasure */
   Crosshair.X = x;
   Crosshair.Y = y;
-  HideCrosshair ();
+  notify_crosshair_change (false);
   MoveCrosshairRelative (TO_SCREEN_SIGN_X (dx), TO_SCREEN_SIGN_Y (dy));
   /* update object position and cursor location */
   AdjustAttachedObjects ();
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
 }
 
 /* ---------------------------------------------------------------------------
@@ -2152,10 +2152,9 @@ EventMoveCrosshair (int ev_x, int ev_y)
     {
       if (MoveCrosshairAbsolute (ev_x, ev_y))
 	{
-
 	  /* update object position and cursor location */
 	  AdjustAttachedObjects ();
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	}
     }
   else
@@ -2720,7 +2719,7 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 	  break;
 
 	case F_CycleClip:
-	  HideCrosshair ();
+	  notify_crosshair_change (false);
 	  if TEST_FLAG
 	    (ALLDIRECTIONFLAG, PCB)
 	    {
@@ -2730,27 +2729,27 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 	  else
 	    PCB->Clipping = (PCB->Clipping + 1) % 3;
 	  AdjustAttachedObjects ();
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  break;
 
 	case F_CycleCrosshair:
-	  HideCrosshair ();
+	  notify_crosshair_change (false);
 	  Crosshair.shape = CrosshairShapeIncrement(Crosshair.shape);
 	  if (Crosshair_Shapes_Number == Crosshair.shape)
 	    Crosshair.shape = Basic_Crosshair_Shape;
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  break;
 
 	case F_ToggleRubberBandMode:
-	  HideCrosshair ();
+	  notify_crosshair_change (false);
 	  TOGGLE_FLAG (RUBBERBANDFLAG, PCB);
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  break;
 
 	case F_ToggleStartDirection:
-	  HideCrosshair ();
+	  notify_crosshair_change (false);
 	  TOGGLE_FLAG (SWAPSTARTDIRFLAG, PCB);
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  break;
 
 	case F_ToggleUniqueNames:
@@ -2758,9 +2757,9 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 	  break;
 
 	case F_ToggleSnapPin:
-	  HideCrosshair ();
+	  notify_crosshair_change (false);
 	  TOGGLE_FLAG (SNAPPINFLAG, PCB);
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  break;
 
 	case F_ToggleLocalRef:
@@ -2801,7 +2800,7 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 	  break;
 
 	case F_ToggleAutoDRC:
-	  HideCrosshair ();
+	  notify_crosshair_change (false);
 	  TOGGLE_FLAG (AUTODRCFLAG, PCB);
 	  if (TEST_FLAG (AUTODRCFLAG, PCB) && Settings.Mode == LINE_MODE)
 	    {
@@ -2815,7 +2814,7 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 				  Crosshair.AttachedLine.Point1.Y, true, 1,
 				  FOUNDFLAG);
 	    }
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  break;
 
 	case F_ToggleCheckPlanes:
@@ -2853,7 +2852,7 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 	    oldGrid = PCB->Grid;
 	    PCB->Grid = 1.0;
 	    if (MoveCrosshairAbsolute (Crosshair.X, Crosshair.Y))
-	      RestoreCrosshair ();	/* was hidden by MoveCrosshairAbs */
+	      notify_crosshair_change (true);	/* first notify was in MoveCrosshairAbs */
 	    SetGrid (oldGrid, true);
 	  }
 	  break;
@@ -3057,7 +3056,7 @@ ActionMode (int argc, char **argv, int x, int y)
     {
       Note.X = Crosshair.X;
       Note.Y = Crosshair.Y;
-      HideCrosshair ();
+      notify_crosshair_change (false);
       switch (GetFunctionID (function))
 	{
 	case F_Arc:
@@ -3253,7 +3252,7 @@ ActionMode (int argc, char **argv, int x, int y)
 	  SaveMode ();
 	  break;
 	}
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
       return 0;
     }
 
@@ -4028,24 +4027,27 @@ ActionMarkCrosshair (int argc, char **argv, int x, int y)
     {
       if (Marked.status)
 	{
-	  DrawMark ();
+	  notify_mark_change (false);
 	  Marked.status = false;
+	  notify_mark_change (true);
 	}
       else
 	{
+	  notify_mark_change (false);
+	  Marked.status = false;
 	  Marked.status = true;
 	  Marked.X = Crosshair.X;
 	  Marked.Y = Crosshair.Y;
-	  DrawMark ();
+	  notify_mark_change (true);
 	}
     }
   else if (GetFunctionID (function) == F_Center)
     {
-      DrawMark ();
+      notify_mark_change (false);
       Marked.status = true;
       Marked.X = Crosshair.X;
       Marked.Y = Crosshair.Y;
-      DrawMark ();
+      notify_mark_change (true);
     }
   return 0;
 }
@@ -5439,7 +5441,7 @@ ActionSelect (int argc, char **argv, int x, int y)
 			  Crosshair.AttachedBox.Point2.X);
 	    box.Y2 = MAX (Crosshair.AttachedBox.Point1.Y,
 			  Crosshair.AttachedBox.Point2.Y);
-	    HideCrosshair ();
+	    notify_crosshair_change (false);
 	    NotifyBlock ();
 	    if (Crosshair.AttachedBox.State == STATE_THIRD &&
 		SelectBlock (&box, true))
@@ -5447,7 +5449,7 @@ ActionSelect (int argc, char **argv, int x, int y)
 		SetChangedFlag (true);
 		Crosshair.AttachedBox.State = STATE_FIRST;
 	      }
-	    RestoreCrosshair ();
+	    notify_crosshair_change (true);
 	    break;
 	  }
 
@@ -5618,7 +5620,7 @@ ActionUnselect (int argc, char **argv, int x, int y)
 			  Crosshair.AttachedBox.Point2.X);
 	    box.Y2 = MAX (Crosshair.AttachedBox.Point1.Y,
 			  Crosshair.AttachedBox.Point2.Y);
-	    HideCrosshair ();
+	    notify_crosshair_change (false);
 	    NotifyBlock ();
 	    if (Crosshair.AttachedBox.State == STATE_THIRD &&
 		SelectBlock (&box, false))
@@ -5626,7 +5628,7 @@ ActionUnselect (int argc, char **argv, int x, int y)
 		SetChangedFlag (true);
 		Crosshair.AttachedBox.State = STATE_FIRST;
 	      }
-	    RestoreCrosshair ();
+	    notify_crosshair_change (true);
 	    break;
 	  }
 
@@ -5857,18 +5859,18 @@ ActionLoadFrom (int argc, char **argv, int x, int y)
 
   if (strcasecmp (function, "ElementToBuffer") == 0)
     {
-      HideCrosshair ();
+      notify_crosshair_change (false);
       if (LoadElementToBuffer (PASTEBUFFER, name, true))
 	SetMode (PASTEBUFFER_MODE);
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
     }
 
   else if (strcasecmp (function, "LayoutToBuffer") == 0)
     {
-      HideCrosshair ();
+      notify_crosshair_change (false);
       if (LoadLayoutToBuffer (PASTEBUFFER, name))
 	SetMode (PASTEBUFFER_MODE);
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
     }
 
   else if (strcasecmp (function, "Layout") == 0)
@@ -5925,7 +5927,7 @@ ActionNew (int argc, char **argv, int x, int y)
       if (!name)
         return 1;
 
-      HideCrosshair ();
+      notify_crosshair_change (false);
       /* do emergency saving
        * clear the old struct and allocate memory for the new one
        */
@@ -5947,7 +5949,7 @@ ActionNew (int argc, char **argv, int x, int y)
       Redraw ();
 
       hid_action ("PCBChanged");
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
       return 0;
     }
   return 1;
@@ -6034,7 +6036,7 @@ ActionPasteBuffer (int argc, char **argv, int x, int y)
   static char *default_file = NULL;
   int free_name = 0;
 
-  HideCrosshair ();
+  notify_crosshair_change (true);
   if (function)
     {
       switch (GetFunctionID (function))
@@ -6141,7 +6143,7 @@ ActionPasteBuffer (int argc, char **argv, int x, int y)
 	      }
 	    else
 	      {
-		RestoreCrosshair ();
+		notify_crosshair_change (false);
 		AFAIL (pastebuffer);
 	      }
 
@@ -6164,7 +6166,7 @@ ActionPasteBuffer (int argc, char **argv, int x, int y)
 	}
     }
 
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   return 0;
 }
 
@@ -6205,13 +6207,13 @@ ActionUndo (int argc, char **argv, int x, int y)
 	return 1;
       /* undo the last operation */
 
-      HideCrosshair ();
+      notify_crosshair_change (false);
       if ((Settings.Mode == POLYGON_MODE ||
            Settings.Mode == POLYGONHOLE_MODE) &&
           Crosshair.AttachedPolygon.PointN)
 	{
 	  GoToPreviousPoint ();
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  return 0;
 	}
       /* move anchor point if undoing during line creation */
@@ -6223,7 +6225,7 @@ ActionUndo (int argc, char **argv, int x, int y)
 		Undo (true);	/* undo the connection find */
 	      Crosshair.AttachedLine.State = STATE_FIRST;
 	      SetLocalRef (0, 0, false);
-	      RestoreCrosshair ();
+	      notify_crosshair_change (true);
 	      return 0;
 	    }
 	  if (Crosshair.AttachedLine.State == STATE_THIRD)
@@ -6251,7 +6253,7 @@ ActionUndo (int argc, char **argv, int x, int y)
 		    Crosshair.AttachedLine.Point1.X;
 		  Crosshair.AttachedLine.Point2.Y =
 		    Crosshair.AttachedLine.Point1.Y;
-		  RestoreCrosshair ();
+		  notify_crosshair_change (true);
 		  return 0;
 		}
 	      /* move to new anchor */
@@ -6298,7 +6300,7 @@ ActionUndo (int argc, char **argv, int x, int y)
 		  ptr2 = (LineTypePtr) ptrtmp;
 		  lastLayer = (LayerTypePtr) ptr1;
 		}
-	      RestoreCrosshair ();
+	      notify_crosshair_change (true);
 	      return 0;
 	    }
 	}
@@ -6307,7 +6309,7 @@ ActionUndo (int argc, char **argv, int x, int y)
 	  if (Crosshair.AttachedBox.State == STATE_SECOND)
 	    {
 	      Crosshair.AttachedBox.State = STATE_FIRST;
-	      RestoreCrosshair ();
+	      notify_crosshair_change (true);
 	      return 0;
 	    }
 	  if (Crosshair.AttachedBox.State == STATE_THIRD)
@@ -6342,7 +6344,7 @@ ActionUndo (int argc, char **argv, int x, int y)
 	  break;
 	}
     }
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   return 0;
 }
 
@@ -6375,7 +6377,7 @@ ActionRedo (int argc, char **argv, int x, int y)
        Crosshair.AttachedPolygon.PointN) ||
       Crosshair.AttachedLine.State == STATE_SECOND)
     return 1;
-  HideCrosshair ();
+  notify_crosshair_change (false);
   if (Redo (true))
     {
       SetChangedFlag (true);
@@ -6390,7 +6392,7 @@ ActionRedo (int argc, char **argv, int x, int y)
 	  addedLines++;
 	}
     }
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   return 0;
 }
 
@@ -6424,7 +6426,7 @@ ActionPolygon (int argc, char **argv, int x, int y)
   char *function = ARG (0);
   if (function && Settings.Mode == POLYGON_MODE)
     {
-      HideCrosshair ();
+      notify_crosshair_change (false);
       switch (GetFunctionID (function))
 	{
 	  /* close open polygon if possible */
@@ -6437,7 +6439,7 @@ ActionPolygon (int argc, char **argv, int x, int y)
 	  GoToPreviousPoint ();
 	  break;
 	}
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
     }
   return 0;
 }
@@ -6601,24 +6603,24 @@ ActionSetSame (int argc, char **argv, int x, int y)
   switch (type)
     {
     case LINE_TYPE:
-      HideCrosshair ();
+      notify_crosshair_change (false);
       Settings.LineThickness = ((LineTypePtr) ptr2)->Thickness;
       Settings.Keepaway = ((LineTypePtr) ptr2)->Clearance / 2;
       layer = (LayerTypePtr) ptr1;
       if (Settings.Mode != LINE_MODE)
 	SetMode (LINE_MODE);
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
       hid_action ("RouteStylesChanged");
       break;
 
     case ARC_TYPE:
-      HideCrosshair ();
+      notify_crosshair_change (false);
       Settings.LineThickness = ((ArcTypePtr) ptr2)->Thickness;
       Settings.Keepaway = ((ArcTypePtr) ptr2)->Clearance / 2;
       layer = (LayerTypePtr) ptr1;
       if (Settings.Mode != ARC_MODE)
 	SetMode (ARC_MODE);
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
       hid_action ("RouteStylesChanged");
       break;
 
@@ -6627,13 +6629,13 @@ ActionSetSame (int argc, char **argv, int x, int y)
       break;
 
     case VIA_TYPE:
-      HideCrosshair ();
+      notify_crosshair_change (false);
       Settings.ViaThickness = ((PinTypePtr) ptr2)->Thickness;
       Settings.ViaDrillingHole = ((PinTypePtr) ptr2)->DrillingHole;
       Settings.Keepaway = ((PinTypePtr) ptr2)->Clearance / 2;
       if (Settings.Mode != VIA_MODE)
 	SetMode (VIA_MODE);
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
       hid_action ("RouteStylesChanged");
       break;
 
diff --git a/src/buffer.c b/src/buffer.c
index 43d5c2b..4f746e9 100644
--- a/src/buffer.c
+++ b/src/buffer.c
@@ -526,7 +526,7 @@ AddSelectedToBuffer (BufferTypePtr Buffer, LocationType X, LocationType Y,
    */
   if (!LeaveSelected)
     ExtraFlag = SELECTEDFLAG;
-  HideCrosshair ();
+  notify_crosshair_change (false);
   Source = PCB->Data;
   Dest = Buffer->Data;
   SelectedOperation (&AddBufferFunctions, false, ALL_TYPES);
@@ -542,7 +542,7 @@ AddSelectedToBuffer (BufferTypePtr Buffer, LocationType X, LocationType Y,
       Buffer->X = Crosshair.X;
       Buffer->Y = Crosshair.Y;
     }
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   ExtraFlag = 0;
 }
 
@@ -1457,9 +1457,9 @@ ActionFreeRotateBuffer(int argc, char **argv, int x, int y)
   else
     angle_s = argv[0];
 
-  HideCrosshair ();
+  notify_crosshair_change (false);
   FreeRotateBuffer(PASTEBUFFER, strtod(angle_s, 0));
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   return 0;
 }
 
diff --git a/src/crosshair.c b/src/crosshair.c
index 054610b..b0ef6f8 100644
--- a/src/crosshair.c
+++ b/src/crosshair.c
@@ -66,15 +66,6 @@ typedef struct
 } point;
 
 /* ---------------------------------------------------------------------------
- * some local identifiers
- */
-
-/* This is a stack for HideCrosshair() and RestoreCrosshair() calls. They
- * must always be matched. */
-static bool CrosshairStack[MAX_CROSSHAIRSTACK_DEPTH];
-static int CrosshairStackLocation = 0;
-
-/* ---------------------------------------------------------------------------
  * some local prototypes
  */
 static void XORPolygon (PolygonTypePtr, LocationType, LocationType);
@@ -706,17 +697,68 @@ DrawMark (void)
 
 
 /* ---------------------------------------------------------------------------
+ * notify the GUI that data relating to the crosshair is being changed.
+ *
+ * The argument passed is false to notify "changes are about to happen",
+ * and true to notify "changes have finished".
+ *
+ * Each call with a 'false' parameter must be matched with a following one
+ * with a 'true' parameter. Unmatched 'true' calls are currently not permitted,
+ * but might be allowed in the future.
+ *
+ * GUIs should not complain if they receive extra calls with 'true' as parameter.
+ * They should initiate a redraw of the crosshair attached objects - which may
+ * (if necessary) mean repainting the whole screen if the GUI hasn't tracked the
+ * location of existing attached drawing.
+ */
+void
+notify_crosshair_change (bool changes_complete)
+{
+  if (gui->notify_crosshair_change)
+    gui->notify_crosshair_change (changes_complete);
+}
+
+
+/* ---------------------------------------------------------------------------
+ * notify the GUI that data relating to the mark is being changed.
+ *
+ * The argument passed is false to notify "changes are about to happen",
+ * and true to notify "changes have finished".
+ *
+ * Each call with a 'false' parameter must be matched with a following one
+ * with a 'true' parameter. Unmatched 'true' calls are currently not permitted,
+ * but might be allowed in the future.
+ *
+ * GUIs should not complain if they receive extra calls with 'true' as parameter.
+ * They should initiate a redraw of the mark - which may (if necessary) mean
+ * repainting the whole screen if the GUI hasn't tracked the mark's location.
+ */
+void
+notify_mark_change (bool changes_complete)
+{
+  if (gui->notify_mark_change)
+    gui->notify_mark_change (changes_complete);
+}
+
+
+/* ---------------------------------------------------------------------------
  * switches crosshair on
  */
 void
 CrosshairOn (void)
 {
-  if (!Crosshair.On)
-    {
-      Crosshair.On = true;
-      DrawAttached ();
-      DrawMark ();
-    }
+  if (Crosshair.On)
+    return;
+
+  notify_crosshair_change (false);
+  if (Marked.status)
+    notify_mark_change (false);
+
+  Crosshair.On = true;
+
+  notify_crosshair_change (true);
+  if (Marked.status)
+    notify_mark_change (true);
 }
 
 /* ---------------------------------------------------------------------------
@@ -725,54 +767,63 @@ CrosshairOn (void)
 void
 CrosshairOff (void)
 {
-  if (Crosshair.On)
-    {
-      DrawAttached ();
-      DrawMark ();
-      Crosshair.On = false;
-    }
+  if (!Crosshair.On)
+    return;
+
+  notify_crosshair_change (false);
+  if (Marked.status)
+    notify_mark_change (false);
+
+  Crosshair.On = false;
+
+  notify_crosshair_change (true);
+  if (Marked.status)
+    notify_mark_change (true);
 }
 
 /* ---------------------------------------------------------------------------
- * saves crosshair state (on/off) and hides him
+ * Convenience for plugins using the old {Hide,Restore}Crosshair API.
+ * This links up to notify the GUI of the expected changes using the new APIs.
+ *
+ * Use of this old API is deprecated, as the names don't necessarily reflect
+ * what all GUIs may do in response to the notifications. Keeping these APIs
+ * is aimed at easing transition to the newer API, they will emit a harmless
+ * warning at the time of their first use.
+ *
  */
 void
-HideCrosshair ()
+HideCrosshair (void)
 {
-  /* fprintf(stderr, "HideCrosshair stack %d\n", CrosshairStackLocation); */
-  if (CrosshairStackLocation >= MAX_CROSSHAIRSTACK_DEPTH)
+  static bool warned_old_api = false;
+  if (!warned_old_api)
     {
-      fprintf(stderr, "Error: CrosshairStackLocation overflow\n");
-      return;
+      Message (_("WARNING: A plugin is using the deprecated API HideCrosshair().\n"
+                 "         This API may be removed in a future release of PCB.\n"));
+      warned_old_api = true;
     }
 
-  CrosshairStack[CrosshairStackLocation] = Crosshair.On;
-  CrosshairStackLocation++;
-
-  CrosshairOff ();
+  notify_crosshair_change (false);
+  notify_mark_change (false);
 }
 
-/* ---------------------------------------------------------------------------
- * restores last crosshair state
- */
 void
 RestoreCrosshair (void)
 {
-  /* fprintf(stderr, "RestoreCrosshair stack %d\n", CrosshairStackLocation); */
-  if (CrosshairStackLocation <= 0)
+  static bool warned_old_api = false;
+  if (!warned_old_api)
     {
-      fprintf(stderr, "Error: CrosshairStackLocation underflow\n");
-      return;
+      Message (_("WARNING: A plugin is using the deprecated API RestoreCrosshair().\n"
+                 "         This API may be removed in a future release of PCB.\n"));
+      warned_old_api = true;
     }
 
-  CrosshairStackLocation--;
-
-  if (CrosshairStack[CrosshairStackLocation])
-    CrosshairOn ();
-  else
-    CrosshairOff ();
+  notify_crosshair_change (true);
+  notify_mark_change (true);
 }
 
+/* ---------------------------------------------------------------------------
+ * Returns the square of the given number
+ */
 static double
 square (double x)
 {
@@ -1064,8 +1115,8 @@ MoveCrosshairRelative (LocationType DeltaX, LocationType DeltaY)
 }
 
 /* ---------------------------------------------------------------------------
- * move crosshair absolute switched off if it moved
- * return true if it switched off
+ * move crosshair absolute
+ * return true if the crosshair was moved from its existing position
  */
 bool
 MoveCrosshairAbsolute (LocationType X, LocationType Y)
@@ -1076,13 +1127,14 @@ MoveCrosshairAbsolute (LocationType X, LocationType Y)
   FitCrosshairIntoGrid (X, Y);
   if (Crosshair.X != x || Crosshair.Y != y)
     {
-      /* back up to old position and erase crosshair */
+      /* back up to old position to notify the GUI
+       * (which might want to erase the old crosshair) */
       z = Crosshair.X;
       Crosshair.X = x;
       x = z;
       z = Crosshair.Y;
       Crosshair.Y = y;
-      HideCrosshair ();
+      notify_crosshair_change (false); /* Our caller notifies when it has done */
       /* now move forward again */
       Crosshair.X = x;
       Crosshair.Y = z;
@@ -1109,8 +1161,7 @@ SetCrosshairRange (LocationType MinX, LocationType MinY, LocationType MaxX,
 
 /* ---------------------------------------------------------------------------
  * initializes crosshair stuff
- * clears the struct, allocates to graphical contexts and
- * initializes the stack
+ * clears the struct, allocates to graphical contexts
  */
 void
 InitCrosshair (void)
@@ -1122,9 +1173,6 @@ InitCrosshair (void)
   gui->set_line_cap (Crosshair.GC, Trace_Cap);
   gui->set_line_width (Crosshair.GC, 1);
 
-  /* fake a crosshair off entry on stack */
-  CrosshairStackLocation = 0;
-  CrosshairStack[CrosshairStackLocation++] = true;
   Crosshair.On = true;
 
   /* set initial shape */
diff --git a/src/crosshair.h b/src/crosshair.h
index ff16b1e..efa6679 100644
--- a/src/crosshair.h
+++ b/src/crosshair.h
@@ -46,6 +46,8 @@
 #define	STATE_SECOND	1
 #define	STATE_THIRD		2
 
+void notify_crosshair_change (bool changes_complete);
+void notify_mark_change (bool changes_complete);
 void CrosshairOn (void);
 void CrosshairOff (void);
 void HideCrosshair (void);
diff --git a/src/hid.h b/src/hid.h
index 0a81ddd..36aca75 100644
--- a/src/hid.h
+++ b/src/hid.h
@@ -298,6 +298,8 @@ typedef enum
     /* This may be called to ask the GUI to force a redraw of a given area */
     void (*invalidate_lr) (int left_, int right_, int top_, int bottom_);
     void (*invalidate_all) (void);
+    void (*notify_crosshair_change) (bool changes_complete);
+    void (*notify_mark_change) (bool changes_complete);
 
     /* During redraw or print/export cycles, this is called once per
        layer (or layer group, for copper layers).  If it returns false
diff --git a/src/hid/common/hidnogui.c b/src/hid/common/hidnogui.c
index 1568cd5..84ceda3 100644
--- a/src/hid/common/hidnogui.c
+++ b/src/hid/common/hidnogui.c
@@ -444,6 +444,8 @@ HID hid_nogui = {
   nogui_parse_arguments,
   nogui_invalidate_lr,
   nogui_invalidate_all,
+  0 /* nogui_notify_crosshair_change */ ,
+  0 /* nogui_notify_mark_change */ ,
   nogui_set_layer,
   nogui_make_gc,
   nogui_destroy_gc,
@@ -505,6 +507,8 @@ apply_default_hid (HID * d, HID * s)
   AD (parse_arguments);
   AD (invalidate_lr);
   AD (invalidate_all);
+  AD (notify_crosshair_change);
+  AD (notify_mark_change);
   AD (set_layer);
   AD (make_gc);
   AD (destroy_gc);
diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index fa6dea0..b2bca34 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -34,6 +34,8 @@ typedef struct render_priv {
   GdkGC *mask_gc;
   GdkGC *u_gc;
   GdkGC *grid_gc;
+  int attached_invalidate_depth;
+  int mark_invalidate_depth;
 } render_priv;
 
 
@@ -709,6 +711,7 @@ ghid_invalidate_lr (int left, int right, int top, int bottom)
   ghid_invalidate_all ();
 }
 
+
 void
 ghid_invalidate_all ()
 {
@@ -776,6 +779,61 @@ ghid_invalidate_all ()
   ghid_screen_update ();
 }
 
+
+void
+ghid_notify_crosshair_change (bool changes_complete)
+{
+  render_priv *priv = gport->render_priv;
+
+  /* We sometimes get called before the GUI is up */
+  if (gport->drawing_area == NULL)
+    return;
+
+  if (changes_complete)
+    priv->attached_invalidate_depth --;
+
+  if (priv->attached_invalidate_depth < 0)
+    {
+      fprintf (stderr, "ERROR: Unmatched notify_crosshair_change calls\n");
+      priv->attached_invalidate_depth = 0;
+    }
+
+  if (priv->attached_invalidate_depth == 0)
+    DrawAttached ();
+
+  if (!changes_complete)
+    priv->attached_invalidate_depth ++;
+  else if (gport->drawing_area != NULL)
+    ghid_draw_area_update (gport, NULL);
+}
+
+void
+ghid_notify_mark_change (bool changes_complete)
+{
+  render_priv *priv = gport->render_priv;
+
+  /* We sometimes get called before the GUI is up */
+  if (gport->drawing_area == NULL)
+    return;
+
+  if (changes_complete)
+    priv->mark_invalidate_depth --;
+
+  if (priv->mark_invalidate_depth < 0)
+    {
+      fprintf (stderr, "ERROR: Unmatched notify_mark_change calls\n");
+      priv->mark_invalidate_depth = 0;
+    }
+
+  if (priv->mark_invalidate_depth == 0)
+    DrawMark ();
+
+  if (!changes_complete)
+    priv->mark_invalidate_depth ++;
+  else
+    ghid_draw_area_update (gport, NULL);
+}
+
 static void
 draw_right_cross (GdkGC *xor_gc, gint x, gint y)
 {
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 5af6ed6..a51d167 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -1838,11 +1838,11 @@ ScrollAction (int argc, char **argv, int x, int y)
   else
     AFAIL (scroll);
 
-  HideCrosshair ();
+  notify_crosshair_change (false);
   ghid_port_ranges_pan (dx, dy, TRUE);
   MoveCrosshairRelative (dx, dy);
   AdjustAttachedObjects ();
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
 
   return 0;
 }
@@ -2102,60 +2102,62 @@ hid_gtk_init ()
 
   common_draw_helpers_init (&ghid_hid);
 
-  ghid_hid.struct_size          = sizeof (HID);
-  ghid_hid.name                 = "gtk";
-  ghid_hid.description          = "Gtk - The Gimp Toolkit";
-  ghid_hid.gui                  = 1;
-  ghid_hid.poly_after           = 1;
-
-  ghid_hid.get_export_options   = ghid_get_export_options;
-  ghid_hid.do_export            = ghid_do_export;
-  ghid_hid.parse_arguments      = ghid_parse_arguments;
-  ghid_hid.invalidate_lr        = ghid_invalidate_lr;
-  ghid_hid.invalidate_all       = ghid_invalidate_all;
-  ghid_hid.set_layer            = ghid_set_layer;
-  ghid_hid.make_gc              = ghid_make_gc;
-  ghid_hid.destroy_gc           = ghid_destroy_gc;
-  ghid_hid.use_mask             = ghid_use_mask;
-  ghid_hid.set_color            = ghid_set_color;
-  ghid_hid.set_line_cap         = ghid_set_line_cap;
-  ghid_hid.set_line_width       = ghid_set_line_width;
-  ghid_hid.set_draw_xor         = ghid_set_draw_xor;
-  ghid_hid.set_draw_faded       = ghid_set_draw_faded;
-  ghid_hid.set_line_cap_angle   = ghid_set_line_cap_angle;
-  ghid_hid.draw_line            = ghid_draw_line;
-  ghid_hid.draw_arc             = ghid_draw_arc;
-  ghid_hid.draw_rect            = ghid_draw_rect;
-  ghid_hid.fill_circle          = ghid_fill_circle;
-  ghid_hid.fill_polygon         = ghid_fill_polygon;
-  ghid_hid.fill_rect            = ghid_fill_rect;
-
-  ghid_hid.calibrate            = ghid_calibrate;
-  ghid_hid.shift_is_pressed     = ghid_shift_is_pressed;
-  ghid_hid.control_is_pressed   = ghid_control_is_pressed;
-  ghid_hid.mod1_is_pressed      = ghid_mod1_is_pressed,
-  ghid_hid.get_coords           = ghid_get_coords;
-  ghid_hid.set_crosshair        = ghid_set_crosshair;
-  ghid_hid.add_timer            = ghid_add_timer;
-  ghid_hid.stop_timer           = ghid_stop_timer;
-  ghid_hid.watch_file           = ghid_watch_file;
-  ghid_hid.unwatch_file         = ghid_unwatch_file;
-  ghid_hid.add_block_hook       = ghid_add_block_hook;
-  ghid_hid.stop_block_hook      = ghid_stop_block_hook;
-
-  ghid_hid.log                  = ghid_log;
-  ghid_hid.logv                 = ghid_logv;
-  ghid_hid.confirm_dialog       = ghid_confirm_dialog;
-  ghid_hid.close_confirm_dialog = ghid_close_confirm_dialog;
-  ghid_hid.report_dialog        = ghid_report_dialog;
-  ghid_hid.prompt_for           = ghid_prompt_for;
-  ghid_hid.fileselect           = ghid_fileselect;
-  ghid_hid.attribute_dialog     = ghid_attribute_dialog;
-  ghid_hid.show_item            = ghid_show_item;
-  ghid_hid.beep                 = ghid_beep;
-  ghid_hid.progress             = ghid_progress;
-  ghid_hid.drc_gui              = &ghid_drc_gui,
-  ghid_hid.edit_attributes      = ghid_attributes;
+  ghid_hid.struct_size              = sizeof (HID);
+  ghid_hid.name                     = "gtk";
+  ghid_hid.description              = "Gtk - The Gimp Toolkit";
+  ghid_hid.gui                      = 1;
+  ghid_hid.poly_after               = 1;
+
+  ghid_hid.get_export_options       = ghid_get_export_options;
+  ghid_hid.do_export                = ghid_do_export;
+  ghid_hid.parse_arguments          = ghid_parse_arguments;
+  ghid_hid.invalidate_lr            = ghid_invalidate_lr;
+  ghid_hid.invalidate_all           = ghid_invalidate_all;
+  ghid_hid.notify_crosshair_change  = ghid_notify_crosshair_change;
+  ghid_hid.notify_mark_change       = ghid_notify_mark_change;
+  ghid_hid.set_layer                = ghid_set_layer;
+  ghid_hid.make_gc                  = ghid_make_gc;
+  ghid_hid.destroy_gc               = ghid_destroy_gc;
+  ghid_hid.use_mask                 = ghid_use_mask;
+  ghid_hid.set_color                = ghid_set_color;
+  ghid_hid.set_line_cap             = ghid_set_line_cap;
+  ghid_hid.set_line_width           = ghid_set_line_width;
+  ghid_hid.set_draw_xor             = ghid_set_draw_xor;
+  ghid_hid.set_draw_faded           = ghid_set_draw_faded;
+  ghid_hid.set_line_cap_angle       = ghid_set_line_cap_angle;
+  ghid_hid.draw_line                = ghid_draw_line;
+  ghid_hid.draw_arc                 = ghid_draw_arc;
+  ghid_hid.draw_rect                = ghid_draw_rect;
+  ghid_hid.fill_circle              = ghid_fill_circle;
+  ghid_hid.fill_polygon             = ghid_fill_polygon;
+  ghid_hid.fill_rect                = ghid_fill_rect;
+
+  ghid_hid.calibrate                = ghid_calibrate;
+  ghid_hid.shift_is_pressed         = ghid_shift_is_pressed;
+  ghid_hid.control_is_pressed       = ghid_control_is_pressed;
+  ghid_hid.mod1_is_pressed          = ghid_mod1_is_pressed,
+  ghid_hid.get_coords               = ghid_get_coords;
+  ghid_hid.set_crosshair            = ghid_set_crosshair;
+  ghid_hid.add_timer                = ghid_add_timer;
+  ghid_hid.stop_timer               = ghid_stop_timer;
+  ghid_hid.watch_file               = ghid_watch_file;
+  ghid_hid.unwatch_file             = ghid_unwatch_file;
+  ghid_hid.add_block_hook           = ghid_add_block_hook;
+  ghid_hid.stop_block_hook          = ghid_stop_block_hook;
+
+  ghid_hid.log                      = ghid_log;
+  ghid_hid.logv                     = ghid_logv;
+  ghid_hid.confirm_dialog           = ghid_confirm_dialog;
+  ghid_hid.close_confirm_dialog     = ghid_close_confirm_dialog;
+  ghid_hid.report_dialog            = ghid_report_dialog;
+  ghid_hid.prompt_for               = ghid_prompt_for;
+  ghid_hid.fileselect               = ghid_fileselect;
+  ghid_hid.attribute_dialog         = ghid_attribute_dialog;
+  ghid_hid.show_item                = ghid_show_item;
+  ghid_hid.beep                     = ghid_beep;
+  ghid_hid.progress                 = ghid_progress;
+  ghid_hid.drc_gui                  = &ghid_drc_gui,
+  ghid_hid.edit_attributes          = ghid_attributes;
 
   hid_register_hid (&ghid_hid);
 #include "gtk_lists.h"
diff --git a/src/hid/gtk/gui-misc.c b/src/hid/gtk/gui-misc.c
index 8bda96d..75ba763 100644
--- a/src/hid/gtk/gui-misc.c
+++ b/src/hid/gtk/gui-misc.c
@@ -403,12 +403,12 @@ run_get_location_loop (const gchar * message)
   oldObjState = Crosshair.AttachedObject.State;
   oldLineState = Crosshair.AttachedLine.State;
   oldBoxState = Crosshair.AttachedBox.State;
-  HideCrosshair ();
+  notify_crosshair_change (false);
   Crosshair.AttachedObject.State = STATE_FIRST;
   Crosshair.AttachedLine.State = STATE_FIRST;
   Crosshair.AttachedBox.State = STATE_FIRST;
   ghid_hand_cursor ();
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
 
   /* Stop the top level GMainLoop from getting user input from keyboard
      |  and mouse so we can install our own handlers here.  Also set the
@@ -439,11 +439,11 @@ run_get_location_loop (const gchar * message)
   ghid_interface_input_signals_connect ();	/* return to normal */
   ghid_interface_set_sensitive (TRUE);
 
-  HideCrosshair ();
+  notify_crosshair_change (false);
   Crosshair.AttachedObject.State = oldObjState;
   Crosshair.AttachedLine.State = oldLineState;
   Crosshair.AttachedBox.State = oldBoxState;
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   ghid_restore_cursor ();
 
   ghid_set_status_line_label ();
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index b62ecf0..a0e8eb3 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -232,7 +232,7 @@ ghid_note_event_location (GdkEventButton * ev)
   if (moved)
     {
       AdjustAttachedObjects ();
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
     }
   ghid_set_cursor_position_labels ();
   return moved;
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index 180e58c..5616489 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -493,6 +493,8 @@ void ghid_fill_polygon (hidGC gc, int n_coords, int *x, int *y);
 void ghid_fill_rect (hidGC gc, int x1, int y1, int x2, int y2);
 void ghid_invalidate_lr (int left, int right, int top, int bottom);
 void ghid_invalidate_all ();
+void ghid_notify_crosshair_change (bool changes_complete);
+void ghid_notify_mark_change (bool changes_complete);
 void ghid_show_crosshair (gboolean show);
 void ghid_init_renderer (int *, char ***, GHidPort *);
 void ghid_init_drawing_widget (GtkWidget *widget, GHidPort *);
diff --git a/src/hid/lesstif/main.c b/src/hid/lesstif/main.c
index c1b12d3..b4a49e3 100644
--- a/src/hid/lesstif/main.c
+++ b/src/hid/lesstif/main.c
@@ -1310,12 +1310,12 @@ mod_changed (XKeyEvent * e, int set)
       return;
     }
   in_move_event = 1;
-  HideCrosshair ();
+  notify_crosshair_change (false);
   if (panning)
     Pan (2, e->x, e->y);
   EventMoveCrosshair (Px (e->x), Py (e->y));
   AdjustAttachedObjects ();
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   in_move_event = 0;
 }
 
@@ -1351,7 +1351,7 @@ work_area_input (Widget w, XtPointer v, XEvent * e, Boolean * ctd)
 	}
         ignore_release = 0;
 
-        HideCrosshair ();
+        notify_crosshair_change (false);
         pressed_button = e->xbutton.button;
         mods = ((e->xbutton.state & ShiftMask) ? M_Shift : 0)
           + ((e->xbutton.state & ControlMask) ? M_Ctrl : 0)
@@ -1361,7 +1361,7 @@ work_area_input (Widget w, XtPointer v, XEvent * e, Boolean * ctd)
           + ((e->xbutton.state & Mod1Mask) ? M_Alt : 0);
 #endif
         do_mouse_action(e->xbutton.button, mods);
-        RestoreCrosshair ();
+        notify_crosshair_change (true);
         break;
       }
 
@@ -1371,7 +1371,7 @@ work_area_input (Widget w, XtPointer v, XEvent * e, Boolean * ctd)
         if (e->xbutton.button != pressed_button)
           return;
         lesstif_button_event (w, e);
-        HideCrosshair ();
+        notify_crosshair_change (false);
         pressed_button = 0;
         mods = ((e->xbutton.state & ShiftMask) ? M_Shift : 0)
           + ((e->xbutton.state & ControlMask) ? M_Ctrl : 0)
@@ -1382,7 +1382,7 @@ work_area_input (Widget w, XtPointer v, XEvent * e, Boolean * ctd)
 #endif
           + M_Release;
         do_mouse_action (e->xbutton.button, mods);
-        RestoreCrosshair ();
+        notify_crosshair_change (true);
         break;
       }
 
@@ -2878,6 +2878,42 @@ lesstif_invalidate_all (void)
   lesstif_invalidate_lr (0, PCB->MaxWidth, 0, PCB->MaxHeight);
 }
 
+static void
+lesstif_notify_crosshair_change (bool changes_complete)
+{
+  static int invalidate_depth = 0;
+
+  if (changes_complete)
+    invalidate_depth --;
+
+  if (invalidate_depth < 0)
+    invalidate_depth = 0;
+
+  if (invalidate_depth == 0)
+    DrawAttached ();
+
+  if (!changes_complete)
+    invalidate_depth ++;
+}
+
+static void
+lesstif_notify_mark_change (bool changes_complete)
+{
+  static int invalidate_depth = 0;
+
+  if (changes_complete)
+    invalidate_depth --;
+
+  if (invalidate_depth < 0)
+    invalidate_depth = 0;
+
+  if (invalidate_depth == 0)
+    DrawMark ();
+
+  if (!changes_complete)
+    invalidate_depth ++;
+}
+
 static int
 lesstif_set_layer (const char *name, int group, int empty)
 {
@@ -3803,60 +3839,62 @@ hid_lesstif_init ()
   memset (&lesstif_hid, 0, sizeof (HID));
 
   common_draw_helpers_init (&lesstif_hid);
-
-  lesstif_hid.struct_size           = sizeof (HID);
-  lesstif_hid.name                  = "lesstif";
-  lesstif_hid.description           = "LessTif - a Motif clone for X/Unix";
-  lesstif_hid.gui                   = 1;
-  lesstif_hid.poly_before           = 1;
-
-  lesstif_hid.get_export_options    = lesstif_get_export_options;
-  lesstif_hid.do_export             = lesstif_do_export;
-  lesstif_hid.parse_arguments       = lesstif_parse_arguments;
-  lesstif_hid.invalidate_lr         = lesstif_invalidate_lr;
-  lesstif_hid.invalidate_all        = lesstif_invalidate_all;
-  lesstif_hid.set_layer             = lesstif_set_layer;
-  lesstif_hid.make_gc               = lesstif_make_gc;
-  lesstif_hid.destroy_gc            = lesstif_destroy_gc;
-  lesstif_hid.use_mask              = lesstif_use_mask;
-  lesstif_hid.set_color             = lesstif_set_color;
-  lesstif_hid.set_line_cap          = lesstif_set_line_cap;
-  lesstif_hid.set_line_width        = lesstif_set_line_width;
-  lesstif_hid.set_draw_xor          = lesstif_set_draw_xor;
-  lesstif_hid.set_draw_faded        = lesstif_set_draw_faded;
-  lesstif_hid.set_line_cap_angle    = lesstif_set_line_cap_angle;
-  lesstif_hid.draw_line             = lesstif_draw_line;
-  lesstif_hid.draw_arc              = lesstif_draw_arc;
-  lesstif_hid.draw_rect             = lesstif_draw_rect;
-  lesstif_hid.fill_circle           = lesstif_fill_circle;
-  lesstif_hid.fill_polygon          = lesstif_fill_polygon;
-  lesstif_hid.fill_rect             = lesstif_fill_rect;
-
-  lesstif_hid.calibrate             = lesstif_calibrate;
-  lesstif_hid.shift_is_pressed      = lesstif_shift_is_pressed;
-  lesstif_hid.control_is_pressed    = lesstif_control_is_pressed;
-  lesstif_hid.mod1_is_pressed       = lesstif_mod1_is_pressed;
-  lesstif_hid.get_coords            = lesstif_get_coords;
-  lesstif_hid.set_crosshair         = lesstif_set_crosshair;
-  lesstif_hid.add_timer             = lesstif_add_timer;
-  lesstif_hid.stop_timer            = lesstif_stop_timer;
-  lesstif_hid.watch_file            = lesstif_watch_file;
-  lesstif_hid.unwatch_file          = lesstif_unwatch_file;
-  lesstif_hid.add_block_hook        = lesstif_add_block_hook;
-  lesstif_hid.stop_block_hook       = lesstif_stop_block_hook;
-
-  lesstif_hid.log                   = lesstif_log;
-  lesstif_hid.logv                  = lesstif_logv;
-  lesstif_hid.confirm_dialog        = lesstif_confirm_dialog;
-  lesstif_hid.close_confirm_dialog  = lesstif_close_confirm_dialog;
-  lesstif_hid.report_dialog         = lesstif_report_dialog;
-  lesstif_hid.prompt_for            = lesstif_prompt_for;
-  lesstif_hid.fileselect            = lesstif_fileselect;
-  lesstif_hid.attribute_dialog      = lesstif_attribute_dialog;
-  lesstif_hid.show_item             = lesstif_show_item;
-  lesstif_hid.beep                  = lesstif_beep;
-  lesstif_hid.progress              = lesstif_progress;
-  lesstif_hid.edit_attributes       = lesstif_attributes_dialog;
+  lesstif_hid.struct_size             = sizeof (HID);
+
+  lesstif_hid.name                    = "lesstif";
+  lesstif_hid.description             = "LessTif - a Motif clone for X/Unix";
+  lesstif_hid.gui                     = 1;
+  lesstif_hid.poly_before             = 1;
+
+  lesstif_hid.get_export_options      = lesstif_get_export_options;
+  lesstif_hid.do_export               = lesstif_do_export;
+  lesstif_hid.parse_arguments         = lesstif_parse_arguments;
+  lesstif_hid.invalidate_lr           = lesstif_invalidate_lr;
+  lesstif_hid.invalidate_all          = lesstif_invalidate_all;
+  lesstif_hid.notify_crosshair_change = lesstif_notify_crosshair_change;
+  lesstif_hid.notify_mark_change      = lesstif_notify_mark_change;
+  lesstif_hid.set_layer               = lesstif_set_layer;
+  lesstif_hid.make_gc                 = lesstif_make_gc;
+  lesstif_hid.destroy_gc              = lesstif_destroy_gc;
+  lesstif_hid.use_mask                = lesstif_use_mask;
+  lesstif_hid.set_color               = lesstif_set_color;
+  lesstif_hid.set_line_cap            = lesstif_set_line_cap;
+  lesstif_hid.set_line_width          = lesstif_set_line_width;
+  lesstif_hid.set_draw_xor            = lesstif_set_draw_xor;
+  lesstif_hid.set_draw_faded          = lesstif_set_draw_faded;
+  lesstif_hid.set_line_cap_angle      = lesstif_set_line_cap_angle;
+  lesstif_hid.draw_line               = lesstif_draw_line;
+  lesstif_hid.draw_arc                = lesstif_draw_arc;
+  lesstif_hid.draw_rect               = lesstif_draw_rect;
+  lesstif_hid.fill_circle             = lesstif_fill_circle;
+  lesstif_hid.fill_polygon            = lesstif_fill_polygon;
+  lesstif_hid.fill_rect               = lesstif_fill_rect;
+
+  lesstif_hid.calibrate               = lesstif_calibrate;
+  lesstif_hid.shift_is_pressed        = lesstif_shift_is_pressed;
+  lesstif_hid.control_is_pressed      = lesstif_control_is_pressed;
+  lesstif_hid.mod1_is_pressed         = lesstif_mod1_is_pressed;
+  lesstif_hid.get_coords              = lesstif_get_coords;
+  lesstif_hid.set_crosshair           = lesstif_set_crosshair;
+  lesstif_hid.add_timer               = lesstif_add_timer;
+  lesstif_hid.stop_timer              = lesstif_stop_timer;
+  lesstif_hid.watch_file              = lesstif_watch_file;
+  lesstif_hid.unwatch_file            = lesstif_unwatch_file;
+  lesstif_hid.add_block_hook          = lesstif_add_block_hook;
+  lesstif_hid.stop_block_hook         = lesstif_stop_block_hook;
+
+  lesstif_hid.log                     = lesstif_log;
+  lesstif_hid.logv                    = lesstif_logv;
+  lesstif_hid.confirm_dialog          = lesstif_confirm_dialog;
+  lesstif_hid.close_confirm_dialog    = lesstif_close_confirm_dialog;
+  lesstif_hid.report_dialog           = lesstif_report_dialog;
+  lesstif_hid.prompt_for              = lesstif_prompt_for;
+  lesstif_hid.fileselect              = lesstif_fileselect;
+  lesstif_hid.attribute_dialog        = lesstif_attribute_dialog;
+  lesstif_hid.show_item               = lesstif_show_item;
+  lesstif_hid.beep                    = lesstif_beep;
+  lesstif_hid.progress                = lesstif_progress;
+  lesstif_hid.edit_attributes         = lesstif_attributes_dialog;
 
   hid_register_hid (&lesstif_hid);
 #include "lesstif_lists.h"
diff --git a/src/misc.c b/src/misc.c
index d63aef1..5bea138 100644
--- a/src/misc.c
+++ b/src/misc.c
@@ -705,15 +705,11 @@ CenterDisplay (LocationType X, LocationType Y, bool Delta)
   double save_grid = PCB->Grid;
   PCB->Grid = 1;
   if (Delta)
-    {
-      MoveCrosshairRelative (X, Y);
-    }
+    MoveCrosshairRelative (X, Y);
   else
     {
       if (MoveCrosshairAbsolute (X, Y))
-        {
-          RestoreCrosshair ();
-        }
+        notify_crosshair_change (true);
     }
   gui->set_crosshair (Crosshair.X, Crosshair.Y, HID_SC_WARP_POINTER);
   PCB->Grid = save_grid;
diff --git a/src/set.c b/src/set.c
index 90db719..c77129e 100644
--- a/src/set.c
+++ b/src/set.c
@@ -244,7 +244,7 @@ SetMode (int Mode)
   if (recursing)
     return;
   recursing = true;
-  HideCrosshair ();
+  notify_crosshair_change (false);
   addedLines = 0;
   Crosshair.AttachedObject.Type = NO_TYPE;
   Crosshair.AttachedObject.State = STATE_FIRST;
@@ -314,7 +314,7 @@ SetMode (int Mode)
    * may have changed
    */
   MoveCrosshairRelative (0, 0);
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
 }
 
 void
@@ -342,20 +342,20 @@ SetLocalRef (LocationType X, LocationType Y, bool Showing)
 
   if (Showing)
     {
-      HideCrosshair ();
+      notify_mark_change (false);
       if (count == 0)
 	old = Marked;
       Marked.X = X;
       Marked.Y = Y;
       Marked.status = true;
       count++;
-      RestoreCrosshair ();
+      notify_mark_change (true);
     }
   else if (count > 0)
     {
-      HideCrosshair ();
+      notify_mark_change (false);
       count = 0;
       Marked = old;
-      RestoreCrosshair ();
+      notify_mark_change (true);
     }
 }

Bottom: cbc44ef59750f921bd9632c98e8a6f3f26092205
Top:    e5e75aa456e0b1544b24ec203efb173ceab54b85
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-04-21 01:38:14 +0100

Refresh of hid-move-non-pcb-specific-draw

---

diff --git a/src/hid.h b/src/hid.h
index 0a81ddd..1ccde0e 100644
--- a/src/hid.h
+++ b/src/hid.h
@@ -230,6 +230,77 @@ typedef enum
     int (*throw_drc_dialog) (void);
   } HID_DRC_GUI;
 
+/* Low leve drawing API */
+  typedef struct
+  {
+    /* Drawing Functions.  Coordinates and distances are ALWAYS in PCB's
+       default coordinates (1/100 mil at the time this comment was
+       written).  Angles are always in degrees, with 0 being "right"
+       (positive X) and 90 being "up" (positive Y).  */
+
+    /* Make an empty graphics context.  */
+      hidGC (*make_gc) (void);
+    void (*destroy_gc) (hidGC gc_);
+
+    /* Special note about the "erase" color: To use this color, you must
+       use this function to tell the HID when you're using it.  At the
+       beginning of a layer redraw cycle (i.e. after set_layer), call
+       use_mask() to redirect output to a buffer.  Draw to the buffer
+       (using regular HID calls) using regular and "erase" colors.  Then
+       call use_mask(HID_MASK_OFF) to flush the buffer to the HID.  If
+       you use the "erase" color when use_mask is disabled, it simply
+       draws in the background color.  */
+    void (*use_mask) (int use_it_);
+    /* Flush the buffer and return to non-mask operation.  */
+#define HID_MASK_OFF 0
+    /* Polygons being drawn before clears.  */
+#define HID_MASK_BEFORE 1
+    /* Clearances being drawn.  */
+#define HID_MASK_CLEAR 2
+    /* Polygons being drawn after clears.  */
+#define HID_MASK_AFTER 3
+    /* Set to do live drawing on the screen   */
+#define HID_LIVE_DRAWING 4
+    /* stop live drawing on the screen   */
+#define HID_LIVE_DRAWING_OFF 5
+    /* flush any queued drawing   */
+#define HID_FLUSH_DRAW_Q 6
+
+    /* Set a color.  Names can be like "red" or "#rrggbb" or special
+       names like "erase".  *Always* use the "erase" color for removing
+       ink (like polygon reliefs or thermals), as you cannot rely on
+       knowing the background color or special needs of the HID.  Always
+       use the "drill" color to draw holes.  You may assume this is
+       cheap enough to call inside the redraw callback, but not cheap
+       enough to call for each item drawn. */
+    void (*set_color) (hidGC gc_, const char *name_);
+
+    /* Set the line style.  While calling this is cheap, calling it with
+       different values each time may be expensive, so grouping items by
+       line style is helpful.  */
+    void (*set_line_cap) (hidGC gc_, EndCapStyle style_);
+    void (*set_line_width) (hidGC gc_, int width_);
+    void (*set_draw_xor) (hidGC gc_, int xor_);
+    /* Blends 20% or so color with 80% background.  Only used for
+       assembly drawings so far. */
+    void (*set_draw_faded) (hidGC gc_, int faded_);
+
+    /* When you pass the same x,y twice to draw_line, the end caps are
+       drawn as if the "line" were parallel to the line defined by these
+       coordinates.  Use this for rotating non-round pads.  */
+    void (*set_line_cap_angle) (hidGC gc_, int x1_, int y1_, int x2_, int y2_);
+
+    /* The usual drawing functions.  "draw" means to use segments of the
+       given width, whereas "fill" means to fill to a zero-width
+       outline.  */
+    void (*draw_line) (hidGC gc_, int x1_, int y1_, int x2_, int y2_);
+    void (*draw_arc) (hidGC gc_, int cx_, int cy_, int xradius_, int yradius_, int start_angle_, int delta_angle_);
+    void (*draw_rect) (hidGC gc_, int x1_, int y1_, int x2_, int y2_);
+    void (*fill_circle) (hidGC gc_, int cx_, int cy_, int radius_);
+    void (*fill_polygon) (hidGC gc_, int n_coords_, int *x_, int *y_);
+    void (*fill_rect) (hidGC gc_, int x1_, int y1_, int x2_, int y2_);
+  } HID_DRAW_API;
+
 
 /* This is the main HID structure.  */
   typedef struct
@@ -312,72 +383,7 @@ typedef enum
        layer is empty, if zero it may be non-empty.  */
     int (*set_layer) (const char *name_, int group_, int _empty);
 
-    /* Drawing Functions.  Coordinates and distances are ALWAYS in PCB's
-       default coordinates (1/100 mil at the time this comment was
-       written).  Angles are always in degrees, with 0 being "right"
-       (positive X) and 90 being "up" (positive Y).  */
-
-    /* Make an empty graphics context.  */
-      hidGC (*make_gc) (void);
-    void (*destroy_gc) (hidGC gc_);
-
-    /* Special note about the "erase" color: To use this color, you must
-       use this function to tell the HID when you're using it.  At the
-       beginning of a layer redraw cycle (i.e. after set_layer), call
-       use_mask() to redirect output to a buffer.  Draw to the buffer
-       (using regular HID calls) using regular and "erase" colors.  Then
-       call use_mask(HID_MASK_OFF) to flush the buffer to the HID.  If
-       you use the "erase" color when use_mask is disabled, it simply
-       draws in the background color.  */
-    void (*use_mask) (int use_it_);
-    /* Flush the buffer and return to non-mask operation.  */
-#define HID_MASK_OFF 0
-    /* Polygons being drawn before clears.  */
-#define HID_MASK_BEFORE 1
-    /* Clearances being drawn.  */
-#define HID_MASK_CLEAR 2
-    /* Polygons being drawn after clears.  */
-#define HID_MASK_AFTER 3
-    /* Set to do live drawing on the screen   */
-#define HID_LIVE_DRAWING 4
-    /* stop live drawing on the screen   */
-#define HID_LIVE_DRAWING_OFF 5
-    /* flush any queued drawing   */
-#define HID_FLUSH_DRAW_Q 6
-
-    /* Set a color.  Names can be like "red" or "#rrggbb" or special
-       names like "erase".  *Always* use the "erase" color for removing
-       ink (like polygon reliefs or thermals), as you cannot rely on
-       knowing the background color or special needs of the HID.  Always
-       use the "drill" color to draw holes.  You may assume this is
-       cheap enough to call inside the redraw callback, but not cheap
-       enough to call for each item drawn. */
-    void (*set_color) (hidGC gc_, const char *name_);
-
-    /* Set the line style.  While calling this is cheap, calling it with
-       different values each time may be expensive, so grouping items by
-       line style is helpful.  */
-    void (*set_line_cap) (hidGC gc_, EndCapStyle style_);
-    void (*set_line_width) (hidGC gc_, int width_);
-    void (*set_draw_xor) (hidGC gc_, int xor_);
-    /* Blends 20% or so color with 80% background.  Only used for
-       assembly drawings so far. */
-    void (*set_draw_faded) (hidGC gc_, int faded_);
-
-    /* When you pass the same x,y twice to draw_line, the end caps are
-       drawn as if the "line" were parallel to the line defined by these
-       coordinates.  Use this for rotating non-round pads.  */
-    void (*set_line_cap_angle) (hidGC gc_, int x1_, int y1_, int x2_, int y2_);
-
-    /* The usual drawing functions.  "draw" means to use segments of the
-       given width, whereas "fill" means to fill to a zero-width
-       outline.  */
-    void (*draw_line) (hidGC gc_, int x1_, int y1_, int x2_, int y2_);
-    void (*draw_arc) (hidGC gc_, int cx_, int cy_, int xradius_, int yradius_,
-		      int start_angle_, int delta_angle_);
-    void (*draw_rect) (hidGC gc_, int x1_, int y1_, int x2_, int y2_);
-    void (*fill_circle) (hidGC gc_, int cx_, int cy_, int radius_);
-    void (*fill_polygon) (hidGC gc_, int n_coords_, int *x_, int *y_);
+    HID_DRAW_API *draw;
     void (*fill_pcb_polygon) (hidGC gc_, PolygonType *poly,
                               const BoxType *clip_box);
     void (*thindraw_pcb_polygon) (hidGC gc_, PolygonType *poly,
@@ -386,7 +392,6 @@ typedef enum
     void (*thindraw_pcb_pad) (hidGC gc_, PadType *pad, bool clip, bool mask);
     void (*fill_pcb_pv) (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool mask);
     void (*thindraw_pcb_pv) (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool mask);
-    void (*fill_rect) (hidGC gc_, int x1_, int y1_, int x2_, int y2_);
 
 
     /* This is for the printer.  If you call this for the GUI, xval and

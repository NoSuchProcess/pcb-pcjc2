Bottom: a96a551f3c2c73b2bfda2d9b970b709f162e8542
Top:    39a94cd074f2d24507b74b4bb606a2264527799a
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-11-19 00:30:54 +0000

Refresh of play-with-perspective

---

diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index a2b1d2a..911099f 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -894,12 +894,10 @@ hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box)
 
   glPushAttrib (GL_STENCIL_BUFFER_BIT);                   // Save the write mask etc.. for final restore
   glPushAttrib (GL_STENCIL_BUFFER_BIT |                   // Resave the stencil write-mask etc.., and
-                GL_COLOR_BUFFER_BIT |                     // the colour buffer write mask etc.., and
-                GL_DEPTH_BUFFER_BIT);                     // the depth write-mask etc.. for part way restore
+                GL_COLOR_BUFFER_BIT);                     // the colour buffer write mask etc.. for part way restore
   glStencilMask (stencil_bit);                            // Only write to our stencil bit
   glStencilFunc (GL_ALWAYS, stencil_bit, stencil_bit);    // Always pass stencil test, ref value is our bit
   glColorMask (0, 0, 0, 0);                               // Disable writting in color buffer
-  glDepthMask (GL_FALSE);
 
   /* It will already be setup like this (so avoid prodding the state-machine):
    * glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index ca42744..c4760f5 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -325,323 +325,6 @@ ghid_draw_grid (BoxTypePtr drawn_area)
   glEnable (GL_STENCIL_TEST);
 }
 
-static void
-setup_resistor_texture ()
-{
-  GLuint texture;
-  GLfloat tex_data[] = {0.5, 0.5, 1.0,
-                        0.5, 0.5, 1.0,
-                        0.5, 0.5, 1.0,
-                        0.0, 0.0, 0.0,
-                        0.5, 0.5, 1.0,
-                        1.0, 0.0, 0.0,
-                        0.5, 0.5, 1.0,
-                        0.0, 1.0, 0.0,
-                        0.5, 0.5, 1.0,
-                        0.5, 0.5, 1.0};
-
-  glGenTextures (1, &texture);
-  glBindTexture (GL_TEXTURE_1D, texture);
-  glTexImage1D (GL_TEXTURE_1D, 0, GL_RGB, 10, 1, GL_RGB, GL_FLOAT, tex_data);
-}
-
-#define NUM_RESISTOR_STRIPS 30
-#define NUM_PIN_RINGS 15
-#define MIL_TO_INTERNAL 100.
-static void
-ghid_draw_acy_resistor (ElementType *element)
-{
-
-  float center_x, center_y, surface_depth;
-  float angle;
-
-  int strip;
-  int no_strips = NUM_RESISTOR_STRIPS;
-  int ring;
-  int no_rings = NUM_PIN_RINGS;
-  int end;
-
-  GLint sp;
-
-  /* XXX: Hard-coded magic */
-  float resistor_bulge_radius = 45. * MIL_TO_INTERNAL;
-  float resistor_barrel_radius = 35. * MIL_TO_INTERNAL;
-  float resistor_pin_radius = 12. * MIL_TO_INTERNAL;
-  float resistor_bulge_width = 65. * MIL_TO_INTERNAL;
-  float resistor_bulge_offset = 15. * MIL_TO_INTERNAL;
-  float resistor_pin_spacing = 400. * MIL_TO_INTERNAL;
-
-  float pin_penetration_depth = 30. * MIL_TO_INTERNAL + BOARD_THICKNESS;
-
-  float resistor_pin_bend_radius = resistor_bulge_radius;
-  float resistor_width = resistor_pin_spacing - 2. * resistor_pin_bend_radius;
-
-  if (FRONT (element))
-    surface_depth = compute_depth (0); /* XXX: FIXME */
-  else
-    surface_depth = compute_depth (max_copper_layer - 1); /* XXX: FIXME */
-
-  center_x = (element->Pin[0].X + element->Pin[1].X) / 2.;
-  center_y = (element->Pin[0].Y + element->Pin[1].Y) / 2.;
-  angle = atan2f (element->Pin[1].Y - element->Pin[0].Y,
-                  element->Pin[1].X - element->Pin[0].X);
-
-  /* TRANSFORM MATRIX */
-  glPushMatrix ();
-  glTranslatef (center_x, center_y, surface_depth + resistor_pin_bend_radius);
-  glRotatef (angle * 180. / M_PI + 90, 0., 0., 1.);
-  glRotatef (90, 1., 0., 0.);
-
-  /* TEXTURE SETUP */
-  glGetIntegerv (GL_CURRENT_PROGRAM, &sp);
-  glUseProgram (0);
-  setup_resistor_texture ();
-  glEnable (GL_TEXTURE_1D);
-
-  glTexEnvf (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
-  glTexParameterf (GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
-  glTexParameterf (GL_TEXTURE_1D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
-  glTexParameterf (GL_TEXTURE_1D, GL_TEXTURE_WRAP_S, GL_CLAMP);
-
-  /* COLOR / MATERIAL SETUP */
-  glColorMaterial (GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
-  glEnable (GL_COLOR_MATERIAL);
-
-  glPushAttrib (GL_CURRENT_BIT);
-  glColor4f (1., 1., 1., 1.);
-
-  if (1) {
-    GLfloat emission[] = {0.0f, 0.0f, 0.0f, 1.0f};
-    GLfloat specular[] = {0.0f, 0.0f, 0.0f, 1.0f};
-    glMaterialfv (GL_FRONT_AND_BACK, GL_EMISSION, emission);
-    glMaterialfv (GL_FRONT_AND_BACK, GL_SPECULAR, specular);
-  }
-
-  glBegin (GL_TRIANGLE_STRIP);
-
-  for (strip = 0; strip < no_strips; strip++) {
-
-    float angle_strip_edge1 = strip * 2. * M_PI / no_strips;
-    float angle_strip_edge2 = (strip + 1) * 2. * M_PI / no_strips;
-
-    float x_strip_edge1 = cosf (angle_strip_edge1);
-    float y_strip_edge1 = sinf (angle_strip_edge1);
-    float x_strip_edge2 = cosf (angle_strip_edge2);
-    float y_strip_edge2 = sinf (angle_strip_edge2);
-    float z;
-    float r;
-
-    z = -resistor_width / 2.;
-    r = resistor_pin_radius;
-    /* repeat first vertex */
-    glTexCoord1f (0.);
-    glNormal3f (0., 0., -1.);
-    glVertex3f (r * x_strip_edge1, r * y_strip_edge1, z);
-    glTexCoord1f (0.);
-    glNormal3f (0., 0., -1.);
-    glVertex3f (r * x_strip_edge1, r * y_strip_edge1, z);
-    glTexCoord1f (0.);
-    glNormal3f (0., 0., -1.);
-    glVertex3f (r * x_strip_edge2, r * y_strip_edge2, z);
-
-    z = -resistor_width / 2. + resistor_bulge_offset;
-    r = resistor_barrel_radius;
-    glTexCoord1f (0.);
-    glNormal3f (x_strip_edge1, y_strip_edge1, 0.);
-    glVertex3f (r * x_strip_edge1, r * y_strip_edge1, z);
-    glTexCoord1f (0.);
-    glNormal3f (x_strip_edge2, y_strip_edge2, 0.);
-    glVertex3f (r * x_strip_edge2, r * y_strip_edge2, z);
-
-    z = -resistor_width / 2. + resistor_bulge_offset + resistor_bulge_width * 1. / 4.;
-    r = resistor_bulge_radius;
-    glTexCoord1f (0.);
-    glNormal3f (x_strip_edge1, y_strip_edge1, 0.);
-    glVertex3f (r * x_strip_edge1, r * y_strip_edge1, z);
-    glTexCoord1f (0.);
-    glNormal3f (x_strip_edge2, y_strip_edge2, 0.);
-    glVertex3f (r * x_strip_edge2, r * y_strip_edge2, z);
-
-    z = -resistor_width / 2. + resistor_bulge_offset + resistor_bulge_width * 3. / 4.;
-    r = resistor_bulge_radius;
-    glTexCoord1f (0.);
-//    glNormal3f (x_strip_edge1, y_strip_edge1, 0.);
-    glNormal3f (0., 0., 1.);
-    glVertex3f (r * x_strip_edge1, r * y_strip_edge1, z);
-    glTexCoord1f (0.);
-//    glNormal3f (x_strip_edge2, y_strip_edge2, 0.);
-    glNormal3f (0., 0., 1.);
-    glVertex3f (r * x_strip_edge2, r * y_strip_edge2, z);
-
-    z = -resistor_width / 2. + resistor_bulge_offset + resistor_bulge_width;
-    r = resistor_barrel_radius;
-    glTexCoord1f (0.);
-    glNormal3f (x_strip_edge1, y_strip_edge1, 0.);
-    glVertex3f (r * x_strip_edge1, r * y_strip_edge1, z);
-    glTexCoord1f (0.);
-    glNormal3f (x_strip_edge2, y_strip_edge2, 0.);
-    glVertex3f (r * x_strip_edge2, r * y_strip_edge2, z);
-
-    z = resistor_width / 2. - resistor_bulge_offset - resistor_bulge_width;
-    r = resistor_barrel_radius;
-    glTexCoord1f (1.);
-    glNormal3f (x_strip_edge1, y_strip_edge1, 0.);
-    glVertex3f (r * x_strip_edge1, r * y_strip_edge1, z);
-    glTexCoord1f (1.);
-    glNormal3f (x_strip_edge2, y_strip_edge2, 0.);
-    glVertex3f (r * x_strip_edge2, r * y_strip_edge2, z);
-
-    z = resistor_width / 2. - resistor_bulge_offset - resistor_bulge_width * 3. / 4.;
-    r = resistor_bulge_radius;
-    glTexCoord1f (1.);
-//    glNormal3f (x_strip_edge1, y_strip_edge1, 0.);
-    glNormal3f (0., 0., -1.);
-    glVertex3f (r * x_strip_edge1, r * y_strip_edge1, z);
-    glTexCoord1f (1.);
-//    glNormal3f (x_strip_edge2, y_strip_edge2, 0.);
-    glNormal3f (0., 0., -1.);
-    glVertex3f (r * x_strip_edge2, r * y_strip_edge2, z);
-
-    z = resistor_width / 2. - resistor_bulge_offset - resistor_bulge_width * 1. / 4.;
-    r = resistor_bulge_radius;
-    glTexCoord1f (1.);
-    glNormal3f (x_strip_edge1, y_strip_edge1, 0.);
-    glVertex3f (r * x_strip_edge1, r * y_strip_edge1, z);
-    glTexCoord1f (1.);
-    glNormal3f (x_strip_edge2, y_strip_edge2, 0.);
-    glVertex3f (r * x_strip_edge2, r * y_strip_edge2, z);
-
-    z = resistor_width / 2. - resistor_bulge_offset;
-    r = resistor_barrel_radius;
-    glTexCoord1f (1.);
-    glNormal3f (x_strip_edge1, y_strip_edge1, 0.);
-    glVertex3f (r * x_strip_edge1, r * y_strip_edge1, z);
-    glTexCoord1f (1.);
-    glNormal3f (x_strip_edge2, y_strip_edge2, 0.);
-    glVertex3f (r * x_strip_edge2, r * y_strip_edge2, z);
-
-    z = resistor_width / 2.;
-    r = resistor_pin_radius;
-    glTexCoord1f (1.);
-    glNormal3f (0., 0., 1.);
-    glVertex3f (r * x_strip_edge1, r * y_strip_edge1, z);
-    glTexCoord1f (1.);
-    glNormal3f (0., 0., 1.);
-    glVertex3f (r * x_strip_edge2, r * y_strip_edge2, z);
-    /* repeat last vertex */
-    glTexCoord1f (1.);
-    glNormal3f (0., 0., 1.);
-    glVertex3f (r * x_strip_edge2, r * y_strip_edge2, z);
-
-  }
-
-  glEnd ();
-
-  glDisable (GL_TEXTURE_1D);
-
-  glColor4f (0.5, 0.5, 0.5, 1.);
-
-  if (1) {
-    GLfloat specular[] = {0.5, 0.5, 0.5, 1.0};
-    GLfloat shininess = 5.;
-    glMaterialfv (GL_FRONT_AND_BACK, GL_SPECULAR, specular);
-    glMaterialfv (GL_FRONT_AND_BACK, GL_SHININESS, &shininess);
-  }
-
-  for (end = 0; end < 2; end++) {
-    float end_sign = (end == 0) ? 1. : -1.;
-
-    for (ring = 0; ring < no_rings; ring++) {
-
-      float angle_ring_edge1 = ring * M_PI / 2. / no_rings + ((end == 0) ? 0. : -M_PI / 2.);
-      float angle_ring_edge2 = (ring + 1) * M_PI / 2. / no_rings + ((end == 0) ? 0. : -M_PI / 2.);
-      float y_strip_edge1 = cosf (angle_ring_edge1);
-      float z_strip_edge1 = sinf (angle_ring_edge1);
-      float y_strip_edge2 = cosf (angle_ring_edge2);
-      float z_strip_edge2 = sinf (angle_ring_edge2);
-      float r = resistor_pin_bend_radius;
-
-      glBegin (GL_TRIANGLE_STRIP);
-
-      /* NB: We wrap back around to complete the last segment, so in effect
-       *     we draw no_strips + 1 strips.
-       */
-      for (strip = 0; strip < no_strips + 1; strip++) {
-        float strip_angle = strip * 2. * M_PI / no_strips;
-
-        float x1 = resistor_pin_radius * cos (strip_angle);
-        float y1 = resistor_pin_radius * sin (strip_angle) * y_strip_edge1 + r * y_strip_edge1 - r;
-        float z1 = resistor_pin_radius * sin (strip_angle) * z_strip_edge1 + r * z_strip_edge1 + resistor_width / 2. * end_sign;
-
-        float x2 = resistor_pin_radius * cos (strip_angle);
-        float y2 = resistor_pin_radius * sin (strip_angle) * y_strip_edge2 + r * y_strip_edge2 - r;
-        float z2 = resistor_pin_radius * sin (strip_angle) * z_strip_edge2 + r * z_strip_edge2 + resistor_width / 2. * end_sign;
-
-        glNormal3f (cos (strip_angle), sin (strip_angle) * y_strip_edge1, sin (strip_angle) * z_strip_edge1);
-        glVertex3f (x1, y1, z1);
-        glNormal3f (cos (strip_angle), sin (strip_angle) * y_strip_edge2, sin (strip_angle) * z_strip_edge2);
-        glVertex3f (x2, y2, z2);
-      }
-      glEnd ();
-    }
-
-    if (1) {
-      float r = resistor_pin_bend_radius;
-      glBegin (GL_TRIANGLE_STRIP);
-
-      /* NB: We wrap back around to complete the last segment, so in effect
-       *     we draw no_strips + 1 strips.
-       */
-      for (strip = 0; strip < no_strips + 1; strip++) {
-        float strip_angle = strip * 2. * M_PI / no_strips;
-
-        float x1 = resistor_pin_radius * cos (strip_angle);
-        float y1 = -r;
-        float z1 = resistor_pin_radius * sin (strip_angle) + (r + resistor_width / 2.) * end_sign;
-
-        float x2 = resistor_pin_radius * cos (strip_angle);
-        float y2 = -r - pin_penetration_depth;
-        float z2 = resistor_pin_radius * sin (strip_angle) + (r + resistor_width / 2.) * end_sign;
-
-        glNormal3f (cos (strip_angle), 0., sin (strip_angle));
-        glVertex3f (x1, y1, z1);
-        glNormal3f (cos (strip_angle), 0., sin (strip_angle));
-        glVertex3f (x2, y2, z2);
-      }
-      glEnd ();
-    }
-
-    if (1) {
-      float r = resistor_pin_bend_radius;
-      glBegin (GL_TRIANGLE_FAN);
-
-      glNormal3f (0, 0., -1.);
-      glVertex3f (0, -r - pin_penetration_depth - resistor_pin_radius / 2., (r + resistor_width / 2.) * end_sign);
-
-      /* NB: We wrap back around to complete the last segment, so in effect
-       *     we draw no_strips + 1 strips.
-       */
-      for (strip = no_strips + 1; strip > 0; strip--) {
-        float strip_angle = strip * 2. * M_PI / no_strips;
-
-        float x = resistor_pin_radius * cos (strip_angle);
-        float y = -r - pin_penetration_depth;
-        float z = resistor_pin_radius * sin (strip_angle) + (r + resistor_width / 2.) * end_sign;
-
-        glNormal3f (cos (strip_angle), 0., sin (strip_angle));
-        glVertex3f (x, y, z);
-      }
-      glEnd ();
-    }
-  }
-
-  glPopAttrib ();
-  glPopMatrix ();
-  glUseProgram (sp);
-
-  glDisable (GL_COLOR_MATERIAL);
-}
-
 #if 0
 static void
 ghid_draw_bg_image (void)
@@ -734,7 +417,6 @@ ghid_use_mask (int use_it)
     case HID_MASK_BEFORE:
       /* Write '1' to the stencil buffer where the solder-mask is drawn. */
       glColorMask (0, 0, 0, 0);                   // Disable writting in color buffer
-      glDepthMask (GL_FALSE);
       glEnable (GL_STENCIL_TEST);                 // Enable Stencil test
       stencil_bit = hidgl_assign_clear_stencil_bit();       // Get a new (clean) bitplane to stencil with
       glStencilFunc (GL_ALWAYS, stencil_bit, stencil_bit);  // Always pass stencil test, write stencil_bit
@@ -751,7 +433,6 @@ ghid_use_mask (int use_it)
     case HID_MASK_AFTER:
       /* Drawing operations as masked to areas where the stencil buffer is '1' */
       glColorMask (1, 1, 1, 1);                   // Enable drawing of r, g, b & a
-      glDepthMask (GL_TRUE);
       glStencilFunc (GL_LEQUAL, stencil_bit, stencil_bit);   // Draw only where our bit of the stencil buffer is set
       glStencilOp (GL_KEEP, GL_KEEP, GL_KEEP);    // Stencil buffer read only
       break;
@@ -1312,7 +993,7 @@ ghid_init_renderer (int *argc, char ***argv, GHidPort *port)
   /* setup GL-context */
   priv->glconfig = gdk_gl_config_new_by_mode (GDK_GL_MODE_RGBA    |
                                               GDK_GL_MODE_STENCIL |
-                                              GDK_GL_MODE_DEPTH   |
+                                           // GDK_GL_MODE_DEPTH   |
                                               GDK_GL_MODE_DOUBLE);
   if (!priv->glconfig)
     {
@@ -1788,9 +1469,8 @@ DrawLayerGroup (int group, const BoxType * screen)
       if (rv) {
         /* Mask out drilled holes on this layer */
         hidgl_flush_triangles (&buffer);
-        glPushAttrib (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+        glPushAttrib (GL_COLOR_BUFFER_BIT);
         glColorMask (0, 0, 0, 0);
-        glDepthMask (GL_FALSE);
         gui->set_color (Output.bgGC, PCB->MaskColor);
         if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
         if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
@@ -1811,9 +1491,8 @@ DrawLayerGroup (int group, const BoxType * screen)
 
         if (rv) {
           hidgl_flush_triangles (&buffer);
-          glPushAttrib (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+          glPushAttrib (GL_COLOR_BUFFER_BIT);
           glColorMask (0, 0, 0, 0);
-          glDepthMask (GL_FALSE);
           /* Mask out drilled holes on this layer */
           if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
           if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
@@ -1913,30 +1592,6 @@ hole_cyl_callback (const BoxType * b, void *cl)
   return 0;
 }
 
-static int
-frontE_package_callback (const BoxType * b, void *cl)
-{
-  ElementTypePtr element = (ElementTypePtr) b;
-
-  if (FRONT (element))
-    {
-      if (element->Name[DESCRIPTION_INDEX].TextString == NULL)
-        return 0;
-
-      if (strcmp (element->Name[DESCRIPTION_INDEX].TextString, "ACY400") == 0)
-        ghid_draw_acy_resistor (element);
-    }
-  return 1;
-}
-
-static void
-ghid_draw_packages (BoxTypePtr drawn_area)
-{
-  /* XXX: Just the front elements for now */
-  r_search (PCB->Data->element_tree, drawn_area, NULL, frontE_package_callback, NULL);
-
-}
-
 void
 ghid_draw_everything (BoxTypePtr drawn_area)
 {
@@ -2074,24 +1729,23 @@ ghid_draw_everything (BoxTypePtr drawn_area)
     gui->set_layer ("topsilk", SL (SILK, TOP), 0);
   else
     gui->set_layer ("bottomsilk", SL (SILK, BOTTOM), 0);
-  //  gui->set_layer (NULL, SL (FINISHED, 0), 0);
+//  gui->set_layer (NULL, SL (FINISHED, 0), 0);
 
   if (global_view_2d)
-  {
-    /* Mask out drilled holes */
-    hidgl_flush_triangles (&buffer);
-    glPushAttrib (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-    glColorMask (0, 0, 0, 0);
-    glDepthMask (GL_FALSE);
-    if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, hole_callback, NULL);
-    if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, hole_callback, NULL);
-    hidgl_flush_triangles (&buffer);
-    glPopAttrib ();
-
-    if (PCB->PinOn) r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, NULL);
-    if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_callback, NULL);
-    if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, via_callback, NULL);
-  }
+    {
+      /* Mask out drilled holes */
+      hidgl_flush_triangles (&buffer);
+      glPushAttrib (GL_COLOR_BUFFER_BIT);
+      glColorMask (0, 0, 0, 0);
+      if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, hole_callback, NULL);
+      if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, hole_callback, NULL);
+      hidgl_flush_triangles (&buffer);
+      glPopAttrib ();
+
+      if (PCB->PinOn) r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, NULL);
+      if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_callback, NULL);
+      if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, via_callback, NULL);
+    }
 
   gui->set_layer (NULL, SL (FINISHED, 0), 0);
 
@@ -2251,8 +1905,6 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
     glNewList (display_list, GL_COMPILE);
 #endif
 
-  glEnable (GL_DEPTH_TEST);
-  glDepthFunc (GL_ALWAYS);
   glEnable (GL_STENCIL_TEST);
   glClearColor (port->bg_color.red / 65535.,
                 port->bg_color.green / 65535.,
@@ -2393,46 +2045,6 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   ghid_draw_everything (&region);
   hidgl_flush_triangles (&buffer);
 
-  glTexCoord2f (0., 0.);
-  glColor3f (1., 1., 1.);
-
-  if (0) {
-    int x, y;
-    float z = max_depth;
-
-    glBegin (GL_LINES);
-
-    ghid_unproject_to_z_plane (ev->area.x, ev->area.y, z, &x, &y);
-    glPushMatrix ();
-    glLoadIdentity ();
-    glVertex3f (0., 0., 0.);
-    glPopMatrix ();
-    glVertex3f (x, y, z);
-
-    ghid_unproject_to_z_plane (ev->area.x, ev->area.y + ev->area.height, z, &x, &y);
-    glPushMatrix ();
-    glLoadIdentity ();
-    glVertex3f (0., 0., 0.);
-    glPopMatrix ();
-    glVertex3f (x, y, z);
-
-    ghid_unproject_to_z_plane (ev->area.x + ev->area.width, ev->area.y + ev->area.height, z, &x, &y);
-    glPushMatrix ();
-    glLoadIdentity ();
-    glVertex3f (0., 0., 0.);
-    glPopMatrix ();
-    glVertex3f (x, y, z);
-
-    ghid_unproject_to_z_plane (ev->area.x + ev->area.width, ev->area.y, z, &x, &y);
-    glPushMatrix ();
-    glLoadIdentity ();
-    glVertex3f (0., 0., 0.);
-    glPopMatrix ();
-    glVertex3f (x, y, z);
-
-    glEnd ();
-  }
-
   /* Just prod the drawing code so the current depth gets set to
      the right value for the layer we are editing */
   hidgl_set_depth (compute_depth (GetLayerGroupNumberByNumber (INDEXOFCURRENT)));
@@ -2443,52 +2055,6 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   DrawMark (TRUE);
   hidgl_flush_triangles (&buffer);
 
-  glEnable (GL_LIGHTING);
-
-  glShadeModel (GL_SMOOTH);
-
-  glEnable (GL_LIGHT0);
-
-  /* XXX: FIX OUR NORMALS */
-  glEnable (GL_NORMALIZE);
-//  glEnable (GL_RESCALE_NORMAL);
-
-  glDepthFunc (GL_LESS);
-  glDisable (GL_STENCIL_TEST);
-
-  glEnable (GL_CULL_FACE);
-  glCullFace (GL_BACK);
-
-  if (1) {
-    GLfloat global_ambient[] = {0.0f, 0.0f, 0.0f, 1.0f};
-    glLightModelfv (GL_LIGHT_MODEL_AMBIENT, global_ambient);
-    glLightModeli (GL_LIGHT_MODEL_LOCAL_VIEWER, GL_FALSE);
-  }
-  if (1) {
-    GLfloat diffuse[] =  {0.3, 0.3, 0.3, 1.0};
-    GLfloat ambient[] =  {0.7, 0.7, 0.7, 1.0};
-    GLfloat specular[] = {1.0, 1.0, 1.0, 1.0};
-    glLightfv (GL_LIGHT0, GL_DIFFUSE,  diffuse);
-    glLightfv (GL_LIGHT0, GL_AMBIENT,  ambient);
-    glLightfv (GL_LIGHT0, GL_SPECULAR, specular);
-  }
-  if (1) {
-//    GLfloat position[] = {1., -1., 1., 0.};
-    GLfloat position[] = {1., -0.5, 1., 0.};
-    glPushMatrix ();
-    glLoadIdentity ();
-    glLightfv (GL_LIGHT0, GL_POSITION, position);
-    glPopMatrix ();
-  }
-
-  ghid_draw_packages (&region);
-
-  glDisable (GL_CULL_FACE);
-  glDisable (GL_DEPTH_TEST);
-  glDisable (GL_LIGHT0);
-  glDisable (GL_COLOR_MATERIAL);
-  glDisable (GL_LIGHTING);
-
 #ifdef ONE_SHOT
     glEndList ();
     one_shot = 0;
@@ -2597,7 +2163,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
                 1.);
   glStencilMask (~0);
   glClearStencil (0);
-  glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+  glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
   hidgl_reset_stencil_usage ();
 
   /* call the drawing routine */
@@ -2663,7 +2229,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
 
   glconfig = gdk_gl_config_new_by_mode (GDK_GL_MODE_RGB     |
                                         GDK_GL_MODE_STENCIL |
-                                        GDK_GL_MODE_DEPTH   |
+//                                        GDK_GL_MODE_DEPTH   |
                                         GDK_GL_MODE_SINGLE);
 
   pixmap = gdk_pixmap_new (NULL, width, height, depth);
@@ -2711,7 +2277,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
                 1.);
   glStencilMask (~0);
   glClearStencil (0);
-  glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+  glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
   hidgl_reset_stencil_usage ();
 
   /* call the drawing routine */

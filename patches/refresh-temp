Bottom: 96ec493b4a0f0817dac64307639f5b20d7bb13c0
Top:    c4f042ee811cb855915884f8f9fabf56b2e42b2a
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-11-05 17:29:57 +0000

Refresh of attempt-at-supporting-mapped-v

---

diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index b61ac2e..88f8373 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -75,24 +75,25 @@ hidgl_new_triangle_array (void)
 }
 #endif
 
-#define NUM_BUF_GLFLOATS (3 * (3 + 2) * TRIANGLE_ARRAY_SIZE)
-
+#define BUFFER_STRIDE (5 * sizeof (GLfloat))
+#define BUFFER_SIZE (BUFFER_STRIDE * 3 * TRIANGLE_ARRAY_SIZE)
 
 /* NB: If using VBOs, the caller must ensure the VBO is bound to the GL_ARRAY_BUFFER */
 static void
 hidgl_reset_triangle_array (triangle_buffer *buffer)
 {
-  /* Hint to the driver that we're done with the previous buffer contents */
-  if (buffer->use_vbo)
-    glBufferData (GL_ARRAY_BUFFER, NUM_BUF_GLFLOATS * sizeof (GLfloat), NULL, GL_STREAM_DRAW);
-
-  /* Map the new memory to upload vertices into. */
-  if (buffer->use_map)
+  if (buffer->use_map) {
+    /* Hint to the driver that we're done with the previous buffer contents */
+    glBufferData (GL_ARRAY_BUFFER, BUFFER_SIZE, NULL, GL_STREAM_DRAW);
+    /* Map the new memory to upload vertices into. */
     buffer->triangle_array = glMapBuffer (GL_ARRAY_BUFFER, GL_WRITE_ONLY);
+  }
 
-  /* If mapping the VBO fails (or if we aren't using VBOs) fall back a local array */
+  /* If mapping the VBO fails (or if we aren't using VBOs) fall back a
+   * local array.
+   */
   if (buffer->triangle_array == NULL) {
-    buffer->triangle_array = malloc (NUM_BUF_GLFLOATS * sizeof (GLfloat));
+    buffer->triangle_array = malloc (BUFFER_SIZE);
     buffer->use_map = false;
   }
 
@@ -110,7 +111,7 @@ hidgl_init_triangle_array (triangle_buffer *buffer)
   CHECK_IS_IN_CONTEXT ();
 
   buffer->use_vbo = true;
-  buffer->use_vbo = false;
+  // buffer->use_vbo = false;
 
   if (buffer->use_vbo) {
     glGenBuffers (1, &buffer->vbo_id);
@@ -121,7 +122,21 @@ hidgl_init_triangle_array (triangle_buffer *buffer)
     buffer->use_vbo = false;
 
   buffer->use_map = buffer->use_vbo;
-  // buffer->use_map = false;
+
+  /* NB: Mapping the whole buffer can be expensive since we ask the driver
+   *     to discard previous data and give us a "new" buffer to write into
+   *     each time. If it is still rendering from previous buffer, we end
+   *     up causing a lot of unnecessary allocation in the driver this way.
+   *
+   *     On intel drivers at least, glBufferSubData does not block. It uploads
+   *     into a temporary buffer and queues a GPU copy of the uploaded data
+   *     for when the "main" buffer has finished rendering.
+   */
+  buffer->use_map = false;
+
+  /* If using VBOs (but not mapping), we only need to this once */
+  if (buffer->use_vbo && !buffer->use_map)
+    glBufferData (GL_ARRAY_BUFFER, BUFFER_SIZE, NULL, GL_STREAM_DRAW);
 
   buffer->triangle_array = NULL;
   hidgl_reset_triangle_array (buffer);
@@ -144,11 +159,11 @@ hidgl_finish_triangle_array (triangle_buffer *buffer)
   }
 }
 
-#define BUF_OFFSET(x) (&((GLfloat *)NULL)[x])
-
 void
 hidgl_flush_triangles (triangle_buffer *buffer)
 {
+  GLfloat *data_pointer = NULL;
+
   CHECK_IS_IN_CONTEXT ();
   if (buffer->vertex_count == 0)
     return;
@@ -160,16 +175,17 @@ hidgl_flush_triangles (triangle_buffer *buffer)
       glUnmapBuffer (GL_ARRAY_BUFFER);
       buffer->triangle_array = NULL;
     } else {
-      glBufferSubData (GL_ARRAY_BUFFER, 0, NUM_BUF_GLFLOATS * sizeof (GLfloat),
+      /* NB: We only upload the portion of the buffer we've used */
+      glBufferSubData (GL_ARRAY_BUFFER, 0,
+                       BUFFER_STRIDE * buffer->vertex_count,
                        buffer->triangle_array);
     }
+  } else {
+    data_pointer = buffer->triangle_array;
   }
 
-  glTexCoordPointer (2, GL_FLOAT, 5 * sizeof (GLfloat), buffer->use_vbo ?
-                       BUF_OFFSET (3) : buffer->triangle_array + 3);
-
-  glVertexPointer (3, GL_FLOAT, 5 * sizeof (GLfloat), buffer->use_vbo ?
-                     BUF_OFFSET (0) : buffer->triangle_array + 0);
+  glTexCoordPointer (2, GL_FLOAT, BUFFER_STRIDE, data_pointer + 3);
+  glVertexPointer   (3, GL_FLOAT, BUFFER_STRIDE, data_pointer + 0);
 
   glEnableClientState (GL_TEXTURE_COORD_ARRAY);
   glEnableClientState (GL_VERTEX_ARRAY);

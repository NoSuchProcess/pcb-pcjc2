Bottom: ab4df904c348d799e4ffa18d7bff9afe0ab50d62
Top:    1704bb412fc06d970f1387e4926764133395b57b
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-11-20 00:50:47 +0000

Refresh of play-with-glsl-shader-for-rend

---

diff --git a/src/Makefile.am b/src/Makefile.am
index 3f3c291..70e759d 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -185,6 +185,8 @@ LIBGTK_GL_SRCS= \
 GL_SRCS= \
 	hid/common/hidgl.c \
 	hid/common/hidgl.h \
+	hid/common/hidgl_shaders.c \
+	hid/common/hidgl_shaders.h \
 	hid/common/trackball.c \
 	hid/common/trackball.h
 
diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index cdc01ce..abedaad 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -47,6 +47,8 @@ RCSID ("$Id: $");
 
 triangle_buffer buffer;
 float global_depth = 0;
+hidgl_shader *circular_program = NULL;
+hidgl_shader *resistor_program = NULL;
 
 static bool in_context = false;
 
@@ -604,8 +606,6 @@ myBegin (GLenum type)
   triangle_comp_idx = 0;
 }
 
-static double global_scale;
-
 static void
 myVertex (GLdouble *vertex_data)
 {
@@ -622,23 +622,11 @@ myVertex (GLdouble *vertex_data)
         }
       else
         {
-#if 1
           hidgl_ensure_triangle_space (&buffer, 1);
           hidgl_add_triangle (&buffer,
                               triangle_vertices [0], triangle_vertices [1],
                               triangle_vertices [2], triangle_vertices [3],
                               vertex_data [0], vertex_data [1]);
-#else
-          hidgl_draw_line (Square_Cap, global_scale,
-                           triangle_vertices [0], triangle_vertices [1],
-                           triangle_vertices [2], triangle_vertices [3], global_scale);
-          hidgl_draw_line (Square_Cap, global_scale,
-                           triangle_vertices [2], triangle_vertices [3],
-                           vertex_data [0],       vertex_data [1],       global_scale);
-          hidgl_draw_line (Square_Cap, global_scale,
-                           vertex_data [0],       vertex_data [1],
-                           triangle_vertices [0], triangle_vertices [1], global_scale);
-#endif
 
           if (tessVertexType == GL_TRIANGLE_STRIP)
             {
@@ -936,129 +924,49 @@ hidgl_fill_rect (int x1, int y1, int x2, int y2)
   /* NB: Repeated last virtex to separate from other tri-strip */
 }
 
-/* From http://gpwiki.org/index.php/OpenGL:Codes:Simple_GLSL_example */
 static void
-printLog(GLuint obj)
-{
-  return;
-  int infologLength = 0;
-  int maxLength;
-  char *infoLog;
-
-  if (glIsShader (obj))
-    glGetShaderiv (obj, GL_INFO_LOG_LENGTH, &maxLength);
-  else
-    glGetProgramiv (obj, GL_INFO_LOG_LENGTH, &maxLength);
-
-  infoLog = malloc (maxLength);
-
-  if (glIsShader (obj))
-    glGetShaderInfoLog (obj, maxLength, &infologLength, infoLog);
-  else
-    glGetProgramInfoLog (obj, maxLength, &infologLength, infoLog);
-
-  if (infologLength > 0)
-    printf ("%s\n", infoLog);
-
-  free (infoLog);
-}
-
-/* From http://gpwiki.org/index.php/OpenGL:Codes:Simple_GLSL_example */
-/* FIXED not to be completely brain-dead with memory allocation! - PCJC2*/
-char *
-file2string (const char *path)
-{
-  FILE *fd;
-  long len, r;
-  char *str;
-
-  if (!(fd = fopen (path, "r")))
-    {
-      fprintf (stderr, "Can't open file '%s' for reading\n", path);
-      return NULL;
-    }
-
-  fseek (fd, 0, SEEK_END);
-  len = ftell(fd);
-
-  printf ("File '%s' is %ld long\n", path, len);
-
-  fseek (fd, 0, SEEK_SET);
-
-  if (!(str = malloc (len * sizeof(char))))
-    {
-      fprintf (stderr, "Can't malloc space for '%s'\n", path);
-      return NULL;
-    }
-
-  r = fread (str, sizeof(char), len, fd);
-
-  str[r - 1] = '\0'; /* Shader sources have to term with null */
-
-  fclose (fd);
-
-  return str;
-}
-
-GLuint sp; /* Shader Program */
-
-void
-hidgl_load_frag_shader (void)
+load_built_in_shaders (void)
 {
-//  char *vs_source;
-  char *fs_source = "void main()\n"
-                    "{\n"
-                    "  float sqdist;\n"
-                    "  sqdist = dot (gl_TexCoord[0].st, gl_TexCoord[0].st);\n"
-                    "  if (sqdist > 1.0)\n"
-                    "    discard;\n"
-                    "  gl_FragColor = gl_Color;\n"
-                    "}\n";
-
-  /* Compile and load the program */
-
-//  GLuint vs; /* Vertex Shader */
-  GLuint fs; /* Fragment Shader */
-
-#if 0
-  vs_source = file2string ("circular.vert");
-  vs = glCreateShader (GL_VERTEX_SHADER);
-  glShaderSource (vs, 1, &vs_source, NULL);
-  glCompileShader (vs);
-  printLog (vs);
-  free (vs_source);
-#endif
-
-//  fs_source = file2string ("circular.frag");
-  if (fs_source == NULL)
-    return;
-  fs = glCreateShader (GL_FRAGMENT_SHADER);
-  glShaderSource (fs, 1, &fs_source, NULL);
-  glCompileShader (fs);
-  printLog (fs);
-//  free (fs_source);
-
-  sp = glCreateProgram ();
-//  glAttachShader (sp, vs);
-  glAttachShader (sp, fs);
-  glLinkProgram (sp);
-  printLog (sp);
-
-  glUseProgram (sp);
-
-  {
-  GLfloat waveTime = 0,
-          waveWidth = 0.00001,
-          waveHeight = 10;
-  GLint waveTimeLoc = glGetUniformLocation(sp, "waveTime");
-  GLint waveWidthLoc = glGetUniformLocation(sp, "waveWidth");
-  GLint waveHeightLoc = glGetUniformLocation(sp, "waveHeight");
-  /* Change time */
-  glUniform1f(waveTimeLoc, waveTime);
-  glUniform1f(waveWidthLoc, waveWidth);
-  glUniform1f(waveHeightLoc, waveHeight);
-
-  }
+  char *circular_fs_source =
+          "void main()\n"
+          "{\n"
+          "  float sqdist;\n"
+          "  sqdist = dot (gl_TexCoord[0].st, gl_TexCoord[0].st);\n"
+          "  if (sqdist > 1.0)\n"
+          "    discard;\n"
+          "  gl_FragColor = gl_Color;\n"
+          "}\n";
+
+  char *resistor_fs_source =
+          "uniform sampler1D detail_tex;\n"
+          "uniform sampler2D bump_tex;\n"
+          "\n"
+          "void main()\n"
+          "{\n"
+          "  vec3 bumpNormal = texture2D (bump_tex, gl_TexCoord[1].st).rgb;\n"
+          "  vec3 detailColor = texture1D (detail_tex, gl_TexCoord[0].s).rgb;\n"
+          "\n"
+          "  /* Uncompress vectors ([0, 1] -> [-1, 1]) */\n"
+          "  vec3 lightVectorFinal = -1.0 + 2.0 * gl_Color.rgb;\n"
+          "  vec3 halfVectorFinal = -1.0 + 2.0 * gl_TexCoord[2].xyz;\n"
+          "  vec3 bumpNormalVectorFinal = -1.0 + 2.0 * bumpNormal;\n"
+          "\n"
+          "  /* Compute diffuse factor */\n"
+          "  float diffuse = clamp(dot(bumpNormalVectorFinal,\n"
+          "                            lightVectorFinal),0.0, 1.0);\n"
+          "  float specular = pow(clamp(dot(bumpNormalVectorFinal,\n"
+          "                                 halfVectorFinal), 0.0, 1.0),\n"
+          "                       2.0);\n"
+          "  specular *= 0.4;\n"
+          "\n"
+          "   gl_FragColor = vec4(detailColor * (0.3 + 0.7 * diffuse) + \n"
+          "                    vec3(specular, specular, specular), 1.0);\n"
+          "}\n";
+
+  circular_program = hidgl_shader_new ("circular_rendering", NULL, circular_fs_source);
+  resistor_program = hidgl_shader_new ("resistor_rendering", NULL, resistor_fs_source);
+
+  hidgl_shader_activate (circular_program);
 }
 
 void
@@ -1085,7 +993,14 @@ hidgl_init (void)
       /* Do we need to disable that somewhere? */
     }
 
-  hidgl_load_frag_shader ();
+  if (!hidgl_shader_init_shaders ()) {
+    printf ("Failed to initialise shader support\n");
+    goto done;
+  }
+
+  load_built_in_shaders ();
+
+done:
   done_once = true;
 }
 
diff --git a/src/hid/common/hidgl_shaders.c b/src/hid/common/hidgl_shaders.c
new file mode 100644
index 0000000..8609afe
--- /dev/null
+++ b/src/hid/common/hidgl_shaders.c
@@ -0,0 +1,165 @@
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 2010 PCB Contributors (See ChangeLog for details).
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdbool.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+
+/* The Linux OpenGL ABI 1.0 spec requires that we define
+ * GL_GLEXT_PROTOTYPES before including gl.h or glx.h for extensions
+ * in order to get prototypes:
+ *   http://www.opengl.org/registry/ABI/
+ */
+#define GL_GLEXT_PROTOTYPES 1
+#include <GL/gl.h>
+#include <GL/glu.h>
+#include "hidgl_shaders.h"
+
+#ifdef HAVE_LIBDMALLOC
+#include <dmalloc.h>
+#endif
+
+/* Opaque data-structure keeping a shader object */
+struct _hidgl_shader {
+  char *name;
+  GLuint program;
+  GLuint vs;
+  GLuint fs;
+};
+
+bool
+hidgl_shader_init_shaders (void)
+{
+  /* XXX: Check for required functionality in the GL driver */
+  return true;
+}
+
+/* From http://gpwiki.org/index.php/OpenGL:Codes:Simple_GLSL_example */
+static void
+print_log (GLuint obj)
+{
+  int infologLength = 0;
+  int maxLength;
+  char *infoLog;
+
+  if (glIsShader (obj))
+    glGetShaderiv (obj, GL_INFO_LOG_LENGTH, &maxLength);
+  else
+    glGetProgramiv (obj, GL_INFO_LOG_LENGTH, &maxLength);
+
+  infoLog = malloc (maxLength);
+
+  if (glIsShader (obj))
+    glGetShaderInfoLog (obj, maxLength, &infologLength, infoLog);
+  else
+    glGetProgramInfoLog (obj, maxLength, &infologLength, infoLog);
+
+  if (infologLength > 0)
+    printf ("%s\n", infoLog);
+
+  free (infoLog);
+}
+
+
+/* If either vs or fs is NULL, used the fixed function pipeline for that */
+hidgl_shader *
+hidgl_shader_new (char *name, char *vs_source, char *fs_source)
+{
+  hidgl_shader *shader;
+  const char *source;
+  int source_len;
+
+  shader = malloc (sizeof (hidgl_shader));
+
+  if (shader == NULL)
+    return NULL;
+
+  shader->name = strdup (name);
+  shader->program = 0;
+  shader->vs = 0;
+  shader->fs = 0;
+
+  if (fs_source == NULL && vs_source == NULL)
+    return shader;
+
+  shader->program = glCreateProgram ();
+
+  if (vs_source != NULL) {
+    source = vs_source;
+    source_len = -1; /* The string is '\0' terminated */
+    shader->vs = glCreateShader (GL_VERTEX_SHADER);
+    glShaderSource (shader->vs, 1, &source, &source_len);
+    glCompileShader (shader->vs);
+    print_log (shader->vs);
+    glAttachShader (shader->program, shader->vs);
+  }
+
+  if (fs_source != NULL) {
+    source = fs_source;
+    source_len = -1; /* The string is '\0' terminated */
+    shader->fs = glCreateShader (GL_FRAGMENT_SHADER);
+    glShaderSource (shader->fs, 1, &source, &source_len);
+    glCompileShader (shader->fs);
+    print_log (shader->fs);
+    glAttachShader (shader->program, shader->fs);
+  }
+
+  glLinkProgram (shader->program);
+  print_log (shader->program);
+  return shader;
+}
+
+
+GLuint
+hidgl_shader_get_program (hidgl_shader *shader)
+{
+  return shader->program;
+}
+
+
+/* Delete the passed shader. */
+void
+hidgl_shader_free (hidgl_shader *shader)
+{
+  /* NB: These calls all silently ignore 0 or NULL arguments */
+  glDeleteShader (shader->vs);
+  glDeleteShader (shader->fs);
+  glDeleteProgram (shader->program);
+  free (shader->name);
+  free (shader);
+}
+
+
+/* Activate the given shader program, or deactivate if NULL passed */
+void
+hidgl_shader_activate (hidgl_shader *shader)
+{
+  if (shader == NULL)
+    glUseProgram (0);
+  else
+    glUseProgram (shader->program);
+}
diff --git a/src/hid/common/hidgl_shaders.h b/src/hid/common/hidgl_shaders.h
new file mode 100644
index 0000000..9812b4b
--- /dev/null
+++ b/src/hid/common/hidgl_shaders.h
@@ -0,0 +1,35 @@
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 2010 PCB Contributors (See ChangeLog for details).
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifndef __HIDGL_SHADERS_INCLUDED__
+#define __HIDGL_SHADERS_INCLUDED__
+
+typedef struct _hidgl_shader hidgl_shader;
+
+bool hidgl_shader_init_shaders (void);
+
+hidgl_shader *hidgl_shader_new (char *name, char *vs_source, char *fs_source);
+GLuint hidgl_shader_get_program (hidgl_shader *shader);
+void hidgl_shader_free (hidgl_shader *shader);
+void hidgl_shader_activate (hidgl_shader *shader);
+
+#endif /* __HIDGL_SHADERS_INCLUDED__  */

Bottom: ab90b5c6328d782b129bc96c4c50cf33b6582cdd
Top:    f80a7482acd6b88c878278111e2f1d5db4a73ad7
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2015-01-11 23:48:55 +0000

Refresh of attempt-at-re-writing-drawing

---

diff --git a/src/autoroute.c b/src/autoroute.c
index 0b4b9e9..e38247f 100644
--- a/src/autoroute.c
+++ b/src/autoroute.c
@@ -3673,7 +3673,7 @@ TracePath (routedata_t * rd, routebox_t * path, const routebox_t * target,
 
 #ifdef ROUTE_DEBUG
   if (ddraw != NULL)
-    gui->flush_debug_draw ();
+    gui->flush_debug_draw (ar_gc);
 #endif
 }
 
@@ -5333,8 +5333,8 @@ donerouting:
 #ifdef ROUTE_DEBUG
   if (ddraw != NULL)
     {
+      gui->finish_debug_draw (ar_gc);
       hid_draw_destroy_gc (ar_gc);
-      gui->finish_debug_draw ();
     }
 #endif
 
diff --git a/src/draw.c b/src/draw.c
index 2993fac..c9fbe2b 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -76,18 +76,17 @@ static BoxType Block = {MAXINT, MAXINT, -MAXINT, -MAXINT};
 
 static int doing_pinout = 0;
 static bool doing_assy = false;
-static HID_DRAW *hid_draw = NULL;
 
 /* ---------------------------------------------------------------------------
  * some local prototypes
  */
-static void DrawEverything (const BoxType *);
+static void DrawEverything (hidGC gc);
 static void AddPart (void *);
-/* static */ void DrawEMark (ElementType *, Coord, Coord, bool);
-/* static */ void DrawRats (HID_DRAW *hid_draw, const BoxType *);
+/* static */ void DrawEMark (hidGC gc, ElementType *, Coord, Coord, bool);
+/* static */ void DrawRats (hidGC gc);
 
 static void
-set_object_color (AnyObjectType *obj, char *warn_color, char *selected_color,
+set_object_color (hidGC gc, AnyObjectType *obj, char *warn_color, char *selected_color,
                   char *connected_color, char *found_color, char *normal_color)
 {
   char *color;
@@ -98,7 +97,7 @@ set_object_color (AnyObjectType *obj, char *warn_color, char *selected_color,
   else if (found_color     != NULL && TEST_FLAG (FOUNDFLAG,     obj)) color = found_color;
   else                                                                color = normal_color;
 
-  hid_draw_set_color (Output.fgGC, color);
+  hid_draw_set_color (gc, color);
 }
 
 /*---------------------------------------------------------------------------
@@ -138,39 +137,46 @@ Redraw (void)
   gui->invalidate_all ();
 }
 
+struct side_info {
+  hidGC gc;
+  int side;
+};
+
 static int
 pad_callback (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *) b;
-  int *side = cl;
+  struct side_info *info = cl;
 
-  if (ON_SIDE (pad, *side))
+  if (ON_SIDE (pad, info->side))
     {
-      set_object_color ((AnyObjectType *)pad, PCB->WarnColor,
+      set_object_color (info->gc, (AnyObjectType *)pad, PCB->WarnColor,
                         PCB->PinSelectedColor, PCB->ConnectedColor, PCB->FoundColor,
                         FRONT (pad) ? PCB->PinColor : PCB->InvisibleObjectsColor);
 
-      dapi->draw_pad (pad, NULL, NULL);
+      dapi->draw_pad (info->gc, pad, NULL);
     }
   return 1;
 }
 
 static void
-draw_element_name (ElementType *element)
+draw_element_name (hidGC gc, ElementType *element)
 {
+  HID_DRAW *hid_draw = gc->hid_draw;
+
   if ((TEST_FLAG (HIDENAMESFLAG, PCB) && hid_draw_is_gui (hid_draw)) ||
       TEST_FLAG (HIDENAMEFLAG, element))
     return;
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)element);
+  ghid_set_lock_effects (gc, (AnyObjectType *)element);
   if (doing_pinout || doing_assy)
-    hid_draw_set_color (Output.fgGC, PCB->ElementColor);
+    hid_draw_set_color (gc, PCB->ElementColor);
   else if (TEST_FLAG (SELECTEDFLAG, &ELEMENT_TEXT (PCB, element)))
-    hid_draw_set_color (Output.fgGC, PCB->ElementSelectedColor);
+    hid_draw_set_color (gc, PCB->ElementSelectedColor);
   else if (FRONT (element))
-    hid_draw_set_color (Output.fgGC, PCB->ElementColor);
+    hid_draw_set_color (gc, PCB->ElementColor);
   else
-    hid_draw_set_color (Output.fgGC, PCB->InvisibleObjectsColor);
-  hid_draw_pcb_text (Output.fgGC, &ELEMENT_TEXT (PCB, element), PCB->minSlk);
+    hid_draw_set_color (gc, PCB->InvisibleObjectsColor);
+  hid_draw_pcb_text (gc, &ELEMENT_TEXT (PCB, element), PCB->minSlk);
 }
 
 static int
@@ -178,42 +184,42 @@ name_callback (const BoxType * b, void *cl)
 {
   TextType *text = (TextType *) b;
   ElementType *element = (ElementType *) text->Element;
-  int *side = cl;
+  struct side_info *info = cl;
 
   if (TEST_FLAG (HIDENAMEFLAG, element))
     return 0;
 
-  if (ON_SIDE (element, *side))
-    draw_element_name (element);
+  if (ON_SIDE (element, info->side))
+    draw_element_name (info->gc, element);
   return 0;
 }
 
 static void
-draw_element_pins_and_pads (ElementType *element)
+draw_element_pins_and_pads (hidGC gc, ElementType *element)
 {
   PAD_LOOP (element);
   {
     if (doing_pinout || doing_assy || FRONT (pad) || PCB->InvisibleObjectsOn)
       {
-        set_object_color ((AnyObjectType *)pad, PCB->WarnColor,
+        set_object_color (gc, (AnyObjectType *)pad, PCB->WarnColor,
                           PCB->PinSelectedColor, PCB->ConnectedColor, PCB->FoundColor,
                           FRONT (pad) ? PCB->PinColor : PCB->InvisibleObjectsColor);
 
-        dapi->draw_pad (pad, NULL, NULL);
+        dapi->draw_pad (gc, pad, NULL);
       }
   }
   END_LOOP;
   PIN_LOOP (element);
   {
-    set_object_color ((AnyObjectType *)pin, PCB->WarnColor, PCB->PinSelectedColor,
+    set_object_color (gc, (AnyObjectType *)pin, PCB->WarnColor, PCB->PinSelectedColor,
                       PCB->ConnectedColor, PCB->FoundColor, PCB->PinColor);
 
-    dapi->draw_pin (pin, NULL, NULL);
+    dapi->draw_pin (gc, pin, NULL);
 
-    set_object_color ((AnyObjectType *)pin, PCB->WarnColor,
+    set_object_color (gc, (AnyObjectType *)pin, PCB->WarnColor,
                       PCB->PinSelectedColor, NULL, NULL, Settings.BlackColor);
 
-    dapi->draw_pin_hole (pin, NULL, NULL);
+    dapi->draw_pin_hole (gc, pin, NULL);
   }
   END_LOOP;
 }
@@ -222,8 +228,9 @@ static int
 EMark_callback (const BoxType * b, void *cl)
 {
   ElementType *element = (ElementType *) b;
+  hidGC gc = cl;
 
-  DrawEMark (element, element->MarkX, element->MarkY, !FRONT (element));
+  DrawEMark (gc, element, element->MarkX, element->MarkY, !FRONT (element));
   return 1;
 }
 
@@ -231,39 +238,40 @@ static int
 rat_callback (const BoxType * b, void *cl)
 {
   RatType *rat = (RatType *)b;
+  hidGC gc = cl;
 
-  set_object_color ((AnyObjectType *) rat, NULL, PCB->RatSelectedColor,
+  set_object_color (gc, (AnyObjectType *) rat, NULL, PCB->RatSelectedColor,
                     PCB->ConnectedColor, PCB->FoundColor, PCB->RatColor);
 
-  dapi->draw_rat (rat, NULL, NULL);
+  dapi->draw_rat (gc, rat, NULL);
   return 1;
 }
 
 static void
-draw_element_package (ElementType *element)
+draw_element_package (hidGC gc, ElementType *element)
 {
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)element);
+  ghid_set_lock_effects (gc, (AnyObjectType *)element);
   /* set color and draw lines, arcs, text and pins */
   if (doing_pinout || doing_assy)
-    hid_draw_set_color (Output.fgGC, PCB->ElementColor);
+    hid_draw_set_color (gc, PCB->ElementColor);
   else if (TEST_FLAG (SELECTEDFLAG, element))
-    hid_draw_set_color (Output.fgGC, PCB->ElementSelectedColor);
+    hid_draw_set_color (gc, PCB->ElementSelectedColor);
   else if (FRONT (element))
-    hid_draw_set_color (Output.fgGC, PCB->ElementColor);
+    hid_draw_set_color (gc, PCB->ElementColor);
   else
-    hid_draw_set_color (Output.fgGC, PCB->InvisibleObjectsColor);
+    hid_draw_set_color (gc, PCB->InvisibleObjectsColor);
 
   /* draw lines, arcs, text and pins */
   ELEMENTLINE_LOOP (element);
   {
-    //hid_draw_pcb_line (Output.fgGC, line);
-    dapi->draw_line (line, NULL, NULL);
+    //hid_draw_pcb_line (gc, line);
+    dapi->draw_line (gc, line, NULL);
   }
   END_LOOP;
   ARC_LOOP (element);
   {
-    //hid_draw_pcb_arc (Output.fgGC, arc);
-    dapi->draw_arc (arc, NULL, NULL);
+    //hid_draw_pcb_arc (gc, arc);
+    dapi->draw_arc (gc, arc, NULL);
   }
   END_LOOP;
 }
@@ -272,10 +280,10 @@ static int
 element_callback (const BoxType * b, void *cl)
 {
   ElementType *element = (ElementType *) b;
-  int *side = cl;
+  struct side_info *info = cl;
 
-  if (ON_SIDE (element, *side))
-    draw_element_package (element);
+  if (ON_SIDE (element, info->side))
+    draw_element_package (info->gc, element);
   return 1;
 }
 
@@ -284,17 +292,17 @@ element_callback (const BoxType * b, void *cl)
  */
 
 void
-PrintAssembly (int side, const BoxType * drawn_area)
+PrintAssembly (hidGC gc, int side)
 {
   int side_group = GetLayerGroupNumberBySide (side);
 
   doing_assy = true;
-  hid_draw_set_draw_faded (Output.fgGC, 1);
-  DrawLayerGroup (side_group, drawn_area);
-  hid_draw_set_draw_faded (Output.fgGC, 0);
+  hid_draw_set_draw_faded (gc, 1);
+  DrawLayerGroup (gc, side_group);
+  hid_draw_set_draw_faded (gc, 0);
 
   /* draw package */
-  DrawSilk (hid_draw, side, drawn_area);
+  DrawSilk (gc, side);
   doing_assy = false;
 }
 
@@ -302,9 +310,9 @@ PrintAssembly (int side, const BoxType * drawn_area)
  * initializes some identifiers for a new zoom factor and redraws whole screen
  */
 static void
-DrawEverything (const BoxType *drawn_area)
+DrawEverything (hidGC gc)
 {
-  int i, ngroups, side;
+  int i, ngroups;
   int top_group, bottom_group;
   /* This is the list of layer groups we will draw.  */
   int do_group[MAX_GROUP];
@@ -312,6 +320,10 @@ DrawEverything (const BoxType *drawn_area)
   int drawn_groups[MAX_GROUP];
   int plated, unplated;
   bool paste_empty;
+  struct side_info info;
+  HID_DRAW *hid_draw = gc->hid_draw;
+
+  info.gc = gc;
 
   PCB->Data->SILKLAYER.Color = PCB->ElementColor;
   PCB->Data->BACKSILKLAYER.Color = PCB->InvisibleObjectsColor;
@@ -337,14 +349,14 @@ DrawEverything (const BoxType *drawn_area)
   if (!TEST_FLAG (CHECKPLANESFLAG, PCB)
       && hid_draw_set_layer (hid_draw, "invisible", SL (INVISIBLE, 0), 0))
     {
-      side = SWAP_IDENT ? TOP_SIDE : BOTTOM_SIDE;
+      info.side = SWAP_IDENT ? TOP_SIDE : BOTTOM_SIDE;
       if (PCB->ElementOn)
 	{
-	  r_search (PCB->Data->element_tree, drawn_area, NULL, element_callback, &side);
-	  r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], drawn_area, NULL, name_callback, &side);
-	  dapi->draw_layer (&(PCB->Data->Layer[max_copper_layer + side]), drawn_area, NULL);
+	  r_search (PCB->Data->element_tree, hid_draw->clip_box, NULL, element_callback, &info);
+	  r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], hid_draw->clip_box, NULL, name_callback, &info);
+	  dapi->draw_layer (gc, &(PCB->Data->Layer[max_copper_layer + info.side]), NULL);
 	}
-      r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, &side);
+      r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_callback, &info);
       hid_draw_end_layer (hid_draw);
     }
 
@@ -355,7 +367,7 @@ DrawEverything (const BoxType *drawn_area)
 
       if (hid_draw_set_layer (hid_draw, 0, group, 0))
         {
-          DrawLayerGroup (group, drawn_area);
+          DrawLayerGroup (gc, group);
           hid_draw_end_layer (hid_draw);
         }
     }
@@ -365,20 +377,20 @@ DrawEverything (const BoxType *drawn_area)
 
   /* Draw pins, pads, vias below silk */
   if (hid_draw_is_gui (hid_draw))
-    dapi->draw_ppv (SWAP_IDENT ? bottom_group : top_group, drawn_area, NULL);
+    dapi->draw_ppv (gc, SWAP_IDENT ? bottom_group : top_group, NULL);
   else
     {
-      CountHoles (&plated, &unplated, drawn_area);
+      CountHoles (&plated, &unplated, hid_draw->clip_box);
 
       if (plated && hid_draw_set_layer (hid_draw, "plated-drill", SL (PDRILL, 0), 0))
         {
-          dapi->draw_holes (1, drawn_area, NULL);
+          dapi->draw_holes (gc, 1, NULL);
           hid_draw_end_layer (hid_draw);
         }
 
       if (unplated && hid_draw_set_layer (hid_draw, "unplated-drill", SL (UDRILL, 0), 0))
         {
-          dapi->draw_holes (0, drawn_area, NULL);
+          dapi->draw_holes (gc, 0, NULL);
           hid_draw_end_layer (hid_draw);
         }
     }
@@ -386,25 +398,25 @@ DrawEverything (const BoxType *drawn_area)
   /* Draw the solder mask if turned on */
   if (hid_draw_set_layer (hid_draw, "componentmask", SL (MASK, TOP), 0))
     {
-      DrawMask (TOP_SIDE, drawn_area);
+      DrawMask (gc, TOP_SIDE);
       hid_draw_end_layer (hid_draw);
     }
 
   if (hid_draw_set_layer (hid_draw, "soldermask", SL (MASK, BOTTOM), 0))
     {
-      DrawMask (BOTTOM_SIDE, drawn_area);
+      DrawMask (gc, BOTTOM_SIDE);
       hid_draw_end_layer (hid_draw);
     }
 
   if (hid_draw_set_layer (hid_draw, "topsilk", SL (SILK, TOP), 0))
     {
-      DrawSilk (hid_draw, TOP_SIDE, drawn_area);
+      DrawSilk (gc, TOP_SIDE);
       hid_draw_end_layer (hid_draw);
     }
 
   if (hid_draw_set_layer (hid_draw, "bottomsilk", SL (SILK, BOTTOM), 0))
     {
-      DrawSilk (hid_draw, BOTTOM_SIDE, drawn_area);
+      DrawSilk (gc, BOTTOM_SIDE);
       hid_draw_end_layer (hid_draw);
     }
 
@@ -412,12 +424,11 @@ DrawEverything (const BoxType *drawn_area)
     {
       /* Draw element Marks */
       if (PCB->PinOn)
-	r_search (PCB->Data->element_tree, drawn_area, NULL, EMark_callback,
-		  NULL);
+	r_search (PCB->Data->element_tree, hid_draw->clip_box, NULL, EMark_callback, gc);
       /* Draw rat lines on top */
       if (hid_draw_set_layer (hid_draw, "rats", SL (RATS, 0), 0))
         {
-          DrawRats (hid_draw, drawn_area);
+          DrawRats (gc);
           hid_draw_end_layer (hid_draw);
         }
     }
@@ -425,38 +436,38 @@ DrawEverything (const BoxType *drawn_area)
   paste_empty = IsPasteEmpty (TOP_SIDE);
   if (hid_draw_set_layer (hid_draw, "toppaste", SL (PASTE, TOP), paste_empty))
     {
-      DrawPaste (TOP_SIDE, drawn_area);
+      DrawPaste (gc, TOP_SIDE);
       hid_draw_end_layer (hid_draw);
     }
 
   paste_empty = IsPasteEmpty (BOTTOM_SIDE);
   if (hid_draw_set_layer (hid_draw, "bottompaste", SL (PASTE, BOTTOM), paste_empty))
     {
-      DrawPaste (BOTTOM_SIDE, drawn_area);
+      DrawPaste (gc, BOTTOM_SIDE);
       hid_draw_end_layer (hid_draw);
     }
 
   if (hid_draw_set_layer (hid_draw, "topassembly", SL (ASSY, TOP), 0))
     {
-      PrintAssembly (TOP_SIDE, drawn_area);
+      PrintAssembly (gc, TOP_SIDE);
       hid_draw_end_layer (hid_draw);
     }
 
   if (hid_draw_set_layer (hid_draw, "bottomassembly", SL (ASSY, BOTTOM), 0))
     {
-      PrintAssembly (BOTTOM_SIDE, drawn_area);
+      PrintAssembly (gc, BOTTOM_SIDE);
       hid_draw_end_layer (hid_draw);
     }
 
   if (hid_draw_set_layer (hid_draw, "fab", SL (FAB, 0), 0))
     {
-      PrintFab (Output.fgGC);
+      PrintFab (gc);
       hid_draw_end_layer (hid_draw);
     }
 }
 
 /* static */ void
-DrawEMark (ElementType *e, Coord X, Coord Y, bool invisible)
+DrawEMark (hidGC gc, ElementType *e, Coord X, Coord Y, bool invisible)
 {
   Coord mark_size = EMARK_SIZE;
   if (!PCB->InvisibleObjectsOn && invisible)
@@ -477,14 +488,14 @@ DrawEMark (ElementType *e, Coord X, Coord Y, bool invisible)
       mark_size = MIN (mark_size, pad0->Thickness / 2);
     }
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)e);
-  hid_draw_set_color (Output.fgGC, invisible ? PCB->InvisibleMarkColor : PCB->ElementColor);
-  hid_draw_set_line_cap (Output.fgGC, Trace_Cap);
-  hid_draw_set_line_width (Output.fgGC, 0);
-  hid_draw_line (Output.fgGC, X - mark_size, Y, X, Y - mark_size);
-  hid_draw_line (Output.fgGC, X + mark_size, Y, X, Y - mark_size);
-  hid_draw_line (Output.fgGC, X - mark_size, Y, X, Y + mark_size);
-  hid_draw_line (Output.fgGC, X + mark_size, Y, X, Y + mark_size);
+  ghid_set_lock_effects (gc, (AnyObjectType *)e);
+  hid_draw_set_color (gc, invisible ? PCB->InvisibleMarkColor : PCB->ElementColor);
+  hid_draw_set_line_cap (gc, Trace_Cap);
+  hid_draw_set_line_width (gc, 0);
+  hid_draw_line (gc, X - mark_size, Y, X, Y - mark_size);
+  hid_draw_line (gc, X + mark_size, Y, X, Y - mark_size);
+  hid_draw_line (gc, X - mark_size, Y, X, Y + mark_size);
+  hid_draw_line (gc, X + mark_size, Y, X, Y + mark_size);
 
   /*
    * If an element is locked, place a "L" on top of the "diamond".
@@ -493,22 +504,26 @@ DrawEMark (ElementType *e, Coord X, Coord Y, bool invisible)
    */
   if (TEST_FLAG (LOCKFLAG, e) )
     {
-      hid_draw_line (Output.fgGC, X, Y, X + 2 * mark_size, Y);
-      hid_draw_line (Output.fgGC, X, Y, X, Y - 4* mark_size);
+      hid_draw_line (gc, X, Y, X + 2 * mark_size, Y);
+      hid_draw_line (gc, X, Y, X, Y - 4* mark_size);
     }
 }
 
 static int
 pin_mask_callback (const BoxType * b, void *cl)
 {
-  dapi->draw_pin_mask ((PinType *) b, NULL, NULL);
+  hidGC gc = cl;
+
+  dapi->draw_pin_mask (gc, (PinType *) b, NULL);
   return 1;
 }
 
 static int
 via_mask_callback (const BoxType * b, void *cl)
 {
-  dapi->draw_via_mask ((PinType *) b, NULL, NULL);
+  hidGC gc = cl;
+
+  dapi->draw_via_mask (gc, (PinType *) b, NULL);
   return 1;
 }
 
@@ -516,9 +531,10 @@ static int
 pad_mask_callback (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *) b;
-  int *side = cl;
-  if (ON_SIDE (pad, *side))
-    dapi->draw_pad_mask (pad, NULL, NULL);
+  struct side_info *info = cl;
+
+  if (ON_SIDE (pad, info->side))
+    dapi->draw_pad_mask (info->gc, pad, NULL);
   return 1;
 }
 
@@ -527,10 +543,13 @@ pad_mask_callback (const BoxType * b, void *cl)
  */
 
 void
-DrawSilk (HID_DRAW *new_hid_draw, int side, const BoxType * drawn_area)
+DrawSilk (hidGC gc, int side)
 {
-  HID_DRAW *old_hid_draw = hid_draw;
-  hid_draw = new_hid_draw;
+  struct side_info info;
+  HID_DRAW *hid_draw = gc->hid_draw;
+
+  info.gc = gc;
+  info.side = side;
 
 #if 0
   /* This code is used when you want to mask silk to avoid exposed
@@ -543,62 +562,57 @@ DrawSilk (HID_DRAW *new_hid_draw, int side, const BoxType * drawn_area)
     {
       hid_draw_use_mask (hid_draw, HID_MASK_BEFORE);
 #endif
-      dapi->draw_layer (LAYER_PTR (max_copper_layer + side), drawn_area, NULL);
+      dapi->draw_layer (gc, LAYER_PTR (max_copper_layer + side), NULL);
       /* draw package */
-      r_search (PCB->Data->element_tree, drawn_area, NULL, element_callback, &side);
-      r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], drawn_area, NULL, name_callback, &side);
+      r_search (PCB->Data->element_tree, hid_draw->clip_box, NULL, element_callback, &info);
+      r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], hid_draw->clip_box, NULL, name_callback, &info);
 #if 0
     }
 
   hid_draw_use_mask (hid_draw, HID_MASK_CLEAR);
-  r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_mask_callback, NULL);
-  r_search (PCB->Data->via_tree, drawn_area, NULL, via_mask_callback, NULL);
-  r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_mask_callback, &side);
+  r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_mask_callback, gc);
+  r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, via_mask_callback, gc);
+  r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_mask_callback, &info);
 
   if (hid_draw->poly_after)
     {
-      hid_draw_use_mask (hid_draw, HID_MASK_AFTER);
-      dapi->draw_layer (LAYER_PTR (max_copper_layer + layer), drawn_area, NULL);
+      hid_draw_use_mask (gc, hid_draw, HID_MASK_AFTER);
+      dapi->draw_layer (gc, LAYER_PTR (max_copper_layer + layer), NULL);
       /* draw package */
-      r_search (PCB->Data->element_tree, drawn_area, NULL, element_callback, &side);
-      r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], drawn_area, NULL, name_callback, &side);
+      r_search (PCB->Data->element_tree, hid_draw->clip_box, NULL, element_callback, &side);
+      r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], hid_draw->clip_box, NULL, name_callback, &info);
     }
   hid_draw_use_mask (hid_draw, HID_MASK_OFF);
 #endif
-
-  hid_draw = old_hid_draw;
 }
 
 
 static void
-DrawMaskBoardArea (int mask_type, const BoxType *drawn_area)
+DrawMaskBoardArea (hidGC gc, int mask_type)
 {
+  HID_DRAW *hid_draw = gc->hid_draw;
+
   /* Skip the mask drawing if the GUI doesn't want this type */
   if ((mask_type == HID_MASK_BEFORE && !hid_draw->poly_before) ||
       (mask_type == HID_MASK_AFTER  && !hid_draw->poly_after))
     return;
 
   hid_draw_use_mask (hid_draw, mask_type);
-  hid_draw_set_color (Output.fgGC, PCB->MaskColor);
-  if (drawn_area == NULL)
-    hid_draw_fill_rect (Output.fgGC, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
+  hid_draw_set_color (gc, PCB->MaskColor);
+  if (hid_draw->clip_box == NULL)
+    hid_draw_fill_rect (gc, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
   else
-    hid_draw_fill_rect (Output.fgGC, drawn_area->X1, drawn_area->Y1,
-                                     drawn_area->X2, drawn_area->Y2);
+    hid_draw_fill_rect (gc, hid_draw->clip_box->X1, hid_draw->clip_box->Y1,
+                            hid_draw->clip_box->X2, hid_draw->clip_box->Y2);
 }
 
-struct poly_info {
-  const const BoxType *drawn_area;
-  LayerType *layer;
-};
-
 static int
 mask_poly_callback (const BoxType * b, void *cl)
 {
-  struct poly_info *i = cl;
   PolygonType *polygon = (PolygonType *)b;
+  hidGC gc = cl;
 
-  hid_draw_pcb_polygon (Output.pmGC, polygon, i->drawn_area);
+  hid_draw_pcb_polygon (Output.pmGC, polygon);
   return 1;
 }
 
@@ -606,6 +620,7 @@ static int
 mask_line_callback (const BoxType * b, void *cl)
 {
   LineType *line = (LineType *)b;
+  hidGC gc = cl;
 
   hid_draw_pcb_line (Output.pmGC, line);
   return 1;
@@ -615,6 +630,7 @@ static int
 mask_arc_callback (const BoxType * b, void *cl)
 {
   ArcType *arc = (ArcType *)b;
+  hidGC gc = cl;
 
   hid_draw_pcb_arc (Output.pmGC, arc);
   return 1;
@@ -623,16 +639,13 @@ mask_arc_callback (const BoxType * b, void *cl)
 static int
 mask_text_callback (const BoxType * b, void *cl)
 {
-  LayerType *layer = cl;
   TextType *text = (TextType *)b;
+  hidGC gc = cl;
   int min_silk_line;
 
-  if (layer == &PCB->Data->SILKLAYER ||
-      layer == &PCB->Data->BACKSILKLAYER)
-    min_silk_line = PCB->minSlk;
-  else
-    min_silk_line = PCB->minWid;
-  hid_draw_pcb_text (Output.fgGC, text, min_silk_line);
+  min_silk_line = PCB->minSlk;
+
+  hid_draw_pcb_text (gc, text, min_silk_line);
   return 1;
 }
 
@@ -640,36 +653,38 @@ mask_text_callback (const BoxType * b, void *cl)
  * draws solder mask layer - this will cover nearly everything
  */
 void
-DrawMask (int side, const BoxType *screen)
+DrawMask (hidGC gc, int side)
 {
   int thin = TEST_FLAG(THINDRAWFLAG, PCB) || TEST_FLAG(THINDRAWPOLYFLAG, PCB);
   LayerType *Layer = LAYER_PTR (side == TOP_SIDE ? top_soldermask_layer : bottom_soldermask_layer);
-  struct poly_info info;
+  struct side_info info;
+  HID_DRAW *hid_draw = gc->hid_draw;
+
+  info.gc = gc;
+  info.side = side;
 
   if (thin)
     hid_draw_set_color (Output.pmGC, PCB->MaskColor);
   else
     {
-      DrawMaskBoardArea (HID_MASK_BEFORE, screen);
+      DrawMaskBoardArea (gc, HID_MASK_BEFORE);
       hid_draw_use_mask (hid_draw, HID_MASK_CLEAR);
     }
 
-  info.layer = Layer;
-  info.drawn_area = screen;
-  r_search (Layer->polygon_tree, screen, NULL, mask_poly_callback, &info);
-  r_search (Layer->line_tree,    screen, NULL, mask_line_callback, Layer);
-  r_search (Layer->arc_tree,     screen, NULL, mask_arc_callback,  Layer);
-  r_search (Layer->text_tree,    screen, NULL, mask_text_callback, Layer);
+  r_search (Layer->polygon_tree, hid_draw->clip_box, NULL, mask_poly_callback, gc);
+  r_search (Layer->line_tree,    hid_draw->clip_box, NULL, mask_line_callback, gc);
+  r_search (Layer->arc_tree,     hid_draw->clip_box, NULL, mask_arc_callback,  gc);
+  r_search (Layer->text_tree,    hid_draw->clip_box, NULL, mask_text_callback, gc);
 
-  r_search (PCB->Data->pin_tree, screen, NULL, pin_mask_callback, NULL);
-  r_search (PCB->Data->via_tree, screen, NULL, via_mask_callback, NULL);
-  r_search (PCB->Data->pad_tree, screen, NULL, pad_mask_callback, &side);
+  r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_mask_callback, gc);
+  r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, via_mask_callback, gc);
+  r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_mask_callback, &info);
 
   if (thin)
     hid_draw_set_color (Output.pmGC, "erase");
   else
     {
-      DrawMaskBoardArea (HID_MASK_AFTER, screen);
+      DrawMaskBoardArea (gc, HID_MASK_AFTER);
       hid_draw_use_mask (hid_draw, HID_MASK_OFF);
     }
 }
@@ -678,22 +693,21 @@ DrawMask (int side, const BoxType *screen)
  * draws solder paste layer for a given side of the board
  */
 void
-DrawPaste (int side, const BoxType *drawn_area)
+DrawPaste (hidGC gc, int side)
 {
-  hid_draw_set_color (Output.fgGC, PCB->ElementColor);
+  hid_draw_set_color (gc, PCB->ElementColor);
   ALLPAD_LOOP (PCB->Data);
   {
     if (ON_SIDE (pad, side))
-      dapi->draw_pad_paste (pad, NULL, NULL);
+      dapi->draw_pad_paste (gc, pad, NULL);
   }
   ENDALL_LOOP;
 }
 
 /* static */ void
-DrawRats (HID_DRAW *new_hid_draw, const BoxType *drawn_area)
+DrawRats (hidGC gc)
 {
-  HID_DRAW *old_hid_draw = hid_draw;
-  hid_draw = new_hid_draw;
+  HID_DRAW *hid_draw = gc->hid_draw;
 
   /*
    * XXX lesstif allows positive AND negative drawing in HID_MASK_CLEAR.
@@ -703,11 +717,9 @@ DrawRats (HID_DRAW *new_hid_draw, const BoxType *drawn_area)
 
   if (hid_draw_can_draw_in_mask_clear (hid_draw))
     hid_draw_use_mask (hid_draw, HID_MASK_CLEAR);
-  r_search (PCB->Data->rat_tree, drawn_area, NULL, rat_callback, NULL);
+  r_search (PCB->Data->rat_tree, hid_draw->clip_box, NULL, rat_callback, gc);
   if (hid_draw_can_draw_in_mask_clear (hid_draw))
     hid_draw_use_mask (hid_draw, HID_MASK_OFF);
-
-  hid_draw = old_hid_draw;
 }
 
 /* ---------------------------------------------------------------------------
@@ -715,13 +727,14 @@ DrawRats (HID_DRAW *new_hid_draw, const BoxType *drawn_area)
  * also draws the pins / pads / vias in this layer group.
  */
 void
-DrawLayerGroup (int group, const BoxType *drawn_area)
+DrawLayerGroup (hidGC gc, int group)
 {
   int i, rv = 1;
   int layernum;
   LayerType *Layer;
   int n_entries = PCB->LayerGroups.Number[group];
   Cardinal *layers = PCB->LayerGroups.Entries[group];
+  HID_DRAW *hid_draw = gc->hid_draw;
 
   for (i = n_entries - 1; i >= 0; i--)
     {
@@ -731,13 +744,13 @@ DrawLayerGroup (int group, const BoxType *drawn_area)
           strcmp (Layer->Name, "route") == 0)
         rv = 0;
       if (layernum < max_copper_layer && Layer->On)
-        dapi->draw_layer (Layer, drawn_area, NULL);
+        dapi->draw_layer (gc, Layer, NULL);
     }
   if (n_entries > 1)
     rv = 1;
 
   if (rv && !hid_draw_is_gui (hid_draw))
-    dapi->draw_ppv (group, drawn_area, NULL);
+    dapi->draw_ppv (gc, group, NULL);
 }
 
 static void
@@ -1244,11 +1257,11 @@ DrawObject (int type, void *ptr1, void *ptr2)
 }
 
 static void
-draw_element (ElementType *element)
+draw_element (hidGC gc, ElementType *element)
 {
-  draw_element_package (element);
-  draw_element_name (element);
-  draw_element_pins_and_pads (element);
+  draw_element_package (gc, element);
+  draw_element_name (gc, element);
+  draw_element_pins_and_pads (gc, element);
 }
 
 /* ---------------------------------------------------------------------------
@@ -1256,10 +1269,11 @@ draw_element (ElementType *element)
  */
 
 void
-hid_expose_callback (HID_DRAW *expose_hid_draw, BoxType *region, void *item)
+hid_expose_callback (HID_DRAW *hid_draw, void *item)
 {
-  hid_draw = expose_hid_draw;
-  Output.fgGC = hid_draw_make_gc (hid_draw);
+  hidGC gc;
+
+  gc = hid_draw_make_gc (hid_draw);
   Output.bgGC = hid_draw_make_gc (hid_draw);
   Output.pmGC = hid_draw_make_gc (hid_draw);
 
@@ -1269,13 +1283,13 @@ hid_expose_callback (HID_DRAW *expose_hid_draw, BoxType *region, void *item)
   if (item)
     {
       doing_pinout = true;
-      draw_element ((ElementType *)item);
+      draw_element (gc, (ElementType *)item);
       doing_pinout = false;
     }
   else
-    DrawEverything (region);
+    DrawEverything (gc);
 
-  hid_draw_destroy_gc (Output.fgGC);
+  hid_draw_destroy_gc (gc);
   hid_draw_destroy_gc (Output.bgGC);
   hid_draw_destroy_gc (Output.pmGC);
   hid_draw = NULL;
diff --git a/src/draw.h b/src/draw.h
index e0688ee..e49e39f 100644
--- a/src/draw.h
+++ b/src/draw.h
@@ -66,22 +66,22 @@ void EraseElementPinsAndPads (ElementType *);
 void EraseElementName (ElementType *);
 void EraseObject (int, void *, void *);
 
-void DrawLayerGroup (int side, const BoxType *drawn_area);
-void DrawPaste (int side, const BoxType *drawn_area);
-void DrawSilk (HID_DRAW *hid_draw, int side, const BoxType *drawn_area);
-void DrawMask (int side, const BoxType *drawn_area);
-void DrawHoles (bool draw_plated, bool draw_unplated, const BoxType *drawn_area);
-void PrintAssembly (int side, const BoxType *drawn_area);
+void DrawLayerGroup (hidGC gc, int side);
+void DrawPaste (hidGC gc, int side);
+void DrawSilk (hidGC gc, int side);
+void DrawMask (hidGC gc, int side);
+void DrawHoles (hidGC gc, bool draw_plated, bool draw_unplated);
+void PrintAssembly (hidGC gc, int side);
 
 /* TEMPORARY */
-void ClearPad (PadType *, bool);
-void DrawPinOrViaLowLevel (PinType *, bool);
-void DrawPlainPin (PinType *, bool);
-void DrawPlainVia (PinType *, bool);
-void DrawRegularText (LayerType *, TextType *);
-void DrawEMark (ElementType *, Coord, Coord, bool);
-void DrawHole (PinType *);
-void DrawRats (HID_DRAW *hid_draw, const BoxType *);
+//void ClearPad (hidGC gc, PadType *, bool);
+//void DrawPinOrViaLowLevel (hidGC gc, PinType *, bool);
+//void DrawPlainPin (hidGC gc, PinType *, bool);
+//void DrawPlainVia (hidGC gc, PinType *, bool);
+//void DrawRegularText (hidGC gc, LayerType *, TextType *);
+void DrawEMark (hidGC gc, ElementType *, Coord, Coord, bool);
+//void DrawHole (hidGC gc, PinType *);
+void DrawRats (hidGC gc);
 /* TEMPORARY */
 
 #endif
diff --git a/src/draw_funcs.c b/src/draw_funcs.c
index af411f7..41cb651 100644
--- a/src/draw_funcs.c
+++ b/src/draw_funcs.c
@@ -10,41 +10,41 @@
 void ghid_set_lock_effects (hidGC gc, AnyObjectType *object);
 
 static void
-draw_pin (PinType *pin, const BoxType *drawn_area, void *userdata)
+draw_pin (hidGC gc, PinType *pin, void *userdata)
 {
-  hid_draw_pcb_pv (Output.fgGC, pin, false);
+  hid_draw_pcb_pv (gc, pin, false);
 }
 
 static void
-draw_pin_mask (PinType *pin, const BoxType *drawn_area, void *userdata)
+draw_pin_mask (hidGC gc, PinType *pin, void *userdata)
 {
   hid_draw_pcb_pv (Output.pmGC, pin, true);
 }
 
 static void
-draw_via (PinType *via, const BoxType *drawn_area, void *userdata)
+draw_via (hidGC gc, PinType *via, void *userdata)
 {
-  hid_draw_pcb_pv (Output.fgGC, via, false);
+  hid_draw_pcb_pv (gc, via, false);
 }
 
 static void
-draw_via_mask (PinType *via, const BoxType *drawn_area, void *userdata)
+draw_via_mask (hidGC gc, PinType *via, void *userdata)
 {
   hid_draw_pcb_pv (Output.pmGC, via, true);
 }
 
 static void
-draw_hole (PinType *pv, const BoxType *drawn_area, void *userdata)
+draw_hole (hidGC gc, PinType *pv, void *userdata)
 {
   if (!TEST_FLAG (THINDRAWFLAG, PCB))
     hid_draw_fill_circle (Output.bgGC, pv->X, pv->Y, pv->DrillingHole / 2);
 
   if (TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG (HOLEFLAG, pv))
     {
-      hid_draw_set_line_cap (Output.fgGC, Round_Cap);
-      hid_draw_set_line_width (Output.fgGC, 0);
+      hid_draw_set_line_cap (gc, Round_Cap);
+      hid_draw_set_line_width (gc, 0);
 
-      hid_draw_arc (Output.fgGC, pv->X, pv->Y, pv->DrillingHole / 2, pv->DrillingHole / 2, 0, 360);
+      hid_draw_arc (gc, pv->X, pv->Y, pv->DrillingHole / 2, pv->DrillingHole / 2, 0, 360);
     }
 }
 
@@ -58,13 +58,13 @@ _draw_pad (hidGC gc, PadType *pad, bool clear, bool mask)
 }
 
 static void
-draw_pad (PadType *pad, const BoxType *drawn_area, void *userdata)
+draw_pad (hidGC gc, PadType *pad, void *userdata)
 {
-  _draw_pad (Output.fgGC, pad, false, false);
+  _draw_pad (gc, pad, false, false);
 }
 
 static void
-draw_pad_mask (PadType *pad, const BoxType *drawn_area, void *userdata)
+draw_pad_mask (hidGC gc, PadType *pad, void *userdata)
 {
   if (pad->Mask <= 0)
     return;
@@ -73,25 +73,25 @@ draw_pad_mask (PadType *pad, const BoxType *drawn_area, void *userdata)
 }
 
 static void
-draw_pad_paste (PadType *pad, const BoxType *drawn_area, void *userdata)
+draw_pad_paste (hidGC gc, PadType *pad, void *userdata)
 {
   if (TEST_FLAG (NOPASTEFLAG, pad) || pad->Mask <= 0)
     return;
 
   if (pad->Mask < pad->Thickness)
-    _draw_pad (Output.fgGC, pad, true, true);
+    _draw_pad (gc, pad, true, true);
   else
-    _draw_pad (Output.fgGC, pad, false, false);
+    _draw_pad (gc, pad, false, false);
 }
 
 static void
-draw_line (LineType *line, const BoxType *drawn_area, void *userdata)
+draw_line (hidGC gc, LineType *line, void *userdata)
 {
-  hid_draw_pcb_line (Output.fgGC, line);
+  hid_draw_pcb_line (gc, line);
 }
 
 static void
-draw_rat (RatType *rat, const BoxType *drawn_area, void *userdata)
+draw_rat (hidGC gc, RatType *rat, void *userdata)
 {
   if (Settings.RatThickness < 100)
     rat->Thickness = pixel_slop * Settings.RatThickness;
@@ -101,29 +101,29 @@ draw_rat (RatType *rat, const BoxType *drawn_area, void *userdata)
       int w = rat->Thickness;
 
       if (TEST_FLAG (THINDRAWFLAG, PCB))
-        hid_draw_set_line_width (Output.fgGC, 0);
+        hid_draw_set_line_width (gc, 0);
       else
-        hid_draw_set_line_width (Output.fgGC, w);
-      hid_draw_arc (Output.fgGC, rat->Point1.X, rat->Point1.Y, w * 2, w * 2, 0, 360);
+        hid_draw_set_line_width (gc, w);
+      hid_draw_arc (gc, rat->Point1.X, rat->Point1.Y, w * 2, w * 2, 0, 360);
     }
   else
-    hid_draw_pcb_line (Output.fgGC, (LineType *) rat);
+    hid_draw_pcb_line (gc, (LineType *) rat);
 }
 
 static void
-draw_arc (ArcType *arc, const BoxType *drawn_area, void *userdata)
+draw_arc (hidGC gc, ArcType *arc, void *userdata)
 {
-  hid_draw_pcb_arc (Output.fgGC, arc);
+  hid_draw_pcb_arc (gc, arc);
 }
 
 static void
-draw_poly (PolygonType *polygon, const BoxType *drawn_area, void *userdata)
+draw_poly (hidGC gc, PolygonType *polygon, void *userdata)
 {
-  hid_draw_pcb_polygon (Output.fgGC, polygon, drawn_area);
+  hid_draw_pcb_polygon (gc, polygon);
 }
 
 static void
-set_object_color (AnyObjectType *obj, char *warn_color, char *selected_color,
+set_object_color (hidGC gc, AnyObjectType *obj, char *warn_color, char *selected_color,
                   char *connected_color, char *found_color, char *normal_color)
 {
   char *color;
@@ -134,142 +134,153 @@ set_object_color (AnyObjectType *obj, char *warn_color, char *selected_color,
   else if (found_color     != NULL && TEST_FLAG (FOUNDFLAG,     obj)) color = found_color;
   else                                                                color = normal_color;
 
-  hid_draw_set_color (Output.fgGC, color);
+  hid_draw_set_color (gc, color);
 }
 
 static void
-set_layer_object_color (LayerType *layer, AnyObjectType *obj)
+set_layer_object_color (hidGC gc, LayerType *layer, AnyObjectType *obj)
 {
-  set_object_color (obj, NULL, layer->SelectedColor, PCB->ConnectedColor, PCB->FoundColor, layer->Color);
+  set_object_color (gc, obj, NULL, layer->SelectedColor, PCB->ConnectedColor, PCB->FoundColor, layer->Color);
 }
 
+struct layer_info {
+  hidGC gc;
+  LayerType *layer;
+};
+
 static int
 line_callback (const BoxType * b, void *cl)
 {
-  LayerType *layer = cl;
   LineType *line = (LineType *)b;
+  struct layer_info *info = cl;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)line);
-  set_layer_object_color (layer, (AnyObjectType *) line);
-  dapi->draw_line (line, NULL, NULL);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *)line);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) line);
+  dapi->draw_line (info->gc, line, NULL);
   return 1;
 }
 
 static int
 arc_callback (const BoxType * b, void *cl)
 {
-  LayerType *layer = cl;
   ArcType *arc = (ArcType *)b;
+  struct layer_info *info = cl;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)arc);
-  set_layer_object_color (layer, (AnyObjectType *) arc);
-  dapi->draw_arc (arc, NULL, NULL);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *)arc);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) arc);
+  dapi->draw_arc (info->gc, arc, NULL);
   return 1;
 }
 
-struct poly_info {
-  const const BoxType *drawn_area;
-  LayerType *layer;
-};
-
 static int
 poly_callback (const BoxType * b, void *cl)
 {
-  struct poly_info *i = cl;
   PolygonType *polygon = (PolygonType *)b;
+  struct layer_info *info = cl;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)polygon);
-  set_layer_object_color (i->layer, (AnyObjectType *) polygon);
-  dapi->draw_poly (polygon, i->drawn_area, NULL);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *)polygon);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) polygon);
+  dapi->draw_poly (info->gc, polygon, NULL);
   return 1;
 }
 
 static int
 text_callback (const BoxType * b, void *cl)
 {
-  LayerType *layer = cl;
   TextType *text = (TextType *)b;
+  struct layer_info *info = cl;
   int min_silk_line;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)text);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *)text);
   if (TEST_FLAG (SELECTEDFLAG, text))
-    hid_draw_set_color (Output.fgGC, layer->SelectedColor);
+    hid_draw_set_color (info->gc, info->layer->SelectedColor);
   else
-    hid_draw_set_color (Output.fgGC, layer->Color);
-  if (layer == &PCB->Data->SILKLAYER ||
-      layer == &PCB->Data->BACKSILKLAYER)
+    hid_draw_set_color (info->gc, info->layer->Color);
+  if (info->layer == &PCB->Data->SILKLAYER ||
+      info->layer == &PCB->Data->BACKSILKLAYER)
     min_silk_line = PCB->minSlk;
   else
     min_silk_line = PCB->minWid;
-  hid_draw_pcb_text (Output.fgGC, text, min_silk_line);
+  hid_draw_pcb_text (info->gc, text, min_silk_line);
   return 1;
 }
 
 static void
-set_pv_inlayer_color (PinType *pv, LayerType *layer, int type)
+set_pv_inlayer_color (hidGC gc, PinType *pv, LayerType *layer, int type)
 {
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pv);
-  if (TEST_FLAG (WARNFLAG, pv))          hid_draw_set_color (Output.fgGC, PCB->WarnColor);
-  else if (TEST_FLAG (SELECTEDFLAG, pv)) hid_draw_set_color (Output.fgGC, (type == VIA_TYPE) ? PCB->ViaSelectedColor
-                                                                                             : PCB->PinSelectedColor);
-  else if (TEST_FLAG (FOUNDFLAG, pv))    hid_draw_set_color (Output.fgGC, PCB->ConnectedColor);
-  else                                   hid_draw_set_color (Output.fgGC, layer->Color);
+  ghid_set_lock_effects (gc, (AnyObjectType *)pv);
+  if (TEST_FLAG (WARNFLAG, pv))          hid_draw_set_color (gc, PCB->WarnColor);
+  else if (TEST_FLAG (SELECTEDFLAG, pv)) hid_draw_set_color (gc, (type == VIA_TYPE) ? PCB->ViaSelectedColor
+                                                                                    : PCB->PinSelectedColor);
+  else if (TEST_FLAG (FOUNDFLAG, pv))    hid_draw_set_color (gc, PCB->ConnectedColor);
+  else                                   hid_draw_set_color (gc, layer->Color);
 }
 
 static int
 pin_inlayer_callback (const BoxType * b, void *cl)
 {
-  set_pv_inlayer_color ((PinType *)b, cl, PIN_TYPE);
-  dapi->draw_pin ((PinType *)b, NULL, NULL);
+  struct layer_info *info = cl;
+
+  set_pv_inlayer_color (info->gc, (PinType *)b, info->layer, PIN_TYPE);
+  dapi->draw_pin (info->gc, (PinType *)b, NULL);
   return 1;
 }
 
 static int
 via_inlayer_callback (const BoxType * b, void *cl)
 {
-  set_pv_inlayer_color ((PinType *)b, cl, VIA_TYPE);
-  dapi->draw_via ((PinType *)b, NULL, NULL);
+  struct layer_info *info = cl;
+
+  set_pv_inlayer_color (info->gc, (PinType *)b, info->layer, VIA_TYPE);
+  dapi->draw_via (info->gc, (PinType *)b, NULL);
   return 1;
 }
 
+struct side_info {
+  hidGC gc;
+  LayerType *layer;
+  int side;
+};
+
 static int
 pad_inlayer_callback (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *)b;
-  LayerType *layer = cl;
-  int bottom_group = GetLayerGroupNumberBySide (BOTTOM_SIDE);
-  int group = GetLayerGroupNumberByPointer (layer);
+  struct side_info *info = cl;
 
-  int side = (group == bottom_group) ? BOTTOM_SIDE : TOP_SIDE;
-
-  if (ON_SIDE (pad, side))
+  if (ON_SIDE (pad, info->side))
     {
-      ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pad);
-      if (TEST_FLAG (WARNFLAG, pad))          hid_draw_set_color (Output.fgGC, PCB->WarnColor);
-      else if (TEST_FLAG (SELECTEDFLAG, pad)) hid_draw_set_color (Output.fgGC, PCB->PinSelectedColor);
-      else if (TEST_FLAG (FOUNDFLAG, pad))    hid_draw_set_color (Output.fgGC, PCB->ConnectedColor);
-      else                                    hid_draw_set_color (Output.fgGC, layer->Color);
+      ghid_set_lock_effects (info->gc, (AnyObjectType *)pad);
+      if (TEST_FLAG (WARNFLAG, pad))          hid_draw_set_color (info->gc, PCB->WarnColor);
+      else if (TEST_FLAG (SELECTEDFLAG, pad)) hid_draw_set_color (info->gc, PCB->PinSelectedColor);
+      else if (TEST_FLAG (FOUNDFLAG, pad))    hid_draw_set_color (info->gc, PCB->ConnectedColor);
+      else                                    hid_draw_set_color (info->gc, info->layer->Color);
 
-      dapi->draw_pad (pad, NULL, NULL);
+      dapi->draw_pad (info->gc, pad, NULL);
     }
   return 1;
 }
 
+struct hole_info {
+  hidGC gc;
+  int plated;
+};
+
 static int
 pin_hole_callback (const BoxType * b, void *cl)
 {
   PinType *pin = (PinType *)b;
-  int plated = cl ? *(int *) cl : -1;
+  struct hole_info *info = cl;
 
-  if ((plated == 0 && !TEST_FLAG (HOLEFLAG, pin)) ||
-      (plated == 1 &&  TEST_FLAG (HOLEFLAG, pin)))
+  if ((info->plated == 0 && !TEST_FLAG (HOLEFLAG, pin)) ||
+      (info->plated == 1 &&  TEST_FLAG (HOLEFLAG, pin)))
     return 1;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pin);
-  set_object_color ((AnyObjectType *) pin, PCB->WarnColor,
+  ghid_set_lock_effects (info->gc, (AnyObjectType *)pin);
+  set_object_color (info->gc, (AnyObjectType *) pin, PCB->WarnColor,
                     PCB->PinSelectedColor, NULL, NULL, Settings.BlackColor);
 
-  dapi->draw_pin_hole (pin, NULL, NULL);
+  dapi->draw_pin_hole (info->gc, pin, NULL);
   return 1;
 }
 
@@ -277,41 +288,45 @@ static int
 via_hole_callback (const BoxType * b, void *cl)
 {
   PinType *via = (PinType *)b;
-  int plated = cl ? *(int *) cl : -1;
+  struct hole_info *info = cl;
 
-  if ((plated == 0 && !TEST_FLAG (HOLEFLAG, via)) ||
-      (plated == 1 &&  TEST_FLAG (HOLEFLAG, via)))
+  if ((info->plated == 0 && !TEST_FLAG (HOLEFLAG, via)) ||
+      (info->plated == 1 &&  TEST_FLAG (HOLEFLAG, via)))
     return 1;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)via);
-  set_object_color ((AnyObjectType *) via, PCB->WarnColor,
+  ghid_set_lock_effects (info->gc, (AnyObjectType *)via);
+  set_object_color (info->gc, (AnyObjectType *) via, PCB->WarnColor,
                     PCB->ViaSelectedColor, NULL, NULL, Settings.BlackColor);
 
-  dapi->draw_via_hole (via, NULL, NULL);
+  dapi->draw_via_hole (info->gc, via, NULL);
   return 1;
 }
 
 static int
 pin_callback (const BoxType * b, void *cl)
 {
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)b);
-  set_object_color ((AnyObjectType *)b,
+  hidGC gc = cl;
+
+  ghid_set_lock_effects (gc, (AnyObjectType *)b);
+  set_object_color (gc, (AnyObjectType *)b,
                     PCB->WarnColor, PCB->PinSelectedColor,
                     PCB->ConnectedColor, PCB->FoundColor, PCB->PinColor);
 
-  dapi->draw_pin ((PinType *)b, NULL, NULL);
+  dapi->draw_pin (gc, (PinType *)b, NULL);
   return 1;
 }
 
 static int
 via_callback (const BoxType * b, void *cl)
 {
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)b);
-  set_object_color ((AnyObjectType *)b,
+  hidGC gc = cl;
+
+  ghid_set_lock_effects (gc, (AnyObjectType *)b);
+  set_object_color (gc, (AnyObjectType *)b,
                     PCB->WarnColor, PCB->ViaSelectedColor,
                     PCB->ConnectedColor, PCB->FoundColor, PCB->ViaColor);
 
-  dapi->draw_via ((PinType *)b, NULL, NULL);
+  dapi->draw_via (gc, (PinType *)b, NULL);
   return 1;
 }
 
@@ -319,91 +334,109 @@ static int
 pad_callback (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *) b;
-  int *side = cl;
+  struct side_info *info = cl;
 
-  if (ON_SIDE (pad, *side))
+  if (ON_SIDE (pad, info->side))
     {
-      ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pad);
-      set_object_color ((AnyObjectType *)pad, PCB->WarnColor,
+      ghid_set_lock_effects (info->gc, (AnyObjectType *)pad);
+      set_object_color (info->gc, (AnyObjectType *)pad, PCB->WarnColor,
                         PCB->PinSelectedColor, PCB->ConnectedColor, PCB->FoundColor,
                         FRONT (pad) ? PCB->PinColor : PCB->InvisibleObjectsColor);
 
-      dapi->draw_pad (pad, NULL, NULL);
+      dapi->draw_pad (info->gc, pad, NULL);
     }
   return 1;
 }
 
 static void
-draw_ppv (int group, const BoxType *drawn_area, void *userdata)
+draw_ppv (hidGC gc, int group, void *userdata)
 {
+  HID_DRAW *hid_draw = gc->hid_draw;
   int top_group = GetLayerGroupNumberBySide (TOP_SIDE);
   int bottom_group = GetLayerGroupNumberBySide (BOTTOM_SIDE);
-  int side;
 
   if (PCB->PinOn || !gui->gui)
     {
+      struct side_info info;
+
       /* draw element pins */
-      r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_callback, NULL);
+      r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_callback, gc);
+
+      info.gc = gc;
+      info.layer = NULL; /* Nasty, but saves creating a load of different info types */
 
       /* draw element pads */
       if (group == top_group)
         {
-          side = TOP_SIDE;
-          r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, &side);
+          info.side = TOP_SIDE;
+          r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_callback, &info);
         }
 
       if (group == bottom_group)
         {
-          side = BOTTOM_SIDE;
-          r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, &side);
+          info.side = BOTTOM_SIDE;
+          r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_callback, &info);
         }
     }
 
   /* draw vias */
   if (PCB->ViaOn)
-    r_search (PCB->Data->via_tree, drawn_area, NULL, via_callback, NULL);
+    r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, via_callback, gc);
 
-  dapi->draw_holes (-1, drawn_area, NULL);
+  dapi->draw_holes (gc, -1, NULL);
 }
 
 static void
-draw_holes (int plated, const BoxType *drawn_area, void *userdata)
+draw_holes (hidGC gc, int plated, void *userdata)
 {
+  HID_DRAW *hid_draw = gc->hid_draw;
+  struct hole_info info;
+
+  info.gc = gc;
+  info.plated = plated;
+
   if (PCB->PinOn)
-    r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_hole_callback, &plated);
+    r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_hole_callback, &info);
   if (PCB->ViaOn)
-    r_search (PCB->Data->via_tree, drawn_area, NULL, via_hole_callback, &plated);
+    r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, via_hole_callback, &info);
 }
 
 static void
-draw_layer (LayerType *layer, const BoxType *drawn_area, void *userdata)
+draw_layer (hidGC gc, LayerType *layer, void *userdata)
 {
+  HID_DRAW *hid_draw = gc->hid_draw;
   int top_group = GetLayerGroupNumberBySide (TOP_SIDE);
   int bottom_group = GetLayerGroupNumberBySide (BOTTOM_SIDE);
   int layer_num = GetLayerNumber (PCB->Data, layer);
   int group = GetLayerGroupNumberByPointer (layer);
-  struct poly_info info = {drawn_area, layer};
   bool is_outline;
+  struct hole_info h_info;
+  struct layer_info l_info;
+
+  h_info.gc = gc;
+  h_info.plated = -1; /* Draw both plated and unplated holes */
+  l_info.gc = gc;
+  l_info.layer = layer;
 
   is_outline = strcmp (layer->Name, "outline") == 0 ||
                strcmp (layer->Name, "route") == 0;
 
   if (layer_num < max_copper_layer && !is_outline)
     {
-      r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_hole_callback, NULL);
-      r_search (PCB->Data->via_tree, drawn_area, NULL, via_hole_callback, NULL);
+      r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_hole_callback, &h_info);
+      r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, via_hole_callback, &h_info);
     }
 
   /* print the non-clearing polys */
-  r_search (layer->polygon_tree, drawn_area, NULL, poly_callback, &info);
+  r_search (layer->polygon_tree, hid_draw->clip_box, NULL, poly_callback, &l_info);
 
   if (TEST_FLAG (CHECKPLANESFLAG, PCB))
     return;
 
   /* draw all visible lines this layer */
-  r_search (layer->line_tree, drawn_area, NULL, line_callback, layer);
-  r_search (layer->arc_tree,  drawn_area, NULL, arc_callback,  layer);
-  r_search (layer->text_tree, drawn_area, NULL, text_callback, layer);
+  r_search (layer->line_tree, hid_draw->clip_box, NULL, line_callback, &l_info);
+  r_search (layer->arc_tree,  hid_draw->clip_box, NULL, arc_callback,  &l_info);
+  r_search (layer->text_tree, hid_draw->clip_box, NULL, text_callback, &l_info);
 
   /* We should check for gui->gui here, but it's kinda cool seeing the
      auto-outline magically disappear when you first add something to
@@ -413,9 +446,9 @@ draw_layer (LayerType *layer, const BoxType *drawn_area, void *userdata)
     {
       if (IsLayerEmpty (layer))
         {
-          hid_draw_set_color (Output.fgGC, layer->Color);
-          hid_draw_set_line_width (Output.fgGC, PCB->minWid);
-          hid_draw_rect (Output.fgGC, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
+          hid_draw_set_color (gc, layer->Color);
+          hid_draw_set_line_width (gc, PCB->minWid);
+          hid_draw_rect (gc, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
         }
       return;
     }
@@ -428,17 +461,22 @@ draw_layer (LayerType *layer, const BoxType *drawn_area, void *userdata)
   if (!gui->gui)
     return;
 
-  r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_inlayer_callback, layer);
+  r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_inlayer_callback, &l_info);
 
   /* draw element pads */
-  if (group == top_group)
-    r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_inlayer_callback, layer);
+  if (group == top_group ||
+      group == bottom_group)
+    {
+      struct side_info s_info;
 
-  if (group == bottom_group)
-    r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_inlayer_callback, layer);
+      s_info.gc = gc;
+      s_info.layer = layer;
+      s_info.side = (group == bottom_group) ? BOTTOM_SIDE : TOP_SIDE;
+      r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_inlayer_callback, &s_info);
+    }
 
   /* draw vias */
-  r_search (PCB->Data->via_tree, drawn_area, NULL, via_inlayer_callback, layer);
+  r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, via_inlayer_callback, &l_info);
 }
 
 struct draw_funcs d_f = {
diff --git a/src/draw_funcs.h b/src/draw_funcs.h
index ba4982d..677b397 100644
--- a/src/draw_funcs.h
+++ b/src/draw_funcs.h
@@ -1,20 +1,20 @@
 struct draw_funcs {
-  void (*draw_pin)       (PinType *,     const BoxType *, void *);
-  void (*draw_pin_mask)  (PinType *,     const BoxType *, void *);
-  void (*draw_pin_hole)  (PinType *,     const BoxType *, void *);
-  void (*draw_via)       (PinType *,     const BoxType *, void *);
-  void (*draw_via_mask)  (PinType *,     const BoxType *, void *);
-  void (*draw_via_hole)  (PinType *,     const BoxType *, void *);
-  void (*draw_pad)       (PadType *,     const BoxType *, void *);
-  void (*draw_pad_mask)  (PadType *,     const BoxType *, void *);
-  void (*draw_pad_paste) (PadType *,     const BoxType *, void *);
-  void (*draw_line)      (LineType *,    const BoxType *, void *);
-  void (*draw_rat)       (RatType *,     const BoxType *, void *);
-  void (*draw_arc)       (ArcType *,     const BoxType *, void *);
-  void (*draw_poly)      (PolygonType *, const BoxType *, void *);
-  void (*draw_ppv)       (int,           const BoxType *, void *);
-  void (*draw_holes)     (int,           const BoxType *, void *);
-  void (*draw_layer)     (LayerType *,   const BoxType *, void *);
+  void (*draw_pin)       (hidGC, PinType *,     void *);
+  void (*draw_pin_mask)  (hidGC, PinType *,     void *);
+  void (*draw_pin_hole)  (hidGC, PinType *,     void *);
+  void (*draw_via)       (hidGC, PinType *,     void *);
+  void (*draw_via_mask)  (hidGC, PinType *,     void *);
+  void (*draw_via_hole)  (hidGC, PinType *,     void *);
+  void (*draw_pad)       (hidGC, PadType *,     void *);
+  void (*draw_pad_mask)  (hidGC, PadType *,     void *);
+  void (*draw_pad_paste) (hidGC, PadType *,     void *);
+  void (*draw_line)      (hidGC, LineType *,    void *);
+  void (*draw_rat)       (hidGC, RatType *,     void *);
+  void (*draw_arc)       (hidGC, ArcType *,     void *);
+  void (*draw_poly)      (hidGC, PolygonType *, void *);
+  void (*draw_ppv)       (hidGC, int,           void *);
+  void (*draw_holes)     (hidGC, int,           void *);
+  void (*draw_layer)     (hidGC, LayerType *,   void *);
 };
 
 extern struct draw_funcs *dapi;
diff --git a/src/global.h b/src/global.h
index b36aebf..050d804 100644
--- a/src/global.h
+++ b/src/global.h
@@ -182,8 +182,7 @@ typedef struct
  */
 typedef struct			/* holds information about output window */
 {
-  hidGC bgGC,			/* background and foreground; */
-    fgGC,			/* changed from some routines */
+  hidGC bgGC,			/* background GC */
     pmGC;			/* depth 1 pixmap GC to store clip */
 }
 OutputType;
diff --git a/src/hid.h b/src/hid.h
index 5059273..c5ba6d4 100644
--- a/src/hid.h
+++ b/src/hid.h
@@ -472,13 +472,13 @@ typedef enum
      * May be implemented as a NOOP if the GUI has chosen to send the
      * debug drawing directly to the screen.
      */
-    void (*flush_debug_draw)   (void);
+    void (*flush_debug_draw)   (hidGC gc);
 
     /* When finished, the user must inform the GUI to clean up resources
      *
      * Any remaining rendering will be flushed to the screen.
      */
-    void (*finish_debug_draw)  (void);
+    void (*finish_debug_draw)  (hidGC gc);
 
     /* Notification to the GUI around saving the PCB file.
      *
@@ -533,7 +533,7 @@ typedef enum
    Do *not* assume that the hid that is passed is the GUI hid.  This
    callback is also used for printing and exporting. */
   struct BoxType;
-  void hid_expose_callback (HID_DRAW *hid_draw, struct BoxType *region_, void *item_);
+  void hid_expose_callback (HID_DRAW *hid_draw, void *item_);
 
 /* This is initially set to a "no-gui" gui, and later reset by
    main. hid_expose_callback also temporarily set it for drawing. */
diff --git a/src/hid/common/draw_helpers.c b/src/hid/common/draw_helpers.c
index f4de2c0..1be2d15 100644
--- a/src/hid/common/draw_helpers.c
+++ b/src/hid/common/draw_helpers.c
@@ -7,6 +7,20 @@
 #include "draw_helpers.h"
 
 
+/* Takes a copy of clip_box so we own it */
+void
+common_set_clip_box (HID_DRAW *hid_draw, BoxType *clip_box)
+{
+  free (hid_draw->clip_box);
+  hid_draw->clip_box = NULL;
+
+  if (clip_box == NULL)
+    return;
+
+  hid_draw->clip_box = malloc (sizeof (BoxType));
+  *hid_draw->clip_box = *clip_box;
+}
+
 static void
 common_draw_pcb_line (hidGC gc, LineType *line)
 {
@@ -189,8 +203,9 @@ fill_contour_cb (PLINE *pl, void *user_data)
 }
 
 static void
-fill_clipped_contour (hidGC gc, PLINE *pl, const BoxType *clip_box)
+fill_clipped_contour (hidGC gc, PLINE *pl)
 {
+  HID_DRAW *hid_draw = gc->hid_draw;
   PLINE *pl_copy;
   POLYAREA *clip_poly;
   POLYAREA *piece_poly;
@@ -198,8 +213,8 @@ fill_clipped_contour (hidGC gc, PLINE *pl, const BoxType *clip_box)
   POLYAREA *draw_piece;
   int x;
 
-  clip_poly = RectPoly (clip_box->X1, clip_box->X2,
-                        clip_box->Y1, clip_box->Y2);
+  clip_poly = RectPoly (hid_draw->clip_box->X1, hid_draw->clip_box->X2,
+                        hid_draw->clip_box->Y1, hid_draw->clip_box->Y2);
   poly_CopyContour (&pl_copy, pl);
   piece_poly = poly_Create ();
   poly_InclContour (piece_poly, pl_copy);
@@ -223,20 +238,21 @@ fill_clipped_contour (hidGC gc, PLINE *pl, const BoxType *clip_box)
  */
 #define BOUNDS_INSIDE_CLIP_THRESHOLD 0.5
 static int
-should_compute_no_holes (PolygonType *poly, const BoxType *clip_box)
+should_compute_no_holes (hidGC gc, PolygonType *poly)
 {
+  HID_DRAW *hid_draw = gc->hid_draw;
   Coord x1, x2, y1, y2;
   double poly_bounding_area;
   double clipped_poly_area;
 
   /* If there is no passed clip box, compute the whole thing */
-  if (clip_box == NULL)
+  if (hid_draw->clip_box == NULL)
     return 1;
 
-  x1 = MAX (poly->BoundingBox.X1, clip_box->X1);
-  x2 = MIN (poly->BoundingBox.X2, clip_box->X2);
-  y1 = MAX (poly->BoundingBox.Y1, clip_box->Y1);
-  y2 = MIN (poly->BoundingBox.Y2, clip_box->Y2);
+  x1 = MAX (poly->BoundingBox.X1, hid_draw->clip_box->X1);
+  x2 = MIN (poly->BoundingBox.X2, hid_draw->clip_box->X2);
+  y1 = MAX (poly->BoundingBox.Y1, hid_draw->clip_box->Y1);
+  y2 = MIN (poly->BoundingBox.Y2, hid_draw->clip_box->Y2);
 
   /* Check if the polygon is outside the clip box */
   if ((x2 <= x1) || (y2 <= y1))
@@ -255,15 +271,15 @@ should_compute_no_holes (PolygonType *poly, const BoxType *clip_box)
 #undef BOUNDS_INSIDE_CLIP_THRESHOLD
 
 void
-common_gui_draw_pcb_polygon (hidGC gc, PolygonType *polygon, const BoxType *clip_box)
+common_gui_draw_pcb_polygon (hidGC gc, PolygonType *polygon)
 {
   if (polygon->Clipped == NULL)
     return;
 
   if (TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG (THINDRAWPOLYFLAG, PCB))
-    hid_draw__thin_pcb_polygon (gc, polygon, clip_box);
+    hid_draw__thin_pcb_polygon (gc, polygon);
   else
-    hid_draw__fill_pcb_polygon (gc, polygon, clip_box);
+    hid_draw__fill_pcb_polygon (gc, polygon);
 
   /* If checking planes, thin-draw any pieces which have been clipped away */
   if (TEST_FLAG (CHECKPLANESFLAG, PCB) && !TEST_FLAG (FULLPOLYFLAG, polygon))
@@ -273,13 +289,15 @@ common_gui_draw_pcb_polygon (hidGC gc, PolygonType *polygon, const BoxType *clip
       for (poly.Clipped = polygon->Clipped->f;
            poly.Clipped != polygon->Clipped;
            poly.Clipped = poly.Clipped->f)
-        hid_draw__thin_pcb_polygon (gc, &poly, clip_box);
+        hid_draw__thin_pcb_polygon (gc, &poly);
     }
 }
 
 void
-common_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+common_fill_pcb_polygon (hidGC gc, PolygonType *poly)
 {
+  HID_DRAW *hid_draw = gc->hid_draw;
+
   if (poly->Clipped == NULL)
     return;
 
@@ -289,10 +307,10 @@ common_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
        * NoHoles version and cache it for later rendering, otherwise
        * just compute what we need to render now.
        */
-      if (should_compute_no_holes (poly, clip_box))
+      if (should_compute_no_holes (gc, poly))
         ComputeNoHoles (poly);
       else
-        NoHolesPolygonDicer (poly, clip_box, fill_contour_cb, gc);
+        NoHolesPolygonDicer (poly, hid_draw->clip_box, fill_contour_cb, gc);
     }
   if (poly->NoHolesValid && poly->NoHoles)
     {
@@ -300,10 +318,10 @@ common_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
 
       for (pl = poly->NoHoles; pl != NULL; pl = pl->next)
         {
-          if (clip_box == NULL)
+          if (hid_draw->clip_box == NULL)
             fill_contour (gc, pl);
           else
-            fill_clipped_contour (gc, pl, clip_box);
+            fill_clipped_contour (gc, pl);
         }
     }
 
@@ -316,7 +334,7 @@ common_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
       for (p.Clipped = poly->Clipped->f;
            p.Clipped != poly->Clipped;
            p.Clipped = p.Clipped->f)
-        NoHolesPolygonDicer (&p, clip_box, fill_contour_cb, gc);
+        NoHolesPolygonDicer (&p, hid_draw->clip_box, fill_contour_cb, gc);
     }
 }
 
@@ -329,14 +347,15 @@ thindraw_hole_cb (PLINE *pl, void *user_data)
 }
 
 void
-common_thindraw_pcb_polygon (hidGC gc, PolygonType *poly,
-                             const BoxType *clip_box)
+common_thindraw_pcb_polygon (hidGC gc, PolygonType *poly)
 {
+  HID_DRAW *hid_draw = gc->hid_draw;
+
   if (poly->Clipped == NULL)
     return;
 
   thindraw_contour (gc, poly->Clipped->contours);
-  PolygonHoles (poly, clip_box, thindraw_hole_cb, gc);
+  PolygonHoles (poly, hid_draw->clip_box, thindraw_hole_cb, gc);
 
   /* Draw other parts of the polygon if fullpoly flag is set */
   if (TEST_FLAG (FULLPOLYFLAG, poly))
@@ -348,7 +367,7 @@ common_thindraw_pcb_polygon (hidGC gc, PolygonType *poly,
            p.Clipped = p.Clipped->f)
         {
           thindraw_contour (gc, p.Clipped->contours);
-          PolygonHoles (&p, clip_box, thindraw_hole_cb, gc);
+          PolygonHoles (&p, hid_draw->clip_box, thindraw_hole_cb, gc);
         }
     }
 }
@@ -675,6 +694,6 @@ common_draw_helpers_class_init (HID_DRAW_CLASS *klass)
 }
 
 void
-common_draw_helpers_init (HID_DRAW *graphics)
+common_draw_helpers_init (HID_DRAW *hid_draw)
 {
 }
diff --git a/src/hid/common/draw_helpers.h b/src/hid/common/draw_helpers.h
index 4fca617..ea5c880 100644
--- a/src/hid/common/draw_helpers.h
+++ b/src/hid/common/draw_helpers.h
@@ -1,6 +1,6 @@
-void common_gui_draw_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box);
-void common_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box);
-void common_thindraw_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box);
+void common_gui_draw_pcb_polygon (hidGC gc, PolygonType *poly);
+void common_fill_pcb_polygon (hidGC gc, PolygonType *poly);
+void common_thindraw_pcb_polygon (hidGC gc, PolygonType *poly);
 void common_gui_draw_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask);
 void common_fill_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask);
 void common_thindraw_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask);
@@ -11,4 +11,5 @@ void common_fill_pcb_pv_hole (hidGC gc, PinType *pv);
 void common_thindraw_pcb_pv (hidGC gc, PinType *pv, bool mask);
 void common_thindraw_pcb_pv_hole (hidGC gc, PinType *pv);
 void common_draw_helpers_class_init (HID_DRAW_CLASS *klass);
-void common_draw_helpers_init (HID_DRAW *graphics);
+void common_draw_helpers_init (HID_DRAW *hid_draw);
+void common_set_clip_box (HID_DRAW *hid_draw, BoxType *clip_box);
diff --git a/src/hid/common/extents.c b/src/hid/common/extents.c
index cd679c6..58949c4 100644
--- a/src/hid/common/extents.c
+++ b/src/hid/common/extents.c
@@ -224,7 +224,9 @@ hid_get_extents (void *item)
   region.Y1 = -COORD_MAX - 1;
   region.X2 = COORD_MAX;
   region.Y2 = COORD_MAX;
-  hid_expose_callback (&extents_graphics, &region, item);
+
+  common_set_clip_box (&extents_graphics, &region);
+  hid_expose_callback (&extents_graphics, item);
 
   return &box;
 }
diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index e6b1eaf..f65293a 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -130,9 +130,9 @@ static bool in_context = false;
 
 /* NB: If using VBOs, the caller must ensure the VBO is bound to the GL_ARRAY_BUFFER */
 static void
-hidgl_reset_triangle_array (hidgl_instance *hidgl)
+hidgl_reset_triangle_array (HID_DRAW *hid_draw)
 {
-  hidgl_priv *priv = hidgl->priv;
+  hidgl_priv *priv = hid_draw->priv;
 
   if (priv->buffer.use_map) {
     /* Hint to the driver that we're done with the previous buffer contents */
@@ -158,9 +158,9 @@ hidgl_reset_triangle_array (hidgl_instance *hidgl)
 }
 
 static void
-hidgl_init_triangle_array (hidgl_instance *hidgl)
+hidgl_init_triangle_array (HID_DRAW *hid_draw)
 {
-  hidgl_priv *priv = hidgl->priv;
+  hidgl_priv *priv = hid_draw->priv;
 
   CHECK_IS_IN_CONTEXT ();
 
@@ -189,13 +189,13 @@ hidgl_init_triangle_array (hidgl_instance *hidgl)
   priv->buffer.use_map = false;
 
   priv->buffer.triangle_array = NULL;
-  hidgl_reset_triangle_array (hidgl);
+  hidgl_reset_triangle_array (hid_draw);
 }
 
 static void
-hidgl_finish_triangle_array (hidgl_instance *hidgl)
+hidgl_finish_triangle_array (HID_DRAW *hid_draw)
 {
-  hidgl_priv *priv = hidgl->priv;
+  hidgl_priv *priv = hid_draw->priv;
 
   if (priv->buffer.use_map) {
     glBindBuffer (GL_ARRAY_BUFFER, priv->buffer.vbo_id);
@@ -212,9 +212,9 @@ hidgl_finish_triangle_array (hidgl_instance *hidgl)
 }
 
 void
-hidgl_flush_triangles (hidgl_instance *hidgl)
+hidgl_flush_triangles (HID_DRAW *hid_draw)
 {
-  hidgl_priv *priv = hidgl->priv;
+  hidgl_priv *priv = hid_draw->priv;
   GLfloat *data_pointer = NULL;
 
   CHECK_IS_IN_CONTEXT ();
@@ -253,15 +253,14 @@ hidgl_flush_triangles (hidgl_instance *hidgl)
   glDisableClientState (GL_VERTEX_ARRAY);
   glDisableClientState (GL_TEXTURE_COORD_ARRAY);
 
-  hidgl_reset_triangle_array (hidgl);
+  hidgl_reset_triangle_array (hid_draw);
 }
 
 void
 hidgl_ensure_vertex_space (hidGC gc, int count)
 {
-  hidglGC hidgl_gc = (hidglGC)gc;
-  hidgl_instance *hidgl = hidgl_gc->hidgl;
-  hidgl_priv *priv = hidgl->priv;
+  HID_DRAW *hid_draw = gc->hid_draw;
+  hidgl_priv *priv = hid_draw->priv;
 
   CHECK_IS_IN_CONTEXT ();
 
@@ -273,7 +272,7 @@ hidgl_ensure_vertex_space (hidGC gc, int count)
       exit (1);
     }
   if (count > 3 * TRIANGLE_ARRAY_SIZE - priv->buffer.vertex_count)
-    hidgl_flush_triangles (hidgl);
+    hidgl_flush_triangles (hid_draw);
 }
 
 void
@@ -294,9 +293,10 @@ hidgl_set_depth (hidGC gc, float depth)
 }
 
 void
-hidgl_draw_grid (hidGC gc, BoxType *drawn_area)
+hidgl_draw_grid (hidGC gc)
 {
   hidglGC hidgl_gc = (hidglGC)gc;
+  HID_DRAW *hid_draw = gc->hid_draw;
 
   static GLfloat *points = 0;
   static int npoints = 0;
@@ -306,10 +306,10 @@ hidgl_draw_grid (hidGC gc, BoxType *drawn_area)
   if (!Settings.DrawGrid)
     return;
 
-  x1 = GridFit (MAX (0, drawn_area->X1), PCB->Grid, PCB->GridOffsetX);
-  y1 = GridFit (MAX (0, drawn_area->Y1), PCB->Grid, PCB->GridOffsetY);
-  x2 = GridFit (MIN (PCB->MaxWidth,  drawn_area->X2), PCB->Grid, PCB->GridOffsetX);
-  y2 = GridFit (MIN (PCB->MaxHeight, drawn_area->Y2), PCB->Grid, PCB->GridOffsetY);
+  x1 = GridFit (MAX (0, hid_draw->clip_box->X1), PCB->Grid, PCB->GridOffsetX);
+  y1 = GridFit (MAX (0, hid_draw->clip_box->Y1), PCB->Grid, PCB->GridOffsetY);
+  x2 = GridFit (MIN (PCB->MaxWidth,  hid_draw->clip_box->X2), PCB->Grid, PCB->GridOffsetX);
+  y2 = GridFit (MIN (PCB->MaxHeight, hid_draw->clip_box->Y2), PCB->Grid, PCB->GridOffsetY);
 
   if (x1 > x2)
     {
@@ -753,6 +753,7 @@ hidgl_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
 
   myFreeCombined ();
   free (vertices);
+  tesselator_gc = NULL;
 }
 
 static inline void
@@ -774,8 +775,8 @@ fill_contour (hidGC gc, PLINE *contour)
 {
   hidglGC hidgl_gc = (hidglGC)gc;
 #if MEMCPY_VERTEX_DATA
-  hidgl_instance *hidgl = hidgl_gc->hidgl;
-  hidgl_priv *priv = hidgl->priv;
+  HID_DRAW *hid_draw = gc->hid_draw;
+  hidgl_priv *priv = hid_draw->priv;
 #endif
   int i;
   int vertex_comp;
@@ -913,11 +914,10 @@ polygon_contains_user_holes (PolygonType *polygon)
 }
 
 static void
-fill_polyarea (hidGC gc, POLYAREA *pa, const BoxType *clip_box, bool use_new_stencil)
+fill_polyarea (hidGC gc, POLYAREA *pa, bool use_new_stencil)
 {
-  hidglGC hidgl_gc = (hidglGC)gc;
-  hidgl_instance *hidgl = hidgl_gc->hidgl;
-  hidgl_priv *priv = hidgl->priv;
+  HID_DRAW *hid_draw = gc->hid_draw;
+  hidgl_priv *priv = hid_draw->priv;
   int stencil_bit;
 
   CHECK_IS_IN_CONTEXT ();
@@ -933,7 +933,7 @@ fill_polyarea (hidGC gc, POLYAREA *pa, const BoxType *clip_box, bool use_new_ste
    */
   if (use_new_stencil)
     {
-      stencil_bit = hidgl_assign_clear_stencil_bit (hidgl);
+      stencil_bit = hidgl_assign_clear_stencil_bit (hid_draw);
       if (!stencil_bit)
         {
           printf ("hidgl_fill_pcb_polygon: No free stencil bits, aborting polygon\n");
@@ -943,7 +943,7 @@ fill_polyarea (hidGC gc, POLYAREA *pa, const BoxType *clip_box, bool use_new_ste
     }
 
   /* Flush out any existing geoemtry to be rendered */
-  hidgl_flush_triangles (hidgl);
+  hidgl_flush_triangles (hid_draw);
 
   glPushAttrib (GL_STENCIL_BUFFER_BIT |                 /* Resave the stencil write-mask etc.., and */
                 GL_COLOR_BUFFER_BIT |                   /* the colour buffer write mask etc.. for part way restore */
@@ -970,36 +970,35 @@ fill_polyarea (hidGC gc, POLYAREA *pa, const BoxType *clip_box, bool use_new_ste
 
   /* Drawing operations now set our reference bit in the stencil buffer */
 
-  r_search (pa->contour_tree, clip_box, NULL, do_hole, gc);
-  hidgl_flush_triangles (hidgl);
+  r_search (pa->contour_tree, hid_draw->clip_box, NULL, do_hole, gc);
+  hidgl_flush_triangles (hid_draw);
 
-  glPopAttrib ();                               /* Restore the colour and stencil buffer write-mask etc.. */
-  glPushAttrib (GL_STENCIL_BUFFER_BIT);         /* Save the stencil op and function */
-  glEnable (GL_STENCIL_TEST);                   /* Enable the stencil test, just in case it wasn't already on */
+  glPopAttrib ();                                   /* Restore the colour and stencil buffer write-mask etc.. */
+  glPushAttrib (GL_STENCIL_BUFFER_BIT);             /* Save the stencil op and function */
+  glEnable (GL_STENCIL_TEST);                       /* Enable the stencil test, just in case it wasn't already on */
 
-  glStencilOp (GL_KEEP, GL_KEEP, GL_INVERT);    /* This allows us to toggle the bit on the subcompositing bitplane */
-                                                /* If the stencil test has passed, we know that bit is 0, so we're */
-                                                /* effectively just setting it to 1. */
-
-  glStencilFunc (GL_GEQUAL, 0, priv->assigned_bits);  /* Pass stencil test if all assigned bits clear, */
-                                                /* reference is all assigned bits so we set */
-                                                /* any bits permitted by the stencil writemask */
+  glStencilOp (GL_KEEP, GL_KEEP, GL_INVERT);        /* This allows us to toggle the bit on the subcompositing bitplane */
+                                                    /* If the stencil test has passed, we know that bit is 0, so we're */
+                                                    /* effectively just setting it to 1. */
+  glStencilFunc (GL_GEQUAL, 0, priv->assigned_bits);/* Pass stencil test if all assigned bits clear, */
+                                                    /* reference is all assigned bits so we set */
+                                                    /* any bits permitted by the stencil writemask */
 
   /* Drawing operations as masked to areas where the stencil buffer is '0' */
 
   /* Draw the polygon outer */
   fill_contour (gc, pa->contours);
-  hidgl_flush_triangles (hidgl);
+  hidgl_flush_triangles (hid_draw);
 
   /* Unassign our stencil buffer bit */
   if (use_new_stencil)
-    hidgl_return_stencil_bit (hidgl, stencil_bit);
+    hidgl_return_stencil_bit (hid_draw, stencil_bit);
 
   glPopAttrib ();                               /* Restore the stencil buffer op and function */
 }
 
 void
-hidgl_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+hidgl_fill_pcb_polygon (hidGC gc, PolygonType *poly)
 {
   bool use_new_stencil;
 
@@ -1009,14 +1008,14 @@ hidgl_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
   use_new_stencil = polygon_contains_user_holes (poly) ||
                     TEST_FLAG (FULLPOLYFLAG, poly);
 
-  fill_polyarea (gc, poly->Clipped, clip_box, use_new_stencil);
+  fill_polyarea (gc, poly->Clipped, use_new_stencil);
 
   if (TEST_FLAG (FULLPOLYFLAG, poly))
     {
       POLYAREA *pa;
 
       for (pa = poly->Clipped->f; pa != poly->Clipped; pa = pa->f)
-        fill_polyarea (gc, pa, clip_box, use_new_stencil);
+        fill_polyarea (gc, pa, use_new_stencil);
     }
 }
 
@@ -1136,15 +1135,19 @@ hidgl_init (void)
   called = true;
 }
 
-hidgl_instance *
-hidgl_new_instance (void)
+void
+hidgl_class_init (HID_DRAW_CLASS *klass)
+{
+  /* XXX: For now, our sub-classes have all the v-func methods, and they call us as required */
+}
+
+void
+hidgl_instance_init (HID_DRAW *hid_draw)
 {
-  hidgl_instance *hidgl;
   hidgl_priv *priv;
 
-  hidgl = calloc (1, sizeof (hidgl_instance));
   priv = calloc (1, sizeof (hidgl_priv));
-  hidgl->priv = priv;
+  hid_draw->priv = priv;
 
 #if 0
   glGetIntegerv (GL_STENCIL_BITS, &priv->stencil_bits);
@@ -1162,28 +1165,25 @@ hidgl_new_instance (void)
       /* Do we need to disable that somewhere? */
     }
 
-  hidgl_reset_stencil_usage (hidgl);
+  hidgl_reset_stencil_usage (hid_draw);
 #endif
-//  hidgl_init_triangle_array (hidgl);
-
-  return hidgl;
+//  hidgl_init_triangle_array (hid_draw);
 }
 
 void
-hidgl_free_instance (hidgl_instance *hidgl)
+hidgl_free_instance (HID_DRAW *hid_draw)
 {
-  free (hidgl->priv);
-  free (hidgl);
+  free (hid_draw->priv);
+  free (hid_draw);
 }
 
 void
-hidgl_init_gc (hidgl_instance *hidgl, hidGC gc)
+hidgl_init_gc (HID_DRAW *hid_draw, hidGC gc)
 {
   hidglGC hidgl_gc = (hidglGC)gc;
 
   CHECK_IS_IN_CONTEXT ();
 
-  hidgl_gc->hidgl = hidgl;
   hidgl_gc->depth = 0.0;
 }
 
@@ -1193,9 +1193,9 @@ hidgl_finish_gc (hidGC gc)
 }
 
 void
-hidgl_start_render (hidgl_instance *hidgl)
+hidgl_start_render (HID_DRAW *hid_draw)
 {
-  hidgl_priv *priv = hidgl->priv;
+  hidgl_priv *priv = hid_draw->priv;
   static bool called = false;
 
   if (in_context)
@@ -1230,33 +1230,33 @@ hidgl_start_render (hidgl_instance *hidgl)
     }
 #endif
 
-  hidgl_init_triangle_array (hidgl);
+  hidgl_init_triangle_array (hid_draw);
   hidgl_shader_activate (/*priv->*/circular_program);
 }
 
 void
-hidgl_finish_render (hidgl_instance *hidgl)
+hidgl_finish_render (HID_DRAW *hid_draw)
 {
   if (!in_context)
     fprintf (stderr, "hidgl: hidgl_finish_render() - Not currently in rendering context!\n");
 
-  hidgl_finish_triangle_array (hidgl);
+  hidgl_finish_triangle_array (hid_draw);
   hidgl_shader_activate (NULL);
   in_context = false;
 }
 
 int
-hidgl_stencil_bits (hidgl_instance *hidgl)
+hidgl_stencil_bits (HID_DRAW *hid_draw)
 {
-  hidgl_priv *priv = hidgl->priv;
+  hidgl_priv *priv = hid_draw->priv;
 
   return priv->stencil_bits;
 }
 
 static void
-hidgl_clean_unassigned_stencil (hidgl_instance *hidgl)
+hidgl_clean_unassigned_stencil (HID_DRAW *hid_draw)
 {
-  hidgl_priv *priv = hidgl->priv;
+  hidgl_priv *priv = hid_draw->priv;
 
   CHECK_IS_IN_CONTEXT ();
 
@@ -1268,9 +1268,9 @@ hidgl_clean_unassigned_stencil (hidgl_instance *hidgl)
 }
 
 int
-hidgl_assign_clear_stencil_bit (hidgl_instance *hidgl)
+hidgl_assign_clear_stencil_bit (HID_DRAW *hid_draw)
 {
-  hidgl_priv *priv = hidgl->priv;
+  hidgl_priv *priv = hid_draw->priv;
 
   int stencil_bitmask = (1 << priv->stencil_bits) - 1;
   int test;
@@ -1299,7 +1299,7 @@ hidgl_assign_clear_stencil_bit (hidgl_instance *hidgl)
     }
 
   /* Didn't find any non dirty planes. Clear those dirty ones which aren't in use */
-  hidgl_clean_unassigned_stencil (hidgl);
+  hidgl_clean_unassigned_stencil (hid_draw);
   priv->assigned_bits |= first_dirty;
   priv->dirty_bits = priv->assigned_bits;
 
@@ -1307,17 +1307,17 @@ hidgl_assign_clear_stencil_bit (hidgl_instance *hidgl)
 }
 
 void
-hidgl_return_stencil_bit (hidgl_instance *hidgl, int bit)
+hidgl_return_stencil_bit (HID_DRAW *hid_draw, int bit)
 {
-  hidgl_priv *priv = hidgl->priv;
+  hidgl_priv *priv = hid_draw->priv;
 
   priv->assigned_bits &= ~bit;
 }
 
 void
-hidgl_reset_stencil_usage (hidgl_instance *hidgl)
+hidgl_reset_stencil_usage (HID_DRAW *hid_draw)
 {
-  hidgl_priv *priv = hidgl->priv;
+  hidgl_priv *priv = hid_draw->priv;
 
   priv->assigned_bits = 0;
   priv->dirty_bits = 0;
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index e2d7f67..042476b 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -52,18 +52,11 @@ typedef struct {
 
 } hidgl_priv;
 
-/* NB: hidgl_instance is a public type, intended to be used as an opaque pointer */
-typedef struct {
-  hidgl_priv *priv;
-
-} hidgl_instance;
 
 /* NB: hidglGC is a semi-private type, only defined here to enable inlining of geometry creation, and for derived GUIs to extend */
 typedef struct hidgl_gc_struct {
   struct hid_gc_struct gc; /* Parent */
 
-  hidgl_instance *hidgl;
-
   float depth;
 
 } *hidglGC;
@@ -71,7 +64,7 @@ typedef struct hidgl_gc_struct {
 extern hidgl_shader *circular_program;
 extern hidgl_shader *resistor_program;
 
-void hidgl_flush_triangles (hidgl_instance *hidgl);
+void hidgl_flush_triangles (HID_DRAW *hid_draw);
 void hidgl_ensure_vertex_space (hidGC gc, int count);
 void hidgl_ensure_triangle_space (hidGC gc, int count);
 
@@ -81,9 +74,8 @@ hidgl_add_vertex_3D_tex (hidGC gc,
                          GLfloat x, GLfloat y, GLfloat z,
                          GLfloat s, GLfloat t)
 {
-  hidglGC hidgl_gc = (hidglGC)gc;
-  hidgl_instance *hidgl = hidgl_gc->hidgl;
-  hidgl_priv *priv = hidgl->priv;
+  HID_DRAW *hid_draw = gc->hid_draw;
+  hidgl_priv *priv = hid_draw->priv;
 
   priv->buffer.triangle_array [priv->buffer.coord_comp_count++] = x;
   priv->buffer.triangle_array [priv->buffer.coord_comp_count++] = y;
@@ -155,27 +147,29 @@ hidgl_add_triangle (hidGC gc,
                              x3, y3, hidgl_gc->depth);
 }
 
-void hidgl_draw_grid (hidGC gc, BoxType *drawn_area);
+void hidgl_draw_grid (hidGC gc);
 void hidgl_set_depth (hidGC gc, float depth);
 void hidgl_draw_line (hidGC gc, int cap, Coord width, Coord x1, Coord y1, Coord x2, Coord y2, double scale);
 void hidgl_draw_arc (hidGC gc, Coord width, Coord vx, Coord vy, Coord vrx, Coord vry, Angle start_angle, Angle delta_angle, double scale);
 void hidgl_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2);
 void hidgl_fill_circle (hidGC gc, Coord vx, Coord vy, Coord vr);
 void hidgl_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y);
-void hidgl_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box);
+void hidgl_fill_pcb_polygon (hidGC gc, PolygonType *poly);
 void hidgl_fill_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2);
 
 void hidgl_init (void);
-hidgl_instance *hidgl_new_instance (void);
-void hidgl_free_instance (hidgl_instance *hidgl);
-void hidgl_init_gc (hidgl_instance *hidgl, hidGC gc);
+HID_DRAW *hidgl_new_instance (void);
+void hidgl_class_init (HID_DRAW_CLASS *klass);
+void hidgl_instance_init (HID_DRAW *hid_draw);
+void hidgl_free_instance (HID_DRAW *hid_draw);
+void hidgl_init_gc (HID_DRAW *hid_draw, hidGC gc);
 void hidgl_finish_gc (hidGC gc);
-void hidgl_start_render (hidgl_instance *hidgl);
-void hidgl_finish_render (hidgl_instance *hidgl);
-int hidgl_stencil_bits (hidgl_instance *hidgl);
-int hidgl_assign_clear_stencil_bit (hidgl_instance *hidgl);
-void hidgl_return_stencil_bit (hidgl_instance *hidgl, int bit);
-void hidgl_reset_stencil_usage (hidgl_instance *hidgl);
+void hidgl_start_render (HID_DRAW *hid_draw);
+void hidgl_finish_render (HID_DRAW *hid_draw);
+int hidgl_stencil_bits (HID_DRAW *hid_draw);
+int hidgl_assign_clear_stencil_bit (HID_DRAW *hid_draw);
+void hidgl_return_stencil_bit (HID_DRAW *hid_draw, int bit);
+void hidgl_reset_stencil_usage (HID_DRAW *hid_draw);
 
 /* hidgl_pacakge_acy_resistor.c */
 void hidgl_draw_acy_resistor (ElementType *element, float surface_depth, float board_thickness);
diff --git a/src/hid/common/hidnogui.c b/src/hid/common/hidnogui.c
index f4b8d2d..cb291e4 100644
--- a/src/hid/common/hidnogui.c
+++ b/src/hid/common/hidnogui.c
@@ -143,7 +143,7 @@ nogui_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
 }
 
 static void
-nogui_draw_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+nogui_draw_pcb_polygon (hidGC gc, PolygonType *poly)
 {
   CRASH;
 }
@@ -425,12 +425,12 @@ nogui_request_debug_draw (void)
 }
 
 static void
-nogui_flush_debug_draw (void)
+nogui_flush_debug_draw (hidGC gc)
 {
 }
 
 static void
-nogui_finish_debug_draw (void)
+nogui_finish_debug_draw (hidGC gc)
 {
 }
 
diff --git a/src/hid/gcode/gcode.c b/src/hid/gcode/gcode.c
index c6c749d..0e00f50 100644
--- a/src/hid/gcode/gcode.c
+++ b/src/hid/gcode/gcode.c
@@ -467,10 +467,12 @@ gcode_start_png_export ()
   region.X2 = PCB->MaxWidth;
   region.Y2 = PCB->MaxHeight;
 
+
   linewidth = -1;
   lastbrush = (gdImagePtr)((void *) -1);
 
-  hid_expose_callback (&gcode_graphics, &region, 0);
+  common_set_clip_box (&gcode_graphics, &region);
+  hid_expose_callback (&gcode_graphics, 0);
 }
 
 static FILE *
diff --git a/src/hid/gerber/gerber.c b/src/hid/gerber/gerber.c
index 6e4616e..f5c6e46 100644
--- a/src/hid/gerber/gerber.c
+++ b/src/hid/gerber/gerber.c
@@ -676,17 +676,20 @@ gerber_do_export (HID_Attr_Val * options)
   region.X2 = PCB->MaxWidth;
   region.Y2 = PCB->MaxHeight;
 
+#warning NULL gc
+  common_set_clip_box (NULL, &region);
+
   pagecount = 1;
   resetApertures ();
 
   lastgroup = -1;
   layer_list_idx = 0;
   finding_apertures = 1;
-  hid_expose_callback (&gerber_graphics, &region, 0);
+  hid_expose_callback (&gerber_graphics, 0);
 
   layer_list_idx = 0;
   finding_apertures = 0;
-  hid_expose_callback (&gerber_graphics, &region, 0);
+  hid_expose_callback (&gerber_graphics, 0);
 
   memcpy (LayerStack, saved_layer_stack, sizeof (LayerStack));
 
@@ -910,12 +913,12 @@ gerber_set_layer (HID_DRAW *hid_draw, const char *name, int group, int empty)
       && strcmp (name, "outline")
       && strcmp (name, "route"))
     {
+      hidGC gc = hid_draw_make_gc (&gerber_graphics);
       if (outline_layer
 	  && outline_layer != PCB->Data->Layer+idx)
-	dapi->draw_layer (outline_layer, &region, NULL);
+	dapi->draw_layer (gc, outline_layer, NULL);
       else if (!outline_layer)
 	{
-	  hidGC gc = hid_draw_make_gc (&gerber_graphics);
 	  printf("name %s idx %d\n", name, idx);
 	  if (SL_TYPE (idx) == SL_SILK)
 	    hid_draw_set_line_width (gc, PCB->minSlk);
@@ -927,8 +930,8 @@ gerber_set_layer (HID_DRAW *hid_draw, const char *name, int group, int empty)
 	  hid_draw_line (gc, 0, 0, 0, PCB->MaxHeight);
 	  hid_draw_line (gc, PCB->MaxWidth, 0, PCB->MaxWidth, PCB->MaxHeight);
 	  hid_draw_line (gc, 0, PCB->MaxHeight, PCB->MaxWidth, PCB->MaxHeight);
-	  hid_draw_destroy_gc (gc);
 	}
+      hid_draw_destroy_gc (gc);
     }
 
   return 1;
diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index 0815245..1606466 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -15,7 +15,8 @@
 #endif
 
 extern HID ghid_hid;
-extern HID_DRAW ghid_graphics;
+HID_DRAW ghid_graphics;
+extern HID_DRAW_CLASS ghid_graphics_class;
 
 /* Sets priv->u_gc to the "right" GC to use (wrt mask or window)
 */
@@ -816,6 +817,9 @@ redraw_region (GdkRectangle *rect)
   region.Y1 = MAX (0, MIN (PCB->MaxHeight, region.Y1));
   region.Y2 = MAX (0, MIN (PCB->MaxHeight, region.Y2));
 
+#warning NULL gc
+//  common_set_clip_box (NULL, &region);
+
   eleft = Vx (0);
   eright = Vx (PCB->MaxWidth);
   etop = Vy (0);
@@ -860,7 +864,7 @@ redraw_region (GdkRectangle *rect)
 
   ghid_draw_bg_image();
 
-  hid_expose_callback (&ghid_graphics, &region, 0);
+  hid_expose_callback (&ghid_graphics, 0);
   ghid_draw_grid ();
 
   /* In some cases we are called with the crosshair still off */
@@ -1111,9 +1115,18 @@ draw_crosshair (render_priv *priv)
 void
 ghid_init_renderer (int *argc, char ***argv, GHidPort *port)
 {
+  /* Init ghid_graphics HID_DRAW instance */
+  memset (&ghid_graphics, 0, sizeof (HID_DRAW));
+
+  ghid_graphics.klass = &ghid_graphics_class;
+  ghid_graphics.poly_after = true;
+  common_draw_helpers_init (&ghid_graphics);
+
   /* Init any GC's required */
   port->render_priv = g_new0 (render_priv, 1);
   port->render_priv->crosshair_gc = hid_draw_make_gc (&ghid_graphics);
+
+  ghid_graphics .
 }
 
 void
@@ -1238,7 +1251,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
                       0, 0, allocation.width, allocation.height);
 
   /* call the drawing routine */
-  hid_expose_callback (&ghid_graphics, NULL, pinout->element);
+  hid_expose_callback (&ghid_graphics, pinout->element);
 
   gport->drawable = save_drawable;
   gport->view = save_view;
@@ -1295,7 +1308,8 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   region.Y1 = MAX (0, MIN (PCB->MaxHeight, region.Y1));
   region.Y2 = MAX (0, MIN (PCB->MaxHeight, region.Y2));
 
-  hid_expose_callback (&ghid_graphics, &region, NULL);
+  common_set_clip_box (&ghid_graphics, &region);
+  hid_expose_callback (&ghid_graphics, NULL);
 
   gport->drawable = save_drawable;
   gport->view = save_view;
@@ -1314,16 +1328,16 @@ ghid_request_debug_draw (void)
 }
 
 void
-ghid_flush_debug_draw (void)
+ghid_flush_debug_draw (hidGC gc)
 {
   ghid_screen_update ();
   gdk_flush ();
 }
 
 void
-ghid_finish_debug_draw (void)
+ghid_finish_debug_draw (hidGC gc)
 {
-  ghid_flush_debug_draw ();
+  ghid_flush_debug_draw (gc);
   /* No special tear down requirements
    */
 }
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 43ec65f..832fb0c 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -52,11 +52,9 @@ extern PFNGLUSEPROGRAMPROC         glUseProgram;
 //#define VIEW_ORTHO
 
 extern HID ghid_hid;
-extern HID_DRAW ghid_graphics;
+static HID_DRAW ghid_graphics;
 extern HID_DRAW_CLASS ghid_graphics_class;
 
-static hidGC current_gc = NULL;
-
 /* Sets gport->u_gc to the "right" GC to use (wrt mask or window)
 */
 #define USE_GC(gc) if (!use_gc(gc)) return
@@ -95,7 +93,7 @@ typedef struct render_priv {
   Coord lead_user_x;
   Coord lead_user_y;
 
-  hidgl_instance *hidgl;
+  HID_DRAW *hid_draw;
   GList *active_gc_list;
   double edit_depth;
 
@@ -238,18 +236,18 @@ compute_depth (int group)
 }
 
 static void
-start_subcomposite (hidgl_instance *hidgl)
+start_subcomposite (HID_DRAW *hid_draw)
 {
   render_priv *priv = gport->render_priv;
   int stencil_bit;
 
   /* Flush out any existing geoemtry to be rendered */
-  hidgl_flush_triangles (hidgl);
+  hidgl_flush_triangles (hid_draw);
 
   glEnable (GL_STENCIL_TEST);                                 /* Enable Stencil test */
   glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);                 /* Stencil pass => replace stencil value (with 1) */
 
-  stencil_bit = hidgl_assign_clear_stencil_bit (hidgl);       /* Get a new (clean) bitplane to stencil with */
+  stencil_bit = hidgl_assign_clear_stencil_bit (hid_draw);    /* Get a new (clean) bitplane to stencil with */
   glStencilMask (stencil_bit);                                /* Only write to our subcompositing stencil bitplane */
   glStencilFunc (GL_GREATER, stencil_bit, stencil_bit);       /* Pass stencil test if our assigned bit is clear */
 
@@ -257,14 +255,14 @@ start_subcomposite (hidgl_instance *hidgl)
 }
 
 static void
-end_subcomposite (hidgl_instance *hidgl)
+end_subcomposite (HID_DRAW *hid_draw)
 {
   render_priv *priv = gport->render_priv;
 
   /* Flush out any existing geoemtry to be rendered */
-  hidgl_flush_triangles (hidgl);
+  hidgl_flush_triangles (hid_draw);
 
-  hidgl_return_stencil_bit (hidgl, priv->subcomposite_stencil_bit);  /* Relinquish any bitplane we previously used */
+  hidgl_return_stencil_bit (hid_draw, priv->subcomposite_stencil_bit);  /* Relinquish any bitplane we previously used */
 
   glStencilMask (0);
   glStencilFunc (GL_ALWAYS, 0, 0);                            /* Always pass stencil test */
@@ -307,7 +305,6 @@ int
 ghid_set_layer (HID_DRAW *hid_draw, const char *name, int group, int empty)
 {
   render_priv *priv = gport->render_priv;
-  hidgl_instance *hidgl = priv->hidgl;
   bool group_visible = false;
   bool subcomposite = true;
 
@@ -352,10 +349,10 @@ ghid_set_layer (HID_DRAW *hid_draw, const char *name, int group, int empty)
 	}
     }
 
-  end_subcomposite (hidgl);
+  end_subcomposite (hid_draw);
 
   if (group_visible && subcomposite)
-    start_subcomposite (hidgl);
+    start_subcomposite (hid_draw);
 
   /* Drawing is already flushed by {start,end}_subcomposite */
   set_depth_on_all_active_gc (priv, compute_depth (group));
@@ -364,12 +361,9 @@ ghid_set_layer (HID_DRAW *hid_draw, const char *name, int group, int empty)
 }
 
 static void
-ghid_end_layer ()
+ghid_end_layer (HID_DRAW *graphics)
 {
-  render_priv *priv = gport->render_priv;
-  hidgl_instance *hidgl = priv->hidgl;
-
-  end_subcomposite (hidgl);
+  end_subcomposite (graphics);
 }
 
 void
@@ -391,9 +385,9 @@ ghid_make_gc (HID_DRAW *hid_draw)
   gtkGC gtk_gc = (gtkGC)gc;
 
   gc->hid = &ghid_hid;
-  gc->hid_draw = &ghid_graphics;
+  gc->hid_draw = hid_draw;
 
-  hidgl_init_gc (priv->hidgl, gc);
+  hidgl_init_gc (hid_draw, gc);
 
   gtk_gc->colorname = Settings.BackgroundColor;
   gtk_gc->alpha_mult = 1.0;
@@ -406,7 +400,7 @@ ghid_make_gc (HID_DRAW *hid_draw)
 }
 
 static void
-ghid_draw_grid (hidGC gc, BoxType *drawn_area)
+ghid_draw_grid (hidGC gc)
 {
   if (Vz (PCB->Grid) < MIN_GRID_DISTANCE)
     return;
@@ -428,7 +422,7 @@ ghid_draw_grid (hidGC gc, BoxType *drawn_area)
              gport->grid_color.green / 65535.,
              gport->grid_color.blue / 65535.);
 
-  hidgl_draw_grid (gc, drawn_area);
+  hidgl_draw_grid (gc);
 
   glDisable (GL_COLOR_LOGIC_OP);
   glEnable (GL_STENCIL_TEST);
@@ -543,15 +537,13 @@ ghid_draw_bg_image (void)
 void
 ghid_use_mask (HID_DRAW *hid_draw, enum mask_mode mode)
 {
-  render_priv *priv = gport->render_priv;
-  hidgl_instance *hidgl = priv->hidgl;
   static int stencil_bit = 0;
 
   if (mode == cur_mask)
     return;
 
   /* Flush out any existing geoemtry to be rendered */
-  hidgl_flush_triangles (hidgl);
+  hidgl_flush_triangles (hid_draw);
 
   switch (mode)
     {
@@ -564,7 +556,7 @@ ghid_use_mask (HID_DRAW *hid_draw, enum mask_mode mode)
       glColorMask (0, 0, 0, 0);                             /* Disable writting in color buffer */
       glDepthMask (GL_FALSE);
       glEnable (GL_STENCIL_TEST);                           /* Enable Stencil test */
-      stencil_bit = hidgl_assign_clear_stencil_bit (hidgl); /* Get a new (clean) bitplane to stencil with */
+      stencil_bit = hidgl_assign_clear_stencil_bit (hid_draw); /* Get a new (clean) bitplane to stencil with */
       glStencilFunc (GL_ALWAYS, stencil_bit, stencil_bit);  /* Always pass stencil test, write stencil_bit */
       glStencilMask (stencil_bit);                          /* Only write to our subcompositing stencil bitplane */
       glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);           /* Stencil pass => replace stencil value (with 1) */
@@ -580,7 +572,7 @@ ghid_use_mask (HID_DRAW *hid_draw, enum mask_mode mode)
 
     case HID_MASK_OFF:
       /* Disable stenciling */
-      hidgl_return_stencil_bit (hidgl, stencil_bit);        /* Relinquish any bitplane we previously used */
+      hidgl_return_stencil_bit (hid_draw, stencil_bit);     /* Relinquish any bitplane we previously used */
       glDisable (GL_STENCIL_TEST);                          /* Disable Stencil test */
       break;
     }
@@ -736,7 +728,7 @@ set_gl_color_for_gc (hidGC gc)
   g = g * gtk_gc->saturation + luminance * (1.0 - gtk_gc->saturation);
   b = b * gtk_gc->saturation + luminance * (1.0 - gtk_gc->saturation);
 
-  hidgl_flush_triangles (gtk_gc->hidgl_gc.hidgl);
+  hidgl_flush_triangles (gtk_gc->hidgl_gc.gc.hid_draw);
   glColor4d (r, g, b, a);
 }
 
@@ -814,12 +806,6 @@ ghid_set_line_cap_angle (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
   printf ("ghid_set_line_cap_angle() -- not implemented\n");
 }
 
-static void
-ghid_invalidate_current_gc (void)
-{
-  current_gc = NULL;
-}
-
 static int
 use_gc (hidGC gc)
 {
@@ -829,10 +815,10 @@ use_gc (hidGC gc)
       abort ();
     }
 
-  if (current_gc == gc)
-    return 1;
+//  if (current_gc == gc)
+//    return 1;
 
-  current_gc = gc;
+//  current_gc = gc;
 
   set_gl_color_for_gc (gc);
   return 1;
@@ -885,22 +871,22 @@ ghid_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
 }
 
 void
-ghid_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+ghid_fill_pcb_polygon (hidGC gc, PolygonType *poly)
 {
   USE_GC (gc);
 
-  hidgl_fill_pcb_polygon (gc, poly, clip_box);
+  hidgl_fill_pcb_polygon (gc, poly);
 }
 
 void
-ghid_thindraw_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+ghid_thindraw_pcb_polygon (hidGC gc, PolygonType *poly)
 {
   gtkGC gtk_gc = (gtkGC)gc;
 
   double old_alpha_mult = gtk_gc->alpha_mult;
-  common_thindraw_pcb_polygon (gc, poly, clip_box);
+  common_thindraw_pcb_polygon (gc, poly);
   ghid_set_alpha_mult (gc, gtk_gc->alpha_mult * 0.25);
-  hid_draw__fill_pcb_polygon (gc, poly, clip_box);
+  hid_draw__fill_pcb_polygon (gc, poly);
   ghid_set_alpha_mult (gc, old_alpha_mult);
 }
 
@@ -1045,6 +1031,7 @@ static void
 draw_crosshair (hidGC gc, render_priv *priv)
 {
   gtkGC gtk_gc = (gtkGC)gc;
+
   gint x, y, z;
   static int done_once = 0;
   static GdkColor cross_color;
@@ -1106,12 +1093,24 @@ ghid_init_renderer (int *argc, char ***argv, GHidPort *port)
     }
 
   hidgl_init ();
-  priv->hidgl = hidgl_new_instance ();
 
   /* Setup HID function pointers specific to the GL renderer*/
+  hidgl_class_init (&ghid_graphics_class);
+
   ghid_graphics_class.end_layer = ghid_end_layer;
   ghid_graphics_class._fill_pcb_polygon = ghid_fill_pcb_polygon;
   ghid_graphics_class._thindraw_pcb_polygon = ghid_thindraw_pcb_polygon;
+
+  /* Init ghid_graphics HID_DRAW instance */
+  memset (&ghid_graphics, 0, sizeof (HID_DRAW));
+
+  ghid_graphics.klass = &ghid_graphics_class;
+  ghid_graphics.poly_after = true;
+  common_nogui_graphics_init (&ghid_graphics);
+  common_draw_helpers_init (&ghid_graphics);
+  hidgl_instance_init (&ghid_graphics);
+
+  priv->hid_draw = &ghid_graphics;
 }
 
 void
@@ -1119,7 +1118,7 @@ ghid_shutdown_renderer (GHidPort *port)
 {
   render_priv *priv = port->render_priv;
 
-  hidgl_free_instance (priv->hidgl);
+  hidgl_free_instance (priv->hid_draw);
 
   ghid_cancel_lead_user ();
   g_free (port->render_priv);
@@ -1164,7 +1163,7 @@ ghid_start_drawing (GHidPort *port, GtkWidget *widget)
 
   port->render_priv->in_context = true;
 
-  hidgl_start_render (port->render_priv->hidgl);
+  hidgl_start_render (port->render_priv->hid_draw);
 
   return TRUE;
 }
@@ -1174,7 +1173,7 @@ ghid_end_drawing (GHidPort *port, GtkWidget *widget)
 {
   GdkGLDrawable *pGlDrawable = gtk_widget_get_gl_drawable (widget);
 
-  hidgl_finish_render (port->render_priv->hidgl);
+  hidgl_finish_render (port->render_priv->hid_draw);
 
   if (gdk_gl_drawable_is_double_buffered (pGlDrawable))
     gdk_gl_drawable_swap_buffers (pGlDrawable);
@@ -1196,13 +1195,14 @@ static int
 EMark_callback (const BoxType * b, void *cl)
 {
   ElementType *element = (ElementType *) b;
+  hidGC gc = cl;
 
-  DrawEMark (element, element->MarkX, element->MarkY, !FRONT (element));
+  DrawEMark (gc, element, element->MarkX, element->MarkY, !FRONT (element));
   return 1;
 }
 
 static void
-set_object_color (AnyObjectType *obj, char *warn_color, char *selected_color,
+set_object_color (hidGC gc, AnyObjectType *obj, char *warn_color, char *selected_color,
                   char *connected_color, char *found_color, char *normal_color)
 {
   char *color;
@@ -1213,42 +1213,42 @@ set_object_color (AnyObjectType *obj, char *warn_color, char *selected_color,
   else if (found_color     != NULL && TEST_FLAG (FOUNDFLAG,     obj)) color = found_color;
   else                                                                color = normal_color;
 
-  ghid_set_lock_effects (Output.fgGC, obj);
-  hid_draw_set_color (Output.fgGC, color);
+  ghid_set_lock_effects (gc, obj);
+  hid_draw_set_color (gc, color);
 }
 
 static void
-set_layer_object_color (LayerType *layer, AnyObjectType *obj)
+set_layer_object_color (hidGC gc, LayerType *layer, AnyObjectType *obj)
 {
-  set_object_color (obj, NULL, layer->SelectedColor, PCB->ConnectedColor, PCB->FoundColor, layer->Color);
+  set_object_color (gc, obj, NULL, layer->SelectedColor, PCB->ConnectedColor, PCB->FoundColor, layer->Color);
 }
 
 static void
-set_pv_inlayer_color (PinType *pv, LayerType *layer, int type)
+set_pv_inlayer_color (hidGC gc, PinType *pv, LayerType *layer, int type)
 {
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *) pv);
+  ghid_set_lock_effects (gc, (AnyObjectType *) pv);
 
-  if (TEST_FLAG (WARNFLAG, pv))           hid_draw_set_color (Output.fgGC, PCB->WarnColor);
-  else if (TEST_FLAG (SELECTEDFLAG, pv))  hid_draw_set_color (Output.fgGC, (type == VIA_TYPE) ? PCB->ViaSelectedColor
-                                                                                              : PCB->PinSelectedColor);
-  else if (TEST_FLAG (CONNECTEDFLAG, pv)) hid_draw_set_color (Output.fgGC, PCB->ConnectedColor);
-  else if (TEST_FLAG (FOUNDFLAG, pv))     hid_draw_set_color (Output.fgGC, PCB->FoundColor);
+  if (TEST_FLAG (WARNFLAG, pv))           hid_draw_set_color (gc, PCB->WarnColor);
+  else if (TEST_FLAG (SELECTEDFLAG, pv))  hid_draw_set_color (gc, (type == VIA_TYPE) ? PCB->ViaSelectedColor
+                                                                                     : PCB->PinSelectedColor);
+  else if (TEST_FLAG (CONNECTEDFLAG, pv)) hid_draw_set_color (gc, PCB->ConnectedColor);
+  else if (TEST_FLAG (FOUNDFLAG, pv))     hid_draw_set_color (gc, PCB->FoundColor);
   else
     {
-      int top_group = GetLayerGroupNumberBySide (TOP_SIDE);
+      int top_group    = GetLayerGroupNumberBySide (TOP_SIDE);
       int bottom_group = GetLayerGroupNumberBySide (BOTTOM_SIDE);
-      int this_group      = GetLayerGroupNumberByPointer (layer);
+      int this_group   = GetLayerGroupNumberByPointer (layer);
 
       if (this_group == top_group || this_group == bottom_group)
-        hid_draw_set_color (Output.fgGC, (SWAP_IDENT == (this_group == bottom_group)) ?
-                                         PCB->ViaColor : PCB->InvisibleObjectsColor);
+        hid_draw_set_color (gc, (SWAP_IDENT == (this_group == bottom_group)) ?
+                                PCB->ViaColor : PCB->InvisibleObjectsColor);
       else
-        hid_draw_set_color (Output.fgGC, layer->Color);
+        hid_draw_set_color (gc, layer->Color);
     }
 }
 
 static void
-_draw_pv_name (PinType *pv)
+_draw_pv_name (hidGC gc, PinType *pv)
 {
   BoxType box;
   bool vert;
@@ -1272,8 +1272,8 @@ _draw_pv_name (PinType *pv)
       box.Y1 = pv->Y - pv->Thickness    / 2 + Settings.PinoutTextOffsetY;
     }
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pv);
-  hid_draw_set_color (Output.fgGC, PCB->PinNameColor);
+  ghid_set_lock_effects (gc, (AnyObjectType *)pv);
+  hid_draw_set_color (gc, PCB->PinNameColor);
 
   text.Flags = NoFlags ();
   /* Set font height to approx 56% of pin thickness */
@@ -1282,46 +1282,47 @@ _draw_pv_name (PinType *pv)
   text.Y = box.Y1;
   text.Direction = vert ? 1 : 0;
 
-  hid_draw_pcb_text (Output.fgGC, &text, 0);
+  hid_draw_pcb_text (gc, &text, 0);
 }
 
 static void
-_draw_pv (PinType *pv, bool draw_hole)
+_draw_pv (hidGC gc, PinType *pv, bool draw_hole)
 {
   if (TEST_FLAG (THINDRAWFLAG, PCB))
     {
-      hid_draw__thin_pcb_pv (Output.fgGC, pv, false);
+      hid_draw__thin_pcb_pv (gc, pv, false);
       if (draw_hole)
-        hid_draw__thin_pcb_pv_hole (Output.fgGC, pv);
+        hid_draw__thin_pcb_pv_hole (gc, pv);
     }
   else
     {
-      hid_draw__fill_pcb_pv (Output.fgGC, pv, false);
+      hid_draw__fill_pcb_pv (gc, pv, false);
       if (draw_hole)
         hid_draw__fill_pcb_pv_hole (Output.bgGC, pv);
     }
 
   if (!TEST_FLAG (HOLEFLAG, pv) && TEST_FLAG (DISPLAYNAMEFLAG, pv))
-    _draw_pv_name (pv);
+    _draw_pv_name (gc, pv);
 }
 
 static void
-draw_pin (PinType *pin, bool draw_hole)
+draw_pin (hidGC gc, PinType *pin, bool draw_hole)
 {
-  set_object_color ((AnyObjectType *) pin, PCB->WarnColor, PCB->PinSelectedColor,
+  set_object_color (gc, (AnyObjectType *) pin, PCB->WarnColor, PCB->PinSelectedColor,
                     PCB->ConnectedColor, PCB->FoundColor, PCB->PinColor);
 
-  _draw_pv (pin, draw_hole);
+  _draw_pv (gc, pin, draw_hole);
 }
 
 static int
 pin_callback (const BoxType * b, void *cl)
 {
   PinType *pin = (PinType *) b;
+  hidGC gc = cl;
 
   if (!TEST_FLAG (HOLEFLAG, pin) && TEST_FLAG (DISPLAYNAMEFLAG, pin))
-    _draw_pv_name (pin);
-  draw_pin (pin, TEST_FLAG (THINDRAWFLAG, PCB));
+    _draw_pv_name (gc, pin);
+  draw_pin (gc, pin, TEST_FLAG (THINDRAWFLAG, PCB));
   return 1;
 }
 
@@ -1329,46 +1330,59 @@ static int
 pin_name_callback (const BoxType * b, void *cl)
 {
   PinType *pin = (PinType *) b;
+  hidGC gc = cl;
 
   if (!TEST_FLAG (HOLEFLAG, pin) && TEST_FLAG (DISPLAYNAMEFLAG, pin))
-    _draw_pv_name (pin);
+    _draw_pv_name (gc, pin);
   return 1;
 }
 
+struct layer_info
+{
+  hidGC gc;
+  LayerType *layer;
+};
+
 static int
 pin_inlayer_callback (const BoxType * b, void *cl)
 {
-  set_pv_inlayer_color ((PinType *) b, cl, PIN_TYPE);
-  _draw_pv ((PinType *) b, false);
+  struct layer_info *info = cl;
+
+  set_pv_inlayer_color (info->gc, (PinType *) b, info->layer, PIN_TYPE);
+  _draw_pv (info->gc, (PinType *) b, false);
   return 1;
 }
 
 static void
-draw_via (PinType *via, bool draw_hole)
+draw_via (hidGC gc, PinType *via, bool draw_hole)
 {
-  set_object_color ((AnyObjectType *) via, PCB->WarnColor, PCB->ViaSelectedColor,
+  set_object_color (gc, (AnyObjectType *) via, PCB->WarnColor, PCB->ViaSelectedColor,
                     PCB->ConnectedColor, PCB->FoundColor, PCB->ViaColor);
 
-  _draw_pv (via, draw_hole);
+  _draw_pv (gc, via, draw_hole);
 }
 
 static int
 via_callback (const BoxType * b, void *cl)
 {
-  draw_via ((PinType *)b, TEST_FLAG (THINDRAWFLAG, PCB));
+  hidGC gc = cl;
+
+  draw_via (gc, (PinType *)b, TEST_FLAG (THINDRAWFLAG, PCB));
   return 1;
 }
 
 static int
 via_inlayer_callback (const BoxType * b, void *cl)
 {
-  set_pv_inlayer_color ((PinType *) b, cl, VIA_TYPE);
-  _draw_pv ((PinType *) b, TEST_FLAG (THINDRAWFLAG, PCB));
+  struct layer_info *info = cl;
+
+  set_pv_inlayer_color (info->gc, (PinType *) b, info->layer, VIA_TYPE);
+  _draw_pv (info->gc, (PinType *) b, TEST_FLAG (THINDRAWFLAG, PCB));
   return 1;
 }
 
 static void
-draw_pad_name (PadType *pad)
+draw_pad_name (hidGC gc, PadType *pad)
 {
   BoxType box;
   bool vert;
@@ -1397,8 +1411,8 @@ draw_pad_name (PadType *pad)
       box.Y1 += Settings.PinoutTextOffsetY;
     }
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pad);
-  hid_draw_set_color (Output.fgGC, PCB->PinNameColor);
+  ghid_set_lock_effects (gc, (AnyObjectType *)pad);
+  hid_draw_set_color (gc, PCB->PinNameColor);
 
   text.Flags = NoFlags ();
   /* Set font height to approx 90% of pad thickness */
@@ -1407,7 +1421,7 @@ draw_pad_name (PadType *pad)
   text.Y = box.Y1;
   text.Direction = vert ? 1 : 0;
 
-  hid_draw_pcb_text (Output.fgGC, &text, 0);
+  hid_draw_pcb_text (gc, &text, 0);
 }
 
 static void
@@ -1424,29 +1438,34 @@ _draw_pad (hidGC gc, PadType *pad, bool clear, bool mask)
 }
 
 static void
-draw_pad (PadType *pad)
+draw_pad (hidGC gc, PadType *pad)
 {
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pad);
-  set_object_color ((AnyObjectType *)pad, PCB->WarnColor,
+  ghid_set_lock_effects (gc, (AnyObjectType *)pad);
+  set_object_color (gc, (AnyObjectType *)pad, PCB->WarnColor,
                     PCB->PinSelectedColor, PCB->ConnectedColor, PCB->FoundColor,
                     FRONT (pad) ? PCB->PinColor : PCB->InvisibleObjectsColor);
 
-  _draw_pad (Output.fgGC, pad, false, false);
+  _draw_pad (gc, pad, false, false);
 
   if (TEST_FLAG (DISPLAYNAMEFLAG, pad))
-    draw_pad_name (pad);
+    draw_pad_name (gc, pad);
 }
 
+struct side_info {
+  hidGC gc;
+  int side;
+};
+
 static int
 pad_callback (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *) b;
-  int *side = cl;
+  struct side_info *info = cl;
 
-  if (ON_SIDE (pad, *side)) {
+  if (ON_SIDE (pad, info->side)) {
     if (TEST_FLAG (DISPLAYNAMEFLAG, pad))
-      draw_pad_name (pad);
-    draw_pad (pad);
+      draw_pad_name (info->gc, pad);
+    draw_pad (info->gc, pad);
   }
   return 1;
 }
@@ -1456,7 +1475,9 @@ static int
 hole_callback (const BoxType * b, void *cl)
 {
   PinType *pv = (PinType *) b;
-  int plated = cl ? *(int *) cl : -1;
+  hidGC gc = cl;
+//  int plated = cl ? *(int *) cl : -1;
+  int plated = -1;
 
   if ((plated == 0 && !TEST_FLAG (HOLEFLAG, pv)) ||
       (plated == 1 &&  TEST_FLAG (HOLEFLAG, pv)))
@@ -1466,10 +1487,9 @@ hole_callback (const BoxType * b, void *cl)
     {
       if (!TEST_FLAG (HOLEFLAG, pv))
         {
-          hid_draw_set_line_cap (Output.fgGC, Round_Cap);
-          hid_draw_set_line_width (Output.fgGC, 0);
-          hid_draw_arc (Output.fgGC, pv->X, pv->Y,
-                        pv->DrillingHole / 2, pv->DrillingHole / 2, 0, 360);
+          hid_draw_set_line_cap (gc, Round_Cap);
+          hid_draw_set_line_width (gc, 0);
+          hid_draw_arc (gc, pv->X, pv->Y, pv->DrillingHole / 2, pv->DrillingHole / 2, 0, 360);
         }
     }
   else
@@ -1477,14 +1497,13 @@ hole_callback (const BoxType * b, void *cl)
 
   if (TEST_FLAG (HOLEFLAG, pv))
     {
-      ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pv);
-      set_object_color ((AnyObjectType *) pv, PCB->WarnColor,
+      ghid_set_lock_effects (gc, (AnyObjectType *)pv);
+      set_object_color (gc, (AnyObjectType *) pv, PCB->WarnColor,
                         PCB->ViaSelectedColor, NULL, NULL, Settings.BlackColor);
 
-      hid_draw_set_line_cap (Output.fgGC, Round_Cap);
-      hid_draw_set_line_width (Output.fgGC, 0);
-      hid_draw_arc (Output.fgGC, pv->X, pv->Y,
-                    pv->DrillingHole / 2, pv->DrillingHole / 2, 0, 360);
+      hid_draw_set_line_cap (gc, Round_Cap);
+      hid_draw_set_line_width (gc, 0);
+      hid_draw_arc (gc, pv->X, pv->Y, pv->DrillingHole / 2, pv->DrillingHole / 2, 0, 360);
     }
   return 1;
 }
@@ -1492,92 +1511,86 @@ hole_callback (const BoxType * b, void *cl)
 static int
 line_callback (const BoxType * b, void *cl)
 {
-  LayerType *layer = cl;
   LineType *line = (LineType *)b;
+  struct layer_info *info = cl;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *) line);
-  set_layer_object_color (layer, (AnyObjectType *) line);
-  hid_draw_pcb_line (Output.fgGC, line);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *) line);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) line);
+  hid_draw_pcb_line (info->gc, line);
   return 1;
 }
 
 static int
 arc_callback (const BoxType * b, void *cl)
 {
-  LayerType *layer = cl;
   ArcType *arc = (ArcType *)b;
+  struct layer_info *info = cl;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *) arc);
-  set_layer_object_color (layer, (AnyObjectType *) arc);
-  hid_draw_pcb_arc (Output.fgGC, arc);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *) arc);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) arc);
+  hid_draw_pcb_arc (info->gc, arc);
   return 1;
 }
 
 static int
 text_callback (const BoxType * b, void *cl)
 {
-  LayerType *layer = cl;
   TextType *text = (TextType *)b;
+  struct layer_info *info = cl;
   int min_silk_line;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)text);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *)text);
   if (TEST_FLAG (SELECTEDFLAG, text))
-    hid_draw_set_color (Output.fgGC, layer->SelectedColor);
+    hid_draw_set_color (info->gc, info->layer->SelectedColor);
   else
-    hid_draw_set_color (Output.fgGC, layer->Color);
-  if (layer == &PCB->Data->SILKLAYER ||
-      layer == &PCB->Data->BACKSILKLAYER)
+    hid_draw_set_color (info->gc, info->layer->Color);
+  if (info->layer == &PCB->Data->SILKLAYER ||
+      info->layer == &PCB->Data->BACKSILKLAYER)
     min_silk_line = PCB->minSlk;
   else
     min_silk_line = PCB->minWid;
-  hid_draw_pcb_text (Output.fgGC, text, min_silk_line);
+  hid_draw_pcb_text (info->gc, text, min_silk_line);
   return 1;
 }
 
-struct poly_info
-{
-  LayerType *layer;
-  const BoxType *drawn_area;
-};
-
 static int
 poly_callback (const BoxType * b, void *cl)
 {
-  struct poly_info *i = (struct poly_info *) cl;
   PolygonType *polygon = (PolygonType *) b;
+  struct layer_info *info = cl;
 
-  set_layer_object_color (i->layer, (AnyObjectType *) polygon);
-  hid_draw_pcb_polygon (Output.fgGC, polygon, i->drawn_area);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) polygon);
+  hid_draw_pcb_polygon (info->gc, polygon);
   return 1;
 }
 
 static int
 poly_callback_no_clear (const BoxType * b, void *cl)
 {
-  struct poly_info *i = (struct poly_info *) cl;
   PolygonType *polygon = (PolygonType *) b;
+  struct layer_info *info = cl;
 
   if (TEST_FLAG (CLEARPOLYFLAG, polygon))
     return 0;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *) polygon);
-  set_layer_object_color (i->layer, (AnyObjectType *) polygon);
-  hid_draw_pcb_polygon (Output.fgGC, polygon, i->drawn_area);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *) polygon);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) polygon);
+  hid_draw_pcb_polygon (info->gc, polygon);
   return 1;
 }
 
 static int
 poly_callback_clearing (const BoxType * b, void *cl)
 {
-  struct poly_info *i = (struct poly_info *) cl;
   PolygonType *polygon = (PolygonType *) b;
+  struct layer_info *info = cl;
 
   if (!TEST_FLAG (CLEARPOLYFLAG, polygon))
     return 0;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *) polygon);
-  set_layer_object_color (i->layer, (AnyObjectType *) polygon);
-  hid_draw_pcb_polygon (Output.fgGC, polygon, i->drawn_area);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *) polygon);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) polygon);
+  hid_draw_pcb_polygon (info->gc, polygon);
   return 1;
 }
 
@@ -1596,8 +1609,9 @@ static int
 clearPad_callback (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *) b;
-  int *side = cl;
-  if (ON_SIDE (pad, *side) && pad->Mask)
+  struct side_info *info = cl;
+
+  if (ON_SIDE (pad, info->side) && pad->Mask)
     _draw_pad (Output.pmGC, pad, true, true);
   return 1;
 }
@@ -1614,8 +1628,9 @@ static int
 clearPad_callback_solid (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *) b;
-  int *side = cl;
-  if (ON_SIDE (pad, *side) && pad->Mask)
+  struct side_info *info = cl;
+
+  if (ON_SIDE (pad, info->side) && pad->Mask)
     hid_draw__fill_pcb_pad (Output.pmGC, pad, true, true);
   return 1;
 }
@@ -1634,7 +1649,7 @@ ensure_board_outline (void)
 }
 
 static void
-fill_board_outline (hidGC gc, const BoxType *drawn_area)
+fill_board_outline (hidGC gc)
 {
   PolygonType polygon;
 
@@ -1642,11 +1657,11 @@ fill_board_outline (hidGC gc, const BoxType *drawn_area)
 
   memset (&polygon, 0, sizeof (polygon));
   polygon.Clipped = PCB->Data->outline;
-  if (drawn_area)
-    polygon.BoundingBox = *drawn_area;
+  if (gc->hid_draw->clip_box)
+    polygon.BoundingBox = *gc->hid_draw->clip_box;
   polygon.Flags = NoFlags ();
   SET_FLAG (FULLPOLYFLAG, &polygon);
-  hid_draw__fill_pcb_polygon (gc, &polygon, drawn_area);
+  hid_draw__fill_pcb_polygon (gc, &polygon);
   poly_FreeContours (&polygon.NoHoles);
 }
 
@@ -1677,8 +1692,8 @@ fill_outline_hole_cb (PLINE *pl, void *user_data)
   SET_FLAG (FULLPOLYFLAG, &polygon);
 
   /* XXX: For some reason, common_fill_pcb_polygon doesn't work for all contours here.. not sure why */
-//  common_fill_pcb_polygon (info->gc, &polygon, NULL);
-  hid_draw__fill_pcb_polygon (info->gc, &polygon, NULL);
+//  common_fill_pcb_polygon (info->gc, &polygon);
+  hid_draw__fill_pcb_polygon (info->gc, &polygon);
 
   poly_FreeContours (&polygon.NoHoles);
 
@@ -1688,7 +1703,7 @@ fill_outline_hole_cb (PLINE *pl, void *user_data)
 }
 
 static void
-fill_board_outline_holes (hidGC gc, const BoxType *drawn_area)
+fill_board_outline_holes (hidGC gc)
 {
   render_priv *priv = gport->render_priv;
   PolygonType polygon, p;
@@ -1698,64 +1713,67 @@ fill_board_outline_holes (hidGC gc, const BoxType *drawn_area)
 
   memset (&polygon, 0, sizeof (polygon));
   polygon.Clipped = PCB->Data->outline;
-  if (drawn_area)
-    polygon.BoundingBox = *drawn_area;
+  if (gc->hid_draw->clip_box)
+    polygon.BoundingBox = *gc->hid_draw->clip_box;
   polygon.Flags = NoFlags ();
   SET_FLAG (FULLPOLYFLAG, &polygon);
 
   info.gc = gc;
 
-  PolygonHoles (&polygon, drawn_area, fill_outline_hole_cb, &info);
+  PolygonHoles (&polygon, gc->hid_draw->clip_box, fill_outline_hole_cb, &info);
 
   p = polygon;
   for (p.Clipped = polygon.Clipped->f;
        p.Clipped != polygon.Clipped;
        p.Clipped = p.Clipped->f) {
-    PolygonHoles (&p, drawn_area, fill_outline_hole_cb, &info);
+    PolygonHoles (&p, gc->hid_draw->clip_box, fill_outline_hole_cb, &info);
   }
 
 //  poly_FreeContours (&polygon.NoHoles);
 
-  hidgl_flush_triangles (priv->hidgl);
+  hidgl_flush_triangles (priv->hid_draw);
 }
 
 static void
-GhidDrawMask (int side, BoxType * screen)
+GhidDrawMask (hidGC gc, int side)
 {
 //  static bool first_run = true;
 //  static GLuint texture;
   int thin = TEST_FLAG(THINDRAWFLAG, PCB) || TEST_FLAG(THINDRAWPOLYFLAG, PCB);
   LayerType *Layer = LAYER_PTR (side == TOP_SIDE ? top_soldermask_layer : bottom_soldermask_layer);
-  struct poly_info info;
+  struct layer_info l_info;
+  struct side_info s_info;
+  HID_DRAW *hid_draw = gc->hid_draw;
 
-  OutputType *out = &Output;
+  l_info.gc = gc;
+  l_info.layer = Layer;
+  s_info.gc = gc;
+  s_info.side = side;
 
   if (thin)
     {
       hid_draw_set_line_width (Output.pmGC, 0);
       hid_draw_set_color (Output.pmGC, PCB->MaskColor);
-      r_search (PCB->Data->pin_tree, screen, NULL, clearPin_callback, NULL);
-      r_search (PCB->Data->via_tree, screen, NULL, clearPin_callback, NULL);
-      r_search (PCB->Data->pad_tree, screen, NULL, clearPad_callback, &side);
+      r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, clearPin_callback, NULL);
+      r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, clearPin_callback, NULL);
+      r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, clearPad_callback, &s_info);
       hid_draw_set_color (Output.pmGC, "erase");
     }
 
-  hid_draw_use_mask (&ghid_graphics, HID_MASK_CLEAR);
+  hid_draw_use_mask (hid_draw, HID_MASK_CLEAR);
 
-  info.layer = Layer;
-  info.drawn_area = screen;
-  r_search (Layer->polygon_tree, screen, NULL, poly_callback, &info);
-  r_search (Layer->line_tree, screen, NULL, line_callback, Layer);
-  r_search (Layer->arc_tree, screen, NULL, arc_callback, Layer);
-  r_search (Layer->text_tree, screen, NULL, text_callback, Layer);
+  r_search (Layer->polygon_tree, hid_draw->clip_box, NULL, poly_callback, &s_info);
+  r_search (Layer->line_tree, hid_draw->clip_box, NULL, line_callback, &l_info);
+  r_search (Layer->arc_tree, hid_draw->clip_box, NULL, arc_callback, &l_info);
+  r_search (Layer->text_tree, hid_draw->clip_box, NULL, text_callback, &l_info);
 
-  r_search (PCB->Data->pin_tree, screen, NULL, clearPin_callback_solid, NULL);
-  r_search (PCB->Data->via_tree, screen, NULL, clearPin_callback_solid, NULL);
-  r_search (PCB->Data->pad_tree, screen, NULL, clearPad_callback_solid, &side);
+  r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, clearPin_callback_solid, NULL);
+  r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, clearPin_callback_solid, NULL);
+  r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, clearPad_callback_solid, &s_info);
 
-  hid_draw_use_mask (&ghid_graphics, HID_MASK_AFTER);
-  hid_draw_set_color (out->fgGC, PCB->MaskColor);
-  ghid_set_alpha_mult (out->fgGC, thin ? 0.35 : 1.0);
+  hid_draw_use_mask (hid_draw, HID_MASK_AFTER);
+  hid_draw_set_color (gc, PCB->MaskColor);
+  ghid_set_alpha_mult (gc, thin ? 0.35 : 1.0);
 
 #if 0
   if (first_run) {
@@ -1792,18 +1810,18 @@ GhidDrawMask (int side, BoxType * screen)
 
   memset (&polygon, 0, sizeof (polygon));
   polygon.Clipped = PCB->Data->outline;
-  if (screen)
-    polygon.BoundingBox = *screen;
+  if (hid_draw->clip_box)
+    polygon.BoundingBox = *hid_draw->clip_box;
   polygon.Flags = NoFlags ();
   SET_FLAG (FULLPOLYFLAG, &polygon);
-  hid_draw__fill_pcb_polygon (out->fgGC, &polygon, screen);
+  hid_draw__fill_pcb_polygon (gc, &polygon);
   poly_FreeContours (&polygon.NoHoles);
 #endif
 
-  fill_board_outline (out->fgGC, screen);
+  fill_board_outline (gc);
 
-  ghid_set_alpha_mult (out->fgGC, 1.0);
-//  hidgl_flush_triangles (priv->hidgl);
+  ghid_set_alpha_mult (gc, 1.0);
+//  hidgl_flush_triangles (priv->hid_draw);
 #if 0
   glDisable (GL_TEXTURE_GEN_S);
   glDisable (GL_TEXTURE_GEN_T);
@@ -1812,7 +1830,7 @@ GhidDrawMask (int side, BoxType * screen)
 #endif
   hidgl_shader_activate (circular_program);
 
-  hid_draw_use_mask (&ghid_graphics, HID_MASK_OFF);
+  hid_draw_use_mask (hid_draw, HID_MASK_OFF);
 
 //  first_run = false;
 }
@@ -1860,7 +1878,7 @@ outline_hole_cb (PLINE *pl, void *user_data)
 }
 
 static void
-ghid_draw_outline_between_layers (int from_layer, int to_layer, BoxType *drawn_area)
+ghid_draw_outline_between_layers (hidGC gc, int from_layer, int to_layer)
 {
   render_priv *priv = gport->render_priv;
   PolygonType polygon, p;
@@ -1870,39 +1888,37 @@ ghid_draw_outline_between_layers (int from_layer, int to_layer, BoxType *drawn_a
 
   memset (&polygon, 0, sizeof (polygon));
   polygon.Clipped = PCB->Data->outline;
-  if (drawn_area)
-    polygon.BoundingBox = *drawn_area;
+  if (gc->hid_draw->clip_box)
+    polygon.BoundingBox = *gc->hid_draw->clip_box;
   polygon.Flags = NoFlags ();
   SET_FLAG (FULLPOLYFLAG, &polygon);
 
-  info.gc = Output.fgGC;
+  info.gc = gc;
   info.z1 = compute_depth (from_layer);
   info.z2 = compute_depth (to_layer);
 
   draw_outline_contour (info.gc, polygon.Clipped->contours, info.z1, info.z2);
-  PolygonHoles (&polygon, drawn_area, outline_hole_cb, &info);
+  PolygonHoles (&polygon, gc->hid_draw->clip_box, outline_hole_cb, &info);
 
   p = polygon;
   for (p.Clipped = polygon.Clipped->f;
        p.Clipped != polygon.Clipped;
        p.Clipped = p.Clipped->f) {
     draw_outline_contour (info.gc, p.Clipped->contours, info.z1, info.z2);
-    PolygonHoles (&p, drawn_area, outline_hole_cb, &info);
+    PolygonHoles (&p, gc->hid_draw->clip_box, outline_hole_cb, &info);
   }
 
   poly_FreeContours (&polygon.NoHoles);
 
-  hidgl_flush_triangles (priv->hidgl);
+  hidgl_flush_triangles (priv->hid_draw);
 }
 
 static int
-GhidDrawLayerGroup (int group, const BoxType * screen)
+GhidDrawLayerGroup (hidGC gc, int group)
 {
   render_priv *priv = gport->render_priv;
   int i;
   int layernum;
-  int side;
-  struct poly_info info;
   LayerType *Layer;
   int n_entries = PCB->LayerGroups.Number[group];
   Cardinal *layers = PCB->LayerGroups.Entries[group];
@@ -1910,8 +1926,14 @@ GhidDrawLayerGroup (int group, const BoxType * screen)
   int top_group = GetLayerGroupNumberBySide (TOP_SIDE);
   int bottom_group = GetLayerGroupNumberBySide (BOTTOM_SIDE);
   bool is_outline;
+  struct layer_info l_info;
+  struct side_info s_info;
+  HID_DRAW *hid_draw = gc->hid_draw;
+
+  l_info.gc = gc;
+  s_info.gc = gc;
 
-  if (!hid_draw_set_layer (&ghid_graphics, 0, group, 0))
+  if (!hid_draw_set_layer (hid_draw, 0, group, 0))
     return 0;
 
   /* HACK: Subcomposite each layer in a layer group separately */
@@ -1922,49 +1944,51 @@ GhidDrawLayerGroup (int group, const BoxType * screen)
     is_outline = strcmp (Layer->Name, "outline") == 0 ||
                  strcmp (Layer->Name, "route") == 0;
 
+    l_info.layer = Layer;
+
+
     if (layernum < max_copper_layer && Layer->On) {
 
       if (!first_run)
-        hid_draw_set_layer (&ghid_graphics, 0, group, 0);
+        hid_draw_set_layer (hid_draw, 0, group, 0);
 
       first_run = 0;
 
       if (!is_outline && !TEST_FLAG (THINDRAWFLAG, PCB)) {
         /* Mask out drilled holes on this layer */
-        hidgl_flush_triangles (priv->hidgl);
+        hidgl_flush_triangles (priv->hid_draw);
         glPushAttrib (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
         glColorMask (0, 0, 0, 0);
         glDepthMask (GL_FALSE);
         hid_draw_set_color (Output.bgGC, PCB->MaskColor);
-        if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
-        if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
-        fill_board_outline_holes (Output.bgGC, screen);
-        hidgl_flush_triangles (priv->hidgl);
+        if (PCB->PinOn) r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, hole_callback, gc);
+        if (PCB->ViaOn) r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, hole_callback, gc);
+        fill_board_outline_holes (Output.bgGC);
+        hidgl_flush_triangles (priv->hid_draw);
         glPopAttrib ();
       }
 
       /* draw all polygons on this layer */
       if (Layer->PolygonN) {
-        info.layer = Layer;
-        info.drawn_area = screen;
-        r_search (Layer->polygon_tree, screen, NULL, poly_callback_no_clear, &info);
-        r_search (Layer->polygon_tree, screen, NULL, poly_callback_clearing, &info);
+        l_info.layer = Layer;
+        r_search (Layer->polygon_tree, hid_draw->clip_box, NULL, poly_callback_no_clear, &l_info);
+        r_search (Layer->polygon_tree, hid_draw->clip_box, NULL, poly_callback_clearing, &l_info);
 
         /* HACK: Subcomposite polygons separately from other layer primitives */
         /* Reset the compositing */
-        hid_draw_end_layer (&ghid_graphics);
-        hid_draw_set_layer (&ghid_graphics, 0, group, 0);
+        hid_draw_end_layer (hid_draw);
+        hid_draw_set_layer (hid_draw, 0, group, 0);
 
         if (!is_outline && !TEST_FLAG (THINDRAWFLAG, PCB)) {
-          hidgl_flush_triangles (priv->hidgl);
+          hidgl_flush_triangles (priv->hid_draw);
           glPushAttrib (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
           glColorMask (0, 0, 0, 0);
           glDepthMask (GL_FALSE);
           /* Mask out drilled holes on this layer */
-          if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
-          if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
-          fill_board_outline_holes (Output.bgGC, screen);
-          hidgl_flush_triangles (priv->hidgl);
+          if (PCB->PinOn) r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, hole_callback, gc);
+          if (PCB->ViaOn) r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, hole_callback, gc);
+          fill_board_outline_holes (Output.bgGC);
+          hidgl_flush_triangles (priv->hid_draw);
           glPopAttrib ();
         }
       }
@@ -1973,31 +1997,31 @@ GhidDrawLayerGroup (int group, const BoxType * screen)
       if (!global_view_2d && !is_outline) {
         if (PCB->PinOn &&
             (group == bottom_group || group == top_group))
-          r_search (PCB->Data->pin_tree, screen, NULL, pin_name_callback, Layer);
-        if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, pin_inlayer_callback, Layer);
-        if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, via_inlayer_callback, Layer);
+          r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_name_callback, gc);
+        if (PCB->PinOn) r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_inlayer_callback, &l_info);
+        if (PCB->ViaOn) r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, via_inlayer_callback, &l_info);
         if (PCB->PinOn && group == top_group)
           {
-            side = TOP_SIDE;
-            r_search (PCB->Data->pad_tree, screen, NULL, pad_callback, &side);
+            s_info.side = TOP_SIDE;
+            r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_callback, &s_info);
           }
         if (PCB->PinOn && group == bottom_group)
           {
-            side = BOTTOM_SIDE;
-            r_search (PCB->Data->pad_tree, screen, NULL, pad_callback, &side);
+            s_info.side = BOTTOM_SIDE;
+            r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_callback, &s_info);
           }
       }
 
       if (TEST_FLAG (CHECKPLANESFLAG, PCB))
         continue;
 
-      r_search (Layer->line_tree, screen, NULL, line_callback, Layer);
-      r_search (Layer->arc_tree, screen, NULL, arc_callback, Layer);
-      r_search (Layer->text_tree, screen, NULL, text_callback, Layer);
+      r_search (Layer->line_tree, hid_draw->clip_box, NULL, line_callback, &l_info);
+      r_search (Layer->arc_tree, hid_draw->clip_box, NULL, arc_callback, &l_info);
+      r_search (Layer->text_tree, hid_draw->clip_box, NULL, text_callback, &l_info);
     }
   }
 
-  hid_draw_end_layer (&ghid_graphics);
+  hid_draw_end_layer (hid_draw);
 
   return (n_entries > 1);
 }
@@ -2048,6 +2072,7 @@ DrawDrillChannel (hidGC gc, int vx, int vy, int vr, int from_layer, int to_layer
 }
 
 struct cyl_info {
+  hidGC gc;
   int from_layer;
   int to_layer;
   double scale;
@@ -2069,9 +2094,9 @@ draw_hole_cyl (PinType *Pin, struct cyl_info *info, int Type)
   else
     color = "drill";
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)Pin);
-  hid_draw_set_color (Output.fgGC, color);
-  DrawDrillChannel (Output.fgGC, Pin->X, Pin->Y, Pin->DrillingHole / 2, info->from_layer, info->to_layer, info->scale);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *)Pin);
+  hid_draw_set_color (info->gc, color);
+  DrawDrillChannel (info->gc, Pin->X, Pin->Y, Pin->DrillingHole / 2, info->from_layer, info->to_layer, info->scale);
   return 0;
 }
 
@@ -2131,19 +2156,18 @@ frontE_package_callback (const BoxType * b, void *cl)
 }
 
 static void
-ghid_draw_packages (BoxType *drawn_area)
+ghid_draw_packages (hidGC gc)
 {
   /* XXX: Just the front elements for now */
-  r_search (PCB->Data->element_tree, drawn_area, NULL, frontE_package_callback, NULL);
+  r_search (PCB->Data->element_tree, gc->hid_draw->clip_box, NULL, frontE_package_callback, NULL);
 }
 
 void
-ghid_draw_everything (BoxType *drawn_area)
+ghid_draw_everything (hidGC gc)
 {
   render_priv *priv = gport->render_priv;
   int i, ngroups;
   int number_phys_on_top;
-  int side;
   /* This is the list of layer groups we will draw.  */
   int do_group[MAX_LAYER];
   /* This is the reverse of the order in which we draw them.  */
@@ -2155,6 +2179,11 @@ ghid_draw_everything (BoxType *drawn_area)
   int bottom_group;
   int min_phys_group;
   int max_phys_group;
+  struct side_info info;
+  HID_DRAW *hid_draw = gc->hid_draw;
+
+  cyl_info.gc = gc;
+  info.gc = gc;
 
   priv->current_colorname = NULL;
 
@@ -2204,23 +2233,23 @@ ghid_draw_everything (BoxType *drawn_area)
   /*
    * first draw all 'invisible' stuff
    */
-  side = SWAP_IDENT ? TOP_SIDE : BOTTOM_SIDE;
+  info.side = SWAP_IDENT ? TOP_SIDE : BOTTOM_SIDE;
 
   if (!TEST_FLAG (CHECKPLANESFLAG, PCB) &&
-      hid_draw_set_layer (&ghid_graphics, "invisible", SL (INVISIBLE, 0), 0)) {
-    DrawSilk (&ghid_graphics, side, drawn_area);
+      hid_draw_set_layer (hid_draw, "invisible", SL (INVISIBLE, 0), 0)) {
+    DrawSilk (gc, info.side);
 
     if (global_view_2d)
-      r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, &side);
+      r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_callback, &info);
 
-    hid_draw_end_layer (&ghid_graphics);
+    hid_draw_end_layer (hid_draw);
 
     /* Draw the reverse-side solder mask if turned on */
     if (!global_view_2d &&
-        hid_draw_set_layer (&ghid_graphics, SWAP_IDENT ? "componentmask" : "soldermask",
-                        SWAP_IDENT ? SL (MASK, TOP) : SL (MASK, BOTTOM), 0)) {
-        GhidDrawMask (side, drawn_area);
-        hid_draw_end_layer (&ghid_graphics);
+        hid_draw_set_layer (hid_draw, SWAP_IDENT ? "componentmask" : "soldermask",
+                            SWAP_IDENT ? SL (MASK, TOP) : SL (MASK, BOTTOM), 0)) {
+        GhidDrawMask (gc, info.side);
+        hid_draw_end_layer (hid_draw);
       }
   }
 
@@ -2240,76 +2269,76 @@ ghid_draw_everything (BoxType *drawn_area)
     if (is_this_physical)
       number_phys_on_top --;
 
-    ghid_set_alpha_mult (Output.fgGC, alpha_mult);
-    GhidDrawLayerGroup (drawn_groups [i], drawn_area);
+    ghid_set_alpha_mult (gc, alpha_mult);
+    GhidDrawLayerGroup (gc, drawn_groups [i]);
 
 #if 1
     if (!global_view_2d && is_this_physical && is_next_physical) {
       cyl_info.from_layer = drawn_groups[i];
       cyl_info.to_layer = drawn_groups[i - 1];
       cyl_info.scale = gport->view.coord_per_px;
-      hid_draw_set_color (Output.fgGC, "drill");
-      ghid_set_alpha_mult (Output.fgGC, alpha_mult * 0.75);
-      ghid_draw_outline_between_layers (cyl_info.from_layer, cyl_info.to_layer, drawn_area);
-      if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_hole_cyl_callback, &cyl_info);
-      if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, via_hole_cyl_callback, &cyl_info);
+      hid_draw_set_color (gc, "drill");
+      ghid_set_alpha_mult (gc, alpha_mult * 0.75);
+      ghid_draw_outline_between_layers (gc, cyl_info.from_layer, cyl_info.to_layer);
+      if (PCB->PinOn) r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_hole_cyl_callback, &cyl_info);
+      if (PCB->ViaOn) r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, via_hole_cyl_callback, &cyl_info);
     }
 #endif
   }
 #undef FADE_FACTOR
 
-  ghid_set_alpha_mult (Output.fgGC, 1.0);
+  ghid_set_alpha_mult (gc, 1.0);
 
   if (TEST_FLAG (CHECKPLANESFLAG, PCB))
     return;
 
-  side = SWAP_IDENT ? BOTTOM_SIDE : TOP_SIDE;
+  info.side = SWAP_IDENT ? BOTTOM_SIDE : TOP_SIDE;
 
   /* Draw pins, pads, vias below silk */
   if (global_view_2d) {
-    start_subcomposite (priv->hidgl);
+    start_subcomposite (hid_draw);
 
     if (!TEST_FLAG (THINDRAWFLAG, PCB)) {
       /* Mask out drilled holes */
-      hidgl_flush_triangles (priv->hidgl);
+      hidgl_flush_triangles (priv->hid_draw);
       glPushAttrib (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
       glColorMask (0, 0, 0, 0);
       glDepthMask (GL_FALSE);
-      if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, hole_callback, NULL);
-      if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, hole_callback, NULL);
-      fill_board_outline_holes (Output.bgGC, drawn_area);
-      hidgl_flush_triangles (priv->hidgl);
+      if (PCB->PinOn) r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, hole_callback, gc);
+      if (PCB->ViaOn) r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, hole_callback, gc);
+      fill_board_outline_holes (Output.bgGC);
+      hidgl_flush_triangles (priv->hid_draw);
       glPopAttrib ();
     }
 
-    if (PCB->PinOn) r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, &side);
-    if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_callback, NULL);
-    if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, via_callback, NULL);
+    if (PCB->PinOn) r_search (PCB->Data->pad_tree, hid_draw->clip_box, NULL, pad_callback, &info);
+    if (PCB->PinOn) r_search (PCB->Data->pin_tree, hid_draw->clip_box, NULL, pin_callback, gc);
+    if (PCB->ViaOn) r_search (PCB->Data->via_tree, hid_draw->clip_box, NULL, via_callback, gc);
 
-    end_subcomposite (priv->hidgl);
+    end_subcomposite (hid_draw);
   }
 
   /* Draw the solder mask if turned on */
-  if (hid_draw_set_layer (&ghid_graphics, SWAP_IDENT ? "soldermask" : "componentmask",
-                      SWAP_IDENT ? SL (MASK, BOTTOM) : SL (MASK, TOP), 0)) {
-    GhidDrawMask (side, drawn_area);
-    hid_draw_end_layer (&ghid_graphics);
+  if (hid_draw_set_layer (hid_draw, SWAP_IDENT ? "soldermask" : "componentmask",
+                          SWAP_IDENT ? SL (MASK, BOTTOM) : SL (MASK, TOP), 0)) {
+    GhidDrawMask (gc, info.side);
+    hid_draw_end_layer (hid_draw);
   }
 
-  if (hid_draw_set_layer (&ghid_graphics, SWAP_IDENT ? "bottomsilk" : "topsilk",
-                      SWAP_IDENT ? SL (SILK, BOTTOM) : SL (SILK, TOP), 0)) {
-      DrawSilk (&ghid_graphics, side, drawn_area);
-      hid_draw_end_layer (&ghid_graphics);
+  if (hid_draw_set_layer (hid_draw, SWAP_IDENT ? "bottomsilk" : "topsilk",
+                          SWAP_IDENT ? SL (SILK, BOTTOM) : SL (SILK, TOP), 0)) {
+      DrawSilk (gc, info.side);
+      hid_draw_end_layer (hid_draw);
   }
 
   /* Draw element Marks */
   if (PCB->PinOn)
-    r_search (PCB->Data->element_tree, drawn_area, NULL, EMark_callback, NULL);
+    r_search (PCB->Data->element_tree, hid_draw->clip_box, NULL, EMark_callback, gc);
 
   /* Draw rat lines on top */
-  if (PCB->RatOn && hid_draw_set_layer (&ghid_graphics, "rats", SL (RATS, 0), 0)) {
-    DrawRats (&ghid_graphics, drawn_area);
-    hid_draw_end_layer (&ghid_graphics);
+  if (PCB->RatOn && hid_draw_set_layer (hid_draw, "rats", SL (RATS, 0), 0)) {
+    DrawRats (gc);
+    hid_draw_end_layer (hid_draw);
   }
 
   Settings.ShowBottomSide = save_show_solder;
@@ -2336,6 +2365,8 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
                      0, 0, 0, 1};
   bool horizon_problem = false;
   static bool do_once = true;
+  HID_DRAW *hid_draw = priv->hid_draw;
+  hidGC gc;
 
   if (do_once) {
     do_once = false;
@@ -2346,14 +2377,14 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   ghid_start_drawing (port, widget);
 
-  Output.fgGC = hid_draw_make_gc (&ghid_graphics);
-  Output.bgGC = hid_draw_make_gc (&ghid_graphics);
-  Output.pmGC = hid_draw_make_gc (&ghid_graphics);
+  gc = hid_draw_make_gc (hid_draw);
+  Output.bgGC = hid_draw_make_gc (hid_draw);
+  Output.pmGC = hid_draw_make_gc (hid_draw);
 
   /* If we don't have any stencil bits available,
      we can't use the hidgl polygon drawing routine */
   /* TODO: We could use the GLU tessellator though */
-  if (hidgl_stencil_bits (priv->hidgl) == 0)
+  if (hidgl_stencil_bits (priv->hid_draw) == 0)
     ghid_graphics_class._fill_pcb_polygon = common_fill_pcb_polygon;
 
   glEnable (GL_BLEND);
@@ -2439,7 +2470,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glStencilMask (~0);
   glClearStencil (0);
   glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-  hidgl_reset_stencil_usage (priv->hidgl);
+  hidgl_reset_stencil_usage (priv->hid_draw);
 
   /* Disable the stencil test until we need it - otherwise it gets dirty */
   glDisable (GL_STENCIL_TEST);
@@ -2538,8 +2569,6 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
              port->bg_color.green / 65535.,
              port->bg_color.blue / 65535.);
 
-  ghid_invalidate_current_gc ();
-
   /* Setup stenciling */
   /* Drawing operations set the stencil buffer to '1' */
   glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); /* Stencil pass => replace stencil value (with 1) */
@@ -2582,9 +2611,10 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   ghid_draw_bg_image ();
 
-  /* hid_expose_callback (&ghid_graphics, &region, 0); */
-  ghid_draw_everything (&region);
-  hidgl_flush_triangles (priv->hidgl);
+  common_set_clip_box (hid_draw, &region);
+  /* hid_expose_callback (hid_draw, 0); */
+  ghid_draw_everything (gc);
+  hidgl_flush_triangles (priv->hid_draw);
 
   glTexCoord2f (0., 0.);
   glColor3f (1., 1., 1.);
@@ -2628,15 +2658,13 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   /* Set the current depth to the right value for the layer we are editing */
   priv->edit_depth = compute_depth (GetLayerGroupNumberByNumber (INDEXOFCURRENT));
-  hidgl_set_depth (Output.fgGC, priv->edit_depth);
-
-  ghid_draw_grid (Output.fgGC, &region);
+  hidgl_set_depth (gc, priv->edit_depth);
 
-  ghid_invalidate_current_gc ();
+  ghid_draw_grid (gc);
 
-  DrawAttached (Output.fgGC);
-  DrawMark (Output.fgGC);
-  hidgl_flush_triangles (priv->hidgl);
+  DrawAttached (gc);
+  DrawMark (gc);
+  hidgl_flush_triangles (priv->hid_draw);
 
   glEnable (GL_LIGHTING);
 
@@ -2688,7 +2716,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   }
 
   if (!global_view_2d)
-    ghid_draw_packages (&region);
+    ghid_draw_packages (gc);
 
   glDisable (GL_CULL_FACE);
   glDisable (GL_DEPTH_TEST);
@@ -2696,20 +2724,19 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glDisable (GL_COLOR_MATERIAL);
   glDisable (GL_LIGHTING);
 
-  draw_crosshair (Output.fgGC, priv);
+  draw_crosshair (gc, priv);
   object3d_draw_debug ();
 
-  hidgl_flush_triangles (priv->hidgl);
+  hidgl_flush_triangles (priv->hid_draw);
 
-  draw_lead_user (Output.fgGC, priv);
+  draw_lead_user (gc, priv);
 
   ghid_end_drawing (port, widget);
 
-  hid_draw_destroy_gc (Output.fgGC);
+  hid_draw_destroy_gc (gc);
   hid_draw_destroy_gc (Output.bgGC);
   hid_draw_destroy_gc (Output.pmGC);
 
-  Output.fgGC = NULL;
   Output.bgGC = NULL;
   Output.pmGC = NULL;
   g_timer_start (priv->time_since_expose);
@@ -2747,6 +2774,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   Coord save_max_width;
   Coord save_max_height;
   double xz, yz;
+  HID_DRAW *hid_draw = priv->hid_draw;
 
   save_view = gport->view;
   save_width = gport->width;
@@ -2830,7 +2858,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   glStencilMask (~0);
   glClearStencil (0);
   glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-  hidgl_reset_stencil_usage (priv->hidgl);
+  hidgl_reset_stencil_usage (priv->hid_draw);
 
   /* Disable the stencil test until we need it - otherwise it gets dirty */
   glDisable (GL_STENCIL_TEST);
@@ -2838,7 +2866,6 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   glStencilFunc (GL_ALWAYS, 0, 0);
 
   /* call the drawing routine */
-  ghid_invalidate_current_gc ();
   glPushMatrix ();
   glScalef ((gport->view.flip_x ? -1. : 1.) / gport->view.coord_per_px,
             (gport->view.flip_y ? -1. : 1.) / gport->view.coord_per_px,
@@ -2848,8 +2875,8 @@ ghid_pinout_preview_expose (GtkWidget *widget,
                 gport->view.flip_y ? gport->view.y0 - PCB->MaxHeight :
                                     -gport->view.y0, 0);
 
-  hid_expose_callback (&ghid_graphics, NULL, pinout->element);
-  hidgl_flush_triangles (priv->hidgl);
+  hid_expose_callback (hid_draw, pinout->element);
+  hidgl_flush_triangles (priv->hid_draw);
   glPopMatrix ();
 
   ghid_end_drawing (gport, widget);
@@ -2877,6 +2904,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   view_data save_view;
   int save_width, save_height;
   BoxType region;
+  HID_DRAW *hid_draw = priv->hid_draw;
 
   save_view = gport->view;
   save_width = gport->width;
@@ -2917,7 +2945,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   if (!gdk_gl_drawable_gl_begin (gldrawable, glcontext)) {
     return NULL;
   }
-  hidgl_start_render (priv->hidgl);
+  hidgl_start_render (priv->hid_draw);
   gport->render_priv->in_context = true;
 
   glEnable (GL_BLEND);
@@ -2942,7 +2970,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   glStencilMask (~0);
   glClearStencil (0);
   glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-  hidgl_reset_stencil_usage (priv->hidgl);
+  hidgl_reset_stencil_usage (priv->hid_draw);
 
   /* Disable the stencil test until we need it - otherwise it gets dirty */
   glDisable (GL_STENCIL_TEST);
@@ -2950,7 +2978,6 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   glStencilFunc (GL_ALWAYS, 0, 0);
 
   /* call the drawing routine */
-  ghid_invalidate_current_gc ();
   glPushMatrix ();
   glScalef ((gport->view.flip_x ? -1. : 1.) / gport->view.coord_per_px,
             (gport->view.flip_y ? -1. : 1.) / gport->view.coord_per_px,
@@ -2970,13 +2997,14 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   region.Y1 = MAX (0, MIN (PCB->MaxHeight, region.Y1));
   region.Y2 = MAX (0, MIN (PCB->MaxHeight, region.Y2));
 
-  hid_expose_callback (&ghid_graphics, &region, NULL);
-  hidgl_flush_triangles (priv->hidgl);
+  common_set_clip_box (hid_draw, &region);
+  hid_expose_callback (hid_draw, NULL);
+  hidgl_flush_triangles (priv->hid_draw);
   glPopMatrix ();
 
   glFlush ();
 
-  hidgl_finish_render (priv->hidgl);
+  hidgl_finish_render (priv->hid_draw);
 
   /* end drawing to current GL-context */
   gport->render_priv->in_context = false;
@@ -2998,6 +3026,7 @@ HID_DRAW *
 ghid_request_debug_draw (void)
 {
   GHidPort *port = gport;
+  render_priv *priv = port->render_priv;
   GtkWidget *widget = port->drawing_area;
   GtkAllocation allocation;
 
@@ -3014,8 +3043,6 @@ ghid_request_debug_draw (void)
   glLoadIdentity ();
   glTranslatef (0.0f, 0.0f, -Z_NEAR);
 
-  ghid_invalidate_current_gc ();
-
   /* Setup stenciling */
   glDisable (GL_STENCIL_TEST);
 
@@ -3028,17 +3055,17 @@ ghid_request_debug_draw (void)
                 port->view.flip_y ? port->view.y0 - PCB->MaxHeight :
                              -port->view.y0, 0);
 
-  return &ghid_graphics;
+  return priv->hid_draw;
 }
 
 void
-ghid_flush_debug_draw (void)
+ghid_flush_debug_draw (hidGC gc)
 {
   render_priv *priv = gport->render_priv;
   GtkWidget *widget = gport->drawing_area;
   GdkGLDrawable *pGlDrawable = gtk_widget_get_gl_drawable (widget);
 
-  hidgl_flush_triangles (priv->hidgl);
+  hidgl_flush_triangles (priv->hid_draw);
 
   if (gdk_gl_drawable_is_double_buffered (pGlDrawable))
     gdk_gl_drawable_swap_buffers (pGlDrawable);
@@ -3047,11 +3074,11 @@ ghid_flush_debug_draw (void)
 }
 
 void
-ghid_finish_debug_draw (void)
+ghid_finish_debug_draw (hidGC gc)
 {
-  render_priv *priv = gport->render_priv;
+  HID_DRAW *hid_draw = gc->hid_draw;
 
-  hidgl_flush_triangles (priv->hidgl);
+  hidgl_flush_triangles (hid_draw);
   glPopMatrix ();
 
   ghid_end_drawing (gport, gport->drawing_area);
@@ -3413,7 +3440,6 @@ ghid_port_rotate (void *ball, float *quarternion, gpointer userdata)
 static void
 draw_lead_user (hidGC gc, render_priv *priv)
 {
-  gtkGC gtk_gc = (gtkGC)gc;
   int i;
   double radius = priv->lead_user_radius;
   double width = MM_TO_COORD (LEAD_USER_WIDTH);
@@ -3440,7 +3466,7 @@ draw_lead_user (hidGC gc, render_priv *priv)
                       radius, radius, 0, 360, gport->view.coord_per_px);
     }
 
-  hidgl_flush_triangles (gtk_gc->hidgl_gc.hidgl);
+  hidgl_flush_triangles (gc->hid_draw);
   glPopAttrib ();
 }
 
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 9fb531b..85d010e 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -2097,8 +2097,7 @@ REGISTER_FLAGS (ghid_main_flag_list)
 #endif
 
 HID ghid_hid;
-HID_DRAW ghid_graphics;
-struct hid_draw_class_st ghid_graphics_class;
+HID_DRAW_CLASS ghid_graphics_class;
 
 void
 hid_gtk_init ()
@@ -2138,7 +2137,6 @@ hid_gtk_init ()
 #endif
 
   memset (&ghid_hid, 0, sizeof (HID));
-  memset (&ghid_graphics, 0, sizeof (HID_DRAW));
   memset (&ghid_graphics_class, 0, sizeof (HID_DRAW_CLASS));
 
   common_nogui_init (&ghid_hid);
@@ -2216,14 +2214,8 @@ hid_gtk_init ()
   ghid_graphics_class.draw_pcb_pad     = common_gui_draw_pcb_pad;
   ghid_graphics_class.draw_pcb_pv      = common_gui_draw_pcb_pv;
 
-
   ghid_graphics_class.gui = true;
 
-  ghid_graphics.klass = &ghid_graphics_class;
-  ghid_graphics.poly_after = true;
-  common_nogui_graphics_init (&ghid_graphics);
-  common_draw_helpers_init (&ghid_graphics);
-
   hid_register_hid (&ghid_hid);
 #include "gtk_lists.h"
 }
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index 32036c8..48b8c3c 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -504,8 +504,8 @@ gboolean ghid_pinout_preview_expose (GtkWidget * widget, GdkEventExpose * ev);
 GdkPixmap *ghid_render_pixmap (int cx, int cy, double zoom,
                                int width, int height, int depth);
 HID_DRAW *ghid_request_debug_draw (void);
-void ghid_flush_debug_draw (void);
-void ghid_finish_debug_draw (void);
+void ghid_flush_debug_draw (hidGC gc);
+void ghid_finish_debug_draw (hidGC gc);
 bool ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y);
 bool ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y);
 void ghid_port_rotate (void *ball, float *quarternion, gpointer userdata);
diff --git a/src/hid/lesstif/main.c b/src/hid/lesstif/main.c
index 3d1ffd3..2bfa077 100644
--- a/src/hid/lesstif/main.c
+++ b/src/hid/lesstif/main.c
@@ -816,6 +816,7 @@ Benchmark (int argc, char **argv, Coord x, Coord y)
   time_t start, end;
   BoxType region;
   Drawable save_main;
+  hidGC gc;
 
   save_main = main_pixmap;
   main_pixmap = window;
@@ -825,13 +826,18 @@ Benchmark (int argc, char **argv, Coord x, Coord y)
   region.X2 = PCB->MaxWidth;
   region.Y2 = PCB->MaxHeight;
 
+#warning NULL gc
+  gc = NULL;
+
+  common_set_clip_box (gc, &region);
+
   pixmap = window;
   XSync (display, 0);
   time (&start);
   do
     {
       XFillRectangle (display, pixmap, bg_gc, 0, 0, view_width, view_height);
-      hid_expose_callback (&lesstif_graphics, &region, 0);
+      hid_expose_callback (&lesstif_graphics, 0);
       XSync (display, 0);
       time (&end);
       i++;
@@ -2496,6 +2502,11 @@ static int need_redraw = 0;
 static Boolean
 idle_proc (XtPointer dummy)
 {
+  hidGC gc;
+
+#warning NULL gc
+  gc = NULL;
+
   if (need_redraw)
     {
       int mx, my;
@@ -2578,8 +2589,11 @@ idle_proc (XtPointer dummy)
 			      rightmost-leftmost+1, view_height-bottommost+1);
 	    }
 	}
+
+      common_set_clip_box (gc, &region);
+
       DrawBackgroundImage();
-      hid_expose_callback (&lesstif_graphics, &region, 0);
+      hid_expose_callback (&lesstif_graphics, 0);
       draw_grid ();
       lesstif_use_mask (&lesstif_graphics, HID_MASK_OFF);
       show_crosshair (0); /* To keep the drawn / not drawn info correct */
@@ -3754,6 +3768,7 @@ pinout_callback (Widget da, PinoutData * pd,
   double save_vz;
   Pixmap save_px;
   int reason = cbs ? cbs->reason : 0;
+  hidGC gc;
 
   if (pd->window == 0 && reason == XmCR_RESIZE)
     return;
@@ -3802,8 +3817,13 @@ pinout_callback (Widget da, PinoutData * pd,
   region.X2 = PCB->MaxWidth;
   region.Y2 = PCB->MaxHeight;
 
+#warning NULL gc
+  gc = NULL;
+
+  common_set_clip_box (gc, &region);
+
   XFillRectangle (display, pixmap, bg_gc, 0, 0, pd->v_width, pd->v_height);
-  hid_expose_callback (&lesstif_graphics, &region, pd->item);
+  hid_expose_callback (&lesstif_graphics, pd->item);
 
   pinout = 0;
   view_left_x = save_vx;
@@ -4034,7 +4054,7 @@ lesstif_request_debug_draw (void)
 }
 
 static void
-lesstif_flush_debug_draw (void)
+lesstif_flush_debug_draw (hidGC gc)
 {
   /* Copy the backing pixmap to the display and redraw any attached objects */
   XSetFunction (display, my_gc, GXcopy);
@@ -4050,9 +4070,9 @@ lesstif_flush_debug_draw (void)
 }
 
 static void
-lesstif_finish_debug_draw (void)
+lesstif_finish_debug_draw (hidGC gc)
 {
-  lesstif_flush_debug_draw ();
+  lesstif_flush_debug_draw (gc);
   /* No special tear down requirements
    */
 }
diff --git a/src/hid/nelma/nelma.c b/src/hid/nelma/nelma.c
index f1d912d..2f8a497 100644
--- a/src/hid/nelma/nelma.c
+++ b/src/hid/nelma/nelma.c
@@ -646,10 +646,13 @@ nelma_start_png_export()
 	region.X2 = PCB->MaxWidth;
 	region.Y2 = PCB->MaxHeight;
 
+#warning NULL gc
+  common_set_clip_box (NULL, &region);
+
 	linewidth = -1;
 	lastbrush = (gdImagePtr)((void *) -1);
 
-	hid_expose_callback(&nelma_graphics, &region, 0);
+	hid_expose_callback(&nelma_graphics, 0);
 }
 
 static void 
diff --git a/src/hid/png/png.c b/src/hid/png/png.c
index 92f8661..f11e313 100644
--- a/src/hid/png/png.c
+++ b/src/hid/png/png.c
@@ -655,7 +655,8 @@ png_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
 	}
     }
 
-  hid_expose_callback (&png_graphics, bounds, 0);
+  common_set_clip_box (&png_graphics, bounds);
+  hid_expose_callback (&png_graphics, 0);
 
   memcpy (LayerStack, saved_layer_stack, sizeof (LayerStack));
   PCB->Flags = save_flags;
diff --git a/src/hid/ps/eps.c b/src/hid/ps/eps.c
index 4b192cc..d7cc194 100644
--- a/src/hid/ps/eps.c
+++ b/src/hid/ps/eps.c
@@ -299,7 +299,8 @@ eps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
   fprintf (f,
 	   "/a { gsave setlinewidth translate scale 0 0 1 5 3 roll arc stroke grestore} bind def\n");
 
-  hid_expose_callback (&eps_graphics, bounds, 0);
+  common_set_clip_box (&eps_graphics, bounds);
+  hid_expose_callback (&eps_graphics, 0);
 
   fprintf (f, "showpage\n");
 
diff --git a/src/hid/ps/ps.c b/src/hid/ps/ps.c
index 2f21bee..17ef7f6 100644
--- a/src/hid/ps/ps.c
+++ b/src/hid/ps/ps.c
@@ -399,8 +399,6 @@ static struct {
 
   double scale_factor;
 
-  BoxType region;
-
   HID_Attr_Val ps_values[NUM_OPTIONS];
 
   bool is_mask;
@@ -598,6 +596,7 @@ ps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
   int i;
   static int saved_layer_stack[MAX_LAYER];
   FlagType save_thindraw;
+  BoxType region;
 
   save_thindraw = PCB->Flags;
   CLEAR_FLAG(THINDRAWFLAG, PCB);
@@ -678,10 +677,12 @@ ps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
   ps_set_layer (&ps_graphics, NULL, 0, -1);
   use_gc (NULL);
 
-  global.region.X1 = 0;
-  global.region.Y1 = 0;
-  global.region.X2 = PCB->MaxWidth;
-  global.region.Y2 = PCB->MaxHeight;
+  region.X1 = 0;
+  region.Y1 = 0;
+  region.X2 = PCB->MaxWidth;
+  region.Y2 = PCB->MaxHeight;
+
+  common_set_clip_box (&ps_graphics, &region);
 
   if (!global.multi_file)
     {
@@ -694,13 +695,13 @@ ps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
 
       global.doing_toc = 1;
       global.pagecount = 1;  /* 'pagecount' is modified by hid_expose_callback() call */
-      hid_expose_callback (&ps_graphics, &global.region, 0);
+      hid_expose_callback (&ps_graphics, 0);
     }
 
   global.pagecount = 1; /* Reset 'pagecount' if single file */
   global.doing_toc = 0;
   ps_set_layer (&ps_graphics, NULL, 0, -1);  /* reset static vars */
-  hid_expose_callback (&ps_graphics, &global.region, 0);
+  hid_expose_callback (&ps_graphics, 0);
 
   if (the_file)
     fprintf (the_file, "showpage\n");
@@ -1008,7 +1009,11 @@ ps_set_layer (HID_DRAW *hid_draw, const char *name, int group, int empty)
       strcmp (name, "route") != 0
       )
     {
-      dapi->draw_layer (global.outline_layer, &global.region, NULL);
+      hidGC gc;
+
+      gc = hid_draw_make_gc (hid_draw);
+      dapi->draw_layer (gc, global.outline_layer, NULL);
+      hid_draw_destroy_gc (gc);
     }
 
   return 1;
@@ -1266,7 +1271,7 @@ ps_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
 }
 
 static void
-fill_polyarea (hidGC gc, POLYAREA * pa, const BoxType * clip_box)
+fill_polyarea (hidGC gc, POLYAREA * pa)
 {
   /* Ignore clip_box, just draw everything */
 
@@ -1295,15 +1300,15 @@ fill_polyarea (hidGC gc, POLYAREA * pa, const BoxType * clip_box)
 }
 
 static void
-ps_draw_pcb_polygon (hidGC gc, PolygonType * poly, const BoxType * clip_box)
+ps_draw_pcb_polygon (hidGC gc, PolygonType * poly)
 {
-  fill_polyarea (gc, poly->Clipped, clip_box);
+  fill_polyarea (gc, poly->Clipped);
   if (TEST_FLAG (FULLPOLYFLAG, poly))
     {
       POLYAREA *pa;
 
       for (pa = poly->Clipped->f; pa != poly->Clipped; pa = pa->f)
-        fill_polyarea (gc, pa, clip_box);
+        fill_polyarea (gc, pa);
     }
 }
 
diff --git a/src/hid_draw.h b/src/hid_draw.h
index 4096a26..dce9e92 100644
--- a/src/hid_draw.h
+++ b/src/hid_draw.h
@@ -70,14 +70,14 @@ typedef struct hid_draw_class_st
   void (*draw_pcb_line) (hidGC gc, LineType *line);
   void (*draw_pcb_arc) (hidGC gc, ArcType *arc);
   void (*draw_pcb_text) (hidGC gc, TextType *, Coord);
-  void (*draw_pcb_polygon) (hidGC gc, PolygonType *poly, const BoxType *clip_box);
+  void (*draw_pcb_polygon) (hidGC gc, PolygonType *poly);
   void (*draw_pcb_pad) (hidGC gc, PadType *pad, bool clip, bool mask);
   void (*draw_pcb_pv) (hidGC gc, PinType *pv, bool mask);
   void (*draw_pcb_pv_hole) (hidGC gc, PinType *pv);
 
   /* The following are not meant to be called outside of the GUI implementations of the above APIs */
-  void (*_fill_pcb_polygon) (hidGC gc, PolygonType *poly, const BoxType *clip_box);
-  void (*_thindraw_pcb_polygon) (hidGC gc, PolygonType *poly, const BoxType *clip_box);
+  void (*_fill_pcb_polygon) (hidGC gc, PolygonType *poly);
+  void (*_thindraw_pcb_polygon) (hidGC gc, PolygonType *poly);
   void (*_fill_pcb_pad) (hidGC gc, PadType *pad, bool clip, bool mask);
   void (*_thindraw_pcb_pad) (hidGC gc, PadType *pad, bool clip, bool mask);
   void (*_fill_pcb_pv) (hidGC gc, PinType *pv, bool mask);
@@ -101,6 +101,10 @@ struct hid_draw_st
   /* Note that both of these may be set, in which case polygons will be drawn twice: */
   bool poly_before; /* If set, the redraw code will draw polygons before erasing the clearances. */
   bool poly_after;  /* If set, the redraw code will draw polygons after  erasing the clearances. */
+
+  BoxType *clip_box; /* Used by HIDs and draw.c to restrict rendering to a given region */
+
+  void *priv; /* XXX: TEMPORARY */
 };
 
 /* Base hidGC elements visible to any module */
@@ -242,9 +246,9 @@ hid_draw_pcb_text (hidGC gc, TextType *text, Coord min_width)
 }
 
 inline void
-hid_draw_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+hid_draw_pcb_polygon (hidGC gc, PolygonType *poly)
 {
-  gc->hid_draw->klass->draw_pcb_polygon (gc, poly, clip_box);
+  gc->hid_draw->klass->draw_pcb_polygon (gc, poly);
 }
 
 inline void
@@ -267,15 +271,15 @@ hid_draw_pcb_pv_hole (hidGC gc, PinType *pv)
 
 
 inline void
-hid_draw__fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+hid_draw__fill_pcb_polygon (hidGC gc, PolygonType *poly)
 {
-  gc->hid_draw->klass->_fill_pcb_polygon (gc, poly, clip_box);
+  gc->hid_draw->klass->_fill_pcb_polygon (gc, poly);
 }
 
 inline void
-hid_draw__thin_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+hid_draw__thin_pcb_polygon (hidGC gc, PolygonType *poly)
 {
-  gc->hid_draw->klass->_thindraw_pcb_polygon (gc, poly, clip_box);
+  gc->hid_draw->klass->_thindraw_pcb_polygon (gc, poly);
 }
 
 inline void

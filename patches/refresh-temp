Bottom: 726c07bed2408f17984c76fdcf9d4149a784785c
Top:    8377f6ea8779fa005e5b6cd106b99f93245d305c
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-10-14 03:28:54 +0100

Refresh of shiny-3d-eye-candy

---

diff --git a/configure.ac b/configure.ac
index 31eec7d..ba1afc7 100644
--- a/configure.ac
+++ b/configure.ac
@@ -978,7 +978,7 @@ AM_CONDITIONAL(DEBUG_BUILD, test x$enable_debug = xyes)
 # ------------- Complete set of CFLAGS and LIBS -------------------
 
 CFLAGS="$CFLAGS $X_CFLAGS $DBUS_CFLAGS $GLIB_CFLAGS $GTK_CFLAGS $CAIRO_CFLAGS $GTKGLEXT_CFLAGS"
-LIBS="$LIBS $XM_LIBS $DBUS_LIBS $X_LIBS $GLIB_LIBS $GTK_LIBS $DMALLOC_LIBS $GD_LIBS $INTLLIBS $CAIRO_LIBS $GTKGLEXT_LIBS"
+LIBS="$LIBS $XM_LIBS $DBUS_LIBS $X_LIBS $GLIB_LIBS $GTK_LIBS $DMALLOC_LIBS $GD_LIBS $INTLLIBS $CAIRO_LIBS $GTKGLEXT_LIBS -lglut"
 
 
 # if we have gcc then add -Wall
diff --git a/src/Makefile.am b/src/Makefile.am
index 6d1be55..9bc9e22 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -158,7 +158,10 @@ DBUS_SRCS= \
 
 GL_SRCS= \
 	hid/common/hidgl.c \
-	hid/common/hidgl.h
+	hid/common/hidgl.h \
+	hid/common/trackball.c \
+	hid/common/trackball.h
+
 
 BUILT_SOURCES = \
 	core_lists.h \
@@ -265,6 +268,8 @@ LIBGTK_SRCS = \
 	hid/gtk/gui-pinout-window.c \
 	hid/gtk/gui-render-pixmap.c \
 	hid/gtk/gui-top-window.c \
+	hid/gtk/gui-trackball.c \
+	hid/gtk/gui-trackball.h \
 	hid/gtk/gui-utils.c \
 	hid/gtk/snavi.c \
 	hid/gtk/snavi.h
diff --git a/src/draw.c b/src/draw.c
index cfec799..10ba3f2 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -308,6 +308,10 @@ hole_callback (const BoxType * b, void *cl)
 {
   PinTypePtr pin = (PinTypePtr) b;
   int plated = cl ? *(int *) cl : -1;
+
+  if (!TEST_FLAG (SQUAREFLAG,pin))
+    return;
+
   switch (plated)
     {
     case -1:
@@ -382,6 +386,31 @@ PrintAssembly (const BoxType * drawn_area, int side_group, int swap_ident)
   SWAP_IDENT = save_swap;
 }
 
+static int
+via_callback (const BoxType * b, void *cl)
+{
+  PinTypePtr via = (PinTypePtr) b;
+//  if (via->Mask)
+    DrawPlainVia (via, False);
+  return 1;
+}
+
+static int
+pin_callback (const BoxType * b, void *cl)
+{
+  DrawPlainPin ((PinTypePtr) b, False);
+  return 1;
+}
+
+static int
+pad_callback (const BoxType * b, void *cl)
+{
+  PadTypePtr pad = (PadTypePtr) b;
+  if (FRONT (pad))
+    DrawPad (pad, 0);
+  return 1;
+}
+
 /* ---------------------------------------------------------------------------
  * initializes some identifiers for a new zoom factor and redraws whole screen
  */
@@ -470,6 +499,20 @@ DrawEverything (BoxTypePtr drawn_area)
 		}
 	    }
 	  gui->set_layer (NULL, SL (FINISHED, 0), 0);
+	  if (gui->gui) {
+            /* draw element pins */
+            if (PCB->PinOn || doing_assy)
+              {
+                r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_callback, NULL);
+//                r_search (PCB->Data->pin_tree, drawn_area, NULL, hole_callback, NULL);
+              }
+            /* draw vias */
+            if (PCB->ViaOn || doing_assy)
+              {
+                r_search (PCB->Data->via_tree, drawn_area, NULL, via_callback, NULL);
+//                r_search (PCB->Data->via_tree, drawn_area, NULL, hole_callback, NULL);
+              }
+          }
 	}
     }
   if (TEST_FLAG (CHECKPLANESFLAG, PCB) && gui->gui)
@@ -479,7 +522,14 @@ DrawEverything (BoxTypePtr drawn_area)
     r_search (PCB->Data->via_tree, drawn_area, NULL, lowvia_callback, NULL);
   /* Draw pins, pads, vias below silk */
   if (gui->gui)
-    DrawTop (drawn_area);
+    {
+      if (!Settings.ShowSolderSide)
+        gui->set_layer ("topsilk", SL (SILK, TOP), 0);
+      else
+        gui->set_layer ("bottomsilk", SL (SILK, BOTTOM), 0);
+      gui->set_layer (NULL, SL (FINISHED, 0), 0);
+      DrawTop (drawn_area);
+    }
   else
     {
       HoleCountStruct hcs;
@@ -638,31 +688,6 @@ DrawEMark (ElementTypePtr e, LocationType X, LocationType Y,
   
 }
 
-static int
-via_callback (const BoxType * b, void *cl)
-{
-  PinTypePtr via = (PinTypePtr) b;
-//  if (via->Mask)
-    DrawPlainVia (via, False);
-  return 1;
-}
-
-static int
-pin_callback (const BoxType * b, void *cl)
-{
-  DrawPlainPin ((PinTypePtr) b, False);
-  return 1;
-}
-
-static int
-pad_callback (const BoxType * b, void *cl)
-{
-  PadTypePtr pad = (PadTypePtr) b;
-  if (FRONT (pad))
-    DrawPad (pad, 0);
-  return 1;
-}
-
 /* ---------------------------------------------------------------------------
  * draws pins pads and vias
  */
@@ -680,10 +705,10 @@ DrawTop (const BoxType * screen)
   if (PCB->ViaOn || doing_assy)
     {
       r_search (PCB->Data->via_tree, screen, NULL, via_callback, NULL);
-      r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
+//      r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
     }
   if (PCB->PinOn || doing_assy)
-    r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
+      r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
 }
 
 struct pin_info
@@ -1139,7 +1164,12 @@ DrawPinOrViaLowLevel (PinTypePtr Ptr, Boolean drawHole)
 	}
       else
 	{
-	  gui->fill_circle (Output.fgGC, Ptr->X, Ptr->Y, Ptr->Thickness / 2);
+	  gui->set_line_cap (Output.fgGC, Round_Cap);
+	  gui->set_line_width (Output.fgGC, (Ptr->Thickness - Ptr->DrillingHole) / 2);
+	  gui->draw_arc (Output.fgGC, Ptr->X, Ptr->Y,
+			 (Ptr->Thickness + Ptr->DrillingHole) / 4,
+                         (Ptr->Thickness + Ptr->DrillingHole) / 4, 0, 360);
+//          gui->fill_circle (Output.fgGC, Ptr->X, Ptr->Y, Ptr->Thickness / 2);
 	}
     }
 
diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index 2525100..48c84ee 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -48,6 +48,7 @@
 RCSID ("$Id: $");
 
 triangle_buffer buffer;
+float global_depth = 0;
 
 #if 0
 triangle_array *
@@ -61,7 +62,7 @@ void
 hidgl_init_triangle_array (triangle_buffer *buffer)
 {
   glEnableClientState (GL_VERTEX_ARRAY);
-  glVertexPointer (2, GL_FLOAT, 0, buffer->triangle_array);
+  glVertexPointer (3, GL_FLOAT, 0, buffer->triangle_array);
   buffer->triangle_count = 0;
   buffer->coord_comp_count = 0;
 }
@@ -698,6 +699,7 @@ hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale
 void
 hidgl_fill_rect (int x1, int y1, int x2, int y2)
 {
+  hidgl_ensure_triangle_space (&buffer, 2);
   hidgl_add_triangle (&buffer, x1, y1, x1, y2, x2, y2);
   hidgl_add_triangle (&buffer, x2, y1, x2, y2, x1, y1);
 }
@@ -786,6 +788,12 @@ hidgl_reset_stencil_usage (void)
   dirty_bits = 0;
 }
 
+void
+hidgl_set_depth (float depth)
+{
+  global_depth = depth;
+}
+
 
 /* ---------------------------------------------------------------------- */
 
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index 4e86e27..e28b586 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -25,16 +25,17 @@
 
 //#define TRIANGLE_ARRAY_SIZE 5000
 #define TRIANGLE_ARRAY_SIZE 5461
-/* Assumes GLFloat is 4 bytes, and we have X,Y coords x3 for each triangle:
+/* Assumes GLFloat is 4 bytes, and we have X,Y(,Z) coords x3 for each triangle:
    4 * 5461 * 2 * 3 = 109464 */
-#define TRIANGLE_ARRAY_BYTES 131072
+//#define TRIANGLE_ARRAY_BYTES 131072
 typedef struct {
-  GLfloat triangle_array [2 * 3 * TRIANGLE_ARRAY_SIZE];
+  GLfloat triangle_array [3 * 3 * TRIANGLE_ARRAY_SIZE];
   unsigned int triangle_count;
   unsigned int coord_comp_count;
 } triangle_buffer;
 
 extern triangle_buffer buffer;
+extern float global_depth;
 
 void hidgl_init_triangle_array (triangle_buffer *buffer);
 void hidgl_flush_triangles (triangle_buffer *buffer);
@@ -46,12 +47,19 @@ hidgl_add_triangle (triangle_buffer *buffer,
                     GLfloat x2, GLfloat y2,
                     GLfloat x3, GLfloat y3)
 {
+  if (buffer->triangle_count == TRIANGLE_ARRAY_SIZE) {
+    printf ("OH CRAP\n");
+    *(char *)0 = 0;
+  }
   buffer->triangle_array [buffer->coord_comp_count++] = x1;
   buffer->triangle_array [buffer->coord_comp_count++] = y1;
+  buffer->triangle_array [buffer->coord_comp_count++] = global_depth;
   buffer->triangle_array [buffer->coord_comp_count++] = x2;
   buffer->triangle_array [buffer->coord_comp_count++] = y2;
+  buffer->triangle_array [buffer->coord_comp_count++] = global_depth;
   buffer->triangle_array [buffer->coord_comp_count++] = x3;
   buffer->triangle_array [buffer->coord_comp_count++] = y3;
+  buffer->triangle_array [buffer->coord_comp_count++] = global_depth;
   buffer->triangle_count++;
 }
 
@@ -69,5 +77,6 @@ int hidgl_stencil_bits (void);
 int hidgl_assign_clear_stencil_bit (void);
 void hidgl_return_stencil_bit (int bit);
 void hidgl_reset_stencil_usage (void);
+void hidgl_set_depth (float depth);
 
 #endif /* __HIDGL_INCLUDED__  */
diff --git a/src/hid/common/trackball.c b/src/hid/common/trackball.c
new file mode 100644
index 0000000..c4b8501
--- /dev/null
+++ b/src/hid/common/trackball.c
@@ -0,0 +1,324 @@
+/*
+ * (c) Copyright 1993, 1994, Silicon Graphics, Inc.
+ * ALL RIGHTS RESERVED
+ * Permission to use, copy, modify, and distribute this software for
+ * any purpose and without fee is hereby granted, provided that the above
+ * copyright notice appear in all copies and that both the copyright notice
+ * and this permission notice appear in supporting documentation, and that
+ * the name of Silicon Graphics, Inc. not be used in advertising
+ * or publicity pertaining to distribution of the software without specific,
+ * written prior permission.
+ *
+ * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
+ * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
+ * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
+ * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
+ * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
+ * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
+ * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
+ * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
+ * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN PAD_CONNECTION WITH THE
+ * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * US Government Users Restricted Rights
+ * Use, duplication, or disclosure by the Government is subject to
+ * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
+ * (c)(1)(ii) of the Rights in Technical Data and Computer Software
+ * clause at DFARS 252.227-7013 and/or in similar or successor
+ * clauses in the FAR or the DOD or NASA FAR Supplement.
+ * Unpublished-- rights reserved under the copyright laws of the
+ * United States.  Contractor/manufacturer is Silicon Graphics,
+ * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
+ *
+ * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
+ */
+/*
+ * Trackball code:
+ *
+ * Implementation of a virtual trackball.
+ * Implemented by Gavin Bell, lots of ideas from Thant Tessman and
+ *   the August '88 issue of Siggraph's "Computer Graphics," pp. 121-129.
+ *
+ * Vector manip code:
+ *
+ * Original code from:
+ * David M. Ciemiewicz, Mark Grossman, Henry Moreton, and Paul Haeberli
+ *
+ * Much mucking with by:
+ * Gavin Bell
+ */
+#include <math.h>
+#include "trackball.h"
+
+/*
+ * This size should really be based on the distance from the center of
+ * rotation to the point on the object underneath the mouse.  That
+ * point would then track the mouse as closely as possible.  This is a
+ * simple example, though, so that is left as an Exercise for the
+ * Programmer.
+ */
+#define TRACKBALLSIZE  (0.8f)
+
+/*
+ * Local function prototypes (not defined in trackball.h)
+ */
+static float tb_project_to_sphere(float, float, float);
+static void normalize_quat(float [4]);
+
+void
+vzero(float *v)
+{
+    v[0] = 0.0;
+    v[1] = 0.0;
+    v[2] = 0.0;
+}
+
+void
+vset(float *v, float x, float y, float z)
+{
+    v[0] = x;
+    v[1] = y;
+    v[2] = z;
+}
+
+void
+vsub(const float *src1, const float *src2, float *dst)
+{
+    dst[0] = src1[0] - src2[0];
+    dst[1] = src1[1] - src2[1];
+    dst[2] = src1[2] - src2[2];
+}
+
+void
+vcopy(const float *v1, float *v2)
+{
+    register int i;
+    for (i = 0 ; i < 3 ; i++)
+        v2[i] = v1[i];
+}
+
+void
+vcross(const float *v1, const float *v2, float *cross)
+{
+    float temp[3];
+
+    temp[0] = (v1[1] * v2[2]) - (v1[2] * v2[1]);
+    temp[1] = (v1[2] * v2[0]) - (v1[0] * v2[2]);
+    temp[2] = (v1[0] * v2[1]) - (v1[1] * v2[0]);
+    vcopy(temp, cross);
+}
+
+float
+vlength(const float *v)
+{
+    return (float) sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
+}
+
+void
+vscale(float *v, float div)
+{
+    v[0] *= div;
+    v[1] *= div;
+    v[2] *= div;
+}
+
+void
+vnormal(float *v)
+{
+    vscale(v, 1.0f/vlength(v));
+}
+
+float
+vdot(const float *v1, const float *v2)
+{
+    return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
+}
+
+void
+vadd(const float *src1, const float *src2, float *dst)
+{
+    dst[0] = src1[0] + src2[0];
+    dst[1] = src1[1] + src2[1];
+    dst[2] = src1[2] + src2[2];
+}
+
+/*
+ * Ok, simulate a track-ball.  Project the points onto the virtual
+ * trackball, then figure out the axis of rotation, which is the cross
+ * product of P1 P2 and O P1 (O is the center of the ball, 0,0,0)
+ * Note:  This is a deformed trackball-- is a trackball in the center,
+ * but is deformed into a hyperbolic sheet of rotation away from the
+ * center.  This particular function was chosen after trying out
+ * several variations.
+ *
+ * It is assumed that the arguments to this routine are in the range
+ * (-1.0 ... 1.0)
+ */
+void
+trackball(float q[4], float p1x, float p1y, float p2x, float p2y)
+{
+    float a[3]; /* Axis of rotation */
+    float phi;  /* how much to rotate about axis */
+    float p1[3], p2[3], d[3];
+    float t;
+
+    if (p1x == p2x && p1y == p2y) {
+        /* Zero rotation */
+        vzero(q);
+        q[3] = 1.0;
+        return;
+    }
+
+    /*
+     * First, figure out z-coordinates for projection of P1 and P2 to
+     * deformed sphere
+     */
+    vset(p1, p1x, p1y, tb_project_to_sphere(TRACKBALLSIZE, p1x, p1y));
+    vset(p2, p2x, p2y, tb_project_to_sphere(TRACKBALLSIZE, p2x, p2y));
+
+    /*
+     *  Now, we want the cross product of P1 and P2
+     */
+    vcross(p2,p1,a);
+
+    /*
+     *  Figure out how much to rotate around that axis.
+     */
+    vsub(p1, p2, d);
+    t = vlength(d) / (2.0f*TRACKBALLSIZE);
+
+    /*
+     * Avoid problems with out-of-control values...
+     */
+    if (t > 1.0) t = 1.0;
+    if (t < -1.0) t = -1.0;
+    phi = 2.0f * (float) asin(t);
+
+    axis_to_quat(a,phi,q);
+}
+
+/*
+ *  Given an axis and angle, compute quaternion.
+ */
+void
+axis_to_quat(float a[3], float phi, float q[4])
+{
+    vnormal(a);
+    vcopy(a, q);
+    vscale(q, (float) sin(phi/2.0));
+    q[3] = (float) cos(phi/2.0);
+}
+
+/*
+ * Project an x,y pair onto a sphere of radius r OR a hyperbolic sheet
+ * if we are away from the center of the sphere.
+ */
+static float
+tb_project_to_sphere(float r, float x, float y)
+{
+    float d, t, z;
+
+    d = (float) sqrt(x*x + y*y);
+    if (d < r * 0.70710678118654752440) {    /* Inside sphere */
+        z = (float) sqrt(r*r - d*d);
+    } else {           /* On hyperbola */
+        t = r / 1.41421356237309504880f;
+        z = t*t / d;
+    }
+    return z;
+}
+
+/*
+ * Given two rotations, e1 and e2, expressed as quaternion rotations,
+ * figure out the equivalent single rotation and stuff it into dest.
+ *
+ * This routine also normalizes the result every RENORMCOUNT times it is
+ * called, to keep error from creeping in.
+ *
+ * NOTE: This routine is written so that q1 or q2 may be the same
+ * as dest (or each other).
+ */
+
+#define RENORMCOUNT 97
+
+void
+add_quats(float q1[4], float q2[4], float dest[4])
+{
+    static int count=0;
+    float t1[4], t2[4], t3[4];
+    float tf[4];
+
+    vcopy(q1,t1);
+    vscale(t1,q2[3]);
+
+    vcopy(q2,t2);
+    vscale(t2,q1[3]);
+
+    vcross(q2,q1,t3);
+    vadd(t1,t2,tf);
+    vadd(t3,tf,tf);
+    tf[3] = q1[3] * q2[3] - vdot(q1,q2);
+
+    dest[0] = tf[0];
+    dest[1] = tf[1];
+    dest[2] = tf[2];
+    dest[3] = tf[3];
+
+    if (++count > RENORMCOUNT) {
+        count = 0;
+        normalize_quat(dest);
+    }
+}
+
+/*
+ * Quaternions always obey:  a^2 + b^2 + c^2 + d^2 = 1.0
+ * If they don't add up to 1.0, dividing by their magnitued will
+ * renormalize them.
+ *
+ * Note: See the following for more information on quaternions:
+ *
+ * - Shoemake, K., Animating rotation with quaternion curves, Computer
+ *   Graphics 19, No 3 (Proc. SIGGRAPH'85), 245-254, 1985.
+ * - Pletinckx, D., Quaternion calculus as a basic tool in computer
+ *   graphics, The Visual Computer 5, 2-13, 1989.
+ */
+static void
+normalize_quat(float q[4])
+{
+    int i;
+    float mag;
+
+    mag = (q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + q[3]*q[3]);
+    for (i = 0; i < 4; i++) q[i] /= mag;
+}
+
+/*
+ * Build a rotation matrix, given a quaternion rotation.
+ *
+ */
+void
+build_rotmatrix(float m[4][4], float q[4])
+{
+    m[0][0] = 1.0f - 2.0f * (q[1] * q[1] + q[2] * q[2]);
+    m[0][1] = 2.0f * (q[0] * q[1] - q[2] * q[3]);
+    m[0][2] = 2.0f * (q[2] * q[0] + q[1] * q[3]);
+    m[0][3] = 0.0f;
+
+    m[1][0] = 2.0f * (q[0] * q[1] + q[2] * q[3]);
+    m[1][1]= 1.0f - 2.0f * (q[2] * q[2] + q[0] * q[0]);
+    m[1][2] = 2.0f * (q[1] * q[2] - q[0] * q[3]);
+    m[1][3] = 0.0f;
+
+    m[2][0] = 2.0f * (q[2] * q[0] - q[1] * q[3]);
+    m[2][1] = 2.0f * (q[1] * q[2] + q[0] * q[3]);
+    m[2][2] = 1.0f - 2.0f * (q[1] * q[1] + q[0] * q[0]);
+    m[2][3] = 0.0f;
+
+    m[3][0] = 0.0f;
+    m[3][1] = 0.0f;
+    m[3][2] = 0.0f;
+    m[3][3] = 1.0f;
+}
+
diff --git a/src/hid/common/trackball.h b/src/hid/common/trackball.h
new file mode 100644
index 0000000..ed0c267
--- /dev/null
+++ b/src/hid/common/trackball.h
@@ -0,0 +1,78 @@
+/*
+ * (c) Copyright 1993, 1994, Silicon Graphics, Inc.
+ * ALL RIGHTS RESERVED
+ * Permission to use, copy, modify, and distribute this software for
+ * any purpose and without fee is hereby granted, provided that the above
+ * copyright notice appear in all copies and that both the copyright notice
+ * and this permission notice appear in supporting documentation, and that
+ * the name of Silicon Graphics, Inc. not be used in advertising
+ * or publicity pertaining to distribution of the software without specific,
+ * written prior permission.
+ *
+ * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
+ * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
+ * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
+ * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
+ * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
+ * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
+ * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
+ * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
+ * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN PAD_CONNECTION WITH THE
+ * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * US Government Users Restricted Rights
+ * Use, duplication, or disclosure by the Government is subject to
+ * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
+ * (c)(1)(ii) of the Rights in Technical Data and Computer Software
+ * clause at DFARS 252.227-7013 and/or in similar or successor
+ * clauses in the FAR or the DOD or NASA FAR Supplement.
+ * Unpublished-- rights reserved under the copyright laws of the
+ * United States.  Contractor/manufacturer is Silicon Graphics,
+ * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
+ *
+ * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
+ */
+/*
+ * trackball.h
+ * A virtual trackball implementation
+ * Written by Gavin Bell for Silicon Graphics, November 1988.
+ */
+
+/*
+ * Pass the x and y coordinates of the last and current positions of
+ * the mouse, scaled so they are from (-1.0 ... 1.0).
+ *
+ * The resulting rotation is returned as a quaternion rotation in the
+ * first paramater.
+ */
+void
+trackball(float q[4], float p1x, float p1y, float p2x, float p2y);
+
+/*
+ * Given two quaternions, add them together to get a third quaternion.
+ * Adding quaternions to get a compound rotation is analagous to adding
+ * translations to get a compound translation.  When incrementally
+ * adding rotations, the first argument here should be the new
+ * rotation, the second and third the total rotation (which will be
+ * over-written with the resulting new total rotation).
+ */
+void
+add_quats(float *q1, float *q2, float *dest);
+
+/*
+ * A useful function, builds a rotation matrix in Matrix based on
+ * given quaternion.
+ */
+void
+build_rotmatrix(float m[4][4], float q[4]);
+
+/*
+ * This function computes a quaternion based on an axis (defined by
+ * the given vector) and an angle about which to rotate.  The angle is
+ * expressed in radians.  The result is put into the third argument.
+ */
+void
+axis_to_quat(float a[3], float phi, float q[4]);
+
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 1b28e71..41ebe19 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -531,6 +531,18 @@ ghid_set_layer (const char *name, int group, int empty)
   /* Flush out any existing geoemtry to be rendered */
   hidgl_flush_triangles (&buffer);
 
+  if (group >= 0 && group < max_layer) {
+    hidgl_set_depth ((max_layer - group) * 10);
+  } else {
+    if (SL_TYPE (idx) == SL_SILK) {
+      if (SL_SIDE (idx) == SL_TOP_SIDE && !Settings.ShowSolderSide) {
+        hidgl_set_depth (max_layer * 10 + 3);
+      } else {
+        hidgl_set_depth (10 - 3);
+      }
+    }
+  }
+
   glEnable (GL_STENCIL_TEST);                // Enable Stencil test
   glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value (with 1)
   /* Reset stencil buffer so we can paint anywhere */
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index 302fa2a..3bfd354 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -793,6 +793,32 @@ ghid_screen_update (void)
 void DrawAttached (Boolean);
 void draw_grid ();
 
+static float view_matrix[4][4] = {{1.0, 0.0, 0.0, 0.0},
+                                  {0.0, 1.0, 0.0, 0.0},
+                                  {0.0, 0.0, 1.0, 0.0},
+                                  {0.0, 0.0, 0.0, 1.0}};
+
+void
+ghid_port_rotate (void *ball, float *quarternion, gpointer userdata)
+{
+  int row, column;
+  build_rotmatrix (view_matrix, quarternion);
+
+#ifdef DEBUG_ROTATE
+  for (row = 0; row < 4; row++) {
+    printf ("[ %f", view_matrix[row][0]);
+    for (column = 1; column < 4; column++) {
+      printf (",\t%f", view_matrix[row][column]);
+    }
+    printf ("\t]\n");
+  }
+  printf ("\n");
+#endif
+
+  ghid_invalidate_all ();
+}
+
+
 #define Z_NEAR 3.0
 gboolean
 ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
@@ -825,99 +851,73 @@ ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
   glEnable (GL_BLEND);
   glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
 
+//  glEnable (GL_DEPTH_TEST);
+
 //  glEnable(GL_POLYGON_SMOOTH);
 //  glHint(GL_POLYGON_SMOOTH_HINT, [GL_FASTEST, GL_NICEST, or GL_DONT_CARE]);
 
-  glViewport (ev->area.x,
-              widget->allocation.height - ev->area.height - ev->area.y,
-              ev->area.width, ev->area.height);
+  glViewport (widget->allocation.x,     widget->allocation.y,
+              widget->allocation.width, widget->allocation.height);
 
+#if 0
   glEnable (GL_SCISSOR_TEST);
   glScissor (ev->area.x,
              widget->allocation.height - ev->area.height - ev->area.y,
              ev->area.width, ev->area.height);
+#endif
 
   glMatrixMode (GL_PROJECTION);
   glLoadIdentity ();
-  glOrtho (ev->area.x, ev->area.x + ev->area.width, ev->area.y + ev->area.height, ev->area.y, 0, 100);
+  glOrtho (0, widget->allocation.width, widget->allocation.height, 0, -100000, 100000);
   glMatrixMode (GL_MODELVIEW);
   glLoadIdentity ();
-  glTranslatef (0.0f, 0.0f, -Z_NEAR);
 
-  glEnable (GL_STENCIL_TEST);
-  glClearColor (gport->bg_color.red / 65535.,
-                gport->bg_color.green / 65535.,
-                gport->bg_color.blue / 65535.,
+  glTranslatef (widget->allocation.width / 2., widget->allocation.height / 2., 0);
+  glMultMatrixf (view_matrix);
+  glTranslatef (-widget->allocation.width / 2., -widget->allocation.height / 2., 0);
+
+//  glEnable (GL_STENCIL_TEST);
+  glClearColor (gport->offlimits_color.red / 65535.,
+                gport->offlimits_color.green / 65535.,
+                gport->offlimits_color.blue / 65535.,
                 1.);
 
-  glDepthMask (0);
+//  glClearDepth (1000);
+
   glClearStencil (0);
-  glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
+  glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
   hidgl_reset_stencil_usage ();
 
+#if 0
+  glClearColor (gport->bg_color.red / 65535.,
+                gport->bg_color.green / 65535.,
+                gport->bg_color.blue / 65535.,
+                1.);
+#endif
+
+#if 1
   region.X1 = MIN (Px (ev->area.x), Px (ev->area.x + ev->area.width + 1));
   region.X2 = MAX (Px (ev->area.x), Px (ev->area.x + ev->area.width + 1));
   region.Y1 = MIN (Py (ev->area.y), Py (ev->area.y + ev->area.height + 1));
   region.Y2 = MAX (Py (ev->area.y), Py (ev->area.y + ev->area.height + 1));
 
-  eleft = Vx (0);
-  eright = Vx (PCB->MaxWidth);
-  etop = Vy (0);
-  ebottom = Vy (PCB->MaxHeight);
-  if (eleft > eright)
-    {
-      int tmp = eleft;
-      eleft = eright;
-      eright = tmp;
-    }
-  if (etop > ebottom)
-    {
-      int tmp = etop;
-      etop = ebottom;
-      ebottom = tmp;
-    }
+  eleft = Vx (0); eright  = Vx (PCB->MaxWidth);
+  etop  = Vy (0); ebottom = Vy (PCB->MaxHeight);
 
-  glColor3f (gport->offlimits_color.red / 65535.,
-             gport->offlimits_color.green / 65535.,
-             gport->offlimits_color.blue / 65535.);
+  glColor3f (gport->bg_color.red / 65535.,
+             gport->bg_color.green / 65535.,
+             gport->bg_color.blue / 65535.);
 
   glBegin (GL_QUADS);
-  if (eleft > 0)
-    {
-      glVertex2i (0, 0);
-      glVertex2i (eleft, 0);
-      glVertex2i (eleft, gport->height);
-      glVertex2i (0, gport->height);
-    }
-  else
-    eleft = 0;
-  if (eright < gport->width)
-    {
-      glVertex2i (eright, 0);
-      glVertex2i (gport->width, 0);
-      glVertex2i (gport->width, gport->height);
-      glVertex2i (eright, gport->height);
-    }
-  else
-    eright = gport->width;
-  if (etop > 0)
-    {
-      glVertex2i (eleft, 0);
-      glVertex2i (eright, 0);
-      glVertex2i (eright, etop);
-      glVertex2i (eleft, etop);
-    }
-  if (ebottom < gport->height)
-    {
-      glVertex2i (eleft, ebottom);
-      glVertex2i (eright + 1, ebottom);
-      glVertex2i (eright + 1, gport->height);
-      glVertex2i (eleft, gport->height);
-    }
+  glVertex3i (eleft,  etop,    -50);
+  glVertex3i (eright, etop,    -50);
+  glVertex3i (eright, ebottom, -50);
+  glVertex3i (eleft,  ebottom, -50);
   glEnd ();
 
   /* TODO: Background image */
 
+#if 1
   hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
 
@@ -934,7 +934,8 @@ ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
                              -gport->view_x0,
                 ghid_flip_y ? gport->view_y0 - PCB->MaxHeight :
                              -gport->view_y0, 0);
-  hid_expose_callback (&ghid_hid, &region, 0);
+//  hid_expose_callback (&ghid_hid, &region, 0);
+  hid_expose_callback (&ghid_hid, NULL, 0);
   hidgl_flush_triangles (&buffer);
   glPopMatrix ();
 
@@ -954,10 +955,14 @@ ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
   hidgl_flush_triangles (&buffer);
   glPopMatrix ();
 
+#endif
+
   ghid_show_crosshair (TRUE);
 
   hidgl_flush_triangles (&buffer);
 
+#endif
+
   if (gdk_gl_drawable_is_double_buffered (pGlDrawable))
     gdk_gl_drawable_swap_buffers (pGlDrawable);
   else
diff --git a/src/hid/gtk/gui-top-window.c b/src/hid/gtk/gui-top-window.c
index 253542b..de48e56 100644
--- a/src/hid/gtk/gui-top-window.c
+++ b/src/hid/gtk/gui-top-window.c
@@ -123,6 +123,7 @@ a zoom in/out.
 #include "gui-icons-mode-buttons.data"
 #include "gui-icons-misc.data"
 #include "snavi.h"
+#include "gui-trackball.h"
 
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
@@ -2156,6 +2157,7 @@ ghid_build_pcb_top_window (void)
   GtkWidget *vbox_main, *vbox_left, *hbox_middle, *hbox = NULL;
   GtkWidget *viewport, *ebox, *vbox, *frame;
   GtkWidget *label;
+  GtkWidget *trackball;
   GHidPort *port = &ghid_port;
   gchar *s;
   GtkWidget *scrolled;
@@ -2264,6 +2266,11 @@ ghid_build_pcb_top_window (void)
       GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
   make_layer_buttons(vbox, port);
 
+  trackball = ghid_trackball_new ();
+  g_signal_connect (trackball, "rotation-changed",
+                    G_CALLBACK (ghid_port_rotate), NULL);
+  gtk_box_pack_start (GTK_BOX (vbox_left), trackball, FALSE, FALSE, 0);
+
   vbox = gtk_vbox_new(FALSE, 0);
   gtk_box_pack_start(GTK_BOX(vbox_left), vbox, FALSE, FALSE, 0);
   ghidgui->mode_buttons0_frame_vbox = vbox;
@@ -2665,8 +2672,10 @@ ghid_parse_arguments (int *argc, char ***argv)
 
   gtk_init (argc, argv);
   gtk_gl_init(argc, argv);
+//  glutInit (argc, argv);
 
   gport = &ghid_port;
+  fprintf (stderr, "gport set at %p\n", gport);
   gport->zoom = 300.0;
   pixel_slop = 300;
 
@@ -2674,7 +2683,7 @@ ghid_parse_arguments (int *argc, char ***argv)
   /* setup GL-context */
   gport->glconfig = gdk_gl_config_new_by_mode (GDK_GL_MODE_RGBA    |
                                                GDK_GL_MODE_STENCIL |
-//                                               GDK_GL_MODE_DEPTH   |
+                                               GDK_GL_MODE_DEPTH   |
                                                GDK_GL_MODE_DOUBLE);
   if (!gport->glconfig) {
     printf("Could not setup GL-context!\n");
diff --git a/src/hid/gtk/gui-trackball.c b/src/hid/gtk/gui-trackball.c
new file mode 100644
index 0000000..cd8ec44
--- /dev/null
+++ b/src/hid/gtk/gui-trackball.c
@@ -0,0 +1,334 @@
+/* $Id$ */
+
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 2009 PCB Contributors (See ChangeLog for details)
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Contact addresses for paper mail and Email:
+ *  Thomas Nau, Schlehenweg 15, 88471 Baustetten, Germany
+ *  Thomas.Nau@rz.uni-ulm.de
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "global.h"
+
+#include "gui.h"
+
+#include "copy.h"
+#include "data.h"
+#include "draw.h"
+#include "mymem.h"
+#include "move.h"
+#include "rotate.h"
+#include "hid/common/trackball.h"
+#include "gui-trackball.h"
+
+#ifdef HAVE_LIBDMALLOC
+#include <dmalloc.h>
+#endif
+
+RCSID ("$Id$");
+
+enum {
+  ROTATION_CHANGED,
+  LAST_SIGNAL
+};
+
+
+static guint ghid_trackball_signals[ LAST_SIGNAL ] = { 0 };
+static GObjectClass *ghid_trackball_parent_class = NULL;
+
+
+
+static gboolean
+button_press_cb (GtkWidget *widget, GdkEventButton *ev, gpointer userdata)
+{
+  GhidTrackball *ball = GHID_TRACKBALL (widget);
+
+  ball->x1 = 2. * ev->x / widget->allocation.width - 1.;
+  ball->y1 = 2. * ev->y / widget->allocation.height - 1.;
+
+  ball->dragging = TRUE;
+
+  return TRUE;
+}
+
+
+static gboolean
+button_release_cb (GtkWidget *widget, GdkEventButton *ev, gpointer userdata)
+{
+  GhidTrackball *ball = GHID_TRACKBALL (widget);
+
+  ball->quart1[0] = ball->quart2[0];
+  ball->quart1[1] = ball->quart2[1];
+  ball->quart1[2] = ball->quart2[2];
+  ball->quart1[3] = ball->quart2[3];
+
+  ball->dragging = FALSE;
+
+  return TRUE;
+}
+
+
+static gboolean
+motion_notify_cb (GtkWidget *widget, GdkEventMotion *ev, gpointer userdata)
+{
+  GhidTrackball *ball = GHID_TRACKBALL (widget);
+  double x1, y1;
+  double x2, y2;
+  float q[4];
+  float newq[4];
+
+  if (!ball->dragging)
+    return TRUE;
+
+  x1 = ball->x1;
+  y1 = ball->y1;
+
+  x2 = 2. * ev->x / widget->allocation.width - 1.;
+  y2 = 2. * ev->y / widget->allocation.height - 1.;
+
+  /* Trackball computation */
+  trackball (q, x1, y1, x2, y2);
+  add_quats (q, ball->quart1, ball->quart2);
+
+  g_signal_emit (ball, ghid_trackball_signals[ROTATION_CHANGED], 0, ball->quart2);
+
+  return TRUE;
+}
+
+
+/*! \brief GObject constructor
+ *
+ *  \par Function Description
+ *  Chain up and construct the object, then setup the
+ *  necessary state for our widget now it is constructed.
+ *
+ *  \param [in] type                    The GType of object to be constructed
+ *  \param [in] n_construct_properties  Number of construct properties
+ *  \param [in] contruct_params         The construct properties
+ *
+ *  \returns The GObject having just been constructed.
+ */
+static GObject *
+ghid_trackball_constructor (GType type,
+                            guint n_construct_properties,
+                            GObjectConstructParam *construct_properties)
+{
+  GhidTrackball *ball;
+  float axis[3];
+
+  /* chain up to constructor of parent class */
+  ball = GHID_TRACKBALL (G_OBJECT_CLASS (ghid_trackball_parent_class)->
+    constructor (type, n_construct_properties, construct_properties));
+
+  gtk_widget_set_size_request (GTK_WIDGET (ball), 100, 100);
+
+  axis[0] = 1.; axis[1] = 0.; axis[2] = 0.;
+  axis_to_quat (axis, 0, ball->quart1);
+  axis_to_quat (axis, 0, ball->quart2);
+
+  g_signal_connect (ball, "button-press-event",   G_CALLBACK (button_press_cb),   NULL);
+  g_signal_connect (ball, "button-release-event", G_CALLBACK (button_release_cb), NULL);
+  g_signal_connect (ball, "motion-notify-event",  G_CALLBACK (motion_notify_cb),  NULL);
+
+  gtk_widget_add_events (GTK_WIDGET (ball), GDK_BUTTON_PRESS_MASK   |
+                                            GDK_BUTTON_RELEASE_MASK |
+                                            GDK_POINTER_MOTION_MASK);
+
+  return G_OBJECT (ball);
+}
+
+
+
+/*! \brief GObject finalise handler
+ *
+ *  \par Function Description
+ *  Just before the GhidTrackball GObject is finalized, free our
+ *  allocated data, and then chain up to the parent's finalize handler.
+ *
+ *  \param [in] widget  The GObject being finalized.
+ */
+static void
+ghid_trackball_finalize (GObject * object)
+{
+//  GhidTrackball *pinout = GHID_TRACKBALL (object);
+
+  G_OBJECT_CLASS (ghid_trackball_parent_class)->finalize (object);
+}
+
+
+/*! \brief GObject property setter function
+ *
+ *  \par Function Description
+ *  Setter function for GhidTrackball's GObject properties,
+ *  "settings-name" and "toplevel".
+ *
+ *  \param [in]  object       The GObject whose properties we are setting
+ *  \param [in]  property_id  The numeric id. under which the property was
+ *                            registered with g_object_class_install_property()
+ *  \param [in]  value        The GValue the property is being set from
+ *  \param [in]  pspec        A GParamSpec describing the property being set
+ */
+static void
+ghid_trackball_set_property (GObject * object, guint property_id,
+				  const GValue * value, GParamSpec * pspec)
+{
+//  GhidTrackball *pinout = GHID_TRACKBALL (object);
+
+  switch (property_id)
+    {
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+    }
+}
+
+
+/*! \brief GObject property getter function
+ *
+ *  \par Function Description
+ *  Getter function for GhidTrackball's GObject properties,
+ *  "settings-name" and "toplevel".
+ *
+ *  \param [in]  object       The GObject whose properties we are getting
+ *  \param [in]  property_id  The numeric id. under which the property was
+ *                            registered with g_object_class_install_property()
+ *  \param [out] value        The GValue in which to return the value of the property
+ *  \param [in]  pspec        A GParamSpec describing the property being got
+ */
+static void
+ghid_trackball_get_property (GObject * object, guint property_id,
+				  GValue * value, GParamSpec * pspec)
+{
+  switch (property_id)
+    {
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+    }
+
+}
+
+
+static gboolean
+ghid_trackball_expose (GtkWidget * widget, GdkEventExpose * ev)
+{
+  gdk_draw_arc (widget->window,
+                widget->style->fg_gc[GTK_WIDGET_STATE (widget)],
+                TRUE,
+                0, 0, widget->allocation.width, widget->allocation.height,
+                0, 64 * 360);
+  return TRUE;
+}
+
+
+/*! \brief GType class initialiser for GhidTrackball
+ *
+ *  \par Function Description
+ *  GType class initialiser for GhidTrackball. We override our parent
+ *  virtual class methods as needed and register our GObject properties.
+ *
+ *  \param [in]  klass       The GhidTrackballClass we are initialising
+ */
+static void
+ghid_trackball_class_init (GhidTrackballClass * klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+  GtkWidgetClass *gtk_widget_class = GTK_WIDGET_CLASS (klass);
+
+  gobject_class->constructor  = ghid_trackball_constructor;
+  gobject_class->finalize     = ghid_trackball_finalize;
+  gobject_class->set_property = ghid_trackball_set_property;
+  gobject_class->get_property = ghid_trackball_get_property;
+
+  gtk_widget_class->expose_event = ghid_trackball_expose;
+
+  ghid_trackball_parent_class = g_type_class_peek_parent (klass);
+
+  ghid_trackball_signals[ROTATION_CHANGED] =
+    g_signal_new ("rotation-changed",
+                  G_OBJECT_CLASS_TYPE( gobject_class ),
+                  G_SIGNAL_RUN_FIRST,     /*signal_flags */
+                  G_STRUCT_OFFSET( GhidTrackballClass, rotation_changed ),
+                  NULL, /* accumulator */
+                  NULL, /* accu_data */
+                  g_cclosure_marshal_VOID__POINTER,
+                  G_TYPE_NONE,
+                  1,    /* n_params */
+                  G_TYPE_POINTER
+                 );
+}
+
+
+/*! \brief Function to retrieve GhidTrackball's GType identifier.
+ *
+ *  \par Function Description
+ *  Function to retrieve GhidTrackball's GType identifier.
+ *  Upon first call, this registers the GhidTrackball in the GType system.
+ *  Subsequently it returns the saved value from its first execution.
+ *
+ *  \return the GType identifier associated with GhidTrackball.
+ */
+GType
+ghid_trackball_get_type ()
+{
+  static GType ghid_trackball_type = 0;
+
+  if (!ghid_trackball_type)
+    {
+      static const GTypeInfo ghid_trackball_info = {
+	sizeof (GhidTrackballClass),
+	NULL,			/* base_init */
+	NULL,			/* base_finalize */
+	(GClassInitFunc) ghid_trackball_class_init,
+	NULL,			/* class_finalize */
+	NULL,			/* class_data */
+	sizeof (GhidTrackball),
+	0,			/* n_preallocs */
+	NULL,			/* instance_init */
+      };
+
+      ghid_trackball_type =
+	g_type_register_static (GTK_TYPE_DRAWING_AREA, "GhidTrackball",
+				&ghid_trackball_info, 0);
+    }
+
+  return ghid_trackball_type;
+}
+
+
+/*! \brief Convenience function to create a new pinout preview
+ *
+ *  \par Function Description
+ *  Convenience function which creates a GhidTrackball.
+ *
+ *  \return  The GhidTrackball created.
+ */
+GtkWidget *
+ghid_trackball_new (void)
+{
+  GhidTrackball *ball;
+
+  ball = g_object_new (GHID_TYPE_TRACKBALL, NULL);
+
+  return GTK_WIDGET (ball);
+}
diff --git a/src/hid/gtk/gui-trackball.h b/src/hid/gtk/gui-trackball.h
new file mode 100644
index 0000000..3318695
--- /dev/null
+++ b/src/hid/gtk/gui-trackball.h
@@ -0,0 +1,66 @@
+/* $Id$ */
+
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 2009  PCB Contributors (see ChangeLog for details)
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Contact addresses for paper mail and Email:
+ *  Thomas Nau, Schlehenweg 15, 88471 Baustetten, Germany
+ *  Thomas.Nau@rz.uni-ulm.de
+ *
+ */
+
+#ifndef __GHID_TRACKBALL_H__
+#define __GHID_TRACKBALL_H__
+
+
+#define GHID_TYPE_TRACKBALL           (ghid_trackball_get_type())
+#define GHID_TRACKBALL(obj)           (G_TYPE_CHECK_INSTANCE_CAST ((obj), GHID_TYPE_TRACKBALL, GhidTrackball))
+#define GHID_TRACKBALL_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST ((klass),  GHID_TYPE_TRACKBALL, GhidTrackballClass))
+#define GHID_IS_TRACKBALL(obj)        (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GHID_TYPE_TRACKBALL))
+#define GHID_TRACKBALL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj),  GHID_TYPE_TRACKBALL, GhidTrackballClass))
+
+typedef struct _GhidTrackballClass GhidTrackballClass;
+typedef struct _GhidTrackball GhidTrackball;
+
+
+struct _GhidTrackballClass
+{
+  GtkDrawingAreaClass parent_class;
+
+  void (*rotation_changed) (GhidTrackball *ball, gpointer rotation, gpointer user_data);
+};
+
+struct _GhidTrackball
+{
+  GtkDrawingArea parent_instance;
+
+  gboolean dragging;
+  gdouble x1, y1;
+
+  float quart1[4];
+  float quart2[4];
+};
+
+
+GType ghid_trackball_get_type (void);
+
+GtkWidget *ghid_trackball_new (void);
+
+#endif /* __GHID_TRACKBALL_H__ */
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index 2e73111..f7149b0 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -366,6 +366,8 @@ gint ghid_port_window_motion_cb (GtkWidget * widget,
 gint ghid_port_window_mouse_scroll_cb (GtkWidget * widget,
 				       GdkEventScroll * ev, GHidPort * out);
 
+void
+ghid_port_rotate (void *ball, float *quarternion, gpointer userdata);
 
 gint ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
 					     GdkEventExpose * ev,

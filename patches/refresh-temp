Bottom: 0907977d30104ba981480ca7ec03401cbb381b8e
Top:    667bf2ce5a93a32dea2a644eb325d2a0b023490c
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-11-06 15:33:10 +0000

Refresh of bentley-ottann-test-implementa

---

diff --git a/src/cairo/cairo-bentley-ottmann.c b/src/cairo/cairo-bentley-ottmann.c
index 22fa43c..778d69c 100644
--- a/src/cairo/cairo-bentley-ottmann.c
+++ b/src/cairo/cairo-bentley-ottmann.c
@@ -1727,44 +1727,25 @@ _cairo_bentley_ottmann_tessellate_bo_edges (cairo_bo_event_t   **start_events,
     return status;
 }
 
-
 static void
-poly_area_to_start_events (POLYAREA                *poly,
-                           cairo_bo_start_event_t  *events,
-                           cairo_bo_event_t       **event_ptrs,
-                           int                     *counter)
+contour_to_start_events (PLINE                   *contour,
+                         cairo_bo_start_event_t  *events,
+                         cairo_bo_event_t       **event_ptrs,
+                         int                     *counter,
+                         int                      outer_contour)
 {
     int i = *counter;
-    PLINE *contour;
-    POLYAREA *pa;
-    int outer_contour;
+    VNODE *bv;
 
-    pa = poly;
+    /* Loop over nodes, adding edges */
+    bv = &contour->head;
     do {
-      /* Loop over contours */
-      outer_contour = 1;
-      for (contour = pa->contours; contour != NULL; contour = contour->next) {
-        /* Loop over nodes, adding edges */
-        VNODE *bv;
-        bv = &contour->head;
-        do {
-          int x1, y1, x2, y2;
-          cairo_edge_t cairo_edge;
-          /* Node is between bv->point[0,1] and bv->next->point[0,1] */
-
-          if (bv->point[1] == bv->next->point[1]) {
-              if (bv->point[0] < bv->next->point[0]) {
-                x1 = bv->point[0];
-                y1 = bv->point[1];
-                x2 = bv->next->point[0];
-                y2 = bv->next->point[1];
-              } else {
-                x1 = bv->next->point[0];
-                y1 = bv->next->point[1];
-                x2 = bv->point[0];
-                y2 = bv->point[1];
-              }
-          } else if (bv->point[1] < bv->next->point[1]) {
+      int x1, y1, x2, y2;
+      cairo_edge_t cairo_edge;
+      /* Node is between bv->point[0,1] and bv->next->point[0,1] */
+
+      if (bv->point[1] == bv->next->point[1]) {
+          if (bv->point[0] < bv->next->point[0]) {
             x1 = bv->point[0];
             y1 = bv->point[1];
             x2 = bv->next->point[0];
@@ -1775,28 +1756,62 @@ poly_area_to_start_events (POLYAREA                *poly,
             x2 = bv->point[0];
             y2 = bv->point[1];
           }
+      } else if (bv->point[1] < bv->next->point[1]) {
+        x1 = bv->point[0];
+        y1 = bv->point[1];
+        x2 = bv->next->point[0];
+        y2 = bv->next->point[1];
+      } else {
+        x1 = bv->next->point[0];
+        y1 = bv->next->point[1];
+        x2 = bv->point[0];
+        y2 = bv->point[1];
+      }
 
-          cairo_edge.line.p1.x = x1;
-          cairo_edge.line.p1.y = y1;
-          cairo_edge.line.p2.x = x2;
-          cairo_edge.line.p2.y = y2;
-          cairo_edge.top = y1;
-          cairo_edge.bottom = y2;
-          cairo_edge.dir = outer_contour ? 1 : -1;
+      cairo_edge.line.p1.x = x1;
+      cairo_edge.line.p1.y = y1;
+      cairo_edge.line.p2.x = x2;
+      cairo_edge.line.p2.y = y2;
+      cairo_edge.top = y1;
+      cairo_edge.bottom = y2;
+      cairo_edge.dir = outer_contour ? 1 : -1;
 
-          event_ptrs[i] = (cairo_bo_event_t *) &events[i];
+      event_ptrs[i] = (cairo_bo_event_t *) &events[i];
 
-          events[i].type = CAIRO_BO_EVENT_TYPE_START;
-          events[i].point.y = cairo_edge.line.p1.y;
-          events[i].point.x = cairo_edge.line.p1.x;
+      events[i].type = CAIRO_BO_EVENT_TYPE_START;
+      events[i].point.y = cairo_edge.line.p1.y;
+      events[i].point.x = cairo_edge.line.p1.x;
 
-          events[i].edge.edge = cairo_edge;
-          events[i].edge.deferred_trap.right = NULL;
-          events[i].edge.prev = NULL;
-          events[i].edge.next = NULL;
-          i++;
+      events[i].edge.edge = cairo_edge;
+      events[i].edge.deferred_trap.right = NULL;
+      events[i].edge.prev = NULL;
+      events[i].edge.next = NULL;
+      i++;
 
-        } while ((bv = bv->next) != &contour->head);
+    } while ((bv = bv->next) != &contour->head);
+
+    *counter = i;
+}
+
+
+static void
+poly_area_to_start_events (POLYAREA                *poly,
+                           cairo_bo_start_event_t  *events,
+                           cairo_bo_event_t       **event_ptrs,
+                           int                     *counter)
+{
+    int i = *counter;
+    PLINE *contour;
+    POLYAREA *pa;
+    int outer_contour;
+
+    pa = poly;
+    do {
+      /* Loop over contours */
+      outer_contour = 1;
+      for (contour = pa->contours; contour != NULL; contour = contour->next) {
+        contour_to_start_events (contour, events, event_ptrs,
+                                 counter, outer_contour);
         outer_contour = 0;
       }
 
@@ -1902,3 +1917,94 @@ bo_poly_to_traps (POLYAREA *poly, cairo_traps_t *traps)
 
   return CAIRO_STATUS_SUCCESS;
 }
+
+
+cairo_status_t
+bo_contour_to_traps (PLINE *contour, cairo_traps_t *traps)
+{
+  int intersections;
+  cairo_status_t status;
+  cairo_bo_start_event_t stack_events[CAIRO_STACK_ARRAY_LENGTH (cairo_bo_start_event_t)];
+  cairo_bo_start_event_t *events;
+  cairo_bo_event_t *stack_event_ptrs[ARRAY_LENGTH (stack_events) + 1];
+  cairo_bo_event_t **event_ptrs;
+  int num_events = 0;
+  int i;
+  int n;
+
+  num_events = contour->Count;
+
+  if (unlikely (0 == num_events))
+      return CAIRO_STATUS_SUCCESS;
+
+  events = stack_events;
+  event_ptrs = stack_event_ptrs;
+  if (num_events > ARRAY_LENGTH (stack_events)) {
+      events = _cairo_malloc_ab_plus_c (num_events,
+                                        sizeof (cairo_bo_start_event_t) +
+                                        sizeof (cairo_bo_event_t *),
+                                        sizeof (cairo_bo_event_t *));
+      if (unlikely (events == NULL))
+          return CAIRO_STATUS_NO_MEMORY;
+
+      event_ptrs = (cairo_bo_event_t **) (events + num_events);
+  }
+
+  i = 0;
+
+  contour_to_start_events (contour, events, event_ptrs, &i, 1);
+
+  /* XXX: This would be the convenient place to throw in multiple
+   * passes of the Bentley-Ottmann algorithm. It would merely
+   * require storing the results of each pass into a temporary
+   * cairo_traps_t. */
+  status = _cairo_bentley_ottmann_tessellate_bo_edges (event_ptrs,
+                                                       num_events,
+                                                       traps,
+                                                       &intersections);
+
+  for (n = 0; n < traps->num_traps; n++) {
+    int x1, y1, x2, y2, x3, y3, x4, y4;
+
+    x1 = _line_compute_intersection_x_for_y (&traps->traps[n].left, traps->traps[n].top);
+    y1 = traps->traps[n].top;
+    x2 = _line_compute_intersection_x_for_y (&traps->traps[n].right, traps->traps[n].top);
+    y2 = traps->traps[n].top;
+    x3 = _line_compute_intersection_x_for_y (&traps->traps[n].right, traps->traps[n].bottom);
+    y3 = traps->traps[n].bottom;
+    x4 = _line_compute_intersection_x_for_y (&traps->traps[n].left, traps->traps[n].bottom);
+    y4 = traps->traps[n].bottom;
+
+#if 1
+    if (x1 == x2) {
+      hidgl_ensure_triangle_space (&buffer, 1);
+      hidgl_add_triangle (&buffer, x1, y1, x3, y3, x4, y4);
+    } else if (x3 == x4) {
+      hidgl_ensure_triangle_space (&buffer, 1);
+      hidgl_add_triangle (&buffer, x1, y1, x2, y2, x3, y3);
+    } else {
+      hidgl_ensure_triangle_space (&buffer, 2);
+      hidgl_add_triangle (&buffer, x1, y1, x2, y2, x3, y3);
+      hidgl_add_triangle (&buffer, x3, y3, x4, y4, x1, y1);
+    }
+#else
+    glBegin (GL_LINES);
+    glVertex2i (x1, y1); glVertex2i (x2, y2);
+    glVertex2i (x2, y2); glVertex2i (x3, y3);
+     glVertex2i (x3, y3); glVertex2i (x1, y1);
+    glVertex2i (x3, y3); glVertex2i (x4, y4);
+    glVertex2i (x4, y4); glVertex2i (x1, y1);
+     glVertex2i (x1, y1); glVertex2i (x3, y3);
+    glEnd ();
+#endif
+  }
+
+#if DEBUG_TRAPS
+  dump_traps (traps, "bo-polygon-out.txt");
+#endif
+
+  if (events != stack_events)
+      free (events);
+
+  return CAIRO_STATUS_SUCCESS;
+}
diff --git a/src/sweep.h b/src/sweep.h
index 2d084ed..257664f 100644
--- a/src/sweep.h
+++ b/src/sweep.h
@@ -1,3 +1,4 @@
 #include "cairo/cairo-traps-private.h"
 
 cairo_status_t bo_poly_to_traps (POLYAREA *poly, cairo_traps_t *traps);
+cairo_status_t bo_contour_to_traps (PLINE *contour, cairo_traps_t *traps);

Bottom: 1eaf1e30fae8ce7753cb67b8dbac211565b6ca19
Top:    e0c2390bc0268e2e55cf18323da8754307b2885f
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-08-26 03:16:46 +0100

Refresh of profile-noholes-dicer-and-add-

---

diff --git a/src/polygon.c b/src/polygon.c
index 74000ce..5742639 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -83,6 +83,7 @@ dicer output is used for HIDs which cannot render things with holes
 #include <memory.h>
 #include <setjmp.h>
 #include <glib.h>
+#include <time.h>
 
 #include "global.h"
 #include "box.h"
@@ -204,12 +205,21 @@ add_noholes_polyarea (PLINE *pline, void *user_data)
 void
 ComputeNoHoles (PolygonType *poly)
 {
+  clock_t start, end;
+  double elapsed;
+
+  start = clock();
+
   poly_FreeContours (&poly->NoHoles);
   if (poly->Clipped)
     NoHolesPolygonDicer (poly, NULL, add_noholes_polyarea, poly);
   else
     printf ("Compute_noholes caught poly->Clipped = NULL\n");
   poly->NoHolesValid = 1;
+
+  end = clock();
+  elapsed = ((double) (end - start)) / CLOCKS_PER_SEC;
+  printf ("Computing NoHoles polygons took %f\n", elapsed);
 }
 
 static POLYAREA *
diff --git a/src/polygon1.c b/src/polygon1.c
index 9948019..37f45a6 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -903,6 +903,7 @@ intersect_impl (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
       sb.X2 = pa->xmax + 1;
       sb.Y2 = pa->ymax + 1;
 
+//      printf ("Searching B's contours using an rtree\n");
       r_search (b->contour_tree, &sb, NULL, contour_bounds_touch, &c_info);
       if (c_info.need_restart) {
         need_restart = 1;
@@ -2249,7 +2250,7 @@ Touching (POLYAREA * a, POLYAREA * b)
 	return -1;
 #endif
       M_POLYAREA_intersect (&e, a, b, false);
-
+#warning Do we end up leaving uncleared labels on our polygons? (Does this mess up the new clipping code?)
       if (M_POLYAREA_label (a, b, TRUE))
 	return TRUE;
       if (M_POLYAREA_label (b, a, TRUE))
@@ -2392,6 +2393,7 @@ poly_Boolean_free (POLYAREA * ai, POLYAREA * bi, POLYAREA ** res, int action)
 
       InsertHoles (&e, *res, &holes);
     }
+#warning holes may be undefined due to the setjmp, if it was modified before the longjmp returned above.
   /* delete holes if any left */
   while ((p = holes) != NULL)
     {
@@ -2492,6 +2494,7 @@ poly_AndSubtract_free (POLYAREA * ai, POLYAREA * bi,
       poly_Free (&b);
       assert (poly_Valid (*aminusb));
     }
+#warning holes may be undefined due to the setjmp, if it was modified before the longjmp returned above.
   /* delete holes if any left */
   while ((p = holes) != NULL)
     {
@@ -2499,7 +2502,7 @@ poly_AndSubtract_free (POLYAREA * ai, POLYAREA * bi,
       poly_DelContour (&p);
     }
 
-
+#warning aand, aminsus may be undefined due to the setjmp, if it was modified before the longjmp returned above.
   if (code)
     {
       poly_Free (aandb);

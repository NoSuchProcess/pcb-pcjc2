Bottom: 7279da8a7692815ff32a1a1cd3aac620d0fdb10c
Top:    f0fb7ad4437d14bc21f179e02a84cf0c7d84ea90
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-04-26 14:01:52 +0100

Refresh of crasy-test

---

diff --git a/src/draw_funcs.c b/src/draw_funcs.c
new file mode 100644
index 0000000..e4ee955
--- /dev/null
+++ b/src/draw_funcs.c
@@ -0,0 +1,233 @@
+
+#include "global.h"
+#include "data.h"
+#include "draw_funcs.h"
+
+static void
+set_pv_color (PinType *pv, int type)
+{
+  char *color;
+
+  if (TEST_FLAG (WARNFLAG, pv))          color = PCB->WarnColor;
+  else if (TEST_FLAG (SELECTEDFLAG, pv)) color = (type == VIA_TYPE) ? PCB->ViaSelectedColor : PCB->PinSelectedColor;
+  else if (TEST_FLAG (FOUNDFLAG, pv))    color = PCB->ConnectedColor;
+  else                                   color = (type == VIA_TYPE) ? PCB->ViaColor : PCB->PinColor;
+
+  gui->set_color (Output.fgGC, color);
+}
+
+static void
+_draw_pv (PinType *pv, bool draw_hole)
+{
+  if (TEST_FLAG (THINDRAWFLAG, PCB))
+    gui->thindraw_pcb_pv (Output.fgGC, Output.fgGC, pv, draw_hole, false);
+  else
+    gui->fill_pcb_pv (Output.fgGC, Output.bgGC, pv, draw_hole, false);
+}
+
+static void
+draw_pin (PinType *pin, void *userdata)
+{
+  set_pv_color (pin, PIN_TYPE);
+  _draw_pv (pin, false);
+}
+
+static void
+draw_pin_mask (PinType *pin, void *userdata)
+{
+  if (TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG (THINDRAWPOLYFLAG, PCB))
+    gui->thindraw_pcb_pv (Output.pmGC, Output.pmGC, pin, false, true);
+  else
+    gui->fill_pcb_pv (Output.pmGC, Output.pmGC, pin, false, true);
+}
+
+static void
+draw_via (PinType *via, void *userdata)
+{
+  set_pv_color (via, VIA_TYPE);
+  _draw_pv (via, false);
+}
+
+static void
+draw_via_mask (PinType *via, void *userdata)
+{
+  if (TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG (THINDRAWPOLYFLAG, PCB))
+    gui->thindraw_pcb_pv (Output.pmGC, Output.pmGC, via, false, true);
+  else
+    gui->fill_pcb_pv (Output.pmGC, Output.pmGC, via, false, true);
+}
+
+static void
+_draw_pad (hidGC gc, PadType *pad, bool clear, bool mask)
+{
+  if (clear && !mask && pad->Clearance <= 0)
+    return;
+
+  if (TEST_FLAG (THINDRAWFLAG, PCB) ||
+      (clear && TEST_FLAG (THINDRAWPOLYFLAG, PCB)))
+    gui->thindraw_pcb_pad (gc, pad, clear, mask);
+  else
+    gui->fill_pcb_pad (gc, pad, clear, mask);
+}
+
+static void
+draw_pad (PadType *pad, void *userdata)
+{
+  if (TEST_FLAG (WARNFLAG, pad))          gui->set_color (Output.fgGC, PCB->WarnColor);
+  else if (TEST_FLAG (SELECTEDFLAG, pad)) gui->set_color (Output.fgGC, PCB->PinSelectedColor);
+  else if (TEST_FLAG (FOUNDFLAG, pad))    gui->set_color (Output.fgGC, PCB->ConnectedColor);
+  else if (FRONT (pad))                   gui->set_color (Output.fgGC, PCB->PinColor);
+  else                                    gui->set_color (Output.fgGC, PCB->InvisibleObjectsColor);
+
+  _draw_pad (Output.fgGC, pad, false, false);
+}
+
+static void
+draw_pad_mask (PadType *pad, void *userdata)
+{
+  if (pad->Mask <= 0)
+    return;
+
+  _draw_pad (Output.fgGC, pad, true, true);
+}
+
+static void
+draw_pad_paste (PadType *pad, void *userdata)
+{
+  if (TEST_FLAG (NOPASTEFLAG, pad) || pad->Mask <= 0)
+    return;
+
+  if (pad->Mask < pad->Thickness)
+    _draw_pad (Output.fgGC, pad, true, true);
+  else
+    _draw_pad (Output.fgGC, pad, false, false);
+}
+
+static void
+_draw_line (LineType *line)
+{
+  gui->set_line_cap (Output.fgGC, Trace_Cap);
+  if (TEST_FLAG (THINDRAWFLAG, PCB))
+    gui->set_line_width (Output.fgGC, 0);
+  else
+    gui->set_line_width (Output.fgGC, line->Thickness);
+
+  gui->draw_line (Output.fgGC,
+                  line->Point1.X, line->Point1.Y,
+                  line->Point2.X, line->Point2.Y);
+}
+
+static void
+draw_line (LineType *line, void *userdata)
+{
+  //if (TEST_FLAG (SELECTEDFLAG, line))   gui->set_color (Output.fgGC, layer->SelectedColor);
+  //else if (TEST_FLAG (FOUNDFLAG, line)) gui->set_color (Output.fgGC, PCB->ConnectedColor);
+  //else                                  gui->set_color (Output.fgGC, layer->Color);
+
+  _draw_line (line);
+}
+
+static void
+draw_rat (RatType *rat, void *userdata)
+{
+  //if (TEST_FLAG (SELECTEDFLAG, rat))   gui->set_color (Output.fgGC, PCB->RatSelectedColor);
+  //else if (TEST_FLAG (FOUNDFLAG, rat)) gui->set_color (Output.fgGC, PCB->ConnectedColor);
+  //else                                 gui->set_color (Output.fgGC, PCB->RatColor);
+
+  if (Settings.RatThickness < 20)
+    rat->Thickness = pixel_slop * Settings.RatThickness;
+  /* rats.c set VIAFLAG if this rat goes to a containing poly: draw a donut */
+  if (TEST_FLAG(VIAFLAG, rat))
+    {
+      int w = rat->Thickness;
+
+      if (TEST_FLAG (THINDRAWFLAG, PCB))
+        gui->set_line_width (Output.fgGC, 0);
+      else
+        gui->set_line_width (Output.fgGC, w);
+      gui->draw_arc (Output.fgGC, rat->Point1.X, rat->Point1.Y,
+                     w * 2, w * 2, 0, 360);
+    }
+  else
+    _draw_line ((LineType *) rat);
+}
+
+static void
+_draw_arc (ArcType *arc)
+{
+  if (!arc->Thickness)
+    return;
+
+  if (TEST_FLAG (THINDRAWFLAG, PCB))
+    gui->set_line_width (Output.fgGC, 0);
+  else
+    gui->set_line_width (Output.fgGC, arc->Thickness);
+  gui->set_line_cap (Output.fgGC, Trace_Cap);
+
+  gui->draw_arc (Output.fgGC, arc->X, arc->Y, arc->Width,
+                 arc->Height, arc->StartAngle, arc->Delta);
+}
+
+static void
+draw_arc (ArcType *arc, void *userdata)
+{
+  //if (TEST_FLAG (SELECTEDFLAG, arc))   gui->set_color (Output.fgGC, layer->SelectedColor);
+  //else if (TEST_FLAG (FOUNDFLAG, arc)) gui->set_color (Output.fgGC, PCB->ConnectedColor);
+  //else                                 gui->set_color (Output.fgGC, layer->Color);
+
+  _draw_arc (arc);
+}
+
+static void
+draw_poly (PolygonType *polygon, void *userdata)
+{
+  static char *color;
+
+  /* HACK */
+  BoxType *drawn_area = NULL;
+
+  if (!polygon->Clipped)
+    return;
+
+  //if (TEST_FLAG (SELECTEDFLAG, polygon))   color = layer->SelectedColor;
+  //else if (TEST_FLAG (FOUNDFLAG, polygon)) color = PCB->ConnectedColor;
+  //else                                     color = layer->Color;
+
+  gui->set_color (Output.fgGC, color);
+
+  if (gui->thindraw_pcb_polygon != NULL &&
+      (TEST_FLAG (THINDRAWFLAG, PCB) ||
+       TEST_FLAG (THINDRAWPOLYFLAG, PCB)))
+    gui->thindraw_pcb_polygon (Output.fgGC, polygon, drawn_area);
+  else
+    gui->fill_pcb_polygon (Output.fgGC, polygon, drawn_area);
+
+  /* If checking planes, thin-draw any pieces which have been clipped away */
+  if (gui->thindraw_pcb_polygon != NULL &&
+      TEST_FLAG (CHECKPLANESFLAG, PCB) &&
+      !TEST_FLAG (FULLPOLYFLAG, polygon))
+    {
+      PolygonType poly = *polygon;
+
+      for (poly.Clipped = polygon->Clipped->f;
+           poly.Clipped != polygon->Clipped;
+           poly.Clipped = poly.Clipped->f)
+        gui->thindraw_pcb_polygon (Output.fgGC, &poly, drawn_area);
+    }
+}
+
+struct draw_funcs d_f = {
+  .draw_pin       = draw_pin,
+  .draw_pin_mask  = draw_pin_mask,
+  .draw_via       = draw_via,
+  .draw_via_mask  = draw_via_mask,
+  .draw_pad       = draw_pad,
+  .draw_pad_mask  = draw_pad_mask,
+  .draw_pad_paste = draw_pad_paste,
+  .draw_line      = draw_line,
+  .draw_rat       = draw_rat,
+  .draw_arc       = draw_arc,
+  .draw_poly      = draw_poly,
+};
+
+struct draw_funcs *dapi = &d_f;
diff --git a/src/draw_funcs.h b/src/draw_funcs.h
new file mode 100644
index 0000000..e29b05c
--- /dev/null
+++ b/src/draw_funcs.h
@@ -0,0 +1,15 @@
+struct draw_funcs {
+  void (*draw_pin)       (PinType *,     void *);
+  void (*draw_pin_mask)  (PinType *,     void *);
+  void (*draw_via)       (PinType *,     void *);
+  void (*draw_via_mask)  (PinType *,     void *);
+  void (*draw_pad)       (PadType *,     void *);
+  void (*draw_pad_mask)  (PadType *,     void *);
+  void (*draw_pad_paste) (PadType *,     void *);
+  void (*draw_line)      (LineType *,    void *);
+  void (*draw_rat)       (RatType *,     void *);
+  void (*draw_arc)       (ArcType *,     void *);
+  void (*draw_poly)      (PolygonType *, void *);
+};
+
+extern struct draw_funcs *dapi;

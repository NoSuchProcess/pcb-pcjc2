Bottom: 1048e4c6bc3ab356fd4762b86a8de39f6dd848dd
Top:    593aa049031b1ea1bf62a735669225384d20fdcf
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2014-07-09 00:33:03 +0100

Refresh of attempt-at-supporting-arc-arc

---

diff --git a/src/circle_circle_intersect.c b/src/circle_circle_intersect.c
new file mode 100644
index 0000000..8ac5c01
--- /dev/null
+++ b/src/circle_circle_intersect.c
@@ -0,0 +1,118 @@
+/* circle_circle_intersection() *
+ * Determine the points where 2 circles in a common plane intersect.
+ *
+ * int circle_circle_intersection(
+ *                                // center and radius of 1st circle
+ *                                double x0, double y0, double r0,
+ *                                // center and radius of 2nd circle
+ *                                double x1, double y1, double r1,
+ *                                // 1st intersection point
+ *                                double *xi, double *yi,
+ *                                // 2nd intersection point
+ *                                double *xi_prime, double *yi_prime)
+ *
+ * This is a public domain work. 3/26/2005 Tim Voght
+ *
+ * Distinct return code for the single intersection case added by Peter Clifton 2014-07-05
+ *
+ */
+#include <stdio.h>
+#include <math.h>
+
+#define EPSILON (1e-8)
+
+
+int circle_circle_intersect (double x0, double y0, double r0,
+                             double x1, double y1, double r1,
+                             double *xi, double *yi,
+                             double *xi_prime, double *yi_prime)
+{
+  double a, dx, dy, d, h, rx, ry;
+  double x2, y2;
+
+  /* dx and dy are the vertical and horizontal distances between
+   * the circle centers.
+   */
+  dx = x1 - x0;
+  dy = y1 - y0;
+
+  /* Determine the straight-line distance between the centers. */
+  //d = sqrt((dy*dy) + (dx*dx));
+  d = hypot(dx,dy); // Suggested by Keith Briggs
+
+  /* Check for solvability. */
+  if (d > (r0 + r1))
+  {
+    /* no solution. circles do not intersect. */
+    return 0;
+  }
+  if (d < fabs(r0 - r1))
+  {
+    /* no solution. one circle is contained in the other */
+    return 0;
+  }
+
+  /* 'point 2' is the point where the line through the circle
+   * intersection points crosses the line between the circle
+   * centers.
+   */
+
+  /* Determine the distance from point 0 to point 2. */
+  a = ((r0*r0) - (r1*r1) + (d*d)) / (2.0 * d) ;
+
+  /* Determine the coordinates of point 2. */
+  x2 = x0 + (dx * a/d);
+  y2 = y0 + (dy * a/d);
+
+  /* Determine the distance from point 2 to either of the
+   * intersection points.
+   */
+  h = sqrt((r0*r0) - (a*a));
+
+  /* Now determine the offsets of the intersection points from
+   * point 2.
+   */
+  rx = -dy * (h/d);
+  ry = dx * (h/d);
+
+  /* Determine the absolute intersection points. */
+  *xi = x2 + rx;
+  *yi = y2 + ry;
+
+  if (fabs(h) < EPSILON)
+    return 1;
+
+  *xi_prime = x2 - rx;
+  *yi_prime = y2 - ry;
+
+  return 2;
+}
+
+#undef TEST
+
+#ifdef TEST
+
+void run_test(double x0, double y0, double r0,
+              double x1, double y1, double r1)
+{
+  double x3, y3, x3_prime, y3_prime;
+
+  printf("x0=%F, y0=%F, r0=%F, x1=%F, y1=%F, r1=%F :\n",
+          x0, y0, r0, x1, y1, r1);
+  circle_circle_intersection(x0, y0, r0, x1, y1, r1,
+                             &x3, &y3, &x3_prime, &y3_prime);
+  printf("  x3=%F, y3=%F, x3_prime=%F, y3_prime=%F\n",
+            x3, y3, x3_prime, y3_prime);
+}
+
+int main(void)
+{
+  /* Add more! */
+  run_test(-1.0, -1.0, 1.5, 1.0, 1.0, 2.0);
+  run_test(1.0, -1.0, 1.5, -1.0, 1.0, 2.0);
+  run_test(-1.0, 1.0, 1.5, 1.0, -1.0, 2.0);
+  run_test(1.0, 1.0, 1.5, -1.0, -1.0, 2.0);
+  exit(0);
+}
+#endif
+
diff --git a/src/circle_circle_intersect.h b/src/circle_circle_intersect.h
new file mode 100644
index 0000000..33289ef
--- /dev/null
+++ b/src/circle_circle_intersect.h
@@ -0,0 +1,4 @@
+int circle_circle_intersect (double x0, double y0, double r0,
+                             double x1, double y1, double r1,
+                             double *xi, double *yi,
+                             double *xi_prime, double *yi_prime);
diff --git a/src/circle_line_intersect.c b/src/circle_line_intersect.c
new file mode 100644
index 0000000..b008572
--- /dev/null
+++ b/src/circle_line_intersect.c
@@ -0,0 +1,68 @@
+/* Based on raysphere.c from:
+ * http://paulbourke.net/geometry/circlesphere/index.html#linesphere
+ *
+ * Converted to PCB coordinate types, and line/circle intersection in 2D
+ * by Peter Clifton 2014-07-05
+ */
+
+#include <math.h>
+
+#define EPSILON (1e-8)
+
+/*
+ * Calculate the intersection of a ray and a sphere
+ * The line segment is defined from p1 to p2
+ * The sphere is of radius r and centered at sc
+ * There are potentially two points of intersection given by
+ * p = p1 + mu1 (p2 - p1)
+ * p = p1 + mu2 (p2 - p1)
+ *
+ * Return 0 if the ray doesn't intersect the circle.
+ * Return 1 if the ray touches the circle at a single point.
+ * Return 2 if the ray intersects the circle.
+ */
+int
+circle_line_intersect (double cx, double cy, double r,
+                       double p1x, double p1y, double p2x, double p2y,
+                       double *mu1, double *mu2)
+{
+   double a,b,c;
+   double bb4ac;
+   double dpx;
+   double dpy;
+
+   dpx = p2x - p1x;
+   dpy = p2y - p1y;
+   a = dpx * dpx + dpy * dpy;
+   b = 2 * (dpx * (p1x - cx) + dpy * (p1y - cy));
+   c = cx * cx + cy * cy;
+   c += p1x * p1x + p1y * p1y;
+   c -= 2 * (cx * p1x + cy * p1y);
+   c -= r * r;
+   bb4ac = b * b - 4 * a * c;
+
+   if (fabs(a) < EPSILON)
+    {
+      *mu1 = 0;
+      *mu2 = 0;
+      return 0;
+    }
+
+   if (fabs(bb4ac) < EPSILON) {
+      *mu1 = -b / (2 * a);
+      *mu2 = 0;
+      return 1;
+   }
+
+   if (bb4ac < 0)
+    {
+      *mu1 = 0;
+      *mu2 = 0;
+      return 0;
+    }
+
+   *mu1 = (-b + sqrt(bb4ac)) / (2 * a);
+   *mu2 = (-b - sqrt(bb4ac)) / (2 * a);
+
+   return 2;
+}
diff --git a/src/circle_line_intersect.h b/src/circle_line_intersect.h
new file mode 100644
index 0000000..c7920d2
--- /dev/null
+++ b/src/circle_line_intersect.h
@@ -0,0 +1,3 @@
+int circle_line_intersect (double cx, double cy, double r,
+                           double p1x, double p1y, double p2x, double p2y,
+                           double *mu1, double *mu2);

Bottom: 8dc12cd4681df7689c5369bcd6b901edb399d40b
Top:    fa19ce8627c062bab64423c0a9f8cbf0d8498f77
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-03-27 15:36:21 +0100

Refresh of cache-polygon-contour-tri-stri

---

diff --git a/src/borast/borast-bentley-ottmann.c b/src/borast/borast-bentley-ottmann.c
index 2f692d7..8012817 100644
--- a/src/borast/borast-bentley-ottmann.c
+++ b/src/borast/borast-bentley-ottmann.c
@@ -127,8 +127,8 @@ typedef struct _borast_bo_sweep_line {
 
 
 /*static*/ borast_fixed_t
-_line_compute_intersection_x_for_y (const cairo_line_t *line,
-                                    cairo_fixed_t y)
+_line_compute_intersection_x_for_y (const borast_line_t *line,
+                                    borast_fixed_t y)
 {
     borast_fixed_t x, dy;
 
@@ -1491,7 +1491,7 @@ bo_poly_to_traps (POLYAREA *poly, borast_traps_t *traps)
 }
 
 borast_status_t
-bo_contour_to_traps (PLINE *contour, cairo_traps_t *traps)
+bo_contour_to_traps (PLINE *contour,  borast_traps_t *traps)
 {
   int intersections;
   borast_status_t status;
@@ -1581,34 +1581,34 @@ bo_contour_to_traps (PLINE *contour, cairo_traps_t *traps)
 }
 
 
-cairo_status_t
-bo_contour_to_traps_no_draw (PLINE *contour, cairo_traps_t *traps)
+borast_status_t
+bo_contour_to_traps_no_draw (PLINE *contour, borast_traps_t *traps)
 {
   int intersections;
-  cairo_status_t status;
-  cairo_bo_start_event_t stack_events[CAIRO_STACK_ARRAY_LENGTH (cairo_bo_start_event_t)];
-  cairo_bo_start_event_t *events;
-  cairo_bo_event_t *stack_event_ptrs[ARRAY_LENGTH (stack_events) + 1];
-  cairo_bo_event_t **event_ptrs;
+  borast_status_t status;
+  borast_bo_start_event_t stack_events[BORAST_STACK_ARRAY_LENGTH (borast_bo_start_event_t)];
+  borast_bo_start_event_t *events;
+  borast_bo_event_t *stack_event_ptrs[ARRAY_LENGTH (stack_events) + 1];
+  borast_bo_event_t **event_ptrs;
   int num_events = 0;
   int i;
 
   num_events = contour->Count;
 
   if (unlikely (0 == num_events))
-      return CAIRO_STATUS_SUCCESS;
+      return BORAST_STATUS_SUCCESS;
 
   events = stack_events;
   event_ptrs = stack_event_ptrs;
   if (num_events > ARRAY_LENGTH (stack_events)) {
-      events = _cairo_malloc_ab_plus_c (num_events,
-                                        sizeof (cairo_bo_start_event_t) +
-                                        sizeof (cairo_bo_event_t *),
-                                        sizeof (cairo_bo_event_t *));
+      events = _borast_malloc_ab_plus_c (num_events,
+                                        sizeof (borast_bo_start_event_t) +
+                                        sizeof (borast_bo_event_t *),
+                                        sizeof (borast_bo_event_t *));
       if (unlikely (events == NULL))
-          return CAIRO_STATUS_NO_MEMORY;
+          return BORAST_STATUS_NO_MEMORY;
 
-      event_ptrs = (cairo_bo_event_t **) (events + num_events);
+      event_ptrs = (borast_bo_event_t **) (events + num_events);
   }
 
   i = 0;
@@ -1618,8 +1618,8 @@ bo_contour_to_traps_no_draw (PLINE *contour, cairo_traps_t *traps)
   /* XXX: This would be the convenient place to throw in multiple
    * passes of the Bentley-Ottmann algorithm. It would merely
    * require storing the results of each pass into a temporary
-   * cairo_traps_t. */
-  status = _cairo_bentley_ottmann_tessellate_bo_edges (event_ptrs,
+   * borast_traps_t. */
+  status = _borast_bentley_ottmann_tessellate_bo_edges (event_ptrs,
                                                        num_events,
                                                        traps,
                                                        &intersections);
@@ -1631,5 +1631,5 @@ bo_contour_to_traps_no_draw (PLINE *contour, cairo_traps_t *traps)
   if (events != stack_events)
       free (events);
 
-  return CAIRO_STATUS_SUCCESS;
+  return BORAST_STATUS_SUCCESS;
 }

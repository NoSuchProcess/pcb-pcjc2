Bottom: 2310009556c151e7946c70b6be58b2ddf24ae892
Top:    fbadc8891f58fa40320121949c811862d18e215b
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2014-06-28 20:21:23 +0100

Refresh of create-a-new-constant

---

diff --git a/globalconst.h b/globalconst.h
index e0779d5..b7794ae 100755
--- a/globalconst.h
+++ b/globalconst.h
@@ -71,6 +71,7 @@
  
 #define	MAX_LAYER		16	/* max number of layer, check source */
 					/* code for more changes, a *lot* more changes */
+#define	MAX_GROUP		MAX_LAYER	/* max number of layer groups (should be equal to MAX_LAYER) */
 #define DEF_LAYER		8	/* default number of layers for new boards */
 #define NUM_STYLES		4
 #define	MIN_LINESIZE		MIL_TO_COORD(0.01)	/* thickness of lines */
diff --git a/src/autoroute.c b/src/autoroute.c
index f766a5e..58ff351 100644
--- a/src/autoroute.c
+++ b/src/autoroute.c
@@ -313,7 +313,7 @@ routebox_t;
 typedef struct routedata
 {
   /* one rtree per layer *group */
-  rtree_t *layergrouptree[MAX_LAYER];	/* no silkscreen layers here =) */
+  rtree_t *layergrouptree[MAX_GROUP];	/* no silkscreen layers here =) */
   /* root pointer into connectivity information */
   routebox_t *first_net;
   /* default routing style */
@@ -428,9 +428,9 @@ static void showroutebox (routebox_t * rb);
  */
 /* group number of groups that hold surface mount pads */
 static Cardinal front, back;
-static bool usedGroup[MAX_LAYER];
-static int x_cost[MAX_LAYER], y_cost[MAX_LAYER];
-static bool is_layer_group_active[MAX_LAYER];
+static bool usedGroup[MAX_GROUP];
+static int x_cost[MAX_GROUP], y_cost[MAX_GROUP];
+static bool is_layer_group_active[MAX_GROUP];
 static int ro = 0;
 static int smoothes = 1;
 static int passes = 12;
@@ -936,7 +936,7 @@ static routedata_t *
 CreateRouteData ()
 {
   NetListListType Nets;
-  PointerListType layergroupboxes[MAX_LAYER];
+  PointerListType layergroupboxes[MAX_GROUP];
   BoxType bbox;
   routedata_t *rd;
   int group, i;
diff --git a/src/draw.c b/src/draw.c
index dee6bea..a87adb4 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -541,9 +541,9 @@ DrawEverything (const BoxType *drawn_area)
   int i, ngroups, side;
   int top_group, bottom_group;
   /* This is the list of layer groups we will draw.  */
-  int do_group[MAX_LAYER];
+  int do_group[MAX_GROUP];
   /* This is the reverse of the order in which we draw them.  */
-  int drawn_groups[MAX_LAYER];
+  int drawn_groups[MAX_GROUP];
   int plated, unplated;
   bool paste_empty;
 
diff --git a/src/global.h b/src/global.h
index 1d017fe..4c1243e 100644
--- a/src/global.h
+++ b/src/global.h
@@ -194,8 +194,8 @@ OutputType;
  */
 typedef struct
 {
-  Cardinal Number[MAX_LAYER],	/* number of entries per groups */
-    Entries[MAX_LAYER][MAX_LAYER + 2];
+  Cardinal Number[MAX_GROUP],	/* number of entries per groups */
+    Entries[MAX_GROUP][MAX_LAYER + 2];
 } LayerGroupType;
 
 struct BoxType		/* a bounding box */
diff --git a/src/hid.h b/src/hid.h
index 003b6a4..f5577eb 100644
--- a/src/hid.h
+++ b/src/hid.h
@@ -306,7 +306,7 @@ typedef enum
        (zero), the HID does not want that layer, and none of the drawing
        functions should be called.  If it returns true (nonzero), the
        items in that layer [group] should be drawn using the various
-       drawing functions.  In addition to the MAX_LAYERS copper layer
+       drawing functions.  In addition to the MAX_GROUP copper layer
        groups, you may select layers indicated by the macros SL_*
        defined above, or any others with an index of -1.  For copper
        layer groups, you may pass NULL for name to have a name fetched
diff --git a/src/hid/batch/batch.c b/src/hid/batch/batch.c
index b04f16e..3714dfe 100644
--- a/src/hid/batch/batch.c
+++ b/src/hid/batch/batch.c
@@ -93,7 +93,7 @@ info (int argc, char **argv, Coord x, Coord y)
     {
       
       int lg = GetLayerGroupNumberByNumber (i);
-      for (j=0; j<MAX_LAYER; j++)
+      for (j = 0; j < MAX_GROUP; j++)
 	putchar(j==lg ? '#' : '-');
       printf(" %c %s\n", lg == top_group ? 'c' : lg == bottom_group ? 's' : '-',
 	     PCB->Data->Layer[i].Name);
diff --git a/src/hid/gcode/gcode.c b/src/hid/gcode/gcode.c
index 2fdb78c..a741e32 100644
--- a/src/hid/gcode/gcode.c
+++ b/src/hid/gcode/gcode.c
@@ -116,7 +116,7 @@ static int is_bottom;
  * Which groups of layers to export into PNG layer masks. 1 means export, 0
  * means do not export.
  */
-static int gcode_export_group[MAX_LAYER];
+static int gcode_export_group[MAX_GROUP];
 
 /* Group that is currently exported. */
 static int gcode_cur_group;
@@ -602,7 +602,7 @@ gcode_do_export (HID_Attr_Val * options)
     }
   UpdateExtents();
 
-  for (i = 0; i < MAX_LAYER; i++)
+  for (i = 0; i < MAX_GROUP; i++)
     {
       if (gcode_export_group[i])
         {
diff --git a/src/hid/gerber/gerber.c b/src/hid/gerber/gerber.c
index 60d159d..9fae772 100644
--- a/src/hid/gerber/gerber.c
+++ b/src/hid/gerber/gerber.c
@@ -313,7 +313,7 @@ static int pagecount = 0;
 static int linewidth = -1;
 static int lastgroup = -1;
 static int lastcap = -1;
-static int print_group[MAX_LAYER];
+static int print_group[MAX_GROUP];
 static int print_layer[MAX_LAYER];
 static int lastX, lastY;	/* the last X and Y coordinate */
 
diff --git a/src/hid/gtk/gui-config.c b/src/hid/gtk/gui-config.c
index ed79d50..e109593 100644
--- a/src/hid/gtk/gui-config.c
+++ b/src/hid/gtk/gui-config.c
@@ -1271,7 +1271,7 @@ config_library_tab_create (GtkWidget * tab_vbox)
 static GtkWidget	*config_groups_table, *config_groups_vbox, *config_groups_window;
 
 static GtkWidget *layer_entry[MAX_LAYER];
-static GtkWidget *group_button[MAX_LAYER + 2][MAX_LAYER];
+static GtkWidget *group_button[MAX_LAYER + 2][MAX_GROUP];
 
 #if FIXME
 static GtkWidget *use_layer_default_button;
diff --git a/src/hid/lesstif/dialogs.c b/src/hid/lesstif/dialogs.c
index db9c657..01ae553 100644
--- a/src/hid/lesstif/dialogs.c
+++ b/src/hid/lesstif/dialogs.c
@@ -1323,7 +1323,7 @@ static GC lg_gc = 0;
 
 #if 0
 static Widget lglabels[MAX_LAYER + 2];
-static Widget lgbuttons[MAX_LAYER + 2][MAX_LAYER];
+static Widget lgbuttons[MAX_LAYER + 2][MAX_GROUP];
 #endif
 
 typedef struct {
@@ -1450,7 +1450,7 @@ lgbutton_resize (Widget w, XtPointer u, XmDrawingAreaCallbackStruct *cbs)
 void
 lesstif_update_layer_groups ()
 {
-  int sets[MAX_LAYER + 2][MAX_LAYER];
+  int sets[MAX_LAYER + 2][MAX_GROUP];
   int i, j, n;
   LayerGroupType *l = &(PCB->LayerGroups);
 
@@ -1516,7 +1516,7 @@ lesstif_update_layer_groups ()
     }
   XtUnmanageChild(lg_buttonform);
   for (i = 0; i < MAX_LAYER + 2; i++)
-    for (j = 0; j < MAX_LAYER; j++)
+    for (j = 0; j < MAX_GROUP; j++)
       {
 	if (i < max_copper_layer + 2 && j < max_group)
 	  {
@@ -1605,7 +1605,7 @@ EditLayerGroups (int argc, char **argv, Coord x, Coord y)
 	  lglabels[i] = XmCreateLabel (layer_groups_form, "layer", args, n);
 	  XtManageChild (lglabels[i]);
 
-	  for (j = 0; j < MAX_LAYER; j++)
+	  for (j = 0; j < MAX_GROUP; j++)
 	    {
 	      n = 0;
 	      stdarg (XmNleftAttachment, XmATTACH_POSITION);
diff --git a/src/hid/nelma/nelma.c b/src/hid/nelma/nelma.c
index 7151f82..2e814de 100644
--- a/src/hid/nelma/nelma.c
+++ b/src/hid/nelma/nelma.c
@@ -123,7 +123,7 @@ static int      is_drill;
  * Which groups of layers to export into PNG layer masks. 1 means export, 0
  * means do not export.
  */
-static int      nelma_export_group[MAX_LAYER];
+static int      nelma_export_group[MAX_GROUP];
 
 /* Group that is currently exported. */
 static int      nelma_cur_group;
@@ -280,7 +280,7 @@ nelma_write_space(FILE * out)
 	fprintf(out, "\t\t\"air-bottom\"");
 
 	z = 10;
-	for (i = 0; i < MAX_LAYER; i++)
+	for (i = 0; i < MAX_GROUP; i++)
 		if (nelma_export_group[i]) {
 			idx = (i >= 0 && i < max_group) ?
 				PCB->LayerGroups.Entries[i][0] : i;
@@ -350,7 +350,7 @@ nelma_write_nets(FILE * out)
 
 			/* pin_name_to_xy(pin, &x, &y); */
 
-			for (i = 0; i < MAX_LAYER; i++)
+			for (i = 0; i < MAX_GROUP; i++)
 				if (nelma_export_group[i]) {
 					idx = (i >= 0 && i < max_group) ?
 						PCB->LayerGroups.Entries[i][0] : i;
@@ -428,7 +428,7 @@ nelma_write_layers(FILE * out)
 	nelma_write_layer(out, 1000, 2 * subh, "air-bottom", 0, "air");
 
 	z = 10;
-	for (i = 0; i < MAX_LAYER; i++)
+	for (i = 0; i < MAX_GROUP; i++)
 		if (nelma_export_group[i]) {
 			idx = (i >= 0 && i < max_group) ?
 				PCB->LayerGroups.Entries[i][0] : i;
@@ -469,7 +469,7 @@ nelma_write_object(FILE * out, LibraryEntryType *pin)
 	x = pcb_to_nelma (px);
 	y = pcb_to_nelma (py);
 
-	for (i = 0; i < MAX_LAYER; i++)
+	for (i = 0; i < MAX_GROUP; i++)
 		if (nelma_export_group[i]) {
 			idx = (i >= 0 && i < max_group) ?
 				PCB->LayerGroups.Entries[i][0] : i;
@@ -683,7 +683,7 @@ nelma_do_export(HID_Attr_Val * options)
 
 	nelma_choose_groups();
 
-	for (i = 0; i < MAX_LAYER; i++) {
+	for (i = 0; i < MAX_GROUP; i++) {
 		if (nelma_export_group[i]) {
 
 			nelma_cur_group = i;
diff --git a/src/hid/png/png.c b/src/hid/png/png.c
index 20491c6..0c68dad 100644
--- a/src/hid/png/png.c
+++ b/src/hid/png/png.c
@@ -112,7 +112,7 @@ static int linewidth = -1;
 static int lastgroup = -1;
 static gdImagePtr lastbrush = (gdImagePtr)((void *) -1);
 static int lastcap = -1;
-static int print_group[MAX_LAYER];
+static int print_group[MAX_GROUP];
 static int print_layer[MAX_LAYER];
 
 /* For photo-mode we need the following layers as monochrome masks:
diff --git a/src/hid/ps/eps.c b/src/hid/ps/eps.c
index 4b9fe3e..cf63487 100644
--- a/src/hid/ps/eps.c
+++ b/src/hid/ps/eps.c
@@ -66,7 +66,7 @@ static FILE *f = 0;
 static Coord linewidth = -1;
 static int lastcap = -1;
 static int lastcolor = -1;
-static int print_group[MAX_LAYER];
+static int print_group[MAX_GROUP];
 static int print_layer[MAX_LAYER];
 static int fast_erase = -1;
 
diff --git a/src/hid/ps/ps.c b/src/hid/ps/ps.c
index 28dbcd5..8e3a2ce 100644
--- a/src/hid/ps/ps.c
+++ b/src/hid/ps/ps.c
@@ -368,7 +368,7 @@ static struct {
   FILE *f;
   int pagecount;
   Coord linewidth;
-  bool print_group[MAX_LAYER];
+  bool print_group[MAX_GROUP];
   bool print_layer[MAX_LAYER];
   double fade_ratio;
   bool multi_file;
diff --git a/src/misc.c b/src/misc.c
index e2644f8..ab5b159 100644
--- a/src/misc.c
+++ b/src/misc.c
@@ -987,7 +987,7 @@ error:
  * comma separated layer numbers (1,2,b:4,6,8,t)
  */
 int
-ParseGroupString (char *s, LayerGroupType *LayerGroup, int LayerN)
+ParseGroupString (char *s, LayerGroupType *LayerGroup, int *LayerN)
 {
   int group, member, layer;
   bool c_set = false,        /* flags for the two special layers to */
diff --git a/src/move.c b/src/move.c
index 16eb73f..9dcba90 100644
--- a/src/move.c
+++ b/src/move.c
@@ -960,7 +960,7 @@ MoveLayer (int old_index, int new_index)
   for (l = 0; l < MAX_LAYER+2; l++)
     group_of_layer[l] = -1;
 
-  for (g = 0; g < MAX_LAYER; g++)
+  for (g = 0; g < MAX_GROUP; g++)
     for (i = 0; i < PCB->LayerGroups.Number[g]; i++)
       group_of_layer[PCB->LayerGroups.Entries[g][i]] = g;
 
@@ -1040,7 +1040,7 @@ MoveLayer (int old_index, int new_index)
 
   move_all_thermals(old_index, new_index);
 
-  for (g = 0; g < MAX_LAYER; g++)
+  for (g = 0; g < MAX_GROUP; g++)
     PCB->LayerGroups.Number[g] = 0;
   for (l = 0; l < max_copper_layer + 2; l++)
     {
@@ -1054,15 +1054,15 @@ MoveLayer (int old_index, int new_index)
       PCB->LayerGroups.Entries[g][i] = l;
     }
 
-  for (g = 1; g < MAX_LAYER; g++)
+  for (g = 1; g < MAX_GROUP; g++)
     if (PCB->LayerGroups.Number[g - 1] == 0)
       {
 	memmove (&PCB->LayerGroups.Number[g - 1],
 		 &PCB->LayerGroups.Number[g],
-		 (MAX_LAYER - g) * sizeof (PCB->LayerGroups.Number[g]));
+		 (MAX_GROUP - g) * sizeof (PCB->LayerGroups.Number[g]));
 	memmove (&PCB->LayerGroups.Entries[g - 1],
 		 &PCB->LayerGroups.Entries[g],
-		 (MAX_LAYER - g) * sizeof (PCB->LayerGroups.Entries[g]));
+		 (MAX_GROUP - g) * sizeof (PCB->LayerGroups.Entries[g]));
       }
 
   hid_action ("LayersChanged");

Bottom: b07ba922d91a7054739a0bd458ae9b044cc76652
Top:    85cd4a60d7fdc1b4bf49f57c8dffcd87ae13d432
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-03-27 15:27:33 +0100

Refresh of bentley-ottann-test-implementa

---

diff --git a/src/borast/borast-bentley-ottmann.c b/src/borast/borast-bentley-ottmann.c
index 247a83e..76f8e87 100644
--- a/src/borast/borast-bentley-ottmann.c
+++ b/src/borast/borast-bentley-ottmann.c
@@ -57,10 +57,10 @@
 #define DEBUG_EVENTS 0
 #define DEBUG_TRAPS 0
 
-typedef borast_point_t cairo_bo_point32_t;
+typedef borast_point_t borast_bo_point32_t;
 
-typedef struct _borast_bo_edge cairo_bo_edge_t;
-typedef struct _borast_bo_trap cairo_bo_trap_t;
+typedef struct _borast_bo_edge borast_bo_edge_t;
+typedef struct _borast_bo_trap borast_bo_trap_t;
 
 /* A deferred trapezoid of an edge */
 struct _borast_bo_trap {
@@ -149,7 +149,7 @@ _line_compute_intersection_x_for_y (const borast_line_t *line,
 }
 
 static inline int
-_borast_bo_point32_compare (cairo_bo_point32_t const *a,
+_borast_bo_point32_compare (borast_bo_point32_t const *a,
                            borast_bo_point32_t const *b)
 {
     int cmp;
@@ -225,8 +225,8 @@ _slope_compare (const borast_bo_edge_t *a,
     {
         int32_t ady = a->edge.line.p2.y - a->edge.line.p1.y;
         int32_t bdy = b->edge.line.p2.y - b->edge.line.p1.y;
-        borast_int64_t adx_bdy = _cairo_int32x32_64_mul (adx, bdy);
-        borast_int64_t bdx_ady = _cairo_int32x32_64_mul (bdx, ady);
+        borast_int64_t adx_bdy = _borast_int32x32_64_mul (adx, bdy);
+        borast_int64_t bdx_ady = _borast_int32x32_64_mul (bdx, ady);
 
         return _borast_int64_cmp (adx_bdy, bdx_ady);
     }
@@ -319,9 +319,9 @@ edges_compare_x_for_y_general (const borast_bo_edge_t *a,
     if (dx == 0)
         have_dx_adx_bdx &= ~HAVE_DX;
 
-#define L _borast_int64x32_128_mul (_cairo_int32x32_64_mul (ady, bdy), dx)
-#define A _borast_int64x32_128_mul (_cairo_int32x32_64_mul (adx, bdy), y - a->edge.line.p1.y)
-#define B _borast_int64x32_128_mul (_cairo_int32x32_64_mul (bdx, ady), y - b->edge.line.p1.y)
+#define L _borast_int64x32_128_mul (_borast_int32x32_64_mul (ady, bdy), dx)
+#define A _borast_int64x32_128_mul (_borast_int32x32_64_mul (adx, bdy), y - a->edge.line.p1.y)
+#define B _borast_int64x32_128_mul (_borast_int32x32_64_mul (bdx, ady), y - b->edge.line.p1.y)
     switch (have_dx_adx_bdx) {
     default:
     case HAVE_NONE:
@@ -376,7 +376,7 @@ edges_compare_x_for_y_general (const borast_bo_edge_t *a,
         }
     case HAVE_ALL:
         /* XXX try comparing (a->edge.line.p2.x - b->edge.line.p2.x) et al */
-        return _borast_int128_cmp (L, _cairo_int128_sub (B, A));
+        return _borast_int128_cmp (L, _borast_int128_sub (B, A));
     }
 #undef B
 #undef A
@@ -482,14 +482,14 @@ edges_compare_x_for_y (const borast_bo_edge_t *a,
 }
 
 static inline int
-_line_equal (const borast_line_t *a, const cairo_line_t *b)
+_line_equal (const borast_line_t *a, const borast_line_t *b)
 {
     return a->p1.x == b->p1.x && a->p1.y == b->p1.y &&
            a->p2.x == b->p2.x && a->p2.y == b->p2.y;
 }
 
 static int
-_borast_bo_sweep_line_compare_edges (cairo_bo_sweep_line_t        *sweep_line,
+_borast_bo_sweep_line_compare_edges (borast_bo_sweep_line_t        *sweep_line,
                                     const borast_bo_edge_t        *a,
                                     const borast_bo_edge_t        *b)
 {
@@ -520,7 +520,7 @@ det32_64 (int32_t a, int32_t b,
           int32_t c, int32_t d)
 {
     /* det = a * d - b * c */
-    return _borast_int64_sub (_cairo_int32x32_64_mul (a, d),
+    return _borast_int64_sub (_borast_int32x32_64_mul (a, d),
                              _borast_int32x32_64_mul (b, c));
 }
 
@@ -529,12 +529,12 @@ det64x32_128 (borast_int64_t a, int32_t       b,
               borast_int64_t c, int32_t       d)
 {
     /* det = a * d - b * c */
-    return _borast_int128_sub (_cairo_int64x32_128_mul (a, d),
+    return _borast_int128_sub (_borast_int64x32_128_mul (a, d),
                               _borast_int64x32_128_mul (c, b));
 }
 
 static inline int
-borast_bo_event_compare (const cairo_bo_event_t *a,
+borast_bo_event_compare (const borast_bo_event_t *a,
                         const borast_bo_event_t *b)
 {
     int cmp;
@@ -655,7 +655,7 @@ _pqueue_pop (pqueue_t *pq)
 }
 
 static inline borast_status_t
-_borast_bo_event_queue_insert (cairo_bo_event_queue_t        *queue,
+_borast_bo_event_queue_insert (borast_bo_event_queue_t        *queue,
                               borast_bo_event_type_t         type,
                               borast_bo_edge_t                *e1,
                               borast_bo_edge_t                *e2,
@@ -676,14 +676,14 @@ _borast_bo_event_queue_insert (cairo_bo_event_queue_t        *queue,
 }
 
 static void
-_borast_bo_event_queue_delete (cairo_bo_event_queue_t *queue,
+_borast_bo_event_queue_delete (borast_bo_event_queue_t *queue,
                               borast_bo_event_t             *event)
 {
     _borast_freepool_free (&queue->pool, event);
 }
 
 static borast_bo_event_t *
-_borast_bo_event_dequeue (cairo_bo_event_queue_t *event_queue)
+_borast_bo_event_dequeue (borast_bo_event_queue_t *event_queue)
 {
     borast_bo_event_t *event, *cmp;
 
@@ -708,7 +708,7 @@ BORAST_COMBSORT_DECLARE (_borast_bo_event_queue_sort,
                         borast_bo_event_compare)
 
 static void
-_borast_bo_event_queue_init (cairo_bo_event_queue_t         *event_queue,
+_borast_bo_event_queue_init (borast_bo_event_queue_t         *event_queue,
                             borast_bo_event_t                **start_events,
                             int                                  num_events)
 {
@@ -724,7 +724,7 @@ _borast_bo_event_queue_init (cairo_bo_event_queue_t         *event_queue,
 }
 
 static borast_status_t
-_borast_bo_event_queue_insert_stop (cairo_bo_event_queue_t        *event_queue,
+_borast_bo_event_queue_insert_stop (borast_bo_event_queue_t        *event_queue,
                                    borast_bo_edge_t                *edge)
 {
     borast_bo_point32_t point;
@@ -739,14 +739,14 @@ _borast_bo_event_queue_insert_stop (cairo_bo_event_queue_t        *event_queue,
 }
 
 static void
-_borast_bo_event_queue_fini (cairo_bo_event_queue_t *event_queue)
+_borast_bo_event_queue_fini (borast_bo_event_queue_t *event_queue)
 {
     _pqueue_fini (&event_queue->pqueue);
     _borast_freepool_fini (&event_queue->pool);
 }
 
 static void
-_borast_bo_sweep_line_init (cairo_bo_sweep_line_t *sweep_line)
+_borast_bo_sweep_line_init (borast_bo_sweep_line_t *sweep_line)
 {
     sweep_line->head = NULL;
     sweep_line->stopped = NULL;
@@ -755,7 +755,7 @@ _borast_bo_sweep_line_init (cairo_bo_sweep_line_t *sweep_line)
 }
 
 static borast_status_t
-_borast_bo_sweep_line_insert (cairo_bo_sweep_line_t        *sweep_line,
+_borast_bo_sweep_line_insert (borast_bo_sweep_line_t        *sweep_line,
                              borast_bo_edge_t                *edge)
 {
     if (sweep_line->current_edge != NULL) {
@@ -815,7 +815,7 @@ _borast_bo_sweep_line_insert (cairo_bo_sweep_line_t        *sweep_line,
 }
 
 static void
-_borast_bo_sweep_line_delete (cairo_bo_sweep_line_t        *sweep_line,
+_borast_bo_sweep_line_delete (borast_bo_sweep_line_t        *sweep_line,
                              borast_bo_edge_t        *edge)
 {
     if (edge->prev != NULL)
@@ -832,7 +832,7 @@ _borast_bo_sweep_line_delete (cairo_bo_sweep_line_t        *sweep_line,
 
 #if DEBUG_PRINT_STATE
 static void
-_borast_bo_edge_print (cairo_bo_edge_t *edge)
+_borast_bo_edge_print (borast_bo_edge_t *edge)
 {
     printf ("(%d, %d)-(%d, %d)",
             edge->edge.line.p1.x, edge->edge.line.p1.y,
@@ -840,7 +840,7 @@ _borast_bo_edge_print (cairo_bo_edge_t *edge)
 }
 
 static void
-_borast_bo_event_print (cairo_bo_event_t *event)
+_borast_bo_event_print (borast_bo_event_t *event)
 {
     switch (event->type) {
     case BORAST_BO_EVENT_TYPE_START:
@@ -851,19 +851,19 @@ _borast_bo_event_print (cairo_bo_event_t *event)
         break;
     }
     printf ("(%d, %d)\t", event->point.x, event->point.y);
-    _borast_bo_edge_print (((cairo_bo_queue_event_t *)event)->e1);
+    _borast_bo_edge_print (((borast_bo_queue_event_t *)event)->e1);
     printf ("\n");
 }
 
 static void
-_borast_bo_event_queue_print (cairo_bo_event_queue_t *event_queue)
+_borast_bo_event_queue_print (borast_bo_event_queue_t *event_queue)
 {
     /* XXX: fixme to print the start/stop array too. */
     printf ("Event queue:\n");
 }
 
 static void
-_borast_bo_sweep_line_print (cairo_bo_sweep_line_t *sweep_line)
+_borast_bo_sweep_line_print (borast_bo_sweep_line_t *sweep_line)
 {
     borast_bool_t first = TRUE;
     borast_bo_edge_t *edge;
@@ -919,7 +919,7 @@ event_log (const char *fmt, ...)
 #endif
 
 static inline borast_bool_t
-edges_colinear (const borast_bo_edge_t *a, const cairo_bo_edge_t *b)
+edges_colinear (const borast_bo_edge_t *a, const borast_bo_edge_t *b)
 {
     if (_line_equal (&a->edge.line, &b->edge.line))
         return TRUE;
@@ -945,7 +945,7 @@ edges_colinear (const borast_bo_edge_t *a, const cairo_bo_edge_t *b)
 
 /* Adds the trapezoid, if any, of the left edge to the #borast_traps_t */
 static borast_status_t
-_borast_bo_edge_end_trap (cairo_bo_edge_t        *left,
+_borast_bo_edge_end_trap (borast_bo_edge_t        *left,
                          int32_t                 bot,
                          borast_traps_t          *traps)
 {
@@ -988,7 +988,7 @@ _borast_bo_edge_end_trap (cairo_bo_edge_t        *left,
  * right edge differs from `edge->next', or do nothing if the new
  * trapezoid would be a continuation of the existing one. */
 static inline borast_status_t
-_borast_bo_edge_start_or_continue_trap (cairo_bo_edge_t        *left,
+_borast_bo_edge_start_or_continue_trap (borast_bo_edge_t        *left,
                                        borast_bo_edge_t  *right,
                                        int               top,
                                        borast_traps_t        *traps)
@@ -1142,7 +1142,7 @@ _active_edges_to_traps (borast_bo_edge_t		*left,
  * generating trapezoids according to the fill_rule and appending them
  * to traps. */
 static borast_status_t
-_borast_bentley_ottmann_tessellate_bo_edges (cairo_bo_event_t   **start_events,
+_borast_bentley_ottmann_tessellate_bo_edges (borast_bo_event_t   **start_events,
                                             int                  num_events,
                                             borast_traps_t       *traps,
                                             int                 *num_intersections)
@@ -1301,7 +1301,7 @@ contour_to_start_events (PLINE                   *contour,
     bv = &contour->head;
     do {
       int x1, y1, x2, y2;
-      borast_edge_t cairo_edge;
+      borast_edge_t borast_edge;
       /* Node is between bv->point[0,1] and bv->next->point[0,1] */
 
       if (bv->point[1] == bv->next->point[1]) {
@@ -1386,7 +1386,7 @@ bo_poly_to_traps (POLYAREA *poly, borast_traps_t *traps)
 {
   int intersections;
   borast_status_t status;
-  borast_bo_start_event_t stack_events[BORAST_STACK_ARRAY_LENGTH (cairo_bo_start_event_t)];
+  borast_bo_start_event_t stack_events[BORAST_STACK_ARRAY_LENGTH (borast_bo_start_event_t)];
   borast_bo_start_event_t *events;
   borast_bo_event_t *stack_event_ptrs[ARRAY_LENGTH (stack_events) + 1];
   borast_bo_event_t **event_ptrs;
@@ -1484,7 +1484,7 @@ bo_contour_to_traps (PLINE *contour, borast_traps_t *traps)
 {
   int intersections;
   borast_status_t status;
-  borast_bo_start_event_t stack_events[BORAST_STACK_ARRAY_LENGTH (cairo_bo_start_event_t)];
+  borast_bo_start_event_t stack_events[BORAST_STACK_ARRAY_LENGTH (borast_bo_start_event_t)];
   borast_bo_start_event_t *events;
   borast_bo_event_t *stack_event_ptrs[ARRAY_LENGTH (stack_events) + 1];
   borast_bo_event_t **event_ptrs;
diff --git a/src/borast/borast-compiler-private.h b/src/borast/borast-compiler-private.h
index 9fe8e9b..f886f40 100644
--- a/src/borast/borast-compiler-private.h
+++ b/src/borast/borast-compiler-private.h
@@ -35,16 +35,16 @@
  *	Carl D. Worth <cworth@cworth.org>
  */
 
-#ifndef CAIRO_COMPILER_PRIVATE_H
-#define CAIRO_COMPILER_PRIVATE_H
+#ifndef BORAST_COMPILER_PRIVATE_H
+#define BORAST_COMPILER_PRIVATE_H
 
 #if HAVE_CONFIG_H
 #include "config.h"
 #endif
 
 #if __GNUC__ >= 3 && defined(__ELF__) && !defined(__sun)
-# define slim_hidden_proto(name)		slim_hidden_proto1(name, slim_hidden_int_name(name)) cairo_private
-# define slim_hidden_proto_no_warn(name)	slim_hidden_proto1(name, slim_hidden_int_name(name)) cairo_private_no_warn
+# define slim_hidden_proto(name)		slim_hidden_proto1(name, slim_hidden_int_name(name)) borast_private
+# define slim_hidden_proto_no_warn(name)	slim_hidden_proto1(name, slim_hidden_int_name(name)) borast_private_no_warn
 # define slim_hidden_def(name)			slim_hidden_def1(name, slim_hidden_int_name(name))
 # define slim_hidden_int_name(name) INT_##name
 # define slim_hidden_proto1(name, internal)				\
@@ -59,35 +59,35 @@
 # define slim_hidden_asmname(name)	slim_hidden_asmname1(name)
 # define slim_hidden_asmname1(name)	slim_hidden_ulp #name
 #else
-# define slim_hidden_proto(name)		int _cairo_dummy_prototype(void)
-# define slim_hidden_proto_no_warn(name)	int _cairo_dummy_prototype(void)
-# define slim_hidden_def(name)			int _cairo_dummy_prototype(void)
+# define slim_hidden_proto(name)		int _borast_dummy_prototype(void)
+# define slim_hidden_proto_no_warn(name)	int _borast_dummy_prototype(void)
+# define slim_hidden_def(name)			int _borast_dummy_prototype(void)
 #endif
 
 #if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4)
-#define CAIRO_PRINTF_FORMAT(fmt_index, va_index) \
+#define BORAST_PRINTF_FORMAT(fmt_index, va_index) \
 	__attribute__((__format__(__printf__, fmt_index, va_index)))
 #else
-#define CAIRO_PRINTF_FORMAT(fmt_index, va_index)
+#define BORAST_PRINTF_FORMAT(fmt_index, va_index)
 #endif
 
 /* slim_internal.h */
-#define CAIRO_HAS_HIDDEN_SYMBOLS 1
+#define BORAST_HAS_HIDDEN_SYMBOLS 1
 #if (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3)) && defined(__ELF__) && !defined(__sun)
-#define cairo_private_no_warn	__attribute__((__visibility__("hidden")))
+#define borast_private_no_warn	__attribute__((__visibility__("hidden")))
 #elif defined(__SUNPRO_C) && (__SUNPRO_C >= 0x550)
-#define cairo_private_no_warn	__hidden
+#define borast_private_no_warn	__hidden
 #else /* not gcc >= 3.3 and not Sun Studio >= 8 */
-#define cairo_private_no_warn
-#undef CAIRO_HAS_HIDDEN_SYMBOLS
+#define borast_private_no_warn
+#undef BORAST_HAS_HIDDEN_SYMBOLS
 #endif
 
 #ifndef WARN_UNUSED_RESULT
 #define WARN_UNUSED_RESULT
 #endif
 /* Add attribute(warn_unused_result) if supported */
-#define cairo_warn	    WARN_UNUSED_RESULT
-#define cairo_private	    cairo_private_no_warn cairo_warn
+#define borast_warn	    WARN_UNUSED_RESULT
+#define borast_private	    borast_private_no_warn borast_warn
 
 /* This macro allow us to deprecate a function by providing an alias
    for the old function name to the new function name. With this
@@ -101,54 +101,54 @@
    function.
 */
 #if __GNUC__ >= 2 && defined(__ELF__)
-# define CAIRO_FUNCTION_ALIAS(old, new)		\
+# define BORAST_FUNCTION_ALIAS(old, new)		\
 	extern __typeof (new) old		\
 	__asm__ ("" #old)			\
 	__attribute__((__alias__("" #new)))
 #else
-# define CAIRO_FUNCTION_ALIAS(old, new)
+# define BORAST_FUNCTION_ALIAS(old, new)
 #endif
 
 /*
  * Cairo uses the following function attributes in order to improve the
  * generated code (effectively by manual inter-procedural analysis).
  *
- *   'cairo_pure': The function is only allowed to read from its arguments
+ *   'borast_pure': The function is only allowed to read from its arguments
  *                 and global memory (i.e. following a pointer argument or
  *                 accessing a shared variable). The return value should
  *                 only depend on its arguments, and for an identical set of
  *                 arguments should return the same value.
  *
- *   'cairo_const': The function is only allowed to read from its arguments.
+ *   'borast_const': The function is only allowed to read from its arguments.
  *                  It is not allowed to access global memory. The return
  *                  value should only depend its arguments, and for an
  *                  identical set of arguments should return the same value.
  *                  This is currently the most strict function attribute.
  *
  * Both these function attributes allow gcc to perform CSE and
- * constant-folding, with 'cairo_const 'also guaranteeing that pointer contents
+ * constant-folding, with 'borast_const 'also guaranteeing that pointer contents
  * do not change across the function call.
  */
 #if __GNUC__ >= 3
-#define cairo_pure __attribute__((pure))
-#define cairo_const __attribute__((const))
+#define borast_pure __attribute__((pure))
+#define borast_const __attribute__((const))
 #else
-#define cairo_pure
-#define cairo_const
+#define borast_pure
+#define borast_const
 #endif
 
 #if defined(__GNUC__) && (__GNUC__ > 2) && defined(__OPTIMIZE__)
-#define _CAIRO_BOOLEAN_EXPR(expr)                   \
+#define _BORAST_BOOLEAN_EXPR(expr)                   \
  __extension__ ({                               \
-   int _cairo_boolean_var_;                         \
+   int _borast_boolean_var_;                         \
    if (expr)                                    \
-      _cairo_boolean_var_ = 1;                      \
+      _borast_boolean_var_ = 1;                      \
    else                                         \
-      _cairo_boolean_var_ = 0;                      \
-   _cairo_boolean_var_;                             \
+      _borast_boolean_var_ = 0;                      \
+   _borast_boolean_var_;                             \
 })
-#define likely(expr) (__builtin_expect (_CAIRO_BOOLEAN_EXPR(expr), 1))
-#define unlikely(expr) (__builtin_expect (_CAIRO_BOOLEAN_EXPR(expr), 0))
+#define likely(expr) (__builtin_expect (_BORAST_BOOLEAN_EXPR(expr), 1))
+#define unlikely(expr) (__builtin_expect (_BORAST_BOOLEAN_EXPR(expr), 0))
 #else
 #define likely(expr) (expr)
 #define unlikely(expr) (expr)
@@ -173,10 +173,10 @@
 
 #if defined(_MSC_VER) && defined(_M_IX86)
 /* When compiling with /Gy and /OPT:ICF identical functions will be folded in together.
-   The CAIRO_ENSURE_UNIQUE macro ensures that a function is always unique and
+   The BORAST_ENSURE_UNIQUE macro ensures that a function is always unique and
    will never be folded into another one. Something like this might eventually
    be needed for GCC but it seems fine for now. */
-#define CAIRO_ENSURE_UNIQUE                       \
+#define BORAST_ENSURE_UNIQUE                       \
     do {                                          \
 	char func[] = __FUNCTION__;               \
 	char file[] = __FILE__;                   \
@@ -192,7 +192,7 @@
 	};                                        \
     } while (0)
 #else
-#define CAIRO_ENSURE_UNIQUE    do { } while (0)
+#define BORAST_ENSURE_UNIQUE    do { } while (0)
 #endif
 
 #ifdef __STRICT_ANSI__
diff --git a/src/borast/borast-fixed-private.h b/src/borast/borast-fixed-private.h
index e3add4a..8c50f15 100644
--- a/src/borast/borast-fixed-private.h
+++ b/src/borast/borast-fixed-private.h
@@ -34,31 +34,31 @@
  *	Vladimir Vukicevic <vladimir@pobox.com>
  */
 
-#ifndef CAIRO_FIXED_PRIVATE_H
-#define CAIRO_FIXED_PRIVATE_H
+#ifndef BORAST_FIXED_PRIVATE_H
+#define BORAST_FIXED_PRIVATE_H
 
-#include "cairo-fixed-type-private.h"
+#include "borast-fixed-type-private.h"
 
-#include "cairo-wideint-private.h"
+#include "borast-wideint-private.h"
 
 /* Implementation */
 
-#if (CAIRO_FIXED_BITS != 32)
-# error CAIRO_FIXED_BITS must be 32, and the type must be a 32-bit type.
+#if (BORAST_FIXED_BITS != 32)
+# error BORAST_FIXED_BITS must be 32, and the type must be a 32-bit type.
 # error To remove this limitation, you will have to fix the tesselator.
 #endif
 
-#define CAIRO_FIXED_ONE        ((cairo_fixed_t)(1 << CAIRO_FIXED_FRAC_BITS))
-#define CAIRO_FIXED_ONE_DOUBLE ((double)(1 << CAIRO_FIXED_FRAC_BITS))
-#define CAIRO_FIXED_EPSILON    ((cairo_fixed_t)(1))
+#define BORAST_FIXED_ONE        ((borast_fixed_t)(1 << BORAST_FIXED_FRAC_BITS))
+#define BORAST_FIXED_ONE_DOUBLE ((double)(1 << BORAST_FIXED_FRAC_BITS))
+#define BORAST_FIXED_EPSILON    ((borast_fixed_t)(1))
 
-#define CAIRO_FIXED_FRAC_MASK  (((cairo_fixed_unsigned_t)(-1)) >> (CAIRO_FIXED_BITS - CAIRO_FIXED_FRAC_BITS))
-#define CAIRO_FIXED_WHOLE_MASK (~CAIRO_FIXED_FRAC_MASK)
+#define BORAST_FIXED_FRAC_MASK  (((borast_fixed_unsigned_t)(-1)) >> (BORAST_FIXED_BITS - BORAST_FIXED_FRAC_BITS))
+#define BORAST_FIXED_WHOLE_MASK (~BORAST_FIXED_FRAC_MASK)
 
-static inline cairo_fixed_t
-_cairo_fixed_from_int (int i)
+static inline borast_fixed_t
+_borast_fixed_from_int (int i)
 {
-    return i << CAIRO_FIXED_FRAC_BITS;
+    return i << BORAST_FIXED_FRAC_BITS;
 }
 
 /* This is the "magic number" approach to converting a double into fixed
@@ -98,21 +98,21 @@ _cairo_fixed_from_int (int i)
  */
 
 /* The 16.16 number must always be available */
-#define CAIRO_MAGIC_NUMBER_FIXED_16_16 (103079215104.0)
+#define BORAST_MAGIC_NUMBER_FIXED_16_16 (103079215104.0)
 
-#if CAIRO_FIXED_BITS <= 32
-#define CAIRO_MAGIC_NUMBER_FIXED ((1LL << (52 - CAIRO_FIXED_FRAC_BITS)) * 1.5)
+#if BORAST_FIXED_BITS <= 32
+#define BORAST_MAGIC_NUMBER_FIXED ((1LL << (52 - BORAST_FIXED_FRAC_BITS)) * 1.5)
 
 /* For 32-bit fixed point numbers */
-static inline cairo_fixed_t
-_cairo_fixed_from_double (double d)
+static inline borast_fixed_t
+_borast_fixed_from_double (double d)
 {
     union {
         double d;
         int32_t i[2];
     } u;
 
-    u.d = d + CAIRO_MAGIC_NUMBER_FIXED;
+    u.d = d + BORAST_MAGIC_NUMBER_FIXED;
 #ifdef FLOAT_WORDS_BIGENDIAN
     return u.i[1];
 #else
@@ -122,94 +122,94 @@ _cairo_fixed_from_double (double d)
 
 #else
 # error Please define a magic number for your fixed point type!
-# error See cairo-fixed-private.h for details.
+# error See borast-fixed-private.h for details.
 #endif
 
-static inline cairo_fixed_t
-_cairo_fixed_from_26_6 (uint32_t i)
+static inline borast_fixed_t
+_borast_fixed_from_26_6 (uint32_t i)
 {
-#if CAIRO_FIXED_FRAC_BITS > 6
-    return i << (CAIRO_FIXED_FRAC_BITS - 6);
+#if BORAST_FIXED_FRAC_BITS > 6
+    return i << (BORAST_FIXED_FRAC_BITS - 6);
 #else
-    return i >> (6 - CAIRO_FIXED_FRAC_BITS);
+    return i >> (6 - BORAST_FIXED_FRAC_BITS);
 #endif
 }
 
 static inline double
-_cairo_fixed_to_double (cairo_fixed_t f)
+_borast_fixed_to_double (borast_fixed_t f)
 {
-    return ((double) f) / CAIRO_FIXED_ONE_DOUBLE;
+    return ((double) f) / BORAST_FIXED_ONE_DOUBLE;
 }
 
 static inline int
-_cairo_fixed_is_integer (cairo_fixed_t f)
+_borast_fixed_is_integer (borast_fixed_t f)
 {
-    return (f & CAIRO_FIXED_FRAC_MASK) == 0;
+    return (f & BORAST_FIXED_FRAC_MASK) == 0;
 }
 
 static inline int
-_cairo_fixed_integer_part (cairo_fixed_t f)
+_borast_fixed_integer_part (borast_fixed_t f)
 {
-    return f >> CAIRO_FIXED_FRAC_BITS;
+    return f >> BORAST_FIXED_FRAC_BITS;
 }
 
 static inline int
-_cairo_fixed_integer_floor (cairo_fixed_t f)
+_borast_fixed_integer_floor (borast_fixed_t f)
 {
     if (f >= 0)
-        return f >> CAIRO_FIXED_FRAC_BITS;
+        return f >> BORAST_FIXED_FRAC_BITS;
     else
-        return -((-f - 1) >> CAIRO_FIXED_FRAC_BITS) - 1;
+        return -((-f - 1) >> BORAST_FIXED_FRAC_BITS) - 1;
 }
 
 static inline int
-_cairo_fixed_integer_ceil (cairo_fixed_t f)
+_borast_fixed_integer_ceil (borast_fixed_t f)
 {
     if (f > 0)
-	return ((f - 1)>>CAIRO_FIXED_FRAC_BITS) + 1;
+	return ((f - 1)>>BORAST_FIXED_FRAC_BITS) + 1;
     else
-	return - (-f >> CAIRO_FIXED_FRAC_BITS);
+	return - (-f >> BORAST_FIXED_FRAC_BITS);
 }
 
 /* A bunch of explicit 16.16 operators; we need these
  * to interface with pixman and other backends that require
  * 16.16 fixed point types.
  */
-static inline cairo_fixed_16_16_t
-_cairo_fixed_to_16_16 (cairo_fixed_t f)
+static inline borast_fixed_16_16_t
+_borast_fixed_to_16_16 (borast_fixed_t f)
 {
-#if (CAIRO_FIXED_FRAC_BITS == 16) && (CAIRO_FIXED_BITS == 32)
+#if (BORAST_FIXED_FRAC_BITS == 16) && (BORAST_FIXED_BITS == 32)
     return f;
-#elif CAIRO_FIXED_FRAC_BITS > 16
+#elif BORAST_FIXED_FRAC_BITS > 16
     /* We're just dropping the low bits, so we won't ever got over/underflow here */
-    return f >> (CAIRO_FIXED_FRAC_BITS - 16);
+    return f >> (BORAST_FIXED_FRAC_BITS - 16);
 #else
-    cairo_fixed_16_16_t x;
+    borast_fixed_16_16_t x;
 
     /* Handle overflow/underflow by clamping to the lowest/highest
      * value representable as 16.16
      */
-    if ((f >> CAIRO_FIXED_FRAC_BITS) < INT16_MIN) {
+    if ((f >> BORAST_FIXED_FRAC_BITS) < INT16_MIN) {
 	x = INT32_MIN;
-    } else if ((f >> CAIRO_FIXED_FRAC_BITS) > INT16_MAX) {
+    } else if ((f >> BORAST_FIXED_FRAC_BITS) > INT16_MAX) {
 	x = INT32_MAX;
     } else {
-	x = f << (16 - CAIRO_FIXED_FRAC_BITS);
+	x = f << (16 - BORAST_FIXED_FRAC_BITS);
     }
 
     return x;
 #endif
 }
 
-static inline cairo_fixed_16_16_t
-_cairo_fixed_16_16_from_double (double d)
+static inline borast_fixed_16_16_t
+_borast_fixed_16_16_from_double (double d)
 {
     union {
         double d;
         int32_t i[2];
     } u;
 
-    u.d = d + CAIRO_MAGIC_NUMBER_FIXED_16_16;
+    u.d = d + BORAST_MAGIC_NUMBER_FIXED_16_16;
 #ifdef FLOAT_WORDS_BIGENDIAN
     return u.i[1];
 #else
@@ -217,38 +217,38 @@ _cairo_fixed_16_16_from_double (double d)
 #endif
 }
 
-#if CAIRO_FIXED_BITS == 32
+#if BORAST_FIXED_BITS == 32
 
-static inline cairo_fixed_t
-_cairo_fixed_mul (cairo_fixed_t a, cairo_fixed_t b)
+static inline borast_fixed_t
+_borast_fixed_mul (borast_fixed_t a, borast_fixed_t b)
 {
-    cairo_int64_t temp = _cairo_int32x32_64_mul (a, b);
-    return _cairo_int64_to_int32(_cairo_int64_rsl (temp, CAIRO_FIXED_FRAC_BITS));
+    borast_int64_t temp = _borast_int32x32_64_mul (a, b);
+    return _borast_int64_to_int32(_borast_int64_rsl (temp, BORAST_FIXED_FRAC_BITS));
 }
 
 /* computes round (a * b / c) */
-static inline cairo_fixed_t
-_cairo_fixed_mul_div (cairo_fixed_t a, cairo_fixed_t b, cairo_fixed_t c)
+static inline borast_fixed_t
+_borast_fixed_mul_div (borast_fixed_t a, borast_fixed_t b, borast_fixed_t c)
 {
-    cairo_int64_t ab  = _cairo_int32x32_64_mul (a, b);
-    cairo_int64_t c64 = _cairo_int32_to_int64 (c);
-    return _cairo_int64_to_int32 (_cairo_int64_divrem (ab, c64).quo);
+    borast_int64_t ab  = _borast_int32x32_64_mul (a, b);
+    borast_int64_t c64 = _borast_int32_to_int64 (c);
+    return _borast_int64_to_int32 (_borast_int64_divrem (ab, c64).quo);
 }
 
 /* computes floor (a * b / c) */
-static inline cairo_fixed_t
-_cairo_fixed_mul_div_floor (cairo_fixed_t a, cairo_fixed_t b, cairo_fixed_t c)
+static inline borast_fixed_t
+_borast_fixed_mul_div_floor (borast_fixed_t a, borast_fixed_t b, borast_fixed_t c)
 {
-    return _cairo_int64_32_div (_cairo_int32x32_64_mul (a, b), c);
+    return _borast_int64_32_div (_borast_int32x32_64_mul (a, b), c);
 }
 
 
-static inline cairo_fixed_t
-_cairo_edge_compute_intersection_y_for_x (const cairo_point_t *p1,
-					  const cairo_point_t *p2,
-					  cairo_fixed_t x)
+static inline borast_fixed_t
+_borast_edge_compute_intersection_y_for_x (const borast_point_t *p1,
+					  const borast_point_t *p2,
+					  borast_fixed_t x)
 {
-    cairo_fixed_t y, dx;
+    borast_fixed_t y, dx;
 
     if (x == p1->x)
 	return p1->y;
@@ -258,17 +258,17 @@ _cairo_edge_compute_intersection_y_for_x (const cairo_point_t *p1,
     y = p1->y;
     dx = p2->x - p1->x;
     if (dx != 0)
-	y += _cairo_fixed_mul_div_floor (x - p1->x, p2->y - p1->y, dx);
+	y += _borast_fixed_mul_div_floor (x - p1->x, p2->y - p1->y, dx);
 
     return y;
 }
 
-static inline cairo_fixed_t
-_cairo_edge_compute_intersection_x_for_y (const cairo_point_t *p1,
-					  const cairo_point_t *p2,
-					  cairo_fixed_t y)
+static inline borast_fixed_t
+_borast_edge_compute_intersection_x_for_y (const borast_point_t *p1,
+					  const borast_point_t *p2,
+					  borast_fixed_t y)
 {
-    cairo_fixed_t x, dy;
+    borast_fixed_t x, dy;
 
     if (y == p1->y)
 	return p1->x;
@@ -278,7 +278,7 @@ _cairo_edge_compute_intersection_x_for_y (const cairo_point_t *p1,
     x = p1->x;
     dy = p2->y - p1->y;
     if (dy != 0)
-	x += _cairo_fixed_mul_div_floor (y - p1->y, p2->x - p1->x, dy);
+	x += _borast_fixed_mul_div_floor (y - p1->y, p2->x - p1->x, dy);
 
     return x;
 }
@@ -287,4 +287,4 @@ _cairo_edge_compute_intersection_x_for_y (const cairo_point_t *p1,
 # error Please define multiplication and other operands for your fixed-point type size
 #endif
 
-#endif /* CAIRO_FIXED_PRIVATE_H */
+#endif /* BORAST_FIXED_PRIVATE_H */
diff --git a/src/borast/borast-fixed-type-private.h b/src/borast/borast-fixed-type-private.h
index 730ed3e..ee5d7eb 100644
--- a/src/borast/borast-fixed-type-private.h
+++ b/src/borast/borast-fixed-type-private.h
@@ -34,42 +34,42 @@
  *	Vladimir Vukicevic <vladimir@pobox.com>
  */
 
-#ifndef CAIRO_FIXED_TYPE_PRIVATE_H
-#define CAIRO_FIXED_TYPE_PRIVATE_H
+#ifndef BORAST_FIXED_TYPE_PRIVATE_H
+#define BORAST_FIXED_TYPE_PRIVATE_H
 
-#include "cairo-wideint-type-private.h"
+#include "borast-wideint-type-private.h"
 
 /*
  * Fixed-point configuration
  */
 
-typedef int32_t		cairo_fixed_16_16_t;
-typedef cairo_int64_t	cairo_fixed_32_32_t;
-typedef cairo_int64_t	cairo_fixed_48_16_t;
-typedef cairo_int128_t	cairo_fixed_64_64_t;
-typedef cairo_int128_t	cairo_fixed_96_32_t;
+typedef int32_t		borast_fixed_16_16_t;
+typedef borast_int64_t	borast_fixed_32_32_t;
+typedef borast_int64_t	borast_fixed_48_16_t;
+typedef borast_int128_t	borast_fixed_64_64_t;
+typedef borast_int128_t	borast_fixed_96_32_t;
 
 /* Eventually, we should allow changing this, but I think
  * there are some assumptions in the tesselator about the
  * size of a fixed type.  For now, it must be 32.
  */
-#define CAIRO_FIXED_BITS	32
+#define BORAST_FIXED_BITS	32
 
 /* The number of fractional bits.  Changing this involves
  * making sure that you compute a double-to-fixed magic number.
  * (see below).
  */
-#define CAIRO_FIXED_FRAC_BITS	8
+#define BORAST_FIXED_FRAC_BITS	8
 
-/* A signed type %CAIRO_FIXED_BITS in size; the main fixed point type */
-typedef int32_t cairo_fixed_t;
+/* A signed type %BORAST_FIXED_BITS in size; the main fixed point type */
+typedef int32_t borast_fixed_t;
 
-/* An unsigned type of the same size as #cairo_fixed_t */
-typedef uint32_t cairo_fixed_unsigned_t;
+/* An unsigned type of the same size as #borast_fixed_t */
+typedef uint32_t borast_fixed_unsigned_t;
 
-typedef struct _cairo_point {
-    cairo_fixed_t x;
-    cairo_fixed_t y;
-} cairo_point_t;
+typedef struct _borast_point {
+    borast_fixed_t x;
+    borast_fixed_t y;
+} borast_point_t;
 
-#endif /* CAIRO_FIXED_TYPE_PRIVATE_H */
+#endif /* BORAST_FIXED_TYPE_PRIVATE_H */
diff --git a/src/borast/borast-freelist-private.h b/src/borast/borast-freelist-private.h
index 5be22b1..6a3aaf7 100644
--- a/src/borast/borast-freelist-private.h
+++ b/src/borast/borast-freelist-private.h
@@ -19,11 +19,11 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
  * OF THIS SOFTWARE.
  */
-#ifndef CAIRO_FREELIST_H
-#define CAIRO_FREELIST_H
+#ifndef BORAST_FREELIST_H
+#define BORAST_FREELIST_H
 
-#include "cairo-types-private.h"
-#include "cairo-compiler-private.h"
+#include "borast-types-private.h"
+#include "borast-compiler-private.h"
 
 /* for stand-alone compilation*/
 #ifndef VG
@@ -34,80 +34,80 @@
 #define NULL (void *) 0
 #endif
 
-typedef struct _cairo_freelist_node cairo_freelist_node_t;
-struct _cairo_freelist_node {
-    cairo_freelist_node_t *next;
+typedef struct _borast_freelist_node borast_freelist_node_t;
+struct _borast_freelist_node {
+    borast_freelist_node_t *next;
 };
 
-typedef struct _cairo_freelist {
-    cairo_freelist_node_t *first_free_node;
+typedef struct _borast_freelist {
+    borast_freelist_node_t *first_free_node;
     unsigned nodesize;
-} cairo_freelist_t;
+} borast_freelist_t;
 
-typedef struct _cairo_freelist_pool cairo_freelist_pool_t;
-struct _cairo_freelist_pool {
-    cairo_freelist_pool_t *next;
+typedef struct _borast_freelist_pool borast_freelist_pool_t;
+struct _borast_freelist_pool {
+    borast_freelist_pool_t *next;
     unsigned size, rem;
     uint8_t *data;
 };
 
-typedef struct _cairo_freepool {
-    cairo_freelist_node_t *first_free_node;
-    cairo_freelist_pool_t *pools;
+typedef struct _borast_freepool {
+    borast_freelist_node_t *first_free_node;
+    borast_freelist_pool_t *pools;
     unsigned nodesize;
-    cairo_freelist_pool_t embedded_pool;
+    borast_freelist_pool_t embedded_pool;
     uint8_t embedded_data[1000];
-} cairo_freepool_t;
+} borast_freepool_t;
 
 
 /* Initialise a freelist that will be responsible for allocating
  * nodes of size nodesize. */
-cairo_private void
-_cairo_freelist_init (cairo_freelist_t *freelist, unsigned nodesize);
+borast_private void
+_borast_freelist_init (borast_freelist_t *freelist, unsigned nodesize);
 
 /* Deallocate any nodes in the freelist. */
-cairo_private void
-_cairo_freelist_fini (cairo_freelist_t *freelist);
+borast_private void
+_borast_freelist_fini (borast_freelist_t *freelist);
 
 /* Allocate a new node from the freelist.  If the freelist contains no
  * nodes, a new one will be allocated using malloc().  The caller is
- * responsible for calling _cairo_freelist_free() or free() on the
+ * responsible for calling _borast_freelist_free() or free() on the
  * returned node.  Returns %NULL on memory allocation error. */
-cairo_private void *
-_cairo_freelist_alloc (cairo_freelist_t *freelist);
+borast_private void *
+_borast_freelist_alloc (borast_freelist_t *freelist);
 
 /* Allocate a new node from the freelist.  If the freelist contains no
  * nodes, a new one will be allocated using calloc().  The caller is
- * responsible for calling _cairo_freelist_free() or free() on the
+ * responsible for calling _borast_freelist_free() or free() on the
  * returned node.  Returns %NULL on memory allocation error. */
-cairo_private void *
-_cairo_freelist_calloc (cairo_freelist_t *freelist);
+borast_private void *
+_borast_freelist_calloc (borast_freelist_t *freelist);
 
 /* Return a node to the freelist. This does not deallocate the memory,
  * but makes it available for later reuse by
- * _cairo_freelist_alloc(). */
-cairo_private void
-_cairo_freelist_free (cairo_freelist_t *freelist, void *node);
+ * _borast_freelist_alloc(). */
+borast_private void
+_borast_freelist_free (borast_freelist_t *freelist, void *node);
 
 
-cairo_private void
-_cairo_freepool_init (cairo_freepool_t *freepool, unsigned nodesize);
+borast_private void
+_borast_freepool_init (borast_freepool_t *freepool, unsigned nodesize);
 
-cairo_private void
-_cairo_freepool_fini (cairo_freepool_t *freepool);
+borast_private void
+_borast_freepool_fini (borast_freepool_t *freepool);
 
-cairo_private void *
-_cairo_freepool_alloc_from_new_pool (cairo_freepool_t *freepool);
+borast_private void *
+_borast_freepool_alloc_from_new_pool (borast_freepool_t *freepool);
 
 static inline void *
-_cairo_freepool_alloc_from_pool (cairo_freepool_t *freepool)
+_borast_freepool_alloc_from_pool (borast_freepool_t *freepool)
 {
-    cairo_freelist_pool_t *pool;
+    borast_freelist_pool_t *pool;
     uint8_t *ptr;
 
     pool = freepool->pools;
     if (unlikely (freepool->nodesize > pool->rem))
-	return _cairo_freepool_alloc_from_new_pool (freepool);
+	return _borast_freepool_alloc_from_new_pool (freepool);
 
     ptr = pool->data;
     pool->data += freepool->nodesize;
@@ -117,13 +117,13 @@ _cairo_freepool_alloc_from_pool (cairo_freepool_t *freepool)
 }
 
 static inline void *
-_cairo_freepool_alloc (cairo_freepool_t *freepool)
+_borast_freepool_alloc (borast_freepool_t *freepool)
 {
-    cairo_freelist_node_t *node;
+    borast_freelist_node_t *node;
 
     node = freepool->first_free_node;
     if (unlikely (node == NULL))
-	return _cairo_freepool_alloc_from_pool (freepool);
+	return _borast_freepool_alloc_from_pool (freepool);
 
     VG (VALGRIND_MAKE_MEM_DEFINED (node, sizeof (node->next)));
     freepool->first_free_node = node->next;
@@ -132,19 +132,19 @@ _cairo_freepool_alloc (cairo_freepool_t *freepool)
     return node;
 }
 
-cairo_private cairo_status_t
-_cairo_freepool_alloc_array (cairo_freepool_t *freepool,
+borast_private borast_status_t
+_borast_freepool_alloc_array (borast_freepool_t *freepool,
 			     int count,
 			     void **array);
 
 static inline void
-_cairo_freepool_free (cairo_freepool_t *freepool, void *ptr)
+_borast_freepool_free (borast_freepool_t *freepool, void *ptr)
 {
-    cairo_freelist_node_t *node = ptr;
+    borast_freelist_node_t *node = ptr;
 
     node->next = freepool->first_free_node;
     freepool->first_free_node = node;
     VG (VALGRIND_MAKE_MEM_NOACCESS (node, freepool->nodesize));
 }
 
-#endif /* CAIRO_FREELIST_H */
+#endif /* BORAST_FREELIST_H */
diff --git a/src/borast/borast-freelist.c b/src/borast/borast-freelist.c
index 6ea5c17..a5904d9 100644
--- a/src/borast/borast-freelist.c
+++ b/src/borast/borast-freelist.c
@@ -23,23 +23,23 @@
 #include <stdlib.h>
 #include <string.h>
 
-#include "cairo-freelist-private.h"
+#include "borast-freelist-private.h"
 
-#define _cairo_error(x) (x)
+#define _borast_error(x) (x)
 
 void
-_cairo_freelist_init (cairo_freelist_t *freelist, unsigned nodesize)
+_borast_freelist_init (borast_freelist_t *freelist, unsigned nodesize)
 {
-    memset (freelist, 0, sizeof (cairo_freelist_t));
+    memset (freelist, 0, sizeof (borast_freelist_t));
     freelist->nodesize = nodesize;
 }
 
 void
-_cairo_freelist_fini (cairo_freelist_t *freelist)
+_borast_freelist_fini (borast_freelist_t *freelist)
 {
-    cairo_freelist_node_t *node = freelist->first_free_node;
+    borast_freelist_node_t *node = freelist->first_free_node;
     while (node) {
-	cairo_freelist_node_t *next;
+	borast_freelist_node_t *next;
 
 	VG (VALGRIND_MAKE_MEM_DEFINED (node, sizeof (node->next)));
 	next = node->next;
@@ -50,10 +50,10 @@ _cairo_freelist_fini (cairo_freelist_t *freelist)
 }
 
 void *
-_cairo_freelist_alloc (cairo_freelist_t *freelist)
+_borast_freelist_alloc (borast_freelist_t *freelist)
 {
     if (freelist->first_free_node) {
-	cairo_freelist_node_t *node;
+	borast_freelist_node_t *node;
 
 	node = freelist->first_free_node;
 	VG (VALGRIND_MAKE_MEM_DEFINED (node, sizeof (node->next)));
@@ -67,18 +67,18 @@ _cairo_freelist_alloc (cairo_freelist_t *freelist)
 }
 
 void *
-_cairo_freelist_calloc (cairo_freelist_t *freelist)
+_borast_freelist_calloc (borast_freelist_t *freelist)
 {
-    void *node = _cairo_freelist_alloc (freelist);
+    void *node = _borast_freelist_alloc (freelist);
     if (node)
 	memset (node, 0, freelist->nodesize);
     return node;
 }
 
 void
-_cairo_freelist_free (cairo_freelist_t *freelist, void *voidnode)
+_borast_freelist_free (borast_freelist_t *freelist, void *voidnode)
 {
-    cairo_freelist_node_t *node = voidnode;
+    borast_freelist_node_t *node = voidnode;
     if (node) {
 	node->next = freelist->first_free_node;
 	freelist->first_free_node = node;
@@ -88,7 +88,7 @@ _cairo_freelist_free (cairo_freelist_t *freelist, void *voidnode)
 
 
 void
-_cairo_freepool_init (cairo_freepool_t *freepool, unsigned nodesize)
+_borast_freepool_init (borast_freepool_t *freepool, unsigned nodesize)
 {
     freepool->first_free_node = NULL;
     freepool->pools = &freepool->embedded_pool;
@@ -104,11 +104,11 @@ _cairo_freepool_init (cairo_freepool_t *freepool, unsigned nodesize)
 }
 
 void
-_cairo_freepool_fini (cairo_freepool_t *freepool)
+_borast_freepool_fini (borast_freepool_t *freepool)
 {
-    cairo_freelist_pool_t *pool = freepool->pools;
+    borast_freelist_pool_t *pool = freepool->pools;
     while (pool != &freepool->embedded_pool) {
-	cairo_freelist_pool_t *next = pool->next;
+	borast_freelist_pool_t *next = pool->next;
 	free (pool);
 	pool = next;
     }
@@ -116,16 +116,16 @@ _cairo_freepool_fini (cairo_freepool_t *freepool)
 }
 
 void *
-_cairo_freepool_alloc_from_new_pool (cairo_freepool_t *freepool)
+_borast_freepool_alloc_from_new_pool (borast_freepool_t *freepool)
 {
-    cairo_freelist_pool_t *pool;
+    borast_freelist_pool_t *pool;
     int poolsize;
 
     if (freepool->pools != &freepool->embedded_pool)
 	poolsize = 2 * freepool->pools->size;
     else
 	poolsize = (128 * freepool->nodesize + 8191) & -8192;
-    pool = malloc (sizeof (cairo_freelist_pool_t) + poolsize);
+    pool = malloc (sizeof (borast_freelist_pool_t) + poolsize);
     if (unlikely (pool == NULL))
 	return pool;
 
@@ -142,15 +142,15 @@ _cairo_freepool_alloc_from_new_pool (cairo_freepool_t *freepool)
     return pool + 1;
 }
 
-cairo_status_t
-_cairo_freepool_alloc_array (cairo_freepool_t *freepool,
+borast_status_t
+_borast_freepool_alloc_array (borast_freepool_t *freepool,
 			     int count,
 			     void **array)
 {
     int i;
 
     for (i = 0; i < count; i++) {
-	cairo_freelist_node_t *node;
+	borast_freelist_node_t *node;
 
 	node = freepool->first_free_node;
 	if (likely (node != NULL)) {
@@ -158,7 +158,7 @@ _cairo_freepool_alloc_array (cairo_freepool_t *freepool,
 	    freepool->first_free_node = node->next;
 	    VG (VALGRIND_MAKE_MEM_UNDEFINED (node, freepool->nodesize));
 	} else {
-	    node = _cairo_freepool_alloc_from_pool (freepool);
+	    node = _borast_freepool_alloc_from_pool (freepool);
 	    if (unlikely (node == NULL))
 		goto CLEANUP;
 	}
@@ -166,11 +166,11 @@ _cairo_freepool_alloc_array (cairo_freepool_t *freepool,
 	array[i] = node;
     }
 
-    return CAIRO_STATUS_SUCCESS;
+    return BORAST_STATUS_SUCCESS;
 
   CLEANUP:
     while (i--)
-	_cairo_freepool_free (freepool, array[i]);
+	_borast_freepool_free (freepool, array[i]);
 
-    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+    return _borast_error (BORAST_STATUS_NO_MEMORY);
 }
diff --git a/src/borast/borast-malloc-private.h b/src/borast/borast-malloc-private.h
index d812058..2b87faf 100644
--- a/src/borast/borast-malloc-private.h
+++ b/src/borast/borast-malloc-private.h
@@ -34,20 +34,20 @@
  *	Vladimir Vukicevic <vladimir@pobox.com>
  */
 
-#ifndef CAIRO_MALLOC_PRIVATE_H
-#define CAIRO_MALLOC_PRIVATE_H
+#ifndef BORAST_MALLOC_PRIVATE_H
+#define BORAST_MALLOC_PRIVATE_H
 
-#include "cairo-wideint-private.h"
+#include "borast-wideint-private.h"
 
 #if HAVE_MEMFAULT
 #include <memfault.h>
-#define CAIRO_INJECT_FAULT() MEMFAULT_INJECT_FAULT()
+#define BORAST_INJECT_FAULT() MEMFAULT_INJECT_FAULT()
 #else
-#define CAIRO_INJECT_FAULT() 0
+#define BORAST_INJECT_FAULT() 0
 #endif
 
 /**
- * _cairo_malloc:
+ * _borast_malloc:
  * @size: size in bytes
  *
  * Allocate @size memory using malloc().
@@ -58,15 +58,15 @@
  * case of malloc() failure or size is 0.
  */
 
-#define _cairo_malloc(size) \
+#define _borast_malloc(size) \
    ((size) ? malloc((unsigned) (size)) : NULL)
 
 /**
- * _cairo_malloc_ab:
+ * _borast_malloc_ab:
  * @n: number of elements to allocate
  * @size: size of each element
  *
- * Allocates @n*@size memory using _cairo_malloc(), taking care to not
+ * Allocates @n*@size memory using _borast_malloc(), taking care to not
  * overflow when doing the multiplication.  Behaves much like
  * calloc(), except that the returned memory is not set to zero.
  * The memory should be freed using free().
@@ -78,12 +78,12 @@
  * case of malloc() failure or overflow.
  */
 
-#define _cairo_malloc_ab(a, size) \
+#define _borast_malloc_ab(a, size) \
   ((size) && (unsigned) (a) >= INT32_MAX / (unsigned) (size) ? NULL : \
-   _cairo_malloc((unsigned) (a) * (unsigned) (size)))
+   _borast_malloc((unsigned) (a) * (unsigned) (size)))
 
 /**
- * _cairo_realloc_ab:
+ * _borast_realloc_ab:
  * @ptr: original pointer to block of memory to be resized
  * @n: number of elements to allocate
  * @size: size of each element
@@ -100,19 +100,19 @@
  * of memory * is left untouched).
  */
 
-#define _cairo_realloc_ab(ptr, a, size) \
+#define _borast_realloc_ab(ptr, a, size) \
   ((size) && (unsigned) (a) >= INT32_MAX / (unsigned) (size) ? NULL : \
    realloc(ptr, (unsigned) (a) * (unsigned) (size)))
 
 /**
- * _cairo_malloc_abc:
+ * _borast_malloc_abc:
  * @n: first factor of number of elements to allocate
  * @b: second factor of number of elements to allocate
  * @size: size of each element
  *
- * Allocates @n*@b*@size memory using _cairo_malloc(), taking care to not
+ * Allocates @n*@b*@size memory using _borast_malloc(), taking care to not
  * overflow when doing the multiplication.  Behaves like
- * _cairo_malloc_ab().  The memory should be freed using free().
+ * _borast_malloc_ab().  The memory should be freed using free().
  *
  * @size should be a constant so that the compiler can optimize
  * out a constant division.
@@ -121,28 +121,28 @@
  * case of malloc() failure or overflow.
  */
 
-#define _cairo_malloc_abc(a, b, size) \
+#define _borast_malloc_abc(a, b, size) \
   ((b) && (unsigned) (a) >= INT32_MAX / (unsigned) (b) ? NULL : \
    (size) && (unsigned) ((a)*(b)) >= INT32_MAX / (unsigned) (size) ? NULL : \
-   _cairo_malloc((unsigned) (a) * (unsigned) (b) * (unsigned) (size)))
+   _borast_malloc((unsigned) (a) * (unsigned) (b) * (unsigned) (size)))
 
 /**
- * _cairo_malloc_ab_plus_c:
+ * _borast_malloc_ab_plus_c:
  * @n: number of elements to allocate
  * @size: size of each element
  * @k: additional size to allocate
  *
- * Allocates @n*@ksize+@k memory using _cairo_malloc(), taking care to not
+ * Allocates @n*@ksize+@k memory using _borast_malloc(), taking care to not
  * overflow when doing the arithmetic.  Behaves like
- * _cairo_malloc_ab().  The memory should be freed using free().
+ * _borast_malloc_ab().  The memory should be freed using free().
  *
  * Return value: A pointer to the newly allocated memory, or %NULL in
  * case of malloc() failure or overflow.
  */
 
-#define _cairo_malloc_ab_plus_c(n, size, k) \
+#define _borast_malloc_ab_plus_c(n, size, k) \
   ((size) && (unsigned) (n) >= INT32_MAX / (unsigned) (size) ? NULL : \
    (unsigned) (k) >= INT32_MAX - (unsigned) (n) * (unsigned) (size) ? NULL : \
-   _cairo_malloc((unsigned) (n) * (unsigned) (size) + (unsigned) (k)))
+   _borast_malloc((unsigned) (n) * (unsigned) (size) + (unsigned) (k)))
 
-#endif /* CAIRO_MALLOC_PRIVATE_H */
+#endif /* BORAST_MALLOC_PRIVATE_H */
diff --git a/src/borast/borast-minimal.h b/src/borast/borast-minimal.h
index 9028299..ada4419 100644
--- a/src/borast/borast-minimal.h
+++ b/src/borast/borast-minimal.h
@@ -35,142 +35,142 @@
  *	Carl D. Worth <cworth@cworth.org>
  */
 
-#ifndef _CAIRO_MINIMAL_H_
-#define _CAIRO_MINIMAL_H_
+#ifndef _BORAST_MINIMAL_H_
+#define _BORAST_MINIMAL_H_
 
 #ifdef  __cplusplus
-# define CAIRO_BEGIN_DECLS  extern "C" {
-# define CAIRO_END_DECLS    }
+# define BORAST_BEGIN_DECLS  extern "C" {
+# define BORAST_END_DECLS    }
 #else
-# define CAIRO_BEGIN_DECLS
-# define CAIRO_END_DECLS
+# define BORAST_BEGIN_DECLS
+# define BORAST_END_DECLS
 #endif
 
-#ifndef cairo_public
-# define cairo_public
+#ifndef borast_public
+# define borast_public
 #endif
 
-CAIRO_BEGIN_DECLS
+BORAST_BEGIN_DECLS
 
 /**
- * cairo_bool_t:
+ * borast_bool_t:
  *
- * #cairo_bool_t is used for boolean values. Returns of type
- * #cairo_bool_t will always be either 0 or 1, but testing against
+ * #borast_bool_t is used for boolean values. Returns of type
+ * #borast_bool_t will always be either 0 or 1, but testing against
  * these values explicitly is not encouraged; just use the
  * value as a boolean condition.
  *
  * <informalexample><programlisting>
- *  if (cairo_in_stroke (cr, x, y)) {
+ *  if (borast_in_stroke (cr, x, y)) {
  *      /<!-- -->* do something *<!-- -->/
  *  }
  * </programlisting></informalexample>
  **/
-typedef int cairo_bool_t;
+typedef int borast_bool_t;
 
 
 /**
- * cairo_status_t:
- * @CAIRO_STATUS_SUCCESS: no error has occurred
- * @CAIRO_STATUS_NO_MEMORY: out of memory
- * @CAIRO_STATUS_INVALID_RESTORE: cairo_restore() called without matching cairo_save()
- * @CAIRO_STATUS_INVALID_POP_GROUP: no saved group to pop, i.e. cairo_pop_group() without matching cairo_push_group()
- * @CAIRO_STATUS_NO_CURRENT_POINT: no current point defined
- * @CAIRO_STATUS_INVALID_MATRIX: invalid matrix (not invertible)
- * @CAIRO_STATUS_INVALID_STATUS: invalid value for an input #cairo_status_t
- * @CAIRO_STATUS_NULL_POINTER: %NULL pointer
- * @CAIRO_STATUS_INVALID_STRING: input string not valid UTF-8
- * @CAIRO_STATUS_INVALID_PATH_DATA: input path data not valid
- * @CAIRO_STATUS_READ_ERROR: error while reading from input stream
- * @CAIRO_STATUS_WRITE_ERROR: error while writing to output stream
- * @CAIRO_STATUS_SURFACE_FINISHED: target surface has been finished
- * @CAIRO_STATUS_SURFACE_TYPE_MISMATCH: the surface type is not appropriate for the operation
- * @CAIRO_STATUS_PATTERN_TYPE_MISMATCH: the pattern type is not appropriate for the operation
- * @CAIRO_STATUS_INVALID_CONTENT: invalid value for an input #cairo_content_t
- * @CAIRO_STATUS_INVALID_FORMAT: invalid value for an input #cairo_format_t
- * @CAIRO_STATUS_INVALID_VISUAL: invalid value for an input Visual*
- * @CAIRO_STATUS_FILE_NOT_FOUND: file not found
- * @CAIRO_STATUS_INVALID_DASH: invalid value for a dash setting
- * @CAIRO_STATUS_INVALID_DSC_COMMENT: invalid value for a DSC comment (Since 1.2)
- * @CAIRO_STATUS_INVALID_INDEX: invalid index passed to getter (Since 1.4)
- * @CAIRO_STATUS_CLIP_NOT_REPRESENTABLE: clip region not representable in desired format (Since 1.4)
- * @CAIRO_STATUS_TEMP_FILE_ERROR: error creating or writing to a temporary file (Since 1.6)
- * @CAIRO_STATUS_INVALID_STRIDE: invalid value for stride (Since 1.6)
- * @CAIRO_STATUS_FONT_TYPE_MISMATCH: the font type is not appropriate for the operation (Since 1.8)
- * @CAIRO_STATUS_USER_FONT_IMMUTABLE: the user-font is immutable (Since 1.8)
- * @CAIRO_STATUS_USER_FONT_ERROR: error occurred in a user-font callback function (Since 1.8)
- * @CAIRO_STATUS_NEGATIVE_COUNT: negative number used where it is not allowed (Since 1.8)
- * @CAIRO_STATUS_INVALID_CLUSTERS: input clusters do not represent the accompanying text and glyph array (Since 1.8)
- * @CAIRO_STATUS_INVALID_SLANT: invalid value for an input #cairo_font_slant_t (Since 1.8)
- * @CAIRO_STATUS_INVALID_WEIGHT: invalid value for an input #cairo_font_weight_t (Since 1.8)
- * @CAIRO_STATUS_INVALID_SIZE: invalid value (typically too big) for the size of the input (surface, pattern, etc.) (Since 1.10)
- * @CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED: user-font method not implemented (Since 1.10)
- * @CAIRO_STATUS_LAST_STATUS: this is a special value indicating the number of
+ * borast_status_t:
+ * @BORAST_STATUS_SUCCESS: no error has occurred
+ * @BORAST_STATUS_NO_MEMORY: out of memory
+ * @BORAST_STATUS_INVALID_RESTORE: borast_restore() called without matching borast_save()
+ * @BORAST_STATUS_INVALID_POP_GROUP: no saved group to pop, i.e. borast_pop_group() without matching borast_push_group()
+ * @BORAST_STATUS_NO_CURRENT_POINT: no current point defined
+ * @BORAST_STATUS_INVALID_MATRIX: invalid matrix (not invertible)
+ * @BORAST_STATUS_INVALID_STATUS: invalid value for an input #borast_status_t
+ * @BORAST_STATUS_NULL_POINTER: %NULL pointer
+ * @BORAST_STATUS_INVALID_STRING: input string not valid UTF-8
+ * @BORAST_STATUS_INVALID_PATH_DATA: input path data not valid
+ * @BORAST_STATUS_READ_ERROR: error while reading from input stream
+ * @BORAST_STATUS_WRITE_ERROR: error while writing to output stream
+ * @BORAST_STATUS_SURFACE_FINISHED: target surface has been finished
+ * @BORAST_STATUS_SURFACE_TYPE_MISMATCH: the surface type is not appropriate for the operation
+ * @BORAST_STATUS_PATTERN_TYPE_MISMATCH: the pattern type is not appropriate for the operation
+ * @BORAST_STATUS_INVALID_CONTENT: invalid value for an input #borast_content_t
+ * @BORAST_STATUS_INVALID_FORMAT: invalid value for an input #borast_format_t
+ * @BORAST_STATUS_INVALID_VISUAL: invalid value for an input Visual*
+ * @BORAST_STATUS_FILE_NOT_FOUND: file not found
+ * @BORAST_STATUS_INVALID_DASH: invalid value for a dash setting
+ * @BORAST_STATUS_INVALID_DSC_COMMENT: invalid value for a DSC comment (Since 1.2)
+ * @BORAST_STATUS_INVALID_INDEX: invalid index passed to getter (Since 1.4)
+ * @BORAST_STATUS_CLIP_NOT_REPRESENTABLE: clip region not representable in desired format (Since 1.4)
+ * @BORAST_STATUS_TEMP_FILE_ERROR: error creating or writing to a temporary file (Since 1.6)
+ * @BORAST_STATUS_INVALID_STRIDE: invalid value for stride (Since 1.6)
+ * @BORAST_STATUS_FONT_TYPE_MISMATCH: the font type is not appropriate for the operation (Since 1.8)
+ * @BORAST_STATUS_USER_FONT_IMMUTABLE: the user-font is immutable (Since 1.8)
+ * @BORAST_STATUS_USER_FONT_ERROR: error occurred in a user-font callback function (Since 1.8)
+ * @BORAST_STATUS_NEGATIVE_COUNT: negative number used where it is not allowed (Since 1.8)
+ * @BORAST_STATUS_INVALID_CLUSTERS: input clusters do not represent the accompanying text and glyph array (Since 1.8)
+ * @BORAST_STATUS_INVALID_SLANT: invalid value for an input #borast_font_slant_t (Since 1.8)
+ * @BORAST_STATUS_INVALID_WEIGHT: invalid value for an input #borast_font_weight_t (Since 1.8)
+ * @BORAST_STATUS_INVALID_SIZE: invalid value (typically too big) for the size of the input (surface, pattern, etc.) (Since 1.10)
+ * @BORAST_STATUS_USER_FONT_NOT_IMPLEMENTED: user-font method not implemented (Since 1.10)
+ * @BORAST_STATUS_LAST_STATUS: this is a special value indicating the number of
  *   status values defined in this enumeration.  When using this value, note
- *   that the version of cairo at run-time may have additional status values
+ *   that the version of borast at run-time may have additional status values
  *   defined than the value of this symbol at compile-time. (Since 1.10)
  *
- * #cairo_status_t is used to indicate errors that can occur when
+ * #borast_status_t is used to indicate errors that can occur when
  * using Cairo. In some cases it is returned directly by functions.
- * but when using #cairo_t, the last error, if any, is stored in
- * the context and can be retrieved with cairo_status().
+ * but when using #borast_t, the last error, if any, is stored in
+ * the context and can be retrieved with borast_status().
  *
- * New entries may be added in future versions.  Use cairo_status_to_string()
+ * New entries may be added in future versions.  Use borast_status_to_string()
  * to get a human-readable representation of an error message.
  **/
-typedef enum _cairo_status {
-    CAIRO_STATUS_SUCCESS = 0,
-
-    CAIRO_STATUS_NO_MEMORY,
-    CAIRO_STATUS_INVALID_RESTORE,
-    CAIRO_STATUS_INVALID_POP_GROUP,
-    CAIRO_STATUS_NO_CURRENT_POINT,
-    CAIRO_STATUS_INVALID_MATRIX,
-    CAIRO_STATUS_INVALID_STATUS,
-    CAIRO_STATUS_NULL_POINTER,
-    CAIRO_STATUS_INVALID_STRING,
-    CAIRO_STATUS_INVALID_PATH_DATA,
-    CAIRO_STATUS_READ_ERROR,
-    CAIRO_STATUS_WRITE_ERROR,
-    CAIRO_STATUS_SURFACE_FINISHED,
-    CAIRO_STATUS_SURFACE_TYPE_MISMATCH,
-    CAIRO_STATUS_PATTERN_TYPE_MISMATCH,
-    CAIRO_STATUS_INVALID_CONTENT,
-    CAIRO_STATUS_INVALID_FORMAT,
-    CAIRO_STATUS_INVALID_VISUAL,
-    CAIRO_STATUS_FILE_NOT_FOUND,
-    CAIRO_STATUS_INVALID_DASH,
-    CAIRO_STATUS_INVALID_DSC_COMMENT,
-    CAIRO_STATUS_INVALID_INDEX,
-    CAIRO_STATUS_CLIP_NOT_REPRESENTABLE,
-    CAIRO_STATUS_TEMP_FILE_ERROR,
-    CAIRO_STATUS_INVALID_STRIDE,
-    CAIRO_STATUS_FONT_TYPE_MISMATCH,
-    CAIRO_STATUS_USER_FONT_IMMUTABLE,
-    CAIRO_STATUS_USER_FONT_ERROR,
-    CAIRO_STATUS_NEGATIVE_COUNT,
-    CAIRO_STATUS_INVALID_CLUSTERS,
-    CAIRO_STATUS_INVALID_SLANT,
-    CAIRO_STATUS_INVALID_WEIGHT,
-    CAIRO_STATUS_INVALID_SIZE,
-    CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED,
-
-    CAIRO_STATUS_LAST_STATUS
-} cairo_status_t;
+typedef enum _borast_status {
+    BORAST_STATUS_SUCCESS = 0,
+
+    BORAST_STATUS_NO_MEMORY,
+    BORAST_STATUS_INVALID_RESTORE,
+    BORAST_STATUS_INVALID_POP_GROUP,
+    BORAST_STATUS_NO_CURRENT_POINT,
+    BORAST_STATUS_INVALID_MATRIX,
+    BORAST_STATUS_INVALID_STATUS,
+    BORAST_STATUS_NULL_POINTER,
+    BORAST_STATUS_INVALID_STRING,
+    BORAST_STATUS_INVALID_PATH_DATA,
+    BORAST_STATUS_READ_ERROR,
+    BORAST_STATUS_WRITE_ERROR,
+    BORAST_STATUS_SURFACE_FINISHED,
+    BORAST_STATUS_SURFACE_TYPE_MISMATCH,
+    BORAST_STATUS_PATTERN_TYPE_MISMATCH,
+    BORAST_STATUS_INVALID_CONTENT,
+    BORAST_STATUS_INVALID_FORMAT,
+    BORAST_STATUS_INVALID_VISUAL,
+    BORAST_STATUS_FILE_NOT_FOUND,
+    BORAST_STATUS_INVALID_DASH,
+    BORAST_STATUS_INVALID_DSC_COMMENT,
+    BORAST_STATUS_INVALID_INDEX,
+    BORAST_STATUS_CLIP_NOT_REPRESENTABLE,
+    BORAST_STATUS_TEMP_FILE_ERROR,
+    BORAST_STATUS_INVALID_STRIDE,
+    BORAST_STATUS_FONT_TYPE_MISMATCH,
+    BORAST_STATUS_USER_FONT_IMMUTABLE,
+    BORAST_STATUS_USER_FONT_ERROR,
+    BORAST_STATUS_NEGATIVE_COUNT,
+    BORAST_STATUS_INVALID_CLUSTERS,
+    BORAST_STATUS_INVALID_SLANT,
+    BORAST_STATUS_INVALID_WEIGHT,
+    BORAST_STATUS_INVALID_SIZE,
+    BORAST_STATUS_USER_FONT_NOT_IMPLEMENTED,
+
+    BORAST_STATUS_LAST_STATUS
+} borast_status_t;
 
 /**
- * cairo_fill_rule_t:
- * @CAIRO_FILL_RULE_WINDING: If the path crosses the ray from
+ * borast_fill_rule_t:
+ * @BORAST_FILL_RULE_WINDING: If the path crosses the ray from
  * left-to-right, counts +1. If the path crosses the ray
  * from right to left, counts -1. (Left and right are determined
  * from the perspective of looking along the ray from the starting
  * point.) If the total count is non-zero, the point will be filled.
- * @CAIRO_FILL_RULE_EVEN_ODD: Counts the total number of
+ * @BORAST_FILL_RULE_EVEN_ODD: Counts the total number of
  * intersections, without regard to the orientation of the contour. If
  * the total number of intersections is odd, the point will be
  * filled.
  *
- * #cairo_fill_rule_t is used to select how paths are filled. For both
+ * #borast_fill_rule_t is used to select how paths are filled. For both
  * fill rules, whether or not a point is included in the fill is
  * determined by taking a ray from that point to infinity and looking
  * at intersections with the path. The ray can be in any direction,
@@ -179,30 +179,30 @@ typedef enum _cairo_status {
  * (Note that filling is not actually implemented in this way. This
  * is just a description of the rule that is applied.)
  *
- * The default fill rule is %CAIRO_FILL_RULE_WINDING.
+ * The default fill rule is %BORAST_FILL_RULE_WINDING.
  *
  * New entries may be added in future versions.
  **/
-typedef enum _cairo_fill_rule {
-    CAIRO_FILL_RULE_WINDING,
-    CAIRO_FILL_RULE_EVEN_ODD
-} cairo_fill_rule_t;
+typedef enum _borast_fill_rule {
+    BORAST_FILL_RULE_WINDING,
+    BORAST_FILL_RULE_EVEN_ODD
+} borast_fill_rule_t;
 
 /* Region functions */
 
-typedef struct _cairo_region cairo_region_t;
+typedef struct _borast_region borast_region_t;
 
-typedef struct _cairo_rectangle_int {
+typedef struct _borast_rectangle_int {
     int x, y;
     int width, height;
-} cairo_rectangle_int_t;
+} borast_rectangle_int_t;
 
-typedef enum _cairo_region_overlap {
-    CAIRO_REGION_OVERLAP_IN,		/* completely inside region */
-    CAIRO_REGION_OVERLAP_OUT,		/* completely outside region */
-    CAIRO_REGION_OVERLAP_PART		/* partly inside region */
-} cairo_region_overlap_t;
+typedef enum _borast_region_overlap {
+    BORAST_REGION_OVERLAP_IN,		/* completely inside region */
+    BORAST_REGION_OVERLAP_OUT,		/* completely outside region */
+    BORAST_REGION_OVERLAP_PART		/* partly inside region */
+} borast_region_overlap_t;
 
-CAIRO_END_DECLS
+BORAST_END_DECLS
 
-#endif /* _CAIRO_MINIMAL_H_ */
+#endif /* _BORAST_MINIMAL_H_ */
diff --git a/src/borast/borast-traps-private.h b/src/borast/borast-traps-private.h
index ac26aee..f9a875c 100644
--- a/src/borast/borast-traps-private.h
+++ b/src/borast/borast-traps-private.h
@@ -43,19 +43,19 @@
  * existing published interfaces. cworth@cworth.org
  */
 
-#ifndef _CAIRO_TRAPS_PRIVATE_H_
-#define _CAIRO_TRAPS_PRIVATE_H_
+#ifndef _BORAST_TRAPS_PRIVATE_H_
+#define _BORAST_TRAPS_PRIVATE_H_
 
 #if HAVE_CONFIG_H
 #include "config.h"
 #endif
 
-#include "cairo-types-private.h"
+#include "borast-types-private.h"
 
-typedef struct _cairo_traps {
-    cairo_status_t status;
+typedef struct _borast_traps {
+    borast_status_t status;
 
-    const cairo_box_t *limits;
+    const borast_box_t *limits;
     int num_limits;
 
     unsigned int maybe_region : 1; /* hint: 0 implies that it cannot be */
@@ -65,86 +65,86 @@ typedef struct _cairo_traps {
 
     int num_traps;
     int traps_size;
-    cairo_trapezoid_t *traps;
-    cairo_trapezoid_t  traps_embedded[16];
-} cairo_traps_t;
+    borast_trapezoid_t *traps;
+    borast_trapezoid_t  traps_embedded[16];
+} borast_traps_t;
 
 
-/* cairo-traps.c */
-cairo_private void
-_cairo_traps_init (cairo_traps_t *traps);
+/* borast-traps.c */
+borast_private void
+_borast_traps_init (borast_traps_t *traps);
 
-cairo_private void
-_cairo_traps_limit (cairo_traps_t	*traps,
-		    const cairo_box_t	*boxes,
+borast_private void
+_borast_traps_limit (borast_traps_t	*traps,
+		    const borast_box_t	*boxes,
 		    int			 num_boxes);
 
-cairo_private cairo_status_t
-_cairo_traps_init_boxes (cairo_traps_t	    *traps,
-			 const cairo_box_t    *boxes,
+borast_private borast_status_t
+_borast_traps_init_boxes (borast_traps_t	    *traps,
+			 const borast_box_t    *boxes,
 			 int		     num_boxes);
 
-cairo_private void
-_cairo_traps_clear (cairo_traps_t *traps);
+borast_private void
+_borast_traps_clear (borast_traps_t *traps);
 
-cairo_private void
-_cairo_traps_fini (cairo_traps_t *traps);
+borast_private void
+_borast_traps_fini (borast_traps_t *traps);
 
-#define _cairo_traps_status(T) (T)->status
+#define _borast_traps_status(T) (T)->status
 
-cairo_private void
-_cairo_traps_translate (cairo_traps_t *traps, int x, int y);
+borast_private void
+_borast_traps_translate (borast_traps_t *traps, int x, int y);
 
-cairo_private cairo_status_t
-_cairo_traps_tessellate_rectangle (cairo_traps_t *traps,
-				   const cairo_point_t *top_left,
-				   const cairo_point_t *bottom_right);
+borast_private borast_status_t
+_borast_traps_tessellate_rectangle (borast_traps_t *traps,
+				   const borast_point_t *top_left,
+				   const borast_point_t *bottom_right);
 
-cairo_private void
-_cairo_traps_add_trap (cairo_traps_t *traps,
-		       cairo_fixed_t top, cairo_fixed_t bottom,
-		       cairo_line_t *left, cairo_line_t *right);
+borast_private void
+_borast_traps_add_trap (borast_traps_t *traps,
+		       borast_fixed_t top, borast_fixed_t bottom,
+		       borast_line_t *left, borast_line_t *right);
 
-cairo_private cairo_status_t
-_cairo_bentley_ottmann_tessellate_rectilinear_polygon (cairo_traps_t	 *traps,
-						       const cairo_polygon_t *polygon,
-						       cairo_fill_rule_t	  fill_rule);
+borast_private borast_status_t
+_borast_bentley_ottmann_tessellate_rectilinear_polygon (borast_traps_t	 *traps,
+						       const borast_polygon_t *polygon,
+						       borast_fill_rule_t	  fill_rule);
 
-cairo_private cairo_status_t
-_cairo_bentley_ottmann_tessellate_polygon (cairo_traps_t         *traps,
-					   const cairo_polygon_t *polygon);
+borast_private borast_status_t
+_borast_bentley_ottmann_tessellate_polygon (borast_traps_t         *traps,
+					   const borast_polygon_t *polygon);
 
-cairo_private cairo_status_t
-_cairo_bentley_ottmann_tessellate_traps (cairo_traps_t *traps,
-					 cairo_fill_rule_t fill_rule);
+borast_private borast_status_t
+_borast_bentley_ottmann_tessellate_traps (borast_traps_t *traps,
+					 borast_fill_rule_t fill_rule);
 
-cairo_private cairo_status_t
-_cairo_bentley_ottmann_tessellate_rectangular_traps (cairo_traps_t *traps,
-						     cairo_fill_rule_t fill_rule);
+borast_private borast_status_t
+_borast_bentley_ottmann_tessellate_rectangular_traps (borast_traps_t *traps,
+						     borast_fill_rule_t fill_rule);
 
-cairo_private cairo_status_t
-_cairo_bentley_ottmann_tessellate_rectilinear_traps (cairo_traps_t *traps,
-						     cairo_fill_rule_t fill_rule);
+borast_private borast_status_t
+_borast_bentley_ottmann_tessellate_rectilinear_traps (borast_traps_t *traps,
+						     borast_fill_rule_t fill_rule);
 
-cairo_private int
-_cairo_traps_contain (const cairo_traps_t *traps,
+borast_private int
+_borast_traps_contain (const borast_traps_t *traps,
 		      double x, double y);
 
-cairo_private void
-_cairo_traps_extents (const cairo_traps_t *traps,
-		      cairo_box_t         *extents);
+borast_private void
+_borast_traps_extents (const borast_traps_t *traps,
+		      borast_box_t         *extents);
 
-cairo_private cairo_int_status_t
-_cairo_traps_extract_region (cairo_traps_t  *traps,
-			     cairo_region_t **region);
+borast_private borast_int_status_t
+_borast_traps_extract_region (borast_traps_t  *traps,
+			     borast_region_t **region);
 
-cairo_private cairo_status_t
-_cairo_traps_path (const cairo_traps_t *traps,
-		   cairo_path_fixed_t  *path);
+borast_private borast_status_t
+_borast_traps_path (const borast_traps_t *traps,
+		   borast_path_fixed_t  *path);
 
-cairo_private void
-_cairo_trapezoid_array_translate_and_scale (cairo_trapezoid_t *offset_traps,
-					    cairo_trapezoid_t *src_traps,
+borast_private void
+_borast_trapezoid_array_translate_and_scale (borast_trapezoid_t *offset_traps,
+					    borast_trapezoid_t *src_traps,
 					    int num_traps,
 					    double tx, double ty,
 					    double sx, double sy);
diff --git a/src/borast/borast-traps.c b/src/borast/borast-traps.c
index 089f3c6..326907a 100644
--- a/src/borast/borast-traps.c
+++ b/src/borast/borast-traps.c
@@ -37,21 +37,21 @@
  * 2002-07-15: Converted from XRenderCompositeDoublePoly to #cairo_trap_t. Carl D. Worth
  */
 
-#include "cairoint-minimal.h"
-#include "cairo-malloc-private.h"
-#include "cairo-traps-private.h"
-#include "cairo-fixed-private.h"
+#include "borastint-minimal.h"
+#include "borast-malloc-private.h"
+#include "borast-traps-private.h"
+#include "borast-fixed-private.h"
 
-#define _cairo_error(x) (x)
+#define _borast_error(x) (x)
 
 /* private functions */
 
 void
-_cairo_traps_init (cairo_traps_t *traps)
+_borast_traps_init (borast_traps_t *traps)
 {
-    VG (VALGRIND_MAKE_MEM_UNDEFINED (traps, sizeof (cairo_traps_t)));
+    VG (VALGRIND_MAKE_MEM_UNDEFINED (traps, sizeof (borast_traps_t)));
 
-    traps->status = CAIRO_STATUS_SUCCESS;
+    traps->status = BORAST_STATUS_SUCCESS;
 
     traps->maybe_region = 1;
     traps->is_rectilinear = 0;
@@ -67,8 +67,8 @@ _cairo_traps_init (cairo_traps_t *traps)
 }
 
 void
-_cairo_traps_limit (cairo_traps_t	*traps,
-		    const cairo_box_t	*limits,
+_borast_traps_limit (borast_traps_t	*traps,
+		    const borast_box_t	*limits,
 		    int			 num_limits)
 {
     traps->limits = limits;
@@ -76,9 +76,9 @@ _cairo_traps_limit (cairo_traps_t	*traps,
 }
 
 void
-_cairo_traps_clear (cairo_traps_t *traps)
+_borast_traps_clear (borast_traps_t *traps)
 {
-    traps->status = CAIRO_STATUS_SUCCESS;
+    traps->status = BORAST_STATUS_SUCCESS;
 
     traps->maybe_region = 1;
     traps->is_rectilinear = 0;
@@ -89,32 +89,32 @@ _cairo_traps_clear (cairo_traps_t *traps)
 }
 
 void
-_cairo_traps_fini (cairo_traps_t *traps)
+_borast_traps_fini (borast_traps_t *traps)
 {
     if (traps->traps != traps->traps_embedded)
 	free (traps->traps);
 
-    VG (VALGRIND_MAKE_MEM_NOACCESS (traps, sizeof (cairo_traps_t)));
+    VG (VALGRIND_MAKE_MEM_NOACCESS (traps, sizeof (borast_traps_t)));
 }
 
 /* make room for at least one more trap */
-static cairo_bool_t
-_cairo_traps_grow (cairo_traps_t *traps)
+static borast_bool_t
+_borast_traps_grow (borast_traps_t *traps)
 {
-    cairo_trapezoid_t *new_traps;
+    borast_trapezoid_t *new_traps;
     int new_size = 4 * traps->traps_size;
 
     if (traps->traps == traps->traps_embedded) {
-	new_traps = _cairo_malloc_ab (new_size, sizeof (cairo_trapezoid_t));
+	new_traps = _borast_malloc_ab (new_size, sizeof (borast_trapezoid_t));
 	if (new_traps != NULL)
 	    memcpy (new_traps, traps->traps, sizeof (traps->traps_embedded));
     } else {
-	new_traps = _cairo_realloc_ab (traps->traps,
-	                               new_size, sizeof (cairo_trapezoid_t));
+	new_traps = _borast_realloc_ab (traps->traps,
+	                               new_size, sizeof (borast_trapezoid_t));
     }
 
     if (unlikely (new_traps == NULL)) {
-	traps->status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
+	traps->status = _borast_error (BORAST_STATUS_NO_MEMORY);
 	return FALSE;
     }
 
@@ -124,14 +124,14 @@ _cairo_traps_grow (cairo_traps_t *traps)
 }
 
 void
-_cairo_traps_add_trap (cairo_traps_t *traps,
-		       cairo_fixed_t top, cairo_fixed_t bottom,
-		       cairo_line_t *left, cairo_line_t *right)
+_borast_traps_add_trap (borast_traps_t *traps,
+		       borast_fixed_t top, borast_fixed_t bottom,
+		       borast_line_t *left, borast_line_t *right)
 {
-    cairo_trapezoid_t *trap;
+    borast_trapezoid_t *trap;
 
     if (unlikely (traps->num_traps == traps->traps_size)) {
-	if (unlikely (! _cairo_traps_grow (traps)))
+	if (unlikely (! _borast_traps_grow (traps)))
 	    return;
     }
 
@@ -143,27 +143,27 @@ _cairo_traps_add_trap (cairo_traps_t *traps,
 }
 
 /**
- * _cairo_traps_init_box:
- * @traps: a #cairo_traps_t
+ * _borast_traps_init_box:
+ * @traps: a #borast_traps_t
  * @box: an array box that will each be converted to a single trapezoid
  *       to store in @traps.
  *
- * Initializes a #cairo_traps_t to contain an array of rectangular
+ * Initializes a #borast_traps_t to contain an array of rectangular
  * trapezoids.
  **/
-cairo_status_t
-_cairo_traps_init_boxes (cairo_traps_t	    *traps,
-		         const cairo_box_t  *boxes,
+borast_status_t
+_borast_traps_init_boxes (borast_traps_t	    *traps,
+		         const borast_box_t  *boxes,
 			 int		     num_boxes)
 {
-    cairo_trapezoid_t *trap;
+    borast_trapezoid_t *trap;
 
-    _cairo_traps_init (traps);
+    _borast_traps_init (traps);
 
     while (traps->traps_size < num_boxes) {
-	if (unlikely (! _cairo_traps_grow (traps))) {
-	    _cairo_traps_fini (traps);
-	    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+	if (unlikely (! _borast_traps_grow (traps))) {
+	    _borast_traps_fini (traps);
+	    return _borast_error (BORAST_STATUS_NO_MEMORY);
 	}
     }
 
@@ -185,32 +185,32 @@ _cairo_traps_init_boxes (cairo_traps_t	    *traps,
 	trap->right.p2   = boxes->p2;
 
 	if (traps->maybe_region) {
-	    traps->maybe_region  = _cairo_fixed_is_integer (boxes->p1.x) &&
-		                   _cairo_fixed_is_integer (boxes->p1.y) &&
-		                   _cairo_fixed_is_integer (boxes->p2.x) &&
-		                   _cairo_fixed_is_integer (boxes->p2.y);
+	    traps->maybe_region  = _borast_fixed_is_integer (boxes->p1.x) &&
+		                   _borast_fixed_is_integer (boxes->p1.y) &&
+		                   _borast_fixed_is_integer (boxes->p2.x) &&
+		                   _borast_fixed_is_integer (boxes->p2.y);
 	}
 
 	trap++, boxes++;
     }
 
-    return CAIRO_STATUS_SUCCESS;
+    return BORAST_STATUS_SUCCESS;
 }
 
-cairo_status_t
-_cairo_traps_tessellate_rectangle (cairo_traps_t *traps,
-				   const cairo_point_t *top_left,
-				   const cairo_point_t *bottom_right)
+borast_status_t
+_borast_traps_tessellate_rectangle (borast_traps_t *traps,
+				   const borast_point_t *top_left,
+				   const borast_point_t *bottom_right)
 {
-    cairo_line_t left;
-    cairo_line_t right;
-    cairo_fixed_t top, bottom;
+    borast_line_t left;
+    borast_line_t right;
+    borast_fixed_t top, bottom;
 
     if (top_left->y == bottom_right->y)
-	return CAIRO_STATUS_SUCCESS;
+	return BORAST_STATUS_SUCCESS;
 
     if (top_left->x == bottom_right->x)
-	return CAIRO_STATUS_SUCCESS;
+	return BORAST_STATUS_SUCCESS;
 
      left.p1.x =  left.p2.x = top_left->x;
      left.p1.y = right.p1.y = top_left->y;
@@ -221,7 +221,7 @@ _cairo_traps_tessellate_rectangle (cairo_traps_t *traps,
      bottom = bottom_right->y;
 
     if (traps->num_limits) {
-	cairo_bool_t reversed;
+	borast_bool_t reversed;
 	int n;
 
 	/* support counter-clockwise winding for rectangular tessellation */
@@ -232,9 +232,9 @@ _cairo_traps_tessellate_rectangle (cairo_traps_t *traps,
 	}
 
 	for (n = 0; n < traps->num_limits; n++) {
-	    const cairo_box_t *limits = &traps->limits[n];
-	    cairo_line_t _left, _right;
-	    cairo_fixed_t _top, _bottom;
+	    const borast_box_t *limits = &traps->limits[n];
+	    borast_line_t _left, _right;
+	    borast_fixed_t _top, _bottom;
 
 	    if (top >= limits->p2.y)
 		continue;
@@ -280,31 +280,31 @@ _cairo_traps_tessellate_rectangle (cairo_traps_t *traps,
 		continue;
 
 	    if (reversed)
-		_cairo_traps_add_trap (traps, _top, _bottom, &_right, &_left);
+		_borast_traps_add_trap (traps, _top, _bottom, &_right, &_left);
 	    else
-		_cairo_traps_add_trap (traps, _top, _bottom, &_left, &_right);
+		_borast_traps_add_trap (traps, _top, _bottom, &_left, &_right);
 	}
     } else {
-	_cairo_traps_add_trap (traps, top, bottom, &left, &right);
+	_borast_traps_add_trap (traps, top, bottom, &left, &right);
     }
 
     return traps->status;
 }
 
 void
-_cairo_traps_translate (cairo_traps_t *traps, int x, int y)
+_borast_traps_translate (borast_traps_t *traps, int x, int y)
 {
-    cairo_fixed_t xoff, yoff;
-    cairo_trapezoid_t *t;
+    borast_fixed_t xoff, yoff;
+    borast_trapezoid_t *t;
     int i;
 
-    /* Ugh. The cairo_composite/(Render) interface doesn't allow
+    /* Ugh. The borast_composite/(Render) interface doesn't allow
        an offset for the trapezoids. Need to manually shift all
        the coordinates to align with the offset origin of the
        intermediate surface. */
 
-    xoff = _cairo_fixed_from_int (x);
-    yoff = _cairo_fixed_from_int (y);
+    xoff = _borast_fixed_from_int (x);
+    yoff = _borast_fixed_from_int (y);
 
     for (i = 0, t = traps->traps; i < traps->num_traps; i++, t++) {
 	t->top += yoff;
@@ -321,15 +321,15 @@ _cairo_traps_translate (cairo_traps_t *traps, int x, int y)
 }
 
 void
-_cairo_trapezoid_array_translate_and_scale (cairo_trapezoid_t *offset_traps,
-                                            cairo_trapezoid_t *src_traps,
+_borast_trapezoid_array_translate_and_scale (borast_trapezoid_t *offset_traps,
+                                            borast_trapezoid_t *src_traps,
                                             int num_traps,
                                             double tx, double ty,
                                             double sx, double sy)
 {
     int i;
-    cairo_fixed_t xoff = _cairo_fixed_from_double (tx);
-    cairo_fixed_t yoff = _cairo_fixed_from_double (ty);
+    borast_fixed_t xoff = _borast_fixed_from_double (tx);
+    borast_fixed_t yoff = _borast_fixed_from_double (ty);
 
     if (sx == 1.0 && sy == 1.0) {
         for (i = 0; i < num_traps; i++) {
@@ -345,34 +345,34 @@ _cairo_trapezoid_array_translate_and_scale (cairo_trapezoid_t *offset_traps,
             offset_traps[i].right.p2.y = src_traps[i].right.p2.y + yoff;
         }
     } else {
-        cairo_fixed_t xsc = _cairo_fixed_from_double (sx);
-        cairo_fixed_t ysc = _cairo_fixed_from_double (sy);
+        borast_fixed_t xsc = _borast_fixed_from_double (sx);
+        borast_fixed_t ysc = _borast_fixed_from_double (sy);
 
         for (i = 0; i < num_traps; i++) {
-            offset_traps[i].top = _cairo_fixed_mul (src_traps[i].top + yoff, ysc);
-            offset_traps[i].bottom = _cairo_fixed_mul (src_traps[i].bottom + yoff, ysc);
-            offset_traps[i].left.p1.x = _cairo_fixed_mul (src_traps[i].left.p1.x + xoff, xsc);
-            offset_traps[i].left.p1.y = _cairo_fixed_mul (src_traps[i].left.p1.y + yoff, ysc);
-            offset_traps[i].left.p2.x = _cairo_fixed_mul (src_traps[i].left.p2.x + xoff, xsc);
-            offset_traps[i].left.p2.y = _cairo_fixed_mul (src_traps[i].left.p2.y + yoff, ysc);
-            offset_traps[i].right.p1.x = _cairo_fixed_mul (src_traps[i].right.p1.x + xoff, xsc);
-            offset_traps[i].right.p1.y = _cairo_fixed_mul (src_traps[i].right.p1.y + yoff, ysc);
-            offset_traps[i].right.p2.x = _cairo_fixed_mul (src_traps[i].right.p2.x + xoff, xsc);
-            offset_traps[i].right.p2.y = _cairo_fixed_mul (src_traps[i].right.p2.y + yoff, ysc);
+            offset_traps[i].top = _borast_fixed_mul (src_traps[i].top + yoff, ysc);
+            offset_traps[i].bottom = _borast_fixed_mul (src_traps[i].bottom + yoff, ysc);
+            offset_traps[i].left.p1.x = _borast_fixed_mul (src_traps[i].left.p1.x + xoff, xsc);
+            offset_traps[i].left.p1.y = _borast_fixed_mul (src_traps[i].left.p1.y + yoff, ysc);
+            offset_traps[i].left.p2.x = _borast_fixed_mul (src_traps[i].left.p2.x + xoff, xsc);
+            offset_traps[i].left.p2.y = _borast_fixed_mul (src_traps[i].left.p2.y + yoff, ysc);
+            offset_traps[i].right.p1.x = _borast_fixed_mul (src_traps[i].right.p1.x + xoff, xsc);
+            offset_traps[i].right.p1.y = _borast_fixed_mul (src_traps[i].right.p1.y + yoff, ysc);
+            offset_traps[i].right.p2.x = _borast_fixed_mul (src_traps[i].right.p2.x + xoff, xsc);
+            offset_traps[i].right.p2.y = _borast_fixed_mul (src_traps[i].right.p2.y + yoff, ysc);
         }
     }
 }
 
-static cairo_fixed_t
-_line_compute_intersection_x_for_y (const cairo_line_t *line,
-				    cairo_fixed_t y)
+static borast_fixed_t
+_line_compute_intersection_x_for_y (const borast_line_t *line,
+				    borast_fixed_t y)
 {
-    return _cairo_edge_compute_intersection_x_for_y (&line->p1, &line->p2, y);
+    return _borast_edge_compute_intersection_x_for_y (&line->p1, &line->p2, y);
 }
 
 void
-_cairo_traps_extents (const cairo_traps_t *traps,
-		      cairo_box_t *extents)
+_borast_traps_extents (const borast_traps_t *traps,
+		      borast_box_t *extents)
 {
     int i;
 
@@ -386,7 +386,7 @@ _cairo_traps_extents (const cairo_traps_t *traps,
     extents->p2.x = extents->p2.y = INT32_MIN;
 
     for (i = 0; i < traps->num_traps; i++) {
-	const cairo_trapezoid_t *trap =  &traps->traps[i];
+	const borast_trapezoid_t *trap =  &traps->traps[i];
 
 	if (trap->top < extents->p1.y)
 	    extents->p1.y = trap->top;
@@ -394,7 +394,7 @@ _cairo_traps_extents (const cairo_traps_t *traps,
 	    extents->p2.y = trap->bottom;
 
 	if (trap->left.p1.x < extents->p1.x) {
-	    cairo_fixed_t x = trap->left.p1.x;
+	    borast_fixed_t x = trap->left.p1.x;
 	    if (trap->top != trap->left.p1.y) {
 		x = _line_compute_intersection_x_for_y (&trap->left,
 							trap->top);
@@ -404,7 +404,7 @@ _cairo_traps_extents (const cairo_traps_t *traps,
 		extents->p1.x = x;
 	}
 	if (trap->left.p2.x < extents->p1.x) {
-	    cairo_fixed_t x = trap->left.p2.x;
+	    borast_fixed_t x = trap->left.p2.x;
 	    if (trap->bottom != trap->left.p2.y) {
 		x = _line_compute_intersection_x_for_y (&trap->left,
 							trap->bottom);
@@ -415,7 +415,7 @@ _cairo_traps_extents (const cairo_traps_t *traps,
 	}
 
 	if (trap->right.p1.x > extents->p2.x) {
-	    cairo_fixed_t x = trap->right.p1.x;
+	    borast_fixed_t x = trap->right.p1.x;
 	    if (trap->top != trap->right.p1.y) {
 		x = _line_compute_intersection_x_for_y (&trap->right,
 							trap->top);
@@ -425,7 +425,7 @@ _cairo_traps_extents (const cairo_traps_t *traps,
 		extents->p2.x = x;
 	}
 	if (trap->right.p2.x > extents->p2.x) {
-	    cairo_fixed_t x = trap->right.p2.x;
+	    borast_fixed_t x = trap->right.p2.x;
 	    if (trap->bottom != trap->right.p2.y) {
 		x = _line_compute_intersection_x_for_y (&trap->right,
 							trap->bottom);
diff --git a/src/borast/borast-types-private.h b/src/borast/borast-types-private.h
index 44c29b9..69a2ea5 100644
--- a/src/borast/borast-types-private.h
+++ b/src/borast/borast-types-private.h
@@ -36,43 +36,43 @@
  *	Carl D. Worth <cworth@cworth.org>
  */
 
-#ifndef CAIRO_TYPES_PRIVATE_H
-#define CAIRO_TYPES_PRIVATE_H
+#ifndef BORAST_TYPES_PRIVATE_H
+#define BORAST_TYPES_PRIVATE_H
 
-#include "cairo-minimal.h"
-#include "cairo-fixed-type-private.h"
-#include "cairo-compiler-private.h"
+#include "borast-minimal.h"
+#include "borast-fixed-type-private.h"
+#include "borast-compiler-private.h"
 
-typedef struct _cairo_array cairo_array_t;
-typedef struct _cairo_backend cairo_backend_t;
-typedef struct _cairo_cache cairo_cache_t;
-typedef struct _cairo_clip cairo_clip_t;
-typedef struct _cairo_clip_path cairo_clip_path_t;
-typedef struct _cairo_gstate cairo_gstate_t;
-typedef struct _cairo_hash_entry cairo_hash_entry_t;
-typedef struct _cairo_hash_table cairo_hash_table_t;
-typedef struct _cairo_path_fixed cairo_path_fixed_t;
+typedef struct _borast_array borast_array_t;
+typedef struct _borast_backend borast_backend_t;
+typedef struct _borast_cache borast_cache_t;
+typedef struct _borast_clip borast_clip_t;
+typedef struct _borast_clip_path borast_clip_path_t;
+typedef struct _borast_gstate borast_gstate_t;
+typedef struct _borast_hash_entry borast_hash_entry_t;
+typedef struct _borast_hash_table borast_hash_table_t;
+typedef struct _borast_path_fixed borast_path_fixed_t;
 
-typedef cairo_array_t cairo_user_data_array_t;
+typedef borast_array_t borast_user_data_array_t;
 
 /**
- * cairo_hash_entry_t:
+ * borast_hash_entry_t:
  *
- * A #cairo_hash_entry_t contains both a key and a value for
- * #cairo_hash_table_t. User-derived types for #cairo_hash_entry_t must
+ * A #borast_hash_entry_t contains both a key and a value for
+ * #borast_hash_table_t. User-derived types for #borast_hash_entry_t must
  * be type-compatible with this structure (eg. they must have an
  * unsigned long as the first parameter. The easiest way to get this
  * is to use:
  *
  * 	typedef _my_entry {
- *	    cairo_hash_entry_t base;
+ *	    borast_hash_entry_t base;
  *	    ... Remainder of key and value fields here ..
  *	} my_entry_t;
  *
  * which then allows a pointer to my_entry_t to be passed to any of
- * the #cairo_hash_table_t functions as follows without requiring a cast:
+ * the #borast_hash_table_t functions as follows without requiring a cast:
  *
- *	_cairo_hash_table_insert (hash_table, &my_entry->base);
+ *	_borast_hash_table_insert (hash_table, &my_entry->base);
  *
  * IMPORTANT: The caller is reponsible for initializing
  * my_entry->base.hash with a hash code derived from the key. The
@@ -84,70 +84,70 @@ typedef cairo_array_t cairo_user_data_array_t;
  * Which parts of the entry make up the "key" and which part make up
  * the value are entirely up to the caller, (as determined by the
  * computation going into base.hash as well as the keys_equal
- * function). A few of the #cairo_hash_table_t functions accept an entry
+ * function). A few of the #borast_hash_table_t functions accept an entry
  * which will be used exclusively as a "key", (indicated by a
  * parameter name of key). In these cases, the value-related fields of
  * the entry need not be initialized if so desired.
  **/
-struct _cairo_hash_entry {
+struct _borast_hash_entry {
     unsigned long hash;
 };
 
-struct _cairo_array {
+struct _borast_array {
     unsigned int size;
     unsigned int num_elements;
     unsigned int element_size;
     char **elements;
 
-    cairo_bool_t is_snapshot;
+    borast_bool_t is_snapshot;
 };
 
 /* Sure wish C had a real enum type so that this would be distinct
- * from #cairo_status_t. Oh well, without that, I'll use this bogus 100
+ * from #borast_status_t. Oh well, without that, I'll use this bogus 100
  * offset.  We want to keep it fit in int8_t as the compiler may choose
- * that for #cairo_status_t */
-typedef enum _cairo_int_status {
-    CAIRO_INT_STATUS_UNSUPPORTED = 100,
-    CAIRO_INT_STATUS_DEGENERATE,
-    CAIRO_INT_STATUS_NOTHING_TO_DO,
-    CAIRO_INT_STATUS_FLATTEN_TRANSPARENCY,
-    CAIRO_INT_STATUS_IMAGE_FALLBACK,
-    CAIRO_INT_STATUS_ANALYZE_RECORDING_SURFACE_PATTERN,
-
-    CAIRO_INT_STATUS_LAST_STATUS
-} cairo_int_status_t;
-
-typedef struct _cairo_slope {
-    cairo_fixed_t dx;
-    cairo_fixed_t dy;
-} cairo_slope_t, cairo_distance_t;
-
-typedef struct _cairo_point_double {
+ * that for #borast_status_t */
+typedef enum _borast_int_status {
+    BORAST_INT_STATUS_UNSUPPORTED = 100,
+    BORAST_INT_STATUS_DEGENERATE,
+    BORAST_INT_STATUS_NOTHING_TO_DO,
+    BORAST_INT_STATUS_FLATTEN_TRANSPARENCY,
+    BORAST_INT_STATUS_IMAGE_FALLBACK,
+    BORAST_INT_STATUS_ANALYZE_RECORDING_SURFACE_PATTERN,
+
+    BORAST_INT_STATUS_LAST_STATUS
+} borast_int_status_t;
+
+typedef struct _borast_slope {
+    borast_fixed_t dx;
+    borast_fixed_t dy;
+} borast_slope_t, borast_distance_t;
+
+typedef struct _borast_point_double {
     double x;
     double y;
-} cairo_point_double_t;
+} borast_point_double_t;
 
-typedef struct _cairo_distance_double {
+typedef struct _borast_distance_double {
     double dx;
     double dy;
-} cairo_distance_double_t;
+} borast_distance_double_t;
 
-typedef struct _cairo_line {
-    cairo_point_t p1;
-    cairo_point_t p2;
-} cairo_line_t, cairo_box_t;
+typedef struct _borast_line {
+    borast_point_t p1;
+    borast_point_t p2;
+} borast_line_t, borast_box_t;
 
-typedef struct _cairo_trapezoid {
-    cairo_fixed_t top, bottom;
-    cairo_line_t left, right;
-} cairo_trapezoid_t;
+typedef struct _borast_trapezoid {
+    borast_fixed_t top, bottom;
+    borast_line_t left, right;
+} borast_trapezoid_t;
 
-typedef struct _cairo_point_int {
+typedef struct _borast_point_int {
     int x, y;
-} cairo_point_int_t;
+} borast_point_int_t;
 
-#define CAIRO_RECT_INT_MIN (INT_MIN >> CAIRO_FIXED_FRAC_BITS)
-#define CAIRO_RECT_INT_MAX (INT_MAX >> CAIRO_FIXED_FRAC_BITS)
+#define BORAST_RECT_INT_MIN (INT_MIN >> BORAST_FIXED_FRAC_BITS)
+#define BORAST_RECT_INT_MAX (INT_MAX >> BORAST_FIXED_FRAC_BITS)
 
 /* Rectangles that take part in a composite operation.
  *
@@ -163,44 +163,44 @@ typedef struct _cairo_point_int {
  * all combine together to form the result at (i,j)+(dst.x,dst.y),
  * for i,j ranging in [0,width) and [0,height) respectively.
  */
-typedef struct _cairo_composite_rectangles {
-        cairo_point_int_t src;
-        cairo_point_int_t mask;
-        cairo_point_int_t clip;
-        cairo_point_int_t dst;
+typedef struct _borast_composite_rectangles {
+        borast_point_int_t src;
+        borast_point_int_t mask;
+        borast_point_int_t clip;
+        borast_point_int_t dst;
         int width;
         int height;
-} cairo_composite_rectangles_t;
+} borast_composite_rectangles_t;
 
-typedef struct _cairo_edge {
-    cairo_line_t line;
+typedef struct _borast_edge {
+    borast_line_t line;
     int top, bottom;
     int dir;
-} cairo_edge_t;
+} borast_edge_t;
 
-typedef struct _cairo_polygon {
-    cairo_status_t status;
+typedef struct _borast_polygon {
+    borast_status_t status;
 
-    cairo_point_t first_point;
-    cairo_point_t last_point;
-    cairo_point_t current_point;
-    cairo_slope_t current_edge;
-    cairo_bool_t has_current_point;
-    cairo_bool_t has_current_edge;
+    borast_point_t first_point;
+    borast_point_t last_point;
+    borast_point_t current_point;
+    borast_slope_t current_edge;
+    borast_bool_t has_current_point;
+    borast_bool_t has_current_edge;
 
-    cairo_box_t extents;
-    cairo_box_t limit;
-    const cairo_box_t *limits;
+    borast_box_t extents;
+    borast_box_t limit;
+    const borast_box_t *limits;
     int num_limits;
 
     int num_edges;
     int edges_size;
-    cairo_edge_t *edges;
-    cairo_edge_t  edges_embedded[32];
-} cairo_polygon_t;
+    borast_edge_t *edges;
+    borast_edge_t  edges_embedded[32];
+} borast_polygon_t;
 
-typedef cairo_warn cairo_status_t
-(*cairo_spline_add_point_func_t) (void *closure,
-				  const cairo_point_t *point);
+typedef borast_warn borast_status_t
+(*borast_spline_add_point_func_t) (void *closure,
+				  const borast_point_t *point);
 
-#endif /* CAIRO_TYPES_PRIVATE_H */
+#endif /* BORAST_TYPES_PRIVATE_H */
diff --git a/src/borast/borast-wideint-private.h b/src/borast/borast-wideint-private.h
index 303dab1..b4a1662 100644
--- a/src/borast/borast-wideint-private.h
+++ b/src/borast/borast-wideint-private.h
@@ -34,12 +34,12 @@
  *
  */
 
-#ifndef CAIRO_WIDEINT_H
-#define CAIRO_WIDEINT_H
+#ifndef BORAST_WIDEINT_H
+#define BORAST_WIDEINT_H
 
-#include "cairo-wideint-type-private.h"
+#include "borast-wideint-type-private.h"
 
-#include "cairo-compiler-private.h"
+#include "borast-compiler-private.h"
 
 /*
  * 64-bit datatypes.  Two separate implementations, one using
@@ -47,161 +47,161 @@
  * as a pair of 32-bit ints
  */
 
-#define I cairo_private cairo_const
+#define I borast_private borast_const
 
 #if !HAVE_UINT64_T
 
-cairo_uquorem64_t I
-_cairo_uint64_divrem (cairo_uint64_t num, cairo_uint64_t den);
-
-cairo_uint64_t I	_cairo_uint32_to_uint64 (uint32_t i);
-#define			_cairo_uint64_to_uint32(a)  ((a).lo)
-cairo_uint64_t I	_cairo_uint64_add (cairo_uint64_t a, cairo_uint64_t b);
-cairo_uint64_t I	_cairo_uint64_sub (cairo_uint64_t a, cairo_uint64_t b);
-cairo_uint64_t I	_cairo_uint64_mul (cairo_uint64_t a, cairo_uint64_t b);
-cairo_uint64_t I	_cairo_uint32x32_64_mul (uint32_t a, uint32_t b);
-cairo_uint64_t I	_cairo_uint64_lsl (cairo_uint64_t a, int shift);
-cairo_uint64_t I	_cairo_uint64_rsl (cairo_uint64_t a, int shift);
-cairo_uint64_t I	_cairo_uint64_rsa (cairo_uint64_t a, int shift);
-int	       I	_cairo_uint64_lt (cairo_uint64_t a, cairo_uint64_t b);
-int	       I	_cairo_uint64_cmp (cairo_uint64_t a, cairo_uint64_t b);
-int	       I	_cairo_uint64_eq (cairo_uint64_t a, cairo_uint64_t b);
-cairo_uint64_t I	_cairo_uint64_negate (cairo_uint64_t a);
-#define			_cairo_uint64_is_zero(a) ((a).hi == 0 && (a).lo == 0)
-#define			_cairo_uint64_negative(a)   (((int32_t) ((a).hi)) < 0)
-cairo_uint64_t I	_cairo_uint64_not (cairo_uint64_t a);
-
-#define			_cairo_uint64_to_int64(i)   (i)
-#define			_cairo_int64_to_uint64(i)   (i)
-
-cairo_int64_t  I	_cairo_int32_to_int64(int32_t i);
-#define			_cairo_int64_to_int32(a)    ((int32_t) _cairo_uint64_to_uint32(a))
-#define			_cairo_int64_add(a,b)	    _cairo_uint64_add (a,b)
-#define			_cairo_int64_sub(a,b)	    _cairo_uint64_sub (a,b)
-#define			_cairo_int64_mul(a,b)	    _cairo_uint64_mul (a,b)
-cairo_int64_t  I	_cairo_int32x32_64_mul (int32_t a, int32_t b);
-int	       I	_cairo_int64_lt (cairo_int64_t a, cairo_int64_t b);
-int	       I	_cairo_int64_cmp (cairo_int64_t a, cairo_int64_t b);
-#define			_cairo_int64_is_zero(a)	    _cairo_uint64_is_zero (a)
-#define			_cairo_int64_eq(a,b)	    _cairo_uint64_eq (a,b)
-#define			_cairo_int64_lsl(a,b)	    _cairo_uint64_lsl (a,b)
-#define			_cairo_int64_rsl(a,b)	    _cairo_uint64_rsl (a,b)
-#define			_cairo_int64_rsa(a,b)	    _cairo_uint64_rsa (a,b)
-#define			_cairo_int64_negate(a)	    _cairo_uint64_negate(a)
-#define			_cairo_int64_negative(a)    (((int32_t) ((a).hi)) < 0)
-#define			_cairo_int64_not(a)	    _cairo_uint64_not(a)
+borast_uquorem64_t I
+_borast_uint64_divrem (borast_uint64_t num, borast_uint64_t den);
+
+borast_uint64_t I	_borast_uint32_to_uint64 (uint32_t i);
+#define			_borast_uint64_to_uint32(a)  ((a).lo)
+borast_uint64_t I	_borast_uint64_add (borast_uint64_t a, borast_uint64_t b);
+borast_uint64_t I	_borast_uint64_sub (borast_uint64_t a, borast_uint64_t b);
+borast_uint64_t I	_borast_uint64_mul (borast_uint64_t a, borast_uint64_t b);
+borast_uint64_t I	_borast_uint32x32_64_mul (uint32_t a, uint32_t b);
+borast_uint64_t I	_borast_uint64_lsl (borast_uint64_t a, int shift);
+borast_uint64_t I	_borast_uint64_rsl (borast_uint64_t a, int shift);
+borast_uint64_t I	_borast_uint64_rsa (borast_uint64_t a, int shift);
+int	       I	_borast_uint64_lt (borast_uint64_t a, borast_uint64_t b);
+int	       I	_borast_uint64_cmp (borast_uint64_t a, borast_uint64_t b);
+int	       I	_borast_uint64_eq (borast_uint64_t a, borast_uint64_t b);
+borast_uint64_t I	_borast_uint64_negate (borast_uint64_t a);
+#define			_borast_uint64_is_zero(a) ((a).hi == 0 && (a).lo == 0)
+#define			_borast_uint64_negative(a)   (((int32_t) ((a).hi)) < 0)
+borast_uint64_t I	_borast_uint64_not (borast_uint64_t a);
+
+#define			_borast_uint64_to_int64(i)   (i)
+#define			_borast_int64_to_uint64(i)   (i)
+
+borast_int64_t  I	_borast_int32_to_int64(int32_t i);
+#define			_borast_int64_to_int32(a)    ((int32_t) _borast_uint64_to_uint32(a))
+#define			_borast_int64_add(a,b)	    _borast_uint64_add (a,b)
+#define			_borast_int64_sub(a,b)	    _borast_uint64_sub (a,b)
+#define			_borast_int64_mul(a,b)	    _borast_uint64_mul (a,b)
+borast_int64_t  I	_borast_int32x32_64_mul (int32_t a, int32_t b);
+int	       I	_borast_int64_lt (borast_int64_t a, borast_int64_t b);
+int	       I	_borast_int64_cmp (borast_int64_t a, borast_int64_t b);
+#define			_borast_int64_is_zero(a)	    _borast_uint64_is_zero (a)
+#define			_borast_int64_eq(a,b)	    _borast_uint64_eq (a,b)
+#define			_borast_int64_lsl(a,b)	    _borast_uint64_lsl (a,b)
+#define			_borast_int64_rsl(a,b)	    _borast_uint64_rsl (a,b)
+#define			_borast_int64_rsa(a,b)	    _borast_uint64_rsa (a,b)
+#define			_borast_int64_negate(a)	    _borast_uint64_negate(a)
+#define			_borast_int64_negative(a)    (((int32_t) ((a).hi)) < 0)
+#define			_borast_int64_not(a)	    _borast_uint64_not(a)
 
 #else
 
-static inline cairo_uquorem64_t
-_cairo_uint64_divrem (cairo_uint64_t num, cairo_uint64_t den)
+static inline borast_uquorem64_t
+_borast_uint64_divrem (borast_uint64_t num, borast_uint64_t den)
 {
-    cairo_uquorem64_t	qr;
+    borast_uquorem64_t	qr;
 
     qr.quo = num / den;
     qr.rem = num % den;
     return qr;
 }
 
-#define			_cairo_uint32_to_uint64(i)  ((uint64_t) (i))
-#define			_cairo_uint64_to_uint32(i)  ((uint32_t) (i))
-#define			_cairo_uint64_add(a,b)	    ((a) + (b))
-#define			_cairo_uint64_sub(a,b)	    ((a) - (b))
-#define			_cairo_uint64_mul(a,b)	    ((a) * (b))
-#define			_cairo_uint32x32_64_mul(a,b)	((uint64_t) (a) * (b))
-#define			_cairo_uint64_lsl(a,b)	    ((a) << (b))
-#define			_cairo_uint64_rsl(a,b)	    ((uint64_t) (a) >> (b))
-#define			_cairo_uint64_rsa(a,b)	    ((uint64_t) ((int64_t) (a) >> (b)))
-#define			_cairo_uint64_lt(a,b)	    ((a) < (b))
-#define                 _cairo_uint64_cmp(a,b)       ((a) == (b) ? 0 : (a) < (b) ? -1 : 1)
-#define			_cairo_uint64_is_zero(a)    ((a) == 0)
-#define			_cairo_uint64_eq(a,b)	    ((a) == (b))
-#define			_cairo_uint64_negate(a)	    ((uint64_t) -((int64_t) (a)))
-#define			_cairo_uint64_negative(a)   ((int64_t) (a) < 0)
-#define			_cairo_uint64_not(a)	    (~(a))
-
-#define			_cairo_uint64_to_int64(i)   ((int64_t) (i))
-#define			_cairo_int64_to_uint64(i)   ((uint64_t) (i))
-
-#define			_cairo_int32_to_int64(i)    ((int64_t) (i))
-#define			_cairo_int64_to_int32(i)    ((int32_t) (i))
-#define			_cairo_int64_add(a,b)	    ((a) + (b))
-#define			_cairo_int64_sub(a,b)	    ((a) - (b))
-#define			_cairo_int64_mul(a,b)	    ((a) * (b))
-#define			_cairo_int32x32_64_mul(a,b) ((int64_t) (a) * (b))
-#define			_cairo_int64_lt(a,b)	    ((a) < (b))
-#define                 _cairo_int64_cmp(a,b)       ((a) == (b) ? 0 : (a) < (b) ? -1 : 1)
-#define			_cairo_int64_is_zero(a)     ((a) == 0)
-#define			_cairo_int64_eq(a,b)	    ((a) == (b))
-#define			_cairo_int64_lsl(a,b)	    ((a) << (b))
-#define			_cairo_int64_rsl(a,b)	    ((int64_t) ((uint64_t) (a) >> (b)))
-#define			_cairo_int64_rsa(a,b)	    ((int64_t) (a) >> (b))
-#define			_cairo_int64_negate(a)	    (-(a))
-#define			_cairo_int64_negative(a)    ((a) < 0)
-#define			_cairo_int64_not(a)	    (~(a))
+#define			_borast_uint32_to_uint64(i)  ((uint64_t) (i))
+#define			_borast_uint64_to_uint32(i)  ((uint32_t) (i))
+#define			_borast_uint64_add(a,b)	    ((a) + (b))
+#define			_borast_uint64_sub(a,b)	    ((a) - (b))
+#define			_borast_uint64_mul(a,b)	    ((a) * (b))
+#define			_borast_uint32x32_64_mul(a,b)	((uint64_t) (a) * (b))
+#define			_borast_uint64_lsl(a,b)	    ((a) << (b))
+#define			_borast_uint64_rsl(a,b)	    ((uint64_t) (a) >> (b))
+#define			_borast_uint64_rsa(a,b)	    ((uint64_t) ((int64_t) (a) >> (b)))
+#define			_borast_uint64_lt(a,b)	    ((a) < (b))
+#define                 _borast_uint64_cmp(a,b)       ((a) == (b) ? 0 : (a) < (b) ? -1 : 1)
+#define			_borast_uint64_is_zero(a)    ((a) == 0)
+#define			_borast_uint64_eq(a,b)	    ((a) == (b))
+#define			_borast_uint64_negate(a)	    ((uint64_t) -((int64_t) (a)))
+#define			_borast_uint64_negative(a)   ((int64_t) (a) < 0)
+#define			_borast_uint64_not(a)	    (~(a))
+
+#define			_borast_uint64_to_int64(i)   ((int64_t) (i))
+#define			_borast_int64_to_uint64(i)   ((uint64_t) (i))
+
+#define			_borast_int32_to_int64(i)    ((int64_t) (i))
+#define			_borast_int64_to_int32(i)    ((int32_t) (i))
+#define			_borast_int64_add(a,b)	    ((a) + (b))
+#define			_borast_int64_sub(a,b)	    ((a) - (b))
+#define			_borast_int64_mul(a,b)	    ((a) * (b))
+#define			_borast_int32x32_64_mul(a,b) ((int64_t) (a) * (b))
+#define			_borast_int64_lt(a,b)	    ((a) < (b))
+#define                 _borast_int64_cmp(a,b)       ((a) == (b) ? 0 : (a) < (b) ? -1 : 1)
+#define			_borast_int64_is_zero(a)     ((a) == 0)
+#define			_borast_int64_eq(a,b)	    ((a) == (b))
+#define			_borast_int64_lsl(a,b)	    ((a) << (b))
+#define			_borast_int64_rsl(a,b)	    ((int64_t) ((uint64_t) (a) >> (b)))
+#define			_borast_int64_rsa(a,b)	    ((int64_t) (a) >> (b))
+#define			_borast_int64_negate(a)	    (-(a))
+#define			_borast_int64_negative(a)    ((a) < 0)
+#define			_borast_int64_not(a)	    (~(a))
 
 #endif
 
 /*
  * 64-bit comparisions derived from lt or eq
  */
-#define			_cairo_uint64_le(a,b)	    (!_cairo_uint64_gt(a,b))
-#define			_cairo_uint64_ne(a,b)	    (!_cairo_uint64_eq(a,b))
-#define			_cairo_uint64_ge(a,b)	    (!_cairo_uint64_lt(a,b))
-#define			_cairo_uint64_gt(a,b)	    _cairo_uint64_lt(b,a)
+#define			_borast_uint64_le(a,b)	    (!_borast_uint64_gt(a,b))
+#define			_borast_uint64_ne(a,b)	    (!_borast_uint64_eq(a,b))
+#define			_borast_uint64_ge(a,b)	    (!_borast_uint64_lt(a,b))
+#define			_borast_uint64_gt(a,b)	    _borast_uint64_lt(b,a)
 
-#define			_cairo_int64_le(a,b)	    (!_cairo_int64_gt(a,b))
-#define			_cairo_int64_ne(a,b)	    (!_cairo_int64_eq(a,b))
-#define			_cairo_int64_ge(a,b)	    (!_cairo_int64_lt(a,b))
-#define			_cairo_int64_gt(a,b)	    _cairo_int64_lt(b,a)
+#define			_borast_int64_le(a,b)	    (!_borast_int64_gt(a,b))
+#define			_borast_int64_ne(a,b)	    (!_borast_int64_eq(a,b))
+#define			_borast_int64_ge(a,b)	    (!_borast_int64_lt(a,b))
+#define			_borast_int64_gt(a,b)	    _borast_int64_lt(b,a)
 
 /*
  * As the C implementation always computes both, create
  * a function which returns both for the 'native' type as well
  */
 
-static inline cairo_quorem64_t
-_cairo_int64_divrem (cairo_int64_t num, cairo_int64_t den)
+static inline borast_quorem64_t
+_borast_int64_divrem (borast_int64_t num, borast_int64_t den)
 {
-    int			num_neg = _cairo_int64_negative (num);
-    int			den_neg = _cairo_int64_negative (den);
-    cairo_uquorem64_t	uqr;
-    cairo_quorem64_t	qr;
+    int			num_neg = _borast_int64_negative (num);
+    int			den_neg = _borast_int64_negative (den);
+    borast_uquorem64_t	uqr;
+    borast_quorem64_t	qr;
 
     if (num_neg)
-	num = _cairo_int64_negate (num);
+	num = _borast_int64_negate (num);
     if (den_neg)
-	den = _cairo_int64_negate (den);
-    uqr = _cairo_uint64_divrem (num, den);
+	den = _borast_int64_negate (den);
+    uqr = _borast_uint64_divrem (num, den);
     if (num_neg)
-	qr.rem = _cairo_int64_negate (uqr.rem);
+	qr.rem = _borast_int64_negate (uqr.rem);
     else
 	qr.rem = uqr.rem;
     if (num_neg != den_neg)
-	qr.quo = (cairo_int64_t) _cairo_int64_negate (uqr.quo);
+	qr.quo = (borast_int64_t) _borast_int64_negate (uqr.quo);
     else
-	qr.quo = (cairo_int64_t) uqr.quo;
+	qr.quo = (borast_int64_t) uqr.quo;
     return qr;
 }
 
 #if 0
 static inline int32_t
-_cairo_int64_32_div (cairo_int64_t num, int32_t den)
+_borast_int64_32_div (borast_int64_t num, int32_t den)
 {
     return num / den;
 }
 #endif
 
 static inline int32_t
-_cairo_int64_32_div (cairo_int64_t num, int32_t den)
+_borast_int64_32_div (borast_int64_t num, int32_t den)
 {
-  cairo_quorem64_t quorem;
-  cairo_int64_t den64;
+  borast_quorem64_t quorem;
+  borast_int64_t den64;
 
-  den64 = _cairo_int32_to_int64 (den);
-  quorem = _cairo_int64_divrem (num, den64);
+  den64 = _borast_int32_to_int64 (den);
+  quorem = _borast_int64_divrem (num, den64);
 
-  return _cairo_int64_to_int32 (quorem.quo);
+  return _borast_int64_to_int32 (quorem.quo);
 }
 
 /*
@@ -212,118 +212,118 @@ _cairo_int64_32_div (cairo_int64_t num, int32_t den)
 
 #if !HAVE_UINT128_T
 
-cairo_uint128_t I	_cairo_uint32_to_uint128 (uint32_t i);
-cairo_uint128_t I	_cairo_uint64_to_uint128 (cairo_uint64_t i);
-#define			_cairo_uint128_to_uint64(a)	((a).lo)
-#define			_cairo_uint128_to_uint32(a)	_cairo_uint64_to_uint32(_cairo_uint128_to_uint64(a))
-cairo_uint128_t I	_cairo_uint128_add (cairo_uint128_t a, cairo_uint128_t b);
-cairo_uint128_t I	_cairo_uint128_sub (cairo_uint128_t a, cairo_uint128_t b);
-cairo_uint128_t I	_cairo_uint128_mul (cairo_uint128_t a, cairo_uint128_t b);
-cairo_uint128_t I	_cairo_uint64x64_128_mul (cairo_uint64_t a, cairo_uint64_t b);
-cairo_uint128_t I	_cairo_uint128_lsl (cairo_uint128_t a, int shift);
-cairo_uint128_t I	_cairo_uint128_rsl (cairo_uint128_t a, int shift);
-cairo_uint128_t I	_cairo_uint128_rsa (cairo_uint128_t a, int shift);
-int	        I	_cairo_uint128_lt (cairo_uint128_t a, cairo_uint128_t b);
-int	        I	_cairo_uint128_cmp (cairo_uint128_t a, cairo_uint128_t b);
-int	        I	_cairo_uint128_eq (cairo_uint128_t a, cairo_uint128_t b);
-#define			_cairo_uint128_is_zero(a) (_cairo_uint64_is_zero ((a).hi) && _cairo_uint64_is_zero ((a).lo))
-cairo_uint128_t I	_cairo_uint128_negate (cairo_uint128_t a);
-#define			_cairo_uint128_negative(a)  (_cairo_uint64_negative(a.hi))
-cairo_uint128_t I	_cairo_uint128_not (cairo_uint128_t a);
-
-#define			_cairo_uint128_to_int128(i)	(i)
-#define			_cairo_int128_to_uint128(i)	(i)
-
-cairo_int128_t  I	_cairo_int32_to_int128 (int32_t i);
-cairo_int128_t  I	_cairo_int64_to_int128 (cairo_int64_t i);
-#define			_cairo_int128_to_int64(a)   ((cairo_int64_t) (a).lo)
-#define			_cairo_int128_to_int32(a)   _cairo_int64_to_int32(_cairo_int128_to_int64(a))
-#define			_cairo_int128_add(a,b)	    _cairo_uint128_add(a,b)
-#define			_cairo_int128_sub(a,b)	    _cairo_uint128_sub(a,b)
-#define			_cairo_int128_mul(a,b)	    _cairo_uint128_mul(a,b)
-cairo_int128_t I _cairo_int64x64_128_mul (cairo_int64_t a, cairo_int64_t b);
-#define                 _cairo_int64x32_128_mul(a, b) _cairo_int64x64_128_mul(a, _cairo_int32_to_int64(b))
-#define			_cairo_int128_lsl(a,b)	    _cairo_uint128_lsl(a,b)
-#define			_cairo_int128_rsl(a,b)	    _cairo_uint128_rsl(a,b)
-#define			_cairo_int128_rsa(a,b)	    _cairo_uint128_rsa(a,b)
-int 	        I	_cairo_int128_lt (cairo_int128_t a, cairo_int128_t b);
-int	        I	_cairo_int128_cmp (cairo_int128_t a, cairo_int128_t b);
-#define			_cairo_int128_is_zero(a)    _cairo_uint128_is_zero (a)
-#define			_cairo_int128_eq(a,b)	    _cairo_uint128_eq (a,b)
-#define			_cairo_int128_negate(a)	    _cairo_uint128_negate(a)
-#define			_cairo_int128_negative(a)   (_cairo_uint128_negative(a))
-#define			_cairo_int128_not(a)	    _cairo_uint128_not(a)
+borast_uint128_t I	_borast_uint32_to_uint128 (uint32_t i);
+borast_uint128_t I	_borast_uint64_to_uint128 (borast_uint64_t i);
+#define			_borast_uint128_to_uint64(a)	((a).lo)
+#define			_borast_uint128_to_uint32(a)	_borast_uint64_to_uint32(_borast_uint128_to_uint64(a))
+borast_uint128_t I	_borast_uint128_add (borast_uint128_t a, borast_uint128_t b);
+borast_uint128_t I	_borast_uint128_sub (borast_uint128_t a, borast_uint128_t b);
+borast_uint128_t I	_borast_uint128_mul (borast_uint128_t a, borast_uint128_t b);
+borast_uint128_t I	_borast_uint64x64_128_mul (borast_uint64_t a, borast_uint64_t b);
+borast_uint128_t I	_borast_uint128_lsl (borast_uint128_t a, int shift);
+borast_uint128_t I	_borast_uint128_rsl (borast_uint128_t a, int shift);
+borast_uint128_t I	_borast_uint128_rsa (borast_uint128_t a, int shift);
+int	        I	_borast_uint128_lt (borast_uint128_t a, borast_uint128_t b);
+int	        I	_borast_uint128_cmp (borast_uint128_t a, borast_uint128_t b);
+int	        I	_borast_uint128_eq (borast_uint128_t a, borast_uint128_t b);
+#define			_borast_uint128_is_zero(a) (_borast_uint64_is_zero ((a).hi) && _borast_uint64_is_zero ((a).lo))
+borast_uint128_t I	_borast_uint128_negate (borast_uint128_t a);
+#define			_borast_uint128_negative(a)  (_borast_uint64_negative(a.hi))
+borast_uint128_t I	_borast_uint128_not (borast_uint128_t a);
+
+#define			_borast_uint128_to_int128(i)	(i)
+#define			_borast_int128_to_uint128(i)	(i)
+
+borast_int128_t  I	_borast_int32_to_int128 (int32_t i);
+borast_int128_t  I	_borast_int64_to_int128 (borast_int64_t i);
+#define			_borast_int128_to_int64(a)   ((borast_int64_t) (a).lo)
+#define			_borast_int128_to_int32(a)   _borast_int64_to_int32(_borast_int128_to_int64(a))
+#define			_borast_int128_add(a,b)	    _borast_uint128_add(a,b)
+#define			_borast_int128_sub(a,b)	    _borast_uint128_sub(a,b)
+#define			_borast_int128_mul(a,b)	    _borast_uint128_mul(a,b)
+borast_int128_t I _borast_int64x64_128_mul (borast_int64_t a, borast_int64_t b);
+#define                 _borast_int64x32_128_mul(a, b) _borast_int64x64_128_mul(a, _borast_int32_to_int64(b))
+#define			_borast_int128_lsl(a,b)	    _borast_uint128_lsl(a,b)
+#define			_borast_int128_rsl(a,b)	    _borast_uint128_rsl(a,b)
+#define			_borast_int128_rsa(a,b)	    _borast_uint128_rsa(a,b)
+int 	        I	_borast_int128_lt (borast_int128_t a, borast_int128_t b);
+int	        I	_borast_int128_cmp (borast_int128_t a, borast_int128_t b);
+#define			_borast_int128_is_zero(a)    _borast_uint128_is_zero (a)
+#define			_borast_int128_eq(a,b)	    _borast_uint128_eq (a,b)
+#define			_borast_int128_negate(a)	    _borast_uint128_negate(a)
+#define			_borast_int128_negative(a)   (_borast_uint128_negative(a))
+#define			_borast_int128_not(a)	    _borast_uint128_not(a)
 
 #else	/* !HAVE_UINT128_T */
 
-#define			_cairo_uint32_to_uint128(i) ((uint128_t) (i))
-#define			_cairo_uint64_to_uint128(i) ((uint128_t) (i))
-#define			_cairo_uint128_to_uint64(i) ((uint64_t) (i))
-#define			_cairo_uint128_to_uint32(i) ((uint32_t) (i))
-#define			_cairo_uint128_add(a,b)	    ((a) + (b))
-#define			_cairo_uint128_sub(a,b)	    ((a) - (b))
-#define			_cairo_uint128_mul(a,b)	    ((a) * (b))
-#define			_cairo_uint64x64_128_mul(a,b)	((uint128_t) (a) * (b))
-#define			_cairo_uint128_lsl(a,b)	    ((a) << (b))
-#define			_cairo_uint128_rsl(a,b)	    ((uint128_t) (a) >> (b))
-#define			_cairo_uint128_rsa(a,b)	    ((uint128_t) ((int128_t) (a) >> (b)))
-#define			_cairo_uint128_lt(a,b)	    ((a) < (b))
-#define			_cairo_uint128_cmp(a,b)	    ((a) == (b) ? 0 : (a) < (b) ? -1 : 1)
-#define			_cairo_uint128_is_zero(a)   ((a) == 0)
-#define			_cairo_uint128_eq(a,b)	    ((a) == (b))
-#define			_cairo_uint128_negate(a)    ((uint128_t) -((int128_t) (a)))
-#define			_cairo_uint128_negative(a)  ((int128_t) (a) < 0)
-#define			_cairo_uint128_not(a)	    (~(a))
-
-#define			_cairo_uint128_to_int128(i) ((int128_t) (i))
-#define			_cairo_int128_to_uint128(i) ((uint128_t) (i))
-
-#define			_cairo_int32_to_int128(i)   ((int128_t) (i))
-#define			_cairo_int64_to_int128(i)   ((int128_t) (i))
-#define			_cairo_int128_to_int64(i)   ((int64_t) (i))
-#define			_cairo_int128_to_int32(i)   ((int32_t) (i))
-#define			_cairo_int128_add(a,b)	    ((a) + (b))
-#define			_cairo_int128_sub(a,b)	    ((a) - (b))
-#define			_cairo_int128_mul(a,b)	    ((a) * (b))
-#define			_cairo_int64x64_128_mul(a,b) ((int128_t) (a) * (b))
-#define                 _cairo_int64x32_128_mul(a, b) _cairo_int64x64_128_mul(a, _cairo_int32_to_int64(b))
-#define			_cairo_int128_lt(a,b)	    ((a) < (b))
-#define			_cairo_int128_cmp(a,b)	    ((a) == (b) ? 0 : (a) < (b) ? -1 : 1)
-#define			_cairo_int128_is_zero(a)    ((a) == 0)
-#define			_cairo_int128_eq(a,b)	    ((a) == (b))
-#define			_cairo_int128_lsl(a,b)	    ((a) << (b))
-#define			_cairo_int128_rsl(a,b)	    ((int128_t) ((uint128_t) (a) >> (b)))
-#define			_cairo_int128_rsa(a,b)	    ((int128_t) (a) >> (b))
-#define			_cairo_int128_negate(a)	    (-(a))
-#define			_cairo_int128_negative(a)   ((a) < 0)
-#define			_cairo_int128_not(a)	    (~(a))
+#define			_borast_uint32_to_uint128(i) ((uint128_t) (i))
+#define			_borast_uint64_to_uint128(i) ((uint128_t) (i))
+#define			_borast_uint128_to_uint64(i) ((uint64_t) (i))
+#define			_borast_uint128_to_uint32(i) ((uint32_t) (i))
+#define			_borast_uint128_add(a,b)	    ((a) + (b))
+#define			_borast_uint128_sub(a,b)	    ((a) - (b))
+#define			_borast_uint128_mul(a,b)	    ((a) * (b))
+#define			_borast_uint64x64_128_mul(a,b)	((uint128_t) (a) * (b))
+#define			_borast_uint128_lsl(a,b)	    ((a) << (b))
+#define			_borast_uint128_rsl(a,b)	    ((uint128_t) (a) >> (b))
+#define			_borast_uint128_rsa(a,b)	    ((uint128_t) ((int128_t) (a) >> (b)))
+#define			_borast_uint128_lt(a,b)	    ((a) < (b))
+#define			_borast_uint128_cmp(a,b)	    ((a) == (b) ? 0 : (a) < (b) ? -1 : 1)
+#define			_borast_uint128_is_zero(a)   ((a) == 0)
+#define			_borast_uint128_eq(a,b)	    ((a) == (b))
+#define			_borast_uint128_negate(a)    ((uint128_t) -((int128_t) (a)))
+#define			_borast_uint128_negative(a)  ((int128_t) (a) < 0)
+#define			_borast_uint128_not(a)	    (~(a))
+
+#define			_borast_uint128_to_int128(i) ((int128_t) (i))
+#define			_borast_int128_to_uint128(i) ((uint128_t) (i))
+
+#define			_borast_int32_to_int128(i)   ((int128_t) (i))
+#define			_borast_int64_to_int128(i)   ((int128_t) (i))
+#define			_borast_int128_to_int64(i)   ((int64_t) (i))
+#define			_borast_int128_to_int32(i)   ((int32_t) (i))
+#define			_borast_int128_add(a,b)	    ((a) + (b))
+#define			_borast_int128_sub(a,b)	    ((a) - (b))
+#define			_borast_int128_mul(a,b)	    ((a) * (b))
+#define			_borast_int64x64_128_mul(a,b) ((int128_t) (a) * (b))
+#define                 _borast_int64x32_128_mul(a, b) _borast_int64x64_128_mul(a, _borast_int32_to_int64(b))
+#define			_borast_int128_lt(a,b)	    ((a) < (b))
+#define			_borast_int128_cmp(a,b)	    ((a) == (b) ? 0 : (a) < (b) ? -1 : 1)
+#define			_borast_int128_is_zero(a)    ((a) == 0)
+#define			_borast_int128_eq(a,b)	    ((a) == (b))
+#define			_borast_int128_lsl(a,b)	    ((a) << (b))
+#define			_borast_int128_rsl(a,b)	    ((int128_t) ((uint128_t) (a) >> (b)))
+#define			_borast_int128_rsa(a,b)	    ((int128_t) (a) >> (b))
+#define			_borast_int128_negate(a)	    (-(a))
+#define			_borast_int128_negative(a)   ((a) < 0)
+#define			_borast_int128_not(a)	    (~(a))
 
 #endif	/* HAVE_UINT128_T */
 
-cairo_uquorem128_t I
-_cairo_uint128_divrem (cairo_uint128_t num, cairo_uint128_t den);
+borast_uquorem128_t I
+_borast_uint128_divrem (borast_uint128_t num, borast_uint128_t den);
 
-cairo_quorem128_t I
-_cairo_int128_divrem (cairo_int128_t num, cairo_int128_t den);
+borast_quorem128_t I
+_borast_int128_divrem (borast_int128_t num, borast_int128_t den);
 
-cairo_uquorem64_t I
-_cairo_uint_96by64_32x64_divrem (cairo_uint128_t num,
-				 cairo_uint64_t  den);
+borast_uquorem64_t I
+_borast_uint_96by64_32x64_divrem (borast_uint128_t num,
+				 borast_uint64_t  den);
 
-cairo_quorem64_t I
-_cairo_int_96by64_32x64_divrem (cairo_int128_t num,
-				cairo_int64_t  den);
+borast_quorem64_t I
+_borast_int_96by64_32x64_divrem (borast_int128_t num,
+				borast_int64_t  den);
 
-#define			_cairo_uint128_le(a,b)	    (!_cairo_uint128_gt(a,b))
-#define			_cairo_uint128_ne(a,b)	    (!_cairo_uint128_eq(a,b))
-#define			_cairo_uint128_ge(a,b)	    (!_cairo_uint128_lt(a,b))
-#define			_cairo_uint128_gt(a,b)	    _cairo_uint128_lt(b,a)
+#define			_borast_uint128_le(a,b)	    (!_borast_uint128_gt(a,b))
+#define			_borast_uint128_ne(a,b)	    (!_borast_uint128_eq(a,b))
+#define			_borast_uint128_ge(a,b)	    (!_borast_uint128_lt(a,b))
+#define			_borast_uint128_gt(a,b)	    _borast_uint128_lt(b,a)
 
-#define			_cairo_int128_le(a,b)	    (!_cairo_int128_gt(a,b))
-#define			_cairo_int128_ne(a,b)	    (!_cairo_int128_eq(a,b))
-#define			_cairo_int128_ge(a,b)	    (!_cairo_int128_lt(a,b))
-#define			_cairo_int128_gt(a,b)	    _cairo_int128_lt(b,a)
+#define			_borast_int128_le(a,b)	    (!_borast_int128_gt(a,b))
+#define			_borast_int128_ne(a,b)	    (!_borast_int128_eq(a,b))
+#define			_borast_int128_ge(a,b)	    (!_borast_int128_lt(a,b))
+#define			_borast_int128_gt(a,b)	    _borast_int128_lt(b,a)
 
 #undef I
 
-#endif /* CAIRO_WIDEINT_H */
+#endif /* BORAST_WIDEINT_H */
diff --git a/src/borast/borast-wideint-type-private.h b/src/borast/borast-wideint-type-private.h
index e18f48e..07c92d2 100644
--- a/src/borast/borast-wideint-type-private.h
+++ b/src/borast/borast-wideint-type-private.h
@@ -98,26 +98,26 @@
 
 #if !HAVE_UINT64_T
 
-typedef struct _cairo_uint64 {
+typedef struct _borast_uint64 {
     uint32_t	lo, hi;
-} cairo_uint64_t, cairo_int64_t;
+} borast_uint64_t, borast_int64_t;
 
 #else
 
-typedef uint64_t    cairo_uint64_t;
-typedef int64_t	    cairo_int64_t;
+typedef uint64_t    borast_uint64_t;
+typedef int64_t	    borast_int64_t;
 
 #endif
 
-typedef struct _cairo_uquorem64 {
-    cairo_uint64_t	quo;
-    cairo_uint64_t	rem;
-} cairo_uquorem64_t;
+typedef struct _borast_uquorem64 {
+    borast_uint64_t	quo;
+    borast_uint64_t	rem;
+} borast_uquorem64_t;
 
-typedef struct _cairo_quorem64 {
-    cairo_int64_t	quo;
-    cairo_int64_t	rem;
-} cairo_quorem64_t;
+typedef struct _borast_quorem64 {
+    borast_int64_t	quo;
+    borast_int64_t	rem;
+} borast_quorem64_t;
 
 /* gcc has a non-standard name. */
 #if HAVE___UINT128_T && !HAVE_UINT128_T
@@ -128,26 +128,26 @@ typedef __int128_t int128_t;
 
 #if !HAVE_UINT128_T
 
-typedef struct cairo_uint128 {
-    cairo_uint64_t	lo, hi;
-} cairo_uint128_t, cairo_int128_t;
+typedef struct borast_uint128 {
+    borast_uint64_t	lo, hi;
+} borast_uint128_t, borast_int128_t;
 
 #else
 
-typedef uint128_t	cairo_uint128_t;
-typedef int128_t	cairo_int128_t;
+typedef uint128_t	borast_uint128_t;
+typedef int128_t	borast_int128_t;
 
 #endif
 
-typedef struct _cairo_uquorem128 {
-    cairo_uint128_t	quo;
-    cairo_uint128_t	rem;
-} cairo_uquorem128_t;
+typedef struct _borast_uquorem128 {
+    borast_uint128_t	quo;
+    borast_uint128_t	rem;
+} borast_uquorem128_t;
 
-typedef struct _cairo_quorem128 {
-    cairo_int128_t	quo;
-    cairo_int128_t	rem;
-} cairo_quorem128_t;
+typedef struct _borast_quorem128 {
+    borast_int128_t	quo;
+    borast_int128_t	rem;
+} borast_quorem128_t;
 
 
 #endif /* CAIRO_WIDEINT_H */
diff --git a/src/borast/borast-wideint.c b/src/borast/borast-wideint.c
index 823ebca..a973af6 100644
--- a/src/borast/borast-wideint.c
+++ b/src/borast/borast-wideint.c
@@ -33,7 +33,7 @@
  *	Keith R. Packard <keithp@keithp.com>
  */
 
-#include "cairo-wideint-private.h"
+#include "borast-wideint-private.h"
 
 #if HAVE_UINT64_T
 
@@ -44,79 +44,79 @@
 #define uint64_shift32(i)   ((i) << 32)
 #define uint64_carry32	(((uint64_t) 1) << 32)
 
-#define _cairo_uint32s_to_uint64(h,l) ((uint64_t) (h) << 32 | (l))
+#define _borast_uint32s_to_uint64(h,l) ((uint64_t) (h) << 32 | (l))
 
 #else
 
 #define uint64_lo32(i)	((i).lo)
 #define uint64_hi32(i)	((i).hi)
 
-static cairo_uint64_t
-uint64_lo (cairo_uint64_t i)
+static borast_uint64_t
+uint64_lo (borast_uint64_t i)
 {
-    cairo_uint64_t  s;
+    borast_uint64_t  s;
 
     s.lo = i.lo;
     s.hi = 0;
     return s;
 }
 
-static cairo_uint64_t
-uint64_hi (cairo_uint64_t i)
+static borast_uint64_t
+uint64_hi (borast_uint64_t i)
 {
-    cairo_uint64_t  s;
+    borast_uint64_t  s;
 
     s.lo = i.hi;
     s.hi = 0;
     return s;
 }
 
-static cairo_uint64_t
-uint64_shift32 (cairo_uint64_t i)
+static borast_uint64_t
+uint64_shift32 (borast_uint64_t i)
 {
-    cairo_uint64_t  s;
+    borast_uint64_t  s;
 
     s.lo = 0;
     s.hi = i.lo;
     return s;
 }
 
-static const cairo_uint64_t uint64_carry32 = { 0, 1 };
+static const borast_uint64_t uint64_carry32 = { 0, 1 };
 
-cairo_uint64_t
-_cairo_uint32_to_uint64 (uint32_t i)
+borast_uint64_t
+_borast_uint32_to_uint64 (uint32_t i)
 {
-    cairo_uint64_t	q;
+    borast_uint64_t	q;
 
     q.lo = i;
     q.hi = 0;
     return q;
 }
 
-cairo_int64_t
-_cairo_int32_to_int64 (int32_t i)
+borast_int64_t
+_borast_int32_to_int64 (int32_t i)
 {
-    cairo_uint64_t	q;
+    borast_uint64_t	q;
 
     q.lo = i;
     q.hi = i < 0 ? -1 : 0;
     return q;
 }
 
-static cairo_uint64_t
-_cairo_uint32s_to_uint64 (uint32_t h, uint32_t l)
+static borast_uint64_t
+_borast_uint32s_to_uint64 (uint32_t h, uint32_t l)
 {
-    cairo_uint64_t	q;
+    borast_uint64_t	q;
 
     q.lo = l;
     q.hi = h;
     return q;
 }
 
-cairo_uint64_t
-_cairo_uint64_add (cairo_uint64_t a, cairo_uint64_t b)
+borast_uint64_t
+_borast_uint64_add (borast_uint64_t a, borast_uint64_t b)
 {
-    cairo_uint64_t	s;
+    borast_uint64_t	s;
 
     s.hi = a.hi + b.hi;
     s.lo = a.lo + b.lo;
@@ -125,10 +125,10 @@ _cairo_uint64_add (cairo_uint64_t a, cairo_uint64_t b)
     return s;
 }
 
-cairo_uint64_t
-_cairo_uint64_sub (cairo_uint64_t a, cairo_uint64_t b)
+borast_uint64_t
+_borast_uint64_sub (borast_uint64_t a, borast_uint64_t b)
 {
-    cairo_uint64_t	s;
+    borast_uint64_t	s;
 
     s.hi = a.hi - b.hi;
     s.lo = a.lo - b.lo;
@@ -141,10 +141,10 @@ _cairo_uint64_sub (cairo_uint64_t a, cairo_uint64_t b)
 #define uint32_hi(i)	((i) >> 16)
 #define uint32_carry16	((1) << 16)
 
-cairo_uint64_t
-_cairo_uint32x32_64_mul (uint32_t a, uint32_t b)
+borast_uint64_t
+_borast_uint32x32_64_mul (uint32_t a, uint32_t b)
 {
-    cairo_uint64_t  s;
+    borast_uint64_t  s;
 
     uint16_t	ah, al, bh, bl;
     uint32_t	r0, r1, r2, r3;
@@ -169,11 +169,11 @@ _cairo_uint32x32_64_mul (uint32_t a, uint32_t b)
     return s;
 }
 
-cairo_int64_t
-_cairo_int32x32_64_mul (int32_t a, int32_t b)
+borast_int64_t
+_borast_int32x32_64_mul (int32_t a, int32_t b)
 {
-    cairo_int64_t s;
-    s = _cairo_uint32x32_64_mul ((uint32_t) a, (uint32_t) b);
+    borast_int64_t s;
+    s = _borast_uint32x32_64_mul ((uint32_t) a, (uint32_t) b);
     if (a < 0)
 	s.hi -= b;
     if (b < 0)
@@ -181,18 +181,18 @@ _cairo_int32x32_64_mul (int32_t a, int32_t b)
     return s;
 }
 
-cairo_uint64_t
-_cairo_uint64_mul (cairo_uint64_t a, cairo_uint64_t b)
+borast_uint64_t
+_borast_uint64_mul (borast_uint64_t a, borast_uint64_t b)
 {
-    cairo_uint64_t	s;
+    borast_uint64_t	s;
 
-    s = _cairo_uint32x32_64_mul (a.lo, b.lo);
+    s = _borast_uint32x32_64_mul (a.lo, b.lo);
     s.hi += a.lo * b.hi + a.hi * b.lo;
     return s;
 }
 
-cairo_uint64_t
-_cairo_uint64_lsl (cairo_uint64_t a, int shift)
+borast_uint64_t
+_borast_uint64_lsl (borast_uint64_t a, int shift)
 {
     if (shift >= 32)
     {
@@ -208,8 +208,8 @@ _cairo_uint64_lsl (cairo_uint64_t a, int shift)
     return a;
 }
 
-cairo_uint64_t
-_cairo_uint64_rsl (cairo_uint64_t a, int shift)
+borast_uint64_t
+_borast_uint64_rsl (borast_uint64_t a, int shift)
 {
     if (shift >= 32)
     {
@@ -225,50 +225,50 @@ _cairo_uint64_rsl (cairo_uint64_t a, int shift)
     return a;
 }
 
-#define _cairo_uint32_rsa(a,n)	((uint32_t) (((int32_t) (a)) >> (n)))
+#define _borast_uint32_rsa(a,n)	((uint32_t) (((int32_t) (a)) >> (n)))
 
-cairo_int64_t
-_cairo_uint64_rsa (cairo_int64_t a, int shift)
+borast_int64_t
+_borast_uint64_rsa (borast_int64_t a, int shift)
 {
     if (shift >= 32)
     {
 	a.lo = a.hi;
-	a.hi = _cairo_uint32_rsa (a.hi, 31);
+	a.hi = _borast_uint32_rsa (a.hi, 31);
 	shift -= 32;
     }
     if (shift)
     {
 	a.lo = a.lo >> shift | a.hi << (32 - shift);
-	a.hi = _cairo_uint32_rsa (a.hi, shift);
+	a.hi = _borast_uint32_rsa (a.hi, shift);
     }
     return a;
 }
 
 int
-_cairo_uint64_lt (cairo_uint64_t a, cairo_uint64_t b)
+_borast_uint64_lt (borast_uint64_t a, borast_uint64_t b)
 {
     return (a.hi < b.hi ||
 	    (a.hi == b.hi && a.lo < b.lo));
 }
 
 int
-_cairo_uint64_eq (cairo_uint64_t a, cairo_uint64_t b)
+_borast_uint64_eq (borast_uint64_t a, borast_uint64_t b)
 {
     return a.hi == b.hi && a.lo == b.lo;
 }
 
 int
-_cairo_int64_lt (cairo_int64_t a, cairo_int64_t b)
+_borast_int64_lt (borast_int64_t a, borast_int64_t b)
 {
-    if (_cairo_int64_negative (a) && !_cairo_int64_negative (b))
+    if (_borast_int64_negative (a) && !_borast_int64_negative (b))
 	return 1;
-    if (!_cairo_int64_negative (a) && _cairo_int64_negative (b))
+    if (!_borast_int64_negative (a) && _borast_int64_negative (b))
 	return 0;
-    return _cairo_uint64_lt (a, b);
+    return _borast_uint64_lt (a, b);
 }
 
 int
-_cairo_uint64_cmp (cairo_uint64_t a, cairo_uint64_t b)
+_borast_uint64_cmp (borast_uint64_t a, borast_uint64_t b)
 {
     if (a.hi < b.hi)
 	return -1;
@@ -283,26 +283,26 @@ _cairo_uint64_cmp (cairo_uint64_t a, cairo_uint64_t b)
 }
 
 int
-_cairo_int64_cmp (cairo_int64_t a, cairo_int64_t b)
+_borast_int64_cmp (borast_int64_t a, borast_int64_t b)
 {
-    if (_cairo_int64_negative (a) && !_cairo_int64_negative (b))
+    if (_borast_int64_negative (a) && !_borast_int64_negative (b))
 	return -1;
-    if (!_cairo_int64_negative (a) && _cairo_int64_negative (b))
+    if (!_borast_int64_negative (a) && _borast_int64_negative (b))
 	return 1;
 
-    return _cairo_uint64_cmp (a, b);
+    return _borast_uint64_cmp (a, b);
 }
 
-cairo_uint64_t
-_cairo_uint64_not (cairo_uint64_t a)
+borast_uint64_t
+_borast_uint64_not (borast_uint64_t a)
 {
     a.lo = ~a.lo;
     a.hi = ~a.hi;
     return a;
 }
 
-cairo_uint64_t
-_cairo_uint64_negate (cairo_uint64_t a)
+borast_uint64_t
+_borast_uint64_negate (borast_uint64_t a)
 {
     a.lo = ~a.lo;
     a.hi = ~a.hi;
@@ -314,33 +314,33 @@ _cairo_uint64_negate (cairo_uint64_t a)
 /*
  * Simple bit-at-a-time divide.
  */
-cairo_uquorem64_t
-_cairo_uint64_divrem (cairo_uint64_t num, cairo_uint64_t den)
+borast_uquorem64_t
+_borast_uint64_divrem (borast_uint64_t num, borast_uint64_t den)
 {
-    cairo_uquorem64_t	qr;
-    cairo_uint64_t	bit;
-    cairo_uint64_t	quo;
+    borast_uquorem64_t	qr;
+    borast_uint64_t	bit;
+    borast_uint64_t	quo;
 
-    bit = _cairo_uint32_to_uint64 (1);
+    bit = _borast_uint32_to_uint64 (1);
 
     /* normalize to make den >= num, but not overflow */
-    while (_cairo_uint64_lt (den, num) && (den.hi & 0x80000000) == 0)
+    while (_borast_uint64_lt (den, num) && (den.hi & 0x80000000) == 0)
     {
-	bit = _cairo_uint64_lsl (bit, 1);
-	den = _cairo_uint64_lsl (den, 1);
+	bit = _borast_uint64_lsl (bit, 1);
+	den = _borast_uint64_lsl (den, 1);
     }
-    quo = _cairo_uint32_to_uint64 (0);
+    quo = _borast_uint32_to_uint64 (0);
 
     /* generate quotient, one bit at a time */
     while (bit.hi | bit.lo)
     {
-	if (_cairo_uint64_le (den, num))
+	if (_borast_uint64_le (den, num))
 	{
-	    num = _cairo_uint64_sub (num, den);
-	    quo = _cairo_uint64_add (quo, bit);
+	    num = _borast_uint64_sub (num, den);
+	    quo = _borast_uint64_add (quo, bit);
 	}
-	bit = _cairo_uint64_rsl (bit, 1);
-	den = _cairo_uint64_rsl (den, 1);
+	bit = _borast_uint64_rsl (bit, 1);
+	den = _borast_uint64_rsl (den, 1);
     }
     qr.quo = quo;
     qr.rem = num;
@@ -350,10 +350,10 @@ _cairo_uint64_divrem (cairo_uint64_t num, cairo_uint64_t den)
 #endif /* !HAVE_UINT64_T */
 
 #if HAVE_UINT128_T
-cairo_uquorem128_t
-_cairo_uint128_divrem (cairo_uint128_t num, cairo_uint128_t den)
+borast_uquorem128_t
+_borast_uint128_divrem (borast_uint128_t num, borast_uint128_t den)
 {
-    cairo_uquorem128_t	qr;
+    borast_uquorem128_t	qr;
 
     qr.quo = num / den;
     qr.rem = num % den;
@@ -362,310 +362,310 @@ _cairo_uint128_divrem (cairo_uint128_t num, cairo_uint128_t den)
 
 #else
 
-cairo_uint128_t
-_cairo_uint32_to_uint128 (uint32_t i)
+borast_uint128_t
+_borast_uint32_to_uint128 (uint32_t i)
 {
-    cairo_uint128_t	q;
+    borast_uint128_t	q;
 
-    q.lo = _cairo_uint32_to_uint64 (i);
-    q.hi = _cairo_uint32_to_uint64 (0);
+    q.lo = _borast_uint32_to_uint64 (i);
+    q.hi = _borast_uint32_to_uint64 (0);
     return q;
 }
 
-cairo_int128_t
-_cairo_int32_to_int128 (int32_t i)
+borast_int128_t
+_borast_int32_to_int128 (int32_t i)
 {
-    cairo_int128_t	q;
+    borast_int128_t	q;
 
-    q.lo = _cairo_int32_to_int64 (i);
-    q.hi = _cairo_int32_to_int64 (i < 0 ? -1 : 0);
+    q.lo = _borast_int32_to_int64 (i);
+    q.hi = _borast_int32_to_int64 (i < 0 ? -1 : 0);
     return q;
 }
 
-cairo_uint128_t
-_cairo_uint64_to_uint128 (cairo_uint64_t i)
+borast_uint128_t
+_borast_uint64_to_uint128 (borast_uint64_t i)
 {
-    cairo_uint128_t	q;
+    borast_uint128_t	q;
 
     q.lo = i;
-    q.hi = _cairo_uint32_to_uint64 (0);
+    q.hi = _borast_uint32_to_uint64 (0);
     return q;
 }
 
-cairo_int128_t
-_cairo_int64_to_int128 (cairo_int64_t i)
+borast_int128_t
+_borast_int64_to_int128 (borast_int64_t i)
 {
-    cairo_int128_t	q;
+    borast_int128_t	q;
 
     q.lo = i;
-    q.hi = _cairo_int32_to_int64 (_cairo_int64_negative(i) ? -1 : 0);
+    q.hi = _borast_int32_to_int64 (_borast_int64_negative(i) ? -1 : 0);
     return q;
 }
 
-cairo_uint128_t
-_cairo_uint128_add (cairo_uint128_t a, cairo_uint128_t b)
+borast_uint128_t
+_borast_uint128_add (borast_uint128_t a, borast_uint128_t b)
 {
-    cairo_uint128_t	s;
+    borast_uint128_t	s;
 
-    s.hi = _cairo_uint64_add (a.hi, b.hi);
-    s.lo = _cairo_uint64_add (a.lo, b.lo);
-    if (_cairo_uint64_lt (s.lo, a.lo))
-	s.hi = _cairo_uint64_add (s.hi, _cairo_uint32_to_uint64 (1));
+    s.hi = _borast_uint64_add (a.hi, b.hi);
+    s.lo = _borast_uint64_add (a.lo, b.lo);
+    if (_borast_uint64_lt (s.lo, a.lo))
+	s.hi = _borast_uint64_add (s.hi, _borast_uint32_to_uint64 (1));
     return s;
 }
 
-cairo_uint128_t
-_cairo_uint128_sub (cairo_uint128_t a, cairo_uint128_t b)
+borast_uint128_t
+_borast_uint128_sub (borast_uint128_t a, borast_uint128_t b)
 {
-    cairo_uint128_t	s;
+    borast_uint128_t	s;
 
-    s.hi = _cairo_uint64_sub (a.hi, b.hi);
-    s.lo = _cairo_uint64_sub (a.lo, b.lo);
-    if (_cairo_uint64_gt (s.lo, a.lo))
-	s.hi = _cairo_uint64_sub (s.hi, _cairo_uint32_to_uint64(1));
+    s.hi = _borast_uint64_sub (a.hi, b.hi);
+    s.lo = _borast_uint64_sub (a.lo, b.lo);
+    if (_borast_uint64_gt (s.lo, a.lo))
+	s.hi = _borast_uint64_sub (s.hi, _borast_uint32_to_uint64(1));
     return s;
 }
 
-cairo_uint128_t
-_cairo_uint64x64_128_mul (cairo_uint64_t a, cairo_uint64_t b)
+borast_uint128_t
+_borast_uint64x64_128_mul (borast_uint64_t a, borast_uint64_t b)
 {
-    cairo_uint128_t	s;
+    borast_uint128_t	s;
     uint32_t		ah, al, bh, bl;
-    cairo_uint64_t	r0, r1, r2, r3;
+    borast_uint64_t	r0, r1, r2, r3;
 
     al = uint64_lo32 (a);
     ah = uint64_hi32 (a);
     bl = uint64_lo32 (b);
     bh = uint64_hi32 (b);
 
-    r0 = _cairo_uint32x32_64_mul (al, bl);
-    r1 = _cairo_uint32x32_64_mul (al, bh);
-    r2 = _cairo_uint32x32_64_mul (ah, bl);
-    r3 = _cairo_uint32x32_64_mul (ah, bh);
+    r0 = _borast_uint32x32_64_mul (al, bl);
+    r1 = _borast_uint32x32_64_mul (al, bh);
+    r2 = _borast_uint32x32_64_mul (ah, bl);
+    r3 = _borast_uint32x32_64_mul (ah, bh);
 
-    r1 = _cairo_uint64_add (r1, uint64_hi (r0));    /* no carry possible */
-    r1 = _cairo_uint64_add (r1, r2);	    	    /* but this can carry */
-    if (_cairo_uint64_lt (r1, r2))		    /* check */
-	r3 = _cairo_uint64_add (r3, uint64_carry32);
+    r1 = _borast_uint64_add (r1, uint64_hi (r0));    /* no carry possible */
+    r1 = _borast_uint64_add (r1, r2);	    	    /* but this can carry */
+    if (_borast_uint64_lt (r1, r2))		    /* check */
+	r3 = _borast_uint64_add (r3, uint64_carry32);
 
-    s.hi = _cairo_uint64_add (r3, uint64_hi(r1));
-    s.lo = _cairo_uint64_add (uint64_shift32 (r1),
+    s.hi = _borast_uint64_add (r3, uint64_hi(r1));
+    s.lo = _borast_uint64_add (uint64_shift32 (r1),
 				uint64_lo (r0));
     return s;
 }
 
-cairo_int128_t
-_cairo_int64x64_128_mul (cairo_int64_t a, cairo_int64_t b)
+borast_int128_t
+_borast_int64x64_128_mul (borast_int64_t a, borast_int64_t b)
 {
-    cairo_int128_t  s;
-    s = _cairo_uint64x64_128_mul (_cairo_int64_to_uint64(a),
-				  _cairo_int64_to_uint64(b));
-    if (_cairo_int64_negative (a))
-	s.hi = _cairo_uint64_sub (s.hi,
-				  _cairo_int64_to_uint64 (b));
-    if (_cairo_int64_negative (b))
-	s.hi = _cairo_uint64_sub (s.hi,
-				  _cairo_int64_to_uint64 (a));
+    borast_int128_t  s;
+    s = _borast_uint64x64_128_mul (_borast_int64_to_uint64(a),
+				  _borast_int64_to_uint64(b));
+    if (_borast_int64_negative (a))
+	s.hi = _borast_uint64_sub (s.hi,
+				  _borast_int64_to_uint64 (b));
+    if (_borast_int64_negative (b))
+	s.hi = _borast_uint64_sub (s.hi,
+				  _borast_int64_to_uint64 (a));
     return s;
 }
 
-cairo_uint128_t
-_cairo_uint128_mul (cairo_uint128_t a, cairo_uint128_t b)
+borast_uint128_t
+_borast_uint128_mul (borast_uint128_t a, borast_uint128_t b)
 {
-    cairo_uint128_t	s;
+    borast_uint128_t	s;
 
-    s = _cairo_uint64x64_128_mul (a.lo, b.lo);
-    s.hi = _cairo_uint64_add (s.hi,
-				_cairo_uint64_mul (a.lo, b.hi));
-    s.hi = _cairo_uint64_add (s.hi,
-				_cairo_uint64_mul (a.hi, b.lo));
+    s = _borast_uint64x64_128_mul (a.lo, b.lo);
+    s.hi = _borast_uint64_add (s.hi,
+				_borast_uint64_mul (a.lo, b.hi));
+    s.hi = _borast_uint64_add (s.hi,
+				_borast_uint64_mul (a.hi, b.lo));
     return s;
 }
 
-cairo_uint128_t
-_cairo_uint128_lsl (cairo_uint128_t a, int shift)
+borast_uint128_t
+_borast_uint128_lsl (borast_uint128_t a, int shift)
 {
     if (shift >= 64)
     {
 	a.hi = a.lo;
-	a.lo = _cairo_uint32_to_uint64 (0);
+	a.lo = _borast_uint32_to_uint64 (0);
 	shift -= 64;
     }
     if (shift)
     {
-	a.hi = _cairo_uint64_add (_cairo_uint64_lsl (a.hi, shift),
-				    _cairo_uint64_rsl (a.lo, (64 - shift)));
-	a.lo = _cairo_uint64_lsl (a.lo, shift);
+	a.hi = _borast_uint64_add (_borast_uint64_lsl (a.hi, shift),
+				    _borast_uint64_rsl (a.lo, (64 - shift)));
+	a.lo = _borast_uint64_lsl (a.lo, shift);
     }
     return a;
 }
 
-cairo_uint128_t
-_cairo_uint128_rsl (cairo_uint128_t a, int shift)
+borast_uint128_t
+_borast_uint128_rsl (borast_uint128_t a, int shift)
 {
     if (shift >= 64)
     {
 	a.lo = a.hi;
-	a.hi = _cairo_uint32_to_uint64 (0);
+	a.hi = _borast_uint32_to_uint64 (0);
 	shift -= 64;
     }
     if (shift)
     {
-	a.lo = _cairo_uint64_add (_cairo_uint64_rsl (a.lo, shift),
-				    _cairo_uint64_lsl (a.hi, (64 - shift)));
-	a.hi = _cairo_uint64_rsl (a.hi, shift);
+	a.lo = _borast_uint64_add (_borast_uint64_rsl (a.lo, shift),
+				    _borast_uint64_lsl (a.hi, (64 - shift)));
+	a.hi = _borast_uint64_rsl (a.hi, shift);
     }
     return a;
 }
 
-cairo_uint128_t
-_cairo_uint128_rsa (cairo_int128_t a, int shift)
+borast_uint128_t
+_borast_uint128_rsa (borast_int128_t a, int shift)
 {
     if (shift >= 64)
     {
 	a.lo = a.hi;
-	a.hi = _cairo_uint64_rsa (a.hi, 64-1);
+	a.hi = _borast_uint64_rsa (a.hi, 64-1);
 	shift -= 64;
     }
     if (shift)
     {
-	a.lo = _cairo_uint64_add (_cairo_uint64_rsl (a.lo, shift),
-				    _cairo_uint64_lsl (a.hi, (64 - shift)));
-	a.hi = _cairo_uint64_rsa (a.hi, shift);
+	a.lo = _borast_uint64_add (_borast_uint64_rsl (a.lo, shift),
+				    _borast_uint64_lsl (a.hi, (64 - shift)));
+	a.hi = _borast_uint64_rsa (a.hi, shift);
     }
     return a;
 }
 
 int
-_cairo_uint128_lt (cairo_uint128_t a, cairo_uint128_t b)
+_borast_uint128_lt (borast_uint128_t a, borast_uint128_t b)
 {
-    return (_cairo_uint64_lt (a.hi, b.hi) ||
-	    (_cairo_uint64_eq (a.hi, b.hi) &&
-	     _cairo_uint64_lt (a.lo, b.lo)));
+    return (_borast_uint64_lt (a.hi, b.hi) ||
+	    (_borast_uint64_eq (a.hi, b.hi) &&
+	     _borast_uint64_lt (a.lo, b.lo)));
 }
 
 int
-_cairo_int128_lt (cairo_int128_t a, cairo_int128_t b)
+_borast_int128_lt (borast_int128_t a, borast_int128_t b)
 {
-    if (_cairo_int128_negative (a) && !_cairo_int128_negative (b))
+    if (_borast_int128_negative (a) && !_borast_int128_negative (b))
 	return 1;
-    if (!_cairo_int128_negative (a) && _cairo_int128_negative (b))
+    if (!_borast_int128_negative (a) && _borast_int128_negative (b))
 	return 0;
-    return _cairo_uint128_lt (a, b);
+    return _borast_uint128_lt (a, b);
 }
 
 int
-_cairo_uint128_cmp (cairo_uint128_t a, cairo_uint128_t b)
+_borast_uint128_cmp (borast_uint128_t a, borast_uint128_t b)
 {
     int cmp;
 
-    cmp = _cairo_uint64_cmp (a.hi, b.hi);
+    cmp = _borast_uint64_cmp (a.hi, b.hi);
     if (cmp)
 	return cmp;
-    return _cairo_uint64_cmp (a.lo, b.lo);
+    return _borast_uint64_cmp (a.lo, b.lo);
 }
 
 int
-_cairo_int128_cmp (cairo_int128_t a, cairo_int128_t b)
+_borast_int128_cmp (borast_int128_t a, borast_int128_t b)
 {
-    if (_cairo_int128_negative (a) && !_cairo_int128_negative (b))
+    if (_borast_int128_negative (a) && !_borast_int128_negative (b))
 	return -1;
-    if (!_cairo_int128_negative (a) && _cairo_int128_negative (b))
+    if (!_borast_int128_negative (a) && _borast_int128_negative (b))
 	return 1;
 
-    return _cairo_uint128_cmp (a, b);
+    return _borast_uint128_cmp (a, b);
 }
 
 int
-_cairo_uint128_eq (cairo_uint128_t a, cairo_uint128_t b)
+_borast_uint128_eq (borast_uint128_t a, borast_uint128_t b)
 {
-    return (_cairo_uint64_eq (a.hi, b.hi) &&
-	    _cairo_uint64_eq (a.lo, b.lo));
+    return (_borast_uint64_eq (a.hi, b.hi) &&
+	    _borast_uint64_eq (a.lo, b.lo));
 }
 
 #if HAVE_UINT64_T
-#define _cairo_msbset64(q)  (q & ((uint64_t) 1 << 63))
+#define _borast_msbset64(q)  (q & ((uint64_t) 1 << 63))
 #else
-#define _cairo_msbset64(q)  (q.hi & ((uint32_t) 1 << 31))
+#define _borast_msbset64(q)  (q.hi & ((uint32_t) 1 << 31))
 #endif
 
-cairo_uquorem128_t
-_cairo_uint128_divrem (cairo_uint128_t num, cairo_uint128_t den)
+borast_uquorem128_t
+_borast_uint128_divrem (borast_uint128_t num, borast_uint128_t den)
 {
-    cairo_uquorem128_t	qr;
-    cairo_uint128_t	bit;
-    cairo_uint128_t	quo;
+    borast_uquorem128_t	qr;
+    borast_uint128_t	bit;
+    borast_uint128_t	quo;
 
-    bit = _cairo_uint32_to_uint128 (1);
+    bit = _borast_uint32_to_uint128 (1);
 
     /* normalize to make den >= num, but not overflow */
-    while (_cairo_uint128_lt (den, num) && !_cairo_msbset64(den.hi))
+    while (_borast_uint128_lt (den, num) && !_borast_msbset64(den.hi))
     {
-	bit = _cairo_uint128_lsl (bit, 1);
-	den = _cairo_uint128_lsl (den, 1);
+	bit = _borast_uint128_lsl (bit, 1);
+	den = _borast_uint128_lsl (den, 1);
     }
-    quo = _cairo_uint32_to_uint128 (0);
+    quo = _borast_uint32_to_uint128 (0);
 
     /* generate quotient, one bit at a time */
-    while (_cairo_uint128_ne (bit, _cairo_uint32_to_uint128(0)))
+    while (_borast_uint128_ne (bit, _borast_uint32_to_uint128(0)))
     {
-	if (_cairo_uint128_le (den, num))
+	if (_borast_uint128_le (den, num))
 	{
-	    num = _cairo_uint128_sub (num, den);
-	    quo = _cairo_uint128_add (quo, bit);
+	    num = _borast_uint128_sub (num, den);
+	    quo = _borast_uint128_add (quo, bit);
 	}
-	bit = _cairo_uint128_rsl (bit, 1);
-	den = _cairo_uint128_rsl (den, 1);
+	bit = _borast_uint128_rsl (bit, 1);
+	den = _borast_uint128_rsl (den, 1);
     }
     qr.quo = quo;
     qr.rem = num;
     return qr;
 }
 
-cairo_int128_t
-_cairo_int128_negate (cairo_int128_t a)
+borast_int128_t
+_borast_int128_negate (borast_int128_t a)
 {
-    a.lo = _cairo_uint64_not (a.lo);
-    a.hi = _cairo_uint64_not (a.hi);
-    return _cairo_uint128_add (a, _cairo_uint32_to_uint128 (1));
+    a.lo = _borast_uint64_not (a.lo);
+    a.hi = _borast_uint64_not (a.hi);
+    return _borast_uint128_add (a, _borast_uint32_to_uint128 (1));
 }
 
-cairo_int128_t
-_cairo_int128_not (cairo_int128_t a)
+borast_int128_t
+_borast_int128_not (borast_int128_t a)
 {
-    a.lo = _cairo_uint64_not (a.lo);
-    a.hi = _cairo_uint64_not (a.hi);
+    a.lo = _borast_uint64_not (a.lo);
+    a.hi = _borast_uint64_not (a.hi);
     return a;
 }
 
 #endif /* !HAVE_UINT128_T */
 
-cairo_quorem128_t
-_cairo_int128_divrem (cairo_int128_t num, cairo_int128_t den)
+borast_quorem128_t
+_borast_int128_divrem (borast_int128_t num, borast_int128_t den)
 {
-    int			num_neg = _cairo_int128_negative (num);
-    int			den_neg = _cairo_int128_negative (den);
-    cairo_uquorem128_t	uqr;
-    cairo_quorem128_t	qr;
+    int			num_neg = _borast_int128_negative (num);
+    int			den_neg = _borast_int128_negative (den);
+    borast_uquorem128_t	uqr;
+    borast_quorem128_t	qr;
 
     if (num_neg)
-	num = _cairo_int128_negate (num);
+	num = _borast_int128_negate (num);
     if (den_neg)
-	den = _cairo_int128_negate (den);
-    uqr = _cairo_uint128_divrem (num, den);
+	den = _borast_int128_negate (den);
+    uqr = _borast_uint128_divrem (num, den);
     if (num_neg)
-	qr.rem = _cairo_int128_negate (uqr.rem);
+	qr.rem = _borast_int128_negate (uqr.rem);
     else
 	qr.rem = uqr.rem;
     if (num_neg != den_neg)
-	qr.quo = _cairo_int128_negate (uqr.quo);
+	qr.quo = _borast_int128_negate (uqr.quo);
     else
 	qr.quo = uqr.quo;
     return qr;
 }
 
 /**
- * _cairo_uint_96by64_32x64_divrem:
+ * _borast_uint_96by64_32x64_divrem:
  *
  * Compute a 32 bit quotient and 64 bit remainder of a 96 bit unsigned
  * dividend and 64 bit divisor.  If the quotient doesn't fit into 32
@@ -673,31 +673,31 @@ _cairo_int128_divrem (cairo_int128_t num, cairo_int128_t den)
  * quotient is the largest representable 64 bit integer.  It is an
  * error to call this function with the high 32 bits of @num being
  * non-zero. */
-cairo_uquorem64_t
-_cairo_uint_96by64_32x64_divrem (cairo_uint128_t num,
-				 cairo_uint64_t den)
+borast_uquorem64_t
+_borast_uint_96by64_32x64_divrem (borast_uint128_t num,
+				 borast_uint64_t den)
 {
-    cairo_uquorem64_t result;
-    cairo_uint64_t B = _cairo_uint32s_to_uint64 (1, 0);
+    borast_uquorem64_t result;
+    borast_uint64_t B = _borast_uint32s_to_uint64 (1, 0);
 
     /* These are the high 64 bits of the *96* bit numerator.  We're
      * going to represent the numerator as xB + y, where x is a 64,
      * and y is a 32 bit number. */
-    cairo_uint64_t x = _cairo_uint128_to_uint64 (_cairo_uint128_rsl(num, 32));
+    borast_uint64_t x = _borast_uint128_to_uint64 (_borast_uint128_rsl(num, 32));
 
     /* Initialise the result to indicate overflow. */
-    result.quo = _cairo_uint32s_to_uint64 (-1U, -1U);
+    result.quo = _borast_uint32s_to_uint64 (-1U, -1U);
     result.rem = den;
 
     /* Don't bother if the quotient is going to overflow. */
-    if (_cairo_uint64_ge (x, den)) {
+    if (_borast_uint64_ge (x, den)) {
 	return /* overflow */ result;
     }
 
-    if (_cairo_uint64_lt (x, B)) {
+    if (_borast_uint64_lt (x, B)) {
 	/* When the final quotient is known to fit in 32 bits, then
 	 * num < 2^64 if and only if den < 2^32. */
-	return _cairo_uint64_divrem (_cairo_uint128_to_uint64 (num), den);
+	return _borast_uint64_divrem (_borast_uint128_to_uint64 (num), den);
     }
     else {
 	/* Denominator is >= 2^32. the numerator is >= 2^64, and the
@@ -707,9 +707,9 @@ _cairo_uint_96by64_32x64_divrem (cairo_uint128_t num,
 	 *	num = xB + y		x : 64 bits, y : 32 bits
 	 *	den = uB + v		u, v : 32 bits
 	 */
-	uint32_t y = _cairo_uint128_to_uint32 (num);
+	uint32_t y = _borast_uint128_to_uint32 (num);
 	uint32_t u = uint64_hi32 (den);
-	uint32_t v = _cairo_uint64_to_uint32 (den);
+	uint32_t v = _borast_uint64_to_uint32 (den);
 
 	/* Compute a lower bound approximate quotient of num/den
 	 * from x/(u+1).  Then we have
@@ -731,8 +731,8 @@ _cairo_uint_96by64_32x64_divrem (cairo_uint128_t num,
 	 * quotient, and as B-v <= 2^32, we may safely use a single
 	 * 64/64 bit division to find its contribution. */
 
-	cairo_uquorem64_t quorem;
-	cairo_uint64_t remainder; /* will contain final remainder */
+	borast_uquorem64_t quorem;
+	borast_uint64_t remainder; /* will contain final remainder */
 	uint32_t quotient;	/* will contain final quotient. */
 	uint32_t q;
 	uint32_t r;
@@ -740,79 +740,79 @@ _cairo_uint_96by64_32x64_divrem (cairo_uint128_t num,
 	/* Approximate quotient by dividing the high 64 bits of num by
 	 * u+1. Watch out for overflow of u+1. */
 	if (u+1) {
-	    quorem = _cairo_uint64_divrem (x, _cairo_uint32_to_uint64 (u+1));
-	    q = _cairo_uint64_to_uint32 (quorem.quo);
-	    r = _cairo_uint64_to_uint32 (quorem.rem);
+	    quorem = _borast_uint64_divrem (x, _borast_uint32_to_uint64 (u+1));
+	    q = _borast_uint64_to_uint32 (quorem.quo);
+	    r = _borast_uint64_to_uint32 (quorem.rem);
 	}
 	else {
 	    q = uint64_hi32 (x);
-	    r = _cairo_uint64_to_uint32 (x);
+	    r = _borast_uint64_to_uint32 (x);
 	}
 	quotient = q;
 
 	/* Add the main term's contribution to quotient.  Note B-v =
 	 * -v as an uint32 (unless v = 0) */
 	if (v)
-	    quorem = _cairo_uint64_divrem (_cairo_uint32x32_64_mul (q, -v), den);
+	    quorem = _borast_uint64_divrem (_borast_uint32x32_64_mul (q, -v), den);
 	else
-	    quorem = _cairo_uint64_divrem (_cairo_uint32s_to_uint64 (q, 0), den);
-	quotient += _cairo_uint64_to_uint32 (quorem.quo);
+	    quorem = _borast_uint64_divrem (_borast_uint32s_to_uint64 (q, 0), den);
+	quotient += _borast_uint64_to_uint32 (quorem.quo);
 
 	/* Add the contribution of the subterm and start computing the
 	 * true remainder. */
-	remainder = _cairo_uint32s_to_uint64 (r, y);
-	if (_cairo_uint64_ge (remainder, den)) {
-	    remainder = _cairo_uint64_sub (remainder, den);
+	remainder = _borast_uint32s_to_uint64 (r, y);
+	if (_borast_uint64_ge (remainder, den)) {
+	    remainder = _borast_uint64_sub (remainder, den);
 	    quotient++;
 	}
 
 	/* Add the contribution of the main term's remainder. The
 	 * funky test here checks that remainder + main_rem >= den,
 	 * taking into account overflow of the addition. */
-	remainder = _cairo_uint64_add (remainder, quorem.rem);
-	if (_cairo_uint64_ge (remainder, den) ||
-	    _cairo_uint64_lt (remainder, quorem.rem))
+	remainder = _borast_uint64_add (remainder, quorem.rem);
+	if (_borast_uint64_ge (remainder, den) ||
+	    _borast_uint64_lt (remainder, quorem.rem))
 	{
-	    remainder = _cairo_uint64_sub (remainder, den);
+	    remainder = _borast_uint64_sub (remainder, den);
 	    quotient++;
 	}
 
-	result.quo = _cairo_uint32_to_uint64 (quotient);
+	result.quo = _borast_uint32_to_uint64 (quotient);
 	result.rem = remainder;
     }
     return result;
 }
 
-cairo_quorem64_t
-_cairo_int_96by64_32x64_divrem (cairo_int128_t num, cairo_int64_t den)
+borast_quorem64_t
+_borast_int_96by64_32x64_divrem (borast_int128_t num, borast_int64_t den)
 {
-    int			num_neg = _cairo_int128_negative (num);
-    int			den_neg = _cairo_int64_negative (den);
-    cairo_uint64_t	nonneg_den;
-    cairo_uquorem64_t	uqr;
-    cairo_quorem64_t	qr;
+    int			num_neg = _borast_int128_negative (num);
+    int			den_neg = _borast_int64_negative (den);
+    borast_uint64_t	nonneg_den;
+    borast_uquorem64_t	uqr;
+    borast_quorem64_t	qr;
 
     if (num_neg)
-	num = _cairo_int128_negate (num);
+	num = _borast_int128_negate (num);
     if (den_neg)
-	nonneg_den = _cairo_int64_negate (den);
+	nonneg_den = _borast_int64_negate (den);
     else
 	nonneg_den = den;
 
-    uqr = _cairo_uint_96by64_32x64_divrem (num, nonneg_den);
-    if (_cairo_uint64_eq (uqr.rem, nonneg_den)) {
+    uqr = _borast_uint_96by64_32x64_divrem (num, nonneg_den);
+    if (_borast_uint64_eq (uqr.rem, nonneg_den)) {
 	/* bail on overflow. */
-	qr.quo = _cairo_uint32s_to_uint64 (0x7FFFFFFF, -1U);;
+	qr.quo = _borast_uint32s_to_uint64 (0x7FFFFFFF, -1U);;
 	qr.rem = den;
 	return qr;
     }
 
     if (num_neg)
-	qr.rem = _cairo_int64_negate (uqr.rem);
+	qr.rem = _borast_int64_negate (uqr.rem);
     else
 	qr.rem = uqr.rem;
     if (num_neg != den_neg)
-	qr.quo = _cairo_int64_negate (uqr.quo);
+	qr.quo = _borast_int64_negate (uqr.quo);
     else
 	qr.quo = uqr.quo;
     return qr;
diff --git a/src/borast/borastint-minimal.h b/src/borast/borastint-minimal.h
index 4b6d20b..ba0f8eb 100644
--- a/src/borast/borastint-minimal.h
+++ b/src/borast/borastint-minimal.h
@@ -43,15 +43,15 @@
  * existing published interfaces. cworth@cworth.org
  */
 
-#ifndef _CAIROINT_H_
-#define _CAIROINT_H_
+#ifndef _BORASTINT_H_
+#define _BORASTINT_H_
 
 #if HAVE_CONFIG_H
 #include "config.h"
 #endif
 
 #ifdef _MSC_VER
-#define cairo_public __declspec(dllexport)
+#define borast_public __declspec(dllexport)
 #endif
 
 #include <assert.h>
@@ -67,16 +67,16 @@
 #include <limits.h>
 #include <stdio.h>
 
-#include "cairo-minimal.h"
+#include "borast-minimal.h"
 
-#include "cairo-compiler-private.h"
+#include "borast-compiler-private.h"
 
-CAIRO_BEGIN_DECLS
+BORAST_BEGIN_DECLS
 
 #if _WIN32 && !_WIN32_WCE /* Permissions on WinCE? No worries! */
-cairo_private FILE *
-_cairo_win32_tmpfile (void);
-#define tmpfile() _cairo_win32_tmpfile()
+borast_private FILE *
+_borast_win32_tmpfile (void);
+#define tmpfile() _borast_win32_tmpfile()
 #endif
 
 #undef MIN
@@ -114,12 +114,12 @@ _cairo_win32_tmpfile (void);
 #define STRINGIFY_ARG(contents)       #contents
 
 #if defined (__GNUC__)
-#define cairo_container_of(ptr, type, member) ({ \
+#define borast_container_of(ptr, type, member) ({ \
     const __typeof__ (((type *) 0)->member) *mptr__ = (ptr); \
     (type *) ((char *) mptr__ - offsetof (type, member)); \
 })
 #else
-#define cairo_container_of(ptr, type, member) \
+#define borast_container_of(ptr, type, member) \
     (type *)((char *) (ptr) - (char *) &((type *)0)->member)
 #endif
 
@@ -127,14 +127,14 @@ _cairo_win32_tmpfile (void);
 /* Size in bytes of buffer to use off the stack per functions.
  * Mostly used by text functions.  For larger allocations, they'll
  * malloc(). */
-#ifndef CAIRO_STACK_BUFFER_SIZE
-#define CAIRO_STACK_BUFFER_SIZE (512 * sizeof (int))
+#ifndef BORAST_STACK_BUFFER_SIZE
+#define BORAST_STACK_BUFFER_SIZE (512 * sizeof (int))
 #endif
 
-#define CAIRO_STACK_ARRAY_LENGTH(T) (CAIRO_STACK_BUFFER_SIZE / sizeof(T))
+#define BORAST_STACK_ARRAY_LENGTH(T) (BORAST_STACK_BUFFER_SIZE / sizeof(T))
 
 
-#include "cairo-types-private.h"
+#include "borast-types-private.h"
 
 #if HAVE_VALGRIND
 # include <memcheck.h>
diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index da6b4a0..eb44deb 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -637,11 +637,11 @@ hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale
   PLINE *contour;
   struct do_hole_info info;
   int stencil_bit;
-  cairo_traps_t traps;
+  borast_traps_t traps;
 
-  _cairo_traps_init (&traps);
+  _borast_traps_init (&traps);
   bo_poly_to_traps (poly->Clipped, &traps);
-  _cairo_traps_fini (&traps);
+  _borast_traps_fini (&traps);
 
   return;
 
diff --git a/src/sweep.h b/src/sweep.h
index 3af86b8..110466d 100644
--- a/src/sweep.h
+++ b/src/sweep.h
@@ -1,4 +1,4 @@
-#include "borast/cairo-traps-private.h"
+#include "borast/borast-traps-private.h"
 
-cairo_status_t bo_poly_to_traps (POLYAREA *poly, cairo_traps_t *traps);
-cairo_status_t bo_contour_to_traps (PLINE *contour, cairo_traps_t *traps);
+borast_status_t bo_poly_to_traps (POLYAREA *poly, borast_traps_t *traps);
+borast_status_t bo_contour_to_traps (PLINE *contour, borast_traps_t *traps);

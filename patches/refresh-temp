Bottom: 64afe10812f2173654a14893191aa01af0de2256
Top:    8ee3ce9e11e8d76d8c779652286edb75f7b72869
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-12-06 21:17:19 +0000

Refresh of play-with-glsl-shader-for-rend

---

diff --git a/src/cairo/cairo-bentley-ottmann.c b/src/cairo/cairo-bentley-ottmann.c
index 9c9d43e..fcc0e66 100644
--- a/src/cairo/cairo-bentley-ottmann.c
+++ b/src/cairo/cairo-bentley-ottmann.c
@@ -126,7 +126,7 @@ typedef struct _cairo_bo_sweep_line {
 } cairo_bo_sweep_line_t;
 
 
-/*static*/ cairo_fixed_t
+static cairo_fixed_t
 _line_compute_intersection_x_for_y (const cairo_line_t *line,
                                     cairo_fixed_t y)
 {
@@ -1451,21 +1451,9 @@ bo_poly_to_traps (POLYAREA *poly, cairo_traps_t *traps)
       hidgl_ensure_triangle_space (&buffer, 1);
       hidgl_add_triangle (&buffer, x1, y1, x2, y2, x3, y3);
     } else {
-#if 0
       hidgl_ensure_triangle_space (&buffer, 2);
       hidgl_add_triangle (&buffer, x1, y1, x2, y2, x3, y3);
       hidgl_add_triangle (&buffer, x3, y3, x4, y4, x1, y1);
-#endif
-      hidgl_ensure_vertex_space (&buffer, 6);
-
-      /* NB: Repeated first virtex to separate from other tri-strip */
-      hidgl_add_vertex_tex (&buffer, x2, y2, 0.0, 0.0);
-      hidgl_add_vertex_tex (&buffer, x2, y2, 0.0, 0.0);
-      hidgl_add_vertex_tex (&buffer, x1, y1, 0.0, 0.0);
-      hidgl_add_vertex_tex (&buffer, x3, y3, 0.0, 0.0);
-      hidgl_add_vertex_tex (&buffer, x4, y4, 0.0, 0.0);
-      hidgl_add_vertex_tex (&buffer, x4, y4, 0.0, 0.0);
-      /* NB: Repeated last virtex to separate from other tri-strip */
     }
 #else
     glBegin (GL_LINES);
@@ -1489,6 +1477,7 @@ bo_poly_to_traps (POLYAREA *poly, cairo_traps_t *traps)
   return CAIRO_STATUS_SUCCESS;
 }
 
+
 cairo_status_t
 bo_contour_to_traps (PLINE *contour, cairo_traps_t *traps)
 {
@@ -1578,57 +1567,3 @@ bo_contour_to_traps (PLINE *contour, cairo_traps_t *traps)
 
   return CAIRO_STATUS_SUCCESS;
 }
-
-
-cairo_status_t
-bo_contour_to_traps_no_draw (PLINE *contour, cairo_traps_t *traps)
-{
-  int intersections;
-  cairo_status_t status;
-  cairo_bo_start_event_t stack_events[CAIRO_STACK_ARRAY_LENGTH (cairo_bo_start_event_t)];
-  cairo_bo_start_event_t *events;
-  cairo_bo_event_t *stack_event_ptrs[ARRAY_LENGTH (stack_events) + 1];
-  cairo_bo_event_t **event_ptrs;
-  int num_events = 0;
-  int i;
-
-  num_events = contour->Count;
-
-  if (unlikely (0 == num_events))
-      return CAIRO_STATUS_SUCCESS;
-
-  events = stack_events;
-  event_ptrs = stack_event_ptrs;
-  if (num_events > ARRAY_LENGTH (stack_events)) {
-      events = _cairo_malloc_ab_plus_c (num_events,
-                                        sizeof (cairo_bo_start_event_t) +
-                                        sizeof (cairo_bo_event_t *),
-                                        sizeof (cairo_bo_event_t *));
-      if (unlikely (events == NULL))
-          return CAIRO_STATUS_NO_MEMORY;
-
-      event_ptrs = (cairo_bo_event_t **) (events + num_events);
-  }
-
-  i = 0;
-
-  contour_to_start_events (contour, events, event_ptrs, &i, 1);
-
-  /* XXX: This would be the convenient place to throw in multiple
-   * passes of the Bentley-Ottmann algorithm. It would merely
-   * require storing the results of each pass into a temporary
-   * cairo_traps_t. */
-  status = _cairo_bentley_ottmann_tessellate_bo_edges (event_ptrs,
-                                                       num_events,
-                                                       traps,
-                                                       &intersections);
-
-#if DEBUG_TRAPS
-  dump_traps (traps, "bo-polygon-out.txt");
-#endif
-
-  if (events != stack_events)
-      free (events);
-
-  return CAIRO_STATUS_SUCCESS;
-}
diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index 3448565..a4ffc0a 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -697,148 +697,38 @@ hidgl_fill_polygon (int n_coords, int *x, int *y)
   free (vertices);
 }
 
-static inline void
-stash_vertex (PLINE *contour, int *vertex_comp,
-              float x, float y, float z, float r, float s)
-{
-  contour->tristrip_vertices[(*vertex_comp)++] = x;
-  contour->tristrip_vertices[(*vertex_comp)++] = y;
-#if MEMCPY_VERTEX_DATA
-  contour->tristrip_vertices[(*vertex_comp)++] = z;
-  contour->tristrip_vertices[(*vertex_comp)++] = r;
-  contour->tristrip_vertices[(*vertex_comp)++] = s;
-#endif
-  contour->tristrip_num_vertices ++;
-}
-
-static void
-fill_contour (PLINE *contour)
-{
-  int i;
-  int vertex_comp;
-  cairo_traps_t traps;
-
-  /* If the contour is round, then call hidgl_fill_circle to draw it. */
-  if (contour->is_round) {
-    hidgl_fill_circle (contour->cx, contour->cy, contour->radius);
-    return;
-  }
-
-  /* If we don't have a cached set of tri-strips, compute them */
-  if (contour->tristrip_vertices == NULL) {
-    int tristrip_space;
-    int x1, x2, x3, x4, y_top, y_bot;
-
-    _cairo_traps_init (&traps);
-    bo_contour_to_traps_no_draw (contour, &traps);
-
-    tristrip_space = 0;
-
-    for (i = 0; i < traps.num_traps; i++) {
-      y_top = traps.traps[i].top;
-      y_bot = traps.traps[i].bottom;
-
-      x1 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_top);
-      x2 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_top);
-      x3 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_bot);
-      x4 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_bot);
-
-      if ((x1 == x2) || (x3 == x4)) {
-        tristrip_space += 5; /* Three vertices + repeated start and end */
-      } else {
-        tristrip_space += 6; /* Four vertices + repeated start and end */
-      }
-    }
-
-    if (tristrip_space == 0) {
-      printf ("Strange, contour didn't tesselate\n");
-      return;
-    }
-
-#if MEMCPY_VERTEX_DATA
-    /* NB: MEMCPY of vertex data causes a problem with depth being cached at the wrong level! */
-    contour->tristrip_vertices = malloc (sizeof (float) * 5 * tristrip_space);
-#else
-    contour->tristrip_vertices = malloc (sizeof (float) * 2 * tristrip_space);
-#endif
-    contour->tristrip_num_vertices = 0;
-
-    vertex_comp = 0;
-    for (i = 0; i < traps.num_traps; i++) {
-      y_top = traps.traps[i].top;
-      y_bot = traps.traps[i].bottom;
-
-      x1 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_top);
-      x2 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_top);
-      x3 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_bot);
-      x4 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_bot);
-
-      if (x1 == x2) {
-        /* NB: Repeated first virtex to separate from other tri-strip */
-        stash_vertex (contour, &vertex_comp, x1, y_top, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x1, y_top, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x3, y_bot, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x4, y_bot, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x4, y_bot, global_depth, 0.0, 0.0);
-        /* NB: Repeated last virtex to separate from other tri-strip */
-      } else if (x3 == x4) {
-        /* NB: Repeated first virtex to separate from other tri-strip */
-        stash_vertex (contour, &vertex_comp, x1, y_top, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x1, y_top, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x2, y_top, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x3, y_bot, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x3, y_bot, global_depth, 0.0, 0.0);
-        /* NB: Repeated last virtex to separate from other tri-strip */
-      } else {
-        /* NB: Repeated first virtex to separate from other tri-strip */
-        stash_vertex (contour, &vertex_comp, x2, y_top, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x2, y_top, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x3, y_bot, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x1, y_top, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x4, y_bot, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x4, y_bot, global_depth, 0.0, 0.0);
-        /* NB: Repeated last virtex to separate from other tri-strip */
-      }
-    }
-
-    _cairo_traps_fini (&traps);
-  }
-
-  if (contour->tristrip_num_vertices == 0)
-    return;
-
-  hidgl_ensure_vertex_space (&buffer, contour->tristrip_num_vertices);
-
-#if MEMCPY_VERTEX_DATA
-  memcpy (&buffer.triangle_array[buffer.coord_comp_count],
-          contour->tristrip_vertices,
-          sizeof (float) * 5 * contour->tristrip_num_vertices);
-  buffer.coord_comp_count += 5 * contour->tristrip_num_vertices;
-  buffer.vertex_count += contour->tristrip_num_vertices;
-
-#else
-  vertex_comp = 0;
-  for (i = 0; i < contour->tristrip_num_vertices; i++) {
-    int x, y;
-    x = contour->tristrip_vertices[vertex_comp++];
-    y = contour->tristrip_vertices[vertex_comp++];
-    hidgl_add_vertex_tex (&buffer, x, y, 0.0, 0.0);
-  }
-#endif
-
-}
+struct do_hole_info {
+  double scale;
+};
 
 static int
 do_hole (const BoxType *b, void *cl)
 {
+  struct do_hole_info *info = cl;
   PLINE *curc = (PLINE *) b;
+  cairo_traps_t traps;
 
   /* Ignore the outer contour - we draw it first explicitly*/
   if (curc->Flags.orient == PLF_DIR) {
     return 0;
   }
 
-  fill_contour (curc);
+  /* If the contour is round, and hidgl_fill_circle would use
+   * less slices than we have vertices to draw it, then call
+   * hidgl_fill_circle to draw this contour.
+   */
+  if (curc->is_round) {
+    double slices = calc_slices (curc->radius / info->scale, 2 * M_PI);
+    if (slices < curc->Count) {
+      hidgl_fill_circle (curc->cx, curc->cy, curc->radius, info->scale);
+      return 1;
+    }
+  }
+
+  _cairo_traps_init (&traps);
+  bo_contour_to_traps (curc, &traps);
+  _cairo_traps_fini (&traps);
+
   return 1;
 }
 
@@ -848,11 +738,15 @@ static int assigned_bits = 0;
 
 /* FIXME: JUST DRAWS THE FIRST PIECE.. TODO: SUPPORT FOR FULLPOLY POLYGONS */
 void
-hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box)
+hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale)
 {
+  struct do_hole_info info;
   int stencil_bit;
+  cairo_traps_t traps;
 
   CHECK_IS_IN_CONTEXT ();
+  info.scale = scale;
+  global_scale = scale;
 
   if (poly->Clipped == NULL)
     {
@@ -882,7 +776,7 @@ hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box)
    */
   /* Drawing operations now set our reference bit in the stencil buffer */
 
-  r_search (poly->Clipped->contour_tree, clip_box, NULL, do_hole, NULL);
+  r_search (poly->Clipped->contour_tree, clip_box, NULL, do_hole, &info);
   hidgl_flush_triangles (&buffer);
 
   /* Drawing operations as masked to areas where the stencil buffer is '0' */
@@ -898,7 +792,9 @@ hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box)
                                                               // any bits permitted by the stencil writemask
 
   /* Draw the polygon outer */
-  fill_contour (poly->Clipped->contours);
+  _cairo_traps_init (&traps);
+  bo_contour_to_traps (poly->Clipped->contours, &traps);
+  _cairo_traps_fini (&traps);
   hidgl_flush_triangles (&buffer);
 
   /* Unassign our stencil buffer bit */
diff --git a/src/polyarea.h b/src/polyarea.h
index 62a1125..ce427ad 100644
--- a/src/polyarea.h
+++ b/src/polyarea.h
@@ -107,8 +107,6 @@ struct PLINE
       unsigned int status:3;
       unsigned int orient:1;
     } Flags;
-    int tristrip_num_vertices;
-    float *tristrip_vertices;
 };
 
 PLINE *poly_NewContour(Vector v);
diff --git a/src/polygon1.c b/src/polygon1.c
index 5419863..468c139 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -2553,9 +2553,6 @@ poly_ClrContour (PLINE * c)
       poly_ExclVertex (cur);
       free (cur);
     }
-  free (c->tristrip_vertices);
-  c->tristrip_vertices = NULL;
-  c->tristrip_num_vertices = 0;
   poly_IniContour (c);
 }
 
@@ -2587,7 +2584,6 @@ poly_DelContour (PLINE ** c)
       rtree_t *r = (*c)->tree;
       r_destroy_tree (&r);
     }
-  free ((*c)->tristrip_vertices);
   free (*c), *c = NULL;
 }
 
diff --git a/src/sweep.h b/src/sweep.h
index 92fdd71..257664f 100644
--- a/src/sweep.h
+++ b/src/sweep.h
@@ -2,5 +2,3 @@
 
 cairo_status_t bo_poly_to_traps (POLYAREA *poly, cairo_traps_t *traps);
 cairo_status_t bo_contour_to_traps (PLINE *contour, cairo_traps_t *traps);
-cairo_status_t bo_contour_to_traps_no_draw (PLINE *contour, cairo_traps_t *traps);
-cairo_fixed_t _line_compute_intersection_x_for_y (const cairo_line_t *line, cairo_fixed_t y);

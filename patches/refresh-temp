Bottom: c248c9466bb0c424d4772c5aad40704acb2b0e00
Top:    1af827883daa0910a120dc3e4030fd24eb61f678
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-11-20 00:44:53 +0000

Refresh of add-vrml-model-rendering-suppo

---

diff --git a/src/Makefile.am b/src/Makefile.am
index 7c122bd..71e3d0c 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -185,10 +185,14 @@ LIBGTK_GL_SRCS= \
 GL_SRCS= \
 	hid/common/hidgl.c \
 	hid/common/hidgl.h \
+	hid/common/hidgl_material.c \
+	hid/common/hidgl_material.h \
 	hid/common/hidgl_package_acy_resistor.c \
 	hid/common/hidgl_package_vrml.c \
 	hid/common/hidgl_package_vrml_y.y \
 	hid/common/hidgl_package_vrml_l.l \
+	hid/common/hidgl_shaders.c \
+	hid/common/hidgl_shaders.h \
 	hid/common/trackball.c \
 	hid/common/trackball.h
 
diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index 9121b93..6e5c6a1 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -47,6 +47,8 @@ RCSID ("$Id: $");
 
 triangle_buffer buffer;
 float global_depth = 0;
+hidgl_shader *circular_program = NULL;
+hidgl_shader *resistor_program = NULL;
 
 static bool in_context = false;
 
@@ -613,8 +615,6 @@ myBegin (GLenum type)
   triangle_comp_idx = 0;
 }
 
-static double global_scale;
-
 static void
 myVertex (GLdouble *vertex_data)
 {
@@ -631,23 +631,11 @@ myVertex (GLdouble *vertex_data)
         }
       else
         {
-#if 1
           hidgl_ensure_triangle_space (&buffer, 1);
           hidgl_add_triangle (&buffer,
                               triangle_vertices [0], triangle_vertices [1],
                               triangle_vertices [2], triangle_vertices [3],
                               vertex_data [0], vertex_data [1]);
-#else
-          hidgl_draw_line (Square_Cap, global_scale,
-                           triangle_vertices [0], triangle_vertices [1],
-                           triangle_vertices [2], triangle_vertices [3], global_scale);
-          hidgl_draw_line (Square_Cap, global_scale,
-                           triangle_vertices [2], triangle_vertices [3],
-                           vertex_data [0],       vertex_data [1],       global_scale);
-          hidgl_draw_line (Square_Cap, global_scale,
-                           vertex_data [0],       vertex_data [1],
-                           triangle_vertices [0], triangle_vertices [1], global_scale);
-#endif
 
           if (tessVertexType == GL_TRIANGLE_STRIP)
             {
@@ -947,168 +935,49 @@ hidgl_fill_rect (int x1, int y1, int x2, int y2)
   /* NB: Repeated last virtex to separate from other tri-strip */
 }
 
-/* From http://gpwiki.org/index.php/OpenGL:Codes:Simple_GLSL_example */
 static void
-printLog(GLuint obj)
-{
-  int infologLength = 0;
-  int maxLength;
-  char *infoLog;
-
-  if (glIsShader (obj))
-    glGetShaderiv (obj, GL_INFO_LOG_LENGTH, &maxLength);
-  else
-    glGetProgramiv (obj, GL_INFO_LOG_LENGTH, &maxLength);
-
-  infoLog = malloc (maxLength);
-
-  if (glIsShader (obj))
-    glGetShaderInfoLog (obj, maxLength, &infologLength, infoLog);
-  else
-    glGetProgramInfoLog (obj, maxLength, &infologLength, infoLog);
-
-  if (infologLength > 0)
-    printf ("%s\n", infoLog);
-
-  free (infoLog);
-}
-
-/* From http://gpwiki.org/index.php/OpenGL:Codes:Simple_GLSL_example */
-/* FIXED not to be completely brain-dead with memory allocation! - PCJC2*/
-char *
-file2string (const char *path)
-{
-  FILE *fd;
-  long len, r;
-  char *str;
-
-  if (!(fd = fopen (path, "r")))
-    {
-      fprintf (stderr, "Can't open file '%s' for reading\n", path);
-      return NULL;
-    }
-
-  fseek (fd, 0, SEEK_END);
-  len = ftell(fd);
-
-  printf ("File '%s' is %ld long\n", path, len);
-
-  fseek (fd, 0, SEEK_SET);
-
-  if (!(str = malloc (len * sizeof(char))))
-    {
-      fprintf (stderr, "Can't malloc space for '%s'\n", path);
-      return NULL;
-    }
-
-  r = fread (str, sizeof(char), len, fd);
-
-  str[r - 1] = '\0'; /* Shader sources have to term with null */
-
-  fclose (fd);
-
-  return str;
-}
-
-GLuint sp; /* Shader Program */
-GLuint sp2; /* Shader Program2 */
-
-void
-hidgl_load_frag_shader (void)
+load_built_in_shaders (void)
 {
-//  char *vs_source;
-
-  const char *fs_source = "void main()\n"
-                    "{\n"
-                    "  float sqdist;\n"
-                    "  sqdist = dot (gl_TexCoord[0].st, gl_TexCoord[0].st);\n"
-                    "  if (sqdist > 1.0)\n"
-                    "    discard;\n"
-                    "  gl_FragColor = gl_Color;\n"
-                    "}\n";
-
-  const char *fs2_source =
-                    "uniform sampler1D detail_tex;\n"
-                    "uniform sampler2D bump_tex;\n"
-                    "\n"
-                    "void main()\n"
-                    "{\n"
-                    "  vec3 bumpNormal = texture2D (bump_tex, gl_TexCoord[1].st).rgb;\n"
-                    "  vec3 detailColor = texture1D (detail_tex, gl_TexCoord[0].s).rgb;\n"
-                    "\n"
-                    "  /* Uncompress vectors ([0, 1] -> [-1, 1]) */\n"
-                    "  vec3 lightVectorFinal = -1.0 + 2.0 * gl_Color.rgb;\n"
-                    "  vec3 halfVectorFinal = -1.0 + 2.0 * gl_TexCoord[2].xyz;\n"
-                    "  vec3 bumpNormalVectorFinal = -1.0 + 2.0 * bumpNormal;\n"
-//                    "vec3 bumpNormalVectorFinal = vec3(0., 0., 1.);\n"
-                    "\n"
-                    "  /* Compute diffuse factor */\n"
-                    "  float diffuse = clamp(dot(bumpNormalVectorFinal, lightVectorFinal),0.0, 1.0);\n"
-                    "  float specular = pow(clamp(dot(bumpNormalVectorFinal, halfVectorFinal), 0.0, 1.0), 2.0);\n"
-                    "  specular *= 0.4;\n"
-//                    "  float specular = pow(clamp(dot(bumpNormalVectorFinal, lightVectorFinal), 0.0, 1.0), 5.0);\n"
-                    "\n"
-//                    "  gl_FragColor = vec4(clamp((diffuse * 1.0 + 0.0) * detailColor, 0.0, 1.0), 1.0);\n"
-//                    "  gl_FragColor = vec4(detailColor + vec3(specular, specular, specular), 1.0);\n"
-                    "   gl_FragColor = vec4(detailColor * (0.3 + 0.7 * diffuse) + vec3(specular, specular, specular), 1.0);\n"
-//                    "   gl_FragColor =vec4(gl_Color.rgb, 1);\n"
-//                    "   gl_FragColor =vec4(gl_Color.r, gl_Color.r, gl_Color.r, 1.0);\n"
-                    "}\n";
-
-  /* Compile and load the program */
-
-//  GLuint vs; /* Vertex Shader */
-  GLuint fs; /* Fragment Shader */
-
-#if 0
-  vs_source = file2string ("circular.vert");
-  vs = glCreateShader (GL_VERTEX_SHADER);
-  glShaderSource (vs, 1, &vs_source, NULL);
-  glCompileShader (vs);
-  printLog (vs);
-  free (vs_source);
-#endif
-
-//  fs_source = file2string ("circular.frag");
-
-#if 1
-  if (fs_source == NULL)
-    return;
-  fs = glCreateShader (GL_FRAGMENT_SHADER);
-  glShaderSource (fs, 1, &fs_source, NULL);
-  glCompileShader (fs);
-  printLog (fs);
-//  free (fs_source);
-
-  sp = glCreateProgram ();
-//  glAttachShader (sp, vs);
-  glAttachShader (sp, fs);
-  glLinkProgram (sp);
-  printLog (sp);
-
-  glUseProgram (sp);
-#endif
-  {
-  GLfloat waveTime = 0,
-          waveWidth = 0.00001,
-          waveHeight = 10;
-  GLint waveTimeLoc = glGetUniformLocation(sp, "waveTime");
-  GLint waveWidthLoc = glGetUniformLocation(sp, "waveWidth");
-  GLint waveHeightLoc = glGetUniformLocation(sp, "waveHeight");
-  /* Change time */
-  glUniform1f(waveTimeLoc, waveTime);
-  glUniform1f(waveWidthLoc, waveWidth);
-  glUniform1f(waveHeightLoc, waveHeight);
-
-  }
-
-  fs = glCreateShader (GL_FRAGMENT_SHADER);
-  glShaderSource (fs, 1, &fs2_source, NULL);
-  glCompileShader (fs);
-  printLog (fs);
-  sp2 = glCreateProgram ();
-  glAttachShader (sp2, fs);
-  glLinkProgram (sp2);
+  char *circular_fs_source =
+          "void main()\n"
+          "{\n"
+          "  float sqdist;\n"
+          "  sqdist = dot (gl_TexCoord[0].st, gl_TexCoord[0].st);\n"
+          "  if (sqdist > 1.0)\n"
+          "    discard;\n"
+          "  gl_FragColor = gl_Color;\n"
+          "}\n";
+
+  char *resistor_fs_source =
+          "uniform sampler1D detail_tex;\n"
+          "uniform sampler2D bump_tex;\n"
+          "\n"
+          "void main()\n"
+          "{\n"
+          "  vec3 bumpNormal = texture2D (bump_tex, gl_TexCoord[1].st).rgb;\n"
+          "  vec3 detailColor = texture1D (detail_tex, gl_TexCoord[0].s).rgb;\n"
+          "\n"
+          "  /* Uncompress vectors ([0, 1] -> [-1, 1]) */\n"
+          "  vec3 lightVectorFinal = -1.0 + 2.0 * gl_Color.rgb;\n"
+          "  vec3 halfVectorFinal = -1.0 + 2.0 * gl_TexCoord[2].xyz;\n"
+          "  vec3 bumpNormalVectorFinal = -1.0 + 2.0 * bumpNormal;\n"
+          "\n"
+          "  /* Compute diffuse factor */\n"
+          "  float diffuse = clamp(dot(bumpNormalVectorFinal,\n"
+          "                            lightVectorFinal),0.0, 1.0);\n"
+          "  float specular = pow(clamp(dot(bumpNormalVectorFinal,\n"
+          "                                 halfVectorFinal), 0.0, 1.0),\n"
+          "                       2.0);\n"
+          "  specular *= 0.4;\n"
+          "\n"
+          "   gl_FragColor = vec4(detailColor * (0.3 + 0.7 * diffuse) + \n"
+          "                    vec3(specular, specular, specular), 1.0);\n"
+          "}\n";
+
+  circular_program = hidgl_shader_new ("circular_rendering", NULL, circular_fs_source);
+  resistor_program = hidgl_shader_new ("resistor_rendering", NULL, resistor_fs_source);
+
+  hidgl_shader_activate (circular_program);
 }
 
 void
@@ -1135,7 +1004,14 @@ hidgl_init (void)
       /* Do we need to disable that somewhere? */
     }
 
-  hidgl_load_frag_shader ();
+  if (!hidgl_shader_init_shaders ()) {
+    printf ("Failed to initialise shader support\n");
+    goto done;
+  }
+
+  load_built_in_shaders ();
+
+done:
   done_once = true;
 }
 
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index 6f32a30..834f606 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -23,6 +23,8 @@
 #ifndef __HIDGL_INCLUDED__
 #define __HIDGL_INCLUDED__
 
+#include "hidgl_shaders.h"
+
 #define TRIANGLE_ARRAY_SIZE 30000
 typedef struct {
   GLfloat *triangle_array;
@@ -39,6 +41,9 @@ typedef struct {
 extern triangle_buffer buffer;
 extern float global_depth;
 
+extern hidgl_shader *circular_program;
+extern hidgl_shader *resistor_program;
+
 void hidgl_in_context (bool is_in_context);
 void hidgl_init_triangle_array (triangle_buffer *buffer);
 void hidgl_finish_triangle_array (triangle_buffer *buffer);
diff --git a/src/hid/common/hidgl_package_acy_resistor.c b/src/hid/common/hidgl_package_acy_resistor.c
index 17eb17c..0fd4ffc 100644
--- a/src/hid/common/hidgl_package_acy_resistor.c
+++ b/src/hid/common/hidgl_package_acy_resistor.c
@@ -19,6 +19,9 @@
 #define GL_GLEXT_PROTOTYPES 1
 #include <GL/gl.h>
 
+#include "hidgl.h"
+#include "hidgl_material.h"
+
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
 #endif
@@ -614,8 +617,8 @@ hidgl_draw_acy_resistor (ElementType *element, float surface_depth, float board_
 
   float center_x, center_y;
   float angle;
-  GLfloat resistor_body_color[] = {0.31, 0.47, 0.64};
-  GLfloat resistor_pin_color[] = {0.82, 0.82, 0.82};
+  GLfloat resistor_body_color[] = {0.31, 0.47, 0.64, 1.0};
+  GLfloat resistor_pin_color[] = {0.55, 0.55, 0.55, 1.0};
 
   int strip;
   int no_strips = NUM_RESISTOR_STRIPS;
@@ -630,7 +633,6 @@ hidgl_draw_acy_resistor (ElementType *element, float surface_depth, float board_
   static GLuint texture2_zero_ohms;
 
   GLuint restore_sp;
-  extern GLuint sp2;
 
   /* XXX: Hard-coded magic */
   float resistor_pin_radius = 12. * MIL_TO_INTERNAL;
@@ -663,11 +665,12 @@ hidgl_draw_acy_resistor (ElementType *element, float surface_depth, float board_
 
   /* TEXTURE SETUP */
   glGetIntegerv (GL_CURRENT_PROGRAM, (GLint*)&restore_sp);
-  glUseProgram (sp2);
+  hidgl_shader_activate (resistor_program);
 
   {
-    int tex0_location = glGetUniformLocation (sp2, "detail_tex");
-    int tex1_location = glGetUniformLocation (sp2, "bump_tex");
+    GLuint program = hidgl_shader_get_program (resistor_program);
+    int tex0_location = glGetUniformLocation (program, "detail_tex");
+    int tex1_location = glGetUniformLocation (program, "bump_tex");
     glUniform1i (tex0_location, 0);
     glUniform1i (tex1_location, 1);
   }
@@ -721,10 +724,15 @@ hidgl_draw_acy_resistor (ElementType *element, float surface_depth, float board_
   if (1) {
     GLfloat emission[] = {0.0f, 0.0f, 0.0f, 1.0f};
     GLfloat specular[] = {0.5f, 0.5f, 0.5f, 1.0f};
-    GLfloat shininess = 20.;
-    glMaterialfv (GL_FRONT_AND_BACK, GL_EMISSION, emission);
-    glMaterialfv (GL_FRONT_AND_BACK, GL_SPECULAR, specular);
-    glMaterialfv (GL_FRONT_AND_BACK, GL_SHININESS, &shininess);
+    hidgl_material *material;
+
+    material = hidgl_material_new ("resistor_body");
+    hidgl_material_set_emission_color (material, emission);
+    hidgl_material_set_specular_color (material, specular);
+    hidgl_material_set_shininess (material, 20.0f);
+    hidgl_material_set_shader (material, resistor_program);
+    hidgl_material_activate (material);
+    hidgl_material_free (material);
   }
 
 #if 1
@@ -797,22 +805,20 @@ hidgl_draw_acy_resistor (ElementType *element, float surface_depth, float board_
 
   glEnable (GL_LIGHTING);
 
-  glUseProgram (0);
-
-  glColor3f (resistor_pin_color[0] / 1.5,
-             resistor_pin_color[1] / 1.5,
-             resistor_pin_color[2] / 1.5);
-
   /* COLOR / MATERIAL SETUP */
-  glColorMaterial (GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
-  glEnable (GL_COLOR_MATERIAL);
-
   if (1) {
-//    GLfloat ambient[] = {0.0, 0.0, 0.0, 1.0};
-    GLfloat specular[] = {0.5, 0.5, 0.5, 1.0};
-    GLfloat shininess = 120.;
-    glMaterialfv (GL_FRONT_AND_BACK, GL_SPECULAR, specular);
-    glMaterialfv (GL_FRONT_AND_BACK, GL_SHININESS, &shininess);
+    GLfloat emission[] = {0.0f, 0.0f, 0.0f, 1.0f};
+    GLfloat specular[] = {0.5f, 0.5f, 0.5f, 1.0f};
+    hidgl_material *material;
+
+    material = hidgl_material_new ("resistor_pin");
+    hidgl_material_set_ambient_color (material, resistor_pin_color);
+    hidgl_material_set_diffuse_color (material, resistor_pin_color);
+    hidgl_material_set_emission_color (material, emission);
+    hidgl_material_set_specular_color (material, specular);
+    hidgl_material_set_shininess (material, 120.0f);
+    hidgl_material_activate (material);
+    hidgl_material_free (material);
   }
 
   for (end = 0; end < 2; end++) {
diff --git a/src/hid/common/hidgl_package_vrml.c b/src/hid/common/hidgl_package_vrml.c
index 9091a52..5ae16ad 100644
--- a/src/hid/common/hidgl_package_vrml.c
+++ b/src/hid/common/hidgl_package_vrml.c
@@ -355,9 +355,14 @@ extern int hidgl_parse_vrml (char *filename);
 void
 hidgl_draw_vrml (ElementType *element, float surface_depth, float board_thickness, char *vrml_file)
 {
+  static bool one_shot = true;
+
+  if (!one_shot)
+    return;
+
   printf ("hidgl_draw_vrml\n");
   hidgl_parse_vrml ("test.wrl");
-  return;
+  one_shot = false;
 }
 
 static float
diff --git a/src/hid/common/hidgl_package_vrml_l.l b/src/hid/common/hidgl_package_vrml_l.l
index 8ffe2b4..b308527 100644
--- a/src/hid/common/hidgl_package_vrml_l.l
+++ b/src/hid/common/hidgl_package_vrml_l.l
@@ -68,18 +68,22 @@ char *vrml_yyfilename; /* in this file */
  */
 extern int	vrml_yyparse(void);
 
+/*STRING			".*" ... double-quotes must be \", backslashes must be \\... */
+/*IDFIRSTCHAR		[^0-9 "#'+,-.\[\\\]{}] */
+/*IDRESTCHARS		[^ "#',.\[\\\]{}] */
+
+/*STRINGCHAR              ([^"\n\r\\]|\\.) */
+/* \"{STRINGCHAR}*\"	{printf ("DEAD RULE?\n");} */
+/* {STRINGCHAR}+		{ */
 
 %}
 
-IDFIRSTCHAR		[^0-9 "#'+,-.\[\\\]{}]
-IDRESTCHARS		[^ "#',.\[\\\]{}]
-FLOAT			([+/-]?((([0-9]+(\.)?)|([0-9]*\.[0-9]+))([eE][+\-]?[0-9]+)?))
-DOUBLE			([+/-]?((([0-9]+(\.)?)|([0-9]*\.[0-9]+))([eE][+\-]?[0-9]+)?))
 INT32			([+\-]?(([0-9]+)|(0[xX][0-9a-fA-F]+)))
-STRING			".*" ... double-quotes must be \", backslashes must be \\...
+FLOATING		([+/-]?((([0-9]+(\.)?)|([0-9]*\.[0-9]+))([eE][+\-]?[0-9]+)?))
 
 DECIMAL                 -?[1-9][0-9]*|0
-STRINGCHAR              ([^"\n\r\\]|\\.)
+
+STRINGCHAR              ([^, "\n\r\\{}\[\]]|\\.)
 
 %option prefix="vrml_yy"
 %option outfile="lex.yy.c"
@@ -104,29 +108,89 @@ field		{ return T_FIELD; }
 
 Script		{ return T_SCRIPT; }
 
-{DOUBLE}		{
+"#VRML V2.0 utf8"	{ return T_VRMLHEADER; }
+
+%{ /* Fields for any grouping node */ %}
+children		{ return T_children; }
+
+%{ /* Transform node and its fields */ %}
+Transform		{ return T_TRANSFORM; }
+center			{ return T_center; }
+rotation		{ return T_rotation; }
+scale			{ return T_scale; }
+scaleOrientation	{ return T_scale_orientation; }
+translation		{ return T_translation; }
+bboxCenter		{ return T_bbox_center; }
+bboxSize		{ return T_bbox_size; }
+
+%{ /* Shape node and its fields */ %}
+Shape			{ return T_SHAPE; }
+appearance		{ return T_appearance; }
+geometry		{ return T_geometry; }
+
+%{ /* Appearance node and its fields */ %}
+Appearance		{ return T_APPEARANCE; }
+material		{ return T_material; }
+texture			{ return T_texture; }
+textureTransform	{ return T_texture_transform; }
+
+%{ /* Material node and its fields */ %}
+Material		{ return T_MATERIAL; }
+ambientIntensity	{ return T_ambient_intensity; }
+diffuseColor		{ return T_diffuse_color; }
+emissiveColor		{ return T_emissive_color; }
+shininess		{ return T_shininess; }
+specularColor		{ return T_specular_color; }
+transparency		{ return T_transparency; }
+
+%{ /* IndexedFaceSet node and its fields */ %}
+IndexedFaceSet		{ return T_INDEXED_FACE_SET; }
+color			{ return T_color; }
+coord			{ return T_coord; }
+normal			{ return T_normal; }
+texCoord		{ return T_tex_coord; }
+ccw			{ return T_ccw; }
+colorIndex		{ return T_color_index; }
+colorPerVertex		{ return T_color_per_vertex; }
+convex			{ return T_convex; }
+coordIndex		{ return T_coord_index; }
+creaseAngle		{ return T_crease_angle; }
+normalIndex		{ return T_normal_index; }
+normalPerVertex		{ return T_normal_per_vertex; }
+solid			{ return T_solid; }
+texCoord		{ return T_tex_coord_index; }
+
+%{ /* Coordinate node and its field */ %}
+Coordinate		{ return T_COORDINATE; }
+point			{ return T_point; }
+
+%{ /* Normal node and its field */ %}
+Normal			{ return T_NORMAL; }
+vector			{ return T_vector; }
+
+
+{INT32}		{
+					vrml_yylval.int32 = atoi(vrml_yytext);
+					return INT32;
+			}
+
+{FLOATING}		{
 					vrml_yylval.floating = strtod (vrml_yytext, NULL);
-					return DOUBLE;
+					return FLOATING;
 			}
 
+#.*					{}
 
-\"{STRINGCHAR}*\"	{
-						char	*p1, *p2;
+{STRINGCHAR}*	{
 
-							/* return NULL on empty string */
-						if (vrml_yyleng == 2)
-						{
-							vrml_yylval.string = NULL;
-							return(STRING);
-						}
+						char	*p1, *p2;
 
 							/* allocate memory and copy string;
 							 * stringlength is counted and copied without
 							 * leading and trailing '"'
 							 */
-						vrml_yyleng -= 2;
 						vrml_yylval.string = MyCalloc(vrml_yyleng+1, sizeof(char), "LEX");
-						p1 = (char *) (vrml_yytext +1);
+						p1 = (char *) (vrml_yytext);
 						p2 = vrml_yylval.string;
 						while(vrml_yyleng--)
 						{
@@ -140,9 +204,9 @@ Script		{ return T_SCRIPT; }
 							*p2++ = *p1++;
 						}
 						*p2 = '\0';
+//						printf ("Returning a string token %s\n", vrml_yylval.string);
 						return(STRING);
 					}
-#.*					{}
 [ \t,]+				{}
 [\n]				{
 #ifndef FLEX_SCANNER
@@ -154,14 +218,14 @@ Script		{ return T_SCRIPT; }
 
 %%
 
-extern int vrml_yydebug;
-
 /* ---------------------------------------------------------------------------
  * sets up the preprocessor command
  */
 static int Parse(char *filename)
 {
   int retval;
+  extern int vrml_yydebug;
+
 #ifdef FLEX_SCANNER
   static	bool	firsttime = true;
 #endif
@@ -180,6 +244,7 @@ static int Parse(char *filename)
   /* init linenumber and filename for vrml_yyerror() */
   vrml_yylineno = 1;
   vrml_yyfilename = filename;
+//  vrml_yydebug = 1;
 
   /* We need to save the data temporarily because lex-yacc are able
    * to break the application if the input file has an illegal format.
@@ -187,8 +252,6 @@ static int Parse(char *filename)
    * on termination.
    */
 
-  vrml_yydebug = 1;
-  printf ("Entering parser\n");
 #if !defined(HAS_ATEXIT) && !defined(HAS_ON_EXIT)
   if (PCB)
     SaveTMPData();
@@ -197,7 +260,6 @@ static int Parse(char *filename)
 #else
   retval = vrml_yyparse();
 #endif
-  printf ("Leaving parser\n");
 
   /* clean up parse buffer */
   vrml_yy_delete_buffer (YY_CURRENT_BUFFER);
diff --git a/src/hid/common/hidgl_package_vrml_y.y b/src/hid/common/hidgl_package_vrml_y.y
index 8d15de4..0a59fbe 100644
--- a/src/hid/common/hidgl_package_vrml_y.y
+++ b/src/hid/common/hidgl_package_vrml_y.y
@@ -29,18 +29,6 @@
 #endif
 
 #include "global.h"
-#include "create.h"
-#include "data.h"
-#include "error.h"
-#include "file.h"
-#include "mymem.h"
-#include "misc.h"
-#include "parse_l.h"
-#include "polygon.h"
-#include "remove.h"
-#include "rtree.h"
-#include "strflags.h"
-#include "thermal.h"
 
 #ifdef HAVE_LIBDMALLOC
 # include <dmalloc.h> /* see http://dmalloc.com */
@@ -59,10 +47,9 @@ extern char *vrml_yyfilename;
 
 %union									/* define YYSTACK type */
 {
-	int		number;
+	int		int32;
 	double		floating;
 	char		*string;
-	FlagType	flagtype;
 }
 
 %token T_DEF
@@ -80,8 +67,6 @@ extern char *vrml_yyfilename;
 %token T_EXPOSEDFIELD
 %token T_FIELD
 
-%token T_SCRIPT
-
 %token MFColor
 %token MFFloat
 %token MFInt32
@@ -103,24 +88,94 @@ extern char *vrml_yyfilename;
 %token SFVec2f
 %token SFVec3f
 
+%token T_VRMLHEADER
+%token T_SCRIPT
 %token T_ID
 %token T_FIELDTYPE
 
-%token <floating>      FLOAT
-%token <floating>      DOUBLE
+
+/* Fields for any grouping node */
+%token T_children
+
+/* Transform node and its fields */
+%token T_TRANSFORM
+%token T_center
+%token T_rotation
+%token T_scale
+%token T_scale_orientation
+%token T_translation
+%token T_bbox_center
+%token T_bbox_size
+
+/* Shape node and its fields */
+%token T_SHAPE
+%token T_appearance
+%token T_geometry
+
+/* Appearance node and its fields */
+%token T_APPEARANCE
+%token T_material
+%token T_texture
+%token T_texture_transform
+
+/* Material node and its fields */
+%token T_MATERIAL
+%token T_ambient_intensity
+%token T_diffuse_color
+%token T_emissive_color
+%token T_shininess
+%token T_specular_color
+%token T_transparency
+
+/* IndexedFaceSet node and its fields */
+%token T_INDEXED_FACE_SET
+%token T_color
+%token T_coord
+%token T_normal
+%token T_tex_coord
+%token T_ccw
+%token T_color_index
+%token T_color_per_vertex
+%token T_convex
+%token T_coord_index
+%token T_crease_angle
+%token T_normal_index
+%token T_normal_per_vertex
+%token T_solid
+%token T_tex_coord_index
+
+/* Coordinate node and its field */
+%token T_COORDINATE
+%token T_point
+
+/* Normal node and its field */
+%token T_NORMAL
+%token T_vector
+
+
+%token <floating>      FLOATING
 %token <number>        INT32
 
 %token <string>        STRING
-%token <string>        IDFIRSTCHAR
-%token <string>        IDRESTCHARS
+//%token <string>        IDFIRSTCHAR
+//%token <string>        IDRESTCHARS
 
 %%
 
 /* General VRML stuff */
 
-parse				: vrmlScene
-				| { printf ("HELLO\n"); }
+parse				: vrmlHeader
+				  vrmlScene
 				| error { YYABORT; }
+				;
+
+vrmlHeader			: T_VRMLHEADER { printf ("Got header\n"); }
+				  vrmlHeaderComment
+				;
+
+vrmlHeaderComment		: sfstringValues
+				| empty
+				;
 
 vrmlScene			: statements
 				;
@@ -131,17 +186,18 @@ statements			: statement
 				;
 
 statement			: nodeStatement
-				| protoStatement
-				| routeStatement
+//				| protoStatement
+//				| routeStatement
 				;
 
 nodeStatement			: node
-				| T_DEF nodeNameId { printf ("Hello world\n");} node
+				| T_DEF nodeNameId node
 				| T_USE nodeNameId
 				;
 
+/*
 rootNodeStatement		: node
-				| T_DEF nodeNameId node
+				| T_DEF nodeNameId node { printf ("Got a root Node Statement\n"); }
 				;
 
 protoStatement			: proto
@@ -192,6 +248,7 @@ routeStatement			: T_ROUTE nodeNameId '.' eventOutId T_TO nodeNameId '.' eventIn
 
 URLList				: mfstringValue
 				;
+*/
 
 empty				:
 				;
@@ -199,20 +256,134 @@ empty				:
 
 /* NODES */
 
+/*
 node				: nodeTypeId '{' nodeBody '}'
 				| T_SCRIPT '{' scriptBody '}'
 				;
+*/
+
+node				: T_TRANSFORM        '{' Transform_nodeBody      '}' { printf ("Got a transform node\n");}
+				| T_SHAPE            '{' Shape_nodeBody          '}' { printf ("Got a shape node\n");}
+				| T_APPEARANCE       '{' Appearance_nodeBody     '}' { printf ("Got an appearance node\n");}
+				| T_MATERIAL         '{' Material_nodeBody       '}' { printf ("Got a material node\n");}
+				| T_INDEXED_FACE_SET '{' IndexedFaceSet_nodeBody '}' { printf ("Got an indexed face set node\n");}
+				| T_COORDINATE       '{' Coordinate_nodeBody     '}' { printf ("Got a coordinate node\n");}
+				| T_NORMAL           '{' Normal_nodeBody         '}' { printf ("Got a normal node\n");}
+				| T_SCRIPT           '{' scriptBody '}'
+				;
+
+/* NORMAL NODE ------------------------------------------------------------- */
+Transform_nodeBody		: Transform_nodeBodyElements
+				| empty;
+
+Transform_nodeBodyElements	: Transform_nodeBodyElement
+				| Transform_nodeBodyElement Transform_nodeBodyElements;
+
+Transform_nodeBodyElement	: T_center sfvec3fValue
+				| T_children '[' statements ']'
+				| T_rotation sfvec3fValue
+				| T_scale sfvec3fValue
+				| T_scale_orientation sfrotationValue
+				| T_translation sfvec3fValue
+				| T_bbox_center sfvec3fValue
+				| T_bbox_size sfvec3fValue
+				;
+
+/* SHAPE NODE -------------------------------------------------------------- */
+Shape_nodeBody			: Shape_nodeBodyElements
+				| empty;
+
+Shape_nodeBodyElements		: Shape_nodeBodyElement
+				| Shape_nodeBodyElement Shape_nodeBodyElements;
+
+Shape_nodeBodyElement		: T_appearance statements
+				| T_geometry statements
+				;
+
+/* APPEARANCE NODE --------------------------------------------------------- */
+Appearance_nodeBody		: Appearance_nodeBodyElements
+				| empty;
+
+Appearance_nodeBodyElements	: Appearance_nodeBodyElement
+				| Appearance_nodeBodyElement Appearance_nodeBodyElements;
+
+Appearance_nodeBodyElement	: T_material statements
+				| T_texture statements
+				| T_texture_transform statements
+				;
+
+/* MATERIAL NODE ----------------------------------------------------------- */
+Material_nodeBody		: Material_nodeBodyElements
+				| empty;
+
+Material_nodeBodyElements	: Material_nodeBodyElement
+				| Material_nodeBodyElement Material_nodeBodyElements;
+
+Material_nodeBodyElement	: T_ambient_intensity sffloatValue
+				| T_diffuse_color sfcolorValue
+				| T_emissive_color sfcolorValue
+				| T_shininess sffloatValue
+				| T_specular_color sfcolorValue
+				| T_transparency sffloatValue
+				;
 
+/* INDEXED_FACE_SET NODE --------------------------------------------------- */
+IndexedFaceSet_nodeBody		: IndexedFaceSet_nodeBodyElements
+				| empty;
+
+IndexedFaceSet_nodeBodyElements	: IndexedFaceSet_nodeBodyElement
+				| IndexedFaceSet_nodeBodyElement IndexedFaceSet_nodeBodyElements;
+
+IndexedFaceSet_nodeBodyElement	: T_color statement
+				| T_coord statement
+				| T_normal statement
+				| T_tex_coord statement
+				| T_ccw sfboolValue
+				| T_color_index mfint32Value
+				| T_color_per_vertex sfboolValue
+				| T_convex sfboolValue
+				| T_coord_index mfint32Value
+				| T_crease_angle sffloatValue
+				| T_normal_index mfint32Value
+				| T_normal_per_vertex sfboolValue
+				| T_solid sfboolValue
+				| T_tex_coord_index mfint32Value
+				;
+
+/* COORDINATE NODE --------------------------------------------------------- */
+Coordinate_nodeBody		: Coordinate_nodeBodyElements
+				| empty;
+
+Coordinate_nodeBodyElements	: Coordinate_nodeBodyElement
+				| Coordinate_nodeBodyElement Coordinate_nodeBodyElements;
+
+Coordinate_nodeBodyElement	: T_point mfvec3fValue
+				;
+
+/* NORMAL NODE ------------------------------------------------------------- */
+Normal_nodeBody			: Normal_nodeBodyElements
+				| empty;
+
+Normal_nodeBodyElements		: Normal_nodeBodyElement
+				| Normal_nodeBodyElement Normal_nodeBodyElements;
+
+Normal_nodeBodyElement		: T_vector mfvec3fValue
+				;
+
+/* GENERIC NODE ------------------------------------------------------------ */
+/*
 nodeBody			: nodeBodyElement
 				| nodeBodyElement nodeBody
 				| empty
 				;
+*/
 
-scriptBody			: scriptBodyElement
-				| scriptBodyElement scriptBody
-				| empty
+scriptBody			: // scriptBodyElement
+//				| scriptBodyElement scriptBody
+/*				| */ empty
 				;
 
+/*
 scriptBodyElement		: nodeBodyElement
 				| restrictedInterfaceDeclaration
 				| T_EVENTIN fieldType eventInId T_IS eventInId
@@ -220,17 +391,19 @@ scriptBodyElement		: nodeBodyElement
 				| T_FIELD fieldType fieldId T_IS fieldId
 				;
 
-nodeBodyElement			: fieldId fieldValue
-				| fieldId T_IS fieldId
-				| eventInId T_IS eventInId
-				| eventOutId T_IS eventOutId
-				| routeStatement
-				| protoStatement
+nodeBodyElement			: //fieldId fieldValue
+//				| fieldId T_IS fieldId
+//				| eventInId T_IS eventInId
+//				| eventOutId T_IS eventOutId
+//				| routeStatement
+//				| protoStatement
 				;
+*/
 
 nodeNameId			: Id
 				;
 
+/*
 nodeTypeId			: Id
 				;
 
@@ -242,13 +415,20 @@ eventInId			: Id
 
 eventOutId			: Id
 				;
+*/
 
+/*
 Id				: IDFIRSTCHAR
 				| IDFIRSTCHAR IDRESTCHARS
 				;
+*/
+
+Id				: STRING
+				;
 
 /* FIELDS */
 
+/*
 fieldType			: MFColor
 				| MFFloat
 				| MFInt32
@@ -293,44 +473,44 @@ fieldValue			:
 				| mfvec2fValue
 				| mfvec3fValue
 				;
+*/
 
 sfboolValue			: T_TRUE
 				| T_FALSE
 				;
 
-sfcolorValue			: FLOAT FLOAT FLOAT
+sfcolorValue			: FLOATING FLOATING FLOATING
 				;
 
-sffloatValue			: FLOAT
+sffloatValue			: FLOATING
 				;
 
+/*
 sfimageValue			: image_data
 				;
 
 image_data			: INT32
 				| image_data INT32
 				;
+*/
 
 sfint32Value			: INT32
 				;
 
+/*
 sfnodeValue			: nodeStatement
 				| T_NULL
 				;
+*/
 
-sfrotationValue			: FLOAT FLOAT FLOAT FLOAT
-				;
-
-sfstringValue			: string
+sfrotationValue			: FLOATING FLOATING FLOATING FLOATING
 				;
 
-string				: STRING
+sfstringValue			: STRING
 				;
 
-sftimeValue			: double
-				;
-
-double				: DOUBLE
+/*
+sftimeValue			: DOUBLE
 				;
 
 mftimeValue			: sftimeValue
@@ -342,12 +522,14 @@ sftimeValues			: sftimeValue
 				| sftimeValue sftimeValues
 				;
 
-sfvec2fValue			: FLOAT FLOAT
+sfvec2fValue			: FLOATING FLOATING
 				;
+*/
 
-sfvec3fValue			: FLOAT FLOAT FLOAT
+sfvec3fValue			: FLOATING FLOATING FLOATING
 				;
 
+/*
 mfcolorValue			: sfcolorValue
 				| '[' ']'
 				| '[' sfcolorValues ']'
@@ -365,6 +547,7 @@ mffloatValue			: sffloatValue
 sffloatValues			: sffloatValue
 				| sffloatValue sffloatValues
 				;
+*/
 
 mfint32Value			: sfint32Value
 				| '[' ']'
@@ -375,6 +558,7 @@ sfint32Values			: sfint32Value
 				| sfint32Value sfint32Values
 				;
 
+/*
 mfnodeValue			: nodeStatement
 				| '[' ']'
 				| '[' nodeStatements ']'
@@ -392,16 +576,20 @@ mfrotationValue			: sfrotationValue
 sfrotationValues		: sfrotationValue
 				| sfrotationValue sfrotationValues
 				;
+*/
 
+/*
 mfstringValue			: sfstringValue
 				| '[' ']'
 				| '[' sfstringValues ']'
 				;
+*/
 
 sfstringValues			: sfstringValue
 				| sfstringValue sfstringValues
 				;
 
+/*
 mfvec2fValue			: sfvec2fValue
 				| '[' ']'
 				| '[' sfvec2fValues ']'
@@ -410,6 +598,7 @@ mfvec2fValue			: sfvec2fValue
 sfvec2fValues			: sfvec2fValue
 				| sfvec2fValue sfvec2fValues
 				;
+*/
 
 mfvec3fValue			: sfvec3fValue
 				| '[' ']'
@@ -429,7 +618,7 @@ sfvec3fValues			: sfvec3fValue
 int vrml_yyerror(s)
 const char *s;
 {
-	Message("ERROR parsing file (%s)\n"
+	printf("ERROR parsing file (%s)\n"
 		"    line number: %i\n"
 		"    description: '%s'\n",
 		vrml_yyfilename, vrml_yylineno, s);
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 73197ef..e1b30f5 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -1429,7 +1429,6 @@ DrawMask (BoxType * screen)
 {
   static bool first_run = true;
   static GLuint texture;
-  extern GLuint sp;
 
   struct pin_info info;
   int thin = TEST_FLAG(THINDRAWFLAG, PCB) || TEST_FLAG(THINDRAWPOLYFLAG, PCB);
@@ -1470,7 +1469,7 @@ DrawMask (BoxType * screen)
   } else {
     glBindTexture (GL_TEXTURE_2D, texture);
   }
-  glUseProgram (0);
+  hidgl_shader_activate (NULL);
 
   if (1) {
     GLfloat s_params[] = {0.0001, 0., 0., 0.};
@@ -1509,7 +1508,7 @@ DrawMask (BoxType * screen)
   glDisable (GL_TEXTURE_GEN_T);
   glBindTexture (GL_TEXTURE_2D, 0);
   glDisable (GL_TEXTURE_2D);
-  glUseProgram (sp);
+  hidgl_shader_activate (circular_program);
 
   gui->use_mask (HID_MASK_OFF);
 
@@ -1924,9 +1923,6 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   int new_x, new_y;
   int min_depth;
   int max_depth;
-  static float wavetime = 0;
-  extern GLuint sp;
-  GLint waveTimeLoc = glGetUniformLocation (sp, "waveTime");
   float aspect;
   GLfloat scale[] = {1, 0, 0, 0,
                      0, 1, 0, 0,
@@ -1943,9 +1939,6 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   hidgl_init ();
   check_gl_drawing_ok_hack = true;
 
-  wavetime += 0.1;
-  glUniform1f (waveTimeLoc, wavetime);
-
   /* If we don't have any stencil bits available,
      we can't use the hidgl polygon drawing routine */
   /* TODO: We could use the GLU tessellator though */

Bottom: 3b620fba260d222affdf81a24525cc61bcc4b96b
Top:    64fc1b63379d062e30f142542700e961c65f846b
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2014-06-08 20:56:22 +0100

Refresh of well-on-the-way-to-completely

---

diff --git a/src/hid/gtk/edge3d.c b/src/hid/gtk/edge3d.c
index 2d34558..3cd5659 100644
--- a/src/hid/gtk/edge3d.c
+++ b/src/hid/gtk/edge3d.c
@@ -17,7 +17,7 @@ make_edge_info (void)
 }
 
 void
-edge_info_set_round (edge_info *info, float cx, float cy, float cz, float nx, float ny, float nz, float radius)
+edge_info_set_round (edge_info *info, double cx, double cy, double cz, double nx, double ny, double nz, double radius)
 {
   info->is_round = true;
   info->cx = cx;
diff --git a/src/hid/gtk/edge3d.h b/src/hid/gtk/edge3d.h
index 696ace3..38fd6c1 100644
--- a/src/hid/gtk/edge3d.h
+++ b/src/hid/gtk/edge3d.h
@@ -5,13 +5,13 @@ typedef struct
 
   /* For circular curves */
   bool is_round;
-  float cx;
-  float cy;
-  float cz;
-  float nx;
-  float ny;
-  float nz;
-  float radius;
+  double cx;
+  double cy;
+  double cz;
+  double nx;
+  double ny;
+  double nz;
+  double radius;
 
   /* STEP crap - to hell with encapsulation */
   step_id infinite_line_identifier;
@@ -19,6 +19,6 @@ typedef struct
 } edge_info;
 
 edge_info *make_edge_info (void);
-void edge_info_set_round (edge_info *info, float cx, float cy, float cz, float nx, float ny, float nz, float radius);
+void edge_info_set_round (edge_info *info, double cx, double cy, double cz, double nx, double ny, double nz, double radius);
 void edge_info_set_stitch (edge_info *info);
 void destroy_edge_info (edge_info *info);
diff --git a/src/hid/gtk/face3d.c b/src/hid/gtk/face3d.c
index 8e8f8c0..59bb963 100644
--- a/src/hid/gtk/face3d.c
+++ b/src/hid/gtk/face3d.c
@@ -38,7 +38,7 @@ face3d_set_appearance (face3d *face, appearance *appear)
 }
 
 void
-face3d_set_normal (face3d *face, float nx, float ny, float nz)
+face3d_set_normal (face3d *face, double nx, double ny, double nz)
 {
   face->nx = nx;
   face->ny = ny;
@@ -46,7 +46,7 @@ face3d_set_normal (face3d *face, float nx, float ny, float nz)
 }
 
 void
-face3d_set_cylindrical (face3d *face, float cx, float cy, float cz, float ax, float ay, float az, float radius)
+face3d_set_cylindrical (face3d *face, double cx, double cy, double cz, double ax, double ay, double az, double radius)
 {
   face->is_cylindrical = true;
   face->cx = cx;
diff --git a/src/hid/gtk/face3d.h b/src/hid/gtk/face3d.h
index 44f6e88..0998a22 100644
--- a/src/hid/gtk/face3d.h
+++ b/src/hid/gtk/face3d.h
@@ -1,12 +1,12 @@
 typedef struct {
-  float nx, ny, nz; /* Face normal?*/
+  double nx, ny, nz; /* Face normal?*/
   GList *contours;
 
   /* For cylindrical surfaces */
   bool is_cylindrical;
-  float cx, cy, cz; /* A point on the axis */
-  float ax, ay, az; /* Direction of the axis */
-  float radius;
+  double cx, cy, cz; /* A point on the axis */
+  double ax, ay, az; /* Direction of the axis */
+  double radius;
 
   appearance *appear;
 
@@ -21,6 +21,6 @@ face3d *make_face3d (void);
 void destroy_face3d (face3d *face);
 void face3d_add_contour (face3d *face, contour3d *contour);
 void face3d_set_appearance (face3d *face, appearance *appear);
-void face3d_set_normal (face3d *face, float nx, float ny, float nz);
-void face3d_set_cylindrical (face3d *face, float cx, float cy, float cz, float ax, float ay, float az, float radius);
+void face3d_set_normal (face3d *face, double nx, double ny, double nz);
+void face3d_set_cylindrical (face3d *face, double cx, double cy, double cz, double ax, double ay, double az, double radius);
 void face3d_set_surface_orientation_reversed (face3d *face);
diff --git a/src/hid/gtk/object3d.c b/src/hid/gtk/object3d.c
index 042ce4d..538eed3 100644
--- a/src/hid/gtk/object3d.c
+++ b/src/hid/gtk/object3d.c
@@ -16,9 +16,13 @@
 #include "polygon.h"
 #include "data.h"
 
+#include "pcb-printf.h"
+
 #define REVERSED_PCB_CONTOURS 1 /* PCB Contours are reversed from the expected CCW for outer ordering - once the Y-coordinate flip is taken into account */
 
 #define EPSILON 1e-5 /* XXX: Unknown  what this needs to be */
+
+#ifdef REVERSED_PCB_CONTOURS
 #define COORD_TO_STEP_X(pcb, x) (COORD_TO_MM(                   (x)))
 #define COORD_TO_STEP_Y(pcb, y) (COORD_TO_MM((pcb)->MaxHeight - (y)))
 #define COORD_TO_STEP_Z(pcb, z) (COORD_TO_MM(                   (z)))
@@ -26,6 +30,17 @@
 #define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
 #define STEP_Y_TO_COORD(pcb, y) ((pcb)->MaxHeight - MM_TO_COORD((y)))
 #define STEP_Z_TO_COORD(pcb, z) (MM_TO_COORD((z)))
+#else
+/* XXX: BROKEN UPSIDE DOWN OUTPUT */
+#define COORD_TO_STEP_X(pcb, x) (COORD_TO_MM((x)))
+#define COORD_TO_STEP_Y(pcb, y) (COORD_TO_MM((y)))
+#define COORD_TO_STEP_Z(pcb, z) (COORD_TO_MM((z)))
+
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) (MM_TO_COORD((y)))
+#define STEP_Z_TO_COORD(pcb, z) (MM_TO_COORD((z)))
+#endif
+
 
 #ifndef WIN32
 /* The Linux OpenGL ABI 1.0 spec requires that we define
@@ -102,7 +117,7 @@ object3d_add_face (object3d *object, face3d *face)
 }
 
 
-float colors[12][3] = {{1., 0., 0.},
+double colors[12][3] = {{1., 0., 0.},
                        {1., 1., 0.},
                        {0., 1., 0.},
                        {0., 1., 1.},
@@ -138,11 +153,11 @@ draw_quad_edge (edge_ref e, void *data)
       glBegin (GL_LINES);
       for (i = 0; i < CIRC_SEGS; i++) {
         /* XXX: THIS ASSUMES THE CIRCLE LIES IN THE X-Y PLANE */
-        glVertex3f (STEP_X_TO_COORD (PCB, info->cx + info->radius * cos (i * 2. * M_PI / (float)CIRC_SEGS)),
-                    STEP_Y_TO_COORD (PCB, info->cy + info->radius * sin (i * 2. * M_PI / (float)CIRC_SEGS)),
+        glVertex3f (STEP_X_TO_COORD (PCB, info->cx + info->radius * cos (i * 2. * M_PI / (double)CIRC_SEGS)),
+                    STEP_Y_TO_COORD (PCB, info->cy + info->radius * sin (i * 2. * M_PI / (double)CIRC_SEGS)),
                     STEP_Z_TO_COORD (PCB, info->cz));
-        glVertex3f (STEP_X_TO_COORD (PCB, info->cx + info->radius * cos ((i + 1) * 2. * M_PI / (float)CIRC_SEGS)),
-                    STEP_Y_TO_COORD (PCB, info->cy + info->radius * sin ((i + 1) * 2. * M_PI / (float)CIRC_SEGS)),
+        glVertex3f (STEP_X_TO_COORD (PCB, info->cx + info->radius * cos ((i + 1) * 2. * M_PI / (double)CIRC_SEGS)),
+                    STEP_Y_TO_COORD (PCB, info->cy + info->radius * sin ((i + 1) * 2. * M_PI / (double)CIRC_SEGS)),
                     STEP_Z_TO_COORD (PCB, info->cz));
       }
       glEnd ();
@@ -335,7 +350,7 @@ object3d_export_to_step (object3d *object, char *filename)
       vertex3d *ov = ODATA (outer_contour->first_edge);
       vertex3d *dv = DDATA (outer_contour->first_edge);
 
-      float rx, ry, rz;
+      double rx, ry, rz;
 
       rx = dv->x - ov->x;
       ry = dv->y - ov->y;
@@ -378,14 +393,30 @@ object3d_export_to_step (object3d *object, char *filename)
       vertex3d *ov = ODATA (edge);
       vertex3d *dv = DDATA (edge);
 
+      double dir_x, dir_y, dir_z;
+
+      dir_x = dv->x - ov->x;
+      dir_y = dv->y - ov->y;
+      dir_z = dv->z - ov->z;
+
+#if 1
+      /* XXX: This avoids the test file step_outline_test.pcb failing to display properly in freecad when coordinates are slightly rounded */
+      if (dir_x < EPSILON && -dir_x < EPSILON &&
+          dir_y < EPSILON && -dir_y < EPSILON &&
+          dir_z < EPSILON && -dir_z < EPSILON) {
+        printf ("EDGE TOO SHORT TO DETERMINE DIRECTION - GUESSING! Coords (%f, %f)\n", ov->x, ov->y);
+        pcb_printf ("Approx PCB coords of short edge: %#mr, %#mr\n", (Coord)STEP_X_TO_COORD (PCB, ov->x), (Coord)STEP_Y_TO_COORD (PCB, ov->y));
+        dir_x = 1.0; /* DUMMY TO AVOID A ZERO LENGTH DIRECTION VECTOR */
+      }
+#endif
+
       info->infinite_line_identifier =
         step_line (step, "NONE",
                    step_cartesian_point (step, "NONE", ov->x, ov->y, ov->z),  // <--- A point on the line (the origin vertex)
                    step_vector (step, "NONE",
-                                step_direction (step, "NONE", dv->x - ov->x,
-                                                              dv->y - ov->y,
-                                                              dv->z - ov->z),  // <--- Direction along the line
+                                step_direction (step, "NONE", dir_x, dir_y, dir_z), // <--- Direction along the line
                                 1000.0));     // <--- Arbitrary length in this direction for the parameterised coordinate "1".
+
     }
   }
 
@@ -715,7 +746,7 @@ object3d_from_board_outline (void)
 
     }
 
-    if (0) {
+    if (1) {
       /* Cylinder centers on 45x45mm, stitch vertex is at 40x45mm. Radius is thus 5mm */
 
       edge_ref cylinder_edges[3];
@@ -728,8 +759,8 @@ object3d_from_board_outline (void)
 #ifdef REVERSED_PCB_CONTOURS
       edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
                            COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
-                            0.,   0., -1., /* Normal */
-                            5.);           /* Radius */
+                            0.,   0., 1., /* Normal */
+                            5.);          /* Radius */
 #else
       edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
                            COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
diff --git a/src/hid/gtk/vertex3d.c b/src/hid/gtk/vertex3d.c
index 8e584ab..bbe5074 100644
--- a/src/hid/gtk/vertex3d.c
+++ b/src/hid/gtk/vertex3d.c
@@ -9,7 +9,7 @@
 static int global_vertex3d_count;
 
 vertex3d *
-make_vertex3d (float x, float y, float z)
+make_vertex3d (double x, double y, double z)
 {
   vertex3d *v;
 
diff --git a/src/hid/gtk/vertex3d.h b/src/hid/gtk/vertex3d.h
index a150934..cad586d 100644
--- a/src/hid/gtk/vertex3d.h
+++ b/src/hid/gtk/vertex3d.h
@@ -1,13 +1,13 @@
 typedef struct
 {
-  float x;
-  float y;
-  float z;
+  double x;
+  double y;
+  double z;
   int id;
 
   /* STEP crap - to hell with encapsulation */
   step_id vertex_identifier;
 } vertex3d;
 
-vertex3d *make_vertex3d (float x, float y, float z);
+vertex3d *make_vertex3d (double x, double y, double z);
 void destroy_vertex3d (vertex3d *v);

Bottom: 5f63c32dc0811f2361cc47293fe9b00433480ec6
Top:    a645fcdfac4298baf7096d7475ee537ba43ce7aa
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-05-09 07:30:42 +0100

Refresh of only-assign-stencil-planes-for

---

diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index e7ccabd..82a3675 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -147,12 +147,48 @@ compute_depth (int group)
   return depth;
 }
 
+static void
+start_subcomposite (void)
+{
+  render_priv *priv = gport->render_priv;
+  int stencil_bit;
+
+  /* Flush out any existing geoemtry to be rendered */
+  hidgl_flush_triangles (&buffer);
+
+  glEnable (GL_STENCIL_TEST);                                 /* Enable Stencil test */
+  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);                 /* Stencil pass => replace stencil value (with 1) */
+
+  stencil_bit = hidgl_assign_clear_stencil_bit();             /* Get a new (clean) bitplane to stencil with */
+  glStencilMask (stencil_bit);                                /* Only write to our subcompositing stencil bitplane */
+  glStencilFunc (GL_GREATER, stencil_bit, stencil_bit);       /* Pass stencil test if our assigned bit is clear */
+
+  priv->subcomposite_stencil_bit = stencil_bit;
+}
+
+static void
+end_subcomposite (void)
+{
+  render_priv *priv = gport->render_priv;
+
+  /* Flush out any existing geoemtry to be rendered */
+  hidgl_flush_triangles (&buffer);
+
+  hidgl_return_stencil_bit (priv->subcomposite_stencil_bit);  /* Relinquish any bitplane we previously used */
+
+  glStencilMask (0);
+  glStencilFunc (GL_ALWAYS, 0, 0);                            /* Always pass stencil test */
+  glDisable (GL_STENCIL_TEST);                                /* Disable Stencil test */
+
+  priv->subcomposite_stencil_bit = 0;
+}
+
 int
 ghid_set_layer (const char *name, int group, int empty)
 {
   render_priv *priv = gport->render_priv;
-  int stencil_bit;
   bool group_visible = false;
+  bool subcomposite = true;
   int idx = group;
   if (idx >= 0 && idx < max_group)
     {
@@ -175,6 +211,7 @@ ghid_set_layer (const char *name, int group, int empty)
   if (idx >= 0 && idx < max_copper_layer + 2)
     {
       priv->trans_lines = true;
+      subcomposite = true;
       group_visible = PCB->Data->Layer[idx].On;
     }
   else if (idx < 0)
@@ -182,44 +219,40 @@ ghid_set_layer (const char *name, int group, int empty)
       switch (SL_TYPE (idx))
 	{
 	case SL_INVISIBLE:
+	  priv->trans_lines = false;
+	  subcomposite = false;
 	  group_visible = PCB->InvisibleObjectsOn;
 	  break;
 	case SL_MASK:
+	  priv->trans_lines = true;
+	  subcomposite = false;
 	  group_visible = TEST_FLAG (SHOWMASKFLAG, PCB);
 	  break;
 	case SL_SILK:
 	  priv->trans_lines = true;
+	  subcomposite = true;
 	  group_visible = PCB->ElementOn;
 	  break;
 	case SL_ASSY:
 	  break;
 	case SL_PDRILL:
 	case SL_UDRILL:
+	  priv->trans_lines = true;
+	  subcomposite = true;
 	  group_visible = true;
 	  break;
 	case SL_RATS:
-	  if (PCB->RatOn)
-	    priv->trans_lines = true;
+	  priv->trans_lines = true;
+	  subcomposite = false;
 	  group_visible = PCB->RatOn;
 	  break;
 	}
     }
 
-  glEnable (GL_STENCIL_TEST);                                 /* Enable Stencil test */
-  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);                 /* Stencil pass => replace stencil value (with 1) */
-
-  hidgl_return_stencil_bit (priv->subcomposite_stencil_bit);  /* Relinquish any bitplane we previously used */
+  end_subcomposite ();
 
-  if (group_visible) {
-    stencil_bit = hidgl_assign_clear_stencil_bit();           /* Get a new (clean) bitplane to stencil with */
-    glStencilMask (stencil_bit);                              /* Only write to our subcompositing stencil bitplane */
-    glStencilFunc (GL_GREATER, stencil_bit, stencil_bit);     /* Pass stencil test if our assigned bit is clear */
-    priv->subcomposite_stencil_bit = stencil_bit;
-  } else {
-    stencil_bit = 0;
-    glStencilMask (0);
-    glStencilFunc (GL_ALWAYS, 0, 0);  /* Always pass stencil test */
-  }
+  if (group_visible && subcomposite)
+    start_subcomposite ();
 
   return group_visible;
 }
@@ -227,18 +260,7 @@ ghid_set_layer (const char *name, int group, int empty)
 static void
 ghid_end_layer (void)
 {
-  render_priv *priv = gport->render_priv;
-
-  /* Flush out any existing geoemtry to be rendered */
-  hidgl_flush_triangles (&buffer);
-
-  /* Relinquish any bitplane we previously used */
-  hidgl_return_stencil_bit (priv->subcomposite_stencil_bit);
-  priv->subcomposite_stencil_bit = 0;
-
-  /* Always pass stencil test */
-  glStencilMask (0);
-  glStencilFunc (GL_ALWAYS, 0, 0);
+  end_subcomposite ();
 }
 
 void
@@ -1858,7 +1880,7 @@ ghid_draw_everything (BoxTypePtr drawn_area)
 
   /* Draw pins, pads, vias below silk */
   if (global_view_2d) {
-    gui->set_layer (NULL, SWAP_IDENT ? solder_group : component_group, 0);
+    start_subcomposite ();
 
     if (!TEST_FLAG (THINDRAWFLAG, PCB)) {
       /* Mask out drilled holes */
@@ -1875,7 +1897,7 @@ ghid_draw_everything (BoxTypePtr drawn_area)
     if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_callback, NULL);
     if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, via_callback, NULL);
 
-    gui->end_layer ();
+    end_subcomposite ();
   }
 
   /* Draw the solder mask if turned on */

Bottom: d4b08189fdb10c3b1d5bc5b796b0285ec9e6c744
Top:    18a5fc9a977a10f38104af891ede0a4920181d23
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-10-01 13:36:38 +0100

Refresh of toporouter-re-implement-functi

---

diff --git a/src/toporouter.c b/src/toporouter.c
index 1c4c332..139b3ca 100644
--- a/src/toporouter.c
+++ b/src/toporouter.c
@@ -717,53 +717,20 @@ print_trace (void)
   free (strings);
 }
 */
-/* fills in x and y with coordinates of point from a towards b of distance d */
-void
-point_from_point_to_point(toporouter_vertex_t *a, toporouter_vertex_t *b, gdouble d, gdouble *x, gdouble *y)
-{
-  gdouble dx = vx(b) - vx(a);
-  gdouble dy = vy(b) - vy(a);
-  gdouble theta = atan(fabs(dy/dx));
-
-//#ifdef DEBUG_EXPORT  
-  if(!finite(theta)) {
-//    printf("!finte(theta): a = %f,%f b = %f,%f d = %f\n", vx(a), vy(a), vx(b), vy(b), d);
-//    print_trace();
-    //TODO: this shouldn't happen, fix the hack
-    *x = vx(a);
-    *y = vy(a);
-    return;
-  }
-//#endif
 
-  g_assert(finite(theta));
-
-  *x = vx(a); *y = vy(a);
-
-  if( dx >= 0. ) {
-
-    if( dy >= 0. ) {
-      *x += d * cos(theta);
-      *y += d * sin(theta);
-    }else{
-      *x += d * cos(theta);
-      *y -= d * sin(theta);
-    }
-
-  }else{
-    
-    if( dy >= 0. ) {
-      *x -= d * cos(theta);
-      *y += d * sin(theta);
-    }else{
-      *x -= d * cos(theta);
-      *y -= d * sin(theta);
-    }
+/* fills in x and y with coordinates of point from a towards b of distance d */
+static void
+point_from_point_to_point (toporouter_vertex_t *a,
+                           toporouter_vertex_t *b,
+                           double d,
+                           double *x, double *y)
+{
+  double theta = atan2 (vy(b) - vy(a), vx(b) - vx(a));
 
-  }
+  *x = vx(a) + d * cos (theta);
+  *y = vy(a) + d * sin (theta);
 }
 
-
 static inline gint
 coord_wind(gdouble ax, gdouble ay, gdouble bx, gdouble by, gdouble cx, gdouble cy) 
 {
@@ -816,78 +783,30 @@ sloppy_vertex_wind(GtsVertex *a, GtsVertex *b, GtsVertex *c)
 }
 
 /* moves vertex v d units in the direction of vertex p */
-void
-coord_move_towards_coord_values(gdouble ax, gdouble ay, gdouble px, gdouble py, gdouble d, gdouble *x, gdouble *y) 
+static void
+coord_move_towards_coord_values (double ax, double ay,
+                                 double px, double py,
+                                 double d,
+                                 double *x, double *y)
 {
-  gdouble dx = px - ax;
-  gdouble dy = py - ay;
-  gdouble theta = atan(fabs(dy/dx));
-
-
-  if(!finite(theta)) {
-    printf("!finite(theta) a = %f,%f p = %f,%f d = %f\n", 
-        ax, ay, px, py, d);
-
-  }
-
-  g_assert(finite(theta));
-
-  if( dx >= 0. ) {
-
-    if( dy >= 0. ) {
-      *x = ax + (d * cos(theta));
-      *y = ay + (d * sin(theta));
-    }else{
-      *x = ax + (d * cos(theta));
-      *y = ay - (d * sin(theta));
-    }
-
-  }else{
-    
-    if( dy >= 0. ) {
-      *x = ax - (d * cos(theta));
-      *y = ay + (d * sin(theta));
-    }else{
-      *x = ax - (d * cos(theta));
-      *y = ay - (d * sin(theta));
-    }
-
-  }
+  double theta = atan2 (py - ay, px - ax);
 
+  *x = ax + d * cos (theta);
+  *y = ay + d * sin (theta);
 }
 
 /* moves vertex v d units in the direction of vertex p */
-void
-vertex_move_towards_vertex_values(GtsVertex *v, GtsVertex *p, gdouble d, gdouble *x, gdouble *y) 
+static void
+vertex_move_towards_vertex_values (GtsVertex *v,
+                                   GtsVertex *p,
+                                   double d,
+                                   double *x, double *y)
 {
-  gdouble dx = GTS_POINT(p)->x - GTS_POINT(v)->x;
-  gdouble dy = GTS_POINT(p)->y - GTS_POINT(v)->y;
-  gdouble theta = atan(fabs(dy/dx));
-
-  g_assert(finite(theta));
-
-  if( dx >= 0. ) {
-
-    if( dy >= 0. ) {
-      *x = GTS_POINT(v)->x + (d * cos(theta));
-      *y = GTS_POINT(v)->y + (d * sin(theta));
-    }else{
-      *x = GTS_POINT(v)->x + (d * cos(theta));
-      *y = GTS_POINT(v)->y - (d * sin(theta));
-    }
-
-  }else{
-    
-    if( dy >= 0. ) {
-      *x = GTS_POINT(v)->x - (d * cos(theta));
-      *y = GTS_POINT(v)->y + (d * sin(theta));
-    }else{
-      *x = GTS_POINT(v)->x - (d * cos(theta));
-      *y = GTS_POINT(v)->y - (d * sin(theta));
-    }
-
-  }
+  double theta = atan2 (GTS_POINT(p)->y - GTS_POINT(v)->y,
+                        GTS_POINT(p)->x - GTS_POINT(v)->x);
 
+  *x = GTS_POINT(v)->x + d * cos (theta);
+  *y = GTS_POINT(v)->y + d * sin (theta);
 }
 
 #define tv_on_layer(v,l) (l == TOPOROUTER_BBOX(TOPOROUTER_VERTEX(v)->boxes->data)->layer)
@@ -2604,48 +2523,17 @@ visited_cmp(gconstpointer a, gconstpointer b)
   return 0;
 }
 
-gdouble 
-coord_xangle(gdouble ax, gdouble ay, gdouble bx, gdouble by) 
+static double
+coord_xangle (double ax, double ay,
+              double bx, double by)
 {
-  gdouble dx, dy, theta;
-
-  dx = fabs(ax - bx);
-  dy = fabs(ay - by);
-  
-  if(dx < EPSILON) {
-    theta = M_PI / 2.;
-  } else theta = atan(dy/dx);
-
-  if(by <= ay) {
-    if(bx < ax) theta = M_PI - theta;
-  }else{
-    if(bx < ax) theta += M_PI;
-    else theta = (2 * M_PI) - theta;
-  }
-  
-  return theta;  
+  return atan2 (ay - by, ax - bx);
 }
 
-gdouble 
-point_xangle(GtsPoint *a, GtsPoint *b) 
+static double
+point_xangle (GtsPoint *a, GtsPoint *b)
 {
-  gdouble dx, dy, theta;
-
-  dx = fabs(a->x - b->x);
-  dy = fabs(a->y - b->y);
-  
-  if(dx < EPSILON) {
-    theta = M_PI / 2.;
-  } else theta = atan(dy/dx);
-
-  if(b->y >= a->y) {
-    if(b->x < a->x) theta = M_PI - theta;
-  }else{
-    if(b->x < a->x) theta += M_PI;
-    else theta = (2 * M_PI) - theta;
-  }
-
-  return theta;  
+  return atan2 (a->y - b->y, a->x - b->x);
 }
 
 
@@ -5163,36 +5051,15 @@ routing_return:
 
 /* moves vertex v d units in the direction of vertex p */
 void
-vertex_move_towards_vertex(GtsVertex *v, GtsVertex *p, gdouble d) 
+vertex_move_towards_vertex (GtsVertex *v,
+                            GtsVertex *p,
+                            double d)
 {
-  gdouble dx = GTS_POINT(p)->x - GTS_POINT(v)->x;
-  gdouble dy = GTS_POINT(p)->y - GTS_POINT(v)->y;
-  gdouble theta = atan(fabs(dy/dx));
-
-  g_assert(finite(theta));
-
-  if( dx >= 0. ) {
-
-    if( dy >= 0. ) {
-      GTS_POINT(v)->x += d * cos(theta);
-      GTS_POINT(v)->y += d * sin(theta);
-    }else{
-      GTS_POINT(v)->x += d * cos(theta);
-      GTS_POINT(v)->y -= d * sin(theta);
-    }
-
-  }else{
-    
-    if( dy >= 0. ) {
-      GTS_POINT(v)->x -= d * cos(theta);
-      GTS_POINT(v)->y += d * sin(theta);
-    }else{
-      GTS_POINT(v)->x -= d * cos(theta);
-      GTS_POINT(v)->y -= d * sin(theta);
-    }
-
-  }
+  double theta = atan2 (GTS_POINT(p)->y - GTS_POINT(v)->y,
+                        GTS_POINT(p)->x - GTS_POINT(v)->x);
 
+  GTS_POINT(v)->x += d * cos (theta);
+  GTS_POINT(v)->y += d * sin (theta);
 }

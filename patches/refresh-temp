Bottom: eca7f5df5f2595411e2d516ee8be542180c9cb2e
Top:    cc0853d4925554435a57bd78c87ad3a2d119b27d
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2012-12-05 23:46:13 +0000

Refresh of add-a-load-more-hacky-models-f

---

diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index b0f80d7..235b0f9 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -140,5 +140,6 @@ void hidgl_draw_800mil_resistor (ElementType *element, float surface_depth, floa
 void hidgl_draw_2300mil_resistor (ElementType *element, float surface_depth, float board_thickness);
 void hidgl_draw_700mil_diode_smd (ElementType *element, float surface_depth, float board_thickness);
 void hidgl_draw_1650mil_cap (ElementType *element, float surface_depth, float board_thickness);
+void hidgl_draw_350x800mil_cap (ElementType *element, float surface_depth, float board_thickness);
 
 #endif /* PCB_HID_COMMON_HIDGL_H  */
diff --git a/src/hid/common/hidgl_package_acy_resistor.c b/src/hid/common/hidgl_package_acy_resistor.c
index 4e4766f..8280d2d 100644
--- a/src/hid/common/hidgl_package_acy_resistor.c
+++ b/src/hid/common/hidgl_package_acy_resistor.c
@@ -2314,6 +2314,317 @@ hidgl_draw_1650mil_cap (ElementType *element, float surface_depth, float board_t
 
   first_run = false;
 }
+
+void
+hidgl_draw_350x800mil_cap (ElementType *element, float surface_depth, float board_thickness)
+{
+
+  float center_x, center_y;
+  float angle;
+  GLfloat resistor_body_color[] =         {0.84, 0.34, 0.00};
+  GLfloat resistor_pin_color[] =          {0.82, 0.82, 0.82};
+  GLfloat resistor_warn_pin_color[] =     {0.82, 0.20, 0.20};
+  GLfloat resistor_found_pin_color[] =    {0.20, 0.82, 0.20};
+  GLfloat resistor_selected_pin_color[] = {0.00, 0.70, 0.82};
+  GLfloat *pin_color;
+
+  GLfloat mvm[16];
+
+  int strip;
+  int no_strips = NUM_RESISTOR_STRIPS;
+  int ring;
+  int no_rings = NUM_PIN_RINGS;
+  int end;
+
+  static bool first_run = true;
+  static GLuint texture1;
+  static GLuint texture2_resistor;
+
+  GLuint restore_sp;
+
+  /* XXX: Hard-coded magic */
+  float resistor_pin_radius = MIL_TO_COORD (22.);
+  float resistor_barrel_radius = MIL_TO_COORD (400.);
+
+  float pin_penetration_depth = resistor_barrel_radius + board_thickness;
+
+  float resistor_pin_bend_radius = MIL_TO_COORD (80.);
+  float resistor_width = MIL_TO_COORD (400.);
+
+  PinType *first_pin = element->Pin->data;
+  PinType *second_pin = g_list_next (element->Pin)->data;
+  PinType *pin;
+
+  Coord pin_delta_x = second_pin->X - first_pin->X;
+  Coord pin_delta_y = second_pin->Y - first_pin->Y;
+
+  center_x = first_pin->X + pin_delta_x / 2.;
+  center_y = first_pin->Y + pin_delta_y / 2.;
+  angle = atan2f (pin_delta_y, pin_delta_x) - atan2f (-800., 350.);
+
+  /* TRANSFORM MATRIX */
+  glPushMatrix ();
+  glTranslatef (center_x, center_y, surface_depth + resistor_barrel_radius);
+  glRotatef (angle * 180. / M_PI + 90, 0., 0., 1.);
+  glRotatef (90, 1., 0., 0.);
+
+  /* Retrieve the resulting modelview matrix for the lighting calculations */
+  glGetFloatv (GL_MODELVIEW_MATRIX, (GLfloat *)mvm);
+
+  /* TEXTURE SETUP */
+  glGetIntegerv (GL_CURRENT_PROGRAM, (GLint*)&restore_sp);
+  hidgl_shader_activate (resistor_program);
+
+  {
+    GLuint program = hidgl_shader_get_program (resistor_program);
+    int tex0_location = glGetUniformLocation (program, "detail_tex");
+    int tex1_location = glGetUniformLocation (program, "bump_tex");
+    glUniform1i (tex0_location, 0);
+    glUniform1i (tex1_location, 1);
+  }
+
+  glActiveTextureARB (GL_TEXTURE0_ARB);
+//  if (first_run) {
+    glGenTextures (1, &texture1);
+    glBindTexture (GL_TEXTURE_1D, texture1);
+    setup_resistor_2300mil_texture (element, resistor_body_color);
+//  } else {
+//    glBindTexture (GL_TEXTURE_1D, texture1);
+//  }
+  glTexEnvf (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+  glTexParameterf (GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+  glTexParameterf (GL_TEXTURE_1D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+  glTexParameterf (GL_TEXTURE_1D, GL_TEXTURE_WRAP_S, GL_CLAMP);
+  glEnable (GL_TEXTURE_1D);
+
+  glActiveTextureARB (GL_TEXTURE1_ARB);
+  if (first_run) {
+    glGenTextures (1, &texture2_resistor);
+    glBindTexture (GL_TEXTURE_2D, texture2_resistor);
+    load_texture_from_png ("resistor_2300mil_bump.png", true);
+  }
+  glBindTexture (GL_TEXTURE_2D, texture2_resistor);
+
+  glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+  glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+  glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
+  glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
+  glEnable (GL_TEXTURE_2D);
+  glActiveTextureARB (GL_TEXTURE0_ARB);
+
+  /* COLOR / MATERIAL SETUP */
+//  glColorMaterial (GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
+//  glEnable (GL_COLOR_MATERIAL);
+
+  glPushAttrib (GL_CURRENT_BIT);
+//  glColor4f (1., 1., 1., 1.);
+  glColor4f (0., 0., 1., 0.);
+
+  glDisable (GL_LIGHTING);
+
+  if (1) {
+    GLfloat emission[] = {0.0f, 0.0f, 0.0f, 1.0f};
+    GLfloat specular[] = {0.5f, 0.5f, 0.5f, 1.0f};
+    GLfloat shininess = 20.;
+    glMaterialfv (GL_FRONT_AND_BACK, GL_EMISSION, emission);
+    glMaterialfv (GL_FRONT_AND_BACK, GL_SPECULAR, specular);
+    glMaterialfv (GL_FRONT_AND_BACK, GL_SHININESS, &shininess);
+  }
+
+#if 1
+  glBegin (GL_TRIANGLE_STRIP);
+
+  for (strip = 0; strip < no_strips; strip++) {
+
+    int ring;
+    int no_rings;
+    float angle_edge1 = strip * 2. * M_PI / no_strips;
+    float angle_edge2 = (strip + 1) * 2. * M_PI / no_strips;
+
+    float cos_edge1 = cosf (angle_edge1);
+    float sin_edge1 = sinf (angle_edge1);
+    float cos_edge2 = cosf (angle_edge2);
+    float sin_edge2 = sinf (angle_edge2);
+
+    struct strip_item {
+      GLfloat z;
+      GLfloat r;
+      GLfloat tex0_s;
+    } strip_data[] = {
+      {-resistor_width / 2. - 1.,                            0.,                      0.}, /* DUMMY */
+      {-resistor_width / 2.,                                 0.,                      0.},
+      {-resistor_width / 2.,                                 resistor_barrel_radius,  0.},
+                                                             /*********************/
+      { 0,                                                   resistor_barrel_radius,  0.5},
+                                                             /*********************/
+      { resistor_width / 2.,                                 resistor_barrel_radius,  1.},
+      { resistor_width / 2.,                                 0.,                      1.},
+      { resistor_width / 2. + 1.,                            0.,                      1.}, /* DUMMY */
+    };
+
+    no_rings = sizeof (strip_data) / sizeof (struct strip_item);
+    for (ring = 1; ring < no_rings - 1; ring++) {
+      enum geom_pos pos = MIDDLE;
+      if (ring == 1)            pos = FIRST;
+      if (ring == no_rings - 2) pos = LAST;
+
+      emit_pair (angle_edge1, cos_edge1, sin_edge1,
+                 angle_edge2, cos_edge2, sin_edge2,
+                 strip_data[ring - 1].r, strip_data[ring - 1].z,
+                 strip_data[ring    ].r, strip_data[ring    ].z,
+                 strip_data[ring + 1].r, strip_data[ring + 1].z,
+                 strip_data[ring    ].tex0_s, resistor_width, pos, mvm);
+    }
+  }
+#endif
+
+  glEnd ();
+
+  glActiveTextureARB (GL_TEXTURE1_ARB);
+  glDisable (GL_TEXTURE_2D);
+  glBindTexture (GL_TEXTURE_2D, 0);
+
+  glActiveTextureARB (GL_TEXTURE0_ARB);
+  glDisable (GL_TEXTURE_1D);
+  glBindTexture (GL_TEXTURE_1D, 0);
+  glDeleteTextures (1, &texture1);
+
+  glEnable (GL_LIGHTING);
+
+  glUseProgram (0);
+
+  /* COLOR / MATERIAL SETUP */
+  glColorMaterial (GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
+  glEnable (GL_COLOR_MATERIAL);
+
+  if (1) {
+//    GLfloat ambient[] = {0.0, 0.0, 0.0, 1.0};
+    GLfloat specular[] = {0.5, 0.5, 0.5, 1.0};
+    GLfloat shininess = 120.;
+    glMaterialfv (GL_FRONT_AND_BACK, GL_SPECULAR, specular);
+    glMaterialfv (GL_FRONT_AND_BACK, GL_SHININESS, &shininess);
+  }
+
+  for (end = 0; end < 2; end++) {
+    float end_sign = (end == 0) ? 1. : -1.;
+
+    pin = (end == 1) ? first_pin : second_pin;
+
+    if (TEST_FLAG (WARNFLAG, pin))
+      pin_color = resistor_warn_pin_color;
+    else if (TEST_FLAG (SELECTEDFLAG, pin))
+      pin_color = resistor_selected_pin_color;
+    else if (TEST_FLAG (FOUNDFLAG, pin))
+      pin_color = resistor_found_pin_color;
+    else
+      pin_color = resistor_pin_color;
+
+    glColor3f (pin_color[0] / 1.5,
+               pin_color[1] / 1.5,
+               pin_color[2] / 1.5);
+
+    for (ring = 0; ring < no_rings; ring++) {
+
+      float angle_ring_edge1 = ring * M_PI / 2. / no_rings + ((end == 0) ? 0. : -M_PI / 2.);
+      float angle_ring_edge2 = (ring + 1) * M_PI / 2. / no_rings + ((end == 0) ? 0. : -M_PI / 2.);
+      float y_strip_edge1 = cosf (angle_ring_edge1);
+      float z_strip_edge1 = sinf (angle_ring_edge1);
+      float y_strip_edge2 = cosf (angle_ring_edge2);
+      float z_strip_edge2 = sinf (angle_ring_edge2);
+      float r = resistor_pin_bend_radius;
+
+      glBegin (GL_TRIANGLE_STRIP);
+
+      /* NB: We wrap back around to complete the last segment, so in effect
+       *     we draw no_strips + 1 strips.
+       */
+      for (strip = 0; strip < no_strips + 1; strip++) {
+        float strip_angle = strip * 2. * M_PI / no_strips;
+
+        float x1 = resistor_pin_radius * sin (strip_angle) * -z_strip_edge1 + r * -z_strip_edge1 + r * end_sign + MIL_TO_COORD (800./2.) * -end_sign;
+        float y1 = resistor_pin_radius * sin (strip_angle) * y_strip_edge1 + r * y_strip_edge1 - r - MIL_TO_COORD (200.);
+        float z1 = resistor_pin_radius * cos (strip_angle) + MIL_TO_COORD (350./2.) * end_sign;
+
+        float x2 = resistor_pin_radius * sin (strip_angle) * -z_strip_edge2 + r * -z_strip_edge2 + r * end_sign + MIL_TO_COORD (800./2.) * -end_sign;
+        float y2 = resistor_pin_radius * sin (strip_angle) * y_strip_edge2 + r * y_strip_edge2 - r - MIL_TO_COORD (200.);
+        float z2 = resistor_pin_radius * cos (strip_angle) + MIL_TO_COORD (350./2.) * end_sign;
+
+        glNormal3f (sin (strip_angle) * -z_strip_edge1, sin (strip_angle) * y_strip_edge1, cos (strip_angle));
+        glVertex3f (x1, y1, z1);
+        glNormal3f (sin (strip_angle) * -z_strip_edge2, sin (strip_angle) * y_strip_edge2, cos (strip_angle));
+        glVertex3f (x2, y2, z2);
+      }
+      glEnd ();
+    }
+
+    if (1) {
+      float r = resistor_pin_bend_radius;
+      glBegin (GL_TRIANGLE_STRIP);
+
+      /* NB: We wrap back around to complete the last segment, so in effect
+       *     we draw no_strips + 1 strips.
+       */
+      for (strip = 0; strip < no_strips + 1; strip++) {
+        float strip_angle = strip * 2. * M_PI / no_strips;
+
+        float x1 = resistor_pin_radius * cos (strip_angle) + MIL_TO_COORD (800./2.) * -end_sign;
+        float y1 = -r - MIL_TO_COORD (200.);
+        float z1 = resistor_pin_radius * sin (strip_angle) + MIL_TO_COORD (350./2.) * end_sign;
+
+        float x2 = resistor_pin_radius * cos (strip_angle) + MIL_TO_COORD (800./2.) * -end_sign;
+        float y2 = -r - pin_penetration_depth;
+        float z2 = resistor_pin_radius * sin (strip_angle) + MIL_TO_COORD (350./2.) * end_sign;
+
+        glNormal3f (cos (strip_angle), 0., sin (strip_angle));
+        glVertex3f (x1, y1, z1);
+        glNormal3f (cos (strip_angle), 0., sin (strip_angle));
+        glVertex3f (x2, y2, z2);
+      }
+      glEnd ();
+    }
+
+    if (1) {
+      float r = resistor_pin_bend_radius;
+      glBegin (GL_TRIANGLE_FAN);
+
+      glNormal3f (0, 0., -1.);
+      glVertex3f (MIL_TO_COORD (800./2.) * -end_sign, -r - pin_penetration_depth - resistor_pin_radius / 2., MIL_TO_COORD (350./2.) * end_sign);
+
+      /* NB: We wrap back around to complete the last segment, so in effect
+       *     we draw no_strips + 1 strips.
+       */
+      for (strip = no_strips + 1; strip > 0; strip--) {
+        float strip_angle = strip * 2. * M_PI / no_strips;
+
+        float x = resistor_pin_radius * cos (strip_angle) + MIL_TO_COORD (800./2.) * -end_sign;
+        float y = -r - pin_penetration_depth;
+        float z = resistor_pin_radius * sin (strip_angle) + MIL_TO_COORD (350./2.) * end_sign;
+
+        glNormal3f (cos (strip_angle), 0., sin (strip_angle));
+        glVertex3f (x, y, z);
+      }
+      glEnd ();
+    }
+  }
+
+  glDisable (GL_COLOR_MATERIAL);
+  glPopAttrib ();
+
+  glDisable (GL_LIGHTING);
+//  glDisable (GL_DEPTH_TEST);
+
+  glPushMatrix ();
+  glLoadIdentity ();
+  debug_basis_display ();
+  glPopMatrix ();
+//  glEnable (GL_DEPTH_TEST);
+
+  glPopMatrix ();
+  glUseProgram (restore_sp);
+
+  first_run = false;
+}
+
 static float
 determinant_4x4 (float m[4][4])
 {
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index d57045b..3190ea1 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -1768,6 +1768,11 @@ frontE_package_callback (const BoxType * b, void *cl)
         int layer_group = FRONT (element) ? 0 : max_copper_layer - 1; /* XXX: FIXME */
         hidgl_draw_1650mil_cap (element, compute_depth (layer_group), BOARD_THICKNESS);
       }
+
+      if (strcmp (element->Name[DESCRIPTION_INDEX].TextString, "cap_15000V_2500pF.fp") == 0) {
+        int layer_group = FRONT (element) ? 0 : max_copper_layer - 1; /* XXX: FIXME */
+        hidgl_draw_350x800mil_cap (element, compute_depth (layer_group), BOARD_THICKNESS);
+      }
     }
   return 1;
 }

Bottom: 986e06d8cfd74bba64998499bae9b76c01e2a0e1
Top:    aa1538b9e03d018e9152e089f33da2562741c239
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2008-10-10 11:30:59 +0100

Refresh of add_pours

---

diff --git a/src/pour.c b/src/pour.c
new file mode 100644
index 0000000..61b5d80
--- /dev/null
+++ b/src/pour.c
@@ -0,0 +1,229 @@
+/* $Id$ */
+
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 1994,1995,1996 Thomas Nau
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Contact addresses for paper mail and Email:
+ *  Thomas Nau, Schlehenweg 15, 88471 Baustetten, Germany
+ *  Thomas.Nau@rz.uni-ulm.de
+ *
+ */
+
+
+/* special polygon editing routines
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <assert.h>
+#include <math.h>
+#include <memory.h>
+#include <setjmp.h>
+
+#include "global.h"
+#include "box.h"
+#include "create.h"
+#include "crosshair.h"
+#include "data.h"
+#include "draw.h"
+#include "error.h"
+#include "find.h"
+#include "misc.h"
+#include "move.h"
+#include "polygon.h"
+#include "pour.h"
+#include "remove.h"
+#include "rtree.h"
+#include "search.h"
+#include "set.h"
+#include "thermal.h"
+#include "undo.h"
+
+#ifdef HAVE_LIBDMALLOC
+#include <dmalloc.h>
+#endif
+
+RCSID ("$Id$");
+
+#define ROUND(x) ((long)(((x) >= 0 ? (x) + 0.5  : (x) - 0.5)))
+
+#define UNSUBTRACT_BLOAT 10
+
+/* ---------------------------------------------------------------------------
+ * local prototypes
+ */
+
+#define CIRC_SEGS 36
+static double circleVerticies[] = {
+  1.0, 0.0,
+  0.98480775301221, 0.17364817766693,
+};
+
+#if 0
+int
+InitClip (DataTypePtr Data, LayerTypePtr layer, PolygonType * p)
+{
+  if (p->Clipped)
+    poly_Free (&p->Clipped);
+  p->Clipped = original_poly (p);
+  if (p->NoHoles)
+    poly_Free (&p->NoHoles);
+  p->NoHoles = NULL;
+  if (!p->Clipped)
+    return 0;
+  assert (poly_Valid (p->Clipped));
+  if (TEST_FLAG (CLEARPOLYFLAG, p))
+    clearPoly (Data, layer, p, NULL, 0);
+  else
+    p->NoHolesValid = 0;
+  return 1;
+}
+#endif
+
+/* --------------------------------------------------------------------------
+ * remove redundant polygon points. Any point that lies on the straight
+ * line between the points on either side of it is redundant.
+ * returns true if any points are removed
+ */
+Boolean
+RemoveExcessPourPoints (LayerTypePtr Layer, PolygonTypePtr Polygon)
+{
+  return RemoveExcessPolygonPoints (Layer, Polygon);
+}
+
+/* ---------------------------------------------------------------------------
+ * returns the index of the polygon point which is the end
+ * point of the segment with the lowest distance to the passed
+ * coordinates
+ */
+Cardinal
+GetLowestDistancePourPoint (PolygonTypePtr Polygon, LocationType X,
+                            LocationType Y)
+{
+  return GetLowestDistancePourPoint (Polygon, X, Y);
+}
+
+/* ---------------------------------------------------------------------------
+ * go back to the  previous point of the polygon
+ */
+void
+GoToPreviousPourPoint (void)
+{
+  switch (Crosshair.AttachedPolygon.PointN)
+    {
+      /* do nothing if mode has just been entered */
+    case 0:
+      break;
+
+      /* reset number of points and 'LINE_MODE' state */
+    case 1:
+      Crosshair.AttachedPolygon.PointN = 0;
+      Crosshair.AttachedLine.State = STATE_FIRST;
+      addedLines = 0;
+      break;
+
+      /* back-up one point */
+    default:
+      {
+        PointTypePtr points = Crosshair.AttachedPolygon.Points;
+        Cardinal n = Crosshair.AttachedPolygon.PointN - 2;
+
+        Crosshair.AttachedPolygon.PointN--;
+        Crosshair.AttachedLine.Point1.X = points[n].X;
+        Crosshair.AttachedLine.Point1.Y = points[n].Y;
+        break;
+      }
+    }
+}
+
+/* ---------------------------------------------------------------------------
+ * close pour if possible
+ */
+void
+ClosePour (void)
+{
+  Cardinal n = Crosshair.AttachedPolygon.PointN;
+
+  /* check number of points */
+  if (n >= 3)
+    {
+      /* if 45 degree lines are what we want do a quick check
+       * if closing the polygon makes sense
+       */
+      if (!TEST_FLAG (ALLDIRECTIONFLAG, PCB))
+        {
+          BDimension dx, dy;
+
+          dx = abs (Crosshair.AttachedPolygon.Points[n - 1].X -
+                    Crosshair.AttachedPolygon.Points[0].X);
+          dy = abs (Crosshair.AttachedPolygon.Points[n - 1].Y -
+                    Crosshair.AttachedPolygon.Points[0].Y);
+          if (!(dx == 0 || dy == 0 || dx == dy))
+            {
+              Message
+                (_
+                 ("Cannot close polygon because 45 degree lines are requested.\n"));
+              return;
+            }
+        }
+      CopyAttachedPolygonToLayer ();
+      Draw ();
+    }
+  else
+    Message (_("A polygon has to have at least 3 points\n"));
+}
+
+/* ---------------------------------------------------------------------------
+ * moves the data of the attached (new) polygon to the current layer
+ */
+void
+CopyAttachedPourToLayer (void)
+{
+  PolygonTypePtr polygon;
+  int saveID;
+
+  /* move data to layer and clear attached struct */
+  polygon = CreateNewPolygon (CURRENT, NoFlags ());
+  saveID = polygon->ID;
+  *polygon = Crosshair.AttachedPolygon;
+  polygon->ID = saveID;
+  SET_FLAG (CLEARPOLYFLAG, polygon);
+  if (TEST_FLAG (NEWFULLPOLYFLAG, PCB))
+    SET_FLAG (FULLPOLYFLAG, polygon);
+  memset (&Crosshair.AttachedPolygon, 0, sizeof (PolygonType));
+  SetPolygonBoundingBox (polygon);
+  if (!CURRENT->polygon_tree)
+    CURRENT->polygon_tree = r_create_tree (NULL, 0, 0);
+  r_insert_entry (CURRENT->polygon_tree, (BoxType *) polygon, 0);
+  InitClip (PCB->Data, CURRENT, polygon);
+  DrawPolygon (CURRENT, polygon, 0);
+  SetChangedFlag (True);
+
+  /* reset state of attached line */
+  Crosshair.AttachedLine.State = STATE_FIRST;
+  addedLines = 0;
+
+  /* add to undo list */
+  AddObjectToCreateUndoList (POLYGON_TYPE, CURRENT, polygon, polygon);
+  IncrementUndoSerialNumber ();
+}
+
diff --git a/src/pour.h b/src/pour.h
new file mode 100644
index 0000000..0ed875e
--- /dev/null
+++ b/src/pour.h
@@ -0,0 +1,43 @@
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 1994,1995,1996 Thomas Nau
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Contact addresses for paper mail and Email:
+ *  Thomas Nau, Schlehenweg 15, 88471 Baustetten, Germany
+ *  Thomas.Nau@rz.uni-ulm.de
+ *
+ *  RCS: $Id$
+ */
+
+/* prototypes for pour editing routines
+ */
+
+#ifndef	__POUR_INCLUDED__
+#define	__POUR_INCLUDED__
+
+#include "global.h"
+
+Cardinal GetLowestDistancePourPoint (PolygonTypePtr,
+					LocationType, LocationType);
+Boolean RemoveExcessPourPoints (LayerTypePtr, PolygonTypePtr);
+void GoToPreviousPourPoint (void);
+void ClosePour (void);
+void CopyAttachedPourToLayer (void);
+//int InitClip(DataType *d, LayerType *l, PolygonType *p);
+#endif

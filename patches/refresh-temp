Bottom: 06bc2b822a1fb92dc4248fd06457511b76e0ad77
Top:    294ca3f6b98aea6df8aa88e4a8e86adbe30e523b
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-11-03 01:24:37 +0000

Refresh of play-with-glsl-shader-for-rend

---

diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index 7c8671d..1771b93 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -76,29 +76,26 @@ hidgl_new_triangle_array (void)
 #endif
 
 #define NUM_BUF_GLFLOATS (3 * (3 + 2) * TRIANGLE_ARRAY_SIZE)
-#define USE_TWO_VBO
-//#undef USE_TWO_VBO
 
-void
-hidgl_init_triangle_array (triangle_buffer *buffer)
-{
-  CHECK_IS_IN_CONTEXT ();
 
-  glGenBuffers (1, &buffer->primary_vbo_id);
-  glBindBuffer (GL_ARRAY_BUFFER, buffer->primary_vbo_id);
-  glBufferData (GL_ARRAY_BUFFER, NUM_BUF_GLFLOATS * sizeof (GLfloat), NULL, GL_STREAM_DRAW);
-
-#ifdef USE_TWO_VBO
-  glGenBuffers (1, &buffer->secondary_vbo_id);
-  glBindBuffer (GL_ARRAY_BUFFER, buffer->secondary_vbo_id);
-  glBufferData (GL_ARRAY_BUFFER, NUM_BUF_GLFLOATS * sizeof (GLfloat), NULL, GL_STREAM_DRAW);
-#endif
+/* NB: Caller must ensure the desired GL_ARRAY_BUFFER is bound */
+static void
+hidgl_reset_triangle_array (triangle_buffer *buffer)
+{
+  if (!buffer->local) {
+    /* Map some new memory to upload vertices into. */
+    glBufferData (GL_ARRAY_BUFFER, NUM_BUF_GLFLOATS * sizeof (GLfloat), NULL, GL_STREAM_DRAW);
+    buffer->triangle_array = glMapBuffer (GL_ARRAY_BUFFER, GL_WRITE_ONLY);
+  }
 
-  buffer->use_primary = true;
+  /* If using VBOs fails, fall back to an allocated array */
+  if (buffer->triangle_array == NULL) {
+    buffer->triangle_array = malloc (NUM_BUF_GLFLOATS * sizeof (GLfloat));
+    buffer->local = true;
+  }
 
-  glBindBuffer (GL_ARRAY_BUFFER, buffer->use_primary ? buffer->primary_vbo_id :
-                                                       buffer->secondary_vbo_id);
-  buffer->triangle_array = glMapBuffer (GL_ARRAY_BUFFER, GL_WRITE_ONLY);
+  /* Don't want this bound for now */
+  glBindBuffer (GL_ARRAY_BUFFER, 0);
 
   buffer->triangle_count = 0;
   buffer->coord_comp_count = 0;
@@ -106,18 +103,29 @@ hidgl_init_triangle_array (triangle_buffer *buffer)
 }
 
 void
+hidgl_init_triangle_array (triangle_buffer *buffer)
+{
+  CHECK_IS_IN_CONTEXT ();
+
+  glGenBuffers (1, &buffer->vbo_id);
+  glBindBuffer (GL_ARRAY_BUFFER, buffer->vbo_id);
+
+  buffer->local = false;
+  hidgl_reset_triangle_array (buffer);
+}
+
+void
 hidgl_finish_triangle_array (triangle_buffer *buffer)
 {
-  glUnmapBuffer (GL_ARRAY_BUFFER);
+  if (buffer->local) {
+    free (buffer->triangle_array);
+  } else {
+    glUnmapBuffer (GL_ARRAY_BUFFER);
+  }
   glBindBuffer (GL_ARRAY_BUFFER, 0);
 
-  glDeleteBuffers (1, &buffer->primary_vbo_id);
-  buffer->primary_vbo_id = 0;
-
-#ifdef USE_TWO_VBO
-  glDeleteBuffers (1, &buffer->secondary_vbo_id);
-  buffer->secondary_vbo_id = 0;
-#endif
+  glDeleteBuffers (1, &buffer->vbo_id);
+  buffer->vbo_id = 0;
 }
 
 #define BUF_OFFSET(x) (&((GLfloat *)NULL)[x])
@@ -129,32 +137,26 @@ hidgl_flush_triangles (triangle_buffer *buffer)
   if (buffer->vertex_count == 0)
     return;
 
-  glUnmapBuffer (GL_ARRAY_BUFFER);
-  buffer->triangle_array = NULL;
+  if (!buffer->local) {
+    glUnmapBuffer (GL_ARRAY_BUFFER);
+    buffer->triangle_array = NULL;
+  }
+
+  glBindBuffer (GL_ARRAY_BUFFER, buffer->vbo_id);
 
   glEnableClientState (GL_VERTEX_ARRAY);
-  glVertexPointer (3, GL_FLOAT, 5 * sizeof (GLfloat),
-                   BUF_OFFSET (0) /*buffer->triangle_array*/);
+  glVertexPointer (3, GL_FLOAT, 5 * sizeof (GLfloat), buffer->local ?
+                     buffer->triangle_array : BUF_OFFSET (0));
 
   glEnableClientState (GL_TEXTURE_COORD_ARRAY);
-  glTexCoordPointer (2, GL_FLOAT, 5 * sizeof (GLfloat),
-                     BUF_OFFSET (3) /*buffer->triangle_array + 3*/);
+  glTexCoordPointer (2, GL_FLOAT, 5 * sizeof (GLfloat), buffer->local ?
+                       buffer->triangle_array + 3 : BUF_OFFSET (3));
 
   glDrawArrays (GL_TRIANGLE_STRIP, 0, buffer->vertex_count);
-
   glDisableClientState (GL_VERTEX_ARRAY);
   glDisableClientState (GL_TEXTURE_COORD_ARRAY);
 
-#ifdef USE_TWO_VBO
-  buffer->use_primary = !buffer->use_primary;
-#endif
-  glBindBuffer (GL_ARRAY_BUFFER, buffer->use_primary ? buffer->primary_vbo_id :
-                                                       buffer->secondary_vbo_id);
-  buffer->triangle_array = glMapBuffer (GL_ARRAY_BUFFER, GL_WRITE_ONLY);
-
-  buffer->triangle_count = 0;
-  buffer->vertex_count = 0;
-  buffer->coord_comp_count = 0;
+  hidgl_reset_triangle_array (buffer);
 }
 
 void
@@ -476,6 +478,7 @@ hidgl_draw_arc (double width, int x, int y, int rx, int ry,
 void
 hidgl_draw_rect (int x1, int y1, int x2, int y2)
 {
+  return;
   CHECK_IS_IN_CONTEXT ();
   glBegin (GL_LINE_LOOP);
   glVertex3f (x1, y1, global_depth);
@@ -900,6 +903,7 @@ hidgl_fill_rect (int x1, int y1, int x2, int y2)
 static void
 printLog(GLuint obj)
 {
+  return;
   int infologLength = 0;
   int maxLength;
   char *infoLog;
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index 88a9120..1e289dc 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -35,9 +35,8 @@ typedef struct {
   unsigned int vertex_count;
   unsigned int total_triangles;
   unsigned int total_vertices;
-  GLuint primary_vbo_id;
-  GLuint secondary_vbo_id;
-  bool use_primary;
+  GLuint vbo_id;
+  bool local;
 } triangle_buffer;
 
 extern triangle_buffer buffer;
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index cee6ce5..d35b913 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -83,7 +83,9 @@ typedef struct hid_gc_struct
 }
 hid_gc_struct;
 
-
+#define BOARD_THICKNESS 6300
+#define MASK_COPPER_SPACING 200
+#define SILK_MASK_SPACING 50
 static int
 compute_depth (int group)
 {
@@ -91,45 +93,56 @@ compute_depth (int group)
 
   int solder_group;
   int component_group;
-  int min_phys_group;
-  int max_phys_group;
-  int max_depth;
-  int depth = last_depth_computed;
-  int newgroup;
-  int idx = (group >= 0
-             && group <
-             max_group) ? PCB->LayerGroups.Entries[group][0] : group;
+  int min_copper_group;
+  int max_copper_group;
+  int num_copper_groups;
+  int middle_copper_group;
+  int depth;
 
   solder_group = GetLayerGroupNumberByNumber (solder_silk_layer);
   component_group = GetLayerGroupNumberByNumber (component_silk_layer);
 
-  min_phys_group = MIN (solder_group, component_group);
-  max_phys_group = MAX (solder_group, component_group);
-
-  max_depth = (1 + max_phys_group - min_phys_group) * 10;
+  min_copper_group = MIN (solder_group, component_group);
+  max_copper_group = MAX (solder_group, component_group);
+  num_copper_groups = max_copper_group - min_copper_group + 1;
+  middle_copper_group = min_copper_group + num_copper_groups / 2;
 
   if (group >= 0 && group < max_group) {
-    newgroup = group;
+    if (group >= min_copper_group && group <= max_copper_group) {
+      /* XXX: IS THIS INCORRECT FOR REVERSED GROUP ORDERINGS? */
+      depth = -(group - middle_copper_group) * BOARD_THICKNESS / num_copper_groups;
+    } else {
+      depth = 0;
+    }
 
-    depth = (max_depth - (newgroup - min_phys_group) * 10) * 200 / gport->zoom;
-  } else if (SL_TYPE (idx) == SL_MASK) {
-    if (SL_SIDE (idx) == SL_TOP_SIDE) {
-      depth = (max_depth + 3) * 200 / gport->zoom;
+  } else if (SL_TYPE (group) == SL_MASK) {
+    if (SL_SIDE (group) == SL_TOP_SIDE) {
+      depth = -((min_copper_group - middle_copper_group) * BOARD_THICKNESS / num_copper_groups - MASK_COPPER_SPACING);
     } else {
-      depth = (10 - 3) * 200 / gport->zoom;
+      depth = -((max_copper_group - middle_copper_group) * BOARD_THICKNESS / num_copper_groups + MASK_COPPER_SPACING);
     }
-  } else if (SL_TYPE (idx) == SL_SILK) {
-    if (SL_SIDE (idx) == SL_TOP_SIDE) {
-      depth = (max_depth + 5) * 200 / gport->zoom;
+  } else if (SL_TYPE (group) == SL_SILK) {
+    if (SL_SIDE (group) == SL_TOP_SIDE) {
+      depth = -((min_copper_group - middle_copper_group) * BOARD_THICKNESS / num_copper_groups - MASK_COPPER_SPACING - SILK_MASK_SPACING);
     } else {
-      depth = (10 - 5) * 200 / gport->zoom;
+      depth = -((max_copper_group - middle_copper_group) * BOARD_THICKNESS / num_copper_groups + MASK_COPPER_SPACING + SILK_MASK_SPACING);
     }
-  } else if (SL_TYPE (idx) == SL_INVISIBLE) {
+
+  } else if (SL_TYPE (group) == SL_INVISIBLE) {
+    /* Same as silk, but for the back-side layer */
     if (Settings.ShowSolderSide) {
-      depth = (max_depth + 5) * 200 / gport->zoom;
+      depth = -((min_copper_group - middle_copper_group) * BOARD_THICKNESS / num_copper_groups - MASK_COPPER_SPACING - SILK_MASK_SPACING);
     } else {
-      depth = (10 - 5) * 200 / gport->zoom;
+      depth = -((max_copper_group - middle_copper_group) * BOARD_THICKNESS / num_copper_groups + MASK_COPPER_SPACING + SILK_MASK_SPACING);
     }
+  } else if (SL_TYPE (group) == SL_RATS) {
+    depth = last_depth_computed;
+  } else if (SL_TYPE (group) == SL_FINISHED) {
+    depth = last_depth_computed;
+  } else {
+    /* DEFAULT CASE */
+    printf ("Unknown layer group to set depth for: %i\n", group);
+    depth = last_depth_computed;
   }
 
   last_depth_computed = depth;
@@ -160,6 +173,7 @@ ghid_set_layer (const char *name, int group, int empty)
 
   hidgl_set_depth (compute_depth (group));
 
+//  glFlush ();
   glEnable (GL_STENCIL_TEST);                   // Enable Stencil test
   glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);   // Stencil pass => replace stencil value (with 1)
   hidgl_return_stencil_bit (stencil_bit);       // Relinquish any bitplane we previously used
@@ -173,6 +187,7 @@ ghid_set_layer (const char *name, int group, int empty)
     glStencilFunc (GL_ALWAYS, 0, 0);  // Always pass stencil test
   }
 
+
   if (idx >= 0 && idx < max_copper_layer + 2)
     {
       priv->trans_lines = true;
@@ -246,15 +261,6 @@ ghid_draw_grid (BoxTypePtr drawn_area)
       gport->grid_color.blue ^= gport->bg_color.blue;
     }
 
-  hidgl_flush_triangles (&buffer);
-
-//  glEnable (GL_COLOR_LOGIC_OP);
-//  glLogicOp (GL_XOR);
-
-  glColor3f (gport->grid_color.red / 65535.,
-             gport->grid_color.green / 65535.,
-             gport->grid_color.blue / 65535.);
-
   x1 = GRIDFIT_X (MAX (0, drawn_area->X1), PCB->Grid);
   y1 = GRIDFIT_Y (MAX (0, drawn_area->Y1), PCB->Grid);
   x2 = GRIDFIT_X (MIN (PCB->MaxWidth, drawn_area->X2), PCB->Grid);
@@ -287,28 +293,36 @@ ghid_draw_grid (BoxTypePtr drawn_area)
 	MyRealloc (points, npoints * 3 * sizeof (GLfloat), "gtk_draw_grid");
     }
 
-  glDisableClientState (GL_TEXTURE_COORD_ARRAY);
+  hidgl_flush_triangles (&buffer);
+
+  glColor3f (gport->grid_color.red / 65535.,
+             gport->grid_color.green / 65535.,
+             gport->grid_color.blue / 65535.);
   glTexCoord2f (0., 0.);
+
+  glDisable (GL_STENCIL_TEST);
+  glEnable (GL_COLOR_LOGIC_OP);
+  glLogicOp (GL_XOR);
   glEnableClientState (GL_VERTEX_ARRAY);
   glVertexPointer (3, GL_FLOAT, 0, points);
 
   n = 0;
   for (x = x1; x <= x2; x += PCB->Grid)
     {
-      points[3 * n] = Vx (x);
+      points[3 * n] = x;
       points[3 * n + 2] = global_depth;
       n++;
     }
   for (y = y1; y <= y2; y += PCB->Grid)
     {
-      int vy = Vy (y);
       for (i = 0; i < n; i++)
-	points[3 * i + 1] = vy;
+	points[3 * i + 1] = y;
       glDrawArrays (GL_POINTS, 0, n);
     }
 
   glDisableClientState (GL_VERTEX_ARRAY);
-//  glDisable (GL_COLOR_LOGIC_OP);
+  glDisable (GL_COLOR_LOGIC_OP);
+  glEnable (GL_STENCIL_TEST);
 }
 
 #if 0
@@ -867,6 +881,8 @@ ghid_show_crosshair (gboolean show)
   static GdkColor cross_color;
   extern float global_depth;
 
+  return;
+
   if (!check_gl_drawing_ok_hack)
     return;
 
@@ -1795,7 +1811,6 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   static int display_list;
 #endif
   BoxType region;
-  int eleft, eright, etop, ebottom;
   int min_x, min_y;
   int max_x, max_y;
   int new_x, new_y;
@@ -1833,7 +1848,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   glViewport (0, 0, widget->allocation.width, widget->allocation.height);
 
-#if 0
+#if 1
   glEnable (GL_SCISSOR_TEST);
   glScissor (ev->area.x,
              widget->allocation.height - ev->area.height - ev->area.y,
@@ -1849,6 +1864,13 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glTranslatef (widget->allocation.width / 2., widget->allocation.height / 2., 0);
   glMultMatrixf ((GLfloat *)view_matrix);
   glTranslatef (-widget->allocation.width / 2., -widget->allocation.height / 2., 0);
+  glScalef ((ghid_flip_x ? -1. : 1.) / port->zoom,
+            (ghid_flip_y ? -1. : 1.) / port->zoom,
+            ((ghid_flip_x == ghid_flip_y) ? 1. : -1.) / port->zoom);
+  glTranslatef (ghid_flip_x ? port->view_x0 - PCB->MaxWidth  :
+                             -port->view_x0,
+                ghid_flip_y ? port->view_y0 - PCB->MaxHeight :
+                             -port->view_y0, 0);
   glGetFloatv (GL_MODELVIEW_MATRIX, (GLfloat *)last_modelview_matrix);
 
 #ifdef ONE_SHOT
@@ -1860,9 +1882,13 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
 #if 1
   glEnable (GL_STENCIL_TEST);
-  glClearColor (port->offlimits_color.red / 65535.,
-                port->offlimits_color.green / 65535.,
-                port->offlimits_color.blue / 65535.,
+//  glClearColor (port->offlimits_color.red / 65535.,
+//                port->offlimits_color.green / 65535.,
+//                port->offlimits_color.blue / 65535.,
+//                1.);
+  glClearColor (gport->bg_color.red / 65535.,
+                gport->bg_color.green / 65535.,
+                gport->bg_color.blue / 65535.,
                 1.);
   glStencilMask (~0);
   glClearStencil (0);
@@ -1874,8 +1900,8 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glStencilFunc (GL_ALWAYS, 0, 0);
 
   /* Test the 8 corners of a cube spanning the event */
-  min_depth = -50 + compute_depth (0);                /* FIXME */
-  max_depth =  50 + compute_depth (max_copper_layer); /* FIXME */
+  min_depth = -50 + compute_depth (0);                    /* FIXME: NEED TO USE PHYSICAL GROUPS */
+  max_depth =  50 + compute_depth (max_copper_layer - 1); /* FIXME: NEED TO USE PHYSICAL GROUPS */
 
   ghid_unproject_to_z_plane (ev->area.x,
                              ev->area.y,
@@ -1929,13 +1955,8 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   min_x = MIN (min_x, new_x);  max_x = MAX (max_x, new_x);
   min_y = MIN (min_y, new_y);  max_y = MAX (max_y, new_y);
 
-  region.X1 = MIN (Px (min_x), Px (max_x + 1));
-  region.X2 = MAX (Px (min_x), Px (max_x + 1));
-  region.Y1 = MIN (Py (min_y), Py (max_y + 1));
-  region.Y2 = MAX (Py (min_y), Py (max_y + 1));
-
-  eleft = Vx (0);  eright  = Vx (PCB->MaxWidth);
-  etop  = Vy (0);  ebottom = Vy (PCB->MaxHeight);
+  region.X1 = min_x;  region.X2 = max_x + 1;
+  region.Y1 = min_y;  region.Y2 = max_y + 1;
 
   glColor3f (port->bg_color.red / 65535.,
              port->bg_color.green / 65535.,
@@ -1952,16 +1973,8 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   /* Drawing operations as masked to areas where the stencil buffer is '0' */
 //  glStencilFunc (GL_GREATER, 1, 1);             // Draw only where stencil buffer is 0
 
-  glPushMatrix ();
-  glScalef ((ghid_flip_x ? -1. : 1.) / port->zoom,
-            (ghid_flip_y ? -1. : 1.) / port->zoom,
-            (ghid_flip_x == ghid_flip_y) ? 1. : -1.);
-  glTranslatef (ghid_flip_x ? port->view_x0 - PCB->MaxWidth  :
-                             -port->view_x0,
-                ghid_flip_y ? port->view_y0 - PCB->MaxHeight :
-                             -port->view_y0, 0);
-
 #endif
+#if 0
   if (global_view_2d) {
 //    int count = 0;
     glBegin (GL_QUADS);
@@ -1997,33 +2010,29 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
     glEnd ();
 #endif
   }
+#endif
+
 
   // hid_expose_callback (&ghid_hid, &region, 0);
   ghid_draw_everything (&region);
   hidgl_flush_triangles (&buffer);
-  glPopMatrix ();
 
   /* Just prod the drawing code so the current depth gets set to
      the right value for the layer we are editing */
+#if 0
   gui->set_layer (NULL, GetLayerGroupNumberByNumber (INDEXOFCURRENT), 0);
-  gui->set_layer (NULL, SL_FINISHED, 0);
-
+  gui->set_layer (NULL, SL (FINISHED, 0), 0);
+#else
+  hidgl_set_depth (compute_depth (GetLayerGroupNumberByNumber (INDEXOFCURRENT)));
+#endif
   ghid_draw_grid (&region);
 
 #if 1
 //  hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
-  glPushMatrix ();
-  glScalef ((ghid_flip_x ? -1. : 1.) / port->zoom,
-            (ghid_flip_y ? -1. : 1.) / port->zoom, 1);
-  glTranslatef (ghid_flip_x ? port->view_x0 - PCB->MaxWidth  :
-                             -port->view_x0,
-                ghid_flip_y ? port->view_y0 - PCB->MaxHeight :
-                             -port->view_y0, 0);
   DrawAttached (TRUE);
   DrawMark (TRUE);
   hidgl_flush_triangles (&buffer);
-  glPopMatrix ();
 #endif
 
 #ifdef ONE_SHOT
@@ -2034,6 +2043,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glCallList (display_list);
 #endif
 
+  /* FIXME MATRIX ?? */
   ghid_show_crosshair (TRUE);
 
   hidgl_flush_triangles (&buffer);
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 98a49d0..1a14478 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -1605,6 +1605,7 @@ Benchmark (int argc, char **argv, int x, int y)
       gdk_window_invalidate_rect (gport->drawing_area->window, NULL, 1);
       gdk_window_process_updates (gport->drawing_area->window, FALSE);
 //      gdk_display_sync (display);
+//      usleep (100000);
       time (&end);
       i++;
     }
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index 476b196..490ccc4 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -256,11 +256,11 @@ ghid_note_event_location (GdkEventButton * ev)
 #ifdef ENABLE_GL
   /* Unproject event_x and event_y to world coordinates of the plane we are on */
   ghid_unproject_to_z_plane (event_x, event_y, global_depth,
-                             &event_x, &event_y);
-#endif
-
+                             &gport->view_x, &gport->view_y);
+#else
   gport->view_x = event_x * gport->zoom + gport->view_x0;
   gport->view_y = event_y * gport->zoom + gport->view_y0;
+#endif
 
   moved = MoveCrosshairAbsolute (SIDE_X (gport->view_x), 
 				 SIDE_Y (gport->view_y));
diff --git a/src/hid/gtk/snavi.c b/src/hid/gtk/snavi.c
index 618be32..7d3f961 100644
--- a/src/hid/gtk/snavi.c
+++ b/src/hid/gtk/snavi.c
@@ -51,16 +51,20 @@ int snavi_set_led (GIOChannel *snavi, int led_state)
   GError      *error = NULL;
   gsize        bytes_written;
 
+  event.time.tv_sec = 0;
+  event.time.tv_usec = 0;
   event.type  = EV_LED;
   event.code  = LED_MISC;
   event.value = led_state;
 
+#if 0
   g_io_channel_seek_position (snavi, 0, G_SEEK_END, &error);
   if (error) {
     g_printerr ("Error: %s\n", error->message);
     /* FIXME: FREE THE ERROR??? */
     return FALSE;
   }
+#endif
 
   g_io_channel_write_chars (snavi,
                             (gchar *) &event,
@@ -74,6 +78,7 @@ int snavi_set_led (GIOChannel *snavi, int led_state)
     return FALSE;
   }
 
+#if 0
   g_io_channel_flush (snavi, &error);
 
   if (error) {
@@ -81,6 +86,7 @@ int snavi_set_led (GIOChannel *snavi, int led_state)
     /* FIXME: FREE THE ERROR??? */
     return FALSE;
   }
+#endif
 
   return bytes_written < sizeof (struct input_event);
 }
@@ -114,6 +120,12 @@ gboolean snavi_event (GIOChannel   *source,
 
   switch (event.type)
     {
+      case EV_ABS:
+        if (event.code <= ABS_RZ)
+          axes[event.code - ABS_X] = event.value;
+        break;
+
+        /* I'm not sure, but previously the SpaceNavigator reported as relative events */
       case EV_REL:
         if (event.code <= REL_RZ)
           axes[event.code - REL_X] = event.value;
@@ -140,12 +152,12 @@ gboolean snavi_event (GIOChannel   *source,
             axes[i] = 0;
         }
 
-        update_pan_cb (axes[0] / 100.0,
-                       axes[2] / 100.0,
-                       axes[1] / 100.0, cb_userdata);
-        update_roll_cb (axes[5] / 100.0,
-                        axes[3] / 100.0,
-                        axes[4] / 100.0, cb_userdata);
+        update_pan_cb (axes[0] / 70.0,
+                       axes[2] / 70.0,
+                       axes[1] / 70.0, cb_userdata);
+        update_roll_cb (axes[5] / 60.0,
+                        axes[3] / 60.0,
+                        axes[4] / 60.0, cb_userdata);
         update_done_cb (cb_userdata);
 
         axes[0] = axes[1] = axes[2] = axes[3] = axes[4] = axes[5] = 0;
@@ -175,11 +187,22 @@ setup_snavi (void (*update_pan)(int, int, int, gpointer),
   update_done_cb = update_done;
   button_cb = button;
   cb_userdata = data;
+#if 0
+  int fd;
+  int grab = 1;
 
+  fd = open("/dev/input/spacenavigator", O_RDWR);
+  ioctl (fd, EVIOCGRAB, &grab);
+
+  snavi = g_io_channel_unix_new (fd);
+#else
   snavi = g_io_channel_new_file ("/dev/input/spacenavigator", "r+", NULL);
+#endif
+
   if (snavi)
     {
       g_io_channel_set_encoding (snavi, NULL, NULL);
+      g_io_channel_set_buffered (snavi, FALSE);
       event_id = g_io_add_watch (snavi, G_IO_IN, snavi_event, NULL);
     }

Bottom: 3a95e242dd51fecf9e77fff4d9a194583226adab
Top:    fdde47be376f12d33e5ab19216050874f3ce9af1
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-07-24 22:22:41 +0100

Refresh of hid-gtk-separate-out-board-fli

---

diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index 4fdb8d3..8394d20 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -26,9 +26,17 @@ extern HID ghid_hid;
 */
 #define USE_GC(gc) if (!use_gc(gc)) return
 
+#define SIDE_X(x)   ((priv->view.flip_x ? PCB->MaxWidth  - (x) : (x)))
+#define SIDE_Y(y)   ((priv->view.flip_y ? PCB->MaxHeight - (y) : (y)))
+
 static int cur_mask = -1;
 static int mask_seq = 0;
 
+typedef struct view_data {
+  bool flip_x;
+  bool flip_y;
+} view_data;
+
 typedef struct render_priv {
   GdkGC *bg_gc;
   GdkGC *offlimits_gc;
@@ -39,6 +47,7 @@ typedef struct render_priv {
   GdkRectangle clip_rect;
   int attached_invalidate_depth;
   int mark_invalidate_depth;
+  view_data view;
 } render_priv;
 
 
@@ -55,6 +64,52 @@ typedef struct hid_gc_struct
 }
 hid_gc_struct;
 
+/* Px converts view->pcb, Vx converts pcb->view */
+static inline int
+Vx (int x)
+{
+  render_priv *priv = gport->render_priv;
+  if (priv->view.flip_x)
+    return (PCB->MaxWidth - x - gport->view_x0) / gport->zoom + 0.5;
+  else
+    return (x - gport->view_x0) / gport->zoom + 0.5;
+}
+
+static inline int
+Vy (int y)
+{
+  render_priv *priv = gport->render_priv;
+  if (priv->view.flip_y)
+    return (PCB->MaxHeight - y - gport->view_y0) / gport->zoom + 0.5;
+  else
+    return (y - gport->view_y0) / gport->zoom + 0.5;
+}
+
+static inline int
+Vz (int z)
+{
+  return z / gport->zoom + 0.5;
+}
+
+static inline int
+Px (int x)
+{
+  render_priv *priv = gport->render_priv;
+  int rv = x * gport->zoom + gport->view_x0;
+  if (priv->view.flip_x)
+    rv = PCB->MaxWidth - (x * gport->zoom + gport->view_x0);
+  return  rv;
+}
+
+static inline int
+Py (int y)
+{
+  render_priv *priv = gport->render_priv;
+  int rv = y * gport->zoom + gport->view_y0;
+  if (priv->view.flip_y)
+    rv = PCB->MaxHeight - (y * gport->zoom + gport->view_y0);
+  return  rv;
+}
 
 int
 ghid_set_layer (const char *name, int group, int empty)
@@ -545,12 +600,12 @@ ghid_draw_arc (hidGC gc, int cx, int cy,
   vrx = Vz (xradius);
   vry = Vz (yradius);
 
-  if (ghid_flip_x)
+  if (priv->view.flip_x)
     {
       start_angle = 180 - start_angle;
       delta_angle = -delta_angle;
     }
-  if (ghid_flip_y)
+  if (priv->view.flip_y)
     {
       start_angle = -start_angle;
       delta_angle = -delta_angle;
@@ -1259,9 +1314,9 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   gport->height = height;
   gport->view_width = width * gport->zoom;
   gport->view_height = height * gport->zoom;
-  gport->view_x0 = ghid_flip_x ? PCB->MaxWidth - cx : cx;
+  gport->view_x0 = priv->view.flip_x ? PCB->MaxWidth - cx : cx;
   gport->view_x0 -= gport->view_height / 2;
-  gport->view_y0 = ghid_flip_y ? PCB->MaxHeight - cy : cy;
+  gport->view_y0 = priv->view.flip_y ? PCB->MaxHeight - cy : cy;
   gport->view_y0 -= gport->view_width  / 2;
 
   /* clear background */
@@ -1312,8 +1367,127 @@ ghid_finish_debug_draw (void)
 bool
 ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y)
 {
+  render_priv *priv = gport->render_priv;
+
   *pcb_x = EVENT_TO_PCB_X (event_x);
   *pcb_y = EVENT_TO_PCB_Y (event_y);
 
   return true;
 }
+
+bool
+ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y)
+{
+  render_priv *priv = gport->render_priv;
+
+  *event_x = DRAW_X (pcb_x);
+  *event_y = DRAW_Y (pcb_y);
+
+  return true;
+}
+
+void
+ghid_pan_view_abs (Coord pcb_x, Coord pcb_y, int widget_x, int widget_y)
+{
+  render_priv *priv = gport->render_priv;
+
+  gport->view_x0 = MAX (0, SIDE_X (pcb_x) - widget_x * gport->zoom);
+  gport->view_y0 = MAX (0, SIDE_Y (pcb_y) - widget_y * gport->zoom);
+
+  /* don't pan so far to the right that we see way past the right edge of the
+   * board, or so far down that we see way past the bottom edge of the board.
+   */
+  gport->view_x0 = MIN (gport->view_x0, PCB->MaxWidth  - gport->view_width);
+  gport->view_y0 = MIN (gport->view_y0, PCB->MaxHeight - gport->view_height);
+
+  /* don't view above or to the left of the board... ever */
+  gport->view_x0 = MAX (0, gport->view_x0);
+  gport->view_y0 = MAX (0, gport->view_y0);
+
+  /* if we can see the entire board and some, then zoom to fit */
+  if (gport->view_width  > PCB->MaxWidth  &&
+      gport->view_height > PCB->MaxHeight)
+    {
+      ghid_zoom_view_fit ();
+      return;
+    }
+
+  ghidgui->adjustment_changed_holdoff = TRUE;
+  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view_x0);
+  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view_y0);
+  ghidgui->adjustment_changed_holdoff = FALSE;
+
+  ghid_port_ranges_changed();
+}
+
+
+/* gport->zoom:
+ * zoom value is PCB units per screen pixel.  Larger numbers mean zooming
+ * out - the largest value means you are looking at the whole board.
+ *
+ * gport->view_width and gport->view_height are in PCB coordinates
+ */
+
+void
+ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
+{
+  render_priv *priv = gport->render_priv;
+  double min_zoom, max_zoom;
+  double xtmp, ytmp;
+
+  /* Limit the "minimum" zoom constant (maximum zoom), at 1 pixel per PCB
+   * unit, and set the "maximum" zoom constant (minimum zoom), such that
+   * the entire board just fits inside the viewport
+   */
+  min_zoom = 1;
+  max_zoom = MAX (PCB->MaxWidth  / gport->width,
+                  PCB->MaxHeight / gport->height);
+  new_zoom = MIN (MAX (min_zoom, new_zoom), max_zoom);
+
+  if (gport->zoom == new_zoom)
+    return;
+
+  xtmp = (SIDE_X (center_x) - gport->view_x0) / (double)gport->view_width;
+  ytmp = (SIDE_Y (center_y) - gport->view_y0) / (double)gport->view_height;
+
+  gport->zoom = new_zoom;
+  pixel_slop = new_zoom;
+  ghid_port_ranges_scale (FALSE);
+
+  gport->view_x0 = MAX (0, SIDE_X (center_x) - xtmp * gport->view_width);
+  gport->view_y0 = MAX (0, SIDE_Y (center_y) - ytmp * gport->view_height);
+
+  ghidgui->adjustment_changed_holdoff = TRUE;
+  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view_x0);
+  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view_y0);
+  ghidgui->adjustment_changed_holdoff = FALSE;
+
+  ghid_port_ranges_changed ();
+  ghid_set_status_line_label ();
+}
+
+void
+ghid_zoom_view_rel (Coord center_x, Coord center_y, double factor)
+{
+  ghid_zoom_view_abs (center_x, center_y, gport->zoom * factor);
+}
+
+void
+ghid_zoom_view_fit (void)
+{
+  ghid_zoom_view_abs (0, 0, MAX (PCB->MaxWidth  / gport->width,
+                                 PCB->MaxHeight / gport->height));
+}
+
+void
+ghid_flip_view (Coord center_x, Coord center_y, bool flip_x, bool flip_y)
+{
+  render_priv *priv = gport->render_priv;
+
+  priv->view.flip_x = flip_x ? ! priv->view.flip_x : priv->view.flip_x;
+  priv->view.flip_y = flip_y ? ! priv->view.flip_y : priv->view.flip_y;
+
+  /* XXX: PAN THE BOARD SO THE CENTER LOCATION REMAINS IN THE SAME PLACE */
+
+  ghid_invalidate_all ();
+}
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 432588f..6c09d23 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -71,6 +71,13 @@ typedef struct hid_gc_struct
 }
 hid_gc_struct;
 
+/* Px converts view->pcb, Vx converts pcb->view */
+static inline int
+Vz (int z)
+{
+  return z / gport->zoom + 0.5;
+}
+
 static inline int
 Px (int x)
 {
@@ -91,12 +98,6 @@ Py (int y)
   return  rv;
 }
 
-static inline int
-Vz (int z)
-{
-  return z / gport->zoom + 0.5;
-}
-
 static void
 start_subcomposite (void)
 {

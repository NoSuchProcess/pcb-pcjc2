Bottom: 6c1654c6d449679da30718304c845f1638b6415f
Top:    4f263fa11718000f31e91bb83b53cd3194330d1d
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2015-02-05 20:22:01 +0000

Refresh of attempt-to-fix-broken-polygon

---

diff --git a/src/polygon1.c b/src/polygon1.c
index 8d927cb..997cf4a 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -1705,15 +1705,15 @@ Collect (char poly, jmp_buf * e, PLINE * a, POLYAREA ** contours, PLINE ** holes
   DIRECTION dir = UNINITIALISED;
 
   cur = (&a->head); //    ->next->next->next->next->next; /* Breaks circ_seg_test9.pcb */
-  cur = (&a->head)        ->next->next->next->next->next;
+  cur = (&a->head)        ;
   do
     {
       // The following may be a nice speedup, but not sure if it is correct.
       // In particular, consider the case when we collect a 'B' polygon contour.
       // Could some of that countour may already have been collected, and there
       // still be a piece we are interested in after? (Can we reach it though??)
-//      if (cur->Flags.mark != 0)
-//        break;
+      if (cur->Flags.mark != 0)
+        break;
 
       if (j_rule (poly, cur, &dir) && cur->Flags.mark == 0)
 	Collect1 (e, cur, dir, contours, holes, j_rule);
@@ -1723,7 +1723,7 @@ Collect (char poly, jmp_buf * e, PLINE * a, POLYAREA ** contours, PLINE ** holes
 
 
 static int
-cntr_Collect (char poly, jmp_buf * e, PLINE ** A, POLYAREA ** contours, PLINE ** holes,
+cntr_Collect (jmp_buf * e, PLINE ** A, POLYAREA ** contours, PLINE ** holes,
 	      int action, POLYAREA * owner, POLYAREA * parent,
 	      PLINE * parent_contour)
 {
@@ -1734,16 +1734,16 @@ cntr_Collect (char poly, jmp_buf * e, PLINE ** A, POLYAREA ** contours, PLINE **
       switch (action)
 	{
 	case PBO_UNITE:
-	  Collect (poly, e, *A, contours, holes, UniteS_Rule, UniteJ_Rule);
+	  Collect ('A', e, *A, contours, holes, UniteS_Rule, UniteJ_Rule);
 	  break;
 	case PBO_ISECT:
-	  Collect (poly, e, *A, contours, holes, IsectS_Rule, IsectJ_Rule);
+	  Collect ('A', e, *A, contours, holes, IsectS_Rule, IsectJ_Rule);
 	  break;
 	case PBO_XOR:
-	  Collect (poly, e, *A, contours, holes, XorS_Rule, XorJ_Rule);
+	  Collect ('A', e, *A, contours, holes, XorS_Rule, XorJ_Rule);
 	  break;
 	case PBO_SUB:
-	  Collect (poly, e, *A, contours, holes, SubS_Rule, SubJ_Rule);
+	  Collect ('A', e, *A, contours, holes, SubS_Rule, SubJ_Rule);
 	  break;
 	};
     }
@@ -1816,17 +1816,23 @@ M_B_AREA_Collect (jmp_buf * e, POLYAREA * bfst, POLYAREA ** contours,
 	       * NB: There Could be grief if the JUMP rule is inconsistent in
 	       *     its interpretation from each side of the vertex.
 	       */
-	      /* if we disappear a contour, don't advance twice */
-	      printf ("Hello 1, cur=%p, contour=%p, holes=%p\n", cur, contours, holes);
-	      if (cntr_Collect ('B', e, cur, contours, holes, action, NULL, NULL, NULL))
-                {
-                  printf ("Hello 2\n");
-	          next = cur;
-                }
-	      continue;
+            switch (action)
+              {
+              case PBO_UNITE:
+                Collect ('B', e, *cur, contours, holes, UniteS_Rule, UniteJ_Rule);
+                break;
+              case PBO_ISECT:
+                Collect ('B', e, *cur, contours, holes, IsectS_Rule, IsectJ_Rule);
+                break;
+              case PBO_XOR:
+                Collect ('B', e, *cur, contours, holes, XorS_Rule, XorJ_Rule);
+                break;
+              case PBO_SUB:
+                Collect ('B', e, *cur, contours, holes, SubS_Rule, SubJ_Rule);
+                break;
+              }
 	    }
-
-	  if ((*cur)->Flags.status == INSIDE)
+          else if ((*cur)->Flags.status == INSIDE)
 	    switch (action)
 	      {
 	      case PBO_XOR:
@@ -2239,73 +2245,11 @@ M_POLYAREA_Collect_separated (jmp_buf * e, PLINE * afst, POLYAREA ** contours,
     {
       next = &((*cur)->next);
       /* if we disappear a contour, don't advance twice */
-      if (cntr_Collect ('A', e, cur, contours, holes, action, NULL, NULL, NULL))
+      if (cntr_Collect (e, cur, contours, holes, action, NULL, NULL, NULL))
 	next = cur;
     }
 }
 
-#if 0
-/* Call cntr_Collect on any intersected contours found on the B-polygon.
- * This is required in order to catch contours that intersect at a single
- * point, which will be flagged as ISECTED, but may not necessarily traverse
- * into a single output contour according to the jump rules.
- *
- * This is distinct from M_POLYAREA_Collect_separated which takes a linked
- * list of separated PLINE contours separated from the 'A' polygon. The 'B'
- * polygon still owns the intersected 'B' contours, so we don't re-link them
- * like this.
- *
- * This is distinct from M_POLYAREA_Colllect, because ..... (WHY???).
- */
-static void
-M_POLYAREA_Collect_from_b (jmp_buf *e, POLYAREA * bfst, POLYAREA ** contours,
-                           PLINE ** holes, int action, BOOLp maybe)
-{
-  POLYAREA *b = bfst;
-  POLYAREA *parent = NULL;	/* Quiet compiler warning */
-  PLINE **cur, **next, *parent_contour;
-
-  assert (b != NULL);
-  while ((b = b->f) != bfst); /* XXX: NOP LOOPS THE LIST, LEAVING b = bfst ?? */
-
-  /* now the non-intersect parts are collected in temp/holes */
-  do
-    {
-      if (maybe && b->contours->Flags.status != ISECTED)
-	parent_contour = b->contours;
-      else
-	parent_contour = NULL;
-
-      /* Take care of the first contour - so we know if we
-       * can shortcut reparenting some of its children
-       */
-      cur = &b->contours;
-      if (*cur != NULL)
-	{
-	  next = &((*cur)->next);
-	  /* if we disappear a contour, don't advance twice */
-	  if (cntr_Collect ('B', e, cur, contours, holes, action, b, NULL, NULL))
-	    {
-	      parent = (*contours)->b;	/* InsCntr inserts behind the head */
-	      next = cur;
-	    }
-	  else
-	    parent = b;
-	  cur = next;
-	}
-      for (; *cur != NULL; cur = next)
-	{
-	  next = &((*cur)->next)
-	  /* if we disappear a contour, don't advance twice */
-	  if (cntr_Collect ('B', e, cur, contours, holes, action, b, parent,
-			    parent_contour))
-	    next = cur;
-	}
-    }
-  while ((a = a->f) != afst);
-}
-#endif
-
 static void
 M_POLYAREA_Collect (jmp_buf * e, POLYAREA * afst, POLYAREA ** contours,
 		    PLINE ** holes, int action, BOOLp maybe)
@@ -2332,7 +2276,7 @@ M_POLYAREA_Collect (jmp_buf * e, POLYAREA * afst, POLYAREA ** contours,
 	{
 	  next = &((*cur)->next);
 	  /* if we disappear a contour, don't advance twice */
-	  if (cntr_Collect ('A', e, cur, contours, holes, action, a, NULL, NULL))
+	  if (cntr_Collect (e, cur, contours, holes, action, a, NULL, NULL))
 	    {
 	      parent = (*contours)->b;	/* InsCntr inserts behind the head */
 	      next = cur;
@@ -2345,7 +2289,7 @@ M_POLYAREA_Collect (jmp_buf * e, POLYAREA * afst, POLYAREA ** contours,
 	{
 	  next = &((*cur)->next);
 	  /* if we disappear a contour, don't advance twice */
-	  if (cntr_Collect ('A', e, cur, contours, holes, action, a, parent,
+	  if (cntr_Collect (e, cur, contours, holes, action, a, parent,
 			    parent_contour))
 	    next = cur;
 	}
@@ -2456,7 +2400,6 @@ poly_Boolean_free (POLYAREA * ai, POLYAREA * bi, POLYAREA ** res, int action)
       M_POLYAREA_label_separated (a_isected, b, FALSE);
       M_POLYAREA_Collect_separated (&e, a_isected, res, &holes, action,
 				    FALSE);
-//      M_POLYAREA_Collect_from_b (&e, b, res, &holes, action, FALSE);
       M_B_AREA_Collect (&e, b, res, &holes, action);
       poly_Free (&b);

Bottom: a03b9039dee28ec9474b408793578aa2d1ab3254
Top:    7667315eaae9ce07bd33ddfd9f5fddccdd43ade1
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2014-07-05 18:02:03 +0100

Refresh of attempt-at-supporting-arc-arc

---

diff --git a/src/polygon.c b/src/polygon.c
index 8590ccf..cf526de 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -282,14 +282,25 @@ ContourToPoly (PLINE * contour)
 }
 
 static void
-degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Coord radius, Vector v /* First point, already laid by caller */, Angle sweep)
+degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Coord radius, Vector v /* First point */, Angle sweep)
 {
   /* We don't re-add a point at v, nor do we add the last point, sweep degrees around from (X,Y)-v */
   double e1, e2, t1;
   int i, range;
 
 //  poly_InclVertex (c->head.prev, poly_CreateNode (v));
-  poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
+
+  if (c->head.prev->point[0] == v[0] &&
+      c->head.prev->point[1] == v[1])
+    {
+      /* Re-use any existing vertex point we got lumbered with (if it matches the coordinate we want) */
+      c->head.prev->is_round = true;
+      c->head.prev->cx = X;
+      c->head.prev->cy = Y;
+      c->head.prev->radius = radius;
+    }
+  else
+    poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
 
   /* move vector to origin */
   e1 = (v[0] - X) * POLY_CIRC_RADIUS_ADJ;
@@ -299,7 +310,7 @@ degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Coord radius, Vector
     {
       /* NB: the caller added the first vertex, and will add the last vertex, hence the -1 */
       range = POLY_CIRC_SEGS * sweep / 360 - 1;
-      for (i = 0; i < range/* SHOULD NOT BE -1 */- 1; i++)
+      for (i = 0; i < range; i++)
         {
           /* rotate the vector */
           t1 = rotate_circle_seg[0] * e1 + rotate_circle_seg[1] * e2;
@@ -501,7 +512,19 @@ frac_circle (PLINE * c, Coord X, Coord Y, Vector v, int fraction)
   /* XXX: Circle already has the first node added */
 //  if (fraction > 1)
 //    poly_InclVertex (c->head.prev, poly_CreateNode (v));
-  poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
+
+  if (c->head.prev->point[0] == v[0] &&
+      c->head.prev->point[1] == v[1])
+    {
+      /* Re-use any existing vertex point we got lumbered with (if it matches the coordinate we want) */
+      c->head.prev->is_round = true;
+      c->head.prev->cx = X;
+      c->head.prev->cy = Y;
+      c->head.prev->radius = radius;
+    }
+  else
+    poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
+
   /* move vector to origin */
   e1 = (v[0] - X) * POLY_CIRC_RADIUS_ADJ;
   e2 = (v[1] - Y) * POLY_CIRC_RADIUS_ADJ;
@@ -614,18 +637,30 @@ ArcPolyNoIntersect (ArcType * a, Coord thick)
 
   ang = a->StartAngle;
   da = (1.0 * a->Delta) / segs;
-  radius_adj = (M_PI*da/360)*(M_PI*da/360)/2;
+
+  /* XXX: No need for radius ofsetting bodgery for the exact arc representation */
+  if (rx == ry)
+    radius_adj = 0.;
+  else
+    radius_adj = (M_PI*da/360)*(M_PI*da/360)/2;
+
   v[0] = a->X - rx * cos (ang * M180);
   v[1] = a->Y + ry * sin (ang * M180);
+
+  /* XXX: First point is a vertex? */
   if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
     return 0;
-  for (i = 0; i < segs - 1; i++)
-    {
-      ang += da;
-      v[0] = a->X - rx * cos (ang * M180);
-      v[1] = a->Y + ry * sin (ang * M180);
-      poly_InclVertex (contour->head.prev, poly_CreateNode (v));
-    }
+
+  if (rx == ry)
+    degree_circle (contour, a->X, a->Y, rx, v, -a->Delta);
+  else
+    for (i = 0; i < segs - 1; i++)
+      {
+        ang += da;
+        v[0] = a->X - rx * cos (ang * M180);
+        v[1] = a->Y + ry * sin (ang * M180);
+        poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+      }
   /* find last point */
   ang = a->StartAngle + a->Delta;
   v[0] = a->X - rx * cos (ang * M180) * (1 - radius_adj);
@@ -636,13 +671,18 @@ ArcPolyNoIntersect (ArcType * a, Coord thick)
   rx = (a->Width + half) * (1+radius_adj);
   ry = (a->Width + half) * (1+radius_adj);
   da = -da;
-  for (i = 0; i < segs; i++)
-    {
-      v[0] = a->X - rx * cos (ang * M180);
-      v[1] = a->Y + ry * sin (ang * M180);
-      poly_InclVertex (contour->head.prev, poly_CreateNode (v));
-      ang += da;
-    }
+  v[0] = a->X - rx * cos (ang * M180);
+  v[1] = a->Y + ry * sin (ang * M180);
+  if (rx == ry)
+    degree_circle (contour, a->X, a->Y, rx, v, a->Delta);
+  else
+    for (i = 0; i < segs; i++)
+      {
+        v[0] = a->X - rx * cos (ang * M180);
+        v[1] = a->Y + ry * sin (ang * M180);
+        poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+        ang += da;
+      }
   /* now add other round cap */
   ang = a->StartAngle;
   v[0] = a->X - rx * cos (ang * M180) * (1 - radius_adj);
diff --git a/src/polygon1.c b/src/polygon1.c
index 9157eb4..1c677ac 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -218,12 +218,11 @@ node_add_single (VNODE * dest, Vector po)
 {
   VNODE *p;
 
-/* XXX: MAY NOT BE CORRECT IF WE NEED TO SEPARATE STRAIGHT AND CURVED SEGMENTS */
   if (vect_equal (po, dest->point))
     return dest;
   if (vect_equal (po, dest->next->point))
     return dest->next;
-  p = poly_CreateNode (po);
+  p = poly_CreateNodeFull (po, dest->is_round, dest->cx, dest->cy, dest->radius);
   if (p == NULL)
     return NULL;
   p->cvc_prev = p->cvc_next = NULL;
@@ -635,6 +634,83 @@ prepend_insert_node_task (insert_node_task *list, seg *seg, VNODE *new_node)
   return task;
 }
 
+static bool
+insert_vertex_in_seg (struct info *i, struct seg *s, Vector v)
+{
+  VNODE *new_node = node_add_single_point (s->v, v);
+  if (new_node == NULL)
+    return false;
+
+#ifdef DEBUG_INTERSECT
+  DEBUGP ("new intersection on segment \"i\" at %#mD\n", v[0], v[1]);
+#endif
+  i->node_insert_list = prepend_insert_node_task (i->node_insert_list, s, new_node);
+  s->intersected = 1;
+  return true;
+}
+
+static int
+seg_in_seg_line_line (struct info *i, struct seg *s1, struct seg *s2)
+{
+  Vector v1, v2;
+  int cnt;
+
+  cnt = vect_inters2 (s1->v->point, s1->v->next->point,
+                      s2->v->point, s2->v->next->point, v1, v2);
+  if (!cnt)
+    return 0;
+
+  if (i->touch)  /* if checking touches one find and we're done */
+    longjmp (*i->touch, TOUCHES);
+
+  /* Mark the contour PLINEs as intersected */
+  s1->p->Flags.status = ISECTED;
+  s2->p->Flags.status = ISECTED;
+
+  for (; cnt; cnt--)
+    {
+      bool done_insert_on_s1 = insert_vertex_in_seg (i, s2, cnt > 1 ? v2 : v1);
+      bool done_insert_on_s2 = insert_vertex_in_seg (i, s1, cnt > 1 ? v2 : v1);
+
+      /* Skip any remaining r_search hits against segment i, as any futher
+       * intersections will be rejected until the next pass anyway.
+       */
+      if ((done_insert_on_s1 && s1 == i->s) ||
+          (done_insert_on_s2 && s2 == i->s))
+        longjmp (*i->env, 1);
+
+      /* If we inserted on s (but not i), skip return now, as we can't continue with
+       * the for-loop iteration if we modified geoemtry
+       */
+      if (done_insert_on_s1 || done_insert_on_s2)
+        return 0;
+    }
+
+  return 0;
+}
+
+static int
+seg_in_seg_arc_line (struct info *i, struct seg *s1, struct seg *s2)
+{
+  assert (s1->v->is_round);
+  assert (!s2->v->is_round);
+
+//  printf ("Querying arc-line intersection\n");
+  /* COP OUT */
+  return seg_in_seg_line_line (i, s1, s2);
+}
+
+static int
+seg_in_seg_arc_arc (struct info *i, struct seg *s1, struct seg *s2)
+{
+  assert (s1->v->is_round);
+  assert (s2->v->is_round);
+
+//  printf ("Querying arc-arc intersection\n");
+  /* COP OUT */
+  return seg_in_seg_line_line (i, s1, s2);
+}
+
 /*
  * seg_in_seg()
  * (C) 2006 harry eaton
@@ -650,60 +726,24 @@ static int
 seg_in_seg (const BoxType * b, void *cl)
 {
   struct info *i = (struct info *) cl;
-  struct seg *s = (struct seg *) b;
-  Vector s1, s2;
-  int cnt;
-  VNODE *new_node;
+  struct seg *s1 = (struct seg *) b;
+  struct seg *s2 = i->s;
 
   /* When new nodes are added at the end of a pass due to an intersection
    * the segments may be altered. If either segment we're looking at has
    * already been intersected this pass, skip it until the next pass.
    */
-  if (s->intersected || i->s->intersected)
+  if (s1->intersected || s2->intersected)
     return 0;
 
-  cnt = vect_inters2 (s->v->point, s->v->next->point,
-		      i->v->point, i->v->next->point, s1, s2);
-  if (!cnt)
-    return 0;
-  if (i->touch)			/* if checking touches one find and we're done */
-    longjmp (*i->touch, TOUCHES);
-  i->s->p->Flags.status = ISECTED;
-  s->p->Flags.status = ISECTED;
-  for (; cnt; cnt--)
-    {
-      bool done_insert_on_i = false;
-      new_node = node_add_single_point (i->v, cnt > 1 ? s2 : s1);
-      if (new_node != NULL)
-	{
-#ifdef DEBUG_INTERSECT
-	  DEBUGP ("new intersection on segment \"i\" at %#mD\n",
-	          cnt > 1 ? s2[0] : s1[0], cnt > 1 ? s2[1] : s1[1]);
-#endif
-	  i->node_insert_list =
-	    prepend_insert_node_task (i->node_insert_list, i->s, new_node);
-	  i->s->intersected = 1;
-	  done_insert_on_i = true;
-	}
-      new_node = node_add_single_point (s->v, cnt > 1 ? s2 : s1);
-      if (new_node != NULL)
-	{
-#ifdef DEBUG_INTERSECT
-	  DEBUGP ("new intersection on segment \"s\" at %#mD\n",
-	          cnt > 1 ? s2[0] : s1[0], cnt > 1 ? s2[1] : s1[1]);
-#endif
-	  i->node_insert_list =
-	    prepend_insert_node_task (i->node_insert_list, s, new_node);
-	  s->intersected = 1;
-	  return 0; /* Keep looking for intersections with segment "i" */
-	}
-      /* Skip any remaining r_search hits against segment i, as any futher
-       * intersections will be rejected until the next pass anyway.
-       */
-      if (done_insert_on_i)
-	longjmp (*i->env, 1);
-    }
-  return 0;
+  if (s1->v->is_round && s2->v->is_round)
+    return seg_in_seg_arc_arc (i, s1, s2);
+  else if (s1->v->is_round)
+    return seg_in_seg_arc_line (i, s1, s2);
+  else if (s2->v->is_round)
+    return seg_in_seg_arc_line (i, s2, s1);
+  else
+    return seg_in_seg_line_line (i, s1, s2);
 }
 
 static void *
@@ -717,6 +757,7 @@ make_edge_tree (PLINE * pb)
     {
       s = (seg *)malloc (sizeof (struct seg));
       s->intersected = 0;
+#warning DOES NOT INCLUDE THE BOUNDING BOX OF ARC SEGMENTS
       if (bv->point[0] < bv->next->point[0])
 	{
 	  s->box.X1 = bv->point[0];
@@ -915,10 +956,6 @@ intersect_impl (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
     {
       insert_node_task *next = task->next;
 
-      /* XXX: If a node was inserted due to an intersection, don't assume we're on the a round contour any more */
-      task->node_seg->v->is_round = false;
-//      task->node_seg->v->next->is_round = false;
-
       /* Do insersion */
       task->new_node->prev = task->node_seg->v;
       task->new_node->next = task->node_seg->v->next;
@@ -2673,7 +2710,9 @@ poly_PreContour (PLINE * C, BOOLp optimize)
 	   * So, remove the point c
 	   */
 
-	  if (vect_det2 (p1, p2) == 0)
+#warning BROKEN FOR CIRCULAR CONTOURS
+//	  if (vect_det2 (p1, p2) == 0)
+          if (0)
 	    {
 	      poly_ExclVertex (c);
 	      free (c);
@@ -3364,6 +3403,7 @@ poly_ChkContour (PLINE * a)
       a2 = a1;
       do
 	{
+#warning THIS DOES NOT TAKE INTO ACCOUNT arc-arc and arc-line segments
 	  if (!node_neighbours (a1, a2) &&
 	      (icnt = vect_inters2 (a1->point, a1->next->point,
 				    a2->point, a2->next->point, i1, i2)) > 0)

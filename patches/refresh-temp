Bottom: c94486f49f5bf7bb5f46aa685fb8b95663a7a1c6
Top:    4e1d8231bd7e54fa9844f66dc2cf50e5f2bf7093
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-04-30 04:27:06 +0100

Refresh of convert-object-memory-allocati

---

diff --git a/src/crosshair.c b/src/crosshair.c
index 2abe960..6b81ae5 100644
--- a/src/crosshair.c
+++ b/src/crosshair.c
@@ -384,8 +384,7 @@ XORDrawInsertPointObject (void)
 static void
 XORDrawMoveOrCopyObject (void)
 {
-  RubberbandTypePtr ptr;
-  Cardinal i;
+  GList *i;
   LocationType dx = Crosshair.X - Crosshair.AttachedObject.X,
     dy = Crosshair.Y - Crosshair.AttachedObject.Y;
 
@@ -503,11 +502,10 @@ XORDrawMoveOrCopyObject (void)
     }
 
   /* draw the attached rubberband lines too */
-  i = Crosshair.AttachedObject.RubberbandN;
-  ptr = Crosshair.AttachedObject.Rubberband;
-  while (i)
+  for (i = Crosshair.AttachedObject.Rubberband; i != NULL; i = g_list_next (i))
     {
-      PointTypePtr point1, point2;
+      RubberbandType *ptr = i->data;
+      PointType *point1, *point2;
 
       if (TEST_FLAG (VIAFLAG, ptr->Line))
 	{
@@ -535,9 +533,6 @@ XORDrawMoveOrCopyObject (void)
 			     ptr->Line->Point1.Y + dy,
 			     ptr->Line->Point2.X + dx,
 			     ptr->Line->Point2.Y + dy, ptr->Line->Thickness);
-
-      ptr++;
-      i--;
     }
 }
 
diff --git a/src/draw.c b/src/draw.c
index 9ebcba6..4a254dd 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -774,10 +774,17 @@ DrawEMark (ElementTypePtr e, LocationType X, LocationType Y,
   if (!PCB->InvisibleObjectsOn && invisible)
     return;
 
-  if (e->PinN && mark_size > e->Pin[0].Thickness / 2)
-    mark_size = e->Pin[0].Thickness / 2;
-  if (e->PadN && mark_size > e->Pad[0].Thickness / 2)
-    mark_size = e->Pad[0].Thickness / 2;
+  if (e->Pin != NULL)
+    {
+      PinType *pin0 = e->Pin->data;
+      mark_size = MIN (mark_size, pin0->Thickness / 2);
+    }
+
+  if (e->Pad != NULL)
+    {
+      PadType *pad0 = e->Pad->data;
+      mark_size = MIN (mark_size, pad0->Thickness / 2);
+    }
 
   gui->set_color (Output.fgGC,
 		  invisible ? PCB->InvisibleMarkColor : PCB->ElementColor);
@@ -1195,7 +1202,7 @@ DrawTextLowLevel (TextTypePtr Text, int min_line_width)
 {
   LocationType x = 0;
   unsigned char *string = (unsigned char *) Text->TextString;
-  Cardinal n;
+  GList *iter;
   FontTypePtr font = &PCB->Font;
 
   while (string && *string)
@@ -1203,11 +1210,12 @@ DrawTextLowLevel (TextTypePtr Text, int min_line_width)
       /* draw lines if symbol is valid and data is present */
       if (*string <= MAX_FONTPOSITION && font->Symbol[*string].Valid)
 	{
-	  LineTypePtr line = font->Symbol[*string].Line;
-	  LineType newline;
-
-	  for (n = font->Symbol[*string].LineN; n; n--, line++)
+	  for (iter = font->Symbol[*string].Line;
+	       iter != NULL; iter = g_list_next (iter))
 	    {
+	      LineType *line = iter->data;
+	      LineType newline;
+
 	      /* create one line, scale, move, rotate and swap it */
 	      newline = *line;
 	      newline.Point1.X = (newline.Point1.X + x) * Text->Scale / 100;
diff --git a/src/drill.c b/src/drill.c
index a7a908b..46e8f80 100644
--- a/src/drill.c
+++ b/src/drill.c
@@ -90,11 +90,9 @@ InitializeDrill (DrillTypePtr drill, PinTypePtr pin, ElementTypePtr element)
   drill->ViaCount = 0;
   drill->PinCount = 0;
   drill->UnplatedCount = 0;
-  drill->ElementMax = 0;
   drill->Element = NULL;
   drill->PinN = 0;
   drill->Pin = NULL;
-  drill->PinMax = 0;
   ptr = (void *) GetDrillPinMemory (drill);
   *((PinTypeHandle) ptr) = pin;
   if (element)
@@ -166,9 +164,8 @@ GetDrillInfo (DataTypePtr top)
 		}
 	    }
 	    END_LOOP;
-	    if (AllDrills->Drill[AllDrills->DrillN - 1].DrillSize <
-		pin->DrillingHole)
-	      {
+	    if (AllDrills->Drill[AllDrills->DrillN - 1].DrillSize < pin->DrillingHole)
+	      { /* ^^ Last drill in the list, presumably sorted? */
 		Drill = GetDrillInfoDrillMemory (AllDrills);
 		InitializeDrill (Drill, pin, element);
 	      }
@@ -231,8 +228,7 @@ RoundDrillInfo (DrillInfoTypePtr d, int roundto)
 	{
 	  int ei, ej;
 
-	  d->Drill[i].ElementMax
-	    = d->Drill[i].ElementN + d->Drill[i+1].ElementN;
+	  d->Drill[i].ElementMax = d->Drill[i].ElementN + d->Drill[i+1].ElementN;
 	  if (d->Drill[i].ElementMax)
 	    {
 	      d->Drill[i].Element = (ElementTypePtr *)realloc (d->Drill[i].Element,
@@ -280,16 +276,3 @@ RoundDrillInfo (DrillInfoTypePtr d, int roundto)
 	}
     }
 }
-
-void
-FreeDrillInfo (DrillInfoTypePtr Drills)
-{
-  DRILL_LOOP (Drills);
-  {
-    free (drill->Element);
-    free (drill->Pin);
-  }
-  END_LOOP;
-  free (Drills->Drill);
-  free (Drills);
-}
diff --git a/src/fontmode.c b/src/fontmode.c
index eae2545..a754843 100644
--- a/src/fontmode.c
+++ b/src/fontmode.c
@@ -81,6 +81,7 @@ FontEdit (int argc, char **argv, int Ux, int Uy)
   SymbolType *symbol;
   LayerTypePtr lfont, lorig, lwidth, lgrid;
   int s, l;
+  GList *ll;
 
   if (hid_actionl ("New", "Font", 0))
     return 1;
@@ -118,25 +119,26 @@ FontEdit (int argc, char **argv, int Ux, int Uy)
       miny = 500;
       maxy = font->MaxHeight;
 
-      for (l = 0; l < symbol->LineN; l++)
+      for (ll = symbol->Line; ll != NULL; ll = g_list_next (ll))
 	{
+	  LineType *line = ll->data;
+
 	  CreateDrawnLineOnLayer (lfont,
-				  symbol->Line[l].Point1.X + ox,
-				  symbol->Line[l].Point1.Y + oy,
-				  symbol->Line[l].Point2.X + ox,
-				  symbol->Line[l].Point2.Y + oy,
-				  symbol->Line[l].Thickness,
-				  symbol->Line[l].Thickness, NoFlags ());
-	  CreateDrawnLineOnLayer (lorig, symbol->Line[l].Point1.X + ox,
-				  symbol->Line[l].Point1.Y + oy,
-				  symbol->Line[l].Point2.X + ox,
-				  symbol->Line[l].Point2.Y + oy,
-				  symbol->Line[l].Thickness,
-				  symbol->Line[l].Thickness, NoFlags ());
-	  if (maxx < symbol->Line[l].Point1.X)
-	    maxx = symbol->Line[l].Point1.X;
-	  if (maxx < symbol->Line[l].Point2.X)
-	    maxx = symbol->Line[l].Point2.X;
+				  line->Point1.X + ox,
+				  line->Point1.Y + oy,
+				  line->Point2.X + ox,
+				  line->Point2.Y + oy,
+				  line->Thickness,
+				  line->Thickness, NoFlags ());
+	  CreateDrawnLineOnLayer (lorig,
+				  line->Point1.X + ox,
+				  line->Point1.Y + oy,
+				  line->Point2.X + ox,
+				  line->Point2.Y + oy,
+				  line->Thickness,
+				  line->Thickness, NoFlags ());
+	  maxx = MAX (maxx, line->Point1.X);
+	  maxx = MAX (maxx, line->Point2.X);
 	}
       w = maxx + symbol->Delta + ox;
       CreateDrawnLineOnLayer (lwidth,
@@ -173,6 +175,7 @@ FontSave (int argc, char **argv, int Ux, int Uy)
   FontTypePtr font;
   SymbolTypePtr symbol;
   int i;
+  GList *ii;
   LayerTypePtr lfont, lwidth;
 
   font = &PCB->Font;
@@ -186,9 +189,9 @@ FontSave (int argc, char **argv, int Ux, int Uy)
       font->Symbol[i].Width = 0;
     }
 
-  for (i = 0; i < lfont->LineN; i++)
+  for (ii = lfont->Line; ii != NULL; ii = g_list_next (ii))
     {
-      LineTypePtr l = &lfont->Line[i];
+      LineType *l = ii->data;
       int x1 = l->Point1.X;
       int y1 = l->Point1.Y;
       int x2 = l->Point2.X;
@@ -214,9 +217,9 @@ FontSave (int argc, char **argv, int Ux, int Uy)
       CreateNewLineInSymbol (symbol, x1, y1, x2, y2, l->Thickness);
     }
 
-  for (i = 0; i < lwidth->LineN; i++)
+  for (ii = lwidth->Line; ii != NULL; ii = g_list_next (ii))
     {
-      LineTypePtr l = &lwidth->Line[i];
+      LineType *l = ii->data;
       int x1 = l->Point1.X;
       int y1 = l->Point1.Y;
       int ox, oy, s;
diff --git a/src/global.h b/src/global.h
index 6496c7b..66bf3e6 100644
--- a/src/global.h
+++ b/src/global.h
@@ -389,14 +389,14 @@ typedef struct			/* holds drill information */
     ViaCount,			/* number of vias drilled this size */
     UnplatedCount,		/* number of these holes that are unplated */
     PinN;			/* number of drill coordinates in the list */
-  PinTypePtr *Pin;		/* coordinates to drill */
-  ElementTypePtr *Element;	/* a pointer to an array of element pointers */
+  GList *Pin;		/* coordinates to drill */
+  GList *Element;		/* a pointer to an array of element pointers */
 } DrillType, *DrillTypePtr;
 
 typedef struct			/* holds a range of Drill Infos */
 {
   Cardinal DrillN;		/* number of drill sizes */
-  DrillTypePtr Drill;		/* plated holes */
+  GList *Drill;			/* plated holes */
 } DrillInfoType, *DrillInfoTypePtr;
 
 typedef struct
diff --git a/src/intersect.c b/src/intersect.c
index e7612e9..104ca29 100644
--- a/src/intersect.c
+++ b/src/intersect.c
@@ -90,18 +90,20 @@ LocationList;
  * Create a sorted list of unique y coords from a BoxList.
  */
 static LocationList
-createSortedYList (BoxListTypePtr boxlist)
+createSortedYList (BoxListType *boxlist)
 {
   LocationList yCoords;
   LocationType last;
   int i, n;
+  GList *ii;
   /* create sorted list of Y coordinates */
   yCoords.size = 2 * boxlist->BoxN;
   yCoords.p = (LocationType *)calloc (yCoords.size, sizeof (*yCoords.p));
-  for (i = 0; i < boxlist->BoxN; i++)
+  for (ii = boxlist->Box, i = 0; ii != NULL; ii = g_list_next (ii), i++)
     {
-      yCoords.p[2 * i] = boxlist->Box[i].Y1;
-      yCoords.p[2 * i + 1] = boxlist->Box[i].Y2;
+      BoxType *box = ii->data;
+      yCoords.p[2 * i + 0] = box->Y1;
+      yCoords.p[2 * i + 1] = box->Y2;
     }
   qsort (yCoords.p, yCoords.size, sizeof (*yCoords.p), comparepos);
   /* count uniq y coords */
@@ -202,12 +204,15 @@ deleteSegment (SegmentTree * st, int n, LocationType Y1, LocationType Y2)
 double
 ComputeIntersectionArea (BoxListTypePtr boxlist)
 {
-  Cardinal i;
+  GList *i;
   double area = 0.0;
   /* first get the aggregate area. */
-  for (i = 0; i < boxlist->BoxN; i++)
-    area += (double) (boxlist->Box[i].X2 - boxlist->Box[i].X1) *
-      (double) (boxlist->Box[i].Y2 - boxlist->Box[i].Y1);
+  for (i = boxlist->Box; i != NULL; i = g_list_next (i))
+    {
+      BoxType *box = i->data;
+      area += (double) (box->X2 - box->X1) *
+              (double) (box->Y2 - box->Y1);
+    }
   /* intersection area is aggregate - union. */
   return area * 0.0001 - ComputeUnionArea (boxlist);
 }
@@ -221,6 +226,7 @@ ComputeUnionArea (BoxListTypePtr boxlist)
 {
   BoxTypePtr *rectLeft, *rectRight;
   Cardinal i, j;
+  GList *ii;
   LocationList yCoords;
   SegmentTree segtree;
   LocationType lastX;
@@ -236,11 +242,12 @@ ComputeUnionArea (BoxListTypePtr boxlist)
   /* create sorted list of left and right X coordinates of rectangles */
   rectLeft = (BoxTypePtr *)calloc (boxlist->BoxN, sizeof (*rectLeft));
   rectRight = (BoxTypePtr *)calloc (boxlist->BoxN, sizeof (*rectRight));
-  for (i = 0; i < boxlist->BoxN; i++)
+  for (ii = boxlist->Box, i = 0; ii != NULL; ii = g_list_next (ii), i++)
     {
-      assert (boxlist->Box[i].X1 <= boxlist->Box[i].X2);
-      assert (boxlist->Box[i].Y1 <= boxlist->Box[i].Y2);
-      rectLeft[i] = rectRight[i] = &boxlist->Box[i];
+      BoxType *box = ii->data;
+      assert (boxlist->Box[i].X1 <= box->X2);
+      assert (boxlist->Box[i].Y1 <= box->Y2);
+      rectLeft[i] = rectRight[i] = box;
     }
   qsort (rectLeft, boxlist->BoxN, sizeof (*rectLeft), compareleft);
   qsort (rectRight, boxlist->BoxN, sizeof (*rectRight), compareright);
diff --git a/src/macro.h b/src/macro.h
index 0794ff5..b27d891 100644
--- a/src/macro.h
+++ b/src/macro.h
@@ -191,12 +191,13 @@ extern int mem_any_set (unsigned char *, int);
        __iter = g_list_next (__iter), n++) {                        \
     PinType *via = __iter->data;
 
-#define DRILL_LOOP(top) do             {                            \
-        Cardinal        n;                                          \
-        DrillTypePtr    drill;                                      \
-        for (n = 0; (top)->DrillN > 0 && n < (top)->DrillN; n++)    \
-        {                                                           \
-                drill = &(top)->Drill[n]
+#define DRILL_LOOP(top) do {                                        \
+  GList *__iter;                                                    \
+  GList *__copy = g_list_copy ((top)->Drill);                       \
+  Cardinal n;                                                       \
+  for (__iter = __copy, n = 0; __iter != NULL;                      \
+       __iter = g_list_next (__iter), n++) {                        \
+    DrillType *drill = __iter->data;
 
 #define NETLIST_LOOP(top) do {                                      \
   GList *__iter;                                                    \
diff --git a/src/misc.c b/src/misc.c
index 0e25089..cbbb172 100644
--- a/src/misc.c
+++ b/src/misc.c
@@ -441,7 +441,7 @@ SetTextBoundingBox (FontTypePtr FontPtr, TextTypePtr Text)
   SymbolTypePtr symbol = FontPtr->Symbol;
   unsigned char *s = (unsigned char *) Text->TextString;
   BDimension minThick = 0;
-  int i;
+  GList *i;
   int space = 0;
 
   LocationType minx=0, miny=0, maxx=0, maxy=0;
@@ -462,9 +462,9 @@ SetTextBoundingBox (FontTypePtr FontPtr, TextTypePtr Text)
     {
       if (*s <= MAX_FONTPOSITION && symbol[*s].Valid)
 	{
-	  LineTypePtr line = symbol[*s].Line;
-	  for (i = 0; i < symbol[*s].LineN; line++, i++)
+	  for (i = symbol[*s].Line; i != NULL; i = g_list_next (i))
 	    {
+              LineType *line = i->data;
 	      int t = line->Thickness / 4;
 	      if (t < minThick)
 		t = minThick;
@@ -723,9 +723,9 @@ CenterDisplay (LocationType X, LocationType Y, bool Delta)
 void
 SetFontInfo (FontTypePtr Ptr)
 {
-  Cardinal i, j;
+  Cardinal i;
+  GList *iter;
   SymbolTypePtr symbol;
-  LineTypePtr line;
   LocationType totalminy = MAX_COORD;
 
   /* calculate cell with and height (is at least DEFAULT_CELLSIZE)
@@ -744,8 +744,9 @@ SetFontInfo (FontTypePtr Ptr)
 
       minx = miny = MAX_COORD;
       maxx = maxy = 0;
-      for (line = symbol->Line, j = symbol->LineN; j; j--, line++)
+      for (iter = symbol->Line ; iter != NULL; iter = g_list_next (iter))
         {
+          LineType *line = iter->data;
           minx = MIN (minx, line->Point1.X);
           miny = MIN (miny, line->Point1.Y);
           minx = MIN (minx, line->Point2.X);
@@ -757,8 +758,11 @@ SetFontInfo (FontTypePtr Ptr)
         }
 
       /* move symbol to left edge */
-      for (line = symbol->Line, j = symbol->LineN; j; j--, line++)
-        MOVE_LINE_LOWLEVEL (line, -minx, 0);
+      for (iter = symbol->Line; iter != NULL; iter = g_list_next (iter))
+        {
+          LineType *line = iter->data;
+          MOVE_LINE_LOWLEVEL (line, -minx, 0);
+        }
 
       /* set symbol bounding box with a minimum cell size of (1,1) */
       symbol->Width = maxx - minx + 1;
@@ -775,8 +779,11 @@ SetFontInfo (FontTypePtr Ptr)
     if (symbol->Valid)
       {
         symbol->Height -= totalminy;
-        for (line = symbol->Line, j = symbol->LineN; j; j--, line++)
-          MOVE_LINE_LOWLEVEL (line, 0, -totalminy);
+        for (iter = symbol->Line; iter != NULL; iter = g_list_next (iter))
+          {
+            LineType *line = iter->data;
+            MOVE_LINE_LOWLEVEL (line, 0, -totalminy);
+          }
       }
 
   /* setup the box for the default symbol */
@@ -1696,8 +1703,11 @@ GetGridLockCoordinates (int type, void *ptr1,
       *y = ((ElementTypePtr) ptr2)->MarkY;
       break;
     case POLYGON_TYPE:
-      *x = ((PolygonTypePtr) ptr2)->Points[0].X;
-      *y = ((PolygonTypePtr) ptr2)->Points[0].Y;
+      {
+        PointType *point0 = ((PolygonTypePtr) ptr2)->Points->data;
+        *x = point0->X;
+        *y = point0->Y;
+      }
       break;
 
     case LINEPOINT_TYPE:
@@ -1980,10 +1990,13 @@ pcb_author (void)
 char *
 AttributeGetFromList (AttributeListType *list, char *name)
 {
-  int i;
-  for (i=0; i<list->Number; i++)
-    if (strcmp (name, list->List[i].name) == 0)
-      return list->List[i].value;
+  GList *i;
+  for (i = list->List; i != NULL; i = g_list_next (i))
+    {
+      AttributeType *attr = i->data;
+      if (strcmp (name, attr->name) == 0)
+        return attr->value;
+    }
   return NULL;
 }
 
diff --git a/src/move.c b/src/move.c
index c8d1938..da1f550 100644
--- a/src/move.c
+++ b/src/move.c
@@ -436,44 +436,36 @@ MovePolygonPoint (LayerTypePtr Layer, PolygonTypePtr Polygon,
  * moves a line between layers; lowlevel routines
  */
 void *
-MoveLineToLayerLowLevel (LayerTypePtr Source, LineTypePtr Line,
+MoveLineToLayerLowLevel (LayerTypePtr Source, LineTypePtr line,
 			 LayerTypePtr Destination)
 {
-  LineTypePtr newone = GetLineMemory (Destination);
-
-  r_delete_entry (Source->line_tree, (BoxTypePtr) Line);
-  /* copy the data and remove it from the former layer */
-  *newone = *Line;
-  *Line = Source->Line[--Source->LineN];
-  r_substitute (Source->line_tree, (BoxType *) & Source->Line[Source->LineN],
-		(BoxType *) Line);
-  memset (&Source->Line[Source->LineN], 0, sizeof (LineType));
+  r_delete_entry (Source->line_tree, (BoxType *)line);
+
+  Source->Line = g_list_remove (Source->Line, line);
+  Destination->Line = g_list_append (Destination->Line, line);
+
   if (!Destination->line_tree)
     Destination->line_tree = r_create_tree (NULL, 0, 0);
-  r_insert_entry (Destination->line_tree, (BoxTypePtr) newone, 0);
-  return (newone);
+  r_insert_entry (Destination->line_tree, (BoxType *)line, 0);
+  return line;
 }
 
 /* ---------------------------------------------------------------------------
  * moves an arc between layers; lowlevel routines
  */
 void *
-MoveArcToLayerLowLevel (LayerTypePtr Source, ArcTypePtr Arc,
+MoveArcToLayerLowLevel (LayerTypePtr Source, ArcTypePtr arc,
 			LayerTypePtr Destination)
 {
-  ArcTypePtr newone = GetArcMemory (Destination);
-
-  r_delete_entry (Source->arc_tree, (BoxTypePtr) Arc);
-  /* copy the data and remove it from the former layer */
-  *newone = *Arc;
-  *Arc = Source->Arc[--Source->ArcN];
-  r_substitute (Source->arc_tree, (BoxType *) & Source->Arc[Source->ArcN],
-		(BoxType *) Arc);
-  memset (&Source->Arc[Source->ArcN], 0, sizeof (ArcType));
+  r_delete_entry (Source->arc_tree, (BoxType *)arc);
+
+  Source->Arc = g_list_remove (Source->Arc, arc);
+  Destination->Arc = g_list_append (Destination->Arc, arc);
+
   if (!Destination->arc_tree)
     Destination->arc_tree = r_create_tree (NULL, 0, 0);
-  r_insert_entry (Destination->arc_tree, (BoxTypePtr) newone, 0);
-  return (newone);
+  r_insert_entry (Destination->arc_tree, (BoxType *)arc, 0);
+  return arc;
 }
 
 
@@ -640,83 +632,74 @@ MoveLineToLayer (LayerTypePtr Layer, LineTypePtr Line)
 /* ---------------------------------------------------------------------------
  * moves a text object between layers; lowlevel routines
  */
-void *
-MoveTextToLayerLowLevel (LayerTypePtr Source, TextTypePtr Text,
+TextType *
+MoveTextToLayerLowLevel (LayerTypePtr Source, TextType *text,
 			 LayerTypePtr Destination)
 {
-  TextTypePtr newone = GetTextMemory (Destination);
-
-  RestoreToPolygon (PCB->Data, TEXT_TYPE, Source, Text);
-  r_delete_entry (Source->text_tree, (BoxTypePtr) Text);
-  /* copy the data and remove it from the former layer */
-  *newone = *Text;
-  *Text = Source->Text[--Source->TextN];
-  r_substitute (Source->text_tree, (BoxType *) & Source->Text[Source->TextN],
-		(BoxType *) Text);
-  memset (&Source->Text[Source->TextN], 0, sizeof (TextType));
+  RestoreToPolygon (PCB->Data, TEXT_TYPE, Source, text);
+  r_delete_entry (Source->text_tree, (BoxType *)text);
+
+  Source->Text = g_list_remove (Source->Text, text);
+  Destination->Text = g_list_append (Destination->Text, text);
+
   if (GetLayerGroupNumberByNumber (solder_silk_layer) ==
       GetLayerGroupNumberByPointer (Destination))
-    SET_FLAG (ONSOLDERFLAG, newone);
+    SET_FLAG (ONSOLDERFLAG, text);
   else
-    CLEAR_FLAG (ONSOLDERFLAG, newone);
+    CLEAR_FLAG (ONSOLDERFLAG, text);
+
   /* re-calculate the bounding box (it could be mirrored now) */
-  SetTextBoundingBox (&PCB->Font, newone);
+  SetTextBoundingBox (&PCB->Font, text);
   if (!Destination->text_tree)
     Destination->text_tree = r_create_tree (NULL, 0, 0);
-  r_insert_entry (Destination->text_tree, (BoxTypePtr) newone, 0);
-  ClearFromPolygon (PCB->Data, TEXT_TYPE, Destination, newone);
-  return (newone);
+  r_insert_entry (Destination->text_tree, (BoxType *) text, 0);
+  ClearFromPolygon (PCB->Data, TEXT_TYPE, Destination, text);
+
+  return text;
 }
 
 /* ---------------------------------------------------------------------------
  * moves a text object between layers
  */
 static void *
-MoveTextToLayer (LayerTypePtr Layer, TextTypePtr Text)
+MoveTextToLayer (LayerType *layer, TextType *text)
 {
-  TextTypePtr newone;
-
-  if (TEST_FLAG (LOCKFLAG, Text))
+  if (TEST_FLAG (LOCKFLAG, text))
     {
       Message (_("Sorry, the object is locked\n"));
       return NULL;
     }
-  if (Dest != Layer)
+  if (Dest != layer)
     {
-      AddObjectToMoveToLayerUndoList (TEXT_TYPE, Layer, Text, Text);
-      if (Layer->On)
-	EraseText (Layer, Text);
-      newone = (TextTypePtr)MoveTextToLayerLowLevel (Layer, Text, Dest);
+      AddObjectToMoveToLayerUndoList (TEXT_TYPE, layer, text, text);
+      if (layer->On)
+	EraseText (layer, text);
+      text = MoveTextToLayerLowLevel (layer, text, Dest);
       if (Dest->On)
-	DrawText (Dest, newone);
-      if (Layer->On || Dest->On)
+	DrawText (Dest, text);
+      if (layer->On || Dest->On)
 	Draw ();
-      return (newone);
     }
-  return (Text);
+  return text;
 }
 
 /* ---------------------------------------------------------------------------
  * moves a polygon between layers; lowlevel routines
  */
 void *
-MovePolygonToLayerLowLevel (LayerTypePtr Source, PolygonTypePtr Polygon,
+MovePolygonToLayerLowLevel (LayerTypePtr Source, PolygonType *polygon,
 			    LayerTypePtr Destination)
 {
-  PolygonTypePtr newone = GetPolygonMemory (Destination);
-
-  r_delete_entry (Source->polygon_tree, (BoxType *) Polygon);
-  /* copy the data and remove it from the former layer */
-  *newone = *Polygon;
-  *Polygon = Source->Polygon[--Source->PolygonN];
-  r_substitute (Source->polygon_tree,
-		(BoxType *) & Source->Polygon[Source->PolygonN],
-		(BoxType *) Polygon);
-  memset (&Source->Polygon[Source->PolygonN], 0, sizeof (PolygonType));
+  r_delete_entry (Source->polygon_tree, (BoxType *) polygon);
+
+  Source->Polygon = g_list_remove (Source->Polygon, polygon);
+  Destination->Polygon = g_list_append (Destination->Polygon, polygon);
+
   if (!Destination->polygon_tree)
     Destination->polygon_tree = r_create_tree (NULL, 0, 0);
-  r_insert_entry (Destination->polygon_tree, (BoxType *) newone, 0);
-  return (newone);
+  r_insert_entry (Destination->polygon_tree, (BoxType *) polygon, 0);
+
+  return polygon;
 }
 
 struct mptlc
@@ -806,7 +789,7 @@ void *
 MoveObjectAndRubberband (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
 			 LocationType DX, LocationType DY)
 {
-  RubberbandTypePtr ptr;
+  GList *iter;
   void *ptr2;
 
   /* setup offset */
@@ -816,9 +799,11 @@ MoveObjectAndRubberband (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
     return (NULL);
 
   /* move all the lines... and reset the counter */
-  ptr = Crosshair.AttachedObject.Rubberband;
-  while (Crosshair.AttachedObject.RubberbandN)
+  for (iter = Crosshair.AttachedObject.Rubberband;
+       iter != NULL; iter = g_list_next (iter))
     {
+      RubberbandType *ptr = iter->data;
+
       /* first clear any marks that we made in the line flags */
       CLEAR_FLAG (RUBBERENDFLAG, ptr->Line);
       AddObjectToMoveUndoList (LINEPOINT_TYPE,
@@ -826,7 +811,6 @@ MoveObjectAndRubberband (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
 			       DY);
       MoveLinePoint (ptr->Layer, ptr->Line, ptr->MovedPoint);
       Crosshair.AttachedObject.RubberbandN--;
-      ptr++;
     }
 
   AddObjectToMoveUndoList (Type, Ptr1, Ptr2, Ptr3, DX, DY);
diff --git a/src/move.h b/src/move.h
index c4a844b..489224b 100644
--- a/src/move.h
+++ b/src/move.h
@@ -101,7 +101,6 @@ void *MoveObjectToLayer (int, void *, void *, void *, LayerTypePtr, bool);
 void *MoveObjectAndRubberband (int, void *, void *, void *,
 			       LocationType, LocationType);
 void *MoveLineToLayerLowLevel (LayerTypePtr, LineTypePtr, LayerTypePtr);
-void *MoveTextToLayerLowLevel (LayerTypePtr, TextTypePtr, LayerTypePtr);
 void *MovePolygonToLayerLowLevel (LayerTypePtr, PolygonTypePtr, LayerTypePtr);
 bool MoveSelectedObjectsToLayer (LayerTypePtr);
 
diff --git a/src/mymem.c b/src/mymem.c
index 55556f3..a3bc896 100644
--- a/src/mymem.c
+++ b/src/mymem.c
@@ -421,8 +421,8 @@ GetLibraryEntryMemory (LibraryMenuType *menu)
   LibraryEntryType *new_obj;
 
   new_obj = g_slice_new (LibraryEntryType);
+  menu->Entry = g_list_append (menu->Entry, new_obj);
   menu->EntryN ++;
-#warning LINK UP WITH OTHER OBJCETS?
 
   return new_obj;
 }
@@ -445,8 +445,8 @@ GetLibraryMenuMemory (LibraryType *lib)
   LibraryMenuType *new_obj;
 
   new_obj = g_slice_new (LibraryMenuType);
+  lib->Menu = g_list_append (lib->Menu, new_obj);
   lib->MenuN ++;
-#warning LINK UP WITH OTHER OBJCETS?
 
   return new_obj;
 }
@@ -468,8 +468,8 @@ GetDrillElementMemory (DrillType *drill)
   ElementType **new_obj;
 
   new_obj = g_slice_new (ElementType *);
+  drill->Element = g_list_append (drill->Element, new_obj);
   drill->ElementN ++;
-#warning LINK UP WITH OTHER OBJCETS?
 
   return new_obj;
 }
@@ -489,8 +489,8 @@ GetDrillPinMemory (DrillType *drill)
   PinType **new_obj;
 
   new_obj = g_slice_new (PinType *);
+  drill->Pin = g_list_append (drill->Pin, new_obj);
   drill->PinN ++;
-#warning LINK UP WITH OTHER OBJCETS?
 
   return new_obj;
 }
@@ -510,18 +510,26 @@ GetDrillInfoDrillMemory (DrillInfoType *drillinfo)
   DrillType *new_obj;
 
   new_obj = g_slice_new (DrillType);
+  drillinfo->Drill = g_list_append (drillinfo->Drill, new_obj);
   drillinfo->DrillN ++;
-#warning LINK UP WITH OTHER OBJCETS?
 
   return new_obj;
 }
 
 static void
-FreeDrill (DrillType *data)
+FreeDrill (DrillType *drill)
 {
-  g_slice_free (DrillType, data);
+  g_list_free_full (drill->Element, (GDestroyNotify)FreeDrillElement);
+  g_list_free_full (drill->Pin, (GDestroyNotify)FreeDrillPin);
+  g_slice_free (DrillType, drill);
 }
 
+void
+FreeDrillInfo (DrillInfoType *drill_info)
+{
+  g_list_free_full (drill_info->Drill, (GDestroyNotify)FreeDrill);
+  g_slice_free (DrillInfoType, drill_info);
+}
 
 AttributeType *
 GetAttributeMemory (AttributeListType *attr_list)
diff --git a/src/mymem.h b/src/mymem.h
index a5be41b..b7bbd16 100644
--- a/src/mymem.h
+++ b/src/mymem.h
@@ -70,6 +70,7 @@ LibraryEntryTypePtr GetLibraryEntryMemory (LibraryMenuTypePtr);
 ElementTypeHandle GetDrillElementMemory (DrillTypePtr);
 PinTypeHandle GetDrillPinMemory (DrillTypePtr);
 DrillTypePtr GetDrillInfoDrillMemory (DrillInfoTypePtr);
+void FreeDrillInfo (DrillInfoTypePtr);
 void **GetPointerMemory (PointerListTypePtr);
 AttributeTypePtr GetAttributeMemory (AttributeListTypePtr);
 void FreeAttribute (AttributeTypePtr);
diff --git a/src/undo.c b/src/undo.c
index 21b86f4..843527c 100644
--- a/src/undo.c
+++ b/src/undo.c
@@ -164,7 +164,7 @@ UndoListType, *UndoListTypePtr;
  * some local variables
  */
 static DataTypePtr RemoveList = NULL;	/* list of removed objects */
-static UndoListTypePtr UndoList = NULL;	/* list of operations */
+static GList *UndoList = NULL;	/* list of operations */
 static int Serial = 1,		/* serial number */
   SavedSerial;
 static size_t UndoN, RedoN,	/* number of entries */
@@ -202,13 +202,15 @@ static int PerformUndo (UndoListTypePtr);
 /* ---------------------------------------------------------------------------
  * adds a command plus some data to the undo list
  */
-static UndoListTypePtr
+static UndoListType *
 GetUndoSlot (int CommandType, int ID, int Kind)
 {
-  UndoListTypePtr ptr;
+  UndoListType *ptr;
   void *ptr1, *ptr2, *ptr3;
   int type;
   static size_t limit = UNDO_WARNING_SIZE;
+  size_t size;
+  GList *iter;
 
 #ifdef DEBUG_ID
   if (SearchObjectByID (PCB->Data, &ptr1, &ptr2, &ptr3, ID, Kind) == NO_TYPE)
@@ -216,53 +218,59 @@ GetUndoSlot (int CommandType, int ID, int Kind)
 	     Kind);
 #endif
 
-  /* allocate memory */
-  if (UndoN >= UndoMax)
+  size = UndoN * sizeof (UndoListType);
+
+  /* ask user to flush the table because of it's size */
+  if (size > limit)
     {
-      size_t size;
+      limit = (size / UNDO_WARNING_SIZE + 1) * UNDO_WARNING_SIZE;
+      Message (_("Size of 'undo-list' exceeds %li kb\n"),
+               (long) (size >> 10));
+    }
 
-      UndoMax += STEP_UNDOLIST;
-      size = UndoMax * sizeof (UndoListType);
-      UndoList = (UndoListTypePtr) realloc (UndoList, size);
-      memset (&UndoList[UndoN], 0, STEP_REMOVELIST * sizeof (UndoListType));
+  /* free structures from the pruned redo list */
 
-      /* ask user to flush the table because of it's size */
-      if (size > limit)
-	{
-	  limit = (size / UNDO_WARNING_SIZE + 1) * UNDO_WARNING_SIZE;
-	  Message (_("Size of 'undo-list' exceeds %li kb\n"),
-		   (long) (size >> 10));
-	}
+  for (iter = g_list_nth (UndoList, UndoN);
+       iter != NULL; iter = g_list_next (iter), RedoN--)
+    {
+      ptr = iter->data;
+
+      switch (ptr->Type)
+        {
+        case UNDO_CHANGENAME:
+          free (ptr->Data.ChangeName.Name);
+          break;
+        case UNDO_REMOVE:
+          type =
+            SearchObjectByID (RemoveList, &ptr1, &ptr2, &ptr3, ptr->ID,
+                              ptr->Kind);
+          if (type != NO_TYPE)
+            {
+              DestroyObject (RemoveList, type, ptr1, ptr2, ptr3);
+            }
+          break;
+        default:
+          break;
+        }
+      g_slice_free (UndoListType, ptr);
     }
 
-  /* free structures from the pruned redo list */
+  /* Break off and free the pruned redo list */
+  iter = g_list_nth (UndoList, UndoN);
+  iter->prev->next = NULL;
+  iter->prev = NULL;
 
-  for (ptr = &UndoList[UndoN]; RedoN; ptr++, RedoN--)
-    switch (ptr->Type)
-      {
-      case UNDO_CHANGENAME:
-	free (ptr->Data.ChangeName.Name);
-	break;
-      case UNDO_REMOVE:
-	type =
-	  SearchObjectByID (RemoveList, &ptr1, &ptr2, &ptr3, ptr->ID,
-			    ptr->Kind);
-	if (type != NO_TYPE)
-	  {
-	    DestroyObject (RemoveList, type, ptr1, ptr2, ptr3);
-	  }
-	break;
-      default:
-	break;
-      }
+  g_list_free (iter);
 
   /* copy typefield and serial number to the list */
-  ptr = &UndoList[UndoN++];
+  ptr = g_slice_new0 (UndoListType);
+  UndoList = g_list_append (UndoList, ptr);
+
   ptr->Type = CommandType;
   ptr->Kind = Kind;
   ptr->ID = ID;
   ptr->Serial = Serial;
-  return (ptr);
+  return ptr;
 }
 
 /* ---------------------------------------------------------------------------
@@ -901,50 +909,35 @@ static bool
 UndoNetlistChange (UndoListTypePtr Entry)
 {
   NetlistChangeTypePtr l = & Entry->Data.NetlistChange;
-  unsigned int i, j;
+  GList *i, *j;
   LibraryTypePtr lib, saved;
 
   lib = l->lib;
   saved = l->old;
 
   /* iterate over each net */
-  for (i = 0 ; i < lib->MenuN; i++)
+  for (i = lib->Menu; i != NULL; i = g_list_next (i))
     {
-      if (lib->Menu[i].Name)
-	free (lib->Menu[i].Name);
+      LibraryMenuType *menu = i->data;
 
-      if (lib->Menu[i].directory)
-	free (lib->Menu[i].directory);
-
-      if (lib->Menu[i].Style)
-	free (lib->Menu[i].Style);
+      free (menu->Name);
+      free (menu->directory);
+      free (menu->Style);
 
       /* iterate over each pin on the net */
-      for (j = 0; j < lib->Menu[i].EntryN; j++) {
-	
-	if (lib->Menu[i].Entry[j].ListEntry)
-	  free (lib->Menu[i].Entry[j].ListEntry);
-	
-	if (lib->Menu[i].Entry[j].AllocatedMemory)
-	  free (lib->Menu[i].Entry[j].AllocatedMemory);
-	
-	if (lib->Menu[i].Entry[j].Template)
-	  free (lib->Menu[i].Entry[j].Template);
-	
-	if (lib->Menu[i].Entry[j].Package)
-	  free (lib->Menu[i].Entry[j].Package);
-	
-	if (lib->Menu[i].Entry[j].Value)
-	  free (lib->Menu[i].Entry[j].Value);
-	
-	if (lib->Menu[i].Entry[j].Description)
-	  free (lib->Menu[i].Entry[j].Description);
-	
+      for (j = menu->Entry; j != NULL; j = g_list_next (j)) {
+        LibraryEntryType *entry = j->data;
+
+        free (entry->ListEntry);
+        free (entry->AllocatedMemory);
+        free (entry->Template);
+        free (entry->Package);
+        free (entry->Value);
+        free (entry->Description);
       }
     }
 
-  if (lib->Menu)
-    free (lib->Menu);
+  free (lib->Menu);
 
   *lib = *saved;
 
@@ -1620,7 +1613,8 @@ void
 AddNetlistLibToUndoList (LibraryTypePtr lib)
 {
   UndoListTypePtr undo;
-  unsigned int i, j;
+  int i, j;
+  GList *ii, *jj;
   LibraryTypePtr old;
   
   if (!Locked)
@@ -1633,7 +1627,6 @@ AddNetlistLibToUndoList (LibraryTypePtr lib)
       undo->Data.NetlistChange.old = (LibraryTypePtr)malloc (sizeof (LibraryTypePtr));
       old = undo->Data.NetlistChange.old;
       old->MenuN = lib->MenuN;
-      old->MenuMax = lib->MenuMax;
       old->Menu = (LibraryMenuTypePtr)malloc (old->MenuMax * sizeof (LibraryMenuType));
       if (old->Menu == NULL)
 	{
@@ -1642,21 +1635,15 @@ AddNetlistLibToUndoList (LibraryTypePtr lib)
 	}
 
       /* iterate over each net */
-      for (i = 0 ; i < lib->MenuN; i++)
+      for (ii = liib->Menu, i = 0; ii != NULL; ii = g_liist_next (ii), i++)
 	{
-	  old->Menu[i].EntryN = lib->Menu[i].EntryN;
-	  old->Menu[i].EntryMax = lib->Menu[i].EntryMax;
+	  MenuType *menu = ii->data;
 
-	  old->Menu[i].Name = 
-	    lib->Menu[i].Name ? strdup (lib->Menu[i].Name) : NULL;
-	  
-	  old->Menu[i].directory = 
-	    lib->Menu[i].directory ? strdup (lib->Menu[i].directory) : NULL;
-	  
-	  old->Menu[i].Style = 
-	    lib->Menu[i].Style ? strdup (lib->Menu[i].Style) : NULL;
+	  old->Menu[i].EntryN = menu->EntryN;
+	  old->Menu[i].Name = menu->Name ? strdup (menu->Name) : NULL;
+	  old->Menu[i].directory = menu->directory ? strdup (menu->directory) : NULL;
+	  old->Menu[i].Style = menu->Style ? strdup (menu->Style) : NULL;
 
-      
 	  old->Menu[i].Entry = 
 	    (LibraryEntryTypePtr)malloc (old->Menu[i].EntryMax * sizeof (LibraryEntryType));
 	  if (old->Menu[i].Entry == NULL)
@@ -1666,39 +1653,19 @@ AddNetlistLibToUndoList (LibraryTypePtr lib)
 	    }
 	  
 	  /* iterate over each pin on the net */
-	  for (j = 0; j < lib->Menu[i].EntryN; j++) {
-
-	    old->Menu[i].Entry[j].ListEntry = 
-	      lib->Menu[i].Entry[j].ListEntry ? 
-	      strdup (lib->Menu[i].Entry[j].ListEntry) :
-	      NULL;
-
-	    old->Menu[i].Entry[j].AllocatedMemory = 
-	      lib->Menu[i].Entry[j].AllocatedMemory ? 
-	      strdup (lib->Menu[i].Entry[j].AllocatedMemory) :
-	      NULL;
-
-	    old->Menu[i].Entry[j].Template = 
-	      lib->Menu[i].Entry[j].Template ? 
-	      strdup (lib->Menu[i].Entry[j].Template) :
-	      NULL;
-
-	    old->Menu[i].Entry[j].Package = 
-	      lib->Menu[i].Entry[j].Package ? 
-	      strdup (lib->Menu[i].Entry[j].Package) :
-	      NULL;
-
-	    old->Menu[i].Entry[j].Value = 
-	      lib->Menu[i].Entry[j].Value ? 
-	      strdup (lib->Menu[i].Entry[j].Value) :
-	      NULL;
-
-	    old->Menu[i].Entry[j].Description = 
-	      lib->Menu[i].Entry[j].Description ? 
-	      strdup (lib->Menu[i].Entry[j].Description) :
-	      NULL;
-	    
-
+	  for (jj = menu->Entry, j = 0; jj != NULL; jj = g_list_next (jj), j++) {
+            LibraryEntryType *entry = jj->data;
+
+	    old->Menu[i].Entry[j].ListEntry =
+              entry->ListEntry ? strdup (entry->ListEntry) : NULL;
+	    old->Menu[i].Entry[j].AllocatedMemory =
+              entry->AllocatedMemory ? strdup (entry->AllocatedMemory) : NULL;
+	    old->Menu[i].Entry[j].Template =
+	      entry->Template ? strdup (entry->Template) : NULL;
+	    old->Menu[i].Entry[j].Package = entry->Package ? strdup (entry->Package) : NULL;
+	    old->Menu[i].Entry[j].Value = entry->Value ? strdup (entry->Value) : NULL;
+	    old->Menu[i].Entry[j].Description =
+              entry->Description ? strdup (entry->Description) : NULL;
 	  }
 	}

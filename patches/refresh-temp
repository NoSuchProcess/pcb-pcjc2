Bottom: b018f9e8fc1664b91954437424587d8187d1a10c
Top:    16c4290b99405851896a4e579e320b83d432d4fb
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-11-24 16:31:42 +0000

Refresh of try-yet-another-way

---

diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index 32002c2..4c0469d 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -862,6 +862,9 @@ void
 hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box)
 {
   int stencil_bit;
+  extern int layer_stencil_bit;
+
+//  return;
 
   CHECK_IS_IN_CONTEXT ();
 
@@ -884,168 +887,74 @@ hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box)
     /* Save the stencil setup */
     glPushAttrib (GL_STENCIL_BUFFER_BIT);
 
-#if 0
-
     /*   ___________________________________________________
      *  |   __________                                      |
-     *  |  |          |                             < n     |
-     *  |  | n        |                                     |
+     *  |  |          |                                1x0  |
+     *  |  | 0x0      |                                     |
      *  |  |      ....|....                                 |
-     *  |  |      : n |< n:                                 |
+     *  |  |      :   |   :                                 |
      *  |  |______:___|   :                                 |
      *  |         :.......: <-Hole we're about to mask      |
-     *  |                                                   |
-     *  |   Existing geometry on this layer is tagged "n"   |
-     *  |   Anywhere else, the stencil value is "< n"       |
-     *  |                                                   |
      *  |___________________________________________________|
      *
      * NEXT: Mask out the holes:
      *
-     *    The stencil test is "< n". It fails for any existing masked regions.
-     *    For these areas, (stencil fail), we GL_INCR-ement the stencil to
-     *    "n + 1". For other areas (stencil pass) we GL_REPLACE the stencil
-     *    with the test value, "n". We don't write holes to the colour buffer.
+     *    Set the object masking bit for regions we don't want to draw.
+     *    We MUST reset this bit afterwards when drawing the outline.
+     *    IE. outlines must always enclose all holes.
      */
 
-    glStencilOp (GL_INCR, GL_KEEP, GL_REPLACE);
     glPushAttrib (GL_COLOR_BUFFER_BIT);
     glColorMask (0, 0, 0, 0);
+
+//    glStencilMask (layer_stencil_bit | 1);
+//    glStencilFunc (GL_EQUAL, layer_stencil_bit, layer_stencil_bit);
+    glStencilOp (GL_KEEP, GL_KEEP, GL_INCR);
     r_search (poly->Clipped->contour_tree, clip_box, NULL, do_hole, NULL);
     hidgl_flush_triangles (&buffer);
+
     glPopAttrib ();
 
     /*   ___________________________________________________
      *  |   __________                                      |
-     *  |  |    ......|...........                  < n     |
-     *  |  | n  :   n |          :                          |
+     *  |  |    ......|...........                     1x0  |
+     *  |  | 0x0: 0x0 |          :                          |
      *  |  |    :  ...|...       :                          |
-     *  |  |    : :n+1| n :      :                          |
-     *  |  |____:_:___|   :      :                          |
+     *  |  |    : :0x0|   :      :                          |
+     *  |  |____:_:___|1x1:      :                          |
      *  |       : :.......:      :                          |
-     *  |       :            < n :                          |
+     *  |       :            1x0 :                          |
      *  |       :................: <-Polygon outer          |
      *  |___________________________________________________|
      *
      * NEXT: Draw the polygon:
      *
-     *    We draw our polygon where the stencil test passes ("< n")
-     *    Where we draw we GL_REPLACE the stencil buffer with "n".
-     */
-
-    glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);
-    fill_contour (poly->Clipped->contours);
-    hidgl_flush_triangles (&buffer);
-
-    /*   ___________________________________________________
-     *  |   __________                                      |
-     *  |  |     .....|__________                           |
-     *  |  | n  :   n |          |                          |
-     *  |  |    :  ...|___       |                          |
-     *  |  |    : :n+1| n |      |                          |
-     *  |  |____:_:___|   |      |                          |
-     *  |       | |_______|      |                          |
-     *  |       |             n  |                          |
-     *  |       |________________|                          |
-     *  |___________________________________________________|
-     *
-     * NEXT: Remove the hole masking:
-     *
-     *    We draw remove our masking by GL_DECR-ementing the hole regions.
-     *    Ex-"Hole" areas still allowed for drawing now have the value "n-1".
-     */
-
-    glStencilOp (GL_DECR, GL_KEEP, GL_DECR);
-    r_search (poly->Clipped->contour_tree, clip_box, NULL, do_hole, NULL);
-    hidgl_flush_triangles (&buffer);
-
-    /*   ___________________________________________________
-     *  |   __________                                      |
-     *  |  |     .....|__________                           |
-     *  |  | n  :   n |          |                          |
-     *  |  |    :  ...|___       |                          |
-     *  |  |    : : n |n-1|      |                          |
-     *  |  |____:_:___|   |      |                          |
-     *  |       | |_______|      |                          |
-     *  |       |             n  |                          |
-     *  |       |________________|                          |
-     *  |___________________________________________________|
-     *
-     * DONE (just cleanup left)
+     *    We draw our polygon where the stencil test passes
+     *    Where we draw we GL_REPLACE the stencil buffer with 1x0
      */
-#else
 
-    /*   ___________________________________________________
-     *  |   __________                                      |
-     *  |  |          |                             < n     |
-     *  |  | n        |                                     |
-     *  |  |      ....|....                                 |
-     *  |  |      : n |< n:                                 |
-     *  |  |______:___|   :                                 |
-     *  |         :.......: <-Hole we're about to mask      |
-     *  |                                                   |
-     *  |   Existing geometry on this layer is tagged "n"   |
-     *  |   Anywhere else, the stencil value is "< n"       |
-     *  |                                                   |
-     *  |___________________________________________________|
-     *
-     * NEXT: Mask out the holes:
-     *
-     *    The stencil test is "< n". It fails for any existing masked regions.
-     *    For these areas, (stencil fail), we GL_INCR-ement the stencil to
-     *    "n + 1". For other areas (stencil pass) we GL_REPLACE the stencil
-     *    with the test value, "n". We don't write holes to the colour buffer.
-     */
+//    glStencilFunc (GL_EQUAL, layer_stencil_bit, layer_stencil_bit | 1);
 
-    glPushAttrib (GL_COLOR_BUFFER_BIT);
-    glColorMask (0, 0, 0, 0);
 
-    glStencilOp (GL_INCR, GL_KEEP, GL_KEEP);
-    fill_contour (poly->Clipped->contours);
-    hidgl_flush_triangles (&buffer);
-
-    glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);
-    r_search (poly->Clipped->contour_tree, clip_box, NULL, do_hole, NULL);
-    hidgl_flush_triangles (&buffer);
-
-    glPopAttrib ();
-    /*   ___________________________________________________
-     *  |   __________                                      |
-     *  |  |    ......|...........                  < n     |
-     *  |  | n  : n+1 |          :                          |
-     *  |  |    :  ...|...       :                          |
-     *  |  |    : :n+1|   :      :                          |
-     *  |  |____:_:___| n :      :                          |
-     *  |       : :.......:      :                          |
-     *  |       :            < n :                          |
-     *  |       :................: <-Polygon outer          |
-     *  |___________________________________________________|
-     *
-     * NEXT: Draw the polygon:
-     *
-     *    We draw our polygon where the stencil test passes ("< n")
-     *    Where we draw we GL_REPLACE the stencil buffer with "n".
-     */
-
-    glStencilOp (GL_DECR, GL_KEEP, GL_REPLACE);
+    /* XXX: DAMN, The stencil op operates on the whole word, thus causing breakage */
+    glStencilOp (GL_DECR, GL_KEEP, GL_ZERO);
     fill_contour (poly->Clipped->contours);
     hidgl_flush_triangles (&buffer);
 
     /*   ___________________________________________________
      *  |   __________                                      |
-     *  |  |     .....|__________                           |
-     *  |  | n  :   n |          |                          |
+     *  |  |     .....|__________                      1x0  |
+     *  |  | 0x0: 0x0 |          |                          |
      *  |  |    :  ...|___       |                          |
-     *  |  |    : : n |n-1|      |                          |
+     *  |  |    : :0x0|1x0|      |                          |
      *  |  |____:_:___|   |      |                          |
      *  |       | |_______|      |                          |
-     *  |       |             n  |                          |
+     *  |       |           0x0  |                          |
      *  |       |________________|                          |
      *  |___________________________________________________|
      *
      * DONE (just cleanup left)
      */
-#endif
 
     /* Restore the stencil buffer setup */
     glPopAttrib ();
@@ -1139,7 +1048,7 @@ hidgl_clean_unassigned_stencil (void)
   CHECK_IS_IN_CONTEXT ();
   glPushAttrib (GL_STENCIL_BUFFER_BIT);
   glStencilMask (~assigned_bits);
-  glClearStencil (0);
+  glClearStencil (0xfe); /* Would have used ~1, but mesa is buggy */
   glClear (GL_STENCIL_BUFFER_BIT);
   glPopAttrib ();
   debug_stencil_clears++;
@@ -1160,7 +1069,7 @@ hidgl_assign_clear_stencil_bit (void)
     }
 
   /* Look for a bitplane we don't have to clear */
-  for (test = 1; test & stencil_bitmask; test <<= 1)
+  for (test = 2 /*<-- Don't assign the first bit, was: 1*/; test & stencil_bitmask; test <<= 1)
     {
       if (!(test & dirty_bits))
         {
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 8d08b9f..431cb84 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -151,7 +151,8 @@ compute_depth (int group)
   return depth;
 }
 
-static int stencil_value = 0;
+//static int stencil_value = 0;
+int layer_stencil_bit = 0;
 
 int
 ghid_set_layer (const char *name, int group, int empty)
@@ -178,18 +179,20 @@ ghid_set_layer (const char *name, int group, int empty)
   hidgl_set_depth (compute_depth (group));
 
   glEnable (GL_STENCIL_TEST);                   // Enable Stencil test
-  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);   // Stencil pass => replace stencil value (with 1)
-//  hidgl_return_stencil_bit (stencil_bit);       // Relinquish any bitplane we previously used
+  glStencilOp (GL_KEEP, GL_KEEP, GL_ZERO);   // Stencil pass => replace stencil value (with 1)
+  hidgl_return_stencil_bit (layer_stencil_bit);       // Relinquish any bitplane we previously used
+  layer_stencil_bit = 0;
   if (SL_TYPE (idx) != SL_FINISHED) {
-    // stencil_bit = hidgl_assign_clear_stencil_bit();       // Get a new (clean) bitplane to stencil with
-    stencil_value++;
-    if (stencil_value == 254)
-      printf ("STENCIL FUBAR\n");
-//    glStencilMask (stencil_bit);                // Only write to our subcompositing stencil bitplane
-    glStencilFunc(GL_GREATER, stencil_value, ~0);    // Pass stencil test if our counter is greater than the buffer value
+    layer_stencil_bit = hidgl_assign_clear_stencil_bit();       // Get a new (clean) bitplane to stencil with
+//    stencil_value++;
+//    if (stencil_value == 254)
+//      printf ("STENCIL FUBAR\n");
+    glStencilMask (layer_stencil_bit | 1);                // Only write to our subcompositing stencil bitplane
+    glStencilFunc(GL_EQUAL, layer_stencil_bit, layer_stencil_bit | 1);
+//    glStencilFunc(GL_GREATER, stencil_value, ~0);    // Pass stencil test if our counter is greater than the buffer value
   } else {
 //    stencil_bit = 0;
-//    glStencilMask (0);
+    glStencilMask (0);
     glStencilFunc (GL_ALWAYS, 0, 0);  // Always pass stencil test
   }
 
@@ -1914,15 +1917,16 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
     glNewList (display_list, GL_COMPILE);
 #endif
 
-  glEnable (GL_STENCIL_TEST);
+//  glEnable (GL_STENCIL_TEST);
+  glDisable (GL_STENCIL_TEST);
   glClearColor (port->bg_color.red / 65535.,
                 port->bg_color.green / 65535.,
                 port->bg_color.blue / 65535.,
                 1.);
   glStencilMask (~0);
-  glClearStencil (0);
+  glClearStencil (0xfe); /* Would have used ~1, but mesa is buggy */
   glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-  stencil_value = 0;
+//  stencil_value = 0;
   hidgl_reset_stencil_usage ();
 
   /* Disable the stencil test until we need it - otherwise it gets dirty */
@@ -2014,7 +2018,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   /* Setup stenciling */
   /* Drawing operations set the stencil buffer to '1' */
-  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value (with 1)
+  glStencilOp (GL_KEEP, GL_KEEP, GL_ZERO); // Stencil pass => replace stencil value (with 1)
   /* Drawing operations as masked to areas where the stencil buffer is '0' */
 //  glStencilFunc (GL_GREATER, 1, 1);             // Draw only where stencil buffer is 0

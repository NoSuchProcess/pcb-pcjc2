Bottom: 26e3016bf7f1a847bf73a4f31c2555ddbec37ddd
Top:    4dbfcdf0776d2c5d9fcde4c9992a2be1182c90a2
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2014-06-05 18:44:05 +0100

Refresh of more-play-with-quad-edge-data

---

diff --git a/src/hid/gtk/object3d.c b/src/hid/gtk/object3d.c
index ef1f4e7..b3fb750 100644
--- a/src/hid/gtk/object3d.c
+++ b/src/hid/gtk/object3d.c
@@ -892,3 +892,246 @@ object3d_test_board_outline (void)
   object3d_export_to_step (board_outline, "object3d_test.step");
   destroy_object3d (board_outline);
 }
+
+object3d *
+object3d_from_tracking (void)
+{
+  object3d *board_object;
+  appearance *board_appearance;
+  appearance *top_bot_appearance;
+  POLYAREA *outline;
+  PLINE *contour;
+  PLINE *ct;
+  int ncontours;
+  int npoints;
+  int i;
+  vertex3d **vertices;
+  edge_ref *edges;
+  face3d **faces;
+  int start_of_ct;
+  int offset_in_ct;
+  int ct_npoints;
+
+  outline = board_outline_poly (true);
+  //outline = board_outline_poly (false); /* (FOR NOW - just the outline, no holes) */
+  ncontours = 0;
+  npoints = 0;
+
+  /* XXX: There can be more than one contour, but for now we restrict ourselves to the first one */
+  contour = outline->contours;
+
+  ct = contour;
+  while (ct != NULL) {
+    ncontours ++;
+    npoints += get_contour_npoints (ct);
+    ct = ct->next;
+  }
+
+  /* We know how many edges and vertices we need now...
+   *
+   * let n = npoints
+   * bodies = 1             (FOR NOW - just the first board outline)
+   * vertices = 2n          (n-top, n-bottom)
+   * edges = 3n             (n-top, n-bottom, n-sides)
+   * faces = 2 + n          (1-top, 1-bottom, n-sides)
+   *
+   * holes = 0              (FOR NOW - just the outline, no holes)
+   * holes = ncontours - 1  (LATER)
+   */
+
+  board_object = make_object3d (PCB->Name);
+  board_appearance = make_appearance ();
+  top_bot_appearance = make_appearance ();
+  appearance_set_color (board_appearance,   1.0, 1.0, 0.6);
+  appearance_set_color (top_bot_appearance, 0.2, 0.8, 0.2);
+
+  object3d_set_appearance (board_object, board_appearance);
+
+  vertices = malloc (sizeof (vertex3d *) * 2 * npoints);
+  edges    = malloc (sizeof (edge_ref  ) * 3 * npoints);
+  faces    = malloc (sizeof (face3d *) * (2 + npoints));
+
+  /* Define the vertices */
+  ct = contour;
+  start_of_ct = 0;
+  offset_in_ct = 0;
+  ct_npoints = get_contour_npoints (ct);
+
+  for (i = 0; i < npoints; i++, offset_in_ct++) {
+    double x1, y1;
+
+    /* Update which contour we're looking at */
+    if (offset_in_ct == ct_npoints) {
+      offset_in_ct = 0;
+      ct = ct->next;
+      ct_npoints = get_contour_npoints (ct);
+    }
+
+    get_contour_coord_n_in_mm (ct, offset_in_ct, &x1, &y1);
+    vertices[i]           = make_vertex3d (x1, y1, -COORD_TO_MM (HACK_BOARD_THICKNESS)); /* Bottom */
+    vertices[npoints + i] = make_vertex3d (x1, y1, 0);                                   /* Top */
+
+    object3d_add_vertex (board_object, vertices[i]);
+    object3d_add_vertex (board_object, vertices[npoints + i]);
+  }
+
+  /* Define the edges */
+  for (i = 0; i < 3 * npoints; i++) {
+    edges[i] = make_edge ();
+    object3d_add_edge (board_object, edges[i]);
+  }
+
+  /* Define the faces */
+  for (i = 0; i < npoints; i++) {
+    faces[i] = make_face3d ();
+
+    object3d_add_face (board_object, faces[i]);
+    /* Pick one of the upright edges which is within this face outer contour loop, and link it to the face */
+    face3d_add_contour (faces[i], make_contour3d (SYM(edges[2 * npoints + i])));
+  }
+
+  faces[npoints] = make_face3d (); /* bottom_face */
+  faces[npoints]->nx =  0.;
+  faces[npoints]->ny =  0.;
+  faces[npoints]->nz = -1.;
+  face3d_set_appearance (faces[npoints], top_bot_appearance);
+  object3d_add_face (board_object, faces[npoints]);
+
+  faces[npoints + 1] = make_face3d (); /* top_face */
+  faces[npoints + 1]->nx = 0.;
+  faces[npoints + 1]->ny = 0.;
+  faces[npoints + 1]->nz = 1.;
+  face3d_set_appearance (faces[npoints + 1], top_bot_appearance);
+  object3d_add_face (board_object, faces[npoints + 1]);
+
+  /* Pick the first bottom / top edge within the bottom / top face outer contour loop, and link it to the face */
+  face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[0])));
+  face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints]));
+
+  ct = contour;
+  start_of_ct = 0;
+  offset_in_ct = 0;
+  ct_npoints = get_contour_npoints (ct);
+
+  for (i = 0; i < npoints; i++, offset_in_ct++) {
+    int next_i_around_ct;
+    int prev_i_around_ct;
+
+    /* Update which contour we're looking at */
+    if (offset_in_ct == ct_npoints) {
+      start_of_ct = i;
+      printf ("start_of_ct = %i\n", start_of_ct);
+      offset_in_ct = 0;
+      ct = ct->next;
+      ct_npoints = get_contour_npoints (ct);
+
+      /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
+      face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[i])));
+      face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints + i]));
+    }
+
+    next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
+    prev_i_around_ct = start_of_ct + (offset_in_ct + ct_npoints - 1) % ct_npoints;
+
+    /* Setup the face normals for the edges along the contour extrusion (top and bottom are handled separaetely) */
+    /* Define the (non-normalized) face normal to point to the outside of the contour */
+    faces[i]->nx = vertices[next_i_around_ct]->y - vertices[i]->y;
+    faces[i]->ny = vertices[i]->x - vertices[next_i_around_ct]->x;
+    faces[i]->nz = 0.;
+
+    /* Assign the appropriate vertex geometric data to each edge end */
+    ODATA (edges[              i]) = vertices[0 * npoints + i];
+    DDATA (edges[              i]) = vertices[0 * npoints + next_i_around_ct];
+    ODATA (edges[1 * npoints + i]) = vertices[1 * npoints + i];
+    DDATA (edges[1 * npoints + i]) = vertices[1 * npoints + next_i_around_ct];
+    ODATA (edges[2 * npoints + i]) = vertices[0 * npoints + i];
+    DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
+    LDATA (edges[              i]) = faces[i];
+    RDATA (edges[              i]) = faces[npoints];
+    LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
+    RDATA (edges[1 * npoints + i]) = faces[i];
+    LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
+    RDATA (edges[2 * npoints + i]) = faces[i];
+
+    /* NB: Contours are counter clockwise in XY plane.
+     *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
+     *     edges[1*npoints-2*npoints-1] are the top  of the extrusion, following in the counter clockwise order
+     *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
+     */
+
+#if 0
+    /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+    splice (edges[i], edges[npoints + i]);                         /* XXX: ???? */
+    splice (edges[npoints + i], SYM(edges[next_i_around_ct]));     /* XXX: ???? */
+
+    /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+    splice (edges[npoints + i], SYM(edges[npoints + next_i_around_ct]));
+    splice (SYM(edges[npoints + next_i_around_ct]), SYM(edges[2 * npoints + i]));
+#endif
+
+#if 1
+    /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+    splice (edges[i], edges[2 * npoints + i]);
+    splice (edges[2 * npoints + i], SYM(edges[prev_i_around_ct]));
+
+    /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+    splice (SYM(edges[2 * npoints + i]), edges[npoints + i]);
+    splice (edges[npoints + i], SYM(edges[npoints + prev_i_around_ct]));
+#endif
+
+    /* XXX: TOPOLOGY WILL BE OK, MAY NEED MORE INFO FOR GEOMETRY */
+    /* XXX: DO WE NEED TO ASSIGN EXTRA INFORMATION TO CIRCULAR EDGES FOR RENDERING / EXPORT??? */
+    if (ct->is_round) {
+      faces[i]->is_cylindrical = true;
+      faces[i]->cx = COORD_TO_MM (ct->cx);
+      faces[i]->cy = COORD_TO_MM (ct->cy);
+      faces[i]->cz = 0.;
+      faces[i]->ax = 0.;
+      faces[i]->ay = 0.;
+      faces[i]->az = 1.;
+      /* XXX: Could line this up with the direction to the vertex in the corresponding circle edge */
+      faces[i]->nx = 1.;
+      faces[i]->ny = 0.;
+      faces[i]->nz = 0.;
+      faces[i]->radius = COORD_TO_MM (ct->radius);
+      UNDIR_DATA (edges[0 * npoints + i]) =
+        make_edge_info (false /* Stitch? */, true, /* Circular */
+                        COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), -COORD_TO_MM (HACK_BOARD_THICKNESS), /* Center of circle */
+                        0., 0., 1., /* Normal */
+                        COORD_TO_MM (ct->radius)); /* Radius */
+
+      UNDIR_DATA (edges[1 * npoints + i]) =
+        make_edge_info (false /* Stitch? */, true, /* Circular */
+                        COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* Center of circle */
+                        0., 0., -1., /* Normal */
+                        COORD_TO_MM (ct->radius)); /* Radius */
+
+      UNDIR_DATA (edges[2 * npoints + i]) =
+        make_edge_info (true /* Stitch? */, false, /* Circular */
+                        0., 0., 0., /* No point in defining an cylinder axis center for the stitch edge */
+                        0., 0., 0., /* No point in defining a normal for the stitch edge - it has no meaning */
+                        0.);        /* No point in defining a cylinder radius for the stitch edge */
+    } else {
+      UNDIR_DATA (edges[0 * npoints + i]) =
+        make_edge_info (false /* Stitch? */, false, /* Circular */
+                        0., 0., 0., /* No point in defining an cylinder axis center for the stitch edge */
+                        0., 0., 0., /* No point in defining a normal for the stitch edge - it has no meaning */
+                        0.);        /* No point in defining a cylinder radius for the stitch edge */
+      UNDIR_DATA (edges[1 * npoints + i]) =
+        make_edge_info (false /* Stitch? */, false, /* Circular */
+                        0., 0., 0., /* No point in defining an cylinder axis center for the stitch edge */
+                        0., 0., 0., /* No point in defining a normal for the stitch edge - it has no meaning */
+                        0.);        /* No point in defining a cylinder radius for the stitch edge */
+      UNDIR_DATA (edges[2 * npoints + i]) =
+        make_edge_info (false /* Stitch? */, false, /* Circular */
+                        0., 0., 0., /* No point in defining an cylinder axis center for the stitch edge */
+                        0., 0., 0., /* No point in defining a normal for the stitch edge - it has no meaning */
+                        0.);        /* No point in defining a cylinder radius for the stitch edge */
+    }
+
+  }
+
+  poly_Free (&outline);
+
+  return board_object;
+}

Bottom: d22154425d3f1cbf6ee9d33b9ac41249777bd0bc
Top:    d5c89b3d7dfd8376e8c43be81788396834b88421
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-08-19 15:05:01 +0100

Refresh of wow-testing

---

diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index a56b56b..fdbce08 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -208,10 +208,11 @@ ghid_draw_grid (void)
   Coord x1, y1, x2, y2, x, y;
   int n, i;
   render_priv *priv = gport->render_priv;
+  return;
 
   if (!Settings.DrawGrid)
     return;
-  if (Vz (PCB->Grid) < MIN_GRID_DISTANCE)
+  if (SCREEN_R (PCB->Grid) < MIN_GRID_DISTANCE)
     return;
   if (!priv->grid_gc)
     {
@@ -246,13 +247,13 @@ ghid_draw_grid (void)
       y1 = y2;
       y2 = tmp;
     }
-  if (Vx (x1) < 0)
+  if (SCREEN_X (x1) < 0)
     x1 += PCB->Grid;
-  if (Vy (y1) < 0)
+  if (SCREEN_Y (y1) < 0)
     y1 += PCB->Grid;
-  if (Vx (x2) >= gport->width)
+  if (SCREEN_X (x2) >= gport->width)
     x2 -= PCB->Grid;
-  if (Vy (y2) >= gport->height)
+  if (SCREEN_Y (y2) >= gport->height)
     y2 -= PCB->Grid;
   n = (x2 - x1) / PCB->Grid + 1;
   if (n > npoints)
@@ -263,15 +264,16 @@ ghid_draw_grid (void)
   n = 0;
   for (x = x1; x <= x2; x += PCB->Grid)
     {
-      points[n].x = Vx (x);
+      points[n].x = SCREEN_X (x);
       n++;
     }
   if (n == 0)
     return;
   for (y = y1; y <= y2; y += PCB->Grid)
     {
+      int vy = SCREEN_Y (y);
       for (i = 0; i < n; i++)
-	points[i].y = Vy (y);
+	points[i].y = vy;
       gdk_draw_points (gport->drawable, priv->grid_gc, points, n);
     }
 }
@@ -513,7 +515,7 @@ ghid_set_line_cap (hidGC gc, EndCapStyle style)
     }
   if (gc->gc)
     gdk_gc_set_line_attributes (WHICH_GC (gc),
-				Vz (gc->width), GDK_LINE_SOLID,
+				SCREEN_R (gc->width), GDK_LINE_SOLID,
 				(GdkCapStyle)gc->cap, (GdkJoinStyle)gc->join);
 }
 
@@ -525,7 +527,7 @@ ghid_set_line_width (hidGC gc, Coord width)
   gc->width = width;
   if (gc->gc)
     gdk_gc_set_line_attributes (WHICH_GC (gc),
-				Vz (gc->width), GDK_LINE_SOLID,
+				SCREEN_R (gc->width), GDK_LINE_SOLID,
 				(GdkCapStyle)gc->cap, (GdkJoinStyle)gc->join);
 }
 
@@ -579,10 +581,10 @@ ghid_draw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
   double dx1, dy1, dx2, dy2;
   render_priv *priv = gport->render_priv;
 
-  dx1 = Vx ((double) x1);
-  dy1 = Vy ((double) y1);
-  dx2 = Vx ((double) x2);
-  dy2 = Vy ((double) y2);
+  dx1 = SCREEN_X ((double) x1);
+  dy1 = SCREEN_Y ((double) y1);
+  dx2 = SCREEN_X ((double) x2);
+  dy2 = SCREEN_Y ((double) y2);
 
   if (!ClipLine (0, 0, gport->width, gport->height,
 		 &dx1, &dy1, &dx2, &dy2, gc->width / priv->view.coords_per_px))
@@ -603,15 +605,17 @@ ghid_draw_arc (hidGC gc, Coord cx, Coord cy,
   w = gport->width  * priv->view.coords_per_px;
   h = gport->height * priv->view.coords_per_px;
   radius = (xradius > yradius) ? xradius : yradius;
+#if 0
   if (SIDE_X (cx) < gport->view_x0 - radius
       || SIDE_X (cx) > gport->view_x0 + w + radius
       || SIDE_Y (cy) < gport->view_y0 - radius
       || SIDE_Y (cy) > gport->view_y0 + h + radius)
     return;
+#endif
 
   USE_GC (gc);
-  vrx = Vz (xradius);
-  vry = Vz (yradius);
+  vrx = SCREEN_R (xradius);
+  vry = SCREEN_R (yradius);
 
   if (priv->view.flip_x)
     {
@@ -628,7 +632,7 @@ ghid_draw_arc (hidGC gc, Coord cx, Coord cy,
   if (start_angle >= 180)  start_angle -= 360;
 
   gdk_draw_arc (gport->drawable, priv->u_gc, 0,
-		Vx (cx) - vrx, Vy (cy) - vry,
+		SCREEN_X (cx) - vrx, SCREEN_Y (cy) - vry,
 		vrx * 2, vry * 2, (start_angle + 180) * 64, delta_angle * 64);
 }
 
@@ -642,6 +646,7 @@ ghid_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
   w = gport->width  * priv->view.coords_per_px;
   h = gport->height * priv->view.coords_per_px;
 
+#if 0
   if ((SIDE_X (x1) < gport->view_x0 - lw
        && SIDE_X (x2) < gport->view_x0 - lw)
       || (SIDE_X (x1) > gport->view_x0 + w + lw
@@ -651,11 +656,12 @@ ghid_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
       || (SIDE_Y (y1) > gport->view_y0 + h + lw
 	  && SIDE_Y (y2) > gport->view_y0 + h + lw))
     return;
+#endif
 
-  x1 = Vx (x1);
-  y1 = Vy (y1);
-  x2 = Vx (x2);
-  y2 = Vy (y2);
+  x1 = SCREEN_X (x1);
+  y1 = SCREEN_Y (y1);
+  x2 = SCREEN_X (x2);
+  y2 = SCREEN_Y (y2);
 
   if (x1 > x2)
     {
@@ -682,18 +688,25 @@ ghid_fill_circle (hidGC gc, Coord cx, Coord cy, Coord radius)
   gint w, h, vr;
   render_priv *priv = gport->render_priv;
 
+<<<<<<< current
   w = gport->width  * priv->view.coords_per_px;
   h = gport->height * priv->view.coords_per_px;
+=======
+  w = gport->width * gport->zoom;
+  h = gport->height * gport->zoom;
+#if 0
+>>>>>>> patched
   if (SIDE_X (cx) < gport->view_x0 - radius
       || SIDE_X (cx) > gport->view_x0 + w + radius
       || SIDE_Y (cy) < gport->view_y0 - radius
       || SIDE_Y (cy) > gport->view_y0 + h + radius)
     return;
+#endif
 
   USE_GC (gc);
-  vr = Vz (radius);
+  vr = SCREEN_R (radius);
   gdk_draw_arc (gport->drawable, priv->u_gc, TRUE,
-		Vx (cx) - vr, Vy (cy) - vr, vr * 2, vr * 2, 0, 360 * 64);
+		SCREEN_X (cx) - vr, SCREEN_Y (cy) - vr, vr * 2, vr * 2, 0, 360 * 64);
 }
 
 void
@@ -712,8 +725,8 @@ ghid_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
     }
   for (i = 0; i < n_coords; i++)
     {
-      points[i].x = Vx (x[i]);
-      points[i].y = Vy (y[i]);
+      points[i].x = SCREEN_X (x[i]);
+      points[i].y = SCREEN_Y (y[i]);
     }
   gdk_draw_polygon (gport->drawable, priv->u_gc, 1, points, n_coords);
 }
@@ -728,6 +741,7 @@ ghid_fill_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
   w = gport->width  * priv->view.coords_per_px;
   h = gport->height * priv->view.coords_per_px;
 
+#if 0
   if ((SIDE_X (x1) < gport->view_x0 - lw
        && SIDE_X (x2) < gport->view_x0 - lw)
       || (SIDE_X (x1) > gport->view_x0 + w + lw
@@ -737,11 +751,12 @@ ghid_fill_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
       || (SIDE_Y (y1) > gport->view_y0 + h + lw
 	  && SIDE_Y (y2) > gport->view_y0 + h + lw))
     return;
+#endif
 
-  x1 = Vx (x1);
-  y1 = Vy (y1);
-  x2 = Vx (x2);
-  y2 = Vy (y2);
+  x1 = SCREEN_X (x1);
+  y1 = SCREEN_Y (y1);
+  x2 = SCREEN_X (x2);
+  y2 = SCREEN_Y (y2);
   if (x2 < x1)
     {
       xx = x1;
@@ -788,19 +803,15 @@ redraw_region (GdkRectangle *rect)
   set_clip (priv, priv->mask_gc);
   set_clip (priv, priv->grid_gc);
 
-  region.X1 = MIN(Px(priv->clip_rect.x),
-                  Px(priv->clip_rect.x + priv->clip_rect.width + 1));
-  region.Y1 = MIN(Py(priv->clip_rect.y),
-                  Py(priv->clip_rect.y + priv->clip_rect.height + 1));
-  region.X2 = MAX(Px(priv->clip_rect.x),
-                  Px(priv->clip_rect.x + priv->clip_rect.width + 1));
-  region.Y2 = MAX(Py(priv->clip_rect.y),
-                  Py(priv->clip_rect.y + priv->clip_rect.height + 1));
-
-  eleft = Vx (0);
-  eright = Vx (PCB->MaxWidth);
-  etop = Vy (0);
-  ebottom = Vy (PCB->MaxHeight);
+  region.X1 = MIN (PCB_X (0), PCB_X (gport->width  + 1));
+  region.Y1 = MIN (PCB_Y (0), PCB_Y (gport->height + 1));
+  region.X2 = MAX (PCB_X (0), PCB_X (gport->width  + 1));
+  region.Y2 = MAX (PCB_Y (0), PCB_Y (gport->height + 1));
+
+  eleft =   SCREEN_X (0);
+  eright =  SCREEN_X (PCB->MaxWidth);
+  etop =    SCREEN_Y (0);
+  ebottom = SCREEN_Y (PCB->MaxHeight);
   if (eleft > eright)
     {
       int tmp = eleft;
@@ -1089,8 +1100,8 @@ show_crosshair (gboolean paint_new_location)
       /* FIXME: when CrossColor changed from config */
       ghid_map_color_string (Settings.CrossColor, &cross_color);
     }
-  x = DRAW_X (gport->crosshair_x);
-  y = DRAW_Y (gport->crosshair_y);
+  x = SCREEN_X (gport->crosshair_x);
+  y = SCREEN_Y (gport->crosshair_y);
 
   gdk_gc_set_foreground (xor_gc, &cross_color);
 
@@ -1347,10 +1358,10 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   gdk_draw_rectangle (pixmap, priv->bg_gc, TRUE, 0, 0, width, height);
 
   /* call the drawing routine */
-  region.X1 = MIN(Px(0), Px(gport->width + 1));
-  region.Y1 = MIN(Py(0), Py(gport->height + 1));
-  region.X2 = MAX(Px(0), Px(gport->width + 1));
-  region.Y2 = MAX(Py(0), Py(gport->height + 1));
+  region.X1 = MIN (PCB_X (0), PCB_X (gport->width  + 1));
+  region.Y1 = MIN (PCB_Y (0), PCB_Y (gport->height + 1));
+  region.X2 = MAX (PCB_X (0), PCB_X (gport->width  + 1));
+  region.Y2 = MAX (PCB_Y (0), PCB_Y (gport->height + 1));
   hid_expose_callback (&ghid_hid, &region, NULL);
 
   gport->drawable = save_drawable;
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 5f66336..1fa6bec 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -1022,10 +1022,10 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glStencilMask (0);
   glStencilFunc (GL_ALWAYS, 0, 0);
 
-  region.X1 = MIN (Px (ev->area.x), Px (ev->area.x + ev->area.width + 1));
-  region.X2 = MAX (Px (ev->area.x), Px (ev->area.x + ev->area.width + 1));
-  region.Y1 = MIN (Py (ev->area.y), Py (ev->area.y + ev->area.height + 1));
-  region.Y2 = MAX (Py (ev->area.y), Py (ev->area.y + ev->area.height + 1));
+  region.X1 = MIN (PCB_X (ev->area.x), PCB_X (ev->area.x + ev->area.width  + 1));
+  region.Y1 = MIN (PCB_Y (ev->area.y), PCB_Y (ev->area.y + ev->area.height + 1));
+  region.X2 = MAX (PCB_X (ev->area.x), PCB_X (ev->area.x + ev->area.width  + 1));
+  region.Y2 = MAX (PCB_Y (ev->area.y), PCB_Y (ev->area.y + ev->area.height + 1));
 
   glColor3f (port->bg_color.red / 65535.,
              port->bg_color.green / 65535.,
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index 8a87a80..b088641 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -633,8 +633,8 @@ ghid_port_window_leave_cb (GtkWidget * widget,
 	  w = ghid_port.width * gport->zoom;
 	  h = ghid_port.height * gport->zoom;
 
-	  x0 = EVENT_TO_PCB_X (0);
-	  y0 = EVENT_TO_PCB_Y (0);
+	  x0 = PCB_X (0);
+	  y0 = PCB_Y (0);
 	  ghid_get_coords (NULL, &x, &y);
 	  x -= x0;
 	  y -= y0;
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index e6c54d5..5f7318b 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -496,8 +496,6 @@ void ghid_get_coords (const char *msg, Coord *x, Coord *y);
 gint PCBChanged (int argc, char **argv, Coord x, Coord y);
 
 
-
-
 extern GdkPixmap *XC_hand_source, *XC_hand_mask;
 extern GdkPixmap *XC_lock_source, *XC_lock_mask;
 extern GdkPixmap *XC_clock_source, *XC_clock_mask;

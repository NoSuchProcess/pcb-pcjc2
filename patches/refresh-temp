Bottom: 9a45cdd78618295ca88a292b3f5ebf5cf3c95a95
Top:    a2da3092dff5a558f1151838c95aa0cd116321ae
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-07-24 22:06:11 +0100

Refresh of hid-gtk-separate-out-board-fli

---

diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 5ddd8e4..432588f 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -1325,14 +1325,51 @@ ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y)
 }
 
 bool
-ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *screen_y)
+ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y)
 {
+  render_priv *priv = gport->render_priv;
+
   *event_x = DRAW_X (pcb_x);
   *event_y = DRAW_Y (pcb_y);
 
   return true;
 }
 
+void
+ghid_pan_view_abs (Coord pcb_x, Coord pcb_y, int widget_x, int widget_y)
+{
+  render_priv *priv = gport->render_priv;
+
+  gport->view_x0 = MAX (0, SIDE_X (pcb_x) - widget_x * gport->zoom);
+  gport->view_y0 = MAX (0, SIDE_Y (pcb_y) - widget_y * gport->zoom);
+
+  /* don't pan so far to the right that we see way past the right edge of the
+   * board, or so far down that we see way past the bottom edge of the board.
+   */
+  gport->view_x0 = MIN (gport->view_x0, PCB->MaxWidth  - gport->view_width);
+  gport->view_y0 = MIN (gport->view_y0, PCB->MaxHeight - gport->view_height);
+
+  /* don't view above or to the left of the board... ever */
+  gport->view_x0 = MAX (0, gport->view_x0);
+  gport->view_y0 = MAX (0, gport->view_y0);
+
+  /* if we can see the entire board and some, then zoom to fit */
+  if (gport->view_width  > PCB->MaxWidth  &&
+      gport->view_height > PCB->MaxHeight)
+    {
+      ghid_zoom_view_fit ();
+      return;
+    }
+
+  ghidgui->adjustment_changed_holdoff = TRUE;
+  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view_x0);
+  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view_y0);
+  ghidgui->adjustment_changed_holdoff = FALSE;
+
+  ghid_port_ranges_changed();
+}
+
+
 /* gport->zoom:
  * zoom value is PCB units per screen pixel.  Larger numbers mean zooming
  * out - the largest value means you are looking at the whole board.
@@ -1399,5 +1436,7 @@ ghid_flip_view (Coord center_x, Coord center_y, bool flip_x, bool flip_y)
   priv->view.flip_x = flip_x ? ! priv->view.flip_x : priv->view.flip_x;
   priv->view.flip_y = flip_y ? ! priv->view.flip_y : priv->view.flip_y;
 
+  /* XXX: PAN THE BOARD SO THE CENTER LOCATION REMAINS IN THE SAME PLACE */
+
   ghid_invalidate_all ();
 }
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index ee6137d..c106690 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -29,47 +29,6 @@
 RCSID ("$Id$");
 
 
-void
-ghid_pan_fixup ()
-{
-
-  /*
-   * don't pan so far to the right that we see way past the right 
-   * edge of the board.
-   */
-  if (gport->view_x0 > PCB->MaxWidth - gport->view_width)
-    gport->view_x0 = PCB->MaxWidth - gport->view_width;
-
-  /*
-   * don't pan so far down that we see way past the bottom edge of
-   * the board.
-   */
-  if (gport->view_y0 > PCB->MaxHeight - gport->view_height)
-    gport->view_y0 = PCB->MaxHeight - gport->view_height;
-
-  /* don't view above or to the left of the board... ever */
-  if (gport->view_x0 < 0)
-    gport->view_x0 = 0;
-
-   if (gport->view_y0 < 0)
-    gport->view_y0 = 0;
-
-  /* if we can see the entire board and some, then zoom to fit */
-  if (gport->view_width > PCB->MaxWidth &&
-      gport->view_height > PCB->MaxHeight)
-    {
-      ghid_zoom_view_fit ();
-      return;
-    }
-
-  ghidgui->adjustment_changed_holdoff = TRUE;
-  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view_x0);
-  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view_y0);
-  ghidgui->adjustment_changed_holdoff = FALSE;
-
-  ghid_port_ranges_changed();
-}
-
 /* ------------------------------------------------------------ */
 
 static const char zoom_syntax[] =
@@ -266,8 +225,6 @@ ghid_set_crosshair (int x, int y, int action)
       ghid_event_to_pcb_coords (widget_x, widget_y, &pcb_x, &pcb_y);
       ghid_pan_view_abs (pcb_x, pcb_y, widget_x, widget_y);
 
-      ghid_pan_fixup (); /* XXX: ??? */
-
       /* Just in case we couldn't pan the board the whole way,
        * we warp the pointer to where the crosshair DID land.
        */
@@ -1510,8 +1467,6 @@ Center(int argc, char **argv, int x, int y)
 
   ghid_pan_view_abs (x, y, widget_x, widget_y);
 
-  ghid_pan_fixup (); /* XXX: ???? */
-
   /* Now move the mouse pointer to the place where the board location
    * actually ended up.
    *
diff --git a/src/hid/gtk/gui-netlist-window.c b/src/hid/gtk/gui-netlist-window.c
index f49733e..27aaf1f 100644
--- a/src/hid/gtk/gui-netlist-window.c
+++ b/src/hid/gtk/gui-netlist-window.c
@@ -221,7 +221,6 @@ node_selection_changed_cb (GtkTreeSelection * selection, gpointer data)
   LibraryMenuType *node_net;
   LibraryEntryType *node;
   static gchar *node_name;
-	gint		x0, y0, margin;
 
   if (selection_holdoff)	/* PCB is highlighting, user is not selecting */
     return;
@@ -264,7 +263,6 @@ node_selection_changed_cb (GtkTreeSelection * selection, gpointer data)
    */
   SelectPin (node, TRUE);
   IncrementUndoSerialNumber ();
-  margin = gport->view_width / 20;
 
   ghid_screen_update();
 }
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index bc47214..7e3891d 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -52,7 +52,7 @@
 
 #define TOOLTIP_UPDATE_DELAY 200
 
-static gint x_pan_speed, y_pan_speed;
+// static gint x_pan_speed, y_pan_speed;
 void
 ghid_port_ranges_changed (void)
 {
@@ -647,6 +647,7 @@ ghid_port_window_enter_cb (GtkWidget * widget,
   return FALSE;
 }
 
+#if 0
 static gboolean
 ghid_pan_idle_cb (gpointer data)
 {
@@ -658,12 +659,13 @@ ghid_pan_idle_cb (gpointer data)
   dx = gport->zoom * x_pan_speed;
   return (ghid_port_ranges_pan (dx, dy, TRUE));
 }
+#endif
 
 gint
 ghid_port_window_leave_cb (GtkWidget * widget, 
                            GdkEventCrossing * ev, GHidPort * out)
 {
-  gint x0, y0, x, y, dx, dy, w, h;
+  // gint x0, y0, x, y, dx, dy, w, h;
   
   /* printf("leave mode: %d detail: %d\n", ev->mode, ev->detail); */
 
@@ -679,6 +681,7 @@ ghid_port_window_leave_cb (GtkWidget * widget,
       return FALSE;
     }
 
+#if 0
   if(out->has_entered && !ghidgui->in_popup)
     {
       /* if actively drawing, start scrolling */
@@ -734,6 +737,7 @@ ghid_port_window_leave_cb (GtkWidget * widget,
 	  g_idle_add (ghid_pan_idle_cb, NULL);
 	}
     }
+#endif
 
   out->has_entered = FALSE;
 
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index db0db99..96a8662 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -508,7 +508,6 @@ void ghid_zoom_view_fit (void);
 void ghid_flip_view (Coord center_x, Coord center_y, bool flip_x, bool flip_y);
 
 /* gtkhid-main.c */
-void ghid_pan_fixup (void);
 void ghid_get_coords (const char *msg, int *x, int *y);
 gint PCBChanged (int argc, char **argv, int x, int y);

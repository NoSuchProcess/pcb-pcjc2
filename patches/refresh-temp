Bottom: 69d15294161e589ef106168550b5028b765dda01
Top:    da7843db838c2f9a5a09e97719b5b3e5985e69cb
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2014-06-08 12:26:44 +0100

Refresh of well-on-the-way-to-completely

---

diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index eb163eb..8075ccc 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -1133,6 +1133,8 @@ ghid_screen_update (void)
 void
 ghid_set_lock_effects (hidGC gc, AnyObjectType *object)
 {
+  return;
+
   /* Only apply effects to locked objects when in "lock" mode */
   if (Settings.Mode == LOCK_MODE &&
       TEST_FLAG (LOCKFLAG, object))
diff --git a/src/hid/gtk/object3d.c b/src/hid/gtk/object3d.c
index a79d255..80d4b85 100644
--- a/src/hid/gtk/object3d.c
+++ b/src/hid/gtk/object3d.c
@@ -17,6 +17,14 @@
 #include "data.h"
 
 
+#define EPSILON 1e-5 /* XXX: Unknown  what this needs to be */
+#define COORD_TO_STEP_X(pcb, x) (COORD_TO_MM(                   (x)))
+#define COORD_TO_STEP_Y(pcb, y) (COORD_TO_MM((pcb)->MaxHeight - (y)))
+#define COORD_TO_STEP_Z(pcb, z) (COORD_TO_MM(                   (z)))
+
+#define STEP_X_TO_COORD(pcb, x) (MM_TO_COORD((x)))
+#define STEP_Y_TO_COORD(pcb, y) ((pcb)->MaxHeight - MM_TO_COORD((y)))
+#define STEP_Z_TO_COORD(pcb, z) (MM_TO_COORD((z)))
 
 #ifndef WIN32
 /* The Linux OpenGL ABI 1.0 spec requires that we define
@@ -129,12 +137,12 @@ draw_quad_edge (edge_ref e, void *data)
       glBegin (GL_LINES);
       for (i = 0; i < CIRC_SEGS; i++) {
         /* XXX: THIS ASSUMES THE CIRCLE LIES IN THE X-Y PLANE */
-        glVertex3f (MM_TO_COORD (info->cx + info->radius * cos (i * 2. * M_PI / (float)CIRC_SEGS)),
-                    MM_TO_COORD (info->cy + info->radius * sin (i * 2. * M_PI / (float)CIRC_SEGS)),
-                    MM_TO_COORD (info->cz));
-        glVertex3f (MM_TO_COORD (info->cx + info->radius * cos ((i + 1) * 2. * M_PI / (float)CIRC_SEGS)),
-                    MM_TO_COORD (info->cy + info->radius * sin ((i + 1) * 2. * M_PI / (float)CIRC_SEGS)),
-                    MM_TO_COORD (info->cz));
+        glVertex3f (STEP_X_TO_COORD (PCB, info->cx + info->radius * cos (i * 2. * M_PI / (float)CIRC_SEGS)),
+                    STEP_Y_TO_COORD (PCB, info->cy + info->radius * sin (i * 2. * M_PI / (float)CIRC_SEGS)),
+                    STEP_Z_TO_COORD (PCB, info->cz));
+        glVertex3f (STEP_X_TO_COORD (PCB, info->cx + info->radius * cos ((i + 1) * 2. * M_PI / (float)CIRC_SEGS)),
+                    STEP_Y_TO_COORD (PCB, info->cy + info->radius * sin ((i + 1) * 2. * M_PI / (float)CIRC_SEGS)),
+                    STEP_Z_TO_COORD (PCB, info->cz));
       }
       glEnd ();
       return;
@@ -142,8 +150,12 @@ draw_quad_edge (edge_ref e, void *data)
   }
 
   glBegin (GL_LINES);
-  glVertex3f (MM_TO_COORD (((vertex3d *)ODATA(e))->x), MM_TO_COORD (((vertex3d *)ODATA(e))->y), MM_TO_COORD (((vertex3d *)ODATA(e))->z));
-  glVertex3f (MM_TO_COORD (((vertex3d *)DDATA(e))->x), MM_TO_COORD (((vertex3d *)DDATA(e))->y), MM_TO_COORD (((vertex3d *)DDATA(e))->z));
+  glVertex3f (STEP_X_TO_COORD (PCB, ((vertex3d *)ODATA(e))->x),
+              STEP_Y_TO_COORD (PCB, ((vertex3d *)ODATA(e))->y),
+              STEP_X_TO_COORD (PCB, ((vertex3d *)ODATA(e))->z));
+  glVertex3f (STEP_X_TO_COORD (PCB, ((vertex3d *)DDATA(e))->x),
+              STEP_Y_TO_COORD (PCB, ((vertex3d *)DDATA(e))->y),
+              STEP_X_TO_COORD (PCB, ((vertex3d *)DDATA(e))->z));
   glEnd ();
 }
 
@@ -175,7 +187,7 @@ get_contour_npoints (PLINE *contour)
 }
 
 static void
-get_contour_coord_n_in_mm (PLINE *contour, int n, double *x, double *y)
+get_contour_coord_n_in_step_mm (PLINE *contour, int n, double *x, double *y)
 {
   VNODE *vertex = &contour->head;
 
@@ -187,8 +199,8 @@ get_contour_coord_n_in_mm (PLINE *contour, int n, double *x, double *y)
        * to define a coordinate system along the contour, and coincides with where
        * we add a straight edge down the side of an extruded cylindrical shape.
        */
-      *x = COORD_TO_MM (contour->cx - contour->radius);
-      *y = COORD_TO_MM (contour->cy); /* FIXME: PCB's coordinate system has y increasing downwards */
+      *x = COORD_TO_STEP_X (PCB, contour->cx - contour->radius);
+      *y = COORD_TO_STEP_Y (PCB, contour->cy);
 
       return;
     }
@@ -198,8 +210,8 @@ get_contour_coord_n_in_mm (PLINE *contour, int n, double *x, double *y)
     n--;
   }
 
-  *x = COORD_TO_MM (vertex->point[0]);
-  *y = COORD_TO_MM (vertex->point[1]); /* FIXME: PCB's coordinate system has y increasing downwards */
+  *x = COORD_TO_STEP_X (PCB, vertex->point[0]);
+  *y = COORD_TO_STEP_Y (PCB, vertex->point[1]);
 }
 
 static step_id_list
@@ -322,6 +334,19 @@ object3d_export_to_step (object3d *object, char *filename)
       vertex3d *ov = ODATA (outer_contour->first_edge);
       vertex3d *dv = DDATA (outer_contour->first_edge);
 
+      float rx, ry, rz;
+
+      rx = dv->x - ov->x;
+      ry = dv->y - ov->y;
+      rz = dv->z - ov->z;
+
+      /* Catch the circular face case where the start and end vertices are identical */
+      if (rx < EPSILON && -rx < EPSILON &&
+          ry < EPSILON && -ry < EPSILON &&
+          rz < EPSILON && -rz < EPSILON) {
+        rx = 1., ry = 0., rz = 0.;
+      }
+
       face->surface_identifier =
         step_plane (step, "NONE",
                     step_axis2_placement_3d (step, "NONE",
@@ -329,9 +354,9 @@ object3d_export_to_step (object3d *object, char *filename)
                                                                                  ov->y,      /* Set this to the origin vertex of the first edge */
                                                                                  ov->z),     /* this contour links to in the quad edge structure. */
                                                    step_direction (step, "NONE", face->nx, face->ny, face->nz), /* An axis direction normal to the the face - Gives z-axis */
-                                                   step_direction (step, "NONE", dv->x - ov->x,     /* Reference x-axis, orthogonal to z-axis. */
-                                                                                 dv->y - ov->y,         /* Define this to be along the first edge this */
-                                                                                 dv->z - ov->z)));      /* contour links to in the quad edge structure */
+                                                   step_direction (step, "NONE", rx,     /* Reference x-axis, orthogonal to z-axis. */
+                                                                                 ry,         /* Define this to be along the first edge this */
+                                                                                 rz)));      /* contour links to in the quad edge structure */
     }
   }
 
@@ -405,10 +430,18 @@ object3d_export_to_step (object3d *object, char *filename)
 
       edge_loop = step_edge_loop (step, "NONE", edge_loop_edges);
 
+#if 1
       if (outer_contour)
         contour->face_bound_identifier = step_face_outer_bound (step, "NONE", edge_loop, true);
       else
         contour->face_bound_identifier = step_face_bound (step, "NONE", edge_loop, true);
+#endif
+#if 0
+      if (outer_contour)
+        contour->face_bound_identifier = step_face_outer_bound (step, "NONE", edge_loop, false /*true*/);
+      else
+        contour->face_bound_identifier = step_face_bound (step, "NONE", edge_loop, false /*true*/);
+#endif
 
       face_contour_list = g_list_append (face_contour_list, GINT_TO_POINTER (contour->face_bound_identifier));
     }
@@ -421,14 +454,13 @@ object3d_export_to_step (object3d *object, char *filename)
   pcb_shell_identifier = step_closed_shell (step, "NONE", shell_face_list);
   brep_identifier = step_manifold_solid_brep (step, "PCB outline", pcb_shell_identifier);
 
+#if 1
   /* Body style */
-  if (1) {
-    /* XXX: THERE MUST BE A BODY STYLE, CERTAINLY IF WE WANT TO OVER RIDE FACE COLOURS */
-    brep_style_identifier = step_styled_item (step, "NONE", presentation_style_assignments_from_appearance (step, object->appear), brep_identifier);
-    step_presentation_layer_assignment (step, "1", "Layer 1", make_step_id_list (1, brep_style_identifier));
+  /* XXX: THERE MUST BE A BODY STYLE, CERTAINLY IF WE WANT TO OVER RIDE FACE COLOURS */
+  brep_style_identifier = step_styled_item (step, "NONE", presentation_style_assignments_from_appearance (step, object->appear), brep_identifier);
+  step_presentation_layer_assignment (step, "1", "Layer 1", make_step_id_list (1, brep_style_identifier));
 
-    styled_item_identifiers = g_list_append (styled_item_identifiers, GINT_TO_POINTER (brep_style_identifier));
-  }
+  styled_item_identifiers = g_list_append (styled_item_identifiers, GINT_TO_POINTER (brep_style_identifier));
 
   /* Face styles */
   for (face_iter = object->faces; face_iter != NULL; face_iter = g_list_next (face_iter)) {
@@ -444,6 +476,7 @@ object3d_export_to_step (object3d *object, char *filename)
 
   /* Emit references to the styled and over_ridden styled items */
   step_mechanical_design_geometric_presentation_representation (step, "", styled_item_identifiers, geometric_representation_context_identifier);
+#endif
 
   shape_representation_identifier =
     step_advanced_brep_shape_representation (step, "test_pcb_absr_name",
@@ -526,9 +559,9 @@ object3d_from_board_outline (void)
         ct_npoints = get_contour_npoints (ct);
       }
 
-      get_contour_coord_n_in_mm (ct, offset_in_ct, &x1, &y1);
-      vertices[i]           = make_vertex3d (x1, y1, -COORD_TO_MM (HACK_BOARD_THICKNESS)); /* Bottom */
-      vertices[npoints + i] = make_vertex3d (x1, y1, 0);                                   /* Top */
+      get_contour_coord_n_in_step_mm (ct, offset_in_ct, &x1, &y1);
+      vertices[i]           = make_vertex3d (x1, y1, -COORD_TO_STEP_Z (PCB, HACK_BOARD_THICKNESS)); /* Bottom */
+      vertices[npoints + i] = make_vertex3d (x1, y1, 0);                                            /* Top */
 
       object3d_add_vertex (board_object, vertices[i]);
       object3d_add_vertex (board_object, vertices[npoints + i]);
@@ -553,7 +586,7 @@ object3d_from_board_outline (void)
     faces[npoints] = make_face3d (); /* bottom_face */
     face3d_set_normal (faces[npoints], 0., 0., -1.);
     face3d_set_appearance (faces[npoints], top_bot_appearance);
-    object3d_add_face (board_object, faces[npoints]);
+//    object3d_add_face (board_object, faces[npoints]);
 
     faces[npoints + 1] = make_face3d (); /* top_face */
     face3d_set_normal (faces[npoints + 1], 0., 0., 1.);
@@ -561,8 +594,14 @@ object3d_from_board_outline (void)
     object3d_add_face (board_object, faces[npoints + 1]);
 
     /* Pick the first bottom / top edge within the bottom / top face outer contour loop, and link it to the face */
+#if 0
     face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[0])));
     face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints]));
+#endif
+#if 1
+    face3d_add_contour (faces[npoints], make_contour3d (edges[0]));
+    face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints])));
+#endif
 
     ct = contour;
     start_of_ct = 0;
@@ -581,8 +620,14 @@ object3d_from_board_outline (void)
         ct_npoints = get_contour_npoints (ct);
 
         /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
+#if 0
         face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[i])));
         face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints + i]));
+#endif
+#if 1
+        face3d_add_contour (faces[npoints], make_contour3d (edges[i]));
+        face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(edges[npoints + i])));
+#endif
       }
 
       next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
@@ -590,8 +635,18 @@ object3d_from_board_outline (void)
 
       /* Setup the face normals for the edges along the contour extrusion (top and bottom are handled separaetely) */
       /* Define the (non-normalized) face normal to point to the outside of the contour */
+#if 0
       face3d_set_normal (faces[i], (vertices[next_i_around_ct]->y - vertices[i]->y),
                                   -(vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
+#endif
+#if 1
+      face3d_set_normal (faces[i], -(vertices[next_i_around_ct]->y - vertices[i]->y),
+                                    (vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
+#endif
+#if 0
+      face3d_set_normal (faces[i], -(vertices[next_i_around_ct]->y - vertices[i]->y),
+                                   -(vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
+#endif
 
       /* Assign the appropriate vertex geometric data to each edge end */
       ODATA (edges[              i]) = vertices[0 * npoints + i];
@@ -600,12 +655,22 @@ object3d_from_board_outline (void)
       DDATA (edges[1 * npoints + i]) = vertices[1 * npoints + next_i_around_ct];
       ODATA (edges[2 * npoints + i]) = vertices[0 * npoints + i];
       DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
+#if 0
       LDATA (edges[              i]) = faces[i];
       RDATA (edges[              i]) = faces[npoints];
       LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
       RDATA (edges[1 * npoints + i]) = faces[i];
       LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
       RDATA (edges[2 * npoints + i]) = faces[i];
+#endif
+#if 1
+      RDATA (edges[              i]) = faces[i];
+      LDATA (edges[              i]) = faces[npoints];
+      RDATA (edges[1 * npoints + i]) = faces[npoints + 1];
+      LDATA (edges[1 * npoints + i]) = faces[i];
+      RDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
+      LDATA (edges[2 * npoints + i]) = faces[i];
+#endif
 
       /* NB: Contours are counter clockwise in XY plane.
        *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
@@ -613,6 +678,7 @@ object3d_from_board_outline (void)
        *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
        */
 
+#if 0 /* UNDERLYING DATA HAS CCW CONTOURS FOR OUTER, CW INNER */
       /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
       splice (edges[i], edges[2 * npoints + i]);
       splice (edges[2 * npoints + i], SYM(edges[prev_i_around_ct]));
@@ -620,29 +686,82 @@ object3d_from_board_outline (void)
       /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
       splice (SYM(edges[2 * npoints + i]), edges[npoints + i]);
       splice (edges[npoints + i], SYM(edges[npoints + prev_i_around_ct]));
+#endif
+#if 0 /* UNDERLYING DATA HAS CCW CONTOURS FOR OUTER, CW INNER... alternative permutation for top vertex.. UNTESTED */
+      /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+      splice (edges[i], edges[2 * npoints + i]);
+      splice (edges[2 * npoints + i], SYM(edges[prev_i_around_ct]));
+
+      /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+      splice (SYM(edges[npoints + prev_i_around_ct]), SYM(edges[2 * npoints + i]));
+      splice (SYM(edges[2 * npoints + i]),  edges[npoints + i]);
+#endif
+#if 0 /* UNDERLYING DATA HAS CW CONTOURS FOR OUTER, CCW INNER - E.g. PCB's broken contours */
+      /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+      splice (SYM(edges[i]), edges[2 * npoints + i]);
+      splice (edges[2 * npoints + i], edges[prev_i_around_ct]);
+
+      /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+      splice (SYM(edges[2 * npoints + i]), SYM(edges[npoints + i]));
+      splice (SYM(edges[npoints + i]), edges[npoints + prev_i_around_ct]);
+#endif
+#if 1 /* UNDERLYING DATA HAS CW CONTOURS FOR OUTER, CCW INNER - E.g. PCB's broken contours... alternative permutation for top vertex */
+      /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+      splice (edges[i], edges[2 * npoints + i]);
+      splice (edges[2 * npoints + i], SYM(edges[prev_i_around_ct]));
+
+      /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+      splice (edges[npoints + prev_i_around_ct], SYM(edges[2 * npoints + i]));
+      splice (SYM(edges[2 * npoints + i]), SYM(edges[npoints + i]));
+#endif
+#if 0 /* UNDERLYING DATA HAS CW CONTOURS FOR OUTER, CCW INNER - E.g. PCB's broken contours... swap edge sequence */
+#if 0
+      /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+      splice (edges[prev_i_around_ct], edges[2 * npoints + i]);
+      splice (edges[2 * npoints + i], SYM(edges[i]));
+#endif
+#if 1
+      /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
+      splice (edges[prev_i_around_ct], edges[2 * npoints + i]);
+      splice (edges[2 * npoints + i], SYM(edges[i]));
+#endif
+
+      /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
+      splice (SYM(edges[npoints + i]), SYM(edges[2 * npoints + i]));
+      splice (SYM(edges[2 * npoints + i]), edges[npoints + prev_i_around_ct]);
+#endif
 
       if (ct->is_round) {
 
-        face3d_set_cylindrical (faces[i], COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* A point on the axis of the cylinder */
-                                          0., 0., 1.,                                     /* Direction of the cylindrical axis */
+        face3d_set_cylindrical (faces[i], COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), 0., /* A point on the axis of the cylinder */
+                                          0., 0., 1.,                                                       /* Direction of the cylindrical axis */
                                           COORD_TO_MM (ct->radius));
         face3d_set_surface_orientation_reversed (faces[i]); /* XXX: Assuming this is a hole, the cylindrical surface normal points in the wrong direction - INCORRECT IF THIS IS THE OUTER CONTOUR!*/
         face3d_set_normal (faces[i], 1., 0., 0.);  /* A normal to the axis direction */
                                   /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
 
-
+#if 0
         edge_info_set_round (UNDIR_DATA (edges[i]),
-                             COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), -COORD_TO_MM (HACK_BOARD_THICKNESS), /* Center of circle */
+                             COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), COORD_TO_STEP_Z (PCB, -HACK_BOARD_THICKNESS), /* Center of circle */
                              0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
         edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
-                             COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* Center of circle */
+                             COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), 0., /* Center of circle */
                              0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+#endif
+#if 1
+        edge_info_set_round (UNDIR_DATA (edges[i]),
+                             COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), COORD_TO_STEP_Z (PCB, -HACK_BOARD_THICKNESS), /* Center of circle */
+                             0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+        edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
+                             COORD_TO_STEP_X (PCB, ct->cx), COORD_TO_STEP_Y (PCB, ct->cy), 0., /* Center of circle */
+                             0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE */
+#endif
         edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
       }
 
     }
 
-    if (1) {
+    if (0) {
       /* Cylinder centers on 45x45mm, stitch vertex is at 40x45mm. Radius is thus 5mm */
 
       edge_ref cylinder_edges[3];
@@ -652,18 +771,26 @@ object3d_from_board_outline (void)
       /* Edge on top of board */
       cylinder_edges[0] = make_edge ();
       UNDIR_DATA (cylinder_edges[0]) = make_edge_info ();
+#if 0
       edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
-                           45., 45., 0., /* Center of circle */
-                            0.,  0., 1., /* Normal */
+                           COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
+                            0.,   0., 1., /* Normal */
                             5.);         /* Radius */
+#endif
+#if 1
+      edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
+                           COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* Center of circle */
+                            0.,   0., -1., /* Normal */
+                            5.);           /* Radius */
+#endif
       object3d_add_edge (board_object, cylinder_edges[0]);
 
       /* Edge on top of cylinder */
       cylinder_edges[1] = make_edge ();
       UNDIR_DATA (cylinder_edges[1]) = make_edge_info ();
       edge_info_set_round (UNDIR_DATA (cylinder_edges[1]),
-                           45., 45., 10., /* Center of circle */
-                            0.,  0., 1.,  /* Normal */
+                           COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10., /* Center of circle */
+                            0.,   0., 1.,  /* Normal */
                             5.);          /* Radius */
       object3d_add_edge (board_object, cylinder_edges[1]);
 
@@ -674,17 +801,17 @@ object3d_from_board_outline (void)
       object3d_add_edge (board_object, cylinder_edges[2]);
 
       /* Vertex on board top surface */
-      cylinder_vertices[0] = make_vertex3d (40., 45., 0.); /* Bottom */
+      cylinder_vertices[0] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0.); /* Bottom */
       object3d_add_vertex (board_object, cylinder_vertices[0]);
 
       /* Vertex on cylinder top surface */
-      cylinder_vertices[1] = make_vertex3d (40., 45., 10.); /* Top */
+      cylinder_vertices[1] = make_vertex3d (COORD_TO_STEP_X (PCB, MM_TO_COORD (40.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 10.); /* Top */
       object3d_add_vertex (board_object, cylinder_vertices[1]);
 
       /* Cylindrical face */
       cylinder_faces[0] = make_face3d ();
-      face3d_set_cylindrical (cylinder_faces[0], 45., 45., 0., /* A point on the axis of the cylinder */
-                                        0., 0., 1.,            /* Direction of the cylindrical axis */
+      face3d_set_cylindrical (cylinder_faces[0], COORD_TO_STEP_X (PCB, MM_TO_COORD (45.)), COORD_TO_STEP_Y (PCB, MM_TO_COORD (45.)), 0., /* A point on the axis of the cylinder */
+                                        0., 0., 1.,             /* Direction of the cylindrical axis */
                                         5.);                   /* Radius of cylinder */
       face3d_set_normal (cylinder_faces[0], 1., 0., 0.);       /* A normal to the axis direction */
                                    /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
diff --git a/src/hid/gtk/step.c b/src/hid/gtk/step.c
index dfb1deb..a9bd478 100644
--- a/src/hid/gtk/step.c
+++ b/src/hid/gtk/step.c
@@ -162,7 +162,7 @@ step_edge_loop (step_file *file, char *name, step_id_list edge_list)
 {
   fprintf (file->f, "#%i = EDGE_LOOP ( '%s', ", file->next_id, name);
   fprint_id_list (file->f, edge_list);
-  fprintf (file->f, " ) ; ");
+  fprintf (file->f, " ) ;\n");
   destroy_step_id_list (edge_list);
 
   return file->next_id++;
@@ -191,7 +191,7 @@ step_advanced_face (step_file *file, char *name, step_id_list bounds, step_id fa
 {
   fprintf (file->f, "#%i = ADVANCED_FACE ( '%s', ", file->next_id, name);
   fprint_id_list (file->f, bounds);
-  fprintf (file->f, ", #%i, %s ) ; ", face_geometry, step_bool (same_sense));
+  fprintf (file->f, ", #%i, %s ) ;\n", face_geometry, step_bool (same_sense));
   destroy_step_id_list (bounds);
 
   return file->next_id++;

Bottom: d89ff5f7873fbe1cf14d93ee24ce3e3fea286bb6
Top:    24ccc8ebcc3bdcfa167e1d7e348f4003acb96e5d
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-10-24 18:59:42 +0100

Refresh of play-with-glsl-shader-for-rend

---

diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index daee7bf..b7274d3 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -831,8 +831,8 @@ fill_contour (PLINE *contour)
   if (contour->tristrip_num_vertices == 0)
     return;
 
-#if 0
   hidgl_ensure_vertex_space (&buffer, contour->tristrip_num_vertices);
+#if 0
   memcpy (&buffer.triangle_array[buffer.coord_comp_count],
           contour->tristrip_vertices,
           sizeof (float) * 5 * contour->tristrip_num_vertices);
@@ -1020,7 +1020,14 @@ void
 hidgl_load_frag_shader (void)
 {
 //  char *vs_source;
-  char *fs_source;
+  char *fs_source = "void main()\n"
+                    "{\n"
+                    "  float sqdist;\n"
+                    "  sqdist = dot (gl_TexCoord[0].st, gl_TexCoord[0].st);\n"
+                    "  if (sqdist > 1.0)\n"
+                    "    discard;\n"
+                    "  gl_FragColor = gl_Color;\n"
+                    "}\n";
 
   /* Compile and load the program */
 
@@ -1036,14 +1043,14 @@ hidgl_load_frag_shader (void)
   free (vs_source);
 #endif
 
-  fs_source = file2string ("circular.frag");
+//  fs_source = file2string ("circular.frag");
   if (fs_source == NULL)
     return;
   fs = glCreateShader (GL_FRAGMENT_SHADER);
   glShaderSource (fs, 1, &fs_source, NULL);
   glCompileShader (fs);
   printLog (fs);
-  free (fs_source);
+//  free (fs_source);
 
   sp = glCreateProgram ();
 //  glAttachShader (sp, vs);
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index f803fc3..69d2ffa 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -1410,6 +1410,7 @@ DrawMask (BoxType * screen)
   polygon.Clipped = board_outline_poly ();
   polygon.NoHoles = NULL;
   polygon.NoHolesValid = 0;
+  polygon.BoundingBox = *screen;
   SET_FLAG (FULLPOLYFLAG, &polygon);
   common_fill_pcb_polygon (out->fgGC, &polygon, screen);
   poly_Free (&polygon.Clipped);

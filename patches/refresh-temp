Bottom: e67b4fcfa210c488fd4f8452bd00fa3810ff5391
Top:    79809f798d22ca7cc65190dfdacb3161a584a801
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-12-06 20:57:57 +0000

Refresh of cache-triangulated-polygons-fo

---

diff --git a/src/create.c b/src/create.c
index bf3b688..5340790 100644
--- a/src/create.c
+++ b/src/create.c
@@ -615,6 +615,8 @@ CreateNewPolygon (LayerTypePtr Layer, FlagType Flags)
   polygon->Clipped = NULL;
   polygon->NoHoles = NULL;
   polygon->NoHolesValid = 0;
+  polygon->gui_cache = NULL;
+  polygon->gui_cache_valid = 0;
   return (polygon);
 }
 
diff --git a/src/global.h b/src/global.h
index bb78abc..a455d3f 100644
--- a/src/global.h
+++ b/src/global.h
@@ -264,6 +264,8 @@ struct polygon_st			/* holds information about a polygon */
   Cardinal HoleIndexN;		/* number of holes in polygon */
   Cardinal HoleIndexMax;	/* max number from malloc() */
 
+  void *gui_cache;		/* Private cache for the GUI */
+  int gui_cache_valid;		/* Reset to false when the polygon changes */
 };
 
 typedef struct			/* holds information about arcs */
diff --git a/src/hid.h b/src/hid.h
index 073dbae..d3616c8 100644
--- a/src/hid.h
+++ b/src/hid.h
@@ -540,6 +540,7 @@ typedef enum
     HID_DRC_GUI *drc_gui;
 
     void (*edit_attributes) (char *owner, AttributeListType *attrlist_);
+    void (*free_polygon_cache) (PolygonType *poly);
 
   } HID;
 
diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index 09815f5..2b49746 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -707,6 +707,7 @@ hidgl_fill_polygon (int n_coords, int *x, int *y)
   free (vertices);
 }
 
+<<<<<<< current
 static inline void
 stash_vertex (PLINE *contour, int *vertex_comp,
               float x, float y, float z, float r, float s)
@@ -859,12 +860,19 @@ polygon_contains_user_holes (PolygonType *polygon)
 }
 
 
+=======
+>>>>>>> patched
 static GLint stencil_bits;
 static int dirty_bits = 0;
 static int assigned_bits = 0;
 
+struct polygon_cache {
+  int fill_display_list;
+};
+
 /* FIXME: JUST DRAWS THE FIRST PIECE.. TODO: SUPPORT FOR FULLPOLY POLYGONS */
 void
+<<<<<<< current
 hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box /*, bool force_new_stencil */)
 {
   bool force_new_stencil = false;
@@ -872,6 +880,15 @@ hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box /*, bool forc
   int stencil_bit;
 
   CHECK_IS_IN_CONTEXT ();
+=======
+hidgl_fill_pcb_polygon_nocache (PolygonType *poly, const BoxType *clip_box, double scale)
+{
+  cairo_traps_t traps;
+
+  CHECK_IS_IN_CONTEXT ();
+
+  global_scale = scale;
+>>>>>>> patched
 
   if (poly->Clipped == NULL)
     {
@@ -879,6 +896,7 @@ hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box /*, bool forc
       return;
     }
 
+<<<<<<< current
   if (poly->Clipped->contour_tree->size == 1)
     {
       /* Polygon does not have holes */
@@ -946,6 +964,45 @@ hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box /*, bool forc
     hidgl_return_stencil_bit (stencil_bit);       // Unassign our stencil buffer bit
 
   glPopAttrib ();                                 // Restore the stencil buffer op and function
+=======
+  _cairo_traps_init (&traps);
+  bo_poly_to_traps (poly->Clipped, &traps);
+  _cairo_traps_fini (&traps);
+}
+
+void
+hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale)
+{
+  struct polygon_cache *cache;
+  int new_cache = 0;
+
+  if (poly->gui_cache == NULL) {
+    poly->gui_cache = malloc (sizeof (struct polygon_cache));
+    new_cache = 1;
+  }
+
+  cache = poly->gui_cache;
+
+#if 1
+  if (!poly->gui_cache_valid) {
+    if (!new_cache)
+      glDeleteLists (cache->fill_display_list, 1);
+
+    cache->fill_display_list = glGenLists (1);
+    hidgl_flush_triangles (&buffer);
+    glNewList (cache->fill_display_list, GL_COMPILE);
+    hidgl_fill_pcb_polygon_nocache (poly, NULL /* clip_box */, scale);
+    hidgl_flush_triangles (&buffer);
+    glEndList ();
+    poly->gui_cache_valid = 1;
+  }
+
+  glCallList (cache->fill_display_list);
+
+#else
+  hidgl_fill_pcb_polygon_nocache (poly, clip_box, scale);
+#endif
+>>>>>>> patched
 }
 
 void
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index f82150c..61623ac 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -785,6 +785,14 @@ ghid_progress (int so_far, int total, const char *message)
   return 0;
 }
 
+static void
+ghid_free_polygon_cache (PolygonType *poly)
+{
+  printf ("FIXME: Should free cached polygon data\n");
+  free (poly->gui_cache);
+  poly->gui_cache_valid = 0;
+}
+
 /* ---------------------------------------------------------------------- */
 
 
@@ -1072,7 +1080,8 @@ HID ghid_hid = {
   ghid_beep,
   ghid_progress,
   &ghid_drc_gui,
-  ghid_attributes
+  ghid_attributes,
+  ghid_free_polygon_cache,
 };
 
 /* ------------------------------------------------------------ 
diff --git a/src/mymem.c b/src/mymem.c
index bed0f9b..ecb6802 100644
--- a/src/mymem.c
+++ b/src/mymem.c
@@ -755,6 +755,10 @@ FreePolygonMemory (PolygonTypePtr Polygon)
 {
   if (Polygon)
     {
+      if (Polygon->gui_cache)
+        {
+          gui->free_polygon_cache (Polygon);
+        }
       MYFREE (Polygon->Points);
       MYFREE (Polygon->HoleIndex);
       if (Polygon->Clipped)
diff --git a/src/polygon.c b/src/polygon.c
index 751c3dc..20bbf37 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -1071,6 +1071,7 @@ clearPoly (DataTypePtr Data, LayerTypePtr Layer, PolygonType * polygon,
       subtract_accumulated (&info, polygon);
     }
   polygon->NoHolesValid = 0;
+  polygon->gui_cache_valid = 0;
   return r;
 }
 
@@ -1218,8 +1219,9 @@ InitClip (DataTypePtr Data, LayerTypePtr layer, PolygonType * p)
   assert (poly_Valid (p->Clipped));
   if (TEST_FLAG (CLEARPOLYFLAG, p))
     clearPoly (Data, layer, p, NULL, 0);
-  else
-    p->NoHolesValid = 0;
+  /* HACK */
+  p->NoHolesValid = 0;
+  p->gui_cache_valid = 0;
   return 1;
 }
 
@@ -1470,22 +1472,27 @@ subtract_plow (DataTypePtr Data, LayerTypePtr Layer, PolygonTypePtr Polygon,
     case VIA_TYPE:
       SubtractPin (Data, (PinTypePtr) ptr2, Layer, Polygon);
       Polygon->NoHolesValid = 0;
+      Polygon->gui_cache_valid = 0;
       return 1;
     case LINE_TYPE:
       SubtractLine ((LineTypePtr) ptr2, Polygon);
       Polygon->NoHolesValid = 0;
+      Polygon->gui_cache_valid = 0;
       return 1;
     case ARC_TYPE:
       SubtractArc ((ArcTypePtr) ptr2, Polygon);
       Polygon->NoHolesValid = 0;
+      Polygon->gui_cache_valid = 0;
       return 1;
     case PAD_TYPE:
       SubtractPad ((PadTypePtr) ptr2, Polygon);
       Polygon->NoHolesValid = 0;
+      Polygon->gui_cache_valid = 0;
       return 1;
     case TEXT_TYPE:
       SubtractText ((TextTypePtr) ptr2, Polygon);
       Polygon->NoHolesValid = 0;
+      Polygon->gui_cache_valid = 0;
       return 1;
     }
   return 0;

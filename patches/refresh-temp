Bottom: 67e1c38be7b269bda52cc61f6e45e04bf97f9453
Top:    444c9f0b79aaef1537abf7c0b1975e8580a3ae0d
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2008-10-16 11:04:15 +0100

Refresh of try-something-with-the-rtrees

---

diff --git a/src/global.h b/src/global.h
index 3f4a5dc..64656e5 100644
--- a/src/global.h
+++ b/src/global.h
@@ -39,7 +39,6 @@
 
 #include "const.h"
 #include "macro.h"
-#include "polyarea.h"
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -52,6 +51,10 @@
 
 #include "hid.h"
 
+typedef struct rtree rtree_t;
+
+#include "polyarea.h" /* Needs rtree_t defined */
+
 #define _(S) (S)
 
 typedef int LocationType;
@@ -232,11 +235,10 @@ typedef struct
 
 typedef struct polygon_st PolygonType, *PolygonTypePtr;
 
-typedef struct
-{
+struct rtree {
   struct rtree_node *root;
   int size;			/* number of entries in tree */
-} rtree_t;
+};
 
 typedef struct			/* holds information about a poured area */
 {
diff --git a/src/polyarea.h b/src/polyarea.h
index 819b074..ee185a9 100644
--- a/src/polyarea.h
+++ b/src/polyarea.h
@@ -98,7 +98,7 @@ struct PLINE
     VNODE head;
     unsigned int Count;
     double area;
-    void *tree;
+    rtree_t *tree;
     struct {
       unsigned int status:3;
       unsigned int orient:1;
@@ -128,7 +128,7 @@ struct POLYAREA
 {
     POLYAREA *f, *b;
     PLINE *contours;
-    void *contour_tree;
+    rtree_t *contour_tree;
 };
 
 BOOLp poly_M_Copy0(POLYAREA ** dst, const POLYAREA * srcfst);
diff --git a/src/polygon1.c b/src/polygon1.c
index c2f1eec..247ebbf 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -45,6 +45,8 @@
 #include	<setjmp.h>
 #include	<math.h>
 #include	<string.h>
+
+#include "global.h"
 #include "polyarea.h"
 #include "rtree.h"
 #include "heap.h"
@@ -647,7 +649,7 @@ seg_in_seg (const BoxType * b, void *cl)
       if (res & 2)
 	{
 	  cntrbox_adjust (i->s->p, cnt > 1 ? s2 : s1);
-	  if (adjust_tree ((rtree_t *) (i->s->p->tree), i->s))
+	  if (adjust_tree (i->s->p->tree, i->s))
 	    return 1;
 	}
       /* if we added a node in the tree we need to change the tree */
@@ -790,12 +792,12 @@ contour_bounds_touch (const BoxType * b, void *cl)
       /* fill in the segment in info corresponding to this node */
       if (setjmp (info.sego) == 0)
         {
-          r_search ((rtree_t *) (looping_over->tree), &box, NULL, get_seg, &info);
+          r_search (looping_over->tree, &box, NULL, get_seg, &info);
           assert (0);
         }
 
         /* NB: If this actually hits anything, we are teleported back to the beginning */
-        info.tree = (rtree_t *) rtree_over->tree;
+        info.tree = rtree_over->tree;
         if (info.tree)
           if (UNLIKELY (r_search (info.tree, &info.s->box,
                                   seg_in_region, seg_in_seg, &info)))
@@ -809,13 +811,13 @@ static int
 intersect (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
 {
   POLYAREA *t;
-  PLINE *pa, *pb;
+  PLINE *pa;
   contour_info c_info;
 
   /* Search the r-tree of the object with most contours
    * We loop over the contours of "a". Swap if necessary.
    */
-  if (((rtree_t *)a->contour_tree)->size > ((rtree_t *)b->contour_tree)->size)
+  if (a->contour_tree->size > b->contour_tree->size)
     {
       t = b;
       b = a;
@@ -850,7 +852,7 @@ intersect (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
       sb.X2 = pa->xmax + 1;
       sb.Y2 = pa->ymax + 1;
 
-      r_search ((rtree_t *) (b->contour_tree), &sb, NULL, contour_bounds_touch, &c_info);
+      r_search (b->contour_tree, &sb, NULL, contour_bounds_touch, &c_info);
     }
 
   return 0;
@@ -1157,34 +1159,41 @@ InsCntr (jmp_buf * e, PLINE * c, POLYAREA ** dst)
 
 static void
 PutContour (jmp_buf * e, PLINE * cntr, POLYAREA ** contours, PLINE ** holes,
-	    POLYAREA * parent, PLINE * parent_contour)
+            POLYAREA *owner, POLYAREA * parent, PLINE * parent_contour)
 {
   assert (cntr != NULL);
   assert (cntr->Count > 2);
   cntr->next = NULL;
 
   if (cntr->Flags.orient == PLF_DIR)
-    InsCntr (e, cntr, contours);
+    {
+      if (owner != NULL)
+        r_delete_entry (owner->contour_tree, (BoxType *)cntr);
+      InsCntr (e, cntr, contours);
+    }
   /* put hole into temporary list */
   else
     {
-#warning THIS SPEEDUP SHORTCUT IS HARD TO FIGURE OUT WITH r_trees
-#if 0
       /* if we know this belongs inside the parent, put it there now */
       if (parent_contour)
 	{
 	  cntr->next = parent_contour->next;
 	  parent_contour->next = cntr;
-#warning FIXME HARDER, the r_tree entry needs to go wherever the parent contour got / will get attached.
-          r_insert_entry ((rtree_t *)parent, (BoxType *)cntr, 0);
+          if (owner != parent)
+            {
+              if (owner != NULL)
+                r_delete_entry (owner->contour_tree, (BoxType *)cntr);
+              r_insert_entry (parent->contour_tree, (BoxType *)cntr, 0);
+            }
 	}
       else
-#endif
 	{
 	  cntr->next = *holes;
 	  *holes = cntr;	/* let cntr be 1st hole in list */
           /* We don't insert the holes into an r-tree,
            * they just form a linked list */
+          if (owner != NULL)
+            r_delete_entry (owner->contour_tree, (BoxType *)cntr);
 	}
     }
 }				/* PutContour */
@@ -1290,7 +1299,7 @@ InsertHoles (jmp_buf * e, POLYAREA * dest, PLINE ** src)
 	  container->next = curh;
 	  curh->next = tmp;
 
-#warning WHICH POLYAREA GOT THIS - STUPID LONG SEARCH!!
+#warning WHICH POLYAREA GOT THIS - STUPID LONG SEARCH - STORE IN HEAP STRUCTURE INSTEAD!!
           curc = dest;
           do
             {
@@ -1538,7 +1547,7 @@ Collect1 (jmp_buf * e, VNODE *cur, DIRECTION dir, POLYAREA **contours, PLINE **
 	    DEBUGP ("adding contour with %d verticies and direction %c\n",
 		    p->Count, p->Flags.orient ? 'F' : 'B');
 #endif
-	    PutContour (e, p, contours, holes, NULL, NULL);
+	    PutContour (e, p, contours, holes, NULL, NULL, NULL);
 	  }
 	else
 	  {
@@ -1572,7 +1581,7 @@ Collect (jmp_buf * e, PLINE * a, POLYAREA ** contours, PLINE ** holes,
 
 static int
 cntr_Collect (jmp_buf * e, PLINE ** A, POLYAREA ** contours, PLINE ** holes,
-	      int action, POLYAREA * parent, PLINE *parent_contour)
+	      int action, POLYAREA *owner, POLYAREA * parent, PLINE *parent_contour)
 {
   PLINE *tmprev;
 
@@ -1603,10 +1612,9 @@ cntr_Collect (jmp_buf * e, PLINE ** A, POLYAREA ** contours, PLINE ** holes,
 	    {
 	      tmprev = *A;
 	      /* disappear this contour */
-#warning Remove from RTREE?
 	      *A = tmprev->next;
 	      tmprev->next = NULL;
-	      PutContour (e, tmprev, contours, holes, NULL, NULL);
+	      PutContour (e, tmprev, contours, holes, owner, NULL, NULL);
 	      return TRUE;
 	    }
 	  break;
@@ -1615,11 +1623,10 @@ cntr_Collect (jmp_buf * e, PLINE ** A, POLYAREA ** contours, PLINE ** holes,
 	    {
 	      tmprev = *A;
 	      /* disappear this contour */
-#warning Remove from RTREE?
 	      *A = tmprev->next;
 	      tmprev->next = NULL;
 	      poly_InvContour (tmprev);
-	      PutContour (e, tmprev, contours, holes, NULL, NULL);
+	      PutContour (e, tmprev, contours, holes, owner, NULL, NULL);
 	      return TRUE;
 	    }
 	  break;
@@ -1629,10 +1636,9 @@ cntr_Collect (jmp_buf * e, PLINE ** A, POLYAREA ** contours, PLINE ** holes,
 	    {
 	      tmprev = *A;
 	      /* disappear this contour */
-#warning Remove from RTREE?
 	      *A = tmprev->next;
 	      tmprev->next = NULL;
-	      PutContour (e, tmprev, contours, holes, parent, parent_contour);
+	      PutContour (e, tmprev, contours, holes, owner, parent, parent_contour);
 	      return TRUE;
 	    }
 	  break;
@@ -1669,7 +1675,7 @@ M_B_AREA_Collect (jmp_buf * e, POLYAREA * bfst, POLYAREA ** contours,
 		next = cur;
 		tmp->next = NULL;
 		tmp->Flags.status = UNKNWN;
-		PutContour (e, tmp, contours, holes, NULL, NULL);
+		PutContour (e, tmp, contours, holes, b, NULL, NULL);
 		break;
 	      case PBO_UNITE:
 		break;		/* nothing to do - already included */
@@ -1685,7 +1691,7 @@ M_B_AREA_Collect (jmp_buf * e, POLYAREA * bfst, POLYAREA ** contours,
 		next = cur;
 		tmp->next = NULL;
 		tmp->Flags.status = UNKNWN;
-		PutContour (e, tmp, contours, holes, NULL, NULL);
+		PutContour (e, tmp, contours, holes, b, NULL, NULL);
 		break;
 	      case PBO_ISECT:
 	      case PBO_SUB:
@@ -1702,8 +1708,8 @@ M_POLYAREA_Collect (jmp_buf * e, POLYAREA * afst, POLYAREA ** contours,
 		    PLINE ** holes, int action, BOOLp maybe)
 {
   POLYAREA *a = afst;
-  POLYAREA *parent;
-  PLINE **cur, **next, *parent_contours;
+  POLYAREA *parent = NULL; /* Quiet GCC warning */
+  PLINE **cur, **next, *parent_contour;
 
   assert (a != NULL);
   while ((a = a->f) != afst);
@@ -1711,32 +1717,34 @@ M_POLYAREA_Collect (jmp_buf * e, POLYAREA * afst, POLYAREA ** contours,
   do
     {
       if (maybe && a->contours->Flags.status != ISECTED)
-        {
-          parent = a;
-          parent_contours = a->contours;
-        }
+          parent_contour = a->contours;
       else
+          parent_contour = NULL;
+
+      /* Take care of the first contour - so we know if we
+       * can shortcut reparenting some of its children
+       */
+      cur = &a->contours;
+      if (*cur != NULL)
         {
-          parent = NULL;
-          parent_contours = NULL;
-        }
-      for (cur = &a->contours; *cur != NULL; cur = next)
-	{
-          PLINE *tmp;
-          tmp = *cur;
-	  next = &((*cur)->next);
-#warning PERHAPS WE NEED TO REMOVE THE CONTOUR FROM THE RTREE BECORE CALLING THIS?
-	  /* if we disappear a contour, don't advance twice */
-	  if (cntr_Collect
-	      (e, cur, contours, holes, action, parent,
-	       *cur == parent_contours ? NULL : parent_contours))
+          next = &((*cur)->next);
+          /* if we disappear a contour, don't advance twice */
+          if (cntr_Collect (e, cur, contours, holes, action, a, NULL, NULL))
             {
-              next = cur;
-#warning SHOULD BE IN cntr_Collect??
-              r_delete_entry ((rtree_t *)a->contour_tree, (BoxType *)tmp);
+              parent = *contours;
+            } else {
+              parent = a;
+              cur = next;
             }
-
-	}
+        }
+      for ( ; *cur != NULL; cur = next)
+        {
+          next = &((*cur)->next);
+          /* if we disappear a contour, don't advance twice */
+          if (cntr_Collect (e, cur, contours, holes, action, a, parent,
+                            parent_contour))
+              next = cur;
+        }
     }
   while ((a = a->f) != afst);
 }
@@ -2158,7 +2166,7 @@ poly_InvContour (PLINE * c)
   c->Flags.orient ^= 1;
   if (c->tree)
     {
-      r = r_search ((rtree_t *) (c->tree), NULL, NULL, flip_cb, NULL);
+      r = r_search (c->tree, NULL, NULL, flip_cb, NULL);
       assert (r == c->Count);
     }
 }
@@ -2390,7 +2398,7 @@ poly_InsideContour (PLINE * c, Vector p)
   ray.X2 = 0x7fffffff;
   ray.Y2 = p[1] + 1;
   if (setjmp (info.env) == 0)
-    r_search ((rtree_t *) c->tree, &ray, NULL, crossing, &info);
+    r_search (c->tree, &ray, NULL, crossing, &info);
   return info.f;
 }
 
@@ -2468,7 +2476,7 @@ poly_Clear (POLYAREA * P)
       P->contours = p->next;
       poly_DelContour (&p);
     }
-  r_destroy_tree ((rtree_t **)&P->contour_tree);
+  r_destroy_tree (&P->contour_tree);
 }
 
 void
diff --git a/src/rtree.h b/src/rtree.h
index 254d64a..3f87c5c 100644
--- a/src/rtree.h
+++ b/src/rtree.h
@@ -39,7 +39,6 @@
 
 #include "global.h"
 
-
 /* create an rtree from the list of boxes.  if 'manage' is true, then
  * the tree will take ownership of 'boxlist' and free it when the tree
  * is destroyed. */

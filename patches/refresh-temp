Bottom: ff9c3146fa32896e333de7fdb020526e18251ec4
Top:    c20fd7b0d1b83061d883b4b26fd1276917c068b4
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-09-29 16:58:45 +0100

Refresh of play-with-glsl-shader-for-rend

---

diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index 23f2e04..0649fac 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -88,14 +88,6 @@ static bool in_context = false;
     } \
   } while (0)
 
-void
-hidgl_in_context (bool is_in_context)
-{
-  if (in_context == is_in_context)
-    fprintf (stderr, "hidgl: hidgl_in_context called with nested value!\n");
-  in_context = is_in_context;
-}
-
 #define BUFFER_STRIDE (5 * sizeof (GLfloat))
 #define BUFFER_SIZE (BUFFER_STRIDE * 3 * TRIANGLE_ARRAY_SIZE)
 
@@ -820,8 +812,6 @@ load_built_in_shaders (void)
           "}\n";
 
   circular_program = hidgl_shader_new ("circular_rendering", NULL, circular_fs_source);
-
-  hidgl_shader_activate (circular_program);
 }
 
 void
@@ -853,12 +843,33 @@ hidgl_init (void)
     goto done;
   }
 
-  load_built_in_shaders ();
-
 done:
   done_once = true;
 }
 
+void
+hidgl_start_render (void)
+{
+  if (in_context)
+    fprintf (stderr, "hidgl: hidgl_start_render() - Already in rendering context!\n");
+
+  in_context = true;
+  hidgl_init ();
+  hidgl_init_triangle_array (&buffer);
+  load_built_in_shaders ();
+  hidgl_shader_activate (circular_program);
+}
+
+void
+hidgl_finish_render (void)
+{
+  if (!in_context)
+    fprintf (stderr, "hidgl: hidgl_finish_render() - Not currently in rendering context!\n");
+
+  hidgl_shader_activate (NULL);
+  in_context = false;
+}
+
 int
 hidgl_stencil_bits (void)
 {
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index 31d28e8..b93ce68 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -41,7 +41,6 @@ extern float global_depth;
 
 extern hidgl_shader *circular_program;
 
-void hidgl_in_context (bool is_in_context);
 void hidgl_init_triangle_array (triangle_buffer *buffer);
 void hidgl_finish_triangle_array (triangle_buffer *buffer);
 void hidgl_flush_triangles (triangle_buffer *buffer);
@@ -129,6 +128,8 @@ void hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box);
 void hidgl_fill_rect (Coord x1, Coord y1, Coord x2, Coord y2);
 
 void hidgl_init (void);
+void hidgl_start_render (void);
+void hidgl_finish_render (void);
 int hidgl_stencil_bits (void);
 int hidgl_assign_clear_stencil_bit (void);
 void hidgl_return_stencil_bit (int bit);
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 1c5a8a7..d9b0ff7 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -45,7 +45,6 @@ RCSID ("$Id$");
 extern HID ghid_hid;
 
 static hidGC current_gc = NULL;
-static bool check_gl_drawing_ok_hack = false;
 
 /* Sets gport->u_gc to the "right" GC to use (wrt mask or window)
 */
@@ -502,7 +501,7 @@ set_gl_color_for_gc (hidGC gc)
    * current_colorname set to NULL, so we don't NOOP the
    * next set_gl_color_for_gc call.
    */
-  if (!check_gl_drawing_ok_hack)
+  if (!priv->in_context)
     return;
 
   priv->current_colorname = strdup (gc->colorname);
@@ -582,9 +581,6 @@ set_gl_color_for_gc (hidGC gc)
 #endif
   }
 
-  if(!priv->in_context)
-    return;
-
   hidgl_flush_triangles (&buffer);
   glColor4d (r, g, b, a);
 }
@@ -861,29 +857,13 @@ draw_dozen_cross (gint x, gint y, gint z)
 }
 
 static void
-draw_crosshair (gint x, gint y, gint z)
-{
-  static enum crosshair_shape prev = Basic_Crosshair_Shape;
-
-  draw_right_cross (x, y, z);
-  if (prev == Union_Jack_Crosshair_Shape)
-    draw_slanted_cross (x, y, z);
-  if (prev == Dozen_Crosshair_Shape)
-    draw_dozen_cross (x, y, z);
-  prev = Crosshair.shape;
-}
-
-void
-ghid_show_crosshair (gboolean paint_new_location)
+draw_crosshair (render_priv *priv)
 {
   gint x, y, z;
   static int done_once = 0;
   static GdkColor cross_color;
 
-  if (!paint_new_location)
-    return;
-
-  if (!check_gl_drawing_ok_hack)
+  if (!priv->in_context)
     return;
 
   if (!done_once)
@@ -892,6 +872,7 @@ ghid_show_crosshair (gboolean paint_new_location)
       /* FIXME: when CrossColor changed from config */
       ghid_map_color_string (Settings.CrossColor, &cross_color);
     }
+
   x = gport->crosshair_x;
   y = gport->crosshair_y;
   z = global_depth;
@@ -903,12 +884,15 @@ ghid_show_crosshair (gboolean paint_new_location)
              cross_color.green / 65535.,
              cross_color.blue / 65535.);
 
-  if (x >= 0 && paint_new_location)
-    {
-      glBegin (GL_LINES);
-      draw_crosshair (x, y, z);
-      glEnd ();
-    }
+  glBegin (GL_LINES);
+
+  draw_right_cross (x, y, z);
+  if (Crosshair.shape == Union_Jack_Crosshair_Shape)
+    draw_slanted_cross (x, y, z);
+  if (Crosshair.shape == Dozen_Crosshair_Shape)
+    draw_dozen_cross (x, y, z);
+
+  glEnd ();
 
   glDisable (GL_COLOR_LOGIC_OP);
 }
@@ -1935,10 +1919,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   gtk_widget_get_allocation (widget, &allocation);
 
   ghid_start_drawing (port);
-
-  hidgl_in_context (true);
-  hidgl_init ();
-  check_gl_drawing_ok_hack = true;
+  hidgl_start_render ();
 
   /* If we don't have any stencil bits available,
      we can't use the hidgl polygon drawing routine */
@@ -2056,7 +2037,6 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
              port->bg_color.green / 65535.,
              port->bg_color.blue / 65535.);
 
-  hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
 
   /* Setup stenciling */
@@ -2113,16 +2093,13 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   DrawMark ();
   hidgl_flush_triangles (&buffer);
 
-  ghid_show_crosshair (TRUE);
+  draw_crosshair (priv);
 
   hidgl_flush_triangles (&buffer);
 
   draw_lead_user (priv);
 
-  hidgl_finish_triangle_array (&buffer);
-
-  check_gl_drawing_ok_hack = false;
-  hidgl_in_context (false);
+  hidgl_finish_render ();
   ghid_end_drawing (port);
 
   g_timer_start (priv->time_since_expose);
@@ -2185,11 +2162,9 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   if (!gdk_gl_drawable_gl_begin (pGlDrawable, pGlContext)) {
     return FALSE;
   }
+  hidgl_start_render ();
   gport->render_priv->in_context = true;
 
-  check_gl_drawing_ok_hack = true;
-  hidgl_in_context (true);
-
   glEnable (GL_BLEND);
   glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
 
@@ -2217,7 +2192,6 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   hidgl_reset_stencil_usage ();
 
   /* call the drawing routine */
-  hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
   glPushMatrix ();
   glScalef ((gport->view.flip_x ? -1. : 1.) / gport->view.coord_per_px,
@@ -2238,8 +2212,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   else
     glFlush ();
 
-  check_gl_drawing_ok_hack = false;
-  hidgl_in_context (false);
+  hidgl_finish_render ();
 
   /* end drawing to current GL-context */
   gport->render_priv->in_context = false;
@@ -2264,7 +2237,6 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   view_data save_view;
   int save_width, save_height;
   BoxType region;
-  bool save_check_gl_drawing_ok_hack;
 
   save_view = gport->view;
   save_width = gport->width;
@@ -2298,12 +2270,9 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   if (!gdk_gl_drawable_gl_begin (gldrawable, glcontext)) {
     return NULL;
   }
+  hidgl_start_render ();
   gport->render_priv->in_context = true;
 
-  save_check_gl_drawing_ok_hack = check_gl_drawing_ok_hack;
-  check_gl_drawing_ok_hack = true;
-  hidgl_in_context (true);
-
   glEnable (GL_BLEND);
   glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
 
@@ -2329,7 +2298,6 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   hidgl_reset_stencil_usage ();
 
   /* call the drawing routine */
-  hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
   glPushMatrix ();
   glScalef ((gport->view.flip_x ? -1. : 1.) / gport->view.coord_per_px,
@@ -2356,8 +2324,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
 
   glFlush ();
 
-  check_gl_drawing_ok_hack = save_check_gl_drawing_ok_hack;
-  hidgl_in_context (false);
+  hidgl_finish_render ();
 
   /* end drawing to current GL-context */
   gport->render_priv->in_context = false;
@@ -2385,6 +2352,7 @@ ghid_request_debug_draw (void)
   gtk_widget_get_allocation (widget, &allocation);
 
   ghid_start_drawing (port);
+  hidgl_start_render ();
 
   glViewport (0, 0, allocation.width, allocation.height);
 
@@ -2395,7 +2363,6 @@ ghid_request_debug_draw (void)
   glLoadIdentity ();
   glTranslatef (0.0f, 0.0f, -Z_NEAR);
 
-  hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
 
   /* Setup stenciling */
@@ -2433,6 +2400,7 @@ ghid_finish_debug_draw (void)
   hidgl_flush_triangles (&buffer);
   glPopMatrix ();
 
+  hidgl_finish_render ();
   ghid_end_drawing (gport);
 }

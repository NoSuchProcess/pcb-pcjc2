Bottom: c60205ce9683794138397134d2b0422ac2ccf6e0
Top:    4f55943668ce0c6bcd46e17ee1c406e85597d8a0
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-01-24 03:08:54 +0000

Refresh of add-some-shared-code-for-gl-dr

---

diff --git a/configure.ac b/configure.ac
index 7873ad5..0908316 100644
--- a/configure.ac
+++ b/configure.ac
@@ -268,34 +268,33 @@ AC_ARG_ENABLE([gl],
 [],[enable_gl=no])
 
 AC_MSG_RESULT([$enable_gl])
-AM_CONDITIONAL(WITH_GL, test x$enable_gl = xyes)
+AM_CONDITIONAL(USE_GL, test x$enable_gl = xyes)
 
 if test "x$enable_gl" = "xyes"; then
 	case " $with_gui " in
 		*\ gtk\ *) ;;
 		* ) AC_MSG_ERROR([GL drawing enabled but only works with the GTK HID.
 Either do not use --enable-gl or enable the gtk HID.])
+	;;
 	esac
-	
-	# Check for pkg-config
-	AC_PATH_PROG(PKG_CONFIG, pkg-config, no)
-	if test "$PKG_CONFIG" = "no"; then
-		AC_MSG_ERROR([Cannot find pkg-config, make sure it is installed and in your PATH])
-	fi
 
-	PKG_CHECK_MODULES(DBUS, dbus-1 >= 0.61,
-		[saved_LIBS="$LIBS"
-		 LIBS="$LIBS $DBUS_LIBS"
-		 AC_CHECK_FUNCS(dbus_watch_get_unix_fd)
-		 LIBS="$saved_LIBS" ],
-		[AC_MSG_ERROR([Cannot find dbus-1 >= 0.61, install it and rerun ./configure
-Please review the following errors:
-$DBUS_PKG_ERRORS])]
-	)
-	DBUS_VERSION=`$PKG_CONFIG dbus-1 --modversion`
-	
-	AC_DEFINE([HAVE_DBUS], 1,
-		[Define to 1 if DBUS IPC is to be compiled in])
+# FIXME... what do we need to check for determining we have GL? Is it headers, API ?
+
+	AC_CHECK_HEADERS(GL/gl.h)
+	case $ac_cv_header_GL_glut_h in
+	  no )
+	    AC_MSG_ERROR([You don't seem to have the GL library headers installed.])
+	    ;;
+	  * ) ;;
+	esac
+
+	AC_CHECK_HEADERS(GL/glut.h)
+	case $ac_cv_header_GL_glut_h in
+	  no )
+	    AC_MSG_ERROR([You don't seem to have the GL glut library headers installed.])
+	    ;;
+	  * ) ;;
+	esac
 
 fi
 
@@ -543,22 +542,16 @@ $GLIB_PKG_ERRORS])]
 	)
 	GLIB_VERSION=`$PKG_CONFIG glib-2.0 --modversion`
 
-	# Check for GtkGLExt
-	PKG_CHECK_MODULES(GTKGLEXT, gtkglext-1.0 >= 1.0.0, , [AC_MSG_ERROR([
+	if test "x$enable_gl" = "xyes"; then
+		# Check for GtkGLExt
+		PKG_CHECK_MODULES(GTKGLEXT, gtkglext-1.0 >= 1.0.0, , [AC_MSG_ERROR([
 *** Required version of gtkglext is not installed - please install first ***
 Please review the following errors:
 $GTKGLEXT_PKG_ERRORS])]
-	)
-
+		)
 	GTKGLEXT_VER=`$PKG_CONFIG gtkglext-1.0 --modversion`
+	fi
 
-	AC_CHECK_HEADERS(GL/glut.h)
-	case $ac_cv_header_GL_glut_h in
-	  no )
-	    AC_MSG_ERROR([You don't seem to have the GL glut library headers installed.])
-	    ;;
-	  * ) ;;
-	esac
 	;;
 
       nelma|png )
diff --git a/src/Makefile.am b/src/Makefile.am
index debc185..a337e16 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -272,7 +272,7 @@ BUILT_SOURCES+=	dbus-introspect.h
 endif
 
 # If we are building with GL support, we need some extra files
-if WITH_DBUS
+if USE_GL
 PCB_SRCS+=	${GL_SRCS}
 endif
 
diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index ed679c8..44487c9 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -1,4 +1,4 @@
-/* $Id: gtkhid-main.c,v 1.59 2008-12-27 19:06:04 djdelorie Exp $ */
+/* $Id: */
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
@@ -24,15 +24,10 @@
 #include "clip.h"
 
 #include "hid.h"
-#include "../hidint.h"
-#include "gui.h"
+#include "hidgl.h"
 
 
-#if !GTK_CHECK_VERSION(2,8,0) && defined(HAVE_GDK_GDKX_H)
-#include <gdk/gdkx.h>
-#endif
-
-#include <gtk/gtkgl.h>
+#include <GL/gl.h>
 #include <GL/glut.h>
 
 #ifdef HAVE_LIBDMALLOC
@@ -41,12 +36,8 @@
 
 #define PIXELS_PER_CIRCLINE 5.
 
-RCSID ("$Id: gtkhid-main.c,v 1.59 2008-12-27 19:06:04 djdelorie Exp $");
-
+RCSID ("$Id: $");
 
-extern HID ghid_hid;
-
-static int ghid_gui_is_up = 0;
 
 #define TRIANGLE_ARRAY_SIZE 5000
 static GLfloat triangle_array [2 * 3 * TRIANGLE_ARRAY_SIZE];
@@ -54,7 +45,7 @@ static unsigned int triangle_count;
 static int coord_comp_count;
 
 void
-ghid_init_triangle_array (void)
+hidgl_init_triangle_array (void)
 {
   glEnableClientState (GL_VERTEX_ARRAY);
   glVertexPointer (2, GL_FLOAT, 0, &triangle_array);
@@ -63,12 +54,11 @@ ghid_init_triangle_array (void)
 }
 
 void
-ghid_flush_triangles ()
+hidgl_flush_triangles ()
 {
   if (triangle_count == 0)
     return;
 
-//  printf ("Flushing %i triangles\n", triangle_count);
   glDrawArrays (GL_TRIANGLES, 0, triangle_count * 3);
   triangle_count = 0;
   coord_comp_count = 0;
@@ -84,7 +74,7 @@ ensure_triangle_space (int count)
       exit (1);
     }
   if (count > TRIANGLE_ARRAY_SIZE - triangle_count)
-    ghid_flush_triangles ();
+    hidgl_flush_triangles ();
 }
 
 static inline void
@@ -101,26 +91,15 @@ add_triangle (GLfloat x1, GLfloat y1,
   triangle_count++;
 }
 
-static void zoom_to (double factor, int x, int y);
-static void zoom_by (double factor, int x, int y);
-
-/* Sets gport->u_gc to the "right" GC to use (wrt mask or window)
-*/
-#define USE_GC(gc) use_gc (gc)
-
 static int cur_mask = -1;
 
-int ghid_flip_x = 0, ghid_flip_y = 0;
-
-/* ------------------------------------------------------------ */
-
 /* Px converts view->pcb, Vx converts pcb->view */
       
 static inline int 
 Vx (int x)
 {     
   int rv;
-  if (ghid_flip_x) 
+  if (hidgl_flip_x) 
     rv = (PCB->MaxWidth - x - gport->view_x0) / gport->zoom + 0.5;
   else
     rv = (x - gport->view_x0) / gport->zoom + 0.5;
@@ -137,7 +116,7 @@ static inline int
 Vy (int y)
 {         
   int rv;
-  if (ghid_flip_y)
+  if (hidgl_flip_y)
     rv = (PCB->MaxHeight - y - gport->view_y0) / gport->zoom + 0.5;
   else
     rv = (y - gport->view_y0) / gport->zoom + 0.5;
@@ -160,7 +139,7 @@ static inline int
 Px (int x)
 {  
   int rv = x * gport->zoom + gport->view_x0;
-  if (ghid_flip_x)
+  if (hidgl_flip_x)
     rv = PCB->MaxWidth - (x * gport->zoom + gport->view_x0);
   return  rv;
 }  
@@ -169,7 +148,7 @@ static inline int
 Py (int y)
 {  
   int rv = y * gport->zoom + gport->view_y0;
-  if (ghid_flip_y)
+  if (hidgl_flip_y)
     rv = PCB->MaxHeight - (y * gport->zoom + gport->view_y0);
   return  rv;
 }  
@@ -182,258 +161,6 @@ Pz (int z)
 
 /* ------------------------------------------------------------ */
 
-static void
-ghid_pan_fixup ()
-{
-
-  /* 
-   * don't pan so far to the right that we see way past the right 
-   * edge of the board.
-   */
-  if (gport->view_x0 > PCB->MaxWidth - gport->view_width)
-    gport->view_x0 = PCB->MaxWidth - gport->view_width;
-
-  /* 
-   * don't pan so far down that we see way past the bottom edge of
-   * the board.
-   */
-  if (gport->view_y0 > PCB->MaxHeight - gport->view_height)
-    gport->view_y0 = PCB->MaxHeight - gport->view_height;
-
-  /* don't view above or to the left of the board... ever */
-  if (gport->view_x0 < 0)
-    gport->view_x0 = 0;
-
-   if (gport->view_y0 < 0)
-    gport->view_y0 = 0;
-
-
-   /* if we can see the entire board and some, then zoom to fit */
-   if (gport->view_width > PCB->MaxWidth &&
-       gport->view_height > PCB->MaxHeight)
-     {
-       zoom_by (1, 0, 0);
-       return;
-     }
-
-   gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view_x0);
-   gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view_y0);
-
-   ghid_invalidate_all ();
-
-}
-
-/* ------------------------------------------------------------ */
-
-static const char zoom_syntax[] =
-"Zoom()\n"
-"Zoom(factor)";
-
-
-static const char zoom_help[] =
-"Various zoom factor changes.";
-
-/* %start-doc actions Zoom
-Changes the zoom (magnification) of the view of the board.  If no
-arguments are passed, the view is scaled such that the board just fits
-inside the visible window (i.e. ``view all'').  Otherwise,
-@var{factor} specifies a change in zoom factor.  It may be prefixed by
-@code{+}, @code{-}, or @code{=} to change how the zoom factor is
-modified.  The @var{factor} is a floating point number, such as
-@code{1.5} or @code{0.75}.
-
-@table @code
-  
-@item +@var{factor}
-Values greater than 1.0 cause the board to be drawn smaller; more of
-the board will be visible.  Values between 0.0 and 1.0 cause the board
-to be drawn bigger; less of the board will be visible.
-  
-@item -@var{factor}
-Values greater than 1.0 cause the board to be drawn bigger; less of
-the board will be visible.  Values between 0.0 and 1.0 cause the board
-to be drawn smaller; more of the board will be visible.
- 
-@item =@var{factor}
- 
-The @var{factor} is an absolute zoom factor; the unit for this value
-is "PCB units per screen pixel".  Since PCB units are 0.01 mil, a
-@var{factor} of 1000 means 10 mils (0.01 in) per pixel, or 100 DPI,
-about the actual resolution of most screens - resulting in an "actual
-size" board.  Similarly, a @var{factor} of 100 gives you a 10x actual
-size.
- 
-@end table
- 
-Note that zoom factors of zero are silently ignored.
- 
-
-
-%end-doc */
-
-static int
-Zoom (int argc, char **argv, int x, int y)
-{
-  double factor;
-  const char *vp;
-  double v;
-
-  if (argc > 1)
-    AFAIL (zoom);
-
-  if (x == 0 && y == 0)
-    {
-      x = gport->view_width / 2;
-      y = gport->view_height / 2;
-    }
-  else
-    {
-      /* Px converts view->pcb, Vx converts pcb->view */
-      x = Vx (x);
-      y = Vy (y);
-    }
-
-  if (argc < 1)
-    {
-      zoom_to (1000000, 0, 0);
-      return 0;
-    }
-
-  vp = argv[0];
-  if (*vp == '+' || *vp == '-' || *vp == '=')
-    vp++;
-  v = strtod (vp, 0);
-  if (v <= 0)
-    return 1;
-  switch (argv[0][0])
-    {
-    case '-':
-      factor = 1 / v;
-      zoom_by (1 / v, x, y);
-      break;
-    default:
-    case '+':
-      factor = v;
-      zoom_by (v, x, y);
-      break;
-    case '=':
-      /* this needs to set the scale factor absolutely*/
-      factor = 1.0;
-      zoom_to (v, x, y);
-      break;
-    }
-
-  return 0;
-}
-
-
-static void
-zoom_to (double new_zoom, int x, int y)
-{
-  double max_zoom, xfrac, yfrac;
-  int cx, cy;
-
-  /* gport->zoom:
-   * zoom value is PCB units per screen pixel.  Larger numbers mean zooming
-   * out - the largest value means you are looking at the whole board.
-   *
-   * PCB units per screen pixel
-   *
-   * gport->view_width and gport->view_height are in PCB coordinates
-   */
-
-#ifdef DEBUG
-  printf ("\nzoom_to( %g, %d, %d)\n", new_zoom, x, y);
-#endif
-
-  xfrac = (double) x / (double) gport->view_width;
-  yfrac = (double) y / (double) gport->view_height;
-
-  if (ghid_flip_x)
-    xfrac = 1-xfrac;
-  if (ghid_flip_y)
-    yfrac = 1-yfrac;
-
-  /* Find the zoom that would just make the entire board fit */
-  max_zoom = PCB->MaxWidth / gport->width;
-  if (max_zoom < PCB->MaxHeight / gport->height)
-    max_zoom = PCB->MaxHeight / gport->height;
-
-#ifdef DEBUG
-  printf ("zoom_to():  max_zoom = %g\n", max_zoom);
-#endif
-
-  /* 
-   * clip the zooming so we can never have more than 1 pixel per PCB
-   * unit and never zoom out more than viewing the entire board
-   */
-     
-  if (new_zoom < 1)
-    new_zoom = 1;
-  if (new_zoom > max_zoom)
-    new_zoom = max_zoom;
-
-#ifdef DEBUG
-  printf ("max_zoom = %g, xfrac = %g, yfrac = %g, new_zoom = %g\n", 
-	  max_zoom, xfrac, yfrac, new_zoom);
-#endif
-
-  /* find center x and y */
-  cx = gport->view_x0 + gport->view_width * xfrac * gport->zoom;
-  cy = gport->view_y0 + gport->view_height * yfrac * gport->zoom;
-
-#ifdef DEBUG
-  printf ("zoom_to():  x0 = %d, cx = %d\n", gport->view_x0, cx);
-  printf ("zoom_to():  y0 = %d, cy = %d\n", gport->view_y0, cy);
-#endif
-
-  if (gport->zoom != new_zoom)
-    {
-      gdouble xtmp, ytmp;
-      gint x0, y0;
-
-      xtmp = (gport->view_x - gport->view_x0) / (gdouble) gport->view_width;
-      ytmp = (gport->view_y - gport->view_y0) / (gdouble) gport->view_height;
-      
-      gport->zoom = new_zoom;
-      pixel_slop = new_zoom;
-      ghid_port_ranges_scale(FALSE);
-
-      x0 = gport->view_x - xtmp * gport->view_width;
-      if (x0 < 0)
-	x0 = 0;
-      gport->view_x0 = x0;
-
-      y0 = gport->view_y - ytmp * gport->view_height;
-      if (y0 < 0)
-	y0 = 0;
-      gport->view_y0 = y0;
-      
-      ghidgui->adjustment_changed_holdoff = TRUE;
-      gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view_x0);
-      gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view_y0);
-      ghidgui->adjustment_changed_holdoff = FALSE;
-      
-      ghid_port_ranges_changed();
-    }
-
-#ifdef DEBUG
-  printf ("zoom_to():  new x0 = %d\n", gport->view_x0);
-  printf ("zoom_to():  new y0 = %d\n", gport->view_y0);
-#endif
-  ghid_set_status_line_label ();
-}
-
-void
-zoom_by (double factor, int x, int y)
-{
-#ifdef DEBUG
-  printf ("\nzoom_by( %g, %d, %d).  old gport->zoom = %g\n", 
-	  factor, x, y, gport->zoom);
-#endif
-  zoom_to (gport->zoom * factor, x, y);
-}
-
 /* ------------------------------------------------------------ */
 
 /*static*/ void
@@ -456,7 +183,7 @@ draw_grid ()
       gport->grid_color.blue ^= gport->bg_color.blue;
     }
 
-  ghid_flush_triangles ();
+  hidgl_flush_triangles ();
 
   glEnable (GL_COLOR_LOGIC_OP);
   glLogicOp (GL_XOR);
@@ -521,105 +248,9 @@ draw_grid ()
 
 /* ------------------------------------------------------------ */
 
-HID_Attribute *
-ghid_get_export_options (int *n_ret)
-{
-  return NULL;
-}
-
-
-void
-ghid_invalidate_wh (int x, int y, int width, int height, int last)
-{
-  ghid_invalidate_all ();
-}
-
-void
-ghid_invalidate_lr (int left, int right, int top, int bottom, int last)
-{
-  ghid_invalidate_all ();
-}
-
-#if 0
-static void
-ghid_draw_bg_image(void)
-{
-  static GdkPixbuf *pixbuf = NULL;
-  static gint vw_scaled, vh_scaled, x_cached, y_cached;
-  GdkInterpType interp_type;
-  gint x, y, vw, vh, w, h, w_src, h_src;
-  int bits_per_sample;
-  gboolean has_alpha;
-
-  if (!ghidgui->bg_pixbuf)
-    return;
-
-  w = PCB->MaxWidth / gport->zoom;
-  h = PCB->MaxHeight / gport->zoom;
-  x = gport->view_x0 / gport->zoom;
-  y = gport->view_y0 / gport->zoom;
-  vw = gport->view_width / gport->zoom;
-  vh = gport->view_height / gport->zoom;
-
-  if (pixbuf == NULL || vw_scaled != vw || vh_scaled != vh)
-    {
-      if (pixbuf != NULL)
-        g_object_unref(G_OBJECT(pixbuf));
-
-      bits_per_sample = gdk_pixbuf_get_bits_per_sample(ghidgui->bg_pixbuf);
-      has_alpha = gdk_pixbuf_get_has_alpha (ghidgui->bg_pixbuf);
-      pixbuf = gdk_pixbuf_new(GDK_COLORSPACE_RGB,
-                              has_alpha,
-                              bits_per_sample,
-                              vw, vh);
-    }
-
-  if (pixbuf == NULL)
-    return;
-
-  if (vw_scaled != vw || vh_scaled != vh ||
-       x_cached != x  ||  y_cached != y)
-    {
-      w_src = gdk_pixbuf_get_width(ghidgui->bg_pixbuf);
-      h_src = gdk_pixbuf_get_height(ghidgui->bg_pixbuf);
-
-      if (w > w_src && h > h_src)
-        interp_type = GDK_INTERP_NEAREST;
-      else
-        interp_type = GDK_INTERP_BILINEAR;
-
-      gdk_pixbuf_scale(ghidgui->bg_pixbuf, pixbuf,
-                       0, 0, vw, vh,
-                       (double) -x,
-                       (double) -y,
-                       (double) w / w_src,
-                       (double) h / h_src,
-                       interp_type);
-
-      x_cached = x;
-      y_cached = y;
-      vw_scaled = vw;
-      vh_scaled = vh;
-    }
-
-  if (pixbuf != NULL)
-    gdk_draw_pixbuf(gport->drawable, gport->bg_gc, pixbuf,
-                    0, 0, 0, 0, vw, vh, GDK_RGB_DITHER_NORMAL, 0, 0);
-}
-#endif
-
-void
-ghid_invalidate_all ()
-{
-  if (ghidgui->need_restore_crosshair)
-    RestoreCrosshair (FALSE);
-  ghidgui->need_restore_crosshair = FALSE;
-  gdk_window_invalidate_rect (gport->drawing_area->window, NULL, 1);
-}
-
 
 int
-ghid_set_layer (const char *name, int group, int empty)
+hidgl_set_layer (const char *name, int group, int empty)
 {
   int idx = (group >= 0
 	     && group <
@@ -659,12 +290,12 @@ ghid_set_layer (const char *name, int group, int empty)
 }
 
 void
-ghid_use_mask (int use_it)
+hidgl_use_mask (int use_it)
 {
   if (use_it == cur_mask)
     return;
 
-  ghid_flush_triangles ();
+  hidgl_flush_triangles ();
 
   switch (use_it)
     {
@@ -697,18 +328,12 @@ ghid_use_mask (int use_it)
   cur_mask = use_it;
 }
 
-void
-ghid_extents_use_mask (int use_it)
-{
-}
-
-
 typedef struct
 {
   int color_set;
-  GdkColor color;
+//  GdkColor color;
   int xor_set;
-  GdkColor xor_color;
+//  GdkColor xor_color;
   double red;
   double green;
   double blue;
@@ -730,29 +355,29 @@ set_special_grid_color (void)
 }
 
 void
-ghid_set_special_colors (HID_Attribute * ha)
+hidgl_set_special_colors (HID_Attribute * ha)
 {
   if (!ha->name || !ha->value)
     return;
   if (!strcmp (ha->name, "background-color"))
     {
-      ghid_map_color_string (*(char **) ha->value, &gport->bg_color);
+      hidgl_map_color_string (*(char **) ha->value, &gport->bg_color);
       set_special_grid_color ();
     }
   else if (!strcmp (ha->name, "off-limit-color"))
   {
-      ghid_map_color_string (*(char **) ha->value, &gport->offlimits_color);
+      hidgl_map_color_string (*(char **) ha->value, &gport->offlimits_color);
     }
   else if (!strcmp (ha->name, "grid-color"))
     {
-      ghid_map_color_string (*(char **) ha->value, &gport->grid_color);
+      hidgl_map_color_string (*(char **) ha->value, &gport->grid_color);
       set_special_grid_color ();
     }
 }
 
 
 void
-ghid_set_color (hidGC gc, const char *name)
+hidgl_set_color (hidGC gc, const char *name)
 {
   static void *cache = NULL;
   static char *old_name = NULL;
@@ -856,15 +481,15 @@ ghid_set_color (hidGC gc, const char *name)
 #endif
   }
 
-  if( ! ghid_gui_is_up )
+  if( ! hidgl_gui_is_up )
     return;
 
-  ghid_flush_triangles ();
+  hidgl_flush_triangles ();
   glColor4d (r, g, b, a);
 }
 
 void
-ghid_set_line_cap (hidGC gc, EndCapStyle style)
+hidgl_set_line_cap (hidGC gc, EndCapStyle style)
 {
   switch (style)
     {
@@ -882,15 +507,15 @@ ghid_set_line_cap (hidGC gc, EndCapStyle style)
 }
 
 void
-ghid_set_line_width (hidGC gc, int width)
+hidgl_set_line_width (hidGC gc, int width)
 {
   gc->width = width;
 }
 
 void
-ghid_set_draw_xor (hidGC gc, int xor)
+hidgl_set_draw_xor (hidGC gc, int xor)
 {
-  // printf ("ghid_set_draw_xor (%p, %d) -- not implemented\n", gc, xor);
+  // printf ("hidgl_set_draw_xor (%p, %d) -- not implemented\n", gc, xor);
   /* NOT IMPLEMENTED */
 
   /* Only presently called when setting up a crosshair GC.
@@ -898,15 +523,15 @@ ghid_set_draw_xor (hidGC gc, int xor)
 }
 
 void
-ghid_set_draw_faded (hidGC gc, int faded)
+hidgl_set_draw_faded (hidGC gc, int faded)
 {
-  printf ("ghid_set_draw_faded(%p,%d) -- not implemented\n", gc, faded);
+  printf ("hidgl_set_draw_faded(%p,%d) -- not implemented\n", gc, faded);
 }
 
 void
-ghid_set_line_cap_angle (hidGC gc, int x1, int y1, int x2, int y2)
+hidgl_set_line_cap_angle (hidGC gc, int x1, int y1, int x2, int y2)
 {
-  printf ("ghid_set_line_cap_angle() -- not implemented\n");
+  printf ("hidgl_set_line_cap_angle() -- not implemented\n");
 }
 
 static void
@@ -919,7 +544,7 @@ use_gc (hidGC gc)
 
   current_gc = gc;
 
-  ghid_set_color (gc, gc->colorname);
+  hidgl_set_color (gc, gc->colorname);
 }
 
 void
@@ -934,7 +559,7 @@ errorCallback(GLenum errorCode)
 
 
 void
-ghid_draw_line (hidGC gc, int x1, int y1, int x2, int y2)
+hidgl_draw_line (hidGC gc, int x1, int y1, int x2, int y2)
 {
 #define TRIANGLES_PER_CAP 15
 #define MIN_TRIANGLES_PER_CAP 3
@@ -1046,12 +671,12 @@ ghid_draw_line (hidGC gc, int x1, int y1, int x2, int y2)
 }
 
 void
-ghid_draw_arc (hidGC gc, int cx, int cy,
+hidgl_draw_arc (hidGC gc, int cx, int cy,
                int xradius, int yradius, int start_angle, int delta_angle)
 {
 #define MIN_SLICES_PER_ARC 10
-  gint vrx, vry;
-  gint w, h, radius, slices;
+  int vrx, vry;
+  int w, h, radius, slices;
   double width;
   GLUquadricObj *qobj;
 
@@ -1073,12 +698,12 @@ ghid_draw_arc (hidGC gc, int cx, int cy,
   vrx = Vz (xradius);
   vry = Vz (yradius);
 
-  if (ghid_flip_x)
+  if (hidgl_flip_x)
     {
       start_angle = 180 - start_angle;
       delta_angle = - delta_angle;
     }
-  if (ghid_flip_y)
+  if (hidgl_flip_y)
     {
       start_angle = - start_angle;
       delta_angle = - delta_angle;					
@@ -1130,9 +755,9 @@ ghid_draw_arc (hidGC gc, int cx, int cy,
 }
 
 void
-ghid_draw_rect (hidGC gc, int x1, int y1, int x2, int y2)
+hidgl_draw_rect (hidGC gc, int x1, int y1, int x2, int y2)
 {
-  gint w, h, lw;
+  int w, h, lw;
 
   lw = gc->width;
   w = gport->width * gport->zoom;
@@ -1165,12 +790,12 @@ ghid_draw_rect (hidGC gc, int x1, int y1, int x2, int y2)
 
 
 void
-ghid_fill_circle (hidGC gc, int cx, int cy, int radius)
+hidgl_fill_circle (hidGC gc, int cx, int cy, int radius)
 {
 #define TRIANGLES_PER_CIRCLE 30
 #define MIN_TRIANGLES_PER_CIRCLE 6
 #define MAX_TRIANGLES_PER_CIRCLE 2000
-  gint w, h, vx, vy, vr;
+  int w, h, vx, vy, vr;
   float last_x, last_y;
   int slices;
   int i;
@@ -1326,7 +951,7 @@ myVertex (GLdouble *vertex_data)
 }
 
 void
-ghid_fill_polygon (hidGC gc, int n_coords, int *x, int *y)
+hidgl_fill_polygon (hidGC gc, int n_coords, int *x, int *y)
 {
   int i;
 
@@ -1335,7 +960,7 @@ ghid_fill_polygon (hidGC gc, int n_coords, int *x, int *y)
 
   USE_GC (gc);
 
-  g_assert (n_coords > 0);
+  assert (n_coords > 0);
 
   vertices = malloc (sizeof(GLdouble) * n_coords * 3);
 
@@ -1365,9 +990,9 @@ ghid_fill_polygon (hidGC gc, int n_coords, int *x, int *y)
 }
 
 void
-ghid_fill_rect (hidGC gc, int x1, int y1, int x2, int y2)
+hidgl_fill_rect (hidGC gc, int x1, int y1, int x2, int y2)
 {
-  gint w, h, lw;
+  int w, h, lw;
 
   lw = gc->width;
   w = gport->width * gport->zoom;
@@ -1397,490 +1022,12 @@ ghid_fill_rect (hidGC gc, int x1, int y1, int x2, int y2)
   glEnd ();
 }
 
-void
-ghid_extents_draw_line (hidGC gc, int x1, int y1, int x2, int y2)
-{
-  printf ("ghid_extents_draw_line() -- not implemented\n");
-}
-
-void
-ghid_extents_draw_arc (hidGC gc, int cx, int cy,
-		       int xradius, int yradius,
-		       int start_angle, int delta_angle)
-{
-  printf ("ghid_extents_draw_arc() -- not implemented\n");
-}
-
-void
-ghid_extents_draw_rect (hidGC gc, int x1, int y1, int x2, int y2)
-{
-  printf ("ghid_extents_draw_rect() -- not implemented\n");
-}
-
-void
-ghid_extents_fill_circle (hidGC gc, int cx, int cy, int radius)
-{
-  printf ("ghid_extents_fill_circle() -- not implemented\n");
-}
-
-void
-ghid_extents_fill_polygon (hidGC gc, int n_coords, int *x, int *y)
-{
-  printf ("ghid_extents_fill_polygon() -- not implemented\n");
-}
-
-void
-ghid_extents_fill_rect (hidGC gc, int x1, int y1, int x2, int y2)
-{
-  printf ("ghid_extents_fill_rect() -- not implemented\n");
-}
-
-void
-ghid_calibrate (double xval, double yval)
-{
-  printf ("ghid_calibrate() -- not implemented\n");
-}
-
-static int ghid_gui_is_up = 0;
-
-void
-ghid_notify_gui_is_up ()
-{
-  ghid_gui_is_up = 1;
-}
-
-int
-ghid_shift_is_pressed ()
-{
-  GdkModifierType mask;
-  GHidPort *out = &ghid_port;
-
-  if( ! ghid_gui_is_up ) 
-    return 0;
-
-  gdk_window_get_pointer (out->drawing_area->window, NULL, NULL, &mask);
-  return (mask & GDK_SHIFT_MASK) ? TRUE : FALSE;
-}
-
-int
-ghid_control_is_pressed ()
-{
-  GdkModifierType mask;
-  GHidPort *out = &ghid_port;
-
-  if( ! ghid_gui_is_up )
-    return 0;
-
-  gdk_window_get_pointer (out->drawing_area->window, NULL, NULL, &mask);
-  return (mask & GDK_CONTROL_MASK) ? TRUE : FALSE;
-}
-
-void
-ghid_set_crosshair (int x, int y, int action)
-{
-  if (gport->x_crosshair != x || gport->y_crosshair != y)
-    {
-      ghid_set_cursor_position_labels ();
-      gport->x_crosshair = x;
-      gport->y_crosshair = y;
-
-      /*
-       * FIXME - does this trigger the idle_proc stuff?  It is in the
-       * lesstif HID.  Maybe something is needed here?
-       *
-       * need_idle_proc ();
-       */
-
-    }
-
-  /*
-   * Pan the viewport so that the crosshair (which is in a fixed
-   * location relative to the board) lands where the pointer
-   * is.  What happens is the crosshair is moved on the board
-   * (see above) and then we move the board here to line it up
-   * again.  We do this by figuring out where the pointer is
-   * in board coordinates and we know where the crosshair is
-   * in board coordinates.  Then we know how far to pan.
-   */
-  if (action == HID_SC_PAN_VIEWPORT)
-    {
-      GdkDisplay *display;
-      GdkScreen *screen;
-      gint pos_x, pos_y, xofs, yofs;
-      
-      display = gdk_display_get_default ();
-      screen = gdk_display_get_default_screen (display); 
-      
-      /* figure out where the pointer is relative to the display */ 
-      gdk_display_get_pointer (display, NULL, &pos_x, &pos_y, NULL); 
-      
-      /*
-       * Figure out where the drawing area is on the screen so we can
-       * figure out where the pointer is relative to the viewport.
-       */ 
-      gdk_window_get_origin (gport->drawing_area->window, &xofs, &yofs);
-      
-      pos_x -= xofs;
-      pos_y -= yofs;
-
-      /*
-       * pointer is at
-       *  px = gport->view_x0 + pos_x * gport->zoom
-       *  py = gport->view_y0 + pos_y * gport->zoom
-       *
-       * cross hair is at
-       *  x
-       *  y
-       *
-       * we need to shift x0 by (x - px) and y0 by (y - py)
-       * x0 = x0 + x - (x0 + pos_x * zoom)
-       *    = x - pos_x*zoom
-       */
-
-      if (ghid_flip_x)
-        gport->view_x0 = x - (gport->view_width - pos_x * gport->zoom);
-      else
-        gport->view_x0 = x - pos_x * gport->zoom;
-
-      if (ghid_flip_y)
-        gport->view_y0 = y - (gport->view_height - pos_y * gport->zoom);
-      else
-        gport->view_y0 = y - pos_y * gport->zoom;
-
-      ghid_pan_fixup();
-
-      action = HID_SC_WARP_POINTER;
-    }
-
-  if (action == HID_SC_WARP_POINTER)
-    {
-#if GTK_CHECK_VERSION(2,8,0)
-    gint xofs, yofs;
-    GdkDisplay *display;
-    GdkScreen *screen;
-
-    display = gdk_display_get_default ();
-    screen = gdk_display_get_default_screen (display); 
-
-    /*
-     * Figure out where the drawing area is on the screen because
-     * gdk_display_warp_pointer will warp relative to the whole display
-     * but the value we've been given is relative to your drawing area
-     */ 
-    gdk_window_get_origin (gport->drawing_area->window, &xofs, &yofs);
-
-    /* 
-     * Note that under X11, gdk_display_warp_pointer is just a wrapper around XWarpPointer, but
-     * hopefully by avoiding the direct call to an X function we might still work under windows
-     * and other non-X11 based gdk's
-     */
-    gdk_display_warp_pointer (display, screen, xofs + Vx2 (x), yofs + Vy2 (y));
-
-
-#else
-#  ifdef HAVE_GDK_GDKX_H
-    gint xofs, yofs;
-    gdk_window_get_origin (gport->drawing_area->window, &xofs, &yofs);
-    XWarpPointer (GDK_DRAWABLE_XDISPLAY (gport->drawing_area->window),
-		  None, GDK_WINDOW_XID (gport->drawing_area->window),
-		  0, 0, 0, 0,
-		  xofs + Vx2 (x), yofs + Vy2 (y));
-#  else
-#    error  "sorry.  You need gtk+>=2.8.0 unless you are on X windows"
-#  endif
-#endif
-    }
-}
-
-typedef struct
-{
-  void (*func) ();
-  gint id;
-  hidval user_data;
-}
-GuiTimer;
-
-  /* We need a wrapper around the hid timer because a gtk timer needs
-     |  to return FALSE else the timer will be restarted.
-   */
-static gboolean
-ghid_timer (GuiTimer * timer)
-{
-  (*timer->func) (timer->user_data);
-  ghid_mode_cursor (Settings.Mode);
-  return FALSE;			/* Turns timer off */
-}
-
-hidval
-ghid_add_timer (void (*func) (hidval user_data),
-		unsigned long milliseconds, hidval user_data)
-{
-  GuiTimer *timer = g_new0 (GuiTimer, 1);
-  hidval ret;
-
-  timer->func = func;
-  timer->user_data = user_data;
-  timer->id = gtk_timeout_add (milliseconds, (GtkFunction) ghid_timer, timer);
-  ret.ptr = (void *) timer;
-  return ret;
-}
-
-void
-ghid_stop_timer (hidval timer)
-{
-  void *ptr = timer.ptr;
-
-  gtk_timeout_remove (((GuiTimer *) ptr)->id);
-  g_free( ptr );
-}
-
-typedef struct
-{
-  void (*func) ( hidval, int, unsigned int, hidval );
-  hidval user_data;
-  int fd;
-  GIOChannel *channel;
-  gint id;
-}
-GuiWatch;
-
-  /* We need a wrapper around the hid file watch to pass the correct flags
-   */
-static gboolean
-ghid_watch (GIOChannel *source, GIOCondition condition, gpointer data)
-{
-  unsigned int pcb_condition = 0;
-  hidval x;
-  GuiWatch *watch = (GuiWatch*)data;
-
-  if (condition & G_IO_IN)
-    pcb_condition |= PCB_WATCH_READABLE;
-  if (condition & G_IO_OUT)
-    pcb_condition |= PCB_WATCH_WRITABLE;
-  if (condition & G_IO_ERR)
-    pcb_condition |= PCB_WATCH_ERROR;
-  if (condition & G_IO_HUP)
-    pcb_condition |= PCB_WATCH_HANGUP;
-
-  x.ptr = (void *) watch;
-  watch->func (x, watch->fd, pcb_condition, watch->user_data);
-  ghid_mode_cursor (Settings.Mode);
-
-  return TRUE;  /* Leave watch on */
-}
-
-hidval
-ghid_watch_file (int fd, unsigned int condition, void (*func) (hidval watch, int fd, unsigned int condition, hidval user_data),
-  hidval user_data)
-{
-  GuiWatch *watch = g_new0 (GuiWatch, 1);
-  hidval ret;
-  unsigned int glib_condition = 0;
-
-  if (condition & PCB_WATCH_READABLE)
-    glib_condition |= G_IO_IN;
-  if (condition & PCB_WATCH_WRITABLE)
-    glib_condition |= G_IO_OUT;
-  if (condition & PCB_WATCH_ERROR)
-    glib_condition |= G_IO_ERR;
-  if (condition & PCB_WATCH_HANGUP)
-    glib_condition |= G_IO_HUP;
-
-  watch->func = func;
-  watch->user_data = user_data;
-  watch->fd = fd;
-  watch->channel = g_io_channel_unix_new( fd );
-  watch->id = g_io_add_watch( watch->channel, glib_condition, ghid_watch, watch );
-
-  ret.ptr = (void *) watch;
-  return ret;
-}
-
-void
-ghid_unwatch_file (hidval data)
-{
-  GuiWatch *watch = (GuiWatch*)data.ptr;
-
-  g_io_channel_shutdown( watch->channel, TRUE, NULL ); 
-  g_io_channel_unref( watch->channel );
-  g_free( watch );
-}
-
-typedef struct
-{
-  GSource source;
-  void (*func) (hidval user_data);
-  hidval user_data; 
-} BlockHookSource;
-
-static gboolean ghid_block_hook_prepare  (GSource     *source,
-                                             gint     *timeout);
-static gboolean ghid_block_hook_check    (GSource     *source);
-static gboolean ghid_block_hook_dispatch (GSource     *source,
-                                          GSourceFunc  callback,
-                                          gpointer     user_data);
-
-static GSourceFuncs ghid_block_hook_funcs = {
-  ghid_block_hook_prepare,
-  ghid_block_hook_check,
-  ghid_block_hook_dispatch,
-  NULL // No destroy notification
-};
-
-static gboolean
-ghid_block_hook_prepare (GSource *source,
-                         gint    *timeout)
-{
-  hidval data = ((BlockHookSource *)source)->user_data;
-  ((BlockHookSource *)source)->func( data );
-  return FALSE;
-}
-
-static gboolean
-ghid_block_hook_check (GSource *source)
-{
-  return FALSE;
-}
-
-static gboolean
-ghid_block_hook_dispatch (GSource     *source,
-                          GSourceFunc  callback,
-                          gpointer     user_data)
-{
-  return FALSE;
-}
-
-static hidval
-ghid_add_block_hook (void (*func) (hidval data),
-                     hidval user_data)
-{
-  hidval ret;
-  BlockHookSource *source;
-
-  source = (BlockHookSource *)g_source_new (&ghid_block_hook_funcs, sizeof( BlockHookSource ));
-
-  source->func = func;
-  source->user_data = user_data;
-
-  g_source_attach ((GSource *)source, NULL);
-
-  ret.ptr = (void *) source;
-  return ret;
-}
-
-static void
-ghid_stop_block_hook (hidval mlpoll)
-{
-  GSource *source = (GSource *)mlpoll.ptr;
-  g_source_destroy( source );
-}
-
-int
-ghid_confirm_dialog (char *msg, ...)
-{
-  int rv;
-  va_list ap;
-  char *cancelmsg = NULL, *okmsg = NULL;
-
-  va_start (ap, msg);
-  cancelmsg = va_arg (ap, char *);
-  okmsg = va_arg (ap, char *);
-  va_end (ap);
-
-  if (!cancelmsg)
-    {
-      cancelmsg = _("_Cancel");
-      okmsg = _("_OK");
-    }
-  if (!okmsg)
-    {
-      okmsg = _("_OK");
-    }
-
-  rv = ghid_dialog_confirm (msg, cancelmsg, okmsg);
-
-  return rv;
-}
-
-int
-ghid_close_confirm_dialog ()
-{
-  switch (ghid_dialog_close_confirm ())
-    {
-    case GUI_DIALOG_CLOSE_CONFIRM_SAVE:
-      {
-        if (hid_actionl ("Save", NULL))
-          { /* Save failed */
-            return 0; /* Cancel */
-          } else {
-            return 1; /* Close */
-          }
-      }
-    case GUI_DIALOG_CLOSE_CONFIRM_NOSAVE:
-      {
-        return 1; /* Close */
-      }
-    case GUI_DIALOG_CLOSE_CONFIRM_CANCEL:
-    default:
-      {
-        return 0; /* Cancel */
-      }
-    }
-}
-
-void
-ghid_report_dialog (char *title, char *msg)
-{
-  ghid_dialog_report (title, msg);
-}
-
-char *
-ghid_prompt_for (char *msg, char *default_string)
-{
-  char *rv;
-
-  rv = ghid_dialog_input (msg, default_string);
-  return rv;
-}
-
-/* FIXME -- implement a proper file select dialog */
-#ifdef FIXME
-char *
-ghid_fileselect (const char *title, const char *descr,
-		 char *default_file, char *default_ext,
-		 const char *history_tag, int flags)
-{
-  char *rv;
-
-  rv = ghid_dialog_input (title, default_file);
-  return rv;
-}
-#endif
-
-void
-ghid_show_item (void *item)
-{
-  ghid_pinout_window_show (&ghid_port, (ElementTypePtr) item);
-}
-
-void
-ghid_beep ()
-{
-  gdk_beep ();
-}
-
-static int
-ghid_progress (int so_far, int total, const char *message)
-{
-  return 0;
-}
-
 /* ---------------------------------------------------------------------- */
 
-HID ghid_hid = {
+HID hidgl_hid = {
   sizeof (HID),
-  "gtk",
-  "Gtk - The Gimp Toolkit",
+  "",
+  "",
   1,				/* gui */
   0,				/* printer */
   0,				/* exporter */
@@ -1888,1110 +1035,52 @@ HID ghid_hid = {
   1,				/* poly after */
   0,				/* poly dicer */
 
-  ghid_get_export_options,
-  ghid_do_export,
-  ghid_parse_arguments,
-
-  ghid_invalidate_wh,
-  ghid_invalidate_lr,
-  ghid_invalidate_all,
-  ghid_set_layer,
-  ghid_make_gc,
-  ghid_destroy_gc,
-  ghid_use_mask,
-  ghid_set_color,
-  ghid_set_line_cap,
-  ghid_set_line_width,
-  ghid_set_draw_xor,
-  ghid_set_draw_faded,
-  ghid_set_line_cap_angle,
-  ghid_draw_line,
-  ghid_draw_arc,
-  ghid_draw_rect,
-  ghid_fill_circle,
-  ghid_fill_polygon,
-  ghid_fill_rect,
-
-  ghid_calibrate,
-  ghid_shift_is_pressed,
-  ghid_control_is_pressed,
-  ghid_get_coords,
-  ghid_set_crosshair,
-  ghid_add_timer,
-  ghid_stop_timer,
-  ghid_watch_file,
-  ghid_unwatch_file,
-  ghid_add_block_hook,
-  ghid_stop_block_hook,
-
-  ghid_log,
-  ghid_logv,
-  ghid_confirm_dialog,
-  ghid_close_confirm_dialog,
-  ghid_report_dialog,
-  ghid_prompt_for,
-  ghid_fileselect,
-  ghid_attribute_dialog,
-  ghid_show_item,
-  ghid_beep,
-  ghid_progress
-};
-
-HID ghid_extents = {
-  sizeof (HID),
-  "ghid_extents",
-  "used to calculate extents",
-  1,				/* gui */
-  0,				/* printer */
-  0,				/* exporter */
-  0,				/* poly before */
-  1,				/* poly after */
-  0,				/* poly dicer */
-
-  0 /* ghid_get_export_options */ ,
-  0 /* ghid_do_export */ ,
-  0 /* ghid_parse_arguments */ ,
-
-  0 /* ghid_invalidate_wh */ ,
-  0 /* ghid_invalidate_lr */ ,
-  0 /* ghid_invalidate_all */ ,
-  0 /* ghid_set_layer */ ,
-  0 /* ghid_make_gc */ ,
-  0 /* ghid_destroy_gc */ ,
-  ghid_extents_use_mask,
-  0 /* ghid_set_color */ ,
-  0 /* ghid_set_line_cap */ ,
-  0 /* ghid_set_line_width */ ,
-  0 /* ghid_set_draw_xor */ ,
-  0 /* ghid_set_draw_faded */ ,
-  0 /* ghid_set_line_cap_angle */ ,
-  ghid_extents_draw_line,
-  ghid_extents_draw_arc,
-  ghid_extents_draw_rect,
-  ghid_extents_fill_circle,
-  ghid_extents_fill_polygon,
-  ghid_extents_fill_rect,
-
-  0 /* ghid_calibrate */ ,
-  0 /* ghid_shift_is_pressed */ ,
-  0 /* ghid_control_is_pressed */ ,
-  0 /* ghid_get_coords */ ,
-  0 /* ghid_set_crosshair */ ,
-  0 /* ghid_add_timer */ ,
-  0 /* ghid_stop_timer */ ,
-  0 /* ghid_watch_file */ ,
-  0 /* ghid_unwatch_file */ ,
-  0 /* ghid_add_block_hook */ ,
-  0 /* ghid_stop_block_hook */ ,
-
-  0 /* ghid_log */ ,
-  0 /* ghid_logv */ ,
-  0 /* ghid_confirm_dialog */ ,
-  0 /* ghid_close_confirm_dialog */ ,
-  0 /* ghid_report_dialog */ ,
-  0 /* ghid_prompt_for */ ,
-  0 /* ghid_attribute_dialog */ ,
-  0 /* ghid_show_item */ ,
-  0 /* ghid_beep */ ,
-  0 /* ghid_progress */
-};
-
-/* ------------------------------------------------------------ 
- *
- * Actions specific to the GTK HID follow from here
- *
- */
-
-
-/* ------------------------------------------------------------ */
-static const char about_syntax[] =
-"About()";
-
-static const char about_help[] =
-"Tell the user about this version of PCB.";
-
-/* %start-doc actions About
-
-This just pops up a dialog telling the user which version of
-@code{pcb} they're running.
-
-%end-doc */
-
-
-static int
-About (int argc, char **argv, int x, int y)
-{
-  ghid_dialog_about ();
-  return 0;
-}
-
-/* ------------------------------------------------------------ */
-static const char getxy_syntax[] =
-"GetXY()";
-
-static const char getxy_help[] =
-"Get a coordinate.";
-
-/* %start-doc actions GetXY
-
-Prompts the user for a coordinate, if one is not already selected.
-
-%end-doc */
-
-static int
-GetXY (int argc, char **argv, int x, int y)
-{
-  return 0;
-}
-
-/* ---------------------------------------------------------------------- */
-
-static int PointCursor (int argc, char **argv, int x, int y)
-{
-  if (!ghidgui)
-    return 0;
-
-  if (argc > 0)
-    ghid_point_cursor ();
-  else
-    ghid_mode_cursor (Settings.Mode);
-  return 0;
-}
-
-/* ---------------------------------------------------------------------- */
-
-static int
-RouteStylesChanged (int argc, char **argv, int x, int y)
-{
-  gint n;
-
-  if (PCB && PCB->RouteStyle[0].Name)
-    for (n = 0; n < NUM_STYLES; ++n)
-      ghid_route_style_set_button_label ((&PCB->RouteStyle[n])->Name, n);
-  return 0;
-}
-
-/* ---------------------------------------------------------------------- */
-
-int
-PCBChanged (int argc, char **argv, int x, int y)
-{
-  if (!ghidgui)
-    return 0;
-
-  ghid_window_set_name_label (PCB->Name);
-
-  if (!gport->pixmap)
-    return 0;
-  RouteStylesChanged (0, NULL, 0, 0);
-  ghid_port_ranges_scale (TRUE);
-  ghid_port_ranges_pan (0, 0, FALSE);
-  ghid_port_ranges_zoom (0);
-  ghid_port_ranges_changed ();
-  ghid_sync_with_new_layout ();
-  return 0;
-}
-
-/* ---------------------------------------------------------------------- */
-
-static int
-LayerGroupsChanged (int argc, char **argv, int x, int y)
-{
-  printf ("LayerGroupsChanged -- not implemented\n");
-  return 0;
-}
-
-/* ---------------------------------------------------------------------- */
-
-static int
-LibraryChanged (int argc, char **argv, int x, int y)
-{
-  ghid_library_window_show (&ghid_port, FALSE);
-  return 0;
-}
-
-/* ---------------------------------------------------------------------- */
-
-static int
-Command (int argc, char **argv, int x, int y)
-{
-  ghid_handle_user_command (TRUE);
-  return 0;
-}
-
-/* ---------------------------------------------------------------------- */
-
-static int
-Load (int argc, char **argv, int x, int y)
-{
-  char *function;
-  char *name = NULL;
-
-  static gchar *current_element_dir = NULL;
-  static gchar *current_layout_dir = NULL;
-  static gchar *current_netlist_dir = NULL;
-
-  /* we've been given the file name */
-  if (argc > 1)
-    return hid_actionv ("LoadFrom", argc, argv);
-
-  function = argc ? argv[0] : "Layout";
-
-  if (strcasecmp (function, "Netlist") == 0)
-    {
-      name = ghid_dialog_file_select_open (_("Load netlist file"),
-					   &current_netlist_dir,
-					   Settings.FilePath);
-    }
-  else if (strcasecmp (function, "ElementToBuffer") == 0)
-    {
-      name = ghid_dialog_file_select_open (_("Load element to buffer"),
-					   &current_element_dir,
-					   Settings.LibraryTree);
-    }
-  else if (strcasecmp (function, "LayoutToBuffer") == 0)
-    {
-      name = ghid_dialog_file_select_open (_("Load layout file to buffer"),
-					   &current_layout_dir,
-					   Settings.FilePath);
-    }
-  else if (strcasecmp (function, "Layout") == 0)
-    {
-      name = ghid_dialog_file_select_open (_("Load layout file"),
-					   &current_layout_dir,
-					   Settings.FilePath);
-    }
-
-  if (name)
-    {
-      if (Settings.verbose)
-      	fprintf (stderr, "%s:  Calling LoadFrom(%s, %s)\n", __FUNCTION__,
-		 function, name);
-      hid_actionl ("LoadFrom", function, name, NULL);
-      g_free (name);
-    }
-
-  return 0;
-}
-
-
-/* ---------------------------------------------------------------------- */
-static const char save_syntax[] =
-"Save()\n"
-"Save(Layout|LayoutAs)\n"
-"Save(AllConnections|AllUnusedPins|ElementConnections)\n"
-"Save(PasteBuffer)";
-
-static const char save_help[] =
-"Save layout and/or element data to a user-selected file.";
-
-/* %start-doc actions Save
-
-This action is a GUI front-end to the core's @code{SaveTo} action
-(@pxref{SaveTo Action}).  If you happen to pass a filename, like
-@code{SaveTo}, then @code{SaveTo} is called directly.  Else, the
-user is prompted for a filename to save, and then @code{SaveTo} is
-called with that filename.
-
-%end-doc */
-
-static int
-Save (int argc, char **argv, int x, int y)
-{
-  char *function;
-  char *name;
-  char *prompt;
-
-  static gchar *current_dir = NULL;
-
-  if (argc > 1)
-    return hid_actionv ("SaveTo", argc, argv);
-
-  function = argc ? argv[0] : "Layout";
-
-  if (strcasecmp (function, "Layout") == 0)
-    if (PCB->Filename)
-      return hid_actionl ("SaveTo", "Layout", PCB->Filename, NULL);
-
-  if (strcasecmp (function, "PasteBuffer") == 0)
-    prompt = _("Save element as");
-  else
-    prompt = _("Save layout as");
-  
-  name = ghid_dialog_file_select_save (prompt,
-				       &current_dir,
-				       PCB->Filename, Settings.FilePath);
-  
-  if (name)
-    {
-      FILE *exist;
-      exist = fopen (name, "r");
-      if (exist)
-	{
-	  fclose (exist);
-	  if (ghid_dialog_confirm (_("File exists!  Ok to overwrite?"), NULL, NULL))
-	    {
-	      if (Settings.verbose)
-		fprintf (stderr, "Overwriting %s\n", name);
-	    }
-	  else
-	    {
-	      g_free (name);
-	      return 1;
-	    }
-	}
-      
-      if (Settings.verbose)
-	fprintf (stderr, "%s:  Calling SaveTo(%s, %s)\n", 
-		 __FUNCTION__, function, name);
-      
-      if (strcasecmp (function, "PasteBuffer") == 0)
-	hid_actionl ("PasteBuffer", "Save", name, NULL);
-      else
-	{
-	  /* 
-	   * if we got this far and the function is Layout, then
-	   * we really needed it to be a LayoutAs.  Otherwise 
-	   * ActionSaveTo() will ignore the new file name we
-	   * just obtained.
-	   */
-	  if (strcasecmp (function, "Layout") == 0)
-	    hid_actionl ("SaveTo", "LayoutAs", name, NULL);
-	  else
-	    hid_actionl ("SaveTo", function, name, NULL);
-	}
-      g_free (name);
-    }
-  else
-    {
-      return 1;
-    }
-
-  return 0;
-}
-
-/* ---------------------------------------------------------------------- */
-static const char swapsides_syntax[] =
-"SwapSides(|v|h|r)";
-
-static const char swapsides_help[] =
-"Swaps the side of the board you're looking at.";
-
-/* %start-doc actions SwapSides
-
-This action changes the way you view the board.
-
-@table @code
-
-@item v
-Flips the board over vertically (up/down).
-
-@item h
-Flips the board over horizontally (left/right), like flipping pages in
-a book.
-
-@item r
-Rotates the board 180 degrees without changing sides.
-
-@end table
-
-If no argument is given, the board isn't moved but the opposite side
-is shown.
-
-Normally, this action changes which pads and silk layer are drawn as
-true silk, and which are drawn as the "invisible" layer.  It also
-determines which solder mask you see.
-
-As a special case, if the layer group for the side you're looking at
-is visible and currently active, and the layer group for the opposite
-is not visible (i.e. disabled), then this action will also swap which
-layer group is visible and active, effectively swapping the ``working
-side'' of the board.
-
-%end-doc */
-
-
-static int
-SwapSides (int argc, char **argv, int x, int y)
-{
-  gint flipd;
-  int do_flip_x = 0;
-  int do_flip_y = 0;
-  int comp_group = GetLayerGroupNumberByNumber (max_layer + COMPONENT_LAYER);
-  int solder_group = GetLayerGroupNumberByNumber (max_layer + SOLDER_LAYER);
-  int active_group = GetLayerGroupNumberByNumber (LayerStack[0]);
-  int comp_showing =
-    PCB->Data->Layer[PCB->LayerGroups.Entries[comp_group][0]].On;
-  int solder_showing =
-    PCB->Data->Layer[PCB->LayerGroups.Entries[solder_group][0]].On;
-
-
-  if (argc > 0)
-    {
-      switch (argv[0][0]) {
-      case 'h':
-      case 'H':
-	ghid_flip_x = ! ghid_flip_x;
-	do_flip_x = 1;
-	break;
-      case 'v':
-      case 'V':
-	ghid_flip_y = ! ghid_flip_y;
-	do_flip_y = 1;
-	break;
-      case 'r':
-      case 'R':
-	ghid_flip_x = ! ghid_flip_x;
-	ghid_flip_y = ! ghid_flip_y;
-	do_flip_x = 1;
-	do_flip_y = 1;
-	break;
-      default:
-	return 1;
-      }
-      /* SwapSides will swap this */
-      Settings.ShowSolderSide = (ghid_flip_x == ghid_flip_y);
-    }
-
-  Settings.ShowSolderSide = !Settings.ShowSolderSide;
-  if (Settings.ShowSolderSide)
-    {
-      if (active_group == comp_group && comp_showing && !solder_showing)
-	{
-	  ChangeGroupVisibility (PCB->LayerGroups.Entries[comp_group][0], 0,
-				 0);
-	  ChangeGroupVisibility (PCB->LayerGroups.Entries[solder_group][0], 1,
-				 1);
-	}
-    }
-  else
-    {
-      if (active_group == solder_group && solder_showing && !comp_showing)
-	{
-	  ChangeGroupVisibility (PCB->LayerGroups.Entries[solder_group][0], 0,
-				 0);
-	  ChangeGroupVisibility (PCB->LayerGroups.Entries[comp_group][0], 1,
-				 1);
-	}
-    }
-
-  /* Update coordinates so that the current location stays where it was on the
-     other side; we need to do this since the actual flip center is the
-     center of the board while the user expect the center would be the current
-     location */
-  if (do_flip_x)
-    {
-	flipd = PCB->MaxWidth / 2 - gport->view_x;
-	ghid_port_ranges_pan (2 * flipd, 0, TRUE);
-    }
-  if (do_flip_y)
-    {
-	flipd = PCB->MaxHeight / 2 - gport->view_y;
-	ghid_port_ranges_pan (0, 2 * flipd, TRUE);
-    }
-
-  ghid_invalidate_all ();
-  return 0;
-}
-
-/* ------------------------------------------------------------ */
-
-static const char print_syntax[] =
-"Print()";
-
-static const char print_help[] =
-"Print the layout.";
-
-/* %start-doc actions Print
-
-This will find the default printing HID, prompt the user for its
-options, and print the layout.
-
-%end-doc */
-
-static int
-Print (int argc, char **argv, int x, int y)
-{
-  HID **hids;
-  int i;
-  HID *printer = NULL;
-
-  hids = hid_enumerate ();
-  for (i = 0; hids[i]; i++)
-    {
-      if (hids[i]->printer)
-	printer = hids[i];
-    }
-
-  if (printer == NULL)
-    {
-      gui->log (_("Can't find a suitable printer HID"));
-      return -1;
-    }
-
-  /* check if layout is empty */
-  if (!IsDataEmpty (PCB->Data))
-    {
-      ghid_dialog_print (printer);
-    }
-  else
-    gui->log (_("Can't print empty layout"));
-
-  return 0;
-}
-
-
-/* ------------------------------------------------------------ */
-
-static HID_Attribute
-printer_calibrate_attrs[] = {
-  {"Enter Values here:", "",
-   HID_Label, 0, 0, {0, 0, 0}, 0, 0},
-  {"x-calibration", "X scale for calibrating your printer",
-   HID_Real, 0.5, 25, {0, 0, 1.00}, 0, 0},
-  {"y-calibration", "Y scale for calibrating your printer",
-   HID_Real, 0.5, 25, {0, 0, 1.00}, 0, 0}
-};
-static HID_Attr_Val printer_calibrate_values[3];
-
-static const char printcalibrate_syntax[] =
-"PrintCalibrate()";
-
-static const char printcalibrate_help[] =
-"Calibrate the printer.";
-
-/* %start-doc actions PrintCalibrate
-
-This will print a calibration page, which you would measure and type
-the measurements in, so that future printouts will be more precise.
-
-%end-doc */
-
-static int
-PrintCalibrate (int argc, char **argv, int x, int y)
-{
-  HID *printer = hid_find_printer ();
-  printer->calibrate (0.0, 0.0);
-
-  if (gui->attribute_dialog (printer_calibrate_attrs, 3,
-			     printer_calibrate_values,
-			     "Printer Calibration Values",
-			     "Enter calibration values for your printer"))
-    return 1;
-  printer->calibrate (printer_calibrate_values[1].real_value,
-		      printer_calibrate_values[2].real_value);
-  return 0;
-}
-
-/* ------------------------------------------------------------ */
-
-static int
-Export (int argc, char **argv, int x, int y)
-{
-
-  /* check if layout is empty */
-  if (!IsDataEmpty (PCB->Data))
-    {
-      ghid_dialog_export ();
-    }
-  else
-    gui->log (_("Can't export empty layout"));
-
-  return 0;
-}
-
-/* ------------------------------------------------------------ */
-
-static int
-Benchmark (int argc, char **argv, int x, int y)
-{
-  int i = 0;
-  time_t start, end;
-  BoxType region;
-  GdkDisplay *display;
-
-  display = gdk_drawable_get_display (gport->drawable);
-
-  region.X1 = 0;
-  region.Y1 = 0;
-  region.X2 = PCB->MaxWidth;
-  region.Y2 = PCB->MaxHeight;
-
-  gdk_display_sync (display);
-  time (&start);
-  do
-    {
-      hid_expose_callback (&ghid_hid, &region, 0);
-      gdk_display_sync (display);
-      time (&end);
-      i++;
-    }
-  while (end - start < 10);
-
-  printf ("%g redraws per second\n", i / 10.0);
-
-  return 0;
-}
-
-/* ------------------------------------------------------------ */
-
-static const char center_syntax[] =
-"Center()\n";
-
-static const char center_help[] =
-"Moves the pointer to the center of the window.";
-
-/* %start-doc actions Center
-
-Move the pointer to the center of the window, but only if it's
-currently within the window already.
-
-%end-doc */
-
-static int
-Center(int argc, char **argv, int x, int y)
-{
-  int x0, y0, w2, h2, dx, dy;
- 
-  if (argc != 0)
-    AFAIL (center);
-
-  x = GRIDFIT_X (SIDE_X (x), PCB->Grid);
-  y = GRIDFIT_Y (SIDE_Y (y), PCB->Grid);
-
-  w2 = gport->view_width / 2;
-  h2 = gport->view_height / 2;
-  x0 = x - w2;
-  y0 = y - h2;
-
-  if (x0 < 0) 
-    {
-      x0 = 0;
-      x = x0 + w2;
-    }
-
-  if (y0 < 0)
-    {
-      y0 = 0;
-      y = y0 + w2;
-    }
-
-  dx = (x0 - gport->view_x0) / gport->zoom ;
-  dy = (y0 - gport->view_y0) / gport->zoom;
-  gport->view_x0 = x0;
-  gport->view_y0 = y0;
-
-
-  ghid_pan_fixup ();
-
-  /* Move the pointer to the center of the window, but only if it's
-     currently within the window already.  Watch out for edges,
-     though.  */
-
-#if GTK_CHECK_VERSION(2,8,0)
-  {
-    GdkDisplay *display;
-    GdkScreen *screen;
-    gint cx, cy;
-
-    display = gdk_display_get_default ();
-    screen = gdk_display_get_default_screen (display); 
-
-    /* figure out where the pointer is and then move it from there by the specified delta */
-    gdk_display_get_pointer (display, NULL, &cx, &cy, NULL); 
-    gdk_display_warp_pointer (display, screen, cx - dx, cy - dy);
-
-    /* 
-     * Note that under X11, gdk_display_warp_pointer is just a wrapper around XWarpPointer, but
-     * hopefully by avoiding the direct call to an X function we might still work under windows
-     * and other non-X11 based gdk's
-     */
-  }
-#else  
-#  ifdef HAVE_GDK_GDKX_H
-  {
-
-    Window w_src, w_dst; 
-    w_src = GDK_WINDOW_XID (gport->drawing_area->window);
-    w_dst = w_src;
-
-    /* don't warp with the auto drc - that creates auto-scroll chaos */
-    if (TEST_FLAG (AUTODRCFLAG, PCB) && Settings.Mode == LINE_MODE
-	&& Crosshair.AttachedLine.State != STATE_FIRST)
-      return 0;
-    
-    XWarpPointer (GDK_DRAWABLE_XDISPLAY (gport->drawing_area->window),
-		 w_src, w_dst,
-		 0, 0, 0, 0,
-		 Vx2 (x), Vy2 (y));
-    
-    /* XWarpPointer creates Motion events normally bound to
-     *  EventMoveCrosshair.
-     *  We don't do any updates when EventMoveCrosshair
-     *  is called the next time to prevent from rounding errors
-     */
-    /* FIXME?
-     * IgnoreMotionEvents = ignore;
-     */
-  }
-#  endif
-#endif
-
-  return 0;
-}
-
-/* ------------------------------------------------------------ */
-static const char cursor_syntax[] =
-"Cursor(Type,DeltaUp,DeltaRight,Units)";
-
-static const char cursor_help[] =
-"Move the cursor.";
-
-/* %start-doc actions Cursor
-
-This action moves the mouse cursor.  Unlike other actions which take
-coordinates, this action's coordinates are always relative to the
-user's view of the board.  Thus, a positive @var{DeltaUp} may move the
-cursor towards the board origin if the board is inverted.
-
-Type is one of @samp{Pan} or @samp{Warp}.  @samp{Pan} causes the
-viewport to move such that the crosshair is under the mouse cursor.
-@samp{Warp} causes the mouse cursor to move to be above the crosshair.
-
-@var{Units} can be one of the following:
-
-@table @samp
-
-@item mil
-@itemx mm
-The cursor is moved by that amount, in board units.
-
-@item grid
-The cursor is moved by that many grid points.
-
-@item view
-The values are percentages of the viewport's view.  Thus, a pan of
-@samp{100} would scroll the viewport by exactly the width of the
-current view.
-
-@item board
-The values are percentages of the board size.  Thus, a move of
-@samp{50,50} moves you halfway across the board.
-
-@end table
-
-%end-doc */
-
-static int
-CursorAction(int argc, char **argv, int x, int y)
-{
-  int pan_warp = HID_SC_DO_NOTHING;
-  double dx, dy;
-  double xu = 0.0, yu = 0.0;
-
-  if (argc != 4)
-    AFAIL (cursor);
-
-  if (strcasecmp (argv[0], "pan") == 0)
-    pan_warp = HID_SC_PAN_VIEWPORT;
-  else if (strcasecmp (argv[0], "warp") == 0)
-    pan_warp = HID_SC_WARP_POINTER;
-  else
-    AFAIL (cursor);
-
-  dx = strtod (argv[1], 0);
-  if (ghid_flip_x)
-    dx = -dx;
-  dy = strtod (argv[2], 0);
-  if (!ghid_flip_y)
-    dy = -dy;
-
-  /* 
-   * xu and yu are the scale factors that we multiply dx and dy by to
-   * come up with PCB internal units.
-   */
-  if (strncasecmp (argv[3], "mm", 2) == 0)
-    xu = yu = MM_TO_COOR;
-  else if (strncasecmp (argv[3], "mil", 3) == 0)
-    xu = yu = 100;
-  else if (strncasecmp (argv[3], "grid", 4) == 0)
-    xu = yu = PCB->Grid;
-  else if (strncasecmp (argv[3], "view", 4) == 0)
-    {
-      xu = gport->view_width / 100.0;
-      yu = gport->view_height / 100.0;
-    }
-  else if (strncasecmp (argv[3], "board", 4) == 0)
-    {
-      xu = PCB->MaxWidth / 100.0;
-      yu = PCB->MaxHeight / 100.0;
-    }
-
-  EventMoveCrosshair (Crosshair.X+(int)(dx*xu), Crosshair.Y+(int)(dy*yu));
-  gui->set_crosshair (Crosshair.X, Crosshair.Y, pan_warp);
-
-  return 0;
-}
-/* ------------------------------------------------------------ */
-
-static const char dowindows_syntax[] =
-"DoWindows(1|2|3|4)\n"
-"DoWindows(Layout|Library|Log|Netlist|Preferences)";
-
-static const char dowindows_help[] =
-"Open various GUI windows.";
-
-/* %start-doc actions DoWindows
-
-@table @code
-
-@item 1
-@itemx Layout
-Open the layout window.  Since the layout window is always shown
-anyway, this has no effect.
-
-@item 2
-@itemx Library
-Open the library window.
-
-@item 3
-@itemx Log
-Open the log window.
-
-@item 4
-@itemx Netlist
-Open the netlist window.
-
-@item 5
-@itemx Preferences
-Open the preferences window.
-
-@end table
-
-%end-doc */
-
-static int
-DoWindows (int argc, char **argv, int x, int y)
-{
-  char *a = argc == 1 ? argv[0] : "";
-
-  if (strcmp (a, "1") == 0 || strcasecmp (a, "Layout") == 0)
-    {
-    }
-  else if (strcmp (a, "2") == 0 || strcasecmp (a, "Library") == 0)
-    {
-      ghid_library_window_show (gport, TRUE);
-    }
-  else if (strcmp (a, "3") == 0 || strcasecmp (a, "Log") == 0)
-    {
-      ghid_log_window_show (TRUE);
-    }
-  else if (strcmp (a, "4") == 0 || strcasecmp (a, "Netlist") == 0)
-    {
-      ghid_netlist_window_show (gport, TRUE);
-    }
-  else if (strcmp (a, "5") == 0 || strcasecmp (a, "Preferences") == 0)
-    {
-      ghid_config_window_show ();
-    }
-  else
-    {
-      AFAIL (dowindows);
-    }
-
-  return 0;
-}
-
-/* ------------------------------------------------------------ */
-static const char setunits_syntax[] =
-"SetUnits(mm|mil)";
-
-static const char setunits_help[] =
-"Set the default measurement units.";
-
-/* %start-doc actions SetUnits
-
-@table @code
-
-@item mil
-Sets the display units to mils (1/1000 inch).
-
-@item mm
-Sets the display units to millimeters.
-
-@end table
-
-%end-doc */
-
-static int
-SetUnits (int argc, char **argv, int x, int y)
-{
-  if (argc == 0)
-    return 0;
-  if (strcmp (argv[0], "mil") == 0)
-    Settings.grid_units_mm = 0;
-  if (strcmp (argv[0], "mm") == 0)
-    Settings.grid_units_mm = 1;
-
-  ghid_config_handle_units_changed ();
-
-  ghid_set_status_line_label ();
-
-  /* FIXME ?
-   * lesstif_sizes_reset ();
-   * lesstif_styles_update_values ();
-   */
-  return 0;
-}
-
-/* ------------------------------------------------------------ */
-static const char popup_syntax[] =
-"Popup(MenuName, [Button])";
-
-static const char popup_help[] =
-"Bring up the popup menu specified by @code{MenuName}.\n"
-"If called by a mouse event then the mouse button number\n"
-"must be specified as the optional second argument.";
-
-/* %start-doc actions Popup
-
-This just pops up the specified menu.  The menu must have been defined
-as a named subresource of the Popups resource in the menu resource
-file.  If called as a response to a mouse button click, the mouse 
-button number must be specified as the second argument.  
-
-%end-doc */
-
-
-static int
-Popup (int argc, char **argv, int x, int y)
-{
-  GtkWidget *menu;
-  char *element;
-  guint button;
-
-  if (argc != 1 && argc != 2)
-    AFAIL (popup);
-
-  if (argc == 1)
-    button = 0;
-  else
-    button = atoi (argv[1]);
-
-  if ( (element = (char *) malloc ( (strlen (argv[0]) + 2) * sizeof (char))) == NULL )
-    {
-      fprintf (stderr, "Popup():  malloc failed\n");
-      exit (1);
-    }
-
-  sprintf (element, "/%s", argv[0]);
-  printf ("Loading popup \"%s\". Button = %u\n", element, button);
-
-  menu = gtk_ui_manager_get_widget (ghidgui->ui_manager, element);
-  free (element);
-
-  if (! GTK_IS_MENU (menu))
-    {
-      Message ("The specified popup menu \"%s\" has not been defined.\n", argv[0]);
-      return 1;
-    }
-  else
-    {
-      ghidgui->in_popup = TRUE;
-      gtk_widget_grab_focus (ghid_port.drawing_area);
-      gtk_menu_popup (GTK_MENU (menu), NULL, NULL, NULL, NULL, 0, 
-		      gtk_get_current_event_time());
-    }
-  return 0;
-}
-
-static int
-Busy (int argc, char **argv, int x, int y)
-{
-  ghid_watch_cursor ();
-  return 0;
-}
-
-HID_Action ghid_main_action_list[] = {
-  {"About", 0, About, about_help, about_syntax},
-  {"Benchmark", 0, Benchmark},
-  {"Busy", 0, Busy},
-  {"Center", "Click on a location to center", Center, center_help, center_syntax},
-  {"Command", 0, Command},
-  {"Cursor", 0, CursorAction, cursor_help, cursor_syntax},
-  {"DoWindows", 0, DoWindows, dowindows_help, dowindows_syntax},
-  {"Export", 0, Export},
-  {"GetXY", "", GetXY, getxy_help, getxy_syntax},
-  {"LayerGroupsChanged", 0, LayerGroupsChanged},
-  {"LibraryChanged", 0, LibraryChanged},
-  {"Load", 0, Load},
-  {"PCBChanged", 0, PCBChanged},
-  {"PointCursor", 0, PointCursor},
-  {"Popup", 0, Popup, popup_help, popup_syntax},
-  {"Print", 0, Print,
-   print_help, print_syntax},
-  {"PrintCalibrate", 0, PrintCalibrate,
-   printcalibrate_help, printcalibrate_syntax},
-  {"RouteStylesChanged", 0, RouteStylesChanged},
-  {"Save", 0, Save, save_help, save_syntax},
-  {"SetUnits", 0, SetUnits, setunits_help, setunits_syntax},
-  {"SwapSides", 0, SwapSides, swapsides_help, swapsides_syntax},
-  {"Zoom", "Click on zoom focus", Zoom, zoom_help, zoom_syntax}
+  NULL, /* hidgl_get_export_options */
+  NULL, /* hidgl_do_export */
+  NULL, /* hidgl_parse_arguments */
+
+  NULL, /* hidgl_invalidate_wh */
+  NULL, /* hidgl_invalidate_lr */
+  NULL, /* hidgl_invalidate_all */
+  hidgl_set_layer,
+  hidgl_make_gc,
+  hidgl_destroy_gc,
+  hidgl_use_mask,
+  hidgl_set_color,
+  hidgl_set_line_cap,
+  hidgl_set_line_width,
+  hidgl_set_draw_xor,
+  hidgl_set_draw_faded,
+  hidgl_set_line_cap_angle,
+  hidgl_draw_line,
+  hidgl_draw_arc,
+  hidgl_draw_rect,
+  hidgl_fill_circle,
+  hidgl_fill_polygon,
+  hidgl_fill_rect,
+
+  NULL, /* hidgl_calibrate */
+  NULL, /* hidgl_shift_is_pressed */
+  NULL, /* hidgl_control_is_pressed */
+  NULL, /* hidgl_get_coords */
+  NULL, /* hidgl_set_crosshair */
+  NULL, /* hidgl_add_timer */
+  NULL, /* hidgl_stop_timer */
+  NULL, /* hidgl_watch_file */
+  NULL, /* hidgl_unwatch_file */
+  NULL, /* hidgl_add_block_hook */
+  NULL, /* hidgl_stop_block_hook */
+
+  NULL, /* hidgl_log */
+  NULL, /* hidgl_logv */
+  NULL, /* hidgl_confirm_dialog */
+  NULL, /* hidgl_close_confirm_dialog */
+  NULL, /* hidgl_report_dialog */
+  NULL, /* hidgl_prompt_for */
+  NULL, /* hidgl_fileselect */
+  NULL, /* hidgl_attribute_dialog */
+  NULL, /* hidgl_show_item */
+  NULL, /* hidgl_beep */
+  NULL, /* hidgl_progress */
 };
 
-REGISTER_ACTIONS (ghid_main_action_list)
-
-
-static int
-flag_flipx (int x)
-{ 
-  return ghid_flip_x;
-} 
-static int  
-flag_flipy (int x)
-{ 
-  return ghid_flip_y;
-} 
-
-HID_Flag ghid_main_flag_list[] = {
-  {"flip_x", flag_flipx, 0},
-  {"flip_y", flag_flipy, 0}
-};  
-
-REGISTER_FLAGS (ghid_main_flag_list)
-
-#include "dolists.h"
-
-/*
- * We will need these for finding the windows installation
- * directory.  Without that we can't find our fonts and
- * footprint libraries.
- */
-#ifdef WIN32
-#include <windows.h>
-#include <winreg.h>
-#endif
-
-void
-hid_gtk_init ()
-{
-  #ifdef WIN32
-
-  char * tmps;
-  char * share_dir;
-
-  tmps = g_win32_get_package_installation_directory (PACKAGE "-" VERSION, NULL);
-#define REST_OF_PATH G_DIR_SEPARATOR_S "share" G_DIR_SEPARATOR_S PACKAGE
-  share_dir = (char *) malloc(strlen(tmps) + 
-			  strlen(REST_OF_PATH) +
-			  1);
-  sprintf (share_dir, "%s%s", tmps, REST_OF_PATH);
-  free (tmps);
-#undef REST_OF_PATH
-  printf ("\"Share\" installation path is \"%s\"\n", share_dir);
-#endif  
-
-  hid_register_hid (&ghid_hid);
-  apply_default_hid (&ghid_extents, &ghid_hid);
-#include "gtk_lists.h"
-}
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index c57173d..e45a468 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -22,513 +22,15 @@
  *
  */
 
-/* FIXME - rename this file to ghid.h */
+#ifndef __HIDGL_INCLUDED__
+#define __HIDGL_INCLUDED__
 
-#ifndef __GHID_INCLUDED__
-#define __GHID_INCLUDED__
-
-#include "hid.h"
-
-#include "data.h"
-#include "misc.h"
-#include <sys/stat.h>
-
-#include <gtk/gtk.h>
-
-#include <gtk/gtkgl.h>
 #include <GL/glu.h>
 //#include <GL/glut.h>
 
-/* Internationalization support.
-*/
-#if defined (ENABLE_NLS)
-#include <libintl.h>
-#   undef _
-#   define _(String) dgettext(GETTEXT_PACKAGE,String)
-#   if defined(gettext_noop)
-#       define N_(String) gettext_noop(String)
-#   else
-#       define N_(String) (String)
-#   endif /* gettext_noop */
-#else
-#   undef _
-#   define _(String) (String)
-#   define N_(String) (String)
-#   define textdomain(String) (String)
-#   define gettext(String) (String)
-#   define dgettext(Domain,String) (String)
-#   define dcgettext(Domain,String,Type) (String)
-#   define bindtextdomain(Domain,Directory) (Domain)
-#endif /* ENABLE_NLS */
-
-
-  /* Silk and rats lines are the two additional selectable to draw on.
-     |  gui code in gui-top-window.c and group code in misc.c must agree
-     |  on what layer is what!
-   */
-#define	LAYER_BUTTON_SILK			MAX_LAYER
-#define	LAYER_BUTTON_RATS			(MAX_LAYER + 1)
-#define	N_SELECTABLE_LAYER_BUTTONS	(LAYER_BUTTON_RATS + 1)
-
-#define LAYER_BUTTON_PINS			(MAX_LAYER + 2)
-#define LAYER_BUTTON_VIAS			(MAX_LAYER + 3)
-#define LAYER_BUTTON_FARSIDE		(MAX_LAYER + 4)
-#define LAYER_BUTTON_MASK			(MAX_LAYER + 5)
-#define N_LAYER_BUTTONS				(MAX_LAYER + 6)
-
-  /* Go from from the grid units in use (millimeters or mils) to PCB units
-     |  and back again.
-     |  PCB keeps values internally to 1/100000 inch (0.01 mils), but gui
-     |  widgets (spin buttons, labels, etc) need mils or millimeters.
-   */
-#define	FROM_PCB_UNITS(v)	(Settings.grid_units_mm ? \
-								((v) * 0.000254) : ((v) * 0.01))
-
-#define TO_PCB_UNITS(v)		(Settings.grid_units_mm ? \
-								((v) / 0.000254 + 0.5) : ((v) * 100.0 + 0.5))
-
-extern int ghid_flip_x, ghid_flip_y;
-#define SIDE_X(x)   ((ghid_flip_x ? PCB->MaxWidth - (x) : (x)))
-#define SIDE_Y(y)   ((ghid_flip_y ? PCB->MaxHeight - (y) : (y)))
-
-#define	DRAW_X(x)	(gint)((SIDE_X(x) - gport->view_x0) / gport->zoom)
-#define	DRAW_Y(y)	(gint)((SIDE_Y(y) - gport->view_y0) / gport->zoom)
-#define	DRAW_Z(z)	(gint)((z) / gport->zoom)
-
-#define	VIEW_X(x)	SIDE_X((gint)((x) * gport->zoom + gport->view_x0))
-#define	VIEW_Y(y)	SIDE_Y((gint)((y) * gport->zoom + gport->view_y0))
-#define	VIEW_Z(z)	(gint)((z) * gport->zoom)
-
-/*
- * Used to intercept "special" hotkeys that gtk doesn't usually pass
- * on to the menu hotkeys.  We catch them and put them back where we
- * want them. 
- */
-
-/* The modifier keys */
-
- #define GHID_KEY_ALT     0x80
- #define GHID_KEY_CONTROL 0x40
- #define GHID_KEY_SHIFT   0x20
-
-/* The actual keys */
-#define GHID_KEY_TAB      0x01
-#define GHID_KEY_UP       0x02
-#define GHID_KEY_DOWN     0x03
-#define GHID_KEY_LEFT     0x04
-#define GHID_KEY_RIGHT    0x05
-
-  /* Pick one of two values depending on current grid units setting.
-   */
-#define GRID_UNITS_VALUE(mm, mil)   (Settings.grid_units_mm ? (mm) : (mil))
-
-
-
-typedef struct hid_gc_struct
-{
-  HID *me_pointer;
-  GdkGC *gc;
-
-  gchar *colorname;
-  gint width;
-  gint cap, join;
-  gchar xor;
-  gchar erase;
-//  gint mask_seq;
-}
-hid_gc_struct;
-
-
-typedef struct
-{
-  GtkUIManager *ui_manager;
-  GtkActionGroup *main_actions,
-    *grid_actions, *change_selected_actions, *displayed_name_actions;
-
-  GtkWidget *name_label,
-    *status_line_label,
-    *cursor_position_relative_label,
-    *cursor_position_absolute_label,
-    *grid_units_label, *status_line_hbox, *command_combo_box;
-  GtkEntry *command_entry;
-
-  GtkWidget *top_hbox,
-    *menu_hbox, *compact_vbox, *compact_hbox, *position_hbox, *label_hbox,
-    *mode_buttons0_vbox, *mode_buttons1_hbox, *mode_buttons1_vbox,
-    *mode_buttons0_frame, *mode_buttons1_frame, *mode_buttons0_frame_vbox;
-
-  GtkWidget *h_range, *v_range;
-  GtkObject *h_adjustment, *v_adjustment;
-
-  GdkPixbuf *bg_pixbuf;
-
-  gchar *name_label_string;
-
-  gboolean adjustment_changed_holdoff,
-    toggle_holdoff,
-    command_entry_status_line_active,
-    auto_pan_on, in_popup, combine_adjustments;
-
-  gboolean config_modified,
-    small_label_markup,
-    compact_horizontal,
-    compact_vertical,
-    ghid_title_window, use_command_window, need_restore_crosshair, creating;
-
-  gint n_mode_button_columns,
-    top_window_width,
-    top_window_height,
-    log_window_width,
-    log_window_height,
-    keyref_window_width,
-    keyref_window_height,
-    library_window_width,
-    library_window_height,
-    netlist_window_height, history_size, settings_mode, auto_pan_speed;
-}
-GhidGui;
-
-extern GhidGui _ghidgui, *ghidgui;
-
-
-  /* The output viewport
-   */
-typedef struct
-{
-  GtkWidget *top_window,	/* toplevel widget              */
-   *drawing_area;		/* and its drawing area */
-  GdkPixmap *pixmap, *mask;
-  GdkDrawable *drawable;	/* Current drawable for drawing routines */
-  gint width, height;
-
-  GdkGLConfig *glconfig;
-
-  gint trans_lines;
-
-//  GdkGC *bg_gc, *offlimits_gc, *mask_gc, *u_gc, *grid_gc;
-
-  GdkColor bg_color, offlimits_color, grid_color;
-
-  GdkColormap *colormap;
-
-  GdkCursor *X_cursor;		/* used X cursor */
-  GdkCursorType X_cursor_shape;	/* and its shape */
-
-  gboolean has_entered;
-
-/* zoom value is PCB units per screen pixel.  Larger numbers mean zooming
-|  out - the largest value means you are looking at the whole board.
-*/
-  gdouble zoom;			/* PCB units per screen pixel.  Larger */
-  /* numbers mean zooming out. */
-  gint view_x0,			/* Viewport in PCB coordinates */
-    view_y0, view_width, view_height, view_x, view_y;
-
-  gint x_crosshair, y_crosshair;
-}
-GHidPort;
-
-extern GHidPort ghid_port, *gport;
-
-typedef enum
-{
-  NONE_PRESSED,
-  SHIFT_PRESSED,
-  CONTROL_PRESSED,
-  MOD1_PRESSED,
-  SHIFT_CONTROL_PRESSED,
-  SHIFT_MOD1_PRESSED,
-  CONTROL_MOD1_PRESSED,
-  SHIFT_CONTROL_MOD1_PRESSED
-}
-ModifierKeysState;
-
-typedef enum
-{
-  NO_BUTTON_PRESSED,
-  BUTTON1_PRESSED,
-  BUTTON2_PRESSED,
-  BUTTON3_PRESSED
-}
-ButtonState;
-
-/* Function prototypes
-*/
-void ghid_parse_arguments (gint * argc, gchar *** argv);
-hidGC ghid_make_gc (void);
-void ghid_destroy_gc (hidGC);
-void ghid_do_export (HID_Attr_Val * options);
-
-void ghid_create_pcb_widgets (void);
-void ghid_window_set_name_label (gchar * name);
-void ghid_interface_set_sensitive (gboolean sensitive);
-void ghid_interface_input_signals_connect (void);
-void ghid_interface_input_signals_disconnect (void);
-
-void ghid_set_menu_toggle_button (GtkActionGroup * ag,
-				  gchar * name, gboolean state);
-void ghid_pcb_saved_toggle_states_set (void);
-void ghid_sync_with_new_layout (void);
-void ghid_size_increment_get_value (const gchar * saction,
-				    gchar ** value, gchar ** units);
-void ghid_line_increment_get_value (const gchar * saction,
-				    gchar ** value, gchar ** units);
-void ghid_clear_increment_get_value (const gchar * saction,
-				     gchar ** value, gchar ** units);
-void ghid_grid_size_increment_get_value (const gchar * saction,
-					 gchar ** value, gchar ** units);
-
-void ghid_grid_setting_update_menu_actions (void);
-void ghid_change_selected_update_menu_actions (void);
-
-void ghid_config_window_show ();
-void ghid_config_handle_units_changed (void);
-void ghid_config_start_backup_timer (void);
-void ghid_config_text_scale_update (void);
-void ghid_config_layer_name_update (gchar * name, gint layer);
-void ghid_config_groups_changed(void);
-
-void ghid_config_init (void);
-void ghid_config_files_write (void);
-void ghid_config_files_read (gint * argc, gchar *** argv);
-
-void ghid_mode_buttons_update (void);
-void ghid_pack_mode_buttons(void);
-void ghid_layer_enable_buttons_update (void);
-void ghid_layer_buttons_update (void);
-void ghid_layer_button_select (gint layer);
-void ghid_layer_buttons_color_update (void);
-
-
-/* gui-misc.c function prototypes
-*/
-void ghid_status_line_set_text (const gchar * text);
-void ghid_cursor_position_label_set_text (gchar * text);
-void ghid_cursor_position_relative_label_set_text (gchar * text);
-
-void ghid_hand_cursor (void);
-void ghid_point_cursor (void);
-void ghid_watch_cursor (void);
-void ghid_mode_cursor (gint mode);
-void ghid_corner_cursor (void);
-void ghid_restore_cursor (void);
-void ghid_get_user_xy (const gchar * msg);
-void ghid_create_abort_dialog (gchar *);
-gboolean ghid_check_abort (void);
-void ghid_end_abort (void);
-void ghid_get_pointer (gint *, gint *);
-
-
-/* gui-output-events.c function prototypes.
-*/
-void ghid_port_ranges_changed (void);
-void ghid_port_ranges_zoom (gdouble zoom);
-gboolean ghid_port_ranges_pan (gdouble x, gdouble y, gboolean relative);
-void ghid_port_ranges_scale (gboolean emit_changed);
-void ghid_port_ranges_update_ranges (void);
-void ghid_show_crosshair (gboolean show);
-void ghid_screen_update (void);
-
-gboolean ghid_note_event_location (GdkEventButton * ev);
-
-gboolean ghid_port_key_press_cb (GtkWidget * drawing_area,
-				 GdkEventKey * kev, GtkUIManager * ui);
-gboolean ghid_port_key_release_cb (GtkWidget * drawing_area,
-				   GdkEventKey * kev, GtkUIManager * ui);
-gboolean ghid_port_button_press_cb (GtkWidget * drawing_area,
-				    GdkEventButton * ev, GtkUIManager * ui);
-gboolean ghid_port_button_release_cb (GtkWidget * drawing_area,
-				      GdkEventButton * ev, GtkUIManager * ui);
-
-
-gint ghid_port_window_enter_cb (GtkWidget * widget,
-			   GdkEventCrossing * ev, GHidPort * out);
-gint ghid_port_window_leave_cb (GtkWidget * widget, 
-                           GdkEventCrossing * ev, GHidPort * out);
-gint ghid_port_window_motion_cb (GtkWidget * widget,
-				 GdkEventButton * ev, GHidPort * out);
-gint ghid_port_window_mouse_scroll_cb (GtkWidget * widget,
-				       GdkEventScroll * ev, GHidPort * out);
-
-
-gint ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
-					     GdkEventExpose * ev,
-					     GHidPort * out);
-gint ghid_port_drawing_area_configure_event_cb (GtkWidget * widget,
-						GdkEventConfigure * ev,
-						GHidPort * out);
-
-
-/* gui-dialog.c function prototypes.
-*/
-#define		GUI_DIALOG_RESPONSE_ALL	1
-
-gchar *ghid_dialog_file_select_open (gchar * title, gchar ** path,
-				     gchar * shortcuts);
-gchar *ghid_dialog_file_select_save (gchar * title, gchar ** path,
-				     gchar * file, gchar * shortcuts);
-void ghid_dialog_message (gchar * message);
-gboolean ghid_dialog_confirm (gchar * message, gchar *cancelmsg, gchar *okmsg);
-int ghid_dialog_close_confirm (void);
-#define GUI_DIALOG_CLOSE_CONFIRM_CANCEL 0
-#define GUI_DIALOG_CLOSE_CONFIRM_NOSAVE 1
-#define GUI_DIALOG_CLOSE_CONFIRM_SAVE   2
-gint ghid_dialog_confirm_all (gchar * message);
-gchar *ghid_dialog_input (gchar * prompt, gchar * initial);
-void ghid_dialog_about (void);
-
-char * ghid_fileselect (const char *, const char *, char *, char *, const char *, int);
-
-
-/* gui-dialog-print.c */
-void ghid_dialog_export (void);
-void ghid_dialog_print (HID *);
-
-int ghid_attribute_dialog (HID_Attribute *, int, HID_Attr_Val *, const char *, const char *);
-
-/* gui-route-style function prototypes.
-*/
-  /* In gui-dialog-size.c */
-void ghid_route_style_dialog (gint index, RouteStyleType * rst);
-  /* In gui-top-window.c  */
-void ghid_route_style_set_button_label (gchar * name, gint index);
-void ghid_route_style_set_temp_style (RouteStyleType * rst, gint which);
-void ghid_route_style_button_set_active (gint number);
-void ghid_route_style_buttons_update (void);
-void ghid_update_toggle_flags (void);
-
-/* gui-utils.c
-*/
-gboolean dup_string (gchar ** dst, gchar * src);
-gboolean utf8_dup_string (gchar ** dst_utf8, gchar * src);
-void free_glist_and_data (GList ** list_head);
-
-
-ModifierKeysState ghid_modifier_keys_state (GdkModifierType * state);
-ButtonState ghid_button_state (GdkModifierType * state);
-gboolean ghid_is_modifier_key_sym (gint ksym);
-gboolean ghid_control_is_pressed (void);
-gboolean ghid_shift_is_pressed (void);
-
-void ghid_draw_area_update (GHidPort * out, GdkRectangle * rect);
-void ghid_string_markup_extents (PangoFontDescription * font_desc,
-				 gchar * string, gint * width, gint * height);
-void ghid_draw_string_markup (GdkDrawable * drawable,
-			      PangoFontDescription * font_desc,
-			      GdkGC * gc, gint x, gint y, gchar * string);
-
-gchar *ghid_get_color_name (GdkColor * color);
-void ghid_map_color_string (gchar * color_string, GdkColor * color);
-void ghid_button_set_text (GtkWidget * button, gchar * text);
-gboolean ghid_button_active (GtkWidget * widget);
-gchar *ghid_entry_get_text (GtkWidget * entry);
-void ghid_check_button_connected (GtkWidget * box, GtkWidget ** button,
-				  gboolean active, gboolean pack_start,
-				  gboolean expand, gboolean fill, gint pad,
-				  void (*cb_func) (), gpointer data,
-				  gchar * string);
-void ghid_button_connected (GtkWidget * box, GtkWidget ** button,
-			    gboolean pack_start, gboolean expand,
-			    gboolean fill, gint pad, void (*cb_func) (),
-			    gpointer data, gchar * string);
-void ghid_spin_button (GtkWidget * box, GtkWidget ** spin_button,
-		       gfloat value, gfloat low, gfloat high, gfloat step0,
-		       gfloat step1, gint digits, gint width,
-		       void (*cb_func) (), gpointer data,
-		       gboolean right_align, gchar * string);
-void ghid_table_spin_button (GtkWidget * box, gint row, gint column,
-			     GtkWidget ** spin_button, gfloat value,
-			     gfloat low, gfloat high, gfloat step0,
-			     gfloat step1, gint digits, gint width,
-			     void (*cb_func) (), gpointer data,
-			     gboolean right_align, gchar * string);
-void ghid_range_control (GtkWidget * box, GtkWidget ** scale_res,
-			 gboolean horizontal, GtkPositionType pos,
-			 gboolean set_draw_value, gint digits,
-			 gboolean pack_start, gboolean expand, gboolean fill,
-			 guint pad, gfloat value, gfloat low, gfloat high,
-			 gfloat step0, gfloat step1, void (*cb_func) (),
-			 gpointer data);
-GtkWidget *ghid_scrolled_vbox (GtkWidget * box, GtkWidget ** scr,
-			       GtkPolicyType h_policy,
-			       GtkPolicyType v_policy);
-GtkWidget *ghid_framed_vbox (GtkWidget * box, gchar * label,
-			     gint frame_border_width, gboolean frame_expand,
-			     gint vbox_pad, gint vbox_border_width);
-GtkWidget *ghid_framed_vbox_end (GtkWidget * box, gchar * label,
-				 gint frame_border_width,
-				 gboolean frame_expand, gint vbox_pad,
-				 gint vbox_border_width);
-GtkWidget *ghid_category_vbox (GtkWidget * box, const gchar * category_header,
-			       gint header_pad, gint box_pad,
-			       gboolean pack_start, gboolean bottom_pad);
-GtkWidget *ghid_notebook_page (GtkWidget * tabs, char *name, gint pad,
-			       gint border);
-GtkWidget *ghid_framed_notebook_page (GtkWidget * tabs, char *name,
-				      gint border, gint frame_border,
-				      gint vbox_pad, gint vbox_border);
-GtkWidget *ghid_scrolled_text_view (GtkWidget * box, GtkWidget ** scr,
-				    GtkPolicyType h_policy,
-				    GtkPolicyType v_policy);
-void ghid_text_view_append (GtkWidget * view, gchar * string);
-void ghid_text_view_append_strings (GtkWidget * view, gchar ** string,
-				    gint n_strings);
-GtkTreeSelection *ghid_scrolled_selection (GtkTreeView * treeview,
-					   GtkWidget * box,
-					   GtkSelectionMode s_mode,
-					   GtkPolicyType h_policy,
-					   GtkPolicyType v_policy,
-					   void (*func_cb) (), gpointer data);
-
-void ghid_dialog_report (gchar * title, gchar * message);
-void ghid_label_set_markup (GtkWidget * label, const gchar * text);
-
-void ghid_set_cursor_position_labels (void);
-void ghid_set_status_line_label (void);
-
-
-/* gui-netlist-window.c */
-void ghid_netlist_window_show (GHidPort * out, gboolean raise);
-void ghid_netlist_window_update (gboolean init_nodes);
-void ghid_netlist_nodes_update (LibraryMenuType * net);
-
-LibraryMenuType *ghid_get_net_from_node_name (gchar * name, gboolean);
-void ghid_netlist_highlight_node (gchar * name);
-
-
-/* gui-command-window.c */
-void ghid_handle_user_command (gboolean raise);
-void ghid_command_window_show (gboolean raise);
-gchar *ghid_command_entry_get (gchar * prompt, gchar * command);
-void ghid_command_use_command_window_sync (void);
-
-/* gui-keyref-window.c */
-void ghid_keyref_window_show (gboolean raise);
-
-/* gui-library-window.c */
-void ghid_library_window_show (GHidPort * out, gboolean raise);
-
-
-/* gui-log-window.c */
-void ghid_log_window_show (gboolean raise);
-void ghid_log (const char *fmt, ...);
-void ghid_logv (const char *fmt, va_list args);
-
-/* gui-pinout-window.c */
-void ghid_pinout_window_show (GHidPort * out, ElementTypePtr Element);
-
-/* gtkhid-main.c */
-void ghid_init_triangle_array ();
-void ghid_flush_triangles ();
-void ghid_invalidate_all ();
-void ghid_get_coords (const char *msg, int *x, int *y);
-gint PCBChanged (int argc, char **argv, int x, int y);
-
-
-
+int trans_lines;
 
-extern GdkPixmap *XC_hand_source, *XC_hand_mask;
-extern GdkPixmap *XC_lock_source, *XC_lock_mask;
-extern GdkPixmap *XC_clock_source, *XC_clock_mask;
+void hidgl_init_triangle_array ();
+void hidgl_flush_triangles ();
 
-#endif /* __GHID_INCLUDED__  */
+#endif /* __HIDGL_INCLUDED__  */

Bottom: 73783344f41ad370ae1ddd806df0a61894ebb62b
Top:    7124fa198b5e6b9bf65422942770bf042d91b022
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-05-10 18:18:13 +0100

Refresh of gl-use-a-vbo-to-avoid-data-cop

---

diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index d3dfa76..ea5f5a1 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -47,6 +47,10 @@ RCSID ("$Id: $");
 
 triangle_buffer buffer;
 float global_depth = 0;
+GLfloat cur_r = 1.;
+GLfloat cur_g = 1.;
+GLfloat cur_b = 1.;
+GLfloat cur_a = 1.;
 
 #if 0
 triangle_array *
@@ -63,7 +67,8 @@ hidgl_init_triangle_array (triangle_buffer *buffer)
   const GLubyte *errString;
 
   buffer->triangle_count = 0;
-  buffer->coord_comp_count = 0;
+//  buffer->coord_comp_count = 0;
+  buffer->array_size = TRIANGLE_ARRAY_BYTES / (3 * sizeof (tri_array_element));
 
   glEnableClientState (GL_VERTEX_ARRAY);
   glGenBuffers (1, &buffer->vbo_name);
@@ -92,9 +97,12 @@ hidgl_flush_triangles (triangle_buffer *buffer)
   glUnmapBuffer (GL_ARRAY_BUFFER);
 
   glEnableClientState (GL_VERTEX_ARRAY);
-  glVertexPointer (3, GL_FLOAT, 0, NULL); // buffer->triangle_array);
+  glEnableClientState (GL_COLOR_ARRAY);
+  glVertexPointer (3, GL_FLOAT, sizeof (tri_array_element), &((tri_array_element *)NULL)->x);
+  glColorPointer (4, GL_FLOAT, sizeof (tri_array_element), &((tri_array_element *)NULL)->r );
   glDrawArrays (GL_TRIANGLES, 0, buffer->triangle_count * 3);
   glDisableClientState (GL_VERTEX_ARRAY);
+  glDisableClientState (GL_COLOR_ARRAY);
 
 //  buffer->triangle_count = 0;
 //  buffer->coord_comp_count = 0;
@@ -108,17 +116,30 @@ hidgl_flush_triangles (triangle_buffer *buffer)
 void
 hidgl_ensure_triangle_space (triangle_buffer *buffer, int count)
 {
-  if (count > TRIANGLE_ARRAY_SIZE)
+  if (count > buffer->array_size)
     {
       fprintf (stderr, "Not enough space in vertex buffer\n");
       fprintf (stderr, "Requested %i triangles, %i available\n",
-                       count, TRIANGLE_ARRAY_SIZE);
+                       count, buffer->array_size);
       exit (1);
     }
-  if (count > TRIANGLE_ARRAY_SIZE - buffer->triangle_count)
+  if (count > buffer->array_size - buffer->triangle_count)
     hidgl_flush_triangles (buffer);
 }
 
+
+void
+hidgl_color (GLfloat r, GLfloat g, GLfloat b, GLfloat a)
+{
+  cur_r = r;
+  cur_g = g;
+  cur_b = b;
+  cur_a = a;
+
+  /* We still draw non-filled rectangles in immediate mode */
+  glColor4f (r, g, b, a);
+}
+
 //static int cur_mask = -1;
 
 
@@ -245,7 +266,7 @@ static void draw_cap (double width, int x, int y, double angle, double scale)
   for (i = 0; i < slices; i++) {
     capx =  radius * cosf (angle * M_PI / 180. + ((float)(i + 1)) * M_PI / (float)slices) + x;
     capy = -radius * sinf (angle * M_PI / 180. + ((float)(i + 1)) * M_PI / (float)slices) + y;
-    hidgl_add_triangle (&buffer, last_capx, last_capy, capx, capy, x, y);
+    hidgl_add_triangle (&buffer, last_capx, last_capy, capx, capy, x, y, cur_r, cur_g, cur_b, cur_a);
     last_capx = capx;
     last_capy = capy;
   }
@@ -310,10 +331,10 @@ hidgl_draw_line (int cap, double width, int x1, int y1, int x2, int y2, double s
   hidgl_ensure_triangle_space (&buffer, 2);
   hidgl_add_triangle (&buffer, x1 - wdx, y1 - wdy,
                                x2 - wdx, y2 - wdy,
-                               x2 + wdx, y2 + wdy);
+                               x2 + wdx, y2 + wdy, cur_r, cur_g, cur_b, cur_a);
   hidgl_add_triangle (&buffer, x1 - wdx, y1 - wdy,
                                x2 + wdx, y2 + wdy,
-                               x1 + wdx, y1 + wdy);
+                               x1 + wdx, y1 + wdy, cur_r, cur_g, cur_b, cur_a);
 
   /* Don't bother capping hairlines */
   if (circular_caps && !hairline)
@@ -383,10 +404,10 @@ hidgl_draw_arc (double width, int x, int y, int rx, int ry,
     outer_x = -outer_r * cos_ang + x;  outer_y = outer_r * sin_ang + y;
     hidgl_add_triangle (&buffer, last_inner_x, last_inner_y,
                                  last_outer_x, last_outer_y,
-                                 outer_x, outer_y);
+                                 outer_x, outer_y, cur_r, cur_g, cur_b, cur_a);
     hidgl_add_triangle (&buffer, last_inner_x, last_inner_y,
                                  inner_x, inner_y,
-                                 outer_x, outer_y);
+                                 outer_x, outer_y, cur_r, cur_g, cur_b, cur_a);
     last_inner_x = inner_x;  last_inner_y = inner_y;
     last_outer_x = outer_x;  last_outer_y = outer_y;
   }
@@ -442,7 +463,7 @@ hidgl_fill_circle (int vx, int vy, int vr, double scale)
     float x, y;
     x = radius * cosf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vx;
     y = radius * sinf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vy;
-    hidgl_add_triangle (&buffer, vx, vy, last_x, last_y, x, y);
+    hidgl_add_triangle (&buffer, vx, vy, last_x, last_y, x, y, cur_r, cur_g, cur_b, cur_a);
     last_x = x;
     last_y = y;
   }
@@ -532,7 +553,7 @@ myVertex (GLdouble *vertex_data)
           hidgl_add_triangle (&buffer,
                               triangle_vertices [0], triangle_vertices [1],
                               triangle_vertices [2], triangle_vertices [3],
-                              vertex_data [0], vertex_data [1]);
+                              vertex_data [0], vertex_data [1], cur_r, cur_g, cur_b, cur_a);
 #else
           hidgl_draw_line (Square_Cap, global_scale,
                            triangle_vertices [0], triangle_vertices [1],
@@ -567,7 +588,7 @@ myVertex (GLdouble *vertex_data)
           hidgl_add_triangle (&buffer,
                               triangle_vertices [0], triangle_vertices [1],
                               triangle_vertices [2], triangle_vertices [3],
-                              triangle_vertices [4], triangle_vertices [5]);
+                              triangle_vertices [4], triangle_vertices [5], cur_r, cur_g, cur_b, cur_a);
           triangle_comp_idx = 0;
           stashed_vertices = 0;
         }
@@ -723,8 +744,8 @@ void
 hidgl_fill_rect (int x1, int y1, int x2, int y2)
 {
   hidgl_ensure_triangle_space (&buffer, 2);
-  hidgl_add_triangle (&buffer, x1, y1, x1, y2, x2, y2);
-  hidgl_add_triangle (&buffer, x2, y1, x2, y2, x1, y1);
+  hidgl_add_triangle (&buffer, x1, y1, x1, y2, x2, y2, cur_r, cur_g, cur_b, cur_a);
+  hidgl_add_triangle (&buffer, x2, y1, x2, y2, x1, y1, cur_r, cur_g, cur_b, cur_a);
 }
 
 void
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index 1005235..89ef8a5 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -23,13 +23,26 @@
 #ifndef __HIDGL_INCLUDED__
 #define __HIDGL_INCLUDED__
 
+typedef struct {
+  GLfloat x;
+  GLfloat y;
+  GLfloat z;
+  GLfloat r;
+  GLfloat g;
+  GLfloat b;
+  GLfloat a;
+} tri_array_element;
+
 #define TRIANGLE_ARRAY_SIZE 5461
-#define TRIANGLE_ARRAY_BYTES (3 * 3 * sizeof (GLfloat) * TRIANGLE_ARRAY_SIZE)
+#define TRIANGLE_ARRAY_BYTES (3 * sizeof (tri_array_element) * TRIANGLE_ARRAY_SIZE)
+
 typedef struct {
 //  GLfloat triangle_array [3 * 3 * TRIANGLE_ARRAY_SIZE];
-  GLfloat *triangle_array;
+//  GLfloat *triangle_array;
+  tri_array_element *triangle_array;
   unsigned int triangle_count;
-  unsigned int coord_comp_count;
+//  unsigned int coord_comp_count;
+  unsigned int array_size;
   GLuint vbo_name;
 } triangle_buffer;
 
@@ -39,22 +52,42 @@ extern float global_depth;
 void hidgl_init_triangle_array (triangle_buffer *buffer);
 void hidgl_flush_triangles (triangle_buffer *buffer);
 void hidgl_ensure_triangle_space (triangle_buffer *buffer, int count);
+void hidgl_color (GLfloat r, GLfloat g, GLfloat b, GLfloat a);
 
 static inline void
 hidgl_add_triangle_3D (triangle_buffer *buffer,
                        GLfloat x1, GLfloat y1, GLfloat z1,
                        GLfloat x2, GLfloat y2, GLfloat z2,
-                       GLfloat x3, GLfloat y3, GLfloat z3)
+                       GLfloat x3, GLfloat y3, GLfloat z3,
+                       GLfloat r, GLfloat g,
+                       GLfloat b, GLfloat a)
 {
-  buffer->triangle_array [buffer->coord_comp_count++] = x1;
-  buffer->triangle_array [buffer->coord_comp_count++] = y1;
-  buffer->triangle_array [buffer->coord_comp_count++] = z1;
-  buffer->triangle_array [buffer->coord_comp_count++] = x2;
-  buffer->triangle_array [buffer->coord_comp_count++] = y2;
-  buffer->triangle_array [buffer->coord_comp_count++] = z2;
-  buffer->triangle_array [buffer->coord_comp_count++] = x3;
-  buffer->triangle_array [buffer->coord_comp_count++] = y3;
-  buffer->triangle_array [buffer->coord_comp_count++] = z3;
+  int i = 0;
+
+  buffer->triangle_array[buffer->triangle_count * 3 + i].x = x1;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].y = y1;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].z = z1;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].r = r;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].g = g;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].b = b;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].a = a;
+  i++;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].x = x2;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].y = y2;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].z = z2;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].r = r;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].g = g;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].b = b;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].a = a;
+  i++;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].x = x3;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].y = y3;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].z = z3;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].r = r;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].g = g;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].b = b;
+  buffer->triangle_array[buffer->triangle_count * 3 + i].a = a;
+
   buffer->triangle_count++;
 }
 
@@ -62,11 +95,14 @@ static inline void
 hidgl_add_triangle (triangle_buffer *buffer,
                     GLfloat x1, GLfloat y1,
                     GLfloat x2, GLfloat y2,
-                    GLfloat x3, GLfloat y3)
+                    GLfloat x3, GLfloat y3,
+                    GLfloat r, GLfloat g,
+                    GLfloat b, GLfloat a)
 {
   hidgl_add_triangle_3D (buffer, x1, y1, global_depth,
                                  x2, y2, global_depth,
-                                 x3, y3, global_depth);
+                                 x3, y3, global_depth,
+                                 r, g, b, a);
 }
 
 // void draw_grid ()
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 2a9d810..8eca81c 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -420,7 +420,272 @@ ghid_set_layer (const char *name, int group, int empty)
     return PCB->Data->Layer[idx].On;
   }
 
+<<<<<<< current
   if (idx < 0)
+=======
+  if (idx < 0) {
+    switch (SL_TYPE (idx)) {
+      case SL_INVISIBLE:
+        return PCB->InvisibleObjectsOn;
+      case SL_MASK:
+        if (SL_MYSIDE (idx))
+          return TEST_FLAG (SHOWMASKFLAG, PCB);
+        return 0;
+      case SL_SILK:
+        gport->trans_lines = TRUE;
+        if (SL_MYSIDE (idx))
+          return PCB->ElementOn;
+        return 0;
+      case SL_ASSY:
+        return 0;
+      case SL_RATS:
+        gport->trans_lines = TRUE;
+        return 1;
+      case SL_PDRILL:
+      case SL_UDRILL:
+        return 1;
+    }
+  }
+  return 0;
+}
+
+void
+ghid_use_mask (int use_it)
+{
+  static int stencil_bit = 0;
+
+  /* THE FOLLOWING IS COMPLETE ABUSE OF THIS MASK RENDERING API... NOT IMPLEMENTED */
+  if (use_it == HID_LIVE_DRAWING ||
+      use_it == HID_LIVE_DRAWING_OFF ||
+      use_it == HID_FLUSH_DRAW_Q) {
+    return;
+  }
+
+  if (use_it == cur_mask)
+    return;
+
+  /* Flush out any existing geoemtry to be rendered */
+  hidgl_flush_triangles (&buffer);
+
+  switch (use_it)
+    {
+    case HID_MASK_BEFORE:
+      /* Write '1' to the stencil buffer where the solder-mask is drawn. */
+      glColorMask (0, 0, 0, 0);                   // Disable writting in color buffer
+      glEnable (GL_STENCIL_TEST);                 // Enable Stencil test
+      stencil_bit = hidgl_assign_clear_stencil_bit();       // Get a new (clean) bitplane to stencil with
+      glStencilFunc (GL_ALWAYS, stencil_bit, stencil_bit);  // Always pass stencil test, write stencil_bit
+      glStencilMask (stencil_bit);                          // Only write to our subcompositing stencil bitplane
+      glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value (with 1)
+      break;
+
+    case HID_MASK_CLEAR:
+      /* Drawing operations clear the stencil buffer to '0' */
+      glStencilFunc (GL_ALWAYS, 0, stencil_bit);  // Always pass stencil test, write 0
+      glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value (with 0)
+      break;
+
+    case HID_MASK_AFTER:
+      /* Drawing operations as masked to areas where the stencil buffer is '1' */
+      glColorMask (1, 1, 1, 1);                   // Enable drawing of r, g, b & a
+      glStencilFunc (GL_LEQUAL, stencil_bit, stencil_bit);   // Draw only where our bit of the stencil buffer is set
+      glStencilOp (GL_KEEP, GL_KEEP, GL_KEEP);    // Stencil buffer read only
+      break;
+
+    case HID_MASK_OFF:
+      /* Disable stenciling */
+      hidgl_return_stencil_bit (stencil_bit);               // Relinquish any bitplane we previously used
+      glDisable (GL_STENCIL_TEST);                // Disable Stencil test
+      break;
+    }
+  cur_mask = use_it;
+}
+
+void
+ghid_extents_use_mask (int use_it)
+{
+}
+
+
+typedef struct
+{
+  int color_set;
+  GdkColor color;
+  int xor_set;
+  GdkColor xor_color;
+  double red;
+  double green;
+  double blue;
+} ColorCache;
+
+
+  /* Config helper functions for when the user changes color preferences.
+     |  set_special colors used in the gtkhid.
+   */
+static void
+set_special_grid_color (void)
+{
+  if (!gport->colormap)
+    return;
+  gport->grid_color.red ^= gport->bg_color.red;
+  gport->grid_color.green ^= gport->bg_color.green;
+  gport->grid_color.blue ^= gport->bg_color.blue;
+//  gdk_color_alloc (gport->colormap, &gport->grid_color);
+}
+
+void
+ghid_set_special_colors (HID_Attribute * ha)
+{
+  if (!ha->name || !ha->value)
+    return;
+  if (!strcmp (ha->name, "background-color"))
+    {
+      ghid_map_color_string (*(char **) ha->value, &gport->bg_color);
+      set_special_grid_color ();
+    }
+  else if (!strcmp (ha->name, "off-limit-color"))
+  {
+      ghid_map_color_string (*(char **) ha->value, &gport->offlimits_color);
+    }
+  else if (!strcmp (ha->name, "grid-color"))
+    {
+      ghid_map_color_string (*(char **) ha->value, &gport->grid_color);
+      set_special_grid_color ();
+    }
+}
+
+/* static */ char *current_color = NULL;
+/* static */ double global_alpha_mult = 1.0;
+/* static */ int alpha_changed = 0;
+
+void
+ghid_set_color (hidGC gc, const char *name)
+{
+  static void *cache = NULL;
+  hidval cval;
+  ColorCache *cc;
+  double alpha_mult = 1.0;
+  double r, g, b, a;
+  a = 1.0;
+
+  if (!alpha_changed && current_color != NULL)
+    {
+      if (strcmp (name, current_color) == 0)
+        return;
+      free (current_color);
+    }
+
+  alpha_changed = 0;
+
+  current_color = strdup (name);
+
+  if (name == NULL)
+    {
+      fprintf (stderr, "%s():  name = NULL, setting to magenta\n",
+               __FUNCTION__);
+      name = "magenta";
+    }
+
+  gc->colorname = (char *) name;
+
+  if (gport->colormap == 0)
+    gport->colormap = gtk_widget_get_colormap (gport->top_window);
+  if (strcmp (name, "erase") == 0)
+    {
+      gc->erase = 1;
+      r = gport->bg_color.red   / 65535.;
+      g = gport->bg_color.green / 65535.;
+      b = gport->bg_color.blue  / 65535.;
+    }
+  else if (strcmp (name, "drill") == 0)
+    {
+      gc->erase = 0;
+      alpha_mult = 0.85;
+      r = gport->offlimits_color.red   / 65535.;
+      g = gport->offlimits_color.green / 65535.;
+      b = gport->offlimits_color.blue  / 65535.;
+    }
+  else
+    {
+      alpha_mult = 0.7;
+      if (hid_cache_color (0, name, &cval, &cache))
+        cc = (ColorCache *) cval.ptr;
+      else
+        {
+          cc = (ColorCache *) malloc (sizeof (ColorCache));
+          memset (cc, 0, sizeof (*cc));
+          cval.ptr = cc;
+          hid_cache_color (1, name, &cval, &cache);
+        }
+
+      if (!cc->color_set)
+        {
+          if (gdk_color_parse (name, &cc->color))
+            gdk_color_alloc (gport->colormap, &cc->color);
+          else
+            gdk_color_white (gport->colormap, &cc->color);
+          cc->red   = cc->color.red   / 65535.;
+          cc->green = cc->color.green / 65535.;
+          cc->blue  = cc->color.blue  / 65535.;
+          cc->color_set = 1;
+        }
+      if (gc->xor)
+        {
+          if (!cc->xor_set)
+            {
+              cc->xor_color.red = cc->color.red ^ gport->bg_color.red;
+              cc->xor_color.green = cc->color.green ^ gport->bg_color.green;
+              cc->xor_color.blue = cc->color.blue ^ gport->bg_color.blue;
+              gdk_color_alloc (gport->colormap, &cc->xor_color);
+              cc->red   = cc->color.red   / 65535.;
+              cc->green = cc->color.green / 65535.;
+              cc->blue  = cc->color.blue  / 65535.;
+              cc->xor_set = 1;
+            }
+        }
+      r = cc->red;
+      g = cc->green;
+      b = cc->blue;
+
+      gc->erase = 0;
+    }
+  if (1) {
+    double maxi, mult;
+    alpha_mult *= global_alpha_mult;
+    if (gport->trans_lines)
+      a = a * alpha_mult;
+    maxi = r;
+    if (g > maxi) maxi = g;
+    if (b > maxi) maxi = b;
+    mult = MIN (1 / alpha_mult, 1 / maxi);
+#if 1
+    r = r * mult;
+    g = g * mult;
+    b = b * mult;
+#endif
+  }
+
+  if( ! ghid_gui_is_up )
+    return;
+
+  hidgl_color (r, g, b, a);
+}
+
+void
+ghid_global_alpha_mult (hidGC gc, double alpha_mult)
+{
+  if (alpha_mult != global_alpha_mult) {
+    global_alpha_mult = alpha_mult;
+    alpha_changed = 1;
+    ghid_set_color (gc, current_color);
+  }
+}
+
+void
+ghid_set_line_cap (hidGC gc, EndCapStyle style)
+{
+  switch (style)
+>>>>>>> patched
     {
       switch (SL_TYPE (idx))
 	{

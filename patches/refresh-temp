Bottom: c7fefb2b00077313535e2f32b95b55e4aee4fec4
Top:    edab551fcc7b1b59ef6253cea341869fa0f4cde7
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2012-12-25 13:22:30 +0000

Refresh of find-c-pass-flags-to-sub-funct

---

diff --git a/src/find.c b/src/find.c
index a21f85b..0cfe1b7 100644
--- a/src/find.c
+++ b/src/find.c
@@ -285,7 +285,7 @@ static bool LookupLOConnectionsToLine (LineType *, Cardinal, int, bool, bool);
 static bool LookupLOConnectionsToPad (PadType *, Cardinal, int, bool);
 static bool LookupLOConnectionsToPolygon (PolygonType *, Cardinal, int, bool);
 static bool LookupLOConnectionsToArc (ArcType *, Cardinal, int, bool);
-static bool LookupLOConnectionsToRatEnd (PointType *, Cardinal);
+static bool LookupLOConnectionsToRatEnd (PointType *, Cardinal, int);
 static bool IsRatPointOnLineEnd (PointType *, LineType *);
 static bool ArcArcIntersect (ArcType *, ArcType *);
 static bool PrepareNextLoop (FILE *);
@@ -727,6 +727,8 @@ LookupLOConnectionsToPVList (int flag, bool AndRats)
   Cardinal layer_no;
   struct pv_info info;
 
+  info.flag = flag;
+
   /* loop over all PVs currently on list */
   while (PVList.Location < PVList.Number)
     {
@@ -820,11 +822,11 @@ LookupLOConnectionsToLOList (int flag, bool AndRats)
             {
               group = RATLIST_ENTRY (*position)->group1;
               if (LookupLOConnectionsToRatEnd
-                  (&(RATLIST_ENTRY (*position)->Point1), group))
+                  (&(RATLIST_ENTRY (*position)->Point1), group, flag))
                 return (true);
               group = RATLIST_ENTRY (*position)->group2;
               if (LookupLOConnectionsToRatEnd
-                  (&(RATLIST_ENTRY (*position)->Point2), group))
+                  (&(RATLIST_ENTRY (*position)->Point2), group, flag))
                 return (true);
             }
         }
@@ -930,6 +932,7 @@ LookupPVConnectionsToPVList (int flag)
   Cardinal save_place;
   struct pv_info info;
 
+  info.flag = flag;
 
   /* loop over all PVs on list */
   save_place = PVList.Location;
@@ -1089,6 +1092,8 @@ LookupPVConnectionsToLOList (int flag, bool AndRats)
   Cardinal layer;
   struct lo_info info;
 
+  info.flag = flag;
+
   /* loop over all layers */
   for (layer = 0; layer < max_copper_layer; layer++)
     {
@@ -1709,6 +1714,7 @@ LookupLOConnectionsToArc (ArcType *Arc, Cardinal LayerGroup, int flag, bool AndR
   struct lo_info info;
   BoxType search_box;
 
+  info.flag = flag;
   info.arc = Arc;
   search_box = expand_bounds ((BoxType *)info.arc);
 
@@ -1839,6 +1845,7 @@ LookupLOConnectionsToLine (LineType *Line, Cardinal LayerGroup,
   struct lo_info info;
   BoxType search_box;
 
+  info.flag = flag;
   info.layer = LayerGroup;
   info.line = Line;
   search_box = expand_bounds ((BoxType *)info.line);
@@ -1965,11 +1972,12 @@ LOCtoPad_callback (const BoxType * b, void *cl)
  * Xij means Xj at line i
  */
 static bool
-LookupLOConnectionsToRatEnd (PointType *Point, Cardinal LayerGroup)
+LookupLOConnectionsToRatEnd (PointType *Point, Cardinal LayerGroup, int flag)
 {
   Cardinal entry;
   struct rat_info info;
 
+  info.flag = flag;
   info.Point = Point;
   /* loop over all layers of this group */
   for (entry = 0; entry < PCB->LayerGroups.Number[LayerGroup]; entry++)
@@ -2112,6 +2120,7 @@ LookupLOConnectionsToPad (PadType *Pad, Cardinal LayerGroup, int flag, bool AndR
   if (!TEST_FLAG (SQUAREFLAG, Pad))
     return (LookupLOConnectionsToLine ((LineType *) Pad, LayerGroup, flag, false, AndRats));
 
+  info.flag = flag;
   info.pad = Pad;
   search_box = expand_bounds ((BoxType *)info.pad);
 
@@ -2246,6 +2255,8 @@ LookupLOConnectionsToPolygon (PolygonType *Polygon, Cardinal LayerGroup, int fla
 
   if (!Polygon->Clipped)
     return false;
+
+  info.flag = flag;
   info.polygon = Polygon;
   search_box = expand_bounds ((BoxType *)info.polygon);
 
@@ -3290,6 +3301,11 @@ DumpList (void)
   RatList.DrawLocation = 0;
 }
 
+struct drc_info
+{
+  int flag;
+};
+
 /*-----------------------------------------------------------------------------
  * Check for DRC violations on a single net starting from the pad or pin
  * sees if the connectivity changes when everything is bloated, or shrunk
@@ -3436,6 +3452,7 @@ static int
 drc_callback (DataType *data, LayerType *layer, PolygonType *polygon,
               int type, void *ptr1, void *ptr2, void *userdata)
 {
+  struct drc_info *i = (struct drc_info *) userdata;
   char *message;
   Coord x, y;
   int object_count;
@@ -3458,7 +3475,7 @@ drc_callback (DataType *data, LayerType *layer, PolygonType *polygon,
       if (line->Clearance < 2 * PCB->Bloat)
         {
           AddObjectToFlagUndoList (type, ptr1, ptr2, ptr2);
-          SET_FLAG (flag, line);
+          SET_FLAG (i->flag, line);
           message = _("Line with insufficient clearance inside polygon\n");
           goto doIsBad;
         }
@@ -3467,7 +3484,7 @@ drc_callback (DataType *data, LayerType *layer, PolygonType *polygon,
       if (arc->Clearance < 2 * PCB->Bloat)
         {
           AddObjectToFlagUndoList (type, ptr1, ptr2, ptr2);
-          SET_FLAG (flag, arc);
+          SET_FLAG (i->flag, arc);
           message = _("Arc with insufficient clearance inside polygon\n");
           goto doIsBad;
         }
@@ -3477,7 +3494,7 @@ drc_callback (DataType *data, LayerType *layer, PolygonType *polygon,
 	if (IsPadInPolygon(pad,polygon))
 	  {
 	    AddObjectToFlagUndoList (type, ptr1, ptr2, ptr2);
-	    SET_FLAG (flag, pad);
+	    SET_FLAG (i->flag, pad);
 	    message = _("Pad with insufficient clearance inside polygon\n");
 	    goto doIsBad;
 	  }
@@ -3486,7 +3503,7 @@ drc_callback (DataType *data, LayerType *layer, PolygonType *polygon,
       if (pin->Clearance && pin->Clearance < 2 * PCB->Bloat)
         {
           AddObjectToFlagUndoList (type, ptr1, ptr2, ptr2);
-          SET_FLAG (flag, pin);
+          SET_FLAG (i->flag, pin);
           message = _("Pin with insufficient clearance inside polygon\n");
           goto doIsBad;
         }
@@ -3495,7 +3512,7 @@ drc_callback (DataType *data, LayerType *layer, PolygonType *polygon,
       if (pin->Clearance && pin->Clearance < 2 * PCB->Bloat)
         {
           AddObjectToFlagUndoList (type, ptr1, ptr2, ptr2);
-          SET_FLAG (flag, pin);
+          SET_FLAG (i->flag, pin);
           message = _("Via with insufficient clearance inside polygon\n");
           goto doIsBad;
         }
@@ -3553,6 +3570,7 @@ DRCAll (void)
   int tmpcnt;
   int nopastecnt = 0;
   int flag;
+  struct drc_info info;
 
   reset_drc_dialog_message();
 
@@ -3621,13 +3639,14 @@ DRCAll (void)
   flag = (IsBad) ? DRCFLAG : (FOUNDFLAG | DRCFLAG | SELECTEDFLAG);
   ClearFlagOnAllObjects (false, flag);
   flag = SELECTEDFLAG;
+  info.flag = flag;
   /* check minimum widths and polygon clearances */
   if (!IsBad)
     {
       COPPERLINE_LOOP (PCB->Data);
       {
         /* check line clearances in polygons */
-        PlowsPolygon (PCB->Data, LINE_TYPE, layer, line, drc_callback, NULL);
+        PlowsPolygon (PCB->Data, LINE_TYPE, layer, line, drc_callback, &info);
         if (IsBad)
           break;
         if (line->Thickness < PCB->minWid)
@@ -3669,7 +3688,7 @@ DRCAll (void)
     {
       COPPERARC_LOOP (PCB->Data);
       {
-        PlowsPolygon (PCB->Data, ARC_TYPE, layer, arc, drc_callback, NULL);
+        PlowsPolygon (PCB->Data, ARC_TYPE, layer, arc, drc_callback, &info);
         if (IsBad)
           break;
         if (arc->Thickness < PCB->minWid)
@@ -3711,7 +3730,7 @@ DRCAll (void)
     {
       ALLPIN_LOOP (PCB->Data);
       {
-        PlowsPolygon (PCB->Data, PIN_TYPE, element, pin, drc_callback, NULL);
+        PlowsPolygon (PCB->Data, PIN_TYPE, element, pin, drc_callback, &info);
         if (IsBad)
           break;
         if (!TEST_FLAG (HOLEFLAG, pin) &&
@@ -3785,7 +3804,7 @@ DRCAll (void)
     {
       ALLPAD_LOOP (PCB->Data);
       {
-        PlowsPolygon (PCB->Data, PAD_TYPE, element, pad, drc_callback, NULL);
+        PlowsPolygon (PCB->Data, PAD_TYPE, element, pad, drc_callback, &info);
         if (IsBad)
           break;
         if (pad->Thickness < PCB->minWid)
@@ -3827,7 +3846,7 @@ DRCAll (void)
     {
       VIA_LOOP (PCB->Data);
       {
-        PlowsPolygon (PCB->Data, VIA_TYPE, via, via, drc_callback, NULL);
+        PlowsPolygon (PCB->Data, VIA_TYPE, via, via, drc_callback, &info);
         if (IsBad)
           break;
         if (!TEST_FLAG (HOLEFLAG, via) &&

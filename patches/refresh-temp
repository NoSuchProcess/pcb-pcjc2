Bottom: 2721d907e3d0ac30e1338e0b9408950d845c4a3d
Top:    1b074ac0f7b32825d8447f106bffe21194c9ce16
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2012-01-21 13:37:47 +0000

Refresh of butcher-the-xor-crosshair-draw

---

diff --git a/src/crosshair.c b/src/crosshair.c
index 9f67d9b..1a4d1ad 100644
--- a/src/crosshair.c
+++ b/src/crosshair.c
@@ -51,6 +51,7 @@
 #include <dmalloc.h>
 #endif
 
+
 static bool
 make_arc_from_crosshair (ArcType *arc, Coord thick)
 {
@@ -105,7 +106,7 @@ make_arc_from_crosshair (ArcType *arc, Coord thick)
  * draws the rubberband to insert points into polygons/lines/...
  */
 static void
-XORDrawInsertPointObject (void)
+XORDrawInsertPointObject (DrawAPI *dapi)
 {
   LineType *line;
   PointType *point;
@@ -116,15 +117,15 @@ XORDrawInsertPointObject (void)
   if (Crosshair.AttachedObject.Type == NO_TYPE)
     return;
 
-  gui->draw_line (Crosshair.GC, point->X, point->Y, line->Point1.X, line->Point1.Y);
-  gui->draw_line (Crosshair.GC, point->X, point->Y, line->Point2.X, line->Point2.Y);
+  dapi->gapi->draw_line (dapi->gc, point->X, point->Y, line->Point1.X, line->Point1.Y);
+  dapi->gapi->draw_line (dapi->gc, point->X, point->Y, line->Point2.X, line->Point2.Y);
 }
 
 /* ---------------------------------------------------------------------------
  * draws the attached object while in MOVE_MODE or COPY_MODE
  */
 static void
-XORDrawMoveOrCopyObject (void)
+draw_move_or_copy_object (DrawAPI *dapi)
 {
   RubberbandType *ptr;
   Cardinal i;
@@ -137,39 +138,39 @@ XORDrawMoveOrCopyObject (void)
    *     they draw, so we will have to make some distinction as to which routines may
    *     set this (and not call them from inside one another!)
    */
-  // dapi->set_draw_offset (dx, dy);
+  // dapi->set_draw_offset (dapi, dx, dy);
 
   switch (Crosshair.AttachedObject.Type)
     {
     case VIA_TYPE:
       {
         PinType *via = (PinType *)Crosshair.AttachedObject.Ptr1;
-        dapi->set_draw_offset (dx, dy);
-        dapi->draw_pcb_via (via);
+        dapi->set_draw_offset (dapi, dx, dy);
+        dapi->draw_pcb_via (dapi, via);
         break;
       }
 
     case LINE_TYPE:
       {
         LineType *line = (LineType *)Crosshair.AttachedObject.Ptr2;
-        dapi->set_draw_offset (dx, dy);
-        dapi->draw_pcb_line (line);
+        dapi->set_draw_offset (dapi, dx, dy);
+        dapi->draw_pcb_line (dapi, NULL, line);
         break;
       }
 
     case ARC_TYPE:
       {
         ArcType *arc = (ArcType *)Crosshair.AttachedObject.Ptr2;
-        dapi->set_draw_offset (dx, dy);
-        dapi->draw_pcb_arc (arc);
+        dapi->set_draw_offset (dapi, dx, dy);
+        dapi->draw_pcb_arc (dapi, NULL, arc);
         break;
       }
 
     case POLYGON_TYPE:
       {
         PolygonType *poly = (PolygonType *)Crosshair.AttachedObject.Ptr2;
-        dapi->set_draw_offset (dx, dy);
-        dapi->draw_pcb_polygon (poly);
+        dapi->set_draw_offset (dapi, dx, dy);
+        dapi->draw_pcb_polygon (dapi, NULL, poly);
         break;
       }
 
@@ -190,7 +191,7 @@ XORDrawMoveOrCopyObject (void)
             draw_line.Point2.Y += dy;
           }
 
-        dapi->draw_pcb_line (&draw_line);
+        dapi->draw_pcb_line (dapi, NULL, &draw_line);
         break;
       }
 
@@ -211,12 +212,12 @@ XORDrawMoveOrCopyObject (void)
         /* XXX: Could do this by adjusting a copy polygon and drawing the entirity of that */
 
         /* draw the two segments */
-        gui->draw_line (Crosshair.GC,
-                        polygon->Points[prev].X, polygon->Points[prev].Y,
-                        point->X + dx, point->Y + dy);
-        gui->draw_line (Crosshair.GC,
-                        point->X + dx, point->Y + dy,
-                        polygon->Points[next].X, polygon->Points[next].Y);
+        dapi->gapi->draw_line (dapi->gc,
+                               polygon->Points[prev].X, polygon->Points[prev].Y,
+                               point->X + dx, point->Y + dy);
+        dapi->gapi->draw_line (dapi->gc,
+                               point->X + dx, point->Y + dy,
+                               polygon->Points[next].X, polygon->Points[next].Y);
         break;
       }
 
@@ -225,8 +226,8 @@ XORDrawMoveOrCopyObject (void)
         /* locate the element "mark" and draw an association line from crosshair to it */
         ElementType *element = (ElementType *) Crosshair.AttachedObject.Ptr1;
 
-        gui->draw_line (Crosshair.GC,
-                        element->MarkX, element->MarkY, Crosshair.X, Crosshair.Y);
+        dapi->gapi->draw_line (dapi->gc,
+                               element->MarkX, element->MarkY, Crosshair.X, Crosshair.Y);
         /* fall through to move the text as a box outline */
       }
     case TEXT_TYPE:
@@ -234,8 +235,9 @@ XORDrawMoveOrCopyObject (void)
         TextType *text = (TextType *) Crosshair.AttachedObject.Ptr2;
         BoxType *box = &text->BoundingBox;
 
-        dapi->set_draw_offset (dx, dy);
-        gui->draw_rect (Crosshair.GC, box->X1, box->Y1, box->X2, box->Y2);
+        dapi->set_draw_offset (dapi, dx, dy);
+        /* XXX: DOES THIS WORK IN CONJUNCTION WITH THE ABOVE? */
+        dapi->gapi->draw_rect (dapi->gc, box->X1, box->Y1, box->X2, box->Y2);
         break;
       }
 
@@ -246,8 +248,8 @@ XORDrawMoveOrCopyObject (void)
       {
         ElementType *element = (ElementType *) Crosshair.AttachedObject.Ptr2;
 
-        dapi->set_draw_offset (dx, dy);
-        dapi->draw_pcb_element (element);
+        dapi->set_draw_offset (dapi, dx, dy);
+        dapi->draw_pcb_element (dapi, element);
         break;
       }
     }
@@ -276,12 +278,12 @@ XORDrawMoveOrCopyObject (void)
               draw_line.Point2.Y += dy;
             }
 
-          dapi->draw_pcb_line (draw_line);
+          dapi->draw_pcb_line (dapi, NULL, &draw_line);
         }
       else if (ptr->MovedPoint == &ptr->Line->Point1) /* XXX: What is this conditional for ?? */
         {
-          dapi->set_draw_offset (dx, dy);
-          dapi->draw_pcb_line (ptr->Line);
+          dapi->set_draw_offset (dapi, dx, dy);
+          dapi->draw_pcb_line (dapi, NULL, ptr->Line);
         }
 
       ptr++;
@@ -293,8 +295,19 @@ XORDrawMoveOrCopyObject (void)
  * draws additional stuff that follows the crosshair
  */
 void
-DrawAttached (void)
+DrawAttached (DrawAPI *dapi)
 {
+  /* DEBUG ONLY */
+  if (dapi == NULL)
+    return;
+
+  dapi->gc = dapi->gapi->make_gc ();
+
+  dapi->gapi->set_color (dapi->gc, Settings.CrosshairColor);
+  dapi->gapi->set_draw_xor (dapi->gc, 1);
+  dapi->gapi->set_line_cap (dapi->gc, Trace_Cap);
+  dapi->gapi->set_line_width (dapi->gc, 1);
+
   switch (Settings.Mode)
     {
     case VIA_MODE:
@@ -309,15 +322,15 @@ DrawAttached (void)
         via.Mask = 0;
         via.Flags = NoFlags ();
 
-        dapi->draw_pcb_pv (Crosshair.GC, Crosshair.GC, &via, true, false);
+        dapi->draw_pcb_via (dapi, &via);
 
         if (TEST_FLAG (SHOWDRCFLAG, PCB))
           {
             /* XXX: Naughty cheat - use the mask to draw DRC clearance! */
             via.Mask = Settings.ViaThickness + PCB->Bloat * 2;
-            gui->set_color (Crosshair.GC, Settings.CrossColor);
-            dapi->draw_pcb_pv (Crosshair.GC, Crosshair.GC, &via, false, true);
-            gui->set_color (Crosshair.GC, Settings.CrosshairColor);
+            dapi->gapi->set_color (dapi->gc, Settings.CrossColor);
+            dapi->draw_pcb_via_mask (dapi, &via);
+            dapi->gapi->set_color (dapi->gc, Settings.CrosshairColor);
           }
         break;
       }
@@ -327,13 +340,13 @@ DrawAttached (void)
     case POLYGONHOLE_MODE:
       /* draw only if starting point is set */
       if (Crosshair.AttachedLine.State != STATE_FIRST)
-        gui->draw_line (Crosshair.GC,
-                        Crosshair.AttachedLine.Point1.X, Crosshair.AttachedLine.Point1.Y,
-                        Crosshair.AttachedLine.Point2.X, Crosshair.AttachedLine.Point2.Y);
+        dapi->gapi->draw_line (dapi->gc,
+                               Crosshair.AttachedLine.Point1.X, Crosshair.AttachedLine.Point1.Y,
+                               Crosshair.AttachedLine.Point2.X, Crosshair.AttachedLine.Point2.Y);
 
       /* draw attached polygon only if in POLYGON_MODE or POLYGONHOLE_MODE */
       if (Crosshair.AttachedPolygon.PointN > 1)
-        dapi->draw_pcb_polygon (&Crosshair.AttachedPolygon);
+        dapi->draw_pcb_polygon (dapi, NULL, &Crosshair.AttachedPolygon);
       break;
 
     case ARC_MODE:
@@ -346,14 +359,14 @@ DrawAttached (void)
         if (!make_arc_from_crosshair (&arc, Settings.LineThickness))
           break;
 
-        dapi->draw_pcb_arc (&arc);
+        dapi->draw_pcb_arc (dapi, NULL, &arc);
         if (TEST_FLAG (SHOWDRCFLAG, PCB))
           {
             if (!make_arc_from_crosshair (&arc, Settings.LineThickness + 2 * (PCB->Bloat + 1)))
               break;
-            gui->set_color (Crosshair.GC, Settings.CrossColor);
-            dapi->draw_pcb_arc (&arc);
-            gui->set_color (Crosshair.GC, Settings.CrosshairColor);
+            dapi->gapi->set_color (dapi->gc, Settings.CrossColor);
+            dapi->draw_pcb_arc (dapi, NULL, &arc);
+            dapi->gapi->set_color (dapi->gc, Settings.CrosshairColor);
           }
 
         break;
@@ -374,32 +387,32 @@ DrawAttached (void)
           draw_line.Flags = NoFlags ();
 
           draw_line.Thickness = PCB->RatDraw ? 10 : Settings.LineThickness;
-          dapi->draw_pcb_line (draw_line);
+          dapi->draw_pcb_line (dapi, NULL, &draw_line);
 
           if (PCB->Clipping)
             {
               draw_line.Point1.X = Crosshair.X;
               draw_line.Point1.Y = Crosshair.Y;
-              dapi->draw_pcb_line (draw_line);
+              dapi->draw_pcb_line (dapi, NULL, &draw_line);
             }
 
           if (TEST_FLAG (SHOWDRCFLAG, PCB))
             {
-              gui->set_color (Crosshair.GC, Settings.CrossColor);
+              dapi->gapi->set_color (dapi->gc, Settings.CrossColor);
 
               draw_line.Point1 = Crosshair.AttachedLine.Point1;
               draw_line.Point2 = Crosshair.AttachedLine.Point2;
               draw_line.Thickness = PCB->RatDraw ? 10 : Settings.LineThickness + 2 * (PCB->Bloat + 1);
-              dapi->draw_pcb_line (draw_line);
+              dapi->draw_pcb_line (dapi, NULL, &draw_line);
 
               if (PCB->Clipping)
                 {
                   draw_line.Point1.X = Crosshair.X;
                   draw_line.Point1.Y = Crosshair.Y;
-                  dapi->draw_pcb_line (draw_line);
+                  dapi->draw_pcb_line (dapi, NULL, &draw_line);
                 }
 
-              gui->set_color (Crosshair.GC, Settings.CrosshairColor);
+              dapi->gapi->set_color (dapi->gc, Settings.CrosshairColor);
             }
         }
       break;
@@ -409,18 +422,18 @@ DrawAttached (void)
        *     they draw, so we will have to make some distinction as to which routines may
        *     set this (and not call them from inside one another!)
        */
-      dapi->set_draw_offset (Crosshair.X - PASTEBUFFER->X,
+      dapi->set_draw_offset (dapi, Crosshair.X - PASTEBUFFER->X,
                              Crosshair.Y - PASTEBUFFER->Y);
-      dapi->draw_pcb_buffer (PASTEBUFFER);
+      dapi->draw_pcb_buffer (dapi, PASTEBUFFER);
       break;
 
     case COPY_MODE:
     case MOVE_MODE:
-      XORDrawMoveOrCopyObject ();
+      draw_move_or_copy_object (dapi);
       break;
 
     case INSERTPOINT_MODE:
-      XORDrawInsertPointObject ();
+      XORDrawInsertPointObject (dapi);
       break;
     }
 
@@ -434,8 +447,10 @@ DrawAttached (void)
       y1 = Crosshair.AttachedBox.Point1.Y;
       x2 = Crosshair.AttachedBox.Point2.X;
       y2 = Crosshair.AttachedBox.Point2.Y;
-      gui->draw_rect (Crosshair.GC, x1, y1, x2, y2);
+      dapi->gapi->draw_rect (dapi->gc, x1, y1, x2, y2);
     }
+
+  dapi->gapi->destroy_gc (dapi->gc);
 }
 
 
@@ -443,16 +458,28 @@ DrawAttached (void)
  * draw the marker position
  */
 void
-DrawMark (void)
+DrawMark (DrawAPI *dapi)
 {
+  /* DEBUG ONLY */
+  if (dapi == NULL)
+    return;
+
   /* Mark is not drawn when it is not set */
   if (!Marked.status)
     return;
 
-  gui->draw_line (Crosshair.GC, Marked.X - MARK_SIZE, Marked.Y - MARK_SIZE,
-                                Marked.X + MARK_SIZE, Marked.Y + MARK_SIZE);
-  gui->draw_line (Crosshair.GC, Marked.X + MARK_SIZE, Marked.Y - MARK_SIZE,
-                                Marked.X - MARK_SIZE, Marked.Y + MARK_SIZE);
+  dapi->gc = dapi->gapi->make_gc ();
+
+  dapi->gapi->set_color (dapi->gc, Settings.CrosshairColor);
+  dapi->gapi->set_draw_xor (dapi->gc, 1);
+  dapi->gapi->set_line_cap (dapi->gc, Trace_Cap);
+  dapi->gapi->set_line_width (dapi->gc, 1);
+
+  dapi->gapi->draw_line (dapi->gc, Marked.X - MARK_SIZE, Marked.Y - MARK_SIZE,
+                                   Marked.X + MARK_SIZE, Marked.Y + MARK_SIZE);
+  dapi->gapi->draw_line (dapi->gc, Marked.X + MARK_SIZE, Marked.Y - MARK_SIZE,
+                                   Marked.X - MARK_SIZE, Marked.Y + MARK_SIZE);
+  dapi->gapi->destroy_gc (dapi->gc);
 }
 
 /* ---------------------------------------------------------------------------
@@ -945,13 +972,6 @@ SetCrosshairRange (Coord MinX, Coord MinY, Coord MaxX, Coord MaxY)
 void
 InitCrosshair (void)
 {
-  Crosshair.GC = gui->make_gc ();
-
-  gui->set_color (Crosshair.GC, Settings.CrosshairColor);
-  gui->set_draw_xor (Crosshair.GC, 1);
-  gui->set_line_cap (Crosshair.GC, Trace_Cap);
-  gui->set_line_width (Crosshair.GC, 1);
-
   /* set initial shape */
   Crosshair.shape = Basic_Crosshair_Shape;
 
@@ -971,5 +991,4 @@ void
 DestroyCrosshair (void)
 {
   FreePolygonMemory (&Crosshair.AttachedPolygon);
-  gui->destroy_gc (Crosshair.GC);
 }
diff --git a/src/crosshair.h b/src/crosshair.h
index 2dd5e7e..3825057 100644
--- a/src/crosshair.h
+++ b/src/crosshair.h
@@ -30,7 +30,9 @@
 #ifndef	PCB_CROSSHAIR_H
 #define	PCB_CROSSHAIR_H
 
+/* Naughty */
 #include "global.h"
+#include "draw_api.h"
 
 /* ---------------------------------------------------------------------------
  * all possible states of an attached object
@@ -44,8 +46,8 @@ void notify_crosshair_change (bool changes_complete);
 void notify_mark_change (bool changes_complete);
 void HideCrosshair (void);
 void RestoreCrosshair (void);
-void DrawAttached (void);
-void DrawMark (void);
+void DrawAttached (DrawAPI *);
+void DrawMark (DrawAPI *);
 void MoveCrosshairRelative (Coord, Coord);
 bool MoveCrosshairAbsolute (Coord, Coord);
 void SetCrosshairRange (Coord, Coord, Coord, Coord);
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index f3133ec..f79aee1 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -945,8 +945,8 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   ghid_invalidate_current_gc ();
 
-  DrawAttached ();
-  DrawMark ();
+  DrawAttached (NULL);
+  DrawMark (NULL);
   hidgl_flush_triangles (&buffer);
 
   draw_crosshair (priv);

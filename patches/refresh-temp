Bottom: 7c0ffc76b155f21648ceb9edc620cb14de86e557
Top:    e916fb9847d13133c12d127c6a5b4770dfa37a78
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2014-06-29 21:39:54 +0100

Refresh of remove-debug-from-outline

---

diff --git a/src/polygon.c b/src/polygon.c
index efbd051..a317dc3 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -105,7 +105,7 @@ dicer output is used for HIDs which cannot render things with holes
 #endif
 
 
-#define DEBUG_CIRCSEGS
+#undef DEBUG_CIRCSEGS
 
 #define ROUND(x) ((long)(((x) >= 0 ? (x) + 0.5  : (x) - 0.5)))
 
@@ -2143,18 +2143,19 @@ struct clip_outline_info {
 
 #define ROUTER_THICKNESS MIL_TO_COORD (10)
 //#define ROUTER_THICKNESS MIL_TO_COORD (0.1)
-
+#undef ROUTER_THICKNESS
+#define ROUTER_THICKNESS (line->Thickness)
 static int
 arc_outline_callback (const BoxType * b, void *cl)
 {
-  ArcType *arc = (ArcType *)b;
+  ArcType *line = (ArcType *)b;
   struct clip_outline_info *info = cl;
   POLYAREA *np, *res;
 
 #ifdef DEBUG_CIRCSEGS
-  if (!(np = ArcPoly (arc, arc->Thickness)))
+  if (!(np = ArcPoly (line, line->Thickness)))
 #else
-  if (!(np = ArcPoly (arc, ROUTER_THICKNESS)))
+  if (!(np = ArcPoly (line, ROUTER_THICKNESS)))
 #endif
     return 0;
 
diff --git a/src/polygon1.c b/src/polygon1.c
index cce3302..78ba618 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -102,7 +102,7 @@ int vect_inters2 (Vector A, Vector B, Vector C, Vector D, Vector S1,
 //#define DEBUG_JUMP
 //#define DEBUG_GATHER
 #undef DEBUG_ANGLE
-//#define DEBUG
+#undef DEBUG
 #ifdef DEBUG
 #define DEBUGP(...) pcb_fprintf(stderr, ## __VA_ARGS__)
 #else
@@ -1674,10 +1674,10 @@ Gather (VNODE * start, PLINE ** result, J_Rule v_rule, DIRECTION initdir)
       /* add edge to polygon */
 //      if ((newn = poly_CreateNodeFull (cur->point, cur->is_round, cur->cx, cur->cy, cur->radius)) == NULL) /* XXX: DIRECTION - might we need to query the previous point for arc details ?? */
       /* XXX: The cur->next part of the line below is somewhat tested, but was determined by trial and error */
-      if ((newn = poly_CreateNodeFull (cur->point, (dir == FORW) ? cur->is_round : cur->next->is_round,
-                                                   (dir == FORW) ? cur->cx       : cur->next->cx,
-                                                   (dir == FORW) ? cur->cy       : cur->next->cy,
-                                                   (dir == FORW) ? cur->radius   : cur->next->radius)) == NULL) /* XXX: DIRECTION - might we need to query the previous point for arc details ?? */
+      if ((newn = poly_CreateNodeFull (cur->point, (dir == FORW) ? cur->is_round : cur->prev->is_round,
+                                                   (dir == FORW) ? cur->cx       : cur->prev->cx,
+                                                   (dir == FORW) ? cur->cy       : cur->prev->cy,
+                                                   (dir == FORW) ? cur->radius   : cur->prev->radius)) == NULL) /* XXX: DIRECTION - might we need to query the previous point for arc details ?? */
         return err_no_memory;
       if (!*result)
 	{
@@ -2720,7 +2720,7 @@ pline_dump (VNODE * v)
   s = v;
   do
     {
-      pcb_fprintf (stderr, "%mm %mm  - %s\n", v->point[0], v->point[1], v->is_round ? "Round" : "Line");
+      pcb_fprintf (stderr, "%mn %mn  - %s, radius %mn\n", v->point[0], v->point[1], v->is_round ? "Round" : "Line", v->is_round ? v->radius : 0);
     }
   while ((v = v->next) != s);
 }
@@ -2738,10 +2738,10 @@ test_polyInvContour (void)
 
   printf ("Testing inv_contour\n");
 
-  v[0] = 0, v[1] = 0; contour = poly_NewContour (poly_CreateNode (v));
-  v[0] = 0, v[1] = 1; poly_InclVertex (contour->head.prev, poly_CreateNodeArcApproximation (v, 0, 0, 0));
-  v[0] = 1, v[1] = 1; poly_InclVertex (contour->head.prev, poly_CreateNode (v));
-  v[0] = 1; v[1] = 0; poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+  v[0] = 0, v[1] = 0;           contour = poly_NewContour (poly_CreateNodeArcApproximation (v, 0, 0, 1));
+  v[0] = 0, v[1] = 2; poly_InclVertex (contour->head.prev, poly_CreateNodeArcApproximation (v, 0, 0, 3));
+  v[0] = 0, v[1] = 4; poly_InclVertex (contour->head.prev, poly_CreateNodeArcApproximation (v, 0, 0, 5));
+  v[0] = 0; v[1] = 6; poly_InclVertex (contour->head.prev, poly_CreateNodeArcApproximation (v, 0, 0, 7));
 
   pline_dump (&contour->head);
   poly_InvContour (contour);
@@ -2762,10 +2762,22 @@ poly_InvContour (PLINE * c)
 
   /* Stash the first data which will get over-written in the loop */
 
+#if 0
   bool stash_is_round = c->head.prev->is_round;
   Coord stash_cx = c->head.prev->cx;
   Coord stash_cy = c->head.prev->cy;
   Coord stash_radius = c->head.prev->radius;
+#else
+  bool stash_is_round = c->head.is_round;
+  Coord stash_cx = c->head.cx;
+  Coord stash_cy = c->head.cy;
+  Coord stash_radius = c->head.radius;
+
+  bool next_is_round;
+  Coord next_cx;
+  Coord next_cy;
+  Coord next_radius;
+#endif
 
 //  printf ("poly_InvContour\n");
 
@@ -2773,12 +2785,28 @@ poly_InvContour (PLINE * c)
   cur = &c->head;
   do
     {
-#if 1
+#if 0
       /* Swap the attachement of round contour information */
       cur->prev->is_round = cur->is_round;
       cur->prev->cx = cur->cx;
       cur->prev->cy = cur->cy;
       cur->prev->radius = cur->radius;
+#else
+      /* Swap the attachement of round contour information */
+      next_is_round = cur->next->is_round;
+      next_cx = cur->next->cx;
+      next_cy = cur->next->cy;
+      next_radius = cur->next->radius;
+
+      cur->next->is_round = stash_is_round;
+      cur->next->cx = stash_cx;
+      cur->next->cy = stash_cy;
+      cur->next->radius = stash_radius;
+
+      stash_is_round = next_is_round;
+      stash_cx = next_cx;
+      stash_cy = next_cy;
+      stash_radius = next_radius;
 #endif
 
       next = cur->next;
@@ -2793,7 +2821,7 @@ poly_InvContour (PLINE * c)
    *     entry in the old order got stale data from the wraparound
    *     Fix that up now.
    */
-#if 1
+#if 0
   c->head.next->next->is_round = stash_is_round;
   c->head.next->next->cx = stash_cx;
   c->head.next->next->cy = stash_cy;
@@ -2855,7 +2883,8 @@ poly_InclVertex (VNODE * after, VNODE * node)
 //  printf ("a-b = %f\n", a-b);
 
   /* XXX: HMM - This doesn't seem to be involved when extra points are left in polygon contours after boolean operations */
-  if (fabs (a - b) < 1000000) //EPSILON &&
+  if (0)
+//  if (fabs (a - b) < 1000000) //EPSILON &&
 //      !node->prev->is_round && !node->is_round)
 //      !node->prev->is_round && !node->is_round)
     {

Bottom: 7b14bf4de6e1cc019909ac9ddea4bb25ec59fbea
Top:    d07098dd71542b3a6c06fd4823e133dd03d69228
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-04-18 22:10:46 +0100

Refresh of give-the-hids-control-over-att

---

diff --git a/src/action.c b/src/action.c
index e5a463f..a0577e4 100644
--- a/src/action.c
+++ b/src/action.c
@@ -607,7 +607,7 @@ click_cb (hidval hv)
 {
   if (Note.Click)
     {
-      HideCrosshair ();
+      notify_crosshair_change (false);
       Note.Click = false;
       if (Note.Moving && !gui->shift_is_pressed ())
 	{
@@ -650,7 +650,7 @@ click_cb (hidval hv)
 	  Crosshair.AttachedBox.Point1.X = Note.X;
 	  Crosshair.AttachedBox.Point1.Y = Note.Y;
 	}
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
     }
 }
 
@@ -945,7 +945,7 @@ NotifyLine (void)
 static void
 NotifyBlock (void)
 {
-  HideCrosshair ();
+  notify_crosshair_change (false);
   switch (Crosshair.AttachedBox.State)
     {
     case STATE_FIRST:		/* setup first point */
@@ -960,7 +960,7 @@ NotifyBlock (void)
       Crosshair.AttachedBox.State = STATE_THIRD;
       break;
     }
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
 }
 
 
@@ -2122,11 +2122,11 @@ ActionMovePointer (char *deltax, char *deltay)
   /* restore crosshair for erasure */
   Crosshair.X = x;
   Crosshair.Y = y;
-  HideCrosshair ();
+  notify_crosshair_change (false);
   MoveCrosshairRelative (TO_SCREEN_SIGN_X (dx), TO_SCREEN_SIGN_Y (dy));
   /* update object position and cursor location */
   AdjustAttachedObjects ();
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
 }
 
 /* ---------------------------------------------------------------------------
@@ -2152,10 +2152,9 @@ EventMoveCrosshair (int ev_x, int ev_y)
     {
       if (MoveCrosshairAbsolute (ev_x, ev_y))
 	{
-
 	  /* update object position and cursor location */
 	  AdjustAttachedObjects ();
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	}
     }
   else
@@ -2731,7 +2730,7 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 	  break;
 
 	case F_CycleClip:
-	  HideCrosshair ();
+	  notify_crosshair_change (false);
 	  if TEST_FLAG
 	    (ALLDIRECTIONFLAG, PCB)
 	    {
@@ -2741,27 +2740,27 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 	  else
 	    PCB->Clipping = (PCB->Clipping + 1) % 3;
 	  AdjustAttachedObjects ();
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  break;
 
 	case F_CycleCrosshair:
-	  HideCrosshair ();
+	  notify_crosshair_change (false);
 	  Crosshair.shape = CrosshairShapeIncrement(Crosshair.shape);
 	  if (Crosshair_Shapes_Number == Crosshair.shape)
 	    Crosshair.shape = Basic_Crosshair_Shape;
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  break;
 
 	case F_ToggleRubberBandMode:
-	  HideCrosshair ();
+	  notify_crosshair_change (false);
 	  TOGGLE_FLAG (RUBBERBANDFLAG, PCB);
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  break;
 
 	case F_ToggleStartDirection:
-	  HideCrosshair ();
+	  notify_crosshair_change (false);
 	  TOGGLE_FLAG (SWAPSTARTDIRFLAG, PCB);
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  break;
 
 	case F_ToggleUniqueNames:
@@ -2769,9 +2768,9 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 	  break;
 
 	case F_ToggleSnapPin:
-	  HideCrosshair ();
+	  notify_crosshair_change (false);
 	  TOGGLE_FLAG (SNAPPINFLAG, PCB);
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  break;
 
 	case F_ToggleLocalRef:
@@ -2812,7 +2811,7 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 	  break;
 
 	case F_ToggleAutoDRC:
-	  HideCrosshair ();
+	  notify_crosshair_change (false);
 	  TOGGLE_FLAG (AUTODRCFLAG, PCB);
 	  if (TEST_FLAG (AUTODRCFLAG, PCB) && Settings.Mode == LINE_MODE)
 	    {
@@ -2826,7 +2825,7 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 				  Crosshair.AttachedLine.Point1.Y, true, 1,
 				  FOUNDFLAG);
 	    }
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  break;
 
 	case F_ToggleCheckPlanes:
@@ -2864,7 +2863,7 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 	    oldGrid = PCB->Grid;
 	    PCB->Grid = 1.0;
 	    if (MoveCrosshairAbsolute (Crosshair.X, Crosshair.Y))
-	      RestoreCrosshair ();	/* was hidden by MoveCrosshairAbs */
+	      notify_crosshair_change (true);	/* first notify was in MoveCrosshairAbs */
 	    SetGrid (oldGrid, true);
 	  }
 	  break;
@@ -3068,7 +3067,7 @@ ActionMode (int argc, char **argv, int x, int y)
     {
       Note.X = Crosshair.X;
       Note.Y = Crosshair.Y;
-      HideCrosshair ();
+      notify_crosshair_change (false);
       switch (GetFunctionID (function))
 	{
 	case F_Arc:
@@ -3264,7 +3263,7 @@ ActionMode (int argc, char **argv, int x, int y)
 	  SaveMode ();
 	  break;
 	}
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
       return 0;
     }
 
@@ -4039,24 +4038,27 @@ ActionMarkCrosshair (int argc, char **argv, int x, int y)
     {
       if (Marked.status)
 	{
-	  DrawMark ();
+	  notify_mark_change (false);
 	  Marked.status = false;
+	  notify_mark_change (true);
 	}
       else
 	{
+	  notify_mark_change (false);
+	  Marked.status = false;
 	  Marked.status = true;
 	  Marked.X = Crosshair.X;
 	  Marked.Y = Crosshair.Y;
-	  DrawMark ();
+	  notify_mark_change (true);
 	}
     }
   else if (GetFunctionID (function) == F_Center)
     {
-      DrawMark ();
+      notify_mark_change (false);
       Marked.status = true;
       Marked.X = Crosshair.X;
       Marked.Y = Crosshair.Y;
-      DrawMark ();
+      notify_mark_change (true);
     }
   return 0;
 }
@@ -5450,7 +5452,7 @@ ActionSelect (int argc, char **argv, int x, int y)
 			  Crosshair.AttachedBox.Point2.X);
 	    box.Y2 = MAX (Crosshair.AttachedBox.Point1.Y,
 			  Crosshair.AttachedBox.Point2.Y);
-	    HideCrosshair ();
+	    notify_crosshair_change (false);
 	    NotifyBlock ();
 	    if (Crosshair.AttachedBox.State == STATE_THIRD &&
 		SelectBlock (&box, true))
@@ -5458,7 +5460,7 @@ ActionSelect (int argc, char **argv, int x, int y)
 		SetChangedFlag (true);
 		Crosshair.AttachedBox.State = STATE_FIRST;
 	      }
-	    RestoreCrosshair ();
+	    notify_crosshair_change (true);
 	    break;
 	  }
 
@@ -5629,7 +5631,7 @@ ActionUnselect (int argc, char **argv, int x, int y)
 			  Crosshair.AttachedBox.Point2.X);
 	    box.Y2 = MAX (Crosshair.AttachedBox.Point1.Y,
 			  Crosshair.AttachedBox.Point2.Y);
-	    HideCrosshair ();
+	    notify_crosshair_change (false);
 	    NotifyBlock ();
 	    if (Crosshair.AttachedBox.State == STATE_THIRD &&
 		SelectBlock (&box, false))
@@ -5637,7 +5639,7 @@ ActionUnselect (int argc, char **argv, int x, int y)
 		SetChangedFlag (true);
 		Crosshair.AttachedBox.State = STATE_FIRST;
 	      }
-	    RestoreCrosshair ();
+	    notify_crosshair_change (true);
 	    break;
 	  }
 
@@ -5868,18 +5870,18 @@ ActionLoadFrom (int argc, char **argv, int x, int y)
 
   if (strcasecmp (function, "ElementToBuffer") == 0)
     {
-      HideCrosshair ();
+      notify_crosshair_change (false);
       if (LoadElementToBuffer (PASTEBUFFER, name, true))
 	SetMode (PASTEBUFFER_MODE);
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
     }
 
   else if (strcasecmp (function, "LayoutToBuffer") == 0)
     {
-      HideCrosshair ();
+      notify_crosshair_change (false);
       if (LoadLayoutToBuffer (PASTEBUFFER, name))
 	SetMode (PASTEBUFFER_MODE);
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
     }
 
   else if (strcasecmp (function, "Layout") == 0)
@@ -5936,7 +5938,7 @@ ActionNew (int argc, char **argv, int x, int y)
       if (!name)
         return 1;
 
-      HideCrosshair ();
+      notify_crosshair_change (false);
       /* do emergency saving
        * clear the old struct and allocate memory for the new one
        */
@@ -5958,7 +5960,7 @@ ActionNew (int argc, char **argv, int x, int y)
       ClearAndRedrawOutput ();
 
       hid_action ("PCBChanged");
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
       return 0;
     }
   return 1;
@@ -6045,7 +6047,7 @@ ActionPasteBuffer (int argc, char **argv, int x, int y)
   static char *default_file = NULL;
   int free_name = 0;
 
-  HideCrosshair ();
+  notify_crosshair_change (true);
   if (function)
     {
       switch (GetFunctionID (function))
@@ -6152,7 +6154,7 @@ ActionPasteBuffer (int argc, char **argv, int x, int y)
 	      }
 	    else
 	      {
-		RestoreCrosshair ();
+		notify_crosshair_change (false);
 		AFAIL (pastebuffer);
 	      }
 
@@ -6175,7 +6177,7 @@ ActionPasteBuffer (int argc, char **argv, int x, int y)
 	}
     }
 
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   return 0;
 }
 
@@ -6216,13 +6218,13 @@ ActionUndo (int argc, char **argv, int x, int y)
 	return 1;
       /* undo the last operation */
 
-      HideCrosshair ();
+      notify_crosshair_change (false);
       if ((Settings.Mode == POLYGON_MODE ||
            Settings.Mode == POLYGONHOLE_MODE) &&
           Crosshair.AttachedPolygon.PointN)
 	{
 	  GoToPreviousPoint ();
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  return 0;
 	}
       /* move anchor point if undoing during line creation */
@@ -6234,7 +6236,7 @@ ActionUndo (int argc, char **argv, int x, int y)
 		Undo (true);	/* undo the connection find */
 	      Crosshair.AttachedLine.State = STATE_FIRST;
 	      SetLocalRef (0, 0, false);
-	      RestoreCrosshair ();
+	      notify_crosshair_change (true);
 	      return 0;
 	    }
 	  if (Crosshair.AttachedLine.State == STATE_THIRD)
@@ -6262,7 +6264,7 @@ ActionUndo (int argc, char **argv, int x, int y)
 		    Crosshair.AttachedLine.Point1.X;
 		  Crosshair.AttachedLine.Point2.Y =
 		    Crosshair.AttachedLine.Point1.Y;
-		  RestoreCrosshair ();
+		  notify_crosshair_change (true);
 		  return 0;
 		}
 	      /* move to new anchor */
@@ -6309,7 +6311,7 @@ ActionUndo (int argc, char **argv, int x, int y)
 		  ptr2 = (LineTypePtr) ptrtmp;
 		  lastLayer = (LayerTypePtr) ptr1;
 		}
-	      RestoreCrosshair ();
+	      notify_crosshair_change (true);
 	      return 0;
 	    }
 	}
@@ -6318,7 +6320,7 @@ ActionUndo (int argc, char **argv, int x, int y)
 	  if (Crosshair.AttachedBox.State == STATE_SECOND)
 	    {
 	      Crosshair.AttachedBox.State = STATE_FIRST;
-	      RestoreCrosshair ();
+	      notify_crosshair_change (true);
 	      return 0;
 	    }
 	  if (Crosshair.AttachedBox.State == STATE_THIRD)
@@ -6353,7 +6355,7 @@ ActionUndo (int argc, char **argv, int x, int y)
 	  break;
 	}
     }
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   return 0;
 }
 
@@ -6386,7 +6388,7 @@ ActionRedo (int argc, char **argv, int x, int y)
        Crosshair.AttachedPolygon.PointN) ||
       Crosshair.AttachedLine.State == STATE_SECOND)
     return 1;
-  HideCrosshair ();
+  notify_crosshair_change (false);
   if (Redo (true))
     {
       SetChangedFlag (true);
@@ -6401,7 +6403,7 @@ ActionRedo (int argc, char **argv, int x, int y)
 	  addedLines++;
 	}
     }
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   return 0;
 }
 
@@ -6435,7 +6437,7 @@ ActionPolygon (int argc, char **argv, int x, int y)
   char *function = ARG (0);
   if (function && Settings.Mode == POLYGON_MODE)
     {
-      HideCrosshair ();
+      notify_crosshair_change (false);
       switch (GetFunctionID (function))
 	{
 	  /* close open polygon if possible */
@@ -6448,7 +6450,7 @@ ActionPolygon (int argc, char **argv, int x, int y)
 	  GoToPreviousPoint ();
 	  break;
 	}
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
     }
   return 0;
 }
@@ -6612,24 +6614,24 @@ ActionSetSame (int argc, char **argv, int x, int y)
   switch (type)
     {
     case LINE_TYPE:
-      HideCrosshair ();
+      notify_crosshair_change (false);
       Settings.LineThickness = ((LineTypePtr) ptr2)->Thickness;
       Settings.Keepaway = ((LineTypePtr) ptr2)->Clearance / 2;
       layer = (LayerTypePtr) ptr1;
       if (Settings.Mode != LINE_MODE)
 	SetMode (LINE_MODE);
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
       hid_action ("RouteStylesChanged");
       break;
 
     case ARC_TYPE:
-      HideCrosshair ();
+      notify_crosshair_change (false);
       Settings.LineThickness = ((ArcTypePtr) ptr2)->Thickness;
       Settings.Keepaway = ((ArcTypePtr) ptr2)->Clearance / 2;
       layer = (LayerTypePtr) ptr1;
       if (Settings.Mode != ARC_MODE)
 	SetMode (ARC_MODE);
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
       hid_action ("RouteStylesChanged");
       break;
 
@@ -6638,13 +6640,13 @@ ActionSetSame (int argc, char **argv, int x, int y)
       break;
 
     case VIA_TYPE:
-      HideCrosshair ();
+      notify_crosshair_change (false);
       Settings.ViaThickness = ((PinTypePtr) ptr2)->Thickness;
       Settings.ViaDrillingHole = ((PinTypePtr) ptr2)->DrillingHole;
       Settings.Keepaway = ((PinTypePtr) ptr2)->Clearance / 2;
       if (Settings.Mode != VIA_MODE)
 	SetMode (VIA_MODE);
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
       hid_action ("RouteStylesChanged");
       break;
 
diff --git a/src/buffer.c b/src/buffer.c
index 43d5c2b..75ab94a 100644
--- a/src/buffer.c
+++ b/src/buffer.c
@@ -521,12 +521,9 @@ void
 AddSelectedToBuffer (BufferTypePtr Buffer, LocationType X, LocationType Y,
 		     bool LeaveSelected)
 {
-  /* switch crosshair off because adding objects to the pastebuffer
-   * may change the 'valid' area for the cursor
-   */
   if (!LeaveSelected)
     ExtraFlag = SELECTEDFLAG;
-  HideCrosshair ();
+  notify_crosshair_change (false);
   Source = PCB->Data;
   Dest = Buffer->Data;
   SelectedOperation (&AddBufferFunctions, false, ALL_TYPES);
@@ -542,7 +539,7 @@ AddSelectedToBuffer (BufferTypePtr Buffer, LocationType X, LocationType Y,
       Buffer->X = Crosshair.X;
       Buffer->Y = Crosshair.Y;
     }
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   ExtraFlag = 0;
 }
 
@@ -1457,9 +1454,9 @@ ActionFreeRotateBuffer(int argc, char **argv, int x, int y)
   else
     angle_s = argv[0];
 
-  HideCrosshair ();
+  notify_crosshair_change (false);
   FreeRotateBuffer(PASTEBUFFER, strtod(angle_s, 0));
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   return 0;
 }
 
diff --git a/src/crosshair.c b/src/crosshair.c
index 7df5299..fb46c66 100644
--- a/src/crosshair.c
+++ b/src/crosshair.c
@@ -66,15 +66,6 @@ typedef struct
 } point;
 
 /* ---------------------------------------------------------------------------
- * some local identifiers
- */
-
-/* This is a stack for HideCrosshair() and RestoreCrosshair() calls. They
- * must always be matched. */
-static bool CrosshairStack[MAX_CROSSHAIRSTACK_DEPTH];
-static int CrosshairStackLocation = 0;
-
-/* ---------------------------------------------------------------------------
  * some local prototypes
  */
 static void XORPolygon (PolygonTypePtr, LocationType, LocationType);
@@ -565,10 +556,14 @@ XORDrawMoveOrCopyObject (void)
 /* ---------------------------------------------------------------------------
  * draws additional stuff that follows the crosshair
  */
-static void
+void
 DrawAttached (void)
 {
   BDimension s;
+
+  if (!Crosshair.On)
+    return;
+
   switch (Settings.Mode)
     {
     case VIA_MODE:
@@ -684,72 +679,82 @@ DrawAttached (void)
     }
 }
 
-/* ---------------------------------------------------------------------------
- * switches crosshair on
+
+/* --------------------------------------------------------------------------
+ * draw the marker position
  */
 void
-CrosshairOn (void)
+DrawMark (void)
 {
-  if (!Crosshair.On)
-    {
-      Crosshair.On = true;
-      DrawAttached ();
-      DrawMark ();
-    }
+  /* Mark is not drawn when the crosshair is off, or when it is not set */
+  if (!Crosshair.On || !Marked.status)
+    return;
+
+  gui->draw_line (Crosshair.GC,
+                  Marked.X - MARK_SIZE,
+                  Marked.Y - MARK_SIZE,
+                  Marked.X + MARK_SIZE, Marked.Y + MARK_SIZE);
+  gui->draw_line (Crosshair.GC,
+                  Marked.X + MARK_SIZE,
+                  Marked.Y - MARK_SIZE,
+                  Marked.X - MARK_SIZE, Marked.Y + MARK_SIZE);
 }
 
-/* ---------------------------------------------------------------------------
- * switches crosshair off
- */
+
 void
-CrosshairOff (void)
+notify_crosshair_change (bool changes_complete)
 {
-  if (Crosshair.On)
-    {
-      Crosshair.On = false;
-      DrawAttached ();
-      DrawMark ();
-    }
+  if (gui->notify_crosshair_change)
+    gui->notify_crosshair_change (changes_complete);
 }
 
+
+void
+notify_mark_change (bool changes_complete)
+{
+  if (gui->notify_mark_change)
+    gui->notify_mark_change (changes_complete);
+}
+
+
 /* ---------------------------------------------------------------------------
- * saves crosshair state (on/off) and hides him
+ * switches crosshair on
  */
 void
-HideCrosshair ()
+CrosshairOn (void)
 {
-  /* fprintf(stderr, "HideCrosshair stack %d\n", CrosshairStackLocation); */
-  if (CrosshairStackLocation >= MAX_CROSSHAIRSTACK_DEPTH)
-    {
-      fprintf(stderr, "Error: CrosshairStackLocation overflow\n");
-      return;
-    }
+  if (Crosshair.On)
+    return;
+
+  notify_crosshair_change (false);
+  if (Marked.status)
+    notify_mark_change (false);
 
-  CrosshairStack[CrosshairStackLocation] = Crosshair.On;
-  CrosshairStackLocation++;
+  Crosshair.On = true;
 
-  CrosshairOff ();
+  notify_crosshair_change (true);
+  if (Marked.status)
+    notify_mark_change (true);
 }
 
 /* ---------------------------------------------------------------------------
- * restores last crosshair state
+ * switches crosshair off
  */
 void
-RestoreCrosshair (void)
+CrosshairOff (void)
 {
-  /* fprintf(stderr, "RestoreCrosshair stack %d\n", CrosshairStackLocation); */
-  if (CrosshairStackLocation <= 0)
-    {
-      fprintf(stderr, "Error: CrosshairStackLocation underflow\n");
-      return;
-    }
+  if (!Crosshair.On)
+    return;
 
-  CrosshairStackLocation--;
+  notify_crosshair_change (false);
+  if (Marked.status)
+    notify_mark_change (false);
 
-  if (CrosshairStack[CrosshairStackLocation])
-    CrosshairOn ();
-  else
-    CrosshairOff ();
+  Crosshair.On = false;
+
+  notify_crosshair_change (true);
+  if (Marked.status)
+    notify_mark_change (true);
 }
 
 static double
@@ -1043,8 +1048,8 @@ MoveCrosshairRelative (LocationType DeltaX, LocationType DeltaY)
 }
 
 /* ---------------------------------------------------------------------------
- * move crosshair absolute switched off if it moved
- * return true if it switched off
+ * move crosshair absolute
+ * return true if the crosshair was moved from its existing position
  */
 bool
 MoveCrosshairAbsolute (LocationType X, LocationType Y)
@@ -1055,13 +1060,14 @@ MoveCrosshairAbsolute (LocationType X, LocationType Y)
   FitCrosshairIntoGrid (X, Y);
   if (Crosshair.X != x || Crosshair.Y != y)
     {
-      /* back up to old position and erase crosshair */
+      /* back up to old position to notify the GUI
+       * (which might want to erase the old crosshair) */
       z = Crosshair.X;
       Crosshair.X = x;
       x = z;
       z = Crosshair.Y;
       Crosshair.Y = y;
-      HideCrosshair ();
+      notify_crosshair_change (false); /* Our caller notifies when it has done */
       /* now move forward again */
       Crosshair.X = x;
       Crosshair.Y = z;
@@ -1086,30 +1092,9 @@ SetCrosshairRange (LocationType MinX, LocationType MinY, LocationType MaxX,
   MoveCrosshairRelative (0, 0);
 }
 
-/* --------------------------------------------------------------------------
- * draw the marker position
- * if argument is true, draw only if it is visible, otherwise draw it regardless
- */
-void
-DrawMark (void)
-{
-  if (Marked.status)
-    {
-      gui->draw_line (Crosshair.GC,
-		      Marked.X - MARK_SIZE,
-		      Marked.Y - MARK_SIZE,
-		      Marked.X + MARK_SIZE, Marked.Y + MARK_SIZE);
-      gui->draw_line (Crosshair.GC,
-		      Marked.X + MARK_SIZE,
-		      Marked.Y - MARK_SIZE,
-		      Marked.X - MARK_SIZE, Marked.Y + MARK_SIZE);
-    }
-}
-
 /* ---------------------------------------------------------------------------
  * initializes crosshair stuff
- * clears the struct, allocates to graphical contexts and
- * initializes the stack
+ * clears the struct, allocates to graphical contexts
  */
 void
 InitCrosshair (void)
@@ -1121,9 +1106,6 @@ InitCrosshair (void)
   gui->set_line_cap (Crosshair.GC, Trace_Cap);
   gui->set_line_width (Crosshair.GC, 1);
 
-  /* fake a crosshair off entry on stack */
-  CrosshairStackLocation = 0;
-  CrosshairStack[CrosshairStackLocation++] = true;
   Crosshair.On = false;
 
   /* set initial shape */
diff --git a/src/crosshair.h b/src/crosshair.h
index 4573e98..44b2c81 100644
--- a/src/crosshair.h
+++ b/src/crosshair.h
@@ -46,18 +46,18 @@
 #define	STATE_SECOND	1
 #define	STATE_THIRD		2
 
-
 void CrosshairOn (void);
 void CrosshairOff (void);
-void HideCrosshair (void);
-void RestoreCrosshair (void);
+void DrawAttached (void);
+void DrawMark (void);
+void notify_crosshair_change (bool changes_complete);
+void notify_mark_change (bool changes_complete);
 void MoveCrosshairRelative (LocationType, LocationType);
 bool MoveCrosshairAbsolute (LocationType, LocationType);
 void SetCrosshairRange (LocationType, LocationType, LocationType,
 			LocationType);
 void InitCrosshair (void);
 void DestroyCrosshair (void);
-void DrawMark (void);
 void FitCrosshairIntoGrid (LocationType, LocationType);
 
 #endif
diff --git a/src/draw.c b/src/draw.c
index bc00a7e..3586db7 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -186,14 +186,10 @@ UpdateAll (void)
 void
 Draw (void)
 {
-  HideCrosshair ();
-
   /* clear and create event if not drawing to a pixmap
    */
   gui->invalidate_lr (Block.X1, Block.X2, Block.Y1, Block.Y2);
 
-  RestoreCrosshair ();
-
   /* shrink the update block */
   Block.X1 = Block.Y1 = Block.X2 = Block.Y2 = 0;
 }
diff --git a/src/hid.h b/src/hid.h
index b13e75b..7779f84 100644
--- a/src/hid.h
+++ b/src/hid.h
@@ -298,6 +298,8 @@ typedef enum
     /* This may be called to ask the GUI to force a redraw of a given area */
     void (*invalidate_lr) (int left_, int right_, int top_, int bottom_);
     void (*invalidate_all) (void);
+    void (*notify_crosshair_change) (bool changes_complete);
+    void (*notify_mark_change) (bool changes_complete);
 
     /* During redraw or print/export cycles, this is called once per
        layer (or layer group, for copper layers).  If it returns false
diff --git a/src/hid/common/hidnogui.c b/src/hid/common/hidnogui.c
index fd86b6a..cd1c0d2 100644
--- a/src/hid/common/hidnogui.c
+++ b/src/hid/common/hidnogui.c
@@ -420,6 +420,8 @@ HID hid_nogui = {
   nogui_parse_arguments,
   nogui_invalidate_lr,
   nogui_invalidate_all,
+  0 /* nogui_notify_crosshair_change */ ,
+  0 /* nogui_notify_mark_change */ ,
   nogui_set_layer,
   nogui_make_gc,
   nogui_destroy_gc,
@@ -477,6 +479,8 @@ apply_default_hid (HID * d, HID * s)
   AD (parse_arguments);
   AD (invalidate_lr);
   AD (invalidate_all);
+  AD (notify_crosshair_change);
+  AD (notify_mark_change);
   AD (set_layer);
   AD (make_gc);
   AD (destroy_gc);
diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index ba58d5d..3d90c27 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -34,6 +34,8 @@ typedef struct render_priv {
   GdkGC *mask_gc;
   GdkGC *u_gc;
   GdkGC *grid_gc;
+  int attached_invalidate_depth;
+  int mark_invalidate_depth;
 } render_priv;
 
 
@@ -709,6 +711,7 @@ ghid_invalidate_lr (int left, int right, int top, int bottom)
   ghid_invalidate_all ();
 }
 
+
 void
 ghid_invalidate_all ()
 {
@@ -770,12 +773,70 @@ ghid_invalidate_all ()
 
   hid_expose_callback (&ghid_hid, &region, 0);
   ghid_draw_grid ();
-  if (ghidgui->need_restore_crosshair)
-    RestoreCrosshair ();
-  ghidgui->need_restore_crosshair = FALSE;
+
+  if (priv->attachment_invalidate_depth == 0)
+    DrawAttached ();
+  if (priv->mark_invalidate_depth == 0)
+    DrawMark ();
+
   ghid_screen_update ();
 }
 
+
+void
+ghid_notify_crosshair_change (bool changes_complete)
+{
+  render_priv *priv = gport->render_priv;
+
+  /* We sometimes get called before the GUI is up */
+  if (priv->drawing_area == NULL)
+    return;
+
+  if (changes_complete)
+    priv->attached_invalidate_depth --;
+
+  if (priv->attached_invalidate_depth < 0)
+    {
+      fprintf (stderr, "ERROR: Unmatched notify_crosshair_change calls\n");
+      priv->attached_invalidate_depth = 0;
+    }
+
+  if (priv->attached_invalidate_depth == 0)
+    DrawAttached ();
+
+  if (!changes_complete)
+    priv->attached_invalidate_depth ++;
+  else if (priv->drawing_area != NULL)
+    ghid_draw_area_update (priv, NULL);
+}
+
+void
+ghid_notify_mark_change (bool changes_complete)
+{
+  render_priv *priv = gport->render_priv;
+
+  /* We sometimes get called before the GUI is up */
+  if (priv->drawing_area == NULL)
+    return;
+
+  if (changes_complete)
+    priv->mark_invalidate_depth --;
+
+  if (priv->mark_invalidate_depth < 0)
+    {
+      fprintf (stderr, "ERROR: Unmatched notify_mark_change calls\n");
+      priv->mark_invalidate_depth = 0;
+    }
+
+  if (priv->mark_invalidate_depth == 0)
+    DrawMark ();
+
+  if (!changes_complete)
+    priv->mark_invalidate_depth ++;
+  else
+    ghid_draw_area_update (priv, NULL);
+}
+
 static void
 draw_right_cross (GdkGC *xor_gc, gint x, gint y)
 {
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 84cca05..25448de 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -1838,11 +1838,11 @@ ScrollAction (int argc, char **argv, int x, int y)
   else
     AFAIL (scroll);
 
-  HideCrosshair ();
   ghid_port_ranges_pan (dx, dy, TRUE);
+  notify_crosshair_change (false);
   MoveCrosshairRelative (dx, dy);
   AdjustAttachedObjects ();
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
 
   return 0;
 }
@@ -2100,62 +2100,64 @@ hid_gtk_init ()
 
   memset (&ghid_hid, 0, sizeof (HID));
 
-  ghid_hid.struct_size          = sizeof (HID);
-  ghid_hid.name                 = "gtk";
-  ghid_hid.description          = "Gtk - The Gimp Toolkit";
-  ghid_hid.gui                  = 1;
-  ghid_hid.poly_after           = 1;
-
-  ghid_hid.get_export_options   = ghid_get_export_options;
-  ghid_hid.do_export            = ghid_do_export;
-  ghid_hid.parse_arguments      = ghid_parse_arguments;
-  ghid_hid.invalidate_lr        = ghid_invalidate_lr;
-  ghid_hid.invalidate_all       = ghid_invalidate_all;
-  ghid_hid.set_layer            = ghid_set_layer;
-  ghid_hid.make_gc              = ghid_make_gc;
-  ghid_hid.destroy_gc           = ghid_destroy_gc;
-  ghid_hid.use_mask             = ghid_use_mask;
-  ghid_hid.set_color            = ghid_set_color;
-  ghid_hid.set_line_cap         = ghid_set_line_cap;
-  ghid_hid.set_line_width       = ghid_set_line_width;
-  ghid_hid.set_draw_xor         = ghid_set_draw_xor;
-  ghid_hid.set_draw_faded       = ghid_set_draw_faded;
-  ghid_hid.set_line_cap_angle   = ghid_set_line_cap_angle;
-  ghid_hid.draw_line            = ghid_draw_line;
-  ghid_hid.draw_arc             = ghid_draw_arc;
-  ghid_hid.draw_rect            = ghid_draw_rect;
-  ghid_hid.fill_circle          = ghid_fill_circle;
-  ghid_hid.fill_polygon         = ghid_fill_polygon;
-  ghid_hid.fill_pcb_polygon     = common_fill_pcb_polygon;
-  ghid_hid.thindraw_pcb_polygon = common_thindraw_pcb_polygon;
-  ghid_hid.fill_rect            = ghid_fill_rect;
-
-  ghid_hid.calibrate            = ghid_calibrate;
-  ghid_hid.shift_is_pressed     = ghid_shift_is_pressed;
-  ghid_hid.control_is_pressed   = ghid_control_is_pressed;
-  ghid_hid.mod1_is_pressed      = ghid_mod1_is_pressed,
-  ghid_hid.get_coords           = ghid_get_coords;
-  ghid_hid.set_crosshair        = ghid_set_crosshair;
-  ghid_hid.add_timer            = ghid_add_timer;
-  ghid_hid.stop_timer           = ghid_stop_timer;
-  ghid_hid.watch_file           = ghid_watch_file;
-  ghid_hid.unwatch_file         = ghid_unwatch_file;
-  ghid_hid.add_block_hook       = ghid_add_block_hook;
-  ghid_hid.stop_block_hook      = ghid_stop_block_hook;
-
-  ghid_hid.log                  = ghid_log;
-  ghid_hid.logv                 = ghid_logv;
-  ghid_hid.confirm_dialog       = ghid_confirm_dialog;
-  ghid_hid.close_confirm_dialog = ghid_close_confirm_dialog;
-  ghid_hid.report_dialog        = ghid_report_dialog;
-  ghid_hid.prompt_for           = ghid_prompt_for;
-  ghid_hid.fileselect           = ghid_fileselect;
-  ghid_hid.attribute_dialog     = ghid_attribute_dialog;
-  ghid_hid.show_item            = ghid_show_item;
-  ghid_hid.beep                 = ghid_beep;
-  ghid_hid.progress             = ghid_progress;
-  ghid_hid.drc_gui              = &ghid_drc_gui,
-  ghid_hid.edit_attributes      = ghid_attributes;
+  ghid_hid.struct_size              = sizeof (HID);
+  ghid_hid.name                     = "gtk";
+  ghid_hid.description              = "Gtk - The Gimp Toolkit";
+  ghid_hid.gui                      = 1;
+  ghid_hid.poly_after               = 1;
+
+  ghid_hid.get_export_options       = ghid_get_export_options;
+  ghid_hid.do_export                = ghid_do_export;
+  ghid_hid.parse_arguments          = ghid_parse_arguments;
+  ghid_hid.invalidate_lr            = ghid_invalidate_lr;
+  ghid_hid.invalidate_all           = ghid_invalidate_all;
+  ghid_hid.notify_crosshair_change  = ghid_notify_crosshair_change;
+  ghid_hid.notify_mark_change       = ghid_notify_mark_change;
+  ghid_hid.set_layer                = ghid_set_layer;
+  ghid_hid.make_gc                  = ghid_make_gc;
+  ghid_hid.destroy_gc               = ghid_destroy_gc;
+  ghid_hid.use_mask                 = ghid_use_mask;
+  ghid_hid.set_color                = ghid_set_color;
+  ghid_hid.set_line_cap             = ghid_set_line_cap;
+  ghid_hid.set_line_width           = ghid_set_line_width;
+  ghid_hid.set_draw_xor             = ghid_set_draw_xor;
+  ghid_hid.set_draw_faded           = ghid_set_draw_faded;
+  ghid_hid.set_line_cap_angle       = ghid_set_line_cap_angle;
+  ghid_hid.draw_line                = ghid_draw_line;
+  ghid_hid.draw_arc                 = ghid_draw_arc;
+  ghid_hid.draw_rect                = ghid_draw_rect;
+  ghid_hid.fill_circle              = ghid_fill_circle;
+  ghid_hid.fill_polygon             = ghid_fill_polygon;
+  ghid_hid.fill_pcb_polygon         = common_fill_pcb_polygon;
+  ghid_hid.thindraw_pcb_polygon     = common_thindraw_pcb_polygon;
+  ghid_hid.fill_rect                = ghid_fill_rect;
+
+  ghid_hid.calibrate                = ghid_calibrate;
+  ghid_hid.shift_is_pressed         = ghid_shift_is_pressed;
+  ghid_hid.control_is_pressed       = ghid_control_is_pressed;
+  ghid_hid.mod1_is_pressed          = ghid_mod1_is_pressed,
+  ghid_hid.get_coords               = ghid_get_coords;
+  ghid_hid.set_crosshair            = ghid_set_crosshair;
+  ghid_hid.add_timer                = ghid_add_timer;
+  ghid_hid.stop_timer               = ghid_stop_timer;
+  ghid_hid.watch_file               = ghid_watch_file;
+  ghid_hid.unwatch_file             = ghid_unwatch_file;
+  ghid_hid.add_block_hook           = ghid_add_block_hook;
+  ghid_hid.stop_block_hook          = ghid_stop_block_hook;
+
+  ghid_hid.log                      = ghid_log;
+  ghid_hid.logv                     = ghid_logv;
+  ghid_hid.confirm_dialog           = ghid_confirm_dialog;
+  ghid_hid.close_confirm_dialog     = ghid_close_confirm_dialog;
+  ghid_hid.report_dialog            = ghid_report_dialog;
+  ghid_hid.prompt_for               = ghid_prompt_for;
+  ghid_hid.fileselect               = ghid_fileselect;
+  ghid_hid.attribute_dialog         = ghid_attribute_dialog;
+  ghid_hid.show_item                = ghid_show_item;
+  ghid_hid.beep                     = ghid_beep;
+  ghid_hid.progress                 = ghid_progress;
+  ghid_hid.drc_gui                  = &ghid_drc_gui,
+  ghid_hid.edit_attributes          = ghid_attributes;
 
   hid_register_hid (&ghid_hid);
 #include "gtk_lists.h"
diff --git a/src/hid/gtk/gui-misc.c b/src/hid/gtk/gui-misc.c
index 8bda96d..75ba763 100644
--- a/src/hid/gtk/gui-misc.c
+++ b/src/hid/gtk/gui-misc.c
@@ -403,12 +403,12 @@ run_get_location_loop (const gchar * message)
   oldObjState = Crosshair.AttachedObject.State;
   oldLineState = Crosshair.AttachedLine.State;
   oldBoxState = Crosshair.AttachedBox.State;
-  HideCrosshair ();
+  notify_crosshair_change (false);
   Crosshair.AttachedObject.State = STATE_FIRST;
   Crosshair.AttachedLine.State = STATE_FIRST;
   Crosshair.AttachedBox.State = STATE_FIRST;
   ghid_hand_cursor ();
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
 
   /* Stop the top level GMainLoop from getting user input from keyboard
      |  and mouse so we can install our own handlers here.  Also set the
@@ -439,11 +439,11 @@ run_get_location_loop (const gchar * message)
   ghid_interface_input_signals_connect ();	/* return to normal */
   ghid_interface_set_sensitive (TRUE);
 
-  HideCrosshair ();
+  notify_crosshair_change (false);
   Crosshair.AttachedObject.State = oldObjState;
   Crosshair.AttachedLine.State = oldLineState;
   Crosshair.AttachedBox.State = oldBoxState;
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   ghid_restore_cursor ();
 
   ghid_set_status_line_label ();
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index 331f214..ea77412 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -58,9 +58,6 @@ ghid_port_ranges_changed (void)
 {
   GtkAdjustment *h_adj, *v_adj;
 
-  HideCrosshair ();
-  ghidgui->need_restore_crosshair = TRUE;
-
   h_adj = gtk_range_get_adjustment (GTK_RANGE (ghidgui->h_range));
   v_adj = gtk_range_get_adjustment (GTK_RANGE (ghidgui->v_range));
   gport->view_x0 = h_adj->value;
@@ -235,7 +232,7 @@ ghid_note_event_location (GdkEventButton * ev)
   if (moved)
     {
       AdjustAttachedObjects ();
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
     }
   ghid_set_cursor_position_labels ();
   return moved;
@@ -305,11 +302,10 @@ ghid_port_key_release_cb (GtkWidget * drawing_area, GdkEventKey * kev,
   if (ghid_is_modifier_key_sym (ksym))
     ghid_note_event_location (NULL);
 
-  HideCrosshair ();
+  notify_crosshair_change (false);
   AdjustAttachedObjects ();
+  notify_crosshair_change (true);
   ghid_invalidate_all ();
-  RestoreCrosshair ();
-  ghid_screen_update ();
   g_idle_add (ghid_idle_cb, NULL);
   return FALSE;
 }
@@ -447,12 +443,10 @@ ghid_port_button_press_cb (GtkWidget * drawing_area,
   state = (GdkModifierType) (ev->state);
   mk = ghid_modifier_keys_state (&state);
   ghid_show_crosshair (FALSE);
-  HideCrosshair ();
 
   do_mouse_action(ev->button, mk);
 
   ghid_invalidate_all ();
-  RestoreCrosshair ();
   ghid_window_set_name_label (PCB->Name);
   ghid_set_status_line_label ();
   ghid_show_crosshair (TRUE);
@@ -473,14 +467,12 @@ ghid_port_button_release_cb (GtkWidget * drawing_area,
   state = (GdkModifierType) (ev->state);
   mk = ghid_modifier_keys_state (&state);
 
-  HideCrosshair ();
-
   do_mouse_action(ev->button, mk + M_Release);
 
+  notify_crosshair_change (false);
   AdjustAttachedObjects ();
+  notify_crosshair_change (true);
   ghid_invalidate_all ();
-  RestoreCrosshair ();
-  ghid_screen_update ();
 
   ghid_window_set_name_label (PCB->Name);
   ghid_set_status_line_label ();
@@ -496,7 +488,6 @@ ghid_port_drawing_area_configure_event_cb (GtkWidget * widget,
 {
   static gboolean first_time_done;
 
-  HideCrosshair ();
   gport->width = ev->width;
   gport->height = ev->height;
 
@@ -530,7 +521,6 @@ ghid_port_drawing_area_configure_event_cb (GtkWidget * widget,
 
   ghid_port_ranges_scale (FALSE);
   ghid_invalidate_all ();
-  RestoreCrosshair ();
   return 0;
 }
 
diff --git a/src/hid/gtk/gui-top-window.c b/src/hid/gtk/gui-top-window.c
index f33678a..e21ef18 100644
--- a/src/hid/gtk/gui-top-window.c
+++ b/src/hid/gtk/gui-top-window.c
@@ -650,11 +650,10 @@ ghid_menu_cb (GtkAction * action, gpointer data)
    */
   if (ghidgui->toggle_holdoff == FALSE) 
     {
-      HideCrosshair ();
+      notify_crosshair_change (false);
       AdjustAttachedObjects ();
+      notify_crosshair_change (true);
       ghid_invalidate_all ();
-      RestoreCrosshair ();
-      ghid_screen_update ();
       ghid_window_set_name_label (PCB->Name);
       ghid_set_status_line_label ();
 #ifdef FIXME
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index f419530..5a51358 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -132,7 +132,7 @@ typedef struct
     small_label_markup,
     compact_horizontal,
     compact_vertical,
-    ghid_title_window, use_command_window, need_restore_crosshair, creating;
+    ghid_title_window, use_command_window, creating;
 
   gint n_mode_button_columns,
     top_window_width,
@@ -494,6 +494,8 @@ void ghid_fill_polygon (hidGC gc, int n_coords, int *x, int *y);
 void ghid_fill_rect (hidGC gc, int x1, int y1, int x2, int y2);
 void ghid_invalidate_lr (int left, int right, int top, int bottom);
 void ghid_invalidate_all ();
+void ghid_notify_crosshair_change (bool changes_complete);
+void ghid_notify_mark_change (bool changes_complete);
 void ghid_show_crosshair (gboolean show);
 void ghid_init_renderer (int *, char ***, GHidPort *);
 void ghid_init_drawing_widget (GtkWidget *widget, GHidPort *);
diff --git a/src/hid/lesstif/main.c b/src/hid/lesstif/main.c
index c5f3e3e..18113f1 100644
--- a/src/hid/lesstif/main.c
+++ b/src/hid/lesstif/main.c
@@ -1310,12 +1310,12 @@ mod_changed (XKeyEvent * e, int set)
       return;
     }
   in_move_event = 1;
-  HideCrosshair ();
+  notify_crosshair_change (false);
   if (panning)
     Pan (2, e->x, e->y);
   EventMoveCrosshair (Px (e->x), Py (e->y));
   AdjustAttachedObjects ();
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   in_move_event = 0;
 }
 
@@ -1351,7 +1351,7 @@ work_area_input (Widget w, XtPointer v, XEvent * e, Boolean * ctd)
 	}
         ignore_release = 0;
 
-        HideCrosshair ();
+        notify_crosshair_change (false);
         pressed_button = e->xbutton.button;
         mods = ((e->xbutton.state & ShiftMask) ? M_Shift : 0)
           + ((e->xbutton.state & ControlMask) ? M_Ctrl : 0)
@@ -1361,7 +1361,7 @@ work_area_input (Widget w, XtPointer v, XEvent * e, Boolean * ctd)
           + ((e->xbutton.state & Mod1Mask) ? M_Alt : 0);
 #endif
         do_mouse_action(e->xbutton.button, mods);
-        RestoreCrosshair ();
+        notify_crosshair_change (true);
         break;
       }
 
@@ -1371,7 +1371,7 @@ work_area_input (Widget w, XtPointer v, XEvent * e, Boolean * ctd)
         if (e->xbutton.button != pressed_button)
           return;
         lesstif_button_event (w, e);
-        HideCrosshair ();
+        notify_crosshair_change (false);
         pressed_button = 0;
         mods = ((e->xbutton.state & ShiftMask) ? M_Shift : 0)
           + ((e->xbutton.state & ControlMask) ? M_Ctrl : 0)
@@ -1382,7 +1382,7 @@ work_area_input (Widget w, XtPointer v, XEvent * e, Boolean * ctd)
 #endif
           + M_Release;
         do_mouse_action (e->xbutton.button, mods);
-        RestoreCrosshair ();
+        notify_crosshair_change (true);
         break;
       }
 
@@ -2433,7 +2433,6 @@ idle_proc (XtPointer dummy)
       int mx, my;
       BoxType region;
       lesstif_use_mask (0);
-      Crosshair.On = 0;
       pixmap = main_pixmap;
       mx = view_width;
       my = view_height;
@@ -2519,7 +2518,8 @@ idle_proc (XtPointer dummy)
       XCopyArea (display, main_pixmap, window, my_gc, 0, 0, view_width,
 		 view_height, 0, 0);
       pixmap = window;
-      CrosshairOn ();
+      DrawAttached ();
+      DrawMark ();
       need_redraw = 0;
     }
 
@@ -2878,6 +2878,48 @@ lesstif_invalidate_all (void)
   lesstif_invalidate_lr (0, PCB->MaxWidth, 0, PCB->MaxHeight);
 }
 
+static void
+lesstif_notify_crosshair_change (bool changes_complete)
+{
+  static int invalidate_depth = 0;
+
+  if (changes_complete)
+    invalidate_depth --;
+
+  if (invalidate_depth < 0)
+    {
+      fprintf (stderr, "ERROR: Unmatched notify_crosshair_change calls\n");
+      invalidate_depth = 0;
+    }
+
+  if (invalidate_depth == 0)
+    DrawAttached ();
+
+  if (!changes_complete)
+    invalidate_depth ++;
+}
+
+static void
+lesstif_notify_mark_change (bool changes_complete)
+{
+  static int invalidate_depth = 0;
+
+  if (changes_complete)
+    invalidate_depth --;
+
+  if (invalidate_depth < 0)
+    {
+      fprintf (stderr, "ERROR: Unmatched notify_mark_change calls\n");
+      invalidate_depth = 0;
+    }
+
+  if (invalidate_depth == 0)
+    DrawMark ();
+
+  if (!changes_complete)
+    invalidate_depth ++;
+}
+
 static int
 lesstif_set_layer (const char *name, int group, int empty)
 {
@@ -3802,61 +3844,63 @@ hid_lesstif_init ()
 {
   memset (&lesstif_hid, 0, sizeof (HID));
 
-  lesstif_hid.struct_size           = sizeof (HID);
-  lesstif_hid.name                  = "lesstif";
-  lesstif_hid.description           = "LessTif - a Motif clone for X/Unix";
-  lesstif_hid.gui                   = 1;
-  lesstif_hid.poly_before           = 1;
-
-  lesstif_hid.get_export_options    = lesstif_get_export_options;
-  lesstif_hid.do_export             = lesstif_do_export;
-  lesstif_hid.parse_arguments       = lesstif_parse_arguments;
-  lesstif_hid.invalidate_lr         = lesstif_invalidate_lr;
-  lesstif_hid.invalidate_all        = lesstif_invalidate_all;
-  lesstif_hid.set_layer             = lesstif_set_layer;
-  lesstif_hid.make_gc               = lesstif_make_gc;
-  lesstif_hid.destroy_gc            = lesstif_destroy_gc;
-  lesstif_hid.use_mask              = lesstif_use_mask;
-  lesstif_hid.set_color             = lesstif_set_color;
-  lesstif_hid.set_line_cap          = lesstif_set_line_cap;
-  lesstif_hid.set_line_width        = lesstif_set_line_width;
-  lesstif_hid.set_draw_xor          = lesstif_set_draw_xor;
-  lesstif_hid.set_draw_faded        = lesstif_set_draw_faded;
-  lesstif_hid.set_line_cap_angle    = lesstif_set_line_cap_angle;
-  lesstif_hid.draw_line             = lesstif_draw_line;
-  lesstif_hid.draw_arc              = lesstif_draw_arc;
-  lesstif_hid.draw_rect             = lesstif_draw_rect;
-  lesstif_hid.fill_circle           = lesstif_fill_circle;
-  lesstif_hid.fill_polygon          = lesstif_fill_polygon;
-  lesstif_hid.fill_pcb_polygon      = common_fill_pcb_polygon;
-  lesstif_hid.thindraw_pcb_polygon  = common_thindraw_pcb_polygon;
-  lesstif_hid.fill_rect             = lesstif_fill_rect;
-
-  lesstif_hid.calibrate             = lesstif_calibrate;
-  lesstif_hid.shift_is_pressed      = lesstif_shift_is_pressed;
-  lesstif_hid.control_is_pressed    = lesstif_control_is_pressed;
-  lesstif_hid.mod1_is_pressed       = lesstif_mod1_is_pressed;
-  lesstif_hid.get_coords            = lesstif_get_coords;
-  lesstif_hid.set_crosshair         = lesstif_set_crosshair;
-  lesstif_hid.add_timer             = lesstif_add_timer;
-  lesstif_hid.stop_timer            = lesstif_stop_timer;
-  lesstif_hid.watch_file            = lesstif_watch_file;
-  lesstif_hid.unwatch_file          = lesstif_unwatch_file;
-  lesstif_hid.add_block_hook        = lesstif_add_block_hook;
-  lesstif_hid.stop_block_hook       = lesstif_stop_block_hook;
-
-  lesstif_hid.log                   = lesstif_log;
-  lesstif_hid.logv                  = lesstif_logv;
-  lesstif_hid.confirm_dialog        = lesstif_confirm_dialog;
-  lesstif_hid.close_confirm_dialog  = lesstif_close_confirm_dialog;
-  lesstif_hid.report_dialog         = lesstif_report_dialog;
-  lesstif_hid.prompt_for            = lesstif_prompt_for;
-  lesstif_hid.fileselect            = lesstif_fileselect;
-  lesstif_hid.attribute_dialog      = lesstif_attribute_dialog;
-  lesstif_hid.show_item             = lesstif_show_item;
-  lesstif_hid.beep                  = lesstif_beep;
-  lesstif_hid.progress              = lesstif_progress;
-  lesstif_hid.edit_attributes       = lesstif_attributes_dialog;
+  lesstif_hid.struct_size             = sizeof (HID);
+  lesstif_hid.name                    = "lesstif";
+  lesstif_hid.description             = "LessTif - a Motif clone for X/Unix";
+  lesstif_hid.gui                     = 1;
+  lesstif_hid.poly_before             = 1;
+
+  lesstif_hid.get_export_options      = lesstif_get_export_options;
+  lesstif_hid.do_export               = lesstif_do_export;
+  lesstif_hid.parse_arguments         = lesstif_parse_arguments;
+  lesstif_hid.invalidate_lr           = lesstif_invalidate_lr;
+  lesstif_hid.invalidate_all          = lesstif_invalidate_all;
+  lesstif_hid.notify_crosshair_change = lesstif_notify_crosshair_change;
+  lesstif_hid.notify_mark_change      = lesstif_notify_mark_change;
+  lesstif_hid.set_layer               = lesstif_set_layer;
+  lesstif_hid.make_gc                 = lesstif_make_gc;
+  lesstif_hid.destroy_gc              = lesstif_destroy_gc;
+  lesstif_hid.use_mask                = lesstif_use_mask;
+  lesstif_hid.set_color               = lesstif_set_color;
+  lesstif_hid.set_line_cap            = lesstif_set_line_cap;
+  lesstif_hid.set_line_width          = lesstif_set_line_width;
+  lesstif_hid.set_draw_xor            = lesstif_set_draw_xor;
+  lesstif_hid.set_draw_faded          = lesstif_set_draw_faded;
+  lesstif_hid.set_line_cap_angle      = lesstif_set_line_cap_angle;
+  lesstif_hid.draw_line               = lesstif_draw_line;
+  lesstif_hid.draw_arc                = lesstif_draw_arc;
+  lesstif_hid.draw_rect               = lesstif_draw_rect;
+  lesstif_hid.fill_circle             = lesstif_fill_circle;
+  lesstif_hid.fill_polygon            = lesstif_fill_polygon;
+  lesstif_hid.fill_pcb_polygon        = common_fill_pcb_polygon;
+  lesstif_hid.thindraw_pcb_polygon    = common_thindraw_pcb_polygon;
+  lesstif_hid.fill_rect               = lesstif_fill_rect;
+
+  lesstif_hid.calibrate               = lesstif_calibrate;
+  lesstif_hid.shift_is_pressed        = lesstif_shift_is_pressed;
+  lesstif_hid.control_is_pressed      = lesstif_control_is_pressed;
+  lesstif_hid.mod1_is_pressed         = lesstif_mod1_is_pressed;
+  lesstif_hid.get_coords              = lesstif_get_coords;
+  lesstif_hid.set_crosshair           = lesstif_set_crosshair;
+  lesstif_hid.add_timer               = lesstif_add_timer;
+  lesstif_hid.stop_timer              = lesstif_stop_timer;
+  lesstif_hid.watch_file              = lesstif_watch_file;
+  lesstif_hid.unwatch_file            = lesstif_unwatch_file;
+  lesstif_hid.add_block_hook          = lesstif_add_block_hook;
+  lesstif_hid.stop_block_hook         = lesstif_stop_block_hook;
+
+  lesstif_hid.log                     = lesstif_log;
+  lesstif_hid.logv                    = lesstif_logv;
+  lesstif_hid.confirm_dialog          = lesstif_confirm_dialog;
+  lesstif_hid.close_confirm_dialog    = lesstif_close_confirm_dialog;
+  lesstif_hid.report_dialog           = lesstif_report_dialog;
+  lesstif_hid.prompt_for              = lesstif_prompt_for;
+  lesstif_hid.fileselect              = lesstif_fileselect;
+  lesstif_hid.attribute_dialog        = lesstif_attribute_dialog;
+  lesstif_hid.show_item               = lesstif_show_item;
+  lesstif_hid.beep                    = lesstif_beep;
+  lesstif_hid.progress                = lesstif_progress;
+  lesstif_hid.edit_attributes         = lesstif_attributes_dialog;
 
   hid_register_hid (&lesstif_hid);
 #include "lesstif_lists.h"
diff --git a/src/misc.c b/src/misc.c
index 649208c..705f8df 100644
--- a/src/misc.c
+++ b/src/misc.c
@@ -679,15 +679,11 @@ CenterDisplay (LocationType X, LocationType Y, bool Delta)
   double save_grid = PCB->Grid;
   PCB->Grid = 1;
   if (Delta)
-    {
-      MoveCrosshairRelative (X, Y);
-    }
+    MoveCrosshairRelative (X, Y);
   else
     {
       if (MoveCrosshairAbsolute (X, Y))
-        {
-          RestoreCrosshair ();
-        }
+        notify_crosshair_change (true);
     }
   gui->set_crosshair (Crosshair.X, Crosshair.Y, HID_SC_WARP_POINTER);
   PCB->Grid = save_grid;
diff --git a/src/set.c b/src/set.c
index 17f7583..8fef65a 100644
--- a/src/set.c
+++ b/src/set.c
@@ -244,7 +244,7 @@ SetMode (int Mode)
   if (recursing)
     return;
   recursing = true;
-  HideCrosshair ();
+  notify_crosshair_change (false);
   addedLines = 0;
   Crosshair.AttachedObject.Type = NO_TYPE;
   Crosshair.AttachedObject.State = STATE_FIRST;
@@ -314,7 +314,7 @@ SetMode (int Mode)
    * may have changed
    */
   MoveCrosshairRelative (0, 0);
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
 }
 
 void
@@ -342,20 +342,20 @@ SetLocalRef (LocationType X, LocationType Y, bool Showing)
 
   if (Showing)
     {
-      HideCrosshair ();
+      notify_mark_change (false);
       if (count == 0)
 	old = Marked;
       Marked.X = X;
       Marked.Y = Y;
       Marked.status = true;
       count++;
-      RestoreCrosshair ();
+      notify_mark_change (true);
     }
   else if (count > 0)
     {
-      HideCrosshair ();
+      notify_mark_change (false);
       count = 0;
       Marked = old;
-      RestoreCrosshair ();
+      notify_mark_change (true);
     }
 }

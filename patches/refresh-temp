Bottom: f58a19c0131225bde0455f4276c9b90990b4339f
Top:    05605b0db6a16910c8d9eb1029c319498f6b57a4
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2014-12-27 17:38:38 +0000

Refresh of draw-c-opencode-the-mask-layer

---

diff --git a/src/draw.c b/src/draw.c
index 26c0ff4..5133522 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -871,6 +871,55 @@ DrawMaskBoardArea (int mask_type, const BoxType *drawn_area)
                                            drawn_area->X2, drawn_area->Y2);
 }
 
+struct poly_info {
+  const const BoxType *drawn_area;
+  LayerType *layer;
+};
+
+static int
+mask_poly_callback (const BoxType * b, void *cl)
+{
+  struct poly_info *i = cl;
+  PolygonType *polygon = (PolygonType *)b;
+
+  dapi->draw_poly (polygon, i->drawn_area, NULL);
+  return 1;
+}
+
+static int
+mask_line_callback (const BoxType * b, void *cl)
+{
+  LineType *line = (LineType *)b;
+
+  dapi->draw_line (line, NULL, NULL);
+  return 1;
+}
+
+static int
+mask_arc_callback (const BoxType * b, void *cl)
+{
+  ArcType *arc = (ArcType *)b;
+
+  dapi->draw_arc (arc, NULL, NULL);
+  return 1;
+}
+
+static int
+mask_text_callback (const BoxType * b, void *cl)
+{
+  LayerType *layer = cl;
+  TextType *text = (TextType *)b;
+  int min_silk_line;
+
+  if (layer == &PCB->Data->SILKLAYER ||
+      layer == &PCB->Data->BACKSILKLAYER)
+    min_silk_line = PCB->minSlk;
+  else
+    min_silk_line = PCB->minWid;
+  gui->graphics->draw_pcb_text (Output.fgGC, text, min_silk_line);
+  return 1;
+}
+
 /* ---------------------------------------------------------------------------
  * draws solder mask layer - this will cover nearly everything
  */
@@ -878,23 +927,34 @@ void
 DrawMask (int side, const BoxType *screen)
 {
   int thin = TEST_FLAG(THINDRAWFLAG, PCB) || TEST_FLAG(THINDRAWPOLYFLAG, PCB);
+  LayerType *Layer = LAYER_PTR (side == TOP_SIDE ? top_soldermask_layer : bottom_soldermask_layer);
+  struct poly_info info;
 
   if (thin)
-    gui->graphics->set_color (Output.pmGC, PCB->MaskColor);
+    {
+      gui->graphics->set_color (Output.pmGC, PCB->MaskColor);
+      gui->graphics->set_color (Output.fgGC, PCB->MaskColor); /* NB: Required, as draw_layer() uses fgGC */
+    }
   else
     {
       DrawMaskBoardArea (HID_MASK_BEFORE, screen);
       gui->graphics->use_mask (HID_MASK_CLEAR);
+      gui->graphics->set_color (Output.fgGC, "erase"); /* NB: Required, as draw_layer() uses fgGC */
     }
 
-  DrawLayer (LAYER_PTR (side == TOP_SIDE ? top_soldermask_layer : bottom_soldermask_layer), screen);
+  info.layer = Layer;
+  info.drawn_area = screen;
+  r_search (Layer->polygon_tree, screen, NULL, mask_poly_callback, &info);
+  r_search (Layer->line_tree,    screen, NULL, mask_line_callback, Layer);
+  r_search (Layer->arc_tree,     screen, NULL, mask_arc_callback,  Layer);
+  r_search (Layer->text_tree,    screen, NULL, mask_text_callback, Layer);
 
   r_search (PCB->Data->pin_tree, screen, NULL, clearPin_callback, NULL);
-  r_search (PCB->Data->via_tree, screen, NULL, clearPin_callback, NULL);
+  r_search (PCB->Data->via_tree, screen, NULL, clearVia_callback, NULL);
   r_search (PCB->Data->pad_tree, screen, NULL, clearPad_callback, &side);
 
   if (thin)
-    gui->graphics->set_color (Output.pmGC, "erase");
+    gui->graphics->set_color (Output.pmGC, "erase"); /* NB: Only need to set pmGC back, fgGC is set when required */
   else
     {
       DrawMaskBoardArea (HID_MASK_AFTER, screen);

Bottom: 29a2692341de66114af0a111f5041d68f085dfa6
Top:    ca4c0b3ef5f1276d2235dde73e4ee2fd88a0f637
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-02-10 11:34:59 +0000

Refresh of nearly-working

---

diff --git a/src/polygon1.c b/src/polygon1.c
index eb33eef..8da586a 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -1000,12 +1000,22 @@ cntr_in_M_PLINE (PLINE * poly, PLINE * outfst, BOOLp test)
   return FALSE;
 }				/* cntr_in_M_PLINE */
 
+static int
+count_contours_i_am_inside (const BoxType *b, void *cl)
+{
+  PLINE *me = cl;
+  PLINE *check = (PLINE *) b;
+
+  if (poly_ContourInContour (check, me))
+    return 1;
+  return 0;
+}
+
 /* cntr_in_M_POLYAREA
 returns poly is inside outfst ? TRUE : FALSE */
 static int
 cntr_in_M_POLYAREA (PLINE * poly, POLYAREA * outfst, BOOLp test)
 {
-  PLINE *curc;
   POLYAREA *outer = outfst;
   heap_t *heap;
 
@@ -1015,9 +1025,7 @@ cntr_in_M_POLYAREA (PLINE * poly, POLYAREA * outfst, BOOLp test)
   heap = heap_create ();
   do
     {
-      if (outer->contours == NULL) {
-        printf ("cntr_in_M_POLYAREA: outer->contours was NULL\n");
-      } else if (cntrbox_inside (poly, outer->contours))
+      if (cntrbox_inside (poly, outer->contours))
 	heap_insert (heap, outer->contours->area, (void *) outer);
     }
   /* if checking touching, use only the first polygon */
@@ -1030,19 +1038,20 @@ cntr_in_M_POLYAREA (PLINE * poly, POLYAREA * outfst, BOOLp test)
       if (heap_is_empty (heap))
 	break;
       outer = (POLYAREA *) heap_remove_smallest (heap);
-      if (poly_ContourInContour (outer->contours, poly))
-	{
-	  for (curc = outer->contours->next; curc != NULL; curc = curc->next)
-	    if (poly_ContourInContour (curc, poly))
-	      {
-		/* it's inside a hole in the smallest polygon 
-		 * no need to check the other polygons */
-		heap_destroy (&heap);
-		return FALSE;
-	      }
-	  heap_destroy (&heap);
-	  return TRUE;
-	}
+
+      switch (r_search (outer->contour_tree, (BoxType *)poly, NULL, count_contours_i_am_inside, poly)) {
+        case 0: /* Didn't find anything in this piece, Keep looking */
+          break;
+        case 1: /* Found we are inside this piece, and not any of its holes */
+          heap_destroy (&heap);
+          return TRUE;
+        case 2: /* Found inside a hole in the smallest polygon so far. No need to check the other polygons */
+          heap_destroy (&heap);
+          return FALSE;
+        default:
+          printf ("Something strange here\n");
+          break;
+      }
     }
   while (1);
   heap_destroy (&heap);
@@ -1411,7 +1420,7 @@ find_inside (const BoxType *b, void *cl)
     return 0;
   }
   if (poly_ContourInContour (info->want_inside, check)) {
-    printf ("find_inside: Found a hole inside the one we're checking\n");
+//    printf ("find_inside: Found a hole inside the one we're checking\n");
     info->result = check;
     longjmp (info->jb, 1);
   }
@@ -1534,10 +1543,6 @@ InsertHoles (jmp_buf * e, POLYAREA * dest, PLINE ** src)
               break;
             }
 
-            /* If nothing found, break out of the loop */
-            if (info.result == NULL)
-              break;
-
             /* We need to find the contour before it, so we can update its next pointer */
             prev = container;
             while (prev->next != info.result) {
@@ -2002,13 +2007,12 @@ M_POLYAREA_separate_isected (jmp_buf * e, POLYAREA ** pieces,
   int finished;
 
   if (a == NULL) {
-    printf ("M_POLYAREA_separate_isected: No polygon pieces to play with\n");
+//    printf ("M_POLYAREA_separate_isected: No polygon pieces to play with\n");
     return;
   }
 
-  /* FIXME: Test the outer contour first, for speed...
-   * coulf shortcut moving all the holes into the holes list.
-   */
+  /* TODO: STASH ENOUGH INFORMATION EARLIER ON, SO WE CAN REMOVE THE INTERSECTED
+           CONTOURS WITHOUT HAVING TO WALK THE FULL DATA-STRUCTURE LOOKING FOR THEM. */
 
   do {
     int hole_contour = 0;
@@ -2038,6 +2042,7 @@ M_POLYAREA_separate_isected (jmp_buf * e, POLYAREA ** pieces,
           curc->next = *isected;
           *isected = curc;
         } else if (hole_contour) {
+//          printf ("Hole contour, perhaps would have been saved the trouble if we mass-evicted children\n");
           /* Link into the list of holes */
           curc->next = *holes;
           *holes = curc;
@@ -2082,19 +2087,11 @@ find_inside_m_pa (const BoxType *b, void *cl)
   /* Don't report for the main contour */
   if (check->Flags.orient == PLF_DIR)
     return 0;
+  /* Don't look at contours marked as being intersected */
+  if (check->Flags.status == ISECTED)
+    return 0;
   if (cntr_in_M_POLYAREA (check, info->want_inside, FALSE)) {
-    printf ("find_inside_m_pa: Found a hole inside the one we're checking\n");
-#if 0
-    if (check->Flags.status == INSIDE) {
-      printf ("find_inside_m_pa: Sanity check, is flagged INSIDE\n");
-    } else if (check->Flags.status == OUTSIDE) {
-      printf ("find_inside_m_pa: ****** IT IS FLAGGED OUTSIDE ********\n");
-    } else if (check->Flags.status == ISECTED) {
-      printf ("find_inside_m_pa: ****** IT IS FLAGGED ISECTED ********\n");
-    } else {
-      printf ("find_inside_m_pa: ****** UNKNOWN STATUS ********\n");
-    }
-#endif
+//    printf ("find_inside_m_pa: Found a hole inside the one we're checking\n");
     info->result = check;
     longjmp (info->jb, 1);
   }
@@ -2139,41 +2136,40 @@ M_POLYAREA_update_primary (jmp_buf * e, POLYAREA ** pieces,
   }
 
   box = *((BoxType *)bpa->contours);
-  b = bpa->f;
-  do {
+  b = bpa;
+  while ((b = b->f) != bpa) {
     BoxType *b_box = (BoxType *)b->contours;
-    box.X1 = MIN (box.X1, b_box->X1);
-    box.Y1 = MIN (box.Y1, b_box->Y1);
-    box.X2 = MAX (box.X2, b_box->X2);
-    box.Y2 = MAX (box.Y2, b_box->Y2);
-  } while ((b = b->f) != bpa);
+    MAKEMIN (box.X1, b_box->X1);
+    MAKEMIN (box.Y1, b_box->Y1);
+    MAKEMAX (box.X2, b_box->X2);
+    MAKEMAX (box.Y2, b_box->Y2);
+  }
 
 #if 1
   if (del_inside) {
-    /* Test the outer contours first... rahter than having to dive into r-tree stuff? */
-    /* Cheat for now, and use the labelled results */
 
     do {
       anext = a->f;
       finished = (anext == *pieces);
 
-      if (a->contours->Flags.status == ISECTED) {
-        /* Move this contour, all children -> holes queue */
-        printf ("**** SHOULD NOT HAPPEN *****\n");
-        continue;
-      }
+      /* Test the outer contour first, as we may need to remove all children */
+
+      /* We've not yet split intersected contours out, just ignore them */
+      if (a->contours->Flags.status != ISECTED &&
+          /* Pre-filter on bounding box */
+          ((a->contours->xmin >= box.X1) && (a->contours->ymin >= box.Y1) &&
+           (a->contours->xmax <= box.X2) && (a->contours->ymax <= box.Y2)) &&
+          /* Then test properly */
+          cntr_in_M_POLYAREA (a->contours, bpa, FALSE)) {
 
-      //if (a->contours->Flags.status == INSIDE) {
-      /* TODO: SHOULD PROBABLY PRE-FILTER ON THE BOUNDING BOX */
-      if (cntr_in_M_POLYAREA (a->contours, bpa, FALSE)) {
         /* Delete this contour, all children -> holes queue */
         printf ("Outer contour needs to be deleted, and children moved to hole queue\n");
 
         /* Delete the outer contour */
         curc = a->contours;
         remove_contour (a, NULL, curc, FALSE); /* Rtree deleted in poly_Free below */
-        poly_DelContour (&curc);
         /* a->contours now points to the remaining holes */
+        poly_DelContour (&curc);
 
         if (a->contours != NULL) {
           /* Find the end of the list of holes */
@@ -2193,7 +2189,7 @@ M_POLYAREA_update_primary (jmp_buf * e, POLYAREA ** pieces,
         continue;
       }
 
-      /* Need to check if this new hole means we need to kick out any old ones for reprocessing */
+      /* Loop whilst we find INSIDE contours to delete */
       while (1) {
         struct find_inside_m_pa_info info;
         PLINE *prev;
@@ -2267,7 +2263,8 @@ M_POLYAREA_update_primary (jmp_buf * e, POLYAREA ** pieces,
 #endif
 
       if (del_outside)
-        del_contour = !cntr_in_M_POLYAREA (curc, bpa, FALSE);
+        del_contour = curc->Flags.status != ISECTED &&
+                     !cntr_in_M_POLYAREA (curc, bpa, FALSE);
 
       /* Reset the intersection flags, since we keep these pieces */
       if (curc->Flags.status != ISECTED)
@@ -2619,7 +2616,7 @@ poly_Boolean_free (POLYAREA * ai, POLYAREA * bi, POLYAREA ** res, int action)
     for (curc = apa->contours; curc != NULL; curc = curc->next) {
       if (curc->Flags.status != UNKNWN) {
         curc->Flags.status = UNKNWN;
-        printf ("OH CRAP, SOMETHING DIDN'T CLEAR THE FLAGS\n");
+        printf ("SOMETHING DIDN'T CLEAR THE FLAGS\n");
       }
     }
     /* If we deleted all the pieces of the polyarea, *pieces is NULL */
@@ -2635,34 +2632,12 @@ poly_Boolean_free (POLYAREA * ai, POLYAREA * bi, POLYAREA ** res, int action)
 //      M_POLYAREA_label (a, b, FALSE);
       M_POLYAREA_label (b, a, FALSE);
 
-/* New faster method */
-#if 1
       *res = a;
-      M_POLYAREA_separate_isected (&e, res, &holes, &a_isected);
-      M_POLYAREA_label_separated (a_isected, b, FALSE);
       M_POLYAREA_update_primary (&e, res, &holes, action, b);
 //      M_POLYAREA_update_primary_old (&e, res, &holes, &a_isected, action);
+      M_POLYAREA_separate_isected (&e, res, &holes, &a_isected);
+      M_POLYAREA_label_separated (a_isected, b, FALSE);
       M_POLYAREA_Collect_separated (&e, a_isected, res, &holes, action, FALSE);
-#endif
-
-/* First attempt at go-faster stripes */
-#if 0
-      /* And speed things up _A LOT_ here by only processing the relevant
-         contours, specifically keeping the source "a" as a starting point
-         for the output polygon */
-      M_POLYAREA_Collect_separated (&e, a_isected, res, &holes, action, FALSE);
-      M_POLYAREA_Collect (&e, a, res, &holes, action, FALSE);
-      poly_Free (&a);
-#endif
-
-/* Old slow way */
-#if 0
-      M_POLYAREA_Collect (&e, a, res, &holes, action, b->f == b
-			  && !b->contours->next
-			  && b->contours->Flags.status != ISECTED);
-      poly_Free (&a);
-#endif
-
       M_B_AREA_Collect (&e, b, res, &holes, action);
       poly_Free (&b);

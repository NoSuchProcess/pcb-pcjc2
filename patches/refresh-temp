Bottom: 353182d0a835a31285519f2557d0a89bbe376ccc
Top:    658d0858cf74491183a9597aeadd5fbdf17407f8
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-02-22 02:26:48 +0000

Refresh of play-with-subcompositing-using

---

diff --git a/src/draw.c b/src/draw.c
index 6d3f763..617e2b1 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -114,6 +114,8 @@ static void DrawSilk (int, int, BoxType *);
 static int pin_callback (const BoxType * b, void *cl);
 static int pad_callback (const BoxType * b, void *cl);
 
+void hidgl_hack_ignore_stencil (int ignore);
+
 /*--------------------------------------------------------------------------------------
  * setup color for pin or via
  */
@@ -133,6 +135,7 @@ SetPVColor (PinTypePtr Pin, int Type)
 	    color = PCB->ViaSelectedColor;
 	  else
 	    color = PCB->ConnectedColor;
+          hidgl_hack_ignore_stencil (1);
 	}
       else
 	color = PCB->ViaColor;
@@ -148,6 +151,7 @@ SetPVColor (PinTypePtr Pin, int Type)
 	    color = PCB->PinSelectedColor;
 	  else
 	    color = PCB->ConnectedColor;
+          hidgl_hack_ignore_stencil (1);
 	}
       else
 	color = PCB->PinColor;
@@ -430,6 +434,7 @@ DrawEverything (BoxTypePtr drawn_area)
 		    backN_callback, NULL);
 	  DrawLayer (&(PCB->Data->BACKSILKLAYER), drawn_area);
 	}
+      gui->set_layer (NULL, SL (FINISHED, 0), 0);
     }
 
   /* draw all layers in layerstack order */
@@ -468,6 +473,7 @@ DrawEverything (BoxTypePtr drawn_area)
 			    &plated);
 		}
 	    }
+	  gui->set_layer (NULL, SL (FINISHED, 0), 0);
 	}
     }
   if (TEST_FLAG (CHECKPLANESFLAG, PCB) && gui->gui)
@@ -921,7 +927,8 @@ DrawLayerGroup (int group, const BoxType * screen)
   Cardinal *layers = PCB->LayerGroups.Entries[group];
 
   clip_box = screen;
-  for (i = n_entries - 1; i >= 0; i--)
+  for (i = n_entries - 1; i >= 0;
+      i--, gui->set_layer (0, group, 0)) /* HACK: Subcomposite each layer in a layer group separately */
     {
       layernum = layers[i];
       Layer = PCB->Data->Layer + layers[i];
@@ -946,10 +953,11 @@ DrawLayerGroup (int group, const BoxType * screen)
 	      r_search (Layer->polygon_tree, screen, NULL, poly_callback,
 			&info);
 	      info.arg = False;
-	    }
 
-          /* Reset the compositing HACK */
-          gui->set_layer (0, group, 0);
+	      /* HACK: Subcomposite polygons separately from other layer primitives */
+	      /* Reset the compositing */
+	      gui->set_layer (0, group, 0);
+	    }
 
 	  if (TEST_FLAG (CHECKPLANESFLAG, PCB))
 	    continue;
@@ -969,8 +977,8 @@ DrawLayerGroup (int group, const BoxType * screen)
           gui->fill_rect (Output.fgGC, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
           gui->use_mask (HID_MASK_OFF);
 #endif
-          /* Reset the compositing HACK */
-          gui->set_layer (0, group, 0);
+//          /* Reset the compositing HACK */
+//          gui->set_layer (0, group, 0);
 	}
     }
   if (n_entries > 1)
@@ -1163,9 +1171,15 @@ DrawHole (PinTypePtr Ptr)
   if (TEST_FLAG (HOLEFLAG, Ptr))
     {
       if (TEST_FLAG (WARNFLAG, Ptr))
-	gui->set_color (Output.fgGC, PCB->WarnColor);
+        {
+          gui->set_color (Output.fgGC, PCB->WarnColor);
+          hidgl_hack_ignore_stencil (1);
+        }
       else if (TEST_FLAG (SELECTEDFLAG, Ptr))
-	gui->set_color (Output.fgGC, PCB->ViaSelectedColor);
+        {
+          gui->set_color (Output.fgGC, PCB->ViaSelectedColor);
+          hidgl_hack_ignore_stencil (1);
+        }
       else
 	gui->set_color (Output.fgGC, Settings.BlackColor);
 
@@ -1174,6 +1188,7 @@ DrawHole (PinTypePtr Ptr)
       gui->draw_arc (Output.fgGC,
 		     Ptr->X, Ptr->Y, Ptr->DrillingHole / 2,
 		     Ptr->DrillingHole / 2, 0, 360);
+      hidgl_hack_ignore_stencil (0);
     }
 }
 
@@ -1277,6 +1292,7 @@ ClearPin (PinTypePtr Pin, int Type, int unused)
     case PIN_TYPE:
       SetPVColor (Pin, Type);
       DrawPinOrViaLowLevel (Pin, True);
+      hidgl_hack_ignore_stencil (0);
       break;
     case NO_TYPE:
     default:
@@ -1802,6 +1818,7 @@ DrawVia (PinTypePtr Via, int unused)
   // ClearPin (Via, VIA_TYPE, 0);
   //else
   DrawPinOrViaLowLevel (Via, True);
+  hidgl_hack_ignore_stencil (0);
   if (!TEST_FLAG (HOLEFLAG, Via) && TEST_FLAG (DISPLAYNAMEFLAG, Via))
     DrawPinOrViaNameLowLevel (Via);
 }
@@ -1815,6 +1832,7 @@ DrawPlainVia (PinTypePtr Via, Boolean holeToo)
   if (!Gathering)
     SetPVColor (Via, VIA_TYPE);
   DrawPinOrViaLowLevel (Via, holeToo);
+  hidgl_hack_ignore_stencil (0);
   if (!TEST_FLAG (HOLEFLAG, Via) && TEST_FLAG (DISPLAYNAMEFLAG, Via))
     DrawPinOrViaNameLowLevel (Via);
 }
@@ -1828,11 +1846,15 @@ DrawViaName (PinTypePtr Via, int unused)
   if (!Gathering)
     {
       if (TEST_FLAG (SELECTEDFLAG, Via))
-	gui->set_color (Output.fgGC, PCB->ViaSelectedColor);
+        {
+	  gui->set_color (Output.fgGC, PCB->ViaSelectedColor);
+          hidgl_hack_ignore_stencil (1);
+        }
       else
 	gui->set_color (Output.fgGC, PCB->ViaColor);
     }
   DrawPinOrViaNameLowLevel (Via);
+  hidgl_hack_ignore_stencil (0);
 }
 
 /* ---------------------------------------------------------------------------
@@ -1848,6 +1870,7 @@ DrawPin (PinTypePtr Pin, int unused)
     if (!Gathering)
       SetPVColor (Pin, PIN_TYPE);
     DrawPinOrViaLowLevel (Pin, True);
+    hidgl_hack_ignore_stencil (0);
   }
   if ((!TEST_FLAG (HOLEFLAG, Pin) && TEST_FLAG (DISPLAYNAMEFLAG, Pin))
       || doing_pinout)
@@ -1862,6 +1885,7 @@ DrawPlainPin (PinTypePtr Pin, Boolean holeToo)
 {
   if (!Gathering)
     SetPVColor (Pin, PIN_TYPE);
+  hidgl_hack_ignore_stencil (0);
   DrawPinOrViaLowLevel (Pin, holeToo);
   if (!TEST_FLAG (HOLEFLAG, Pin) && TEST_FLAG (DISPLAYNAMEFLAG, Pin))
     DrawPinOrViaNameLowLevel (Pin);
@@ -1876,11 +1900,15 @@ DrawPinName (PinTypePtr Pin, int unused)
   if (!Gathering)
     {
       if (TEST_FLAG (SELECTEDFLAG, Pin))
-	gui->set_color (Output.fgGC, PCB->PinSelectedColor);
+        {
+	  gui->set_color (Output.fgGC, PCB->PinSelectedColor);
+          hidgl_hack_ignore_stencil (1);
+        }
       else
 	gui->set_color (Output.fgGC, PCB->PinColor);
     }
   DrawPinOrViaNameLowLevel (Pin);
+  hidgl_hack_ignore_stencil (0);
 }
 
 /* ---------------------------------------------------------------------------
@@ -1901,6 +1929,7 @@ DrawPad (PadTypePtr Pad, int unused)
 	    gui->set_color (Output.fgGC, PCB->PinSelectedColor);
 	  else
 	    gui->set_color (Output.fgGC, PCB->ConnectedColor);
+          hidgl_hack_ignore_stencil (1);
 	}
       else if (FRONT (Pad))
 	gui->set_color (Output.fgGC, PCB->PinColor);
@@ -1910,6 +1939,7 @@ DrawPad (PadTypePtr Pad, int unused)
   DrawPadLowLevel (Output.fgGC, Pad, False, False);
   if (doing_pinout || TEST_FLAG (DISPLAYNAMEFLAG, Pad))
     DrawPadNameLowLevel (Pad);
+  hidgl_hack_ignore_stencil (0);
 }
 
 /* ---------------------------------------------------------------------------
@@ -1921,13 +1951,17 @@ DrawPadName (PadTypePtr Pad, int unused)
   if (!Gathering)
     {
       if (TEST_FLAG (SELECTEDFLAG, Pad))
-	gui->set_color (Output.fgGC, PCB->PinSelectedColor);
+        {
+	  gui->set_color (Output.fgGC, PCB->PinSelectedColor);
+          hidgl_hack_ignore_stencil (1);
+        }
       else if (FRONT (Pad))
 	gui->set_color (Output.fgGC, PCB->PinColor);
       else
 	gui->set_color (Output.fgGC, PCB->InvisibleObjectsColor);
     }
   DrawPadNameLowLevel (Pad);
+  hidgl_hack_ignore_stencil (0);
 }
 
 /* ---------------------------------------------------------------------------
@@ -1944,11 +1978,13 @@ DrawLine (LayerTypePtr Layer, LineTypePtr Line, int unused)
 	    gui->set_color (Output.fgGC, Layer->SelectedColor);
 	  else
 	    gui->set_color (Output.fgGC, PCB->ConnectedColor);
+          hidgl_hack_ignore_stencil (1);
 	}
       else
 	gui->set_color (Output.fgGC, Layer->Color);
     }
   DrawLineLowLevel (Line, False);
+  hidgl_hack_ignore_stencil (0);
 }
 
 /* ---------------------------------------------------------------------------
@@ -1965,6 +2001,7 @@ DrawRat (RatTypePtr Line, int unused)
 	    gui->set_color (Output.fgGC, PCB->RatSelectedColor);
 	  else
 	    gui->set_color (Output.fgGC, PCB->ConnectedColor);
+          hidgl_hack_ignore_stencil (1);
 	}
       else
 	gui->set_color (Output.fgGC, PCB->RatColor);
@@ -1998,6 +2035,7 @@ DrawRat (RatTypePtr Line, int unused)
     }
   else
     DrawLineLowLevel ((LineTypePtr) Line, False);
+  hidgl_hack_ignore_stencil (0);
 }
 
 /* ---------------------------------------------------------------------------
@@ -2016,11 +2054,13 @@ DrawArc (LayerTypePtr Layer, ArcTypePtr Arc, int unused)
 	    gui->set_color (Output.fgGC, Layer->SelectedColor);
 	  else
 	    gui->set_color (Output.fgGC, PCB->ConnectedColor);
+          hidgl_hack_ignore_stencil (1);
 	}
       else
 	gui->set_color (Output.fgGC, Layer->Color);
     }
   DrawArcLowLevel (Arc);
+  hidgl_hack_ignore_stencil (0);
 }
 
 /* ---------------------------------------------------------------------------
@@ -2033,7 +2073,10 @@ DrawText (LayerTypePtr Layer, TextTypePtr Text, int unused)
   if (!Layer->On)
     return;
   if (TEST_FLAG (SELECTEDFLAG, Text))
-    gui->set_color (Output.fgGC, Layer->SelectedColor);
+    {
+      gui->set_color (Output.fgGC, Layer->SelectedColor);
+      hidgl_hack_ignore_stencil (1);
+    }
   else
     gui->set_color (Output.fgGC, Layer->Color);
   if (Layer == & PCB->Data->SILKLAYER
@@ -2042,6 +2085,7 @@ DrawText (LayerTypePtr Layer, TextTypePtr Text, int unused)
   else
     min_silk_line = PCB->minWid;
   DrawTextLowLevel (Text, min_silk_line);
+  hidgl_hack_ignore_stencil (0);
 }
 
 /* ---------------------------------------------------------------------------
@@ -2052,7 +2096,10 @@ DrawRegularText (LayerTypePtr Layer, TextTypePtr Text, int unused)
 {
   int min_silk_line;
   if (TEST_FLAG (SELECTEDFLAG, Text))
-    gui->set_color (Output.fgGC, Layer->SelectedColor);
+    {
+      gui->set_color (Output.fgGC, Layer->SelectedColor);
+      hidgl_hack_ignore_stencil (1);
+    }
   else
     gui->set_color (Output.fgGC, Layer->Color);
   if (Layer == & PCB->Data->SILKLAYER
@@ -2061,6 +2108,7 @@ DrawRegularText (LayerTypePtr Layer, TextTypePtr Text, int unused)
   else
     min_silk_line = PCB->minWid;
   DrawTextLowLevel (Text, min_silk_line);
+  hidgl_hack_ignore_stencil (0);
 }
 
 static int
@@ -2081,7 +2129,10 @@ DrawPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon, int unused)
   if (TEST_FLAG (SELECTEDFLAG | FOUNDFLAG, Polygon))
     {
       if (TEST_FLAG (SELECTEDFLAG, Polygon))
-	gui->set_color (Output.fgGC, Layer->SelectedColor);
+        {
+	  gui->set_color (Output.fgGC, Layer->SelectedColor);
+          hidgl_hack_ignore_stencil (1);
+        }
       else
 	gui->set_color (Output.fgGC, PCB->ConnectedColor);
     }
@@ -2089,6 +2140,7 @@ DrawPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon, int unused)
     gui->set_color (Output.fgGC, Layer->Color);
   layernum = GetLayerNumber (PCB->Data, Layer);
   DrawPolygonLowLevel (Polygon);
+  hidgl_hack_ignore_stencil (0);
   if (TEST_FLAG (CLEARPOLYFLAG, Polygon))
     {
       r_search (PCB->Data->pin_tree, &Polygon->BoundingBox, NULL,
@@ -2146,7 +2198,10 @@ DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
     }
 
   if (TEST_FLAG (SELECTEDFLAG, Polygon))
-    color = Layer->SelectedColor;
+    {
+      color = Layer->SelectedColor;
+      hidgl_hack_ignore_stencil (1);
+    }
   else if (TEST_FLAG (FOUNDFLAG, Polygon))
     color = PCB->ConnectedColor;
   else
@@ -2179,6 +2234,7 @@ DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
            poly.Clipped = poly.Clipped->f)
         gui->thindraw_pcb_polygon (Output.fgGC, &poly, clip_box);
     }
+  hidgl_hack_ignore_stencil (0);
 }
 
 /* ---------------------------------------------------------------------------
@@ -2243,7 +2299,10 @@ DrawElementName (ElementTypePtr Element, int unused)
   if (doing_pinout || doing_assy)
     gui->set_color (Output.fgGC, PCB->ElementColor);
   else if (TEST_FLAG (SELECTEDFLAG, &ELEMENT_TEXT (PCB, Element)))
-    gui->set_color (Output.fgGC, PCB->ElementSelectedColor);
+    {
+      gui->set_color (Output.fgGC, PCB->ElementSelectedColor);
+      hidgl_hack_ignore_stencil (1);
+    }
   else if (FRONT (Element))
     gui->set_color (Output.fgGC, PCB->ElementColor);
   else
@@ -2256,6 +2315,7 @@ DrawElementName (ElementTypePtr Element, int unused)
 #else
   DrawStrippedText (Element, PCB->minSlk);
 #endif
+  hidgl_hack_ignore_stencil (0);
 }
 
 #define MASK_SUBCOMPOSITE_ELEMENT_PACKAGE 0
@@ -2277,9 +2337,12 @@ DrawElementPackage (ElementTypePtr Element, int unused)
 
   /* set color and draw lines, arcs, text and pins */
   if (doing_pinout || doing_assy)
-    gui->set_color (Output.fgGC, PCB->ElementColor);
+      gui->set_color (Output.fgGC, PCB->ElementColor);
   else if (TEST_FLAG (SELECTEDFLAG, Element))
-    gui->set_color (Output.fgGC, PCB->ElementSelectedColor);
+    {
+      gui->set_color (Output.fgGC, PCB->ElementSelectedColor);
+      hidgl_hack_ignore_stencil (1);
+    }
   else if (FRONT (Element))
     gui->set_color (Output.fgGC, PCB->ElementColor);
   else
@@ -2292,6 +2355,7 @@ DrawElementPackage (ElementTypePtr Element, int unused)
 #else
   DrawElementPackageLowLevel (Element, unused);
 #endif
+  hidgl_hack_ignore_stencil (0);
 }
 
 /* ---------------------------------------------------------------------------
diff --git a/src/hid.h b/src/hid.h
index c01a0b4..e65a1be 100644
--- a/src/hid.h
+++ b/src/hid.h
@@ -197,6 +197,7 @@ extern "C"
 #define SL_FAB		0x0070
 #define SL_ASSY		0x0080
 #define SL_RATS		0x0090
+#define SL_FINISHED	0x00A0
 /* Callers should use this.  */
 #define SL(type,side) (~0xfff | SL_##type | SL_##side##_SIDE)
 
diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index c8e3998..31888b6 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -182,88 +182,6 @@ draw_grid ()
 #endif
 /* ------------------------------------------------------------ */
 
-#if 0
-int
-hidgl_set_layer (const char *name, int group, int empty)
-{
-  int idx = (group >= 0
-             && group <
-             max_layer) ? PCB->LayerGroups.Entries[group][0] : group;
-
-  if (idx >= 0 && idx < max_layer + 2) {
-    gport->trans_lines = TRUE;
-    return /*pinout ? 1 : */ PCB->Data->Layer[idx].On;
-  }
-  if (idx < 0)
-    {
-      switch (SL_TYPE (idx))
-        {
-        case SL_INVISIBLE:
-          return /* pinout ? 0 : */ PCB->InvisibleObjectsOn;
-        case SL_MASK:
-          if (SL_MYSIDE (idx) /*&& !pinout */ )
-            return TEST_FLAG (SHOWMASKFLAG, PCB);
-          return 0;
-        case SL_SILK:
-//          gport->trans_lines = TRUE;
-          gport->trans_lines = FALSE;
-          if (SL_MYSIDE (idx) /*|| pinout */ )
-            return PCB->ElementOn;
-          return 0;
-        case SL_ASSY:
-          return 0;
-        case SL_RATS:
-          gport->trans_lines = TRUE;
-          return 1;
-        case SL_PDRILL:
-        case SL_UDRILL:
-          return 1;
-        }
-    }
-  return 0;
-}
-
-void
-hidgl_use_mask (int use_it)
-{
-  if (use_it == cur_mask)
-    return;
-
-  hidgl_flush_triangles ();
-
-  switch (use_it)
-    {
-    case HID_MASK_BEFORE:
-      /* Write '1' to the stencil buffer where the solder-mask is drawn. */
-      glColorMask (0, 0, 0, 0);                   // Disable writting in color buffer
-      glEnable (GL_STENCIL_TEST);                 // Enable Stencil test
-      glStencilFunc (GL_ALWAYS, 1, 1);            // Test always passes, value written 1
-      glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value (with 1)
-      break;
-
-    case HID_MASK_CLEAR:
-      /* Drawing operations clear the stencil buffer to '0' */
-      glStencilFunc (GL_ALWAYS, 0, 1);            // Test always passes, value written 0
-      glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value (with 0)
-      break;
-
-    case HID_MASK_AFTER:
-      /* Drawing operations as masked to areas where the stencil buffer is '1' */
-      glColorMask (1, 1, 1, 1);                   // Enable drawing of r, g, b & a
-      glStencilFunc (GL_EQUAL, 1, 1);             // Draw only where stencil buffer is 1
-      glStencilOp (GL_KEEP, GL_KEEP, GL_KEEP);    // Stencil buffer read only
-      break;
-
-    case HID_MASK_OFF:
-      /* Disable stenciling */
-      glDisable (GL_STENCIL_TEST);                // Disable Stencil test
-      break;
-    }
-  cur_mask = use_it;
-}
-#endif
-
-
 #define MIN_TRIANGLES_PER_CAP 3
 #define MAX_TRIANGLES_PER_CAP 90
 static void draw_cap (double width, int x, int y, double angle, double scale)
@@ -656,28 +574,27 @@ hidgl_fill_polygon (int n_coords, int *x, int *y)
   free (vertices);
 }
 
-void tesselate_contour (GLUtesselator *tobj, VNODE *vnode,
-                        GLdouble *vertices, int *i)
+void tesselate_contour (GLUtesselator *tobj, VNODE *vnode, GLdouble *vertices)
 {
   VNODE *vn = vnode;
-  int offset = *i * 3;
+  int offset = 0;
 
+  gluTessBeginPolygon (tobj, NULL);
   gluTessBeginContour (tobj);
   do {
     vertices [0 + offset] = vn->point[0];
     vertices [1 + offset] = vn->point[1];
     vertices [2 + offset] = 0.;
     gluTessVertex (tobj, &vertices [offset], &vertices [offset]);
-    (*i)++;
     offset += 3;
   } while ((vn = vn->next) != vnode);
   gluTessEndContour (tobj);
+  gluTessEndPolygon (tobj);
 }
 
 struct do_hole_info {
   GLUtesselator *tobj;
   GLdouble *vertices;
-  int *i;
 };
 
 static int
@@ -689,82 +606,89 @@ do_hole (const BoxType *b, void *cl)
   if (curc->Flags.orient == PLF_DIR) {
     return 0;
   }
-  gluTessBeginPolygon (info->tobj, NULL);
-  tesselate_contour (info->tobj, &curc->head, info->vertices, info->i);
-  gluTessEndPolygon (info->tobj);
+  tesselate_contour (info->tobj, &curc->head, info->vertices);
   return 1;
 }
 
+static GLint stencil_bits;
+static int dirty_bits = 0;
+static int assigned_bits = 0;
+
+/* FIXME: JUST DRAWS THE FIRST PIECE.. TODO: SUPPORT FOR FULLPOLY POLYGONS */
 void
 hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale)
 {
-  int i, cc;
   int vertex_count = 0;
   PLINE *contour;
   struct do_hole_info info;
-
+  int stencil_bit;
 
   global_scale = scale;
 
-  if (poly->Clipped == NULL) {
-    fprintf (stderr, "hidgl_fill_pcb_polygon: poly->Clipped == NULL\n");
-    return;
-  }
+  if (poly->Clipped == NULL)
+    {
+      fprintf (stderr, "hidgl_fill_pcb_polygon: poly->Clipped == NULL\n");
+      return;
+    }
 
-  /* TODO: Just draw our triangles, no need to flush the buffer */
+  stencil_bit = hidgl_assign_clear_stencil_bit ();
+  if (!stencil_bit)
+    {
+      printf ("hidgl_fill_pcb_polygon: No free stencil bits, aborting polygon\n");
+      return;
+    }
+
+  /* Flush out any existing geoemtry to be rendered */
   hidgl_flush_triangles (&buffer);
 
-  /* JUST DRAW THE FIRST PIECE */
   /* Walk the polygon structure, counting vertices */
   /* This gives an upper bound on the amount of storage required */
   for (contour = poly->Clipped->contours;
        contour != NULL; contour = contour->next)
-    vertex_count += contour->Count;
+    vertex_count = MAX (vertex_count, contour->Count);
 
   info.vertices = malloc (sizeof(GLdouble) * vertex_count * 3);
   info.tobj = gluNewTess ();
-  info.i = &i;
   gluTessCallback(info.tobj, GLU_TESS_BEGIN, myBegin);
   gluTessCallback(info.tobj, GLU_TESS_VERTEX, myVertex);
   gluTessCallback(info.tobj, GLU_TESS_COMBINE, myCombine);
   gluTessCallback(info.tobj, GLU_TESS_ERROR, myError);
 
-  glStencilFunc (GL_ALWAYS, 2, 2);            // Always pass stencil test, reference value is 2
-
-//  glClear (GL_STENCIL_BUFFER_BIT);
-  glColorMask (0, 0, 0, 0);                   // Disable writting in color buffer
-//  glEnable (GL_STENCIL_TEST);
+  glPushAttrib (GL_STENCIL_BUFFER_BIT);                   // Save the write mask etc.. for final restore
+  glPushAttrib (GL_STENCIL_BUFFER_BIT |                   // Resave the stencil write-mask etc.., and
+                GL_COLOR_BUFFER_BIT);                     // the colour buffer write mask etc.. for part way restore
+  glStencilMask (stencil_bit);                            // Only write to our stencil bit
+  glStencilFunc (GL_ALWAYS, stencil_bit, stencil_bit);    // Always pass stencil test, ref value is our bit
+  glColorMask (0, 0, 0, 0);                               // Disable writting in color buffer
 
-  i = 0;
-  cc = 1;
-
-  /* Drawing operations set the stencil buffer to '1' */
-//  glStencilFunc (GL_ALWAYS, 1, 1);            // Test always passes, value written 1
-//  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value (with 1)
+  /* It will already be setup like this (so avoid prodding the state-machine):
+   * glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value
+   */
+  /* Drawing operations now set our reference bit in the stencil buffer */
 
   r_search (poly->Clipped->contour_tree, clip_box, NULL, do_hole, &info);
   hidgl_flush_triangles (&buffer);
 
   /* Drawing operations as masked to areas where the stencil buffer is '0' */
-  glColorMask (1, 1, 1, 1);                   // Enable drawing of r, g, b & a
-//  glStencilFunc (GL_EQUAL, 0, 1);             // Draw only where stencil buffer is 0
-//  glStencilOp (GL_KEEP, GL_KEEP, GL_KEEP);    // Stencil buffer read only
-  glStencilFunc (GL_GREATER, 1, 3);                // Pass stencil test if all bits clear, reference value is 1
+
+  glPopAttrib ();                                             // Restore the colour and stencil buffer write-mask etc..
+
+  glStencilOp (GL_KEEP, GL_KEEP, GL_INVERT); // This allows us to toggle the bit on the subcompositing bitplane
+                                             // If the stencil test has passed, we know that bit is 0, so we're
+                                             // effectively just setting it to 1.
+  glStencilFunc (GL_GEQUAL, 0, assigned_bits);
+//  glStencilFunc (GL_GREATER, assigned_bits, assigned_bits);   // Pass stencil test if all assigned bits clear,
+                                                              // reference is all assigned bits so we set
+                                                              // any bits permitted by the stencil writemask
 
   /* Draw the polygon outer */
-  gluTessBeginPolygon (info.tobj, NULL);
-  tesselate_contour (info.tobj, &poly->Clipped->contours->head, info.vertices, &i);
-  gluTessEndPolygon (info.tobj);
+  tesselate_contour (info.tobj, &poly->Clipped->contours->head, info.vertices);
   hidgl_flush_triangles (&buffer);
 
-//  glClear (GL_STENCIL_BUFFER_BIT);
-//  glDisable (GL_STENCIL_TEST);                // Disable Stencil test
-  glStencilFunc (GL_GREATER, 1, 1);                // Pass stencil test stencil buffer bit 1 is 0, reference value is 1
+  /* Unassign our stencil buffer bit */
+  hidgl_return_stencil_bit (stencil_bit);
 
-  /* Clear the second stencil buffer bits */
-  glStencilMask (2);
-  glClear (GL_STENCIL_BUFFER_BIT);
-  glStencilMask (~0);
+  glPopAttrib ();                                             // Restore the stencil buffer write-mask etc..
 
   gluDeleteTess (info.tobj);
   myFreeCombined ();
@@ -778,6 +702,84 @@ hidgl_fill_rect (int x1, int y1, int x2, int y2)
   hidgl_add_triangle (&buffer, x2, y1, x2, y2, x1, y1);
 }
 
+void
+hidgl_init (void)
+{
+  glGetIntegerv (GL_STENCIL_BITS, &stencil_bits);
+
+  if (stencil_bits == 0)
+    {
+      printf ("No stencil bits available.\n"
+              "Cannot mask polygon holes or subcomposite layers\n");
+      /* TODO: Flag this to the HID so it can rever to the dicer? */
+    }
+  else if (stencil_bits == 1)
+    {
+      printf ("Only one stencil bitplane avilable\n"
+              "Cannot use stencil buffer to sub-composite layers.\n");
+      /* Do we need to disable that somewhere? */
+    }
+}
+
+int
+hidgl_stencil_bits (void)
+{
+  return stencil_bits;
+}
+
+int
+hidgl_assign_clear_stencil_bit (void)
+{
+  int stencil_bitmask = (1 << stencil_bits) - 1;
+  int test;
+  int first_dirty = 0;
+
+  if (assigned_bits == stencil_bitmask)
+    {
+      printf ("No more stencil bits available, total of %i already assigned\n",
+              stencil_bits);
+      return 0;
+    }
+
+  /* Look for a bitplane we don't have to clear */
+  for (test = 1; test & stencil_bitmask; test <<= 1)
+    {
+      if (!(test & dirty_bits))
+        {
+          assigned_bits |= test;
+          dirty_bits |= test;
+//          printf ("Assigning an already clean stencil bitplane %x\n", test);
+          return test;
+        }
+      else if (!first_dirty && !(test & assigned_bits))
+        {
+          first_dirty = test;
+        }
+    }
+
+//  printf ("Cleaning bitplanes %x, assigned are %x\n", ~assigned_bits & dirty_bits, assigned_bits);
+
+  /* Didn't find any non dirty planes. Clear those dirty ones which aren't in use */
+  glPushAttrib (GL_STENCIL_BUFFER_BIT);
+  glStencilMask (~assigned_bits & dirty_bits);
+  glClearStencil (0);
+  glClear (GL_STENCIL_BUFFER_BIT);
+  glPopAttrib ();
+
+  assigned_bits |= first_dirty;
+  dirty_bits = assigned_bits;
+
+//  printf ("Assigning the first of the dirty bitplanes we just cleaned, %x\n", first_dirty);
+  return first_dirty;
+}
+
+void
+hidgl_return_stencil_bit (int bit)
+{
+  assigned_bits &= ~bit;
+}
+
+
 /* ---------------------------------------------------------------------- */
 
 #endif /* DISABLE EVERYTHING! */
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index ae7f68f..f0eb74e 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -1,10 +1,8 @@
-/* $Id: gui.h,v 1.25 2008-04-13 14:15:38 petercjclifton Exp $ */
-
 /*
  *                            COPYRIGHT
  *
  *  PCB, interactive printed circuit board design
- *  Copyright (C) 1994,1995,1996 Thomas Nau
+ *  Copyright (C) 2009 PCB Contributors (See ChangeLog for details).
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -68,5 +66,9 @@ void hidgl_fill_polygon (int n_coords, int *x, int *y);
 void hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale);
 void hidgl_fill_rect (int x1, int y1, int x2, int y2);
 
+void hidgl_init (void);
+int hidgl_stencil_bits (void);
+int hidgl_assign_clear_stencil_bit (void);
+void hidgl_return_stencil_bit (int bit);
 
 #endif /* __HIDGL_INCLUDED__  */
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 55387c9..517d2f4 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -572,17 +572,62 @@ ghid_invalidate_all ()
   gdk_window_invalidate_rect (gport->drawing_area->window, NULL, 1);
 }
 
+/* These calls should be matched as an ignore==1, ignore==0 pair!! */
+/* BUT.. we often call with ingore == 0 without having ignore==1'd */
+void hidgl_hack_ignore_stencil (int ignore)
+{
+  return 0;
+  static GLint ref = 0;
+  static GLuint mask = 0;
+  static int ignored = 0;
+
+  if (ignore)
+    {
+      hidgl_flush_triangles (&buffer);
+      ignored = 1;
+      glPushAttrib (GL_STENCIL_BUFFER_BIT);
+      glGetIntegerv (GL_STENCIL_REF, &ref);
+      glGetIntegerv (GL_STENCIL_VALUE_MASK, (GLint *)&mask);
+      glStencilFunc (GL_ALWAYS, ref, mask);
+    }
+  else if (ignored)
+    {
+      hidgl_flush_triangles (&buffer);
+      ignored = 0;
+      glPopAttrib ();
+//      glStencilFunc (GL_GREATER, ref, mask);
+    }
+}
 
 int
 ghid_set_layer (const char *name, int group, int empty)
 {
+  static int stencil_bit = 0;
   int idx = (group >= 0
 	     && group <
 	     max_layer) ? PCB->LayerGroups.Entries[group][0] : group;
 
-  /* Reset stencil buffer so we can paint anywhere */
+#define SUBCOMPOSITE_LAYERS
+#ifdef SUBCOMPOSITE_LAYERS
+  /* Flush out any existing geoemtry to be rendered */
   hidgl_flush_triangles (&buffer);
-  glClear (GL_STENCIL_BUFFER_BIT);
+
+  /* Reset stencil buffer so we can paint anywhere */
+  hidgl_return_stencil_bit (stencil_bit);               // Relinquish any bitplane we previously used
+  if (SL_TYPE (idx) != SL_FINISHED)
+    {
+      stencil_bit = hidgl_assign_clear_stencil_bit();       // Get a new (clean) bitplane to stencil with
+      glStencilFunc (GL_GREATER, stencil_bit, stencil_bit); // Pass stencil test if our assigned bit is clear
+      glStencilMask (stencil_bit);                          // Only write to our subcompositing stencil bitplane
+    }
+  else
+    {
+#endif
+      glStencilMask (0);
+      glStencilFunc (GL_ALWAYS, stencil_bit, stencil_bit);  // Always pass stencil test
+#ifdef SUBCOMPOSITE_LAYERS
+    }
+#endif
 
   if (idx >= 0 && idx < max_layer + 2) {
     gport->trans_lines = TRUE;
@@ -599,8 +644,8 @@ ghid_set_layer (const char *name, int group, int empty)
 	    return TEST_FLAG (SHOWMASKFLAG, PCB);
 	  return 0;
 	case SL_SILK:
-//          gport->trans_lines = TRUE;
-          gport->trans_lines = FALSE;
+          gport->trans_lines = TRUE;
+//          gport->trans_lines = FALSE;
 	  if (SL_MYSIDE (idx) /*|| pinout */ )
 	    return PCB->ElementOn;
 	  return 0;
@@ -620,9 +665,13 @@ ghid_set_layer (const char *name, int group, int empty)
 void
 ghid_use_mask (int use_it)
 {
+  static int stencil_bit = 0;
+
+#warning FIX THIS UP TO COOPORATE WITH HIDGL'S ASSIGNMENT OF STENCIL BITPLANES
   if (use_it == cur_mask)
     return;
 
+  /* Flush out any existing geoemtry to be rendered */
   hidgl_flush_triangles (&buffer);
 
   switch (use_it)
@@ -631,25 +680,28 @@ ghid_use_mask (int use_it)
       /* Write '1' to the stencil buffer where the solder-mask is drawn. */
       glColorMask (0, 0, 0, 0);                   // Disable writting in color buffer
       glEnable (GL_STENCIL_TEST);                 // Enable Stencil test
-      glStencilFunc (GL_ALWAYS, 1, 1);            // Test always passes, value written 1
+      stencil_bit = hidgl_assign_clear_stencil_bit();       // Get a new (clean) bitplane to stencil with
+      glStencilFunc (GL_ALWAYS, stencil_bit, stencil_bit);  // Always pass stencil test, write stencil_bit
+      glStencilMask (stencil_bit);                          // Only write to our subcompositing stencil bitplane
       glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value (with 1)
       break;
 
     case HID_MASK_CLEAR:
       /* Drawing operations clear the stencil buffer to '0' */
-      glStencilFunc (GL_ALWAYS, 0, 1);            // Test always passes, value written 0
+      glStencilFunc (GL_ALWAYS, 0, stencil_bit);  // Always pass stencil test, write 0
       glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value (with 0)
       break;
 
     case HID_MASK_AFTER:
       /* Drawing operations as masked to areas where the stencil buffer is '1' */
       glColorMask (1, 1, 1, 1);                   // Enable drawing of r, g, b & a
-      glStencilFunc (GL_EQUAL, 1, 1);             // Draw only where stencil buffer is 1
+      glStencilFunc (GL_LEQUAL, stencil_bit, stencil_bit);   // Draw only where our bit of the stencil buffer is set
       glStencilOp (GL_KEEP, GL_KEEP, GL_KEEP);    // Stencil buffer read only
       break;
 
     case HID_MASK_OFF:
       /* Disable stenciling */
+      hidgl_return_stencil_bit (stencil_bit);               // Relinquish any bitplane we previously used
       glDisable (GL_STENCIL_TEST);                // Disable Stencil test
       break;
     }
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index 8c60287..55e9e68 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -34,6 +34,7 @@
 
 #include "gui.h"
 #include "gtkhid.h"
+#include "hid/common/draw_helpers.h"
 
 #include <gdk/gdkkeysyms.h>
 
@@ -963,6 +964,17 @@ ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
     return FALSE;
   }
 
+  hidgl_init ();
+
+  /* If we don't have any stencil bits available,
+     we can't use the hidgl polygon drawing routine */
+  /* TODO: We could use the GLU tessellator though */
+  if (hidgl_stencil_bits() == 0)
+    {
+      ghid_hid.fill_pcb_polygon = common_fill_pcb_polygon;
+      ghid_hid.poly_dicer = 1;
+    }
+
   ghid_show_crosshair (FALSE);
 
   glEnable (GL_BLEND);
@@ -1065,10 +1077,9 @@ ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
 
   /* Setup stenciling */
   /* Drawing operations set the stencil buffer to '1' */
-//  glStencilFunc (GL_ALWAYS, 1, 1);            // Test always passes, value written 1
   glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value (with 1)
   /* Drawing operations as masked to areas where the stencil buffer is '0' */
-  glStencilFunc (GL_GREATER, 1, 1);             // Draw only where stencil buffer is 0
+//  glStencilFunc (GL_GREATER, 1, 1);             // Draw only where stencil buffer is 0
 
   glPushMatrix ();
   glScalef ((ghid_flip_x ? -1. : 1.) / gport->zoom,
diff --git a/src/hid/gtk/gui-top-window.c b/src/hid/gtk/gui-top-window.c
index a2d00b2..3027113 100644
--- a/src/hid/gtk/gui-top-window.c
+++ b/src/hid/gtk/gui-top-window.c
@@ -2669,6 +2669,7 @@ ghid_parse_arguments (int *argc, char ***argv)
   gport->zoom = 300.0;
   pixel_slop = 300;
 
+#ifdef ENABLE_GL
   /* setup GL-context */
   gport->glconfig = gdk_gl_config_new_by_mode (GDK_GL_MODE_RGBA    |
                                                GDK_GL_MODE_STENCIL |
@@ -2678,6 +2679,7 @@ ghid_parse_arguments (int *argc, char ***argv)
     printf("Could not setup GL-context!\n");
     return; /* Should we abort? */
   }
+#endif
 
   ghid_config_files_read (argc, argv);

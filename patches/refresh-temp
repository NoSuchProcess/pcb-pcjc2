Bottom: 31921232b0d82b5f226db8d8a14aea3ec61f850e
Top:    15f34361a5b49b19e8309bcf5e51f8aca57cfba9
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-06-11 00:21:18 +0100

Refresh of add-support-for-a-poured-objec-I

---

diff --git a/src/buffer.c b/src/buffer.c
index d5d1f06..6e7f128 100644
--- a/src/buffer.c
+++ b/src/buffer.c
@@ -389,6 +389,7 @@ MovePourToBuffer (LayerTypePtr Layer, PourTypePtr Pour)
 {
   LayerTypePtr lay;
   PourTypePtr pour;
+  Cardinal i;
 
   r_delete_entry (Layer->pour_tree, (BoxTypePtr) Pour);
   lay = &Dest->Layer[GetLayerNumber (Source, Layer)];
@@ -396,12 +397,14 @@ MovePourToBuffer (LayerTypePtr Layer, PourTypePtr Pour)
   *pour = *Pour;
   CLEAR_FLAG (FOUNDFLAG, pour);
   if (Pour != &Layer->Pour[--Layer->PourN])
-  {
-  *Pour = Layer->Pour[Layer->PourN];
-  r_substitute (Layer->pour_tree,
-		(BoxTypePtr) & Layer->Pour[Layer->PourN],
-		(BoxTypePtr) Pour);
-  }
+    {
+      *Pour = Layer->Pour[Layer->PourN];
+      r_substitute (Layer->pour_tree,
+                    (BoxTypePtr) & Layer->Pour[Layer->PourN],
+                    (BoxTypePtr) Pour);
+      for (i = 0; i < Pour->PolygonN; i++)
+        Pour->Polygons[i].ParentPour = Pour;
+    }
   memset (&Layer->Pour[Layer->PourN], 0, sizeof (PourType));
   if (!lay->pour_tree)
     lay->pour_tree = r_create_tree (NULL, 0, 0);
diff --git a/src/move.c b/src/move.c
index 162cccd..bf9670e 100644
--- a/src/move.c
+++ b/src/move.c
@@ -714,6 +714,7 @@ MovePourToLayerLowLevel (LayerTypePtr Source, PourTypePtr Pour,
 			    LayerTypePtr Destination)
 {
   PourTypePtr new = GetPourMemory (Destination);
+  Cardinal i;
 
   r_delete_entry (Source->pour_tree, (BoxType *) Pour);
   /* copy the data and remove it from the former layer */
@@ -722,6 +723,8 @@ MovePourToLayerLowLevel (LayerTypePtr Source, PourTypePtr Pour,
   r_substitute (Source->pour_tree,
 		(BoxType *) & Source->Pour[Source->PourN],
 		(BoxType *) Pour);
+  for (i = 0; i < Pour->PolygonN; i++)
+    Pour->Polygons[i].ParentPour = Pour;
   memset (&Source->Pour[Source->PourN], 0, sizeof (PourType));
   if (!Destination->pour_tree)
     Destination->pour_tree = r_create_tree (NULL, 0, 0);
diff --git a/src/pour.c b/src/pour.c
index afd7f41..a3efa93 100644
--- a/src/pour.c
+++ b/src/pour.c
@@ -987,7 +987,7 @@ original_pour_poly (PourType * p)
 
           hole++;
         }
-  }
+    }
   return np;
 }
 
@@ -1183,6 +1183,12 @@ InitPourClip (DataTypePtr Data, LayerTypePtr layer, PourType * pour)
       printf ("Clipping returned NULL - can that be good?\n");
       return 0;
     }
+  if (!pg->contours)
+    {
+      printf ("Clipping returned NULL contours - can that be good?\n");
+      printf ("Pour was %ld, %p\n", pour->ID, pour);
+      return 0;
+    }
 //  assert (poly_Valid (clipped));
   if (TEST_FLAG (CLEARPOLYFLAG, pour))
     {
@@ -1196,6 +1202,13 @@ InitPourClip (DataTypePtr Data, LayerTypePtr layer, PourType * pour)
       return 0;
     }
 
+  if (pg->contours == NULL)
+    {
+      printf ("Got pg->contours == NULL for some reason\n");
+      printf ("Pour was %ld, %p\n", pour->ID, pour);
+      return 0;
+    }
+
   count_all = count_added = 0;
   /* For each piece of the clipped up polygon, create a new child */
   start_pg = pg;
@@ -1409,12 +1422,12 @@ PolyToPoursOnLayer (DataType *Destination, LayerType *Layer,
         }
       while ((pline = pline->next) != NULL);
 
-      InitPourClip (Destination, Layer, Pour);
       SetPourBoundingBox (Pour);
       if (!Layer->pour_tree)
         Layer->pour_tree = r_create_tree (NULL, 0, 0);
       r_insert_entry (Layer->pour_tree, (BoxType *) Pour, 0);
 
+      InitPourClip (Destination, Layer, Pour);
       DrawPour (Layer, Pour, 0);
       /* add to undo list */
       AddObjectToCreateUndoList (POLYGON_TYPE, Layer, Pour, Pour);
diff --git a/src/remove.c b/src/remove.c
index a2d05cb..d124284 100644
--- a/src/remove.c
+++ b/src/remove.c
@@ -187,6 +187,8 @@ DestroyArc (LayerTypePtr Layer, ArcTypePtr Arc)
 static void *
 DestroyPour (LayerTypePtr Layer, PourTypePtr Pour)
 {
+  Cardinal i;
+
   r_delete_entry (Layer->pour_tree, (BoxTypePtr) Pour);
   FreePourMemory (Pour);
   if (Pour != &Layer->Pour[--Layer->PourN])
@@ -195,6 +197,8 @@ DestroyPour (LayerTypePtr Layer, PourTypePtr Pour)
       r_substitute (Layer->pour_tree,
                     (BoxType *) & Layer->Pour[Layer->PourN],
                     (BoxType *) Pour);
+      for (i = 0; i < Pour->PolygonN; i++)
+        Pour->Polygons[i].ParentPour = Pour;
     }
   memset (&Layer->Pour[Layer->PourN], 0, sizeof (PourType));
   return (NULL);
diff --git a/src/undo.c b/src/undo.c
index 70c8401..2dacee3 100644
--- a/src/undo.c
+++ b/src/undo.c
@@ -849,7 +849,7 @@ UndoSwapCopiedObject (UndoListTypePtr Entry)
 
   obj = MoveObjectToBuffer (PCB->Data, RemoveList, type, ptr1, ptr2, ptr3);
   if (Entry->Kind == POUR_TYPE)
-    InitPourClip (PCB->Data, ptr1b, (PolygonType *)obj);
+    InitPourClip (PCB->Data, ptr1b, (PourType *)obj);
   return (true);
 }

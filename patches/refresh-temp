Bottom: ccd437c470a77723448066db8597f6bb18eaabb3
Top:    9638597fde8ef091cc89dbef65125209ca23227f
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2014-06-07 18:25:53 +0100

Refresh of attempt-to-refactor-the-step

---

diff --git a/src/hid/gtk/object3d.c b/src/hid/gtk/object3d.c
index 66eace1..89b519b 100644
--- a/src/hid/gtk/object3d.c
+++ b/src/hid/gtk/object3d.c
@@ -296,6 +296,17 @@ get_contour_coord_n_in_mm (PLINE *contour, int n, double *x, double *y)
   *y = COORD_TO_MM (vertex->point[1]); /* FIXME: PCB's coordinate system has y increasing downwards */
 }
 
+static step_id_list
+presentation_style_assignments_from_appearance (step_file *step, appearance *appear)
+{
+  step_id colour = step_colour_rgb (step, "", appear->r, appear->g, appear->b);
+  step_id fill_area_style = step_fill_area_style (step, "", make_step_id_list (1, step_fill_area_style_colour (step, "", colour)));
+  step_id surface_side_style = step_surface_side_style (step, "", make_step_id_list (1, step_surface_style_fill_area (step, fill_area_style)));
+  step_id_list styles_list = make_step_id_list (1, step_surface_style_usage (step, "BOTH", surface_side_style));
+  step_id_list psa_list = make_step_id_list (1, step_presentation_style_assignment (step, styles_list));
+
+  return psa_list;
+}
 
 void
 object3d_export_to_step (object3d *object, char *filename)
@@ -310,7 +321,7 @@ object3d_export_to_step (object3d *object, char *filename)
   int pcb_shell_identifier;
   int brep_style_identifier;
   GList *styled_item_identifiers = NULL;
-  GList *styled_item_iter;
+  GList *shell_face_list = NULL;
   GList *face_iter;
   GList *edge_iter;
   GList *vertex_iter;
@@ -379,236 +390,162 @@ object3d_export_to_step (object3d *object, char *filename)
               "#17 =( NAMED_UNIT ( * ) SI_UNIT ( $, .STERADIAN. ) SOLID_ANGLE_UNIT ( ) );\n"
               "#18 =( GEOMETRIC_REPRESENTATION_CONTEXT ( 3 ) GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT ( ( #14 ) ) GLOBAL_UNIT_ASSIGNED_CONTEXT ( ( #15, #16, #17 ) ) REPRESENTATION_CONTEXT ( 'NONE', 'WORKASPACE' ) );\n");
   geometric_representation_context_identifier = 18;
-
-  /* Save a place for the advanced_brep_shape_representation identifier */
   step->next_id = 19;
-  shape_representation_identifier = step->next_id++;
-
-  fprintf (f, "#20 = SHAPE_DEFINITION_REPRESENTATION ( #9, #%i ) ;\n", shape_representation_identifier);
-
-  /* Save a place for the brep identifier */
-  step->next_id = 21;
-  brep_identifier = step->next_id++;
-
-  /* Body style */
-  fprintf (f, "#22 = COLOUR_RGB ( '', %f, %f, %f ) ;\n", object->appear->r, object->appear->g, object->appear->b);
-  fprintf (f, "#23 = FILL_AREA_STYLE_COLOUR ( '', #22 ) ;\n"
-              "#24 = FILL_AREA_STYLE ('', ( #23 ) ) ;\n"
-              "#25 = SURFACE_STYLE_FILL_AREA ( #24 ) ;\n"
-              "#26 = SURFACE_SIDE_STYLE ('', ( #25 ) ) ;\n"
-              "#27 = SURFACE_STYLE_USAGE ( .BOTH. , #26 ) ;\n"
-              "#28 = PRESENTATION_STYLE_ASSIGNMENT ( ( #27 ) ) ;\n");
-  fprintf (f, "#29 = STYLED_ITEM ( 'NONE', ( #28 ), #%i ) ;\n", brep_identifier);
-  brep_style_identifier = 29;
-  fprintf (f, "#30 = PRESENTATION_LAYER_ASSIGNMENT (  '1', 'Layer 1', ( #%i ) ) ;\n", brep_style_identifier);
-
-  step->next_id = 31;
-  styled_item_identifiers = g_list_append (styled_item_identifiers, GINT_TO_POINTER (brep_style_identifier));
 
 #define FWD 1
 #define REV 2
 #define ORIENTED_EDGE_IDENTIFIER(e) (((edge_info *)UNDIR_DATA (e))->edge_identifier + ((e & 2) ? REV : FWD))
 
   /* Define ininite planes corresponding to every planar face, and cylindrical surfaces for every cylindrical face */
+  for (face_iter = object->faces; face_iter != NULL; face_iter = g_list_next (face_iter)) {
+    face3d *face = face_iter->data;
 
-  for (face_iter = object->faces; face_iter != NULL; face_iter = g_list_next (face_iter))
-    {
-      face3d *face = face_iter->data;
-
-      if (face->is_cylindrical)
-        {
-          /* CYLINDRICAL SURFACE NORMAL POINTS OUTWARDS AWAY FROM ITS AXIS.
-           * face->surface_orientation_reversed NEEDS TO BE SET FOR HOLES IN THE SOLID
-           */
-          face->surface_identifier =
-            step_cylindrical_surface (step, "NONE",
-                                      step_axis2_placement_3d (step, "NONE",
-                                                               step_cartesian_point (step, "NONE", face->cx, face->cy, face->cz),
-                                                                     step_direction (step, "NONE", face->ax, face->ay, face->az),
-                                                                     step_direction (step, "NONE", face->nx, face->ny, face->nz)),
-                                      face->radius);
-        }
-      else
-        {
-          contour3d *outer_contour = face->contours->data;
-          edge_ref first_edge = outer_contour->first_edge;
-
-          float ox, oy, oz;
-          float nx, ny, nz;
-          float rx, ry, rz;
-
-          /* Define 0,0 of the face coordinate system to arbitraily correspond to the
-             origin vertex of the edge this contour links to in the quad edge structure.
-           */
-          ox = ((vertex3d *)ODATA (first_edge))->x;
-          oy = ((vertex3d *)ODATA (first_edge))->y;
-          oz = ((vertex3d *)ODATA (first_edge))->z;
-
-          nx = face->nx;
-          ny = face->ny;
-          nz = face->nz;
-
-          /* Define the reference x-axis of the face coordinate system to be along the
-             edge this contour links to in the quad edge data structure.
-           */
-
-          rx = ((vertex3d *)DDATA (first_edge))->x - ox;
-          ry = ((vertex3d *)DDATA (first_edge))->y - oy;
-          rz = ((vertex3d *)DDATA (first_edge))->z - oz;
-
-          face->surface_identifier =
-            step_plane (step, "NONE",
-                        step_axis2_placement_3d (step, "NONE",
-                                                 step_cartesian_point (step, "NONE", ox, oy, oz),   /* A point on the plane. Forms 0,0 of its parameterised coords. */
-                                                       step_direction (step, "NONE", nx, ny, nz),   /* An axis direction normal to the the face - Gives z-axis */
-                                                       step_direction (step, "NONE", rx, ry, rz))); /* Reference x-axis, orthogonal to z-axis above */
-        }
+    if (face->is_cylindrical) {
+      /* CYLINDRICAL SURFACE NORMAL POINTS OUTWARDS AWAY FROM ITS AXIS.
+       * face->surface_orientation_reversed NEEDS TO BE SET FOR HOLES IN THE SOLID
+       */
+      face->surface_identifier =
+        step_cylindrical_surface (step, "NONE",
+                                  step_axis2_placement_3d (step, "NONE",
+                                                           step_cartesian_point (step, "NONE", face->cx, face->cy, face->cz),
+                                                                 step_direction (step, "NONE", face->ax, face->ay, face->az),
+                                                                 step_direction (step, "NONE", face->nx, face->ny, face->nz)),
+                                  face->radius);
+    } else {
+      contour3d *outer_contour = face->contours->data;
+      vertex3d *ov = ODATA (outer_contour->first_edge);
+      vertex3d *dv = DDATA (outer_contour->first_edge);
+
+      face->surface_identifier =
+        step_plane (step, "NONE",
+                    step_axis2_placement_3d (step, "NONE",
+                                             step_cartesian_point (step, "NONE", ov->x,  /* A point on the plane. Defines 0,0 of the plane's parameterised coords. */ 
+                                                                                 ov->y,      /* Set this to the origin vertex of the first edge */
+                                                                                 ov->z),     /* this contour links to in the quad edge structure. */
+                                                   step_direction (step, "NONE", face->nx, face->ny, face->nz), /* An axis direction normal to the the face - Gives z-axis */
+                                                   step_direction (step, "NONE", dv->x - ov->x,     /* Reference x-axis, orthogonal to z-axis. */
+                                                                                 dv->y - ov->y,         /* Define this to be along the first edge this */
+                                                                                 dv->z - ov->z)));      /* contour links to in the quad edge structure */
     }
+  }
 
   /* Define the infinite lines corresponding to every edge (either lines or circles)*/
-  for (edge_iter = object->edges; edge_iter != NULL; edge_iter = g_list_next (edge_iter))
-    {
-      edge_ref edge = (edge_ref)edge_iter->data;
-      edge_info *info = UNDIR_DATA (edge);
-
-      if (info->is_round)
-        {
-          info->infinite_line_identifier =
-            step_circle (step, "NONE",
-                         step_axis2_placement_3d (step, "NONE",
-                                                  step_cartesian_point (step, "NONE", info->cx, info->cy, info->cz),  // <--- Center of the circle
-                                                        step_direction (step, "NONE", info->nx, info->ny, info->nz),  // <--- Normal of the circle
-                                                        step_direction (step, "NONE", -1.0,     0.0,      0.0)),      // <--- Approximate X-axis direction of placement /* XXX: PULL FROM FACE DATA */
-                                                        info->radius);
-        }
-      else
-        {
-          vertex3d *ov = ODATA (edge);
-          vertex3d *dv = DDATA (edge);
-
-          info->infinite_line_identifier =
-            step_line (step, "NONE",
-                       step_cartesian_point (step, "NONE", ov->x, ov->y, ov->z),  // <--- A point on the line (the origin vertex)
-                       step_vector (step, "NONE",
-                                    step_direction (step, "NONE", dv->x - ov->x,
-                                                                  dv->y - ov->y,
-                                                                  dv->z - ov->z),  // <--- Direction along the line
-                                    1000.0));     // <--- Arbitrary length in this direction for the parameterised coordinate "1".
-        }
+  for (edge_iter = object->edges; edge_iter != NULL; edge_iter = g_list_next (edge_iter)) {
+    edge_ref edge = (edge_ref)edge_iter->data;
+    edge_info *info = UNDIR_DATA (edge);
+
+    if (info->is_round) {
+      info->infinite_line_identifier =
+        step_circle (step, "NONE",
+                     step_axis2_placement_3d (step, "NONE",
+                                              step_cartesian_point (step, "NONE", info->cx, info->cy, info->cz),  // <--- Center of the circle
+                                                    step_direction (step, "NONE", info->nx, info->ny, info->nz),  // <--- Normal of the circle
+                                                    step_direction (step, "NONE", -1.0,     0.0,      0.0)),      // <--- Approximate X-axis direction of placement /* XXX: PULL FROM FACE DATA */
+                                                    info->radius);
+    } else {
+      vertex3d *ov = ODATA (edge);
+      vertex3d *dv = DDATA (edge);
+
+      info->infinite_line_identifier =
+        step_line (step, "NONE",
+                   step_cartesian_point (step, "NONE", ov->x, ov->y, ov->z),  // <--- A point on the line (the origin vertex)
+                   step_vector (step, "NONE",
+                                step_direction (step, "NONE", dv->x - ov->x,
+                                                              dv->y - ov->y,
+                                                              dv->z - ov->z),  // <--- Direction along the line
+                                1000.0));     // <--- Arbitrary length in this direction for the parameterised coordinate "1".
     }
+  }
 
   /* Define the vertices */
-  for (vertex_iter = object->vertices; vertex_iter != NULL; vertex_iter = g_list_next (vertex_iter))
-    {
-      vertex3d *vertex = vertex_iter->data;
+  for (vertex_iter = object->vertices; vertex_iter != NULL; vertex_iter = g_list_next (vertex_iter)) {
+    vertex3d *vertex = vertex_iter->data;
 
-      vertex->vertex_identifier = step_vertex_point (step, "NONE",
-                                                     step_cartesian_point (step, "NONE",
-                                                                           vertex->x, vertex->y, vertex->z));
-    }
+    vertex->vertex_identifier =
+      step_vertex_point (step, "NONE", step_cartesian_point (step, "NONE", vertex->x, vertex->y, vertex->z));
+  }
 
   /* Define the Edges */
-  for (edge_iter = object->edges; edge_iter != NULL; edge_iter = g_list_next (edge_iter))
-    {
-      edge_ref edge = (edge_ref)edge_iter->data;
-      edge_info *info = UNDIR_DATA (edge);
-      step_id sv = ((vertex3d *)ODATA (edge))->vertex_identifier;
-      step_id ev = ((vertex3d *)DDATA (edge))->vertex_identifier;
-
-      /* XXX: The lookup of these edges by adding to info->edge_identifier requires the step_* functions to assign sequential identifiers */
-      info->edge_identifier = step_edge_curve (step, "NONE", sv, ev, info->infinite_line_identifier, true);
-      step_oriented_edge (step, "NONE", info->edge_identifier, true);  /* Add 1 to info->edge_identifier to find this (same) oriented edge */
-      step_oriented_edge (step, "NONE", info->edge_identifier, false); /* Add 2 to info->edge_identifier to find this (back) oriented edge */
-    }
+  for (edge_iter = object->edges; edge_iter != NULL; edge_iter = g_list_next (edge_iter)) {
+    edge_ref edge = (edge_ref)edge_iter->data;
+    edge_info *info = UNDIR_DATA (edge);
+    step_id sv = ((vertex3d *)ODATA (edge))->vertex_identifier;
+    step_id ev = ((vertex3d *)DDATA (edge))->vertex_identifier;
+
+    /* XXX: The lookup of these edges by adding to info->edge_identifier requires the step_* functions to assign sequential identifiers */
+    info->edge_identifier = step_edge_curve (step, "NONE", sv, ev, info->infinite_line_identifier, true);
+    step_oriented_edge (step, "NONE", info->edge_identifier, true);  /* Add 1 to info->edge_identifier to find this (same) oriented edge */
+    step_oriented_edge (step, "NONE", info->edge_identifier, false); /* Add 2 to info->edge_identifier to find this (back) oriented edge */
+  }
 
   /* Define the faces */
-  for (face_iter = object->faces; face_iter != NULL; face_iter = g_list_next (face_iter))
-    {
-      face3d *face = face_iter->data;
-      bool outer_contour = true;
-
-      for (contour_iter = face->contours;
-           contour_iter != NULL;
-           contour_iter = g_list_next (contour_iter), outer_contour = false) {
-        contour3d *contour = contour_iter->data;
-        edge_ref edge;
-
-        fprintf (f, "#%i = EDGE_LOOP ( 'NONE', ", step->next_id);
-
-        /* Emit the edges.. */
-        fprintf (f, "(");
-        for (edge = contour->first_edge;
-             edge != LPREV (contour->first_edge);
-             edge = LNEXT (edge)) {
-          fprintf (f, "#%i, ", ORIENTED_EDGE_IDENTIFIER(edge)); /* XXX: IS ORIENTATION GOING TO BE CORRECT?? */
-        }
-        fprintf (f, "#%i)", ORIENTED_EDGE_IDENTIFIER(edge)); /* XXX: IS ORIENTATION GOING TO BE CORRECT?? */
-        fprintf (f, " ) ; ");
-
-        fprintf (f, "#%i = FACE_%sBOUND ( 'NONE', #%i, .T. ) ;\n", step->next_id + 1, outer_contour ? "OUTER_" : "", step->next_id);
-        contour->face_bound_identifier = step->next_id + 1;
-        step->next_id = step->next_id + 2;
-      }
+  for (face_iter = object->faces; face_iter != NULL; face_iter = g_list_next (face_iter)) {
+    face3d *face = face_iter->data;
+    bool outer_contour = true;
+    step_id_list face_contour_list = NULL;
+
+    for (contour_iter = face->contours;
+         contour_iter != NULL;
+         contour_iter = g_list_next (contour_iter), outer_contour = false) {
+      contour3d *contour = contour_iter->data;
+      edge_ref edge;
 
-      fprintf (f, "#%i = ADVANCED_FACE ( 'NONE', ", step->next_id);
+      fprintf (f, "#%i = EDGE_LOOP ( 'NONE', ", step->next_id);
+
+      /* Emit the edges.. */
       fprintf (f, "(");
-      for (contour_iter = face->contours;
-           contour_iter != NULL && g_list_next (contour_iter) != NULL;
-           contour_iter = g_list_next (contour_iter)) {
-        fprintf (f, "#%i, ", ((contour3d *)contour_iter->data)->face_bound_identifier);
-      }
-      fprintf (f, "#%i)", ((contour3d *)contour_iter->data)->face_bound_identifier);
-      fprintf (f, ", #%i, %s ) ;\n", face->surface_identifier, face->surface_orientation_reversed ? ".F." : ".T.");
-      face->face_identifier = step->next_id;
-      step->next_id = step->next_id + 1;
-
-      if (face->appear != NULL) {
-        /* Face styles */
-        fprintf (f, "#%i = COLOUR_RGB ( '', %f, %f, %f ) ;\n",             step->next_id, face->appear->r, face->appear->g, face->appear->b);
-        fprintf (f, "#%i = FILL_AREA_STYLE_COLOUR ( '', #%i ) ;\n",        step->next_id + 1, step->next_id);
-        fprintf (f, "#%i = FILL_AREA_STYLE ('', ( #%i ) ) ;\n",            step->next_id + 2, step->next_id + 1);
-        fprintf (f, "#%i = SURFACE_STYLE_FILL_AREA ( #%i ) ;\n",           step->next_id + 3, step->next_id + 2);
-        fprintf (f, "#%i = SURFACE_SIDE_STYLE ('', ( #%i ) ) ;\n",         step->next_id + 4, step->next_id + 3);
-        fprintf (f, "#%i = SURFACE_STYLE_USAGE ( .BOTH. , #%i ) ;\n",      step->next_id + 5, step->next_id + 4);
-        fprintf (f, "#%i = PRESENTATION_STYLE_ASSIGNMENT ( ( #%i ) ) ;\n", step->next_id + 6, step->next_id + 5);
-        fprintf (f, "#%i = OVER_RIDING_STYLED_ITEM ( 'NONE', ( #%i ), #%i, #%i ) ;\n",
-                 step->next_id + 7, step->next_id + 6, face->face_identifier, brep_style_identifier);
-        styled_item_identifiers = g_list_append (styled_item_identifiers, GINT_TO_POINTER (step->next_id + 7));
-        step->next_id = step->next_id + 8;
+      for (edge = contour->first_edge;
+           edge != LPREV (contour->first_edge);
+           edge = LNEXT (edge)) {
+        fprintf (f, "#%i, ", ORIENTED_EDGE_IDENTIFIER(edge));
       }
+      fprintf (f, "#%i)", ORIENTED_EDGE_IDENTIFIER(edge));
+      fprintf (f, " ) ; ");
+
+      fprintf (f, "#%i = FACE_%sBOUND ( 'NONE', #%i, .T. ) ;\n", step->next_id + 1, outer_contour ? "OUTER_" : "", step->next_id);
+      contour->face_bound_identifier = step->next_id + 1;
+      step->next_id = step->next_id + 2;
+
+      face_contour_list = g_list_append (face_contour_list, GINT_TO_POINTER (contour->face_bound_identifier));
     }
 
+    face->face_identifier = step_advanced_face (step, "NONE", face_contour_list, face->surface_identifier, !face->surface_orientation_reversed);
+    shell_face_list = g_list_append (shell_face_list, GINT_TO_POINTER (face->face_identifier));
+  }
+
   /* Closed shell which bounds the brep solid */
-  pcb_shell_identifier = step->next_id;
-  step->next_id++;
-  fprintf (f, "#%i = CLOSED_SHELL ( 'NONE', ", pcb_shell_identifier);
-  /* Emit the faces.. */
-  fprintf (f, "(");
-  for (face_iter = object->faces;
-       face_iter != NULL && g_list_next (face_iter) != NULL;
-       face_iter = g_list_next (face_iter)) {
-    fprintf (f, "#%i, ", ((face3d *)face_iter->data)->face_identifier);
+  pcb_shell_identifier = step_closed_shell (step, "NONE", shell_face_list);
+  brep_identifier = step_manifold_solid_brep (step, "PCB outline", pcb_shell_identifier);
+
+  /* Body style */
+  if (1) {
+    /* XXX: THERE MUST BE A BODY STYLE, CERTAINLY IF WE WANT TO OVER RIDE FACE COLOURS */
+    brep_style_identifier = step_styled_item (step, "NONE", presentation_style_assignments_from_appearance (step, object->appear), brep_identifier);
+    step_presentation_layer_assignment (step, "1", "Layer 1", make_step_id_list (1, brep_style_identifier));
+
+    styled_item_identifiers = g_list_append (styled_item_identifiers, GINT_TO_POINTER (brep_style_identifier));
   }
-  fprintf (f, "#%i)", ((face3d *)face_iter->data)->face_identifier);
-  fprintf (f, " ) ;\n");
 
-  /* Finally emit the brep solid definition */
-  fprintf (f, "#%i = MANIFOLD_SOLID_BREP ( 'PCB outline', #%i ) ;\n", brep_identifier, pcb_shell_identifier);
+  /* Face styles */
+  for (face_iter = object->faces; face_iter != NULL; face_iter = g_list_next (face_iter)) {
+    face3d *face = face_iter->data;
 
-  /* Emit references to the styled and over_ridden styled items */
-  fprintf (f, "#%i = MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION (  '', ", step->next_id);
-  fprintf (f, "(");
-  for (styled_item_iter = styled_item_identifiers;
-       styled_item_iter != NULL && g_list_next (styled_item_iter) != NULL;
-       styled_item_iter = g_list_next (styled_item_iter)) {
-    fprintf (f, "#%i, ", GPOINTER_TO_INT (styled_item_iter->data));
+    if (face->appear != NULL) {
+      step_id orsi = step_over_riding_styled_item (step, "NONE",
+                                                   presentation_style_assignments_from_appearance (step, face->appear),
+                                                   face->face_identifier, brep_style_identifier);
+      styled_item_identifiers = g_list_append (styled_item_identifiers, GINT_TO_POINTER (orsi));
+    }
   }
-  fprintf (f, "#%i)", GPOINTER_TO_INT (styled_item_iter->data));
-  fprintf (f, ", #%i ) ;\n", geometric_representation_context_identifier);
-  step->next_id = step->next_id + 1;
 
-  fprintf (f, "#%i = ADVANCED_BREP_SHAPE_REPRESENTATION ( '%s', ( #%i, #13 ), #%i ) ;\n",
-           shape_representation_identifier, "test_pcb_absr_name", brep_identifier, geometric_representation_context_identifier);
+  /* Emit references to the styled and over_ridden styled items */
+  step_mechanical_design_geometric_presentation_representation (step, "", styled_item_identifiers, geometric_representation_context_identifier);
+
+  shape_representation_identifier =
+    step_advanced_brep_shape_representation (step, "test_pcb_absr_name",
+                                             make_step_id_list (2, brep_identifier, 13 /* XXX */), geometric_representation_context_identifier);
+
+  step_shape_definition_representation (step, 9 /* XXX */, shape_representation_identifier);
 
 #undef ORIENTED_EDGE_IDENTIFIER
 #undef FWD
diff --git a/src/hid/gtk/step.c b/src/hid/gtk/step.c
index 3e4dfaa..dfb1deb 100644
--- a/src/hid/gtk/step.c
+++ b/src/hid/gtk/step.c
@@ -1,6 +1,7 @@
 #include <glib.h>
 #include <stdbool.h>
 #include <stdio.h>
+#include <stdarg.h>
 
 #include "step.h"
 
@@ -10,6 +11,46 @@ step_bool (bool expr)
   return expr ? ".T." : ".F.";
 }
 
+static void
+fprint_id_list (FILE *f, step_id_list list)
+{
+  GList *iter;
+
+  fprintf (f, "( ");
+  for (iter = list;
+       iter != NULL && g_list_next (iter) != NULL;
+       iter = g_list_next (iter)) {
+    fprintf (f, "#%i, ", GPOINTER_TO_INT (iter->data));
+  }
+  fprintf (f, "#%i )", GPOINTER_TO_INT (iter->data));
+}
+
+static void
+destroy_step_id_list (step_id_list list)
+{
+  g_list_free (list);
+}
+
+/* NB: The GList this produces will leak if not passed back to one of the step_* functions which uses the list and destroys it */
+step_id_list
+make_step_id_list (int count, ...)
+{
+  step_id_list list = NULL;
+  va_list args;
+  int i;
+
+  va_start (args, NULL);
+
+  for (i = 0; i < count; i++) {
+    step_id id = va_arg (args, step_id);
+    list = g_list_append (list, GINT_TO_POINTER (id));
+  }
+
+  va_end (args);
+
+  return list;
+}
+
 step_file
 *step_output_file (FILE *f)
 {
@@ -47,7 +88,7 @@ step_direction (step_file *file, char *name, double x, double y, double z)
 step_id
 step_axis2_placement_3d (step_file *file, char *name, step_id location, step_id axis, step_id ref_direction)
 {
-  fprintf (file->f, "#%i = AXIS2_PLACEMENT_3D ( '%s', ( #%i, #%i, #%i ) ) ;\n",
+  fprintf (file->f, "#%i = AXIS2_PLACEMENT_3D ( '%s', #%i, #%i, #%i ) ;\n",
                     file->next_id, name, location, axis, ref_direction);
   return file->next_id++;
 }
@@ -87,7 +128,7 @@ step_vector (step_file *file, char *name, step_id orientation, double magnitude)
 step_id
 step_line (step_file *file, char *name, step_id pnt, step_id dir)
 {
-  fprintf (file->f, "#%i = LINE ( '%s', #%i, %i ) ;\n",
+  fprintf (file->f, "#%i = LINE ( '%s', #%i, #%i ) ;\n",
                     file->next_id, name, pnt, dir);
   return file->next_id++;
 }
@@ -115,3 +156,194 @@ step_oriented_edge (step_file *file, char *name, step_id edge_element, bool orie
                     file->next_id, name, edge_element, step_bool (orientation));
   return file->next_id++;
 }
+
+step_id
+step_edge_loop (step_file *file, char *name, step_id_list edge_list)
+{
+  fprintf (file->f, "#%i = EDGE_LOOP ( '%s', ", file->next_id, name);
+  fprint_id_list (file->f, edge_list);
+  fprintf (file->f, " ) ; ");
+  destroy_step_id_list (edge_list);
+
+  return file->next_id++;
+}
+
+step_id
+step_face_bound (step_file *file, char *name, step_id bound, bool orientation)
+{
+  fprintf (file->f, "#%i = FACE_BOUND ( '%s', #%i, %s ) ;\n",
+                    file->next_id, name, bound, step_bool (orientation));
+
+  return file->next_id++;
+}
+
+step_id
+step_face_outer_bound (step_file *file, char *name, step_id bound, bool orientation)
+{
+  fprintf (file->f, "#%i = FACE_BOUND ( '%s', #%i, %s ) ;\n",
+                    file->next_id, name, bound, step_bool (orientation));
+
+  return file->next_id++;
+}
+
+step_id
+step_advanced_face (step_file *file, char *name, step_id_list bounds, step_id face_geometry, bool same_sense)
+{
+  fprintf (file->f, "#%i = ADVANCED_FACE ( '%s', ", file->next_id, name);
+  fprint_id_list (file->f, bounds);
+  fprintf (file->f, ", #%i, %s ) ; ", face_geometry, step_bool (same_sense));
+  destroy_step_id_list (bounds);
+
+  return file->next_id++;
+}
+
+step_id
+step_closed_shell (step_file *file, char *name, step_id_list cfs_faces)
+{
+  fprintf (file->f, "#%i = CLOSED_SHELL ( '%s', ", file->next_id, name);
+  fprint_id_list (file->f, cfs_faces);
+  fprintf (file->f, " ) ;\n");
+  destroy_step_id_list (cfs_faces);
+
+  return file->next_id++;
+}
+
+step_id
+step_manifold_solid_brep (step_file *file, char *name, step_id outer)
+{
+  fprintf (file->f, "#%i = MANIFOLD_SOLID_BREP ( '%s', #%i ) ;\n", file->next_id, name, outer);
+
+  return file->next_id++;
+}
+
+step_id
+step_advanced_brep_shape_representation (step_file *file, char *name, step_id_list items, step_id context_of_items)
+{
+  fprintf (file->f, "#%i = ADVANCED_BREP_SHAPE_REPRESENTATION ( '%s', ", file->next_id, name);
+  fprint_id_list (file->f, items);
+  fprintf (file->f, ", #%i ) ;\n", context_of_items);
+  destroy_step_id_list (items);
+
+  return file->next_id++;
+}
+
+step_id
+step_shape_definition_representation (step_file *file, step_id definition, step_id used_representation)
+{
+  fprintf (file->f, "#%i = SHAPE_DEFINITION_REPRESENTATION ( #%i, #%i ) ;\n", file->next_id, definition, used_representation);
+
+  return file->next_id++;
+}
+
+step_id
+step_colour_rgb (step_file *file, char *name, double red, double green, double blue)
+{
+  fprintf (file->f, "#%i = COLOUR_RGB ( '%s', %f, %f, %f ) ;\n",
+                    file->next_id, name, red, green, blue);
+  return file->next_id++;
+}
+
+step_id
+step_fill_area_style_colour (step_file *file, char *name, step_id fill_colour)
+{
+  fprintf (file->f, "#%i = FILL_AREA_STYLE_COLOUR ( '%s', #%i ) ;\n",
+                    file->next_id, name, fill_colour);
+
+  return file->next_id++;
+}
+
+step_id
+step_fill_area_style (step_file *file, char *name, step_id_list fill_styles)
+{
+  fprintf (file->f, "#%i = FILL_AREA_STYLE ('%s', ", file->next_id, name);
+  fprint_id_list (file->f, fill_styles);
+  fprintf (file->f, " ) ;\n");
+  destroy_step_id_list (fill_styles);
+
+  return file->next_id++;
+}
+
+step_id
+step_surface_style_fill_area (step_file *file, step_id fill_area)
+{
+  fprintf (file->f, "#%i = SURFACE_STYLE_FILL_AREA ( #%i ) ;\n",
+                    file->next_id, fill_area);
+
+  return file->next_id++;
+}
+
+step_id
+step_surface_side_style (step_file *file, char *name, step_id_list styles)
+{
+  fprintf (file->f, "#%i = SURFACE_SIDE_STYLE ('%s', ", file->next_id, name);
+  fprint_id_list (file->f, styles);
+  fprintf (file->f, " ) ;\n");
+  destroy_step_id_list (styles);
+
+  return file->next_id++;
+}
+
+/* XXX: surface_side should be an enum ".POSITIVE.", ".NEGATIVE." or ".BOTH." */
+step_id
+step_surface_style_usage (step_file *file, char *surface_side, step_id style)
+{
+  fprintf (file->f, "#%i = SURFACE_STYLE_USAGE ( .%s. , #%i ) ;\n",
+                    file->next_id, surface_side, style);
+
+  return file->next_id++;
+}
+
+step_id
+step_presentation_style_assignment (step_file *file, step_id_list styles)
+{
+  fprintf (file->f, "#%i = PRESENTATION_STYLE_ASSIGNMENT ( ", file->next_id);
+  fprint_id_list (file->f, styles);
+  fprintf (file->f, " ) ;\n");
+  destroy_step_id_list (styles);
+
+  return file->next_id++;
+}
+
+step_id
+step_styled_item (step_file *file, char *name, step_id_list styles, step_id item)
+{
+  fprintf (file->f, "#%i = STYLED_ITEM ( '%s', ", file->next_id, name);
+  fprint_id_list (file->f, styles);
+  fprintf (file->f, ", #%i ) ;\n", item);
+  destroy_step_id_list (styles);
+
+  return file->next_id++;
+}
+
+step_id
+step_over_riding_styled_item (step_file *file, char *name, step_id_list styles, step_id item, step_id over_ridden_style)
+{
+  fprintf (file->f, "#%i = OVER_RIDING_STYLED_ITEM ( '%s', ", file->next_id, name);
+  fprint_id_list (file->f, styles);
+  fprintf (file->f, ", #%i, #%i ) ;\n", item, over_ridden_style);
+  destroy_step_id_list (styles);
+
+  return file->next_id++;
+}
+
+step_id
+step_presentation_layer_assignment (step_file *file, char *name, char *description, step_id_list assigned_items)
+{
+  fprintf (file->f, "#%i = PRESENTATION_LAYER_ASSIGNMENT ( '%s', '%s', ", file->next_id, name, description);
+  fprint_id_list (file->f, assigned_items);
+  fprintf (file->f, " ) ;\n");
+  destroy_step_id_list (assigned_items);
+
+  return file->next_id++;
+}
+
+step_id
+step_mechanical_design_geometric_presentation_representation (step_file *file, char *name, step_id_list items, step_id context_of_items)
+{
+  fprintf (file->f, "#%i = MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION (  '%s', ", file->next_id, name);
+  fprint_id_list (file->f, items);
+  fprintf (file->f, ", #%i ) ;\n", context_of_items);
+  destroy_step_id_list (items);
+
+  return file->next_id++;
+}
diff --git a/src/hid/gtk/step.h b/src/hid/gtk/step.h
index ce4c096..2a5cbc3 100644
--- a/src/hid/gtk/step.h
+++ b/src/hid/gtk/step.h
@@ -1,11 +1,15 @@
 typedef int step_id;
 
+typedef GList* step_id_list;
+
 typedef struct {
   FILE *f;
   step_id next_id;
 
 } step_file;
 
+step_id_list make_step_id_list (int count, ...);
+
 step_file *step_output_file (FILE *f);
 void destroy_step_output_file (step_file *file);
 
@@ -20,3 +24,23 @@ step_id step_line (step_file *file, char *name, step_id pnt, step_id dir);
 step_id step_vertex_point (step_file *file, char *name, step_id pnt);
 step_id step_edge_curve (step_file *file, char *name, step_id edge_start, step_id edge_end, step_id edge_geometry, bool same_sense);
 step_id step_oriented_edge (step_file *file, char *name, step_id edge_element, bool orientation);
+step_id step_edge_loop (step_file *file, char *name, step_id_list edge_list);
+step_id step_face_bound (step_file *file, char *name, step_id bound, bool orientation);
+step_id step_face_outer_bound (step_file *file, char *name, step_id bound, bool orientation);
+step_id step_advanced_face (step_file *file, char *name, step_id_list bounds, step_id face_geometry, bool same_sense);
+step_id step_closed_shell (step_file *file, char *name, step_id_list cfs_faces);
+step_id step_manifold_solid_brep (step_file *file, char *name, step_id outer);
+step_id step_advanced_brep_shape_representation (step_file *file, char *name, step_id_list items, step_id context_of_items);
+step_id step_shape_definition_representation (step_file *file, step_id definition, step_id used_representation);
+
+step_id step_colour_rgb (step_file *file, char *name, double red, double green, double blue);
+step_id step_fill_area_style_colour (step_file *file, char *name, step_id fill_colour);
+step_id step_fill_area_style (step_file *file, char *name, step_id_list fill_styles);
+step_id step_surface_style_fill_area (step_file *file, step_id fill_area);
+step_id step_surface_side_style (step_file *file, char *name, step_id_list styles);
+step_id step_surface_style_usage (step_file *file, char *surface_side, step_id style); /* XXX: surface_side should be an enum "POSITIVE, NEGATIVE or BOTH" */
+step_id step_presentation_style_assignment (step_file *file, step_id_list styles);
+step_id step_styled_item (step_file *file, char *name, step_id_list styles, step_id item);
+step_id step_over_riding_styled_item (step_file *file, char *name, step_id_list styles, step_id item, step_id over_ridden_style);
+step_id step_presentation_layer_assignment (step_file *file, char *name, char *description, step_id_list assigned_items);
+step_id step_mechanical_design_geometric_presentation_representation (step_file *file, char *name, step_id_list items, step_id context_of_items);
diff --git a/src/hid/gtk/vertex3d.c b/src/hid/gtk/vertex3d.c
index 8abe19f..8e584ab 100644
--- a/src/hid/gtk/vertex3d.c
+++ b/src/hid/gtk/vertex3d.c
@@ -1,3 +1,4 @@
+#include <glib.h>
 #include <stdlib.h>
 #include <stdbool.h>
 #include <stdio.h>

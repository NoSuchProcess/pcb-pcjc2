Bottom: 493062a453bfbb6662f1cd280a6bebf092c4ead4
Top:    4d3154c078bf804ba2a56c0a9edb52c190a9e7d2
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-11-26 02:38:52 +0000

Refresh of avoid-re-starting-the-intersec-I

---

diff --git a/src/polygon1.c b/src/polygon1.c
index 6333474..3ca4d00 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -46,8 +46,6 @@
 #include	<math.h>
 #include	<string.h>
 
-#include <glib.h>
-
 #include "global.h"
 #include "rtree.h"
 #include "heap.h"
@@ -500,12 +498,14 @@ typedef struct seg
   int intersected;
 } seg;
 
-typedef struct insert_task
+typedef struct _insert_node_task insert_node_task;
+
+struct _insert_node_task
 {
-  VNODE *new_node;
+  insert_node_task *next;
   seg *seg;
-
-} insert_task;
+  VNODE *new_node;
+};
 
 typedef struct info
 {
@@ -515,7 +515,7 @@ typedef struct info
   struct seg *s;
   jmp_buf *env, sego, *touch;
   int need_restart;
-  GList *node_insert_list;
+  insert_node_task *node_insert_list;
 } info;
 
 typedef struct contour_info
@@ -524,7 +524,7 @@ typedef struct contour_info
   jmp_buf restart;
   jmp_buf *getout;
   int need_restart;
-  GList *node_insert_list;
+  insert_node_task *node_insert_list;
 } contour_info;
 
 
@@ -587,6 +587,17 @@ seg_in_region (const BoxType * b, void *cl)
   return 1;			/* might intersect */
 }
 
+/* Prepend a deferred node-insersion task to a list */
+static insert_node_task *
+prepend_insert_node_task (insert_node_task *list, seg *seg, VNODE *new_node)
+{
+  insert_node_task *task = malloc (sizeof (*task));
+  task->seg = seg;
+  task->new_node = new_node;
+  task->next = list;
+  return task;
+}
+
 /*
  * seg_in_seg()
  * (C) 2006 harry eaton
@@ -627,26 +638,27 @@ seg_in_seg (const BoxType * b, void *cl)
       new_node = node_add_single_point (i->v, cnt > 1 ? s2 : s1);
       if (new_node != NULL)
 	{
-	  insert_task *task = g_new0 (insert_task, 1);
-	  task->new_node = new_node;
-	  task->seg = i->s;
-	  task->seg->intersected = 1;
-	  i->node_insert_list = g_list_prepend (i->node_insert_list, task);
+	  i->node_insert_list =
+	    prepend_insert_node_task (i->node_insert_list, i->s, new_node);
+	  i->s->intersected = 1;
 	  done_insert = 1;
 	}
       new_node = node_add_single_point (s->v, cnt > 1 ? s2 : s1);
       if (new_node != NULL)
 	{
-	  insert_task *task = g_new0 (insert_task, 1);
-	  task->new_node = new_node;
-	  task->seg = s;
-	  task->seg->intersected = 1;
-	  i->node_insert_list = g_list_prepend (i->node_insert_list, task);
+	  i->node_insert_list =
+	    prepend_insert_node_task (i->node_insert_list, s, new_node);
+	  s->intersected = 1;
 	  return 0;		/* Don't do any more processing */
 	}
       if (done_insert)
 	{
 	  longjmp (*i->env, 1);	/* Skip this contour if we intersected on i */
+	  /* XXX: CODE BELOW NOT REACHED!!
+	   *      Why did I add these following two lines?
+	   *      Is it a piece of dead code left over from a point when I
+	   *      tried _not_ skipping the contour?
+	   */
 	  i->need_restart = 1;	/* If we skip some processing, we definately need a restart */
 	  return 0;
 	}
@@ -805,24 +817,6 @@ contour_bounds_touch (const BoxType * b, void *cl)
   return 0;
 }
 
-static void
-insert_new_nodes_cb (gpointer data, gpointer userdata)
-{
-  insert_task *task = data;
-
-  /* Do insersion */
-  task->new_node->prev = task->seg->v;
-  task->new_node->next = task->seg->v->next;
-  task->seg->v->next->prev = task->new_node;
-  task->seg->v->next = task->new_node;
-  task->seg->p->Count++;
-
-  cntrbox_adjust (task->seg->p, task->new_node->point);
-  if (adjust_tree (task->seg->p->tree, task->seg))
-    assert (0); /* XXX: Memory allocation failure */
-  g_free (task);
-}
-
 static int
 intersect_impl (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
 {
@@ -830,6 +824,7 @@ intersect_impl (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
   PLINE *pa;
   contour_info c_info;
   int need_restart = 0;
+  insert_node_task *task;
   c_info.need_restart = 0;
   c_info.node_insert_list = NULL;
 
@@ -874,10 +869,28 @@ intersect_impl (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
 	need_restart = 1;
     }
 
-  if (c_info.node_insert_list != NULL)
-    need_restart = 1; /* Any new nodes could intersect */
-  g_list_foreach (c_info.node_insert_list, insert_new_nodes_cb, NULL);
-  g_list_free (c_info.node_insert_list);
+  /* Process any deferred node insersions */
+  task = c_info.node_insert_list;
+  while (task != NULL)
+    {
+      insert_node_task *next = task->next;
+
+      /* Do insersion */
+      task->new_node->prev = task->seg->v;
+      task->new_node->next = task->seg->v->next;
+      task->seg->v->next->prev = task->new_node;
+      task->seg->v->next = task->new_node;
+      task->seg->p->Count++;
+
+      cntrbox_adjust (task->seg->p, task->new_node->point);
+      if (adjust_tree (task->seg->p->tree, task->seg))
+	assert (0); /* XXX: Memory allocation failure */
+
+      need_restart = 1; /* Any new nodes could intersect */
+
+      free (task);
+      task = next;
+    }
 
   return need_restart;
 }

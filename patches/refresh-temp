Bottom: 29e6c91934b987e39fd6e5d08d544eaaad65f21f
Top:    e40feebab113552a97485b3c40be2ce8acf3c1bd
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2012-11-15 01:01:47 +0000

Refresh of hid-gtk-move-viewport-view-dat

---

diff --git a/src/gpcb-menu.res.in b/src/gpcb-menu.res.in
index f28edff..6cf7f19 100644
--- a/src/gpcb-menu.res.in
+++ b/src/gpcb-menu.res.in
@@ -172,8 +172,8 @@ MainMenu =
     {"Zoom to 10mil/px" Zoom(=10mil)}
     {"Zoom In 20% and center" Zoom(-1.2) Center() m=Z }
     {"Zoom Out 20% and center" Zoom(+1.2) Center() m=O }
-    {"Flip up/down" checked=flip_y SwapSides(V) a={"Tab" "<Key>Tab"}}
-    {"Flip left/right" checked=flip_x SwapSides(H) a={"Shift-Tab" "Shift<Key>Tab"}}
+    {"Flip up/down" SwapSides(V) a={"Tab" "<Key>Tab"}}
+    {"Flip left/right" SwapSides(H) a={"Shift-Tab" "Shift<Key>Tab"}}
     {"Spin 180 degrees" SwapSides(R) a={"Ctrl-Tab" "Ctrl<Key>Tab"}}
     {"Swap Sides" SwapSides() a={"Ctrl-Shift-Tab" "Ctrl Shift<Key>Tab"}}
     {"Center cursor" Center() a={"C" "<Key>c"}}
diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index 507ad16..ea43664 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -20,9 +20,30 @@ extern HID ghid_hid;
 */
 #define USE_GC(gc) if (!use_gc(gc)) return
 
+#define SIDE_X(x)   ((priv->view.flip_x ? PCB->MaxWidth  - (x) : (x)))
+#define SIDE_Y(y)   ((priv->view.flip_y ? PCB->MaxHeight - (y) : (y)))
+
+#define DRAW_X(x)         (int)((SIDE_X(x) - priv->view.x0) / priv->view.coord_per_px)
+#define DRAW_Y(y)         (int)((SIDE_Y(y) - priv->view.y0) / priv->view.coord_per_px)
+
+#define EVENT_TO_PCB_X(x) SIDE_X((int)((x) * priv->view.coord_per_px + priv->view.x0))
+#define EVENT_TO_PCB_Y(y) SIDE_Y((int)((y) * priv->view.coord_per_px + priv->view.y0))
+
 static enum mask_mode cur_mask = HID_MASK_OFF;
 static int mask_seq = 0;
 
+typedef struct view_data {
+  double coord_per_px;
+
+  Coord x0;
+  Coord y0;
+  Coord width;
+  Coord height;
+
+  bool flip_x;
+  bool flip_y;
+} view_data;
+
 typedef struct render_priv {
   GdkGC *bg_gc;
   GdkGC *offlimits_gc;
@@ -33,6 +54,7 @@ typedef struct render_priv {
   GdkRectangle clip_rect;
   int attached_invalidate_depth;
   int mark_invalidate_depth;
+  view_data view;
 
   /* Feature for leading the user to a particular location */
   guint lead_user_timeout;
@@ -58,6 +80,58 @@ typedef struct hid_gc_struct
 }
 hid_gc_struct;
 
+/* Px converts view->pcb, Vx converts pcb->view */
+static inline int
+Vx (Coord x)
+{
+  render_priv *priv = gport->render_priv;
+
+  if (priv->view.flip_x)
+    return (PCB->MaxWidth - x - priv->view.x0) / priv->view.coord_per_px + 0.5;
+  else
+    return (x - priv->view.x0) / priv->view.coord_per_px + 0.5;
+}
+
+static inline int
+Vy (Coord y)
+{
+  render_priv *priv = gport->render_priv;
+
+  if (priv->view.flip_y)
+    return (PCB->MaxHeight - y - priv->view.y0) / priv->view.coord_per_px + 0.5;
+  else
+    return (y - priv->view.y0) / priv->view.coord_per_px + 0.5;
+}
+
+static inline int
+Vz (Coord z)
+{
+  render_priv *priv = gport->render_priv;
+
+  return z / priv->view.coord_per_px + 0.5;
+}
+
+static inline Coord
+Px (int x)
+{
+  render_priv *priv = gport->render_priv;
+
+  Coord rv = x * priv->view.coord_per_px + priv->view.x0;
+  if (priv->view.flip_x)
+    rv = PCB->MaxWidth - (x * priv->view.coord_per_px + priv->view.x0);
+  return  rv;
+}
+
+static inline Coord
+Py (int y)
+{
+  render_priv *priv = gport->render_priv;
+  Coord rv = y * priv->view.coord_per_px + priv->view.y0;
+
+  if (priv->view.flip_y)
+    rv = PCB->MaxHeight - (y * priv->view.coord_per_px + priv->view.y0);
+  return  rv;
+}
 
 static void draw_lead_user (render_priv *priv);
 
@@ -166,11 +240,11 @@ ghid_draw_grid (void)
       gdk_gc_set_clip_origin (priv->grid_gc, 0, 0);
       set_clip (priv, priv->grid_gc);
     }
-  x1 = GridFit (SIDE_X (gport->view.x0), PCB->Grid, PCB->GridOffsetX);
-  y1 = GridFit (SIDE_Y (gport->view.y0), PCB->Grid, PCB->GridOffsetY);
-  x2 = GridFit (SIDE_X (gport->view.x0 + gport->view.width - 1),
+  x1 = GridFit (SIDE_X (priv->view.x0), PCB->Grid, PCB->GridOffsetX);
+  y1 = GridFit (SIDE_Y (priv->view.y0), PCB->Grid, PCB->GridOffsetY);
+  x2 = GridFit (SIDE_X (priv->view.x0 + priv->view.width - 1),
                 PCB->Grid, PCB->GridOffsetX);
-  y2 = GridFit (SIDE_Y (gport->view.y0 + gport->view.height - 1),
+  y2 = GridFit (SIDE_Y (priv->view.y0 + priv->view.height - 1),
                 PCB->Grid, PCB->GridOffsetY);
   if (x1 > x2)
     {
@@ -188,9 +262,9 @@ ghid_draw_grid (void)
     x1 += PCB->Grid;
   if (Vy (y1) < 0)
     y1 += PCB->Grid;
-  if (Vx (x2) >= gport->width)
+  if (Vx (x2) >= priv->view.width)
     x2 -= PCB->Grid;
-  if (Vy (y2) >= gport->height)
+  if (Vy (y2) >= priv->view.height)
     y2 -= PCB->Grid;
   n = (x2 - x1) / PCB->Grid + 1;
   if (n > npoints)
@@ -227,10 +301,10 @@ ghid_draw_bg_image (void)
   if (!ghidgui->bg_pixbuf)
     return;
 
-  w = PCB->MaxWidth / gport->view.coord_per_px;
-  h = PCB->MaxHeight / gport->view.coord_per_px;
-  x = gport->view.x0 / gport->view.coord_per_px;
-  y = gport->view.y0 / gport->view.coord_per_px;
+  w = PCB->MaxWidth / priv->view.coord_per_px;
+  h = PCB->MaxHeight / priv->view.coord_per_px;
+  x = priv->view.x0 / priv->view.coord_per_px;
+  y = priv->view.y0 / priv->view.coord_per_px;
 
   if (w_scaled != w || h_scaled != h)
     {
@@ -281,7 +355,7 @@ ghid_use_mask (enum mask_mode mode)
 
     case HID_MASK_CLEAR:
       if (!gport->mask)
-	gport->mask = gdk_pixmap_new (0, gport->width, gport->height, 1);
+	gport->mask = gdk_pixmap_new (0, priv->view.width, priv->view.height, 1);
       gport->drawable = gport->mask;
       mask_seq = 0;
       if (!priv->mask_gc)
@@ -293,7 +367,7 @@ ghid_use_mask (enum mask_mode mode)
       color.pixel = 1;
       gdk_gc_set_foreground (priv->mask_gc, &color);
       gdk_draw_rectangle (gport->drawable, priv->mask_gc, TRUE, 0, 0,
-			  gport->width, gport->height);
+			  priv->view.width, priv->view.height);
       color.pixel = 0;
       gdk_gc_set_foreground (priv->mask_gc, &color);
       break;
@@ -523,8 +597,8 @@ ghid_draw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
   dx2 = Vx ((double) x2);
   dy2 = Vy ((double) y2);
 
-  if (!ClipLine (0, 0, gport->width, gport->height,
-		 &dx1, &dy1, &dx2, &dy2, gc->width / gport->view.coord_per_px))
+  if (!ClipLine (0, 0, priv->view.width, priv->view.height,
+		 &dx1, &dy1, &dx2, &dy2, gc->width / priv->view.coord_per_px))
     return;
 
   USE_GC (gc);
@@ -539,25 +613,25 @@ ghid_draw_arc (hidGC gc, Coord cx, Coord cy,
   gint w, h, radius;
   render_priv *priv = gport->render_priv;
 
-  w = gport->width * gport->view.coord_per_px;
-  h = gport->height * gport->view.coord_per_px;
+  w = priv->view.width * priv->view.coord_per_px;
+  h = priv->view.height * priv->view.coord_per_px;
   radius = (xradius > yradius) ? xradius : yradius;
-  if (SIDE_X (cx) < gport->view.x0 - radius
-      || SIDE_X (cx) > gport->view.x0 + w + radius
-      || SIDE_Y (cy) < gport->view.y0 - radius
-      || SIDE_Y (cy) > gport->view.y0 + h + radius)
+  if (SIDE_X (cx) < priv->view.x0 - radius
+      || SIDE_X (cx) > priv->view.x0 + w + radius
+      || SIDE_Y (cy) < priv->view.y0 - radius
+      || SIDE_Y (cy) > priv->view.y0 + h + radius)
     return;
 
   USE_GC (gc);
   vrx = Vz (xradius);
   vry = Vz (yradius);
 
-  if (gport->view.flip_x)
+  if (priv->view.flip_x)
     {
       start_angle = 180 - start_angle;
       delta_angle = -delta_angle;
     }
-  if (gport->view.flip_y)
+  if (priv->view.flip_y)
     {
       start_angle = -start_angle;
       delta_angle = -delta_angle;
@@ -578,17 +652,17 @@ ghid_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
   render_priv *priv = gport->render_priv;
 
   lw = gc->width;
-  w = gport->width * gport->view.coord_per_px;
-  h = gport->height * gport->view.coord_per_px;
-
-  if ((SIDE_X (x1) < gport->view.x0 - lw
-       && SIDE_X (x2) < gport->view.x0 - lw)
-      || (SIDE_X (x1) > gport->view.x0 + w + lw
-	  && SIDE_X (x2) > gport->view.x0 + w + lw)
-      || (SIDE_Y (y1) < gport->view.y0 - lw
-	  && SIDE_Y (y2) < gport->view.y0 - lw)
-      || (SIDE_Y (y1) > gport->view.y0 + h + lw
-	  && SIDE_Y (y2) > gport->view.y0 + h + lw))
+  w = priv->view.width * priv->view.coord_per_px;
+  h = priv->view.height * priv->view.coord_per_px;
+
+  if ((SIDE_X (x1) < priv->view.x0 - lw
+       && SIDE_X (x2) < priv->view.x0 - lw)
+      || (SIDE_X (x1) > priv->view.x0 + w + lw
+	  && SIDE_X (x2) > priv->view.x0 + w + lw)
+      || (SIDE_Y (y1) < priv->view.y0 - lw
+	  && SIDE_Y (y2) < priv->view.y0 - lw)
+      || (SIDE_Y (y1) > priv->view.y0 + h + lw
+	  && SIDE_Y (y2) > priv->view.y0 + h + lw))
     return;
 
   x1 = Vx (x1);
@@ -621,12 +695,12 @@ ghid_fill_circle (hidGC gc, Coord cx, Coord cy, Coord radius)
   gint w, h, vr;
   render_priv *priv = gport->render_priv;
 
-  w = gport->width * gport->view.coord_per_px;
-  h = gport->height * gport->view.coord_per_px;
-  if (SIDE_X (cx) < gport->view.x0 - radius
-      || SIDE_X (cx) > gport->view.x0 + w + radius
-      || SIDE_Y (cy) < gport->view.y0 - radius
-      || SIDE_Y (cy) > gport->view.y0 + h + radius)
+  w = priv->view.width * priv->view.coord_per_px;
+  h = priv->view.height * priv->view.coord_per_px;
+  if (SIDE_X (cx) < priv->view.x0 - radius
+      || SIDE_X (cx) > priv->view.x0 + w + radius
+      || SIDE_Y (cy) < priv->view.y0 - radius
+      || SIDE_Y (cy) > priv->view.y0 + h + radius)
     return;
 
   USE_GC (gc);
@@ -664,17 +738,17 @@ ghid_fill_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
   render_priv *priv = gport->render_priv;
 
   lw = gc->width;
-  w = gport->width * gport->view.coord_per_px;
-  h = gport->height * gport->view.coord_per_px;
-
-  if ((SIDE_X (x1) < gport->view.x0 - lw
-       && SIDE_X (x2) < gport->view.x0 - lw)
-      || (SIDE_X (x1) > gport->view.x0 + w + lw
-	  && SIDE_X (x2) > gport->view.x0 + w + lw)
-      || (SIDE_Y (y1) < gport->view.y0 - lw
-	  && SIDE_Y (y2) < gport->view.y0 - lw)
-      || (SIDE_Y (y1) > gport->view.y0 + h + lw
-	  && SIDE_Y (y2) > gport->view.y0 + h + lw))
+  w = priv->view.width * priv->view.coord_per_px;
+  h = priv->view.height * priv->view.coord_per_px;
+
+  if ((SIDE_X (x1) < priv->view.x0 - lw
+       && SIDE_X (x2) < priv->view.x0 - lw)
+      || (SIDE_X (x1) > priv->view.x0 + w + lw
+	  && SIDE_X (x2) > priv->view.x0 + w + lw)
+      || (SIDE_Y (y1) < priv->view.y0 - lw
+	  && SIDE_Y (y2) < priv->view.y0 - lw)
+      || (SIDE_Y (y1) > priv->view.y0 + h + lw
+	  && SIDE_Y (y2) > priv->view.y0 + h + lw))
     return;
 
   x1 = Vx (x1);
@@ -717,8 +791,8 @@ redraw_region (GdkRectangle *rect)
     {
       priv->clip_rect.x = 0;
       priv->clip_rect.y = 0;
-      priv->clip_rect.width = gport->width;
-      priv->clip_rect.height = gport->height;
+      priv->clip_rect.width = priv->view.width;
+      priv->clip_rect.height = priv->view.height;
       priv->clip = false;
     }
 
@@ -760,25 +834,25 @@ redraw_region (GdkRectangle *rect)
 
   if (eleft > 0)
     gdk_draw_rectangle (gport->drawable, priv->offlimits_gc,
-                        1, 0, 0, eleft, gport->height);
+                        1, 0, 0, eleft, priv->view.height);
   else
     eleft = 0;
-  if (eright < gport->width)
+  if (eright < priv->view.width)
     gdk_draw_rectangle (gport->drawable, priv->offlimits_gc,
-                        1, eright, 0, gport->width - eright, gport->height);
+                        1, eright, 0, priv->view.width - eright, priv->view.height);
   else
-    eright = gport->width;
+    eright = priv->view.width;
   if (etop > 0)
     gdk_draw_rectangle (gport->drawable, priv->offlimits_gc,
                         1, eleft, 0, eright - eleft + 1, etop);
   else
     etop = 0;
-  if (ebottom < gport->height)
+  if (ebottom < priv->view.height)
     gdk_draw_rectangle (gport->drawable, priv->offlimits_gc,
                         1, eleft, ebottom, eright - eleft + 1,
-                        gport->height - ebottom);
+                        priv->view.height - ebottom);
   else
-    ebottom = gport->height;
+    ebottom = priv->view.height;
 
   gdk_draw_rectangle (gport->drawable, priv->bg_gc, 1,
                       eleft, etop, eright - eleft + 1, ebottom - etop + 1);
@@ -917,84 +991,87 @@ ghid_notify_mark_change (bool changes_complete)
 static void
 draw_right_cross (GdkGC *xor_gc, gint x, gint y)
 {
+  render_priv *priv = gport->render_priv;
   GdkWindow *window = gtk_widget_get_window (gport->drawing_area);
 
-  gdk_draw_line (window, xor_gc, x, 0, x, gport->height);
-  gdk_draw_line (window, xor_gc, 0, y, gport->width, y);
+  gdk_draw_line (window, xor_gc, x, 0, x, priv->view.height);
+  gdk_draw_line (window, xor_gc, 0, y, priv->view.width, y);
 }
 
 static void
 draw_slanted_cross (GdkGC *xor_gc, gint x, gint y)
 {
+  render_priv *priv = gport->render_priv;
   GdkWindow *window = gtk_widget_get_window (gport->drawing_area);
   gint x0, y0, x1, y1;
 
-  x0 = x + (gport->height - y);
-  x0 = MAX(0, MIN (x0, gport->width));
+  x0 = x + (priv->view.height - y);
+  x0 = MAX(0, MIN (x0, priv->view.width));
   x1 = x - y;
-  x1 = MAX(0, MIN (x1, gport->width));
-  y0 = y + (gport->width - x);
-  y0 = MAX(0, MIN (y0, gport->height));
+  x1 = MAX(0, MIN (x1, priv->view.width));
+  y0 = y + (priv->view.width - x);
+  y0 = MAX(0, MIN (y0, priv->view.height));
   y1 = y - x;
-  y1 = MAX(0, MIN (y1, gport->height));
+  y1 = MAX(0, MIN (y1, priv->view.height));
   gdk_draw_line (window, xor_gc, x0, y0, x1, y1);
 
-  x0 = x - (gport->height - y);
-  x0 = MAX(0, MIN (x0, gport->width));
+  x0 = x - (priv->view.height - y);
+  x0 = MAX(0, MIN (x0, priv->view.width));
   x1 = x + y;
-  x1 = MAX(0, MIN (x1, gport->width));
+  x1 = MAX(0, MIN (x1, priv->view.width));
   y0 = y + x;
-  y0 = MAX(0, MIN (y0, gport->height));
-  y1 = y - (gport->width - x);
-  y1 = MAX(0, MIN (y1, gport->height));
+  y0 = MAX(0, MIN (y0, priv->view.height));
+  y1 = y - (priv->view.width - x);
+  y1 = MAX(0, MIN (y1, priv->view.height));
   gdk_draw_line (window, xor_gc, x0, y0, x1, y1);
 }
 
 static void
 draw_dozen_cross (GdkGC *xor_gc, gint x, gint y)
 {
+  render_priv *priv = gport->render_priv;
   GdkWindow *window = gtk_widget_get_window (gport->drawing_area);
   gint x0, y0, x1, y1;
   gdouble tan60 = sqrt (3);
 
-  x0 = x + (gport->height - y) / tan60;
-  x0 = MAX(0, MIN (x0, gport->width));
+  x0 = x + (priv->view.height - y) / tan60;
+  x0 = MAX(0, MIN (x0, priv->view.width));
   x1 = x - y / tan60;
-  x1 = MAX(0, MIN (x1, gport->width));
-  y0 = y + (gport->width - x) * tan60;
-  y0 = MAX(0, MIN (y0, gport->height));
+  x1 = MAX(0, MIN (x1, priv->view.width));
+  y0 = y + (priv->view.width - x) * tan60;
+  y0 = MAX(0, MIN (y0, priv->view.height));
   y1 = y - x * tan60;
-  y1 = MAX(0, MIN (y1, gport->height));
+  y1 = MAX(0, MIN (y1, priv->view.height));
   gdk_draw_line (window, xor_gc, x0, y0, x1, y1);
 
-  x0 = x + (gport->height - y) * tan60;
-  x0 = MAX(0, MIN (x0, gport->width));
+  x0 = x + (priv->view.height - y) * tan60;
+  x0 = MAX(0, MIN (x0, priv->view.width));
   x1 = x - y * tan60;
-  x1 = MAX(0, MIN (x1, gport->width));
-  y0 = y + (gport->width - x) / tan60;
-  y0 = MAX(0, MIN (y0, gport->height));
+  x1 = MAX(0, MIN (x1, priv->view.width));
+  y0 = y + (priv->view.width - x) / tan60;
+  y0 = MAX(0, MIN (y0, priv->view.height));
   y1 = y - x / tan60;
-  y1 = MAX(0, MIN (y1, gport->height));
+  y1 = MAX(0, MIN (y1, priv->view.height));
   gdk_draw_line (window, xor_gc, x0, y0, x1, y1);
 
-  x0 = x - (gport->height - y) / tan60;
-  x0 = MAX(0, MIN (x0, gport->width));
+  x0 = x - (priv->view.height - y) / tan60;
+  x0 = MAX(0, MIN (x0, priv->view.width));
   x1 = x + y / tan60;
-  x1 = MAX(0, MIN (x1, gport->width));
+  x1 = MAX(0, MIN (x1, priv->view.width));
   y0 = y + x * tan60;
-  y0 = MAX(0, MIN (y0, gport->height));
-  y1 = y - (gport->width - x) * tan60;
-  y1 = MAX(0, MIN (y1, gport->height));
+  y0 = MAX(0, MIN (y0, priv->view.height));
+  y1 = y - (priv->view.width - x) * tan60;
+  y1 = MAX(0, MIN (y1, priv->view.height));
   gdk_draw_line (window, xor_gc, x0, y0, x1, y1);
 
-  x0 = x - (gport->height - y) * tan60;
-  x0 = MAX(0, MIN (x0, gport->width));
+  x0 = x - (priv->view.height - y) * tan60;
+  x0 = MAX(0, MIN (x0, priv->view.width));
   x1 = x + y * tan60;
-  x1 = MAX(0, MIN (x1, gport->width));
+  x1 = MAX(0, MIN (x1, priv->view.width));
   y0 = y + x / tan60;
-  y0 = MAX(0, MIN (y0, gport->height));
-  y1 = y - (gport->width - x) / tan60;
-  y1 = MAX(0, MIN (y1, gport->height));
+  y0 = MAX(0, MIN (y0, priv->view.height));
+  y1 = y - (priv->view.width - x) / tan60;
+  y1 = MAX(0, MIN (y1, priv->view.height));
   gdk_draw_line (window, xor_gc, x0, y0, x1, y1);
 }
 
@@ -1074,7 +1151,7 @@ ghid_drawing_area_configure_hook (GHidPort *port)
   if (port->mask)
     {
       gdk_pixmap_unref (port->mask);
-      port->mask = gdk_pixmap_new (0, port->width, port->height, 1);
+      port->mask = gdk_pixmap_new (0, priv->view.width, priv->view.height, 1);
     }
 }
 
@@ -1088,7 +1165,7 @@ ghid_screen_update (void)
     return;
 
   gdk_draw_drawable (window, priv->bg_gc, gport->pixmap,
-                     0, 0, 0, 0, gport->width, gport->height);
+                     0, 0, 0, 0, priv->view.width, priv->view.height);
   draw_crosshair (priv);
 }
 
@@ -1120,37 +1197,34 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   GdkWindow *window = gtk_widget_get_window (widget);
   GdkDrawable *save_drawable;
   GtkAllocation allocation;
-  view_data save_view;
-  int save_width, save_height;
   Coord save_max_width;
   Coord save_max_height;
+  view_data save_view;
   double xz, yz;
   render_priv *priv = gport->render_priv;
 
   /* Setup drawable and zoom factor for drawing routines
    */
   save_drawable = gport->drawable;
-  save_view = gport->view;
-  save_width = gport->width;
-  save_height = gport->height;
   save_max_width = PCB->MaxWidth;
   save_max_height = PCB->MaxHeight;
+  save_view = priv->view;
 
   gtk_widget_get_allocation (widget, &allocation);
   xz = (double) pinout->x_max / allocation.width;
   yz = (double) pinout->y_max / allocation.height;
   if (xz > yz)
-    gport->view.coord_per_px = xz;
+    priv->view.coord_per_px = xz;
   else
-    gport->view.coord_per_px = yz;
-
-  gport->drawable = window;
-  gport->width = allocation.width;
-  gport->height = allocation.height;
-  gport->view.width = allocation.width * gport->view.coord_per_px;
-  gport->view.height = allocation.height * gport->view.coord_per_px;
-  gport->view.x0 = (pinout->x_max - gport->view.width) / 2;
-  gport->view.y0 = (pinout->y_max - gport->view.height) / 2;
+    priv->view.coord_per_px = yz;
+
+  gport->drawable = widget->window;
+  priv->view.width = allocation.width;
+  priv->view.height = allocation.height;
+  priv->view.width = allocation.width * priv->view.coord_per_px;
+  priv->view.height = allocation.height * priv->view.coord_per_px;
+  priv->view.x0 = (pinout->x_max - priv->view.width) / 2;
+  priv->view.y0 = (pinout->y_max - priv->view.height) / 2;
   PCB->MaxWidth =  pinout->x_max;
   PCB->MaxHeight = pinout->y_max;
 
@@ -1162,9 +1236,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   hid_expose_callback (&ghid_hid, NULL, &pinout->element);
 
   gport->drawable = save_drawable;
-  gport->view = save_view;
-  gport->width = save_width;
-  gport->height = save_height;
+  priv->view = save_view;
   PCB->MaxWidth = save_max_width;
   PCB->MaxHeight = save_max_height;
 
@@ -1177,14 +1249,11 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   GdkPixmap *pixmap;
   GdkDrawable *save_drawable;
   view_data save_view;
-  int save_width, save_height;
   BoxType region;
   render_priv *priv = gport->render_priv;
 
   save_drawable = gport->drawable;
-  save_view = gport->view;
-  save_width = gport->width;
-  save_height = gport->height;
+  save_view = priv->view;
 
   pixmap = gdk_pixmap_new (NULL, width, height, depth);
 
@@ -1192,24 +1261,24 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
    */
 
   gport->drawable = pixmap;
-  gport->view.coord_per_px = zoom;
-  gport->width = width;
-  gport->height = height;
-  gport->view.width = width * gport->view.coord_per_px;
-  gport->view.height = height * gport->view.coord_per_px;
-  gport->view.x0 = gport->view.flip_x ? PCB->MaxWidth - cx : cx;
-  gport->view.x0 -= gport->view.height / 2;
-  gport->view.y0 = gport->view.flip_y ? PCB->MaxHeight - cy : cy;
-  gport->view.y0 -= gport->view.width  / 2;
+  priv->view.coord_per_px = zoom;
+  priv->view.width = width;
+  priv->view.height = height;
+  priv->view.width = width * priv->view.coord_per_px;
+  priv->view.height = height * priv->view.coord_per_px;
+  priv->view.x0 = priv->view.flip_x ? PCB->MaxWidth - cx : cx;
+  priv->view.x0 -= priv->view.height / 2;
+  priv->view.y0 = priv->view.flip_y ? PCB->MaxHeight - cy : cy;
+  priv->view.y0 -= priv->view.width  / 2;
 
   /* clear background */
   gdk_draw_rectangle (pixmap, priv->bg_gc, TRUE, 0, 0, width, height);
 
   /* call the drawing routine */
-  region.X1 = MIN(Px(0), Px(gport->width + 1));
-  region.Y1 = MIN(Py(0), Py(gport->height + 1));
-  region.X2 = MAX(Px(0), Px(gport->width + 1));
-  region.Y2 = MAX(Py(0), Py(gport->height + 1));
+  region.X1 = MIN(Px(0), Px(priv->view.width + 1));
+  region.Y1 = MIN(Py(0), Py(priv->view.height + 1));
+  region.X2 = MAX(Px(0), Px(priv->view.width + 1));
+  region.Y2 = MAX(Py(0), Py(priv->view.height + 1));
 
   region.X1 = MAX (0, MIN (PCB->MaxWidth,  region.X1));
   region.X2 = MAX (0, MIN (PCB->MaxWidth,  region.X2));
@@ -1219,9 +1288,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   hid_expose_callback (&ghid_hid, &region, NULL);
 
   gport->drawable = save_drawable;
-  gport->view = save_view;
-  gport->width = save_width;
-  gport->height = save_height;
+  priv->view = save_view;
 
   return pixmap;
 }
@@ -1252,6 +1319,8 @@ ghid_finish_debug_draw (void)
 bool
 ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y)
 {
+  render_priv *priv = gport->render_priv;
+
   *pcb_x = EVENT_TO_PCB_X (event_x);
   *pcb_y = EVENT_TO_PCB_Y (event_y);
 
@@ -1261,6 +1330,8 @@ ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y)
 bool
 ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y)
 {
+  render_priv *priv = gport->render_priv;
+
   *event_x = DRAW_X (pcb_x);
   *event_y = DRAW_Y (pcb_y);
 
@@ -1270,6 +1341,7 @@ ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y)
 static void
 pan_common (GHidPort *port)
 {
+  render_priv *priv = gport->render_priv;
   int event_x, event_y;
 
   /* We need to fix up the PCB coordinates corresponding to the last
@@ -1277,10 +1349,10 @@ pan_common (GHidPort *port)
   ghid_pcb_to_event_coords (gport->pcb_x, gport->pcb_y, &event_x, &event_y);
 
   /* Don't pan so far the board is completely off the screen */
-  port->view.x0 = MAX (-port->view.width,  port->view.x0);
-  port->view.y0 = MAX (-port->view.height, port->view.y0);
-  port->view.x0 = MIN ( port->view.x0, PCB->MaxWidth);
-  port->view.y0 = MIN ( port->view.y0, PCB->MaxHeight);
+  priv->view.x0 = MAX (-priv->view.width,  priv->view.x0);
+  priv->view.y0 = MAX (-priv->view.height, priv->view.y0);
+  priv->view.x0 = MIN ( priv->view.x0, PCB->MaxWidth);
+  priv->view.y0 = MIN ( priv->view.y0, PCB->MaxHeight);
 
   /* Fix up noted event coordinates to match where we clamped. Alternatively
    * we could call ghid_note_event_location (NULL); to get a new pointer
@@ -1289,8 +1361,8 @@ pan_common (GHidPort *port)
   ghid_event_to_pcb_coords (event_x, event_y, &gport->pcb_x, &gport->pcb_y);
 
   ghidgui->adjustment_changed_holdoff = TRUE;
-  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view.x0);
-  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view.y0);
+  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), priv->view.x0);
+  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), priv->view.y0);
   ghidgui->adjustment_changed_holdoff = FALSE;
 
   ghid_port_ranges_changed();
@@ -1299,8 +1371,10 @@ pan_common (GHidPort *port)
 void
 ghid_pan_view_abs (Coord pcb_x, Coord pcb_y, int widget_x, int widget_y)
 {
-  gport->view.x0 = SIDE_X (pcb_x) - widget_x * gport->view.coord_per_px;
-  gport->view.y0 = SIDE_Y (pcb_y) - widget_y * gport->view.coord_per_px;
+  render_priv *priv = gport->render_priv;
+
+  priv->view.x0 = SIDE_X (pcb_x) - widget_x * priv->view.coord_per_px;
+  priv->view.y0 = SIDE_Y (pcb_y) - widget_y * priv->view.coord_per_px;
 
   pan_common (gport);
 }
@@ -1308,24 +1382,27 @@ ghid_pan_view_abs (Coord pcb_x, Coord pcb_y, int widget_x, int widget_y)
 void
 ghid_pan_view_rel (Coord dx, Coord dy)
 {
-  gport->view.x0 += dx;
-  gport->view.y0 += dy;
+  render_priv *priv = gport->render_priv;
+
+  priv->view.x0 += dx;
+  priv->view.y0 += dy;
 
   pan_common (gport);
 }
 
 
-/* gport->view.coord_per_px:
+/* priv->view.coord_per_px:
  * zoom value is PCB units per screen pixel.  Larger numbers mean zooming
  * out - the largest value means you are looking at the whole board.
  *
- * gport->view_width and gport->view_height are in PCB coordinates
+ * priv->view_width and priv->view_height are in PCB coordinates
  */
 
 #define ALLOW_ZOOM_OUT_BY 10 /* Arbitrary, and same as the lesstif HID */
 void
 ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
 {
+  render_priv *priv = gport->render_priv;
   double min_zoom, max_zoom;
   double xtmp, ytmp;
 
@@ -1334,22 +1411,22 @@ ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
    * the entire board just fits inside the viewport
    */
   min_zoom = 1;
-  max_zoom = MAX (PCB->MaxWidth  / gport->width,
-                  PCB->MaxHeight / gport->height) * ALLOW_ZOOM_OUT_BY;
+  max_zoom = MAX (PCB->MaxWidth  / priv->view.width,
+                  PCB->MaxHeight / priv->view.height) * ALLOW_ZOOM_OUT_BY;
   new_zoom = MIN (MAX (min_zoom, new_zoom), max_zoom);
 
-  if (gport->view.coord_per_px == new_zoom)
+  if (priv->view.coord_per_px == new_zoom)
     return;
 
-  xtmp = (SIDE_X (center_x) - gport->view.x0) / (double)gport->view.width;
-  ytmp = (SIDE_Y (center_y) - gport->view.y0) / (double)gport->view.height;
+  xtmp = (SIDE_X (center_x) - priv->view.x0) / (double)priv->view.width;
+  ytmp = (SIDE_Y (center_y) - priv->view.y0) / (double)priv->view.height;
 
-  gport->view.coord_per_px = new_zoom;
+  priv->view.coord_per_px = new_zoom;
   pixel_slop = new_zoom;
   ghid_port_ranges_scale ();
 
-  gport->view.x0 = SIDE_X (center_x) - xtmp * gport->view.width;
-  gport->view.y0 = SIDE_Y (center_y) - ytmp * gport->view.height;
+  priv->view.x0 = SIDE_X (center_x) - xtmp * priv->view.width;
+  priv->view.y0 = SIDE_Y (center_y) - ytmp * priv->view.height;
 
   pan_common (gport);
 
@@ -1359,28 +1436,32 @@ ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
 void
 ghid_zoom_view_rel (Coord center_x, Coord center_y, double factor)
 {
-  ghid_zoom_view_abs (center_x, center_y, gport->view.coord_per_px * factor);
+  render_priv *priv = gport->render_priv;
+
+  ghid_zoom_view_abs (center_x, center_y, priv->view.coord_per_px * factor);
 }
 
 void
 ghid_zoom_view_fit (void)
 {
+  render_priv *priv = gport->render_priv;
   ghid_pan_view_abs (SIDE_X (0), SIDE_Y (0), 0, 0);
   ghid_zoom_view_abs (SIDE_X (0), SIDE_Y (0),
-                      MAX (PCB->MaxWidth  / gport->width,
-                           PCB->MaxHeight / gport->height));
+                      MAX (PCB->MaxWidth  / priv->view.width,
+                           PCB->MaxHeight / priv->view.height));
 }
 
 void
 ghid_flip_view (Coord center_x, Coord center_y, bool flip_x, bool flip_y)
 {
+  render_priv *priv = gport->render_priv;
   int widget_x, widget_y;
 
   /* Work out where on the screen the flip point is */
   ghid_pcb_to_event_coords (center_x, center_y, &widget_x, &widget_y);
 
-  gport->view.flip_x = gport->view.flip_x != flip_x;
-  gport->view.flip_y = gport->view.flip_y != flip_y;
+  priv->view.flip_x = priv->view.flip_x != flip_x;
+  priv->view.flip_y = priv->view.flip_y != flip_y;
 
   /* Pan the board so the center location remains in the same place */
   ghid_pan_view_abs (center_x, center_y, widget_x, widget_y);
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 9ac4c7b..89aa171 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -41,6 +41,19 @@ static hidGC current_gc = NULL;
 */
 #define USE_GC(gc) if (!use_gc(gc)) return
 
+#define FLIP_X(x)         ((priv->view.flip_x ? -(x) : (x)))
+#define FLIP_Y(y)         ((priv->view.flip_y ? -(y) : (y)))
+
+#define SIDE_X(x)         ((priv->view.flip_x ? PCB->MaxWidth  - (x) : (x)))
+#define SIDE_Y(y)         ((priv->view.flip_y ? PCB->MaxHeight - (y) : (y)))
+
+#define DRAW_X(x)         (int)((SIDE_X(x) - priv->view.x0) / priv->view.coord_per_px)
+#define DRAW_Y(y)         (int)((SIDE_Y(y) - priv->view.y0) / priv->view.coord_per_px)
+
+#define EVENT_TO_PCB_X(x) SIDE_X((int)((x) * priv->view.coord_per_px + priv->view.x0))
+#define EVENT_TO_PCB_Y(y) SIDE_Y((int)((y) * priv->view.coord_per_px + priv->view.y0))
+
+
 static enum mask_mode cur_mask = HID_MASK_OFF;
 static GLfloat view_matrix[4][4] = {{1.0, 0.0, 0.0, 0.0},
                                     {0.0, 1.0, 0.0, 0.0},
@@ -52,6 +65,21 @@ static GLfloat last_modelview_matrix[4][4] = {{1.0, 0.0, 0.0, 0.0},
                                               {0.0, 0.0, 0.0, 1.0}};
 static int global_view_2d = 1;
 
+typedef struct view_data {
+  double coord_per_px;
+  Coord center_x;
+  Coord center_y;
+
+  Coord x0; /* XXX */
+  Coord y0; /* XXX */
+  Coord width;  /* XXX */
+  Coord height; /* XXX */
+
+  bool flip_x;
+  bool flip_y;
+  /* TODO: Rotation matrix ? */
+} view_data;
+
 typedef struct render_priv {
   GdkGLConfig *glconfig;
   bool trans_lines;
@@ -61,6 +89,8 @@ typedef struct render_priv {
   double current_alpha_mult;
   GTimer *time_since_expose;
 
+  view_data view;
+
   /* Feature for leading the user to a particular location */
   guint lead_user_timeout;
   GTimer *lead_user_timer;
@@ -87,6 +117,36 @@ hid_gc_struct;
 static void draw_lead_user (render_priv *priv);
 static void ghid_unproject_to_z_plane (int ex, int ey, Coord pcb_z, Coord *pcb_x, Coord *pcb_y);
 
+/* Px converts view->pcb, Vx converts pcb->view */
+static inline int
+Vz (Coord z)
+{
+  render_priv *priv = gport->render_priv;
+
+  return z / priv->view.coord_per_px + 0.5;
+}
+
+static inline Coord
+Px (int x)
+{
+  render_priv *priv = gport->render_priv;
+  Coord rv = x * priv->view.coord_per_px + priv->view.x0;
+
+  if (priv->view.flip_x)
+    rv = PCB->MaxWidth - (x * priv->view.coord_per_px + priv->view.x0);
+  return  rv;
+}
+
+static inline Coord
+Py (int y)
+{
+  render_priv *priv = gport->render_priv;
+  Coord rv = y * priv->view.coord_per_px + priv->view.y0;
+
+  if (priv->view.flip_y)
+    rv = PCB->MaxHeight - (y * priv->view.coord_per_px + priv->view.y0);
+  return  rv;
+}
 
 static void
 start_subcomposite (void)
@@ -533,19 +593,21 @@ use_gc (hidGC gc)
 void
 ghid_draw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
+  render_priv *priv = gport->render_priv;
   USE_GC (gc);
 
-  hidgl_draw_line (gc->cap, gc->width, x1, y1, x2, y2, gport->view.coord_per_px);
+  hidgl_draw_line (gc->cap, gc->width, x1, y1, x2, y2, priv->view.coord_per_px);
 }
 
 void
 ghid_draw_arc (hidGC gc, Coord cx, Coord cy, Coord xradius, Coord yradius,
                          Angle start_angle, Angle delta_angle)
 {
+  render_priv *priv = gport->render_priv;
   USE_GC (gc);
 
   hidgl_draw_arc (gc->width, cx, cy, xradius, yradius,
-                  start_angle, delta_angle, gport->view.coord_per_px);
+                  start_angle, delta_angle, priv->view.coord_per_px);
 }
 
 void
@@ -560,9 +622,10 @@ ghid_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 void
 ghid_fill_circle (hidGC gc, Coord cx, Coord cy, Coord radius)
 {
+  render_priv *priv = gport->render_priv;
   USE_GC (gc);
 
-  hidgl_fill_circle (cx, cy, radius, gport->view.coord_per_px);
+  hidgl_fill_circle (cx, cy, radius, priv->view.coord_per_px);
 }
 
 
@@ -577,6 +640,7 @@ ghid_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
 void
 ghid_draw_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
 {
+  render_priv *priv = gport->render_priv;
   static char *color;
   USE_GC (gc);
 
@@ -600,11 +664,11 @@ ghid_draw_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
     {
       common_thindraw_pcb_polygon (gc, poly, clip_box);
       ghid_set_alpha_mult (gc, 0.25);
-      hidgl_fill_pcb_polygon (poly, clip_box, gport->view.coord_per_px);
+      hidgl_fill_pcb_polygon (poly, clip_box, priv->view.coord_per_px);
       ghid_set_alpha_mult (gc, 1.0);
     }
   else
-    hidgl_fill_pcb_polygon (poly, clip_box, gport->view.coord_per_px);
+    hidgl_fill_pcb_polygon (poly, clip_box, priv->view.coord_per_px);
 
   /* If checking planes, thin-draw any pieces which have been clipped away */
   if (TEST_FLAG (CHECKPLANESFLAG, PCB) && !TEST_FLAG (FULLPOLYFLAG, poly))
@@ -844,6 +908,11 @@ ghid_init_drawing_widget (GtkWidget *widget, GHidPort *port)
 void
 ghid_drawing_area_configure_hook (GHidPort *port)
 {
+  render_priv *priv = port->render_priv;
+  GtkWidget *widget = port->drawing_area;
+
+  priv->view.width =  widget->allocation.width  * priv->view.coord_per_px;
+  priv->view.height = widget->allocation.height * priv->view.coord_per_px;
 }
 
 gboolean
@@ -928,13 +997,13 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glTranslatef (widget->allocation.width / 2., widget->allocation.height / 2., 0);
   glMultMatrixf ((GLfloat *)view_matrix);
   glTranslatef (-widget->allocation.width / 2., -widget->allocation.height / 2., 0);
-  glScalef ((port->view.flip_x ? -1. : 1.) / port->view.coord_per_px,
-            (port->view.flip_y ? -1. : 1.) / port->view.coord_per_px,
-            ((port->view.flip_x == port->view.flip_y) ? 1. : -1.) / port->view.coord_per_px);
-  glTranslatef (port->view.flip_x ?  port->view.x0 - PCB->MaxWidth  :
-                                    -port->view.x0,
-                port->view.flip_y ?  port->view.y0 - PCB->MaxHeight :
-                                    -port->view.y0, 0);
+  glScalef ((priv->view.flip_x ? -1. : 1.) / priv->view.coord_per_px,
+            (priv->view.flip_y ? -1. : 1.) / priv->view.coord_per_px,
+            ((priv->view.flip_x == priv->view.flip_y) ? 1. : -1.) / priv->view.coord_per_px);
+  glTranslatef (priv->view.flip_x ?  priv->view.x0 - PCB->MaxWidth  :
+                                    -priv->view.x0,
+                priv->view.flip_y ?  priv->view.y0 - PCB->MaxHeight :
+                                    -priv->view.y0, 0);
   glGetFloatv (GL_MODELVIEW_MATRIX, (GLfloat *)last_modelview_matrix);
 
   glEnable (GL_STENCIL_TEST);
@@ -1076,21 +1145,19 @@ gboolean
 ghid_pinout_preview_expose (GtkWidget *widget,
                             GdkEventExpose *ev)
 {
+  render_priv *priv = gport->render_priv;
   GdkGLContext* pGlContext = gtk_widget_get_gl_context (widget);
   GdkGLDrawable* pGlDrawable = gtk_widget_get_gl_drawable (widget);
   GhidPinoutPreview *pinout = GHID_PINOUT_PREVIEW (widget);
   GtkAllocation allocation;
   view_data save_view;
-  int save_width, save_height;
   Coord save_max_width;
   Coord save_max_height;
   double xz, yz;
 
-  save_view = gport->view;
-  save_width = gport->width;
-  save_height = gport->height;
   save_max_width = PCB->MaxWidth;
   save_max_height = PCB->MaxHeight;
+  save_view = priv->view;
 
   /* Setup zoom factor for drawing routines */
 
@@ -1098,16 +1165,14 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   xz = (double) pinout->x_max / allocation.width;
   yz = (double) pinout->y_max / allocation.height;
   if (xz > yz)
-    gport->view.coord_per_px = xz;
+    priv->view.coord_per_px = xz;
   else
-    gport->view.coord_per_px = yz;
-
-  gport->width = allocation.width;
-  gport->height = allocation.height;
-  gport->view.width = allocation.width * gport->view.coord_per_px;
-  gport->view.height = allocation.height * gport->view.coord_per_px;
-  gport->view.x0 = (pinout->x_max - gport->view.width) / 2;
-  gport->view.y0 = (pinout->y_max - gport->view.height) / 2;
+    priv->view.coord_per_px = yz;
+
+  priv->view.width = allocation.width  * priv->view.coord_per_px;
+  priv->view.height = allocation.height * priv->view.coord_per_px;
+  priv->view.x0 = (pinout->x_max - priv->view.width) / 2;
+  priv->view.y0 = (pinout->y_max - priv->view.height) / 2;
   PCB->MaxWidth = pinout->x_max;
   PCB->MaxHeight = pinout->y_max;
 
@@ -1147,14 +1212,13 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   /* call the drawing routine */
   ghid_invalidate_current_gc ();
   glPushMatrix ();
-  glScalef ((gport->view.flip_x ? -1. : 1.) / gport->view.coord_per_px,
-            (gport->view.flip_y ? -1. : 1.) / gport->view.coord_per_px,
-            ((gport->view.flip_x == gport->view.flip_y) ? 1. : -1.) / gport->view.coord_per_px);
-  glTranslatef (gport->view.flip_x ? gport->view.x0 - PCB->MaxWidth  :
-                                    -gport->view.x0,
-                gport->view.flip_y ? gport->view.y0 - PCB->MaxHeight :
-                                    -gport->view.y0, 0);
-
+  glScalef ((priv->view.flip_x ? -1. : 1.) / priv->view.coord_per_px,
+            (priv->view.flip_y ? -1. : 1.) / priv->view.coord_per_px,
+            ((priv->view.flip_x == priv->view.flip_y) ? 1. : -1.) / priv->view.coord_per_px);
+  glTranslatef (priv->view.flip_x ? priv->view.x0 - PCB->MaxWidth  :
+                                   -priv->view.x0,
+                priv->view.flip_y ? priv->view.y0 - PCB->MaxHeight :
+                                   -priv->view.y0, 0);
   hid_expose_callback (&ghid_hid, NULL, &pinout->element);
   hidgl_flush_triangles (&buffer);
   glPopMatrix ();
@@ -1170,9 +1234,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   gport->render_priv->in_context = false;
   gdk_gl_drawable_gl_end (pGlDrawable);
 
-  gport->view = save_view;
-  gport->width = save_width;
-  gport->height = save_height;
+  priv->view = save_view;
   PCB->MaxWidth = save_max_width;
   PCB->MaxHeight = save_max_height;
 
@@ -1183,18 +1245,16 @@ ghid_pinout_preview_expose (GtkWidget *widget,
 GdkPixmap *
 ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int depth)
 {
+  render_priv *priv = gport->render_priv;
   GdkGLConfig *glconfig;
   GdkPixmap *pixmap;
   GdkGLPixmap *glpixmap;
   GdkGLContext* glcontext;
   GdkGLDrawable* gldrawable;
   view_data save_view;
-  int save_width, save_height;
   BoxType region;
 
-  save_view = gport->view;
-  save_width = gport->width;
-  save_height = gport->height;
+  save_view = priv->view;
 
   /* Setup rendering context for drawing routines
    */
@@ -1210,15 +1270,13 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
 
   /* Setup zoom factor for drawing routines */
 
-  gport->view.coord_per_px = zoom;
-  gport->width = width;
-  gport->height = height;
-  gport->view.width = width * gport->view.coord_per_px;
-  gport->view.height = height * gport->view.coord_per_px;
-  gport->view.x0 = gport->view.flip_x ? PCB->MaxWidth - cx : cx;
-  gport->view.x0 -= gport->view.height / 2;
-  gport->view.y0 = gport->view.flip_y ? PCB->MaxHeight - cy : cy;
-  gport->view.y0 -= gport->view.width / 2;
+  priv->view.coord_per_px = zoom;
+  priv->view.width = width   * priv->view.coord_per_px;
+  priv->view.height = height * priv->view.coord_per_px;
+  priv->view.x0 = priv->view.flip_x ? PCB->MaxWidth - cx : cx;
+  priv->view.x0 -= priv->view.height / 2;
+  priv->view.y0 = priv->view.flip_y ? PCB->MaxHeight - cy : cy;
+  priv->view.y0 -= priv->view.width  / 2;
 
   /* make GL-context "current" */
   if (!gdk_gl_drawable_gl_begin (gldrawable, glcontext)) {
@@ -1254,18 +1312,18 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   /* call the drawing routine */
   ghid_invalidate_current_gc ();
   glPushMatrix ();
-  glScalef ((gport->view.flip_x ? -1. : 1.) / gport->view.coord_per_px,
-            (gport->view.flip_y ? -1. : 1.) / gport->view.coord_per_px,
-            ((gport->view.flip_x == gport->view.flip_y) ? 1. : -1.) / gport->view.coord_per_px);
-  glTranslatef (gport->view.flip_x ? gport->view.x0 - PCB->MaxWidth  :
-                                    -gport->view.x0,
-                gport->view.flip_y ? gport->view.y0 - PCB->MaxHeight :
-                                    -gport->view.y0, 0);
-
-  region.X1 = MIN(Px(0), Px(gport->width + 1));
-  region.Y1 = MIN(Py(0), Py(gport->height + 1));
-  region.X2 = MAX(Px(0), Px(gport->width + 1));
-  region.Y2 = MAX(Py(0), Py(gport->height + 1));
+  glScalef ((priv->view.flip_x ? -1. : 1.) / priv->view.coord_per_px,
+            (priv->view.flip_y ? -1. : 1.) / priv->view.coord_per_px,
+            ((priv->view.flip_x == priv->view.flip_y) ? 1. : -1.) / priv->view.coord_per_px);
+  glTranslatef (priv->view.flip_x ? priv->view.x0 - PCB->MaxWidth  :
+                                   -priv->view.x0,
+                priv->view.flip_y ? priv->view.y0 - PCB->MaxHeight :
+                                   -priv->view.y0, 0);
+
+  region.X1 = MIN (Px(0), Px(width + 1));
+  region.Y1 = MIN (Py(0), Py(height + 1));
+  region.X2 = MAX (Px(0), Px(width + 1));
+  region.Y2 = MAX (Py(0), Py(height + 1));
 
   region.X1 = MAX (0, MIN (PCB->MaxWidth,  region.X1));
   region.X2 = MAX (0, MIN (PCB->MaxWidth,  region.X2));
@@ -1289,9 +1347,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   g_object_unref (glconfig);
   g_object_unref (glcontext);
 
-  gport->view = save_view;
-  gport->width = save_width;
-  gport->height = save_height;
+  priv->view = save_view;
 
   return pixmap;
 }
@@ -1300,6 +1356,7 @@ HID *
 ghid_request_debug_draw (void)
 {
   GHidPort *port = gport;
+  render_priv *priv = port->render_priv;
   GtkWidget *widget = port->drawing_area;
   GtkAllocation allocation;
 
@@ -1323,13 +1380,13 @@ ghid_request_debug_draw (void)
   glDisable (GL_STENCIL_TEST);
 
   glPushMatrix ();
-  glScalef ((port->view.flip_x ? -1. : 1.) / port->view.coord_per_px,
-            (port->view.flip_y ? -1. : 1.) / port->view.coord_per_px,
-            ((gport->view.flip_x == port->view.flip_y) ? 1. : -1.) / gport->view.coord_per_px);
-  glTranslatef (port->view.flip_x ? port->view.x0 - PCB->MaxWidth  :
-                             -port->view.x0,
-                port->view.flip_y ? port->view.y0 - PCB->MaxHeight :
-                             -port->view.y0, 0);
+  glScalef ((priv->view.flip_x ? -1. : 1.) / priv->view.coord_per_px,
+            (priv->view.flip_y ? -1. : 1.) / priv->view.coord_per_px,
+            ((priv->view.flip_x == priv->view.flip_y) ? 1. : -1.) / priv->view.coord_per_px);
+  glTranslatef (priv->view.flip_x ? priv->view.x0 - PCB->MaxWidth  :
+                             -priv->view.x0,
+                priv->view.flip_y ? priv->view.y0 - PCB->MaxHeight :
+                             -priv->view.y0, 0);
 
   return &ghid_hid;
 }
@@ -1551,7 +1608,7 @@ ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y)
 }
 
 static void
-pan_common (GHidPort *port)
+pan_common (render_priv *priv)
 {
   int event_x, event_y;
 
@@ -1560,10 +1617,10 @@ pan_common (GHidPort *port)
   ghid_pcb_to_event_coords (gport->pcb_x, gport->pcb_y, &event_x, &event_y);
 
   /* Don't pan so far the board is completely off the screen */
-  port->view.x0 = MAX (-port->view.width,  port->view.x0);
-  port->view.y0 = MAX (-port->view.height, port->view.y0);
-  port->view.x0 = MIN ( port->view.x0, PCB->MaxWidth);
-  port->view.y0 = MIN ( port->view.y0, PCB->MaxHeight);
+  priv->view.x0 = MAX (-priv->view.width,  priv->view.x0);
+  priv->view.y0 = MAX (-priv->view.height, priv->view.y0);
+  priv->view.x0 = MIN ( priv->view.x0, PCB->MaxWidth);
+  priv->view.y0 = MIN ( priv->view.y0, PCB->MaxHeight);
 
   /* Fix up noted event coordinates to match where we clamped. Alternatively
    * we could call ghid_note_event_location (NULL); to get a new pointer
@@ -1572,8 +1629,8 @@ pan_common (GHidPort *port)
   ghid_event_to_pcb_coords (event_x, event_y, &gport->pcb_x, &gport->pcb_y);
 
   ghidgui->adjustment_changed_holdoff = TRUE;
-  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view.x0);
-  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view.y0);
+  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), priv->view.x0);
+  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), priv->view.y0);
   ghidgui->adjustment_changed_holdoff = FALSE;
 
   ghid_port_ranges_changed();
@@ -1582,33 +1639,49 @@ pan_common (GHidPort *port)
 void
 ghid_pan_view_abs (Coord pcb_x, Coord pcb_y, int widget_x, int widget_y)
 {
-  gport->view.x0 = SIDE_X (pcb_x) - widget_x * gport->view.coord_per_px;
-  gport->view.y0 = SIDE_Y (pcb_y) - widget_y * gport->view.coord_per_px;
+  render_priv *priv = gport->render_priv;
 
-  pan_common (gport);
+  priv->view.x0 = SIDE_X (pcb_x) - widget_x * priv->view.coord_per_px;
+  priv->view.y0 = SIDE_Y (pcb_y) - widget_y * priv->view.coord_per_px;
+
+  pan_common (priv);
 }
 
 void
 ghid_pan_view_rel (Coord dx, Coord dy)
 {
-  gport->view.x0 += dx;
-  gport->view.y0 += dy;
+  render_priv *priv = gport->render_priv;
+
+  priv->view.x0 += dx;
+  priv->view.y0 += dy;
 
-  pan_common (gport);
+  pan_common (priv);
 }
 
+void
+ghid_pan_view_rel_to_visible (double fraction_x, double fraction_y)
+{
+  render_priv *priv = gport->render_priv;
+
+  priv->view.x0 = MAX (0, priv->view.x0 + FLIP_X (priv->view.width)  * fraction_x);
+  priv->view.y0 = MAX (0, priv->view.y0 + FLIP_Y (priv->view.height) * fraction_y);
+
+  pan_common (priv);
+}
 
-/* gport->view.coord_per_px:
+
+/* priv->view.coord_per_px:
  * zoom value is PCB units per screen pixel.  Larger numbers mean zooming
  * out - the largest value means you are looking at the whole board.
  *
- * gport->view_width and gport->view_height are in PCB coordinates
+ * priv->view.width and priv->view.height are in PCB coordinates
  */
 
 #define ALLOW_ZOOM_OUT_BY 10 /* Arbitrary, and same as the lesstif HID */
 void
 ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
 {
+  render_priv *priv = gport->render_priv;
   double min_zoom, max_zoom;
   double xtmp, ytmp;
 
@@ -1617,24 +1690,24 @@ ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
    * the entire board just fits inside the viewport
    */
   min_zoom = 1;
-  max_zoom = MAX (PCB->MaxWidth  / gport->width,
-                  PCB->MaxHeight / gport->height) * ALLOW_ZOOM_OUT_BY;
+  max_zoom = MAX (PCB->MaxWidth  / gport->drawing_area->allocation.width,
+                  PCB->MaxHeight / gport->drawing_area->allocation.height) * ALLOW_ZOOM_OUT_BY;
   new_zoom = MIN (MAX (min_zoom, new_zoom), max_zoom);
 
-  if (gport->view.coord_per_px == new_zoom)
+  if (priv->view.coord_per_px == new_zoom)
     return;
 
-  xtmp = (SIDE_X (center_x) - gport->view.x0) / (double)gport->view.width;
-  ytmp = (SIDE_Y (center_y) - gport->view.y0) / (double)gport->view.height;
+  xtmp = (SIDE_X (center_x) - priv->view.x0) / (double)priv->view.width;
+  ytmp = (SIDE_Y (center_y) - priv->view.y0) / (double)priv->view.height;
 
-  gport->view.coord_per_px = new_zoom;
+  priv->view.coord_per_px = new_zoom;
   pixel_slop = new_zoom;
   ghid_port_ranges_scale ();
 
-  gport->view.x0 = SIDE_X (center_x) - xtmp * gport->view.width;
-  gport->view.y0 = SIDE_Y (center_y) - ytmp * gport->view.height;
+  priv->view.x0 = SIDE_X (center_x) - xtmp * priv->view.width;
+  priv->view.y0 = SIDE_Y (center_y) - ytmp * priv->view.height;
 
-  pan_common (gport);
+  pan_common (priv);
 
   ghid_set_status_line_label ();
 }
@@ -1642,28 +1715,32 @@ ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
 void
 ghid_zoom_view_rel (Coord center_x, Coord center_y, double factor)
 {
-  ghid_zoom_view_abs (center_x, center_y, gport->view.coord_per_px * factor);
+  render_priv *priv = gport->render_priv;
+
+  ghid_zoom_view_abs (center_x, center_y, priv->view.coord_per_px * factor);
 }
 
 void
 ghid_zoom_view_fit (void)
 {
+  render_priv *priv = gport->render_priv;
   ghid_pan_view_abs (SIDE_X (0), SIDE_Y (0), 0, 0);
   ghid_zoom_view_abs (SIDE_X (0), SIDE_Y (0),
-                      MAX (PCB->MaxWidth  / gport->width,
-                           PCB->MaxHeight / gport->height));
+                      MAX (PCB->MaxWidth  / gport->drawing_area->allocation.width,
+                           PCB->MaxHeight / gport->drawing_area->allocation.height));
 }
 
 void
 ghid_flip_view (Coord center_x, Coord center_y, bool flip_x, bool flip_y)
 {
+  render_priv *priv = gport->render_priv;
   int widget_x, widget_y;
 
   /* Work out where on the screen the flip point is */
   ghid_pcb_to_event_coords (center_x, center_y, &widget_x, &widget_y);
 
-  gport->view.flip_x = gport->view.flip_x != flip_x;
-  gport->view.flip_y = gport->view.flip_y != flip_y;
+  priv->view.flip_x = priv->view.flip_x != flip_x;
+  priv->view.flip_y = priv->view.flip_y != flip_y;
 
   /* Pan the board so the center location remains in the same place */
   ghid_pan_view_abs (center_x, center_y, widget_x, widget_y);
@@ -1737,7 +1814,7 @@ draw_lead_user (render_priv *priv)
 
       /* Draw an arc at radius */
       hidgl_draw_arc (width, priv->lead_user_x, priv->lead_user_y,
-                      radius, radius, 0, 360, gport->view.coord_per_px);
+                      radius, radius, 0, 360, priv->view.coord_per_px);
     }
 
   hidgl_flush_triangles (&buffer);
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 83750c9..a8feba6 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -1473,8 +1473,8 @@ Center(int argc, char **argv, Coord pcb_x, Coord pcb_y)
     AFAIL (center);
 
   /* Aim to put the given x, y PCB coordinates in the center of the widget */
-  widget_x = gport->width / 2;
-  widget_y = gport->height / 2;
+  widget_x = gport->drawing_area->allocation.width / 2;
+  widget_y = gport->drawing_area->allocation.height / 2;
 
   ghid_pan_view_abs (pcb_x, pcb_y, widget_x, widget_y);
 
@@ -1545,13 +1545,13 @@ CursorAction(int argc, char **argv, Coord x, Coord y)
 {
   UnitList extra_units_x = {
     { "grid",  PCB->Grid, 0 },
-    { "view",  gport->view.width, UNIT_PERCENT },
+//    { "view",  gport->view_width, UNIT_PERCENT },
     { "board", PCB->MaxWidth, UNIT_PERCENT },
     { "", 0, 0 }
   };
   UnitList extra_units_y = {
     { "grid",  PCB->Grid, 0 },
-    { "view",  gport->view.height, UNIT_PERCENT },
+//    { "view",  gport->view_height, UNIT_PERCENT },
     { "board", PCB->MaxHeight, UNIT_PERCENT },
     { "", 0, 0 }
   };
@@ -1569,11 +1569,12 @@ CursorAction(int argc, char **argv, Coord x, Coord y)
     AFAIL (cursor);
 
   dx = GetValueEx (argv[1], argv[3], NULL, extra_units_x, "");
-  if (gport->view.flip_x)
-    dx = -dx;
   dy = GetValueEx (argv[2], argv[3], NULL, extra_units_y, "");
-  if (!gport->view.flip_y)
-    dy = -dy;
+
+#if 0 /* We cannot know this sensibly from the renderer, so we have to remove it */
+  if (gport->view.flip_x) dx = -dx;
+  if (gport->view.flip_x) dy = -dy;
+#endif
 
   EventMoveCrosshair (Crosshair.X + dx, Crosshair.Y + dy);
   gui->set_crosshair (Crosshair.X, Crosshair.Y, pan_warp);
@@ -1727,8 +1728,9 @@ default is given, div=40.
 static int
 ScrollAction (int argc, char **argv, Coord x, Coord y)
 {
-  gdouble dx = 0.0, dy = 0.0;
-  int div = 40;
+  double dx = 0.;
+  double dy = 0.;
+  double fraction = 1. / 40.;
 
   if (!ghidgui)
     return 0;
@@ -1737,20 +1739,20 @@ ScrollAction (int argc, char **argv, Coord x, Coord y)
     AFAIL (scroll);
 
   if (argc == 2)
-    div = atoi(argv[1]);
+    fraction = 1. / (double) atoi(argv[1]);
 
   if (strcasecmp (argv[0], "up") == 0)
-    dy = -gport->view.height / div;
-  else if (strcasecmp (argv[0], "down") == 0)
-    dy = gport->view.height / div;
+    dy = -fraction;
+  else if (strcasecmp (argv[0], "down")  == 0)
+    dy =  fraction;
   else if (strcasecmp (argv[0], "right") == 0)
-    dx = gport->view.width / div;
-  else if (strcasecmp (argv[0], "left") == 0)
-    dx = -gport->view.width / div;
+    dx =  fraction;
+  else if (strcasecmp (argv[0], "left")  == 0)
+    dx = -fraction;
   else
     AFAIL (scroll);
 
-  ghid_pan_view_rel (dx, dy);
+  ghid_pan_view_rel_to_visible (dx, dy);
 
   return 0;
 }
@@ -1935,25 +1937,6 @@ HID_Action ghid_main_action_list[] = {
 REGISTER_ACTIONS (ghid_main_action_list)
 
 
-static int
-flag_flipx (void *data)
-{
-  return gport->view.flip_x;
-}
-
-static int
-flag_flipy (void *data)
-{
-  return gport->view.flip_y;
-}
-
-HID_Flag ghid_main_flag_list[] = {
-  {"flip_x", flag_flipx, NULL},
-  {"flip_y", flag_flipy, NULL}
-};
-
-REGISTER_FLAGS (ghid_main_flag_list)
-
 #include "dolists.h"
 
 /*
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index 2ca39de..8c4a2a8 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -55,12 +55,14 @@
 void
 ghid_port_ranges_changed (void)
 {
+#if 0
   GtkAdjustment *h_adj, *v_adj;
 
   h_adj = gtk_range_get_adjustment (GTK_RANGE (ghidgui->h_range));
   v_adj = gtk_range_get_adjustment (GTK_RANGE (ghidgui->v_range));
   gport->view.x0 = gtk_adjustment_get_value (h_adj);
   gport->view.y0 = gtk_adjustment_get_value (v_adj);
+#endif
 
   ghid_invalidate_all ();
 }
@@ -71,6 +73,7 @@ ghid_port_ranges_changed (void)
 void
 ghid_port_ranges_scale (void)
 {
+#if 0
   GtkAdjustment *adj;
   gdouble page_size;
 
@@ -100,6 +103,7 @@ ghid_port_ranges_scale (void)
                             page_size / 100.0,              /* step_increment */
                             page_size / 10.0,               /* page_increment */
                             page_size);                     /* page_size      */
+#endif
 }
 
 
@@ -352,14 +356,11 @@ ghid_port_drawing_area_configure_event_cb (GtkWidget * widget,
 {
   static gboolean first_time_done;
 
-  gport->width = ev->width;
-  gport->height = ev->height;
-
   if (gport->pixmap)
     gdk_pixmap_unref (gport->pixmap);
 
   gport->pixmap = gdk_pixmap_new (gtk_widget_get_window (widget),
-				  gport->width, gport->height, -1);
+				  ev->width, ev->height, -1);
   gport->drawable = gport->pixmap;
 
   if (!first_time_done)
@@ -507,24 +508,20 @@ gint
 ghid_port_window_motion_cb (GtkWidget * widget,
 			    GdkEventMotion * ev, GHidPort * out)
 {
-  gdouble dx, dy;
-  static gint x_prev = -1, y_prev = -1;
-
   gdk_event_request_motions (ev);
 
   if (out->panning)
     {
-      dx = gport->view.coord_per_px * (x_prev - ev->x);
-      dy = gport->view.coord_per_px * (y_prev - ev->y);
-      if (x_prev > 0)
-        ghid_pan_view_rel (dx, dy);
-      x_prev = ev->x;
-      y_prev = ev->y;
+      /* gport->pcb_x and gport->pcb_y will correspond to where the user
+       * grabbed the board. Move the board so that location lands where
+       * the mouse pointer now is, as indicated by the event.
+       */
+      ghid_pan_view_abs (gport->pcb_x, gport->pcb_y, ev->x, ev->y);
+
       return FALSE;
     }
-  x_prev = y_prev = -1;
-  ghid_note_event_location ((GdkEventButton *)ev);
 
+  ghid_note_event_location ((GdkEventButton *)ev);
   queue_tooltip_update (out);
 
   return FALSE;
@@ -577,9 +574,7 @@ ghid_port_window_leave_cb (GtkWidget * widget,
    */
 
   if(ev->mode != GDK_CROSSING_NORMAL)
-    {
-      return FALSE;
-    }
+    return FALSE;
 
   out->has_entered = FALSE;
 
diff --git a/src/hid/gtk/gui-top-window.c b/src/hid/gtk/gui-top-window.c
index aa6d8e6..b1cad8a 100644
--- a/src/hid/gtk/gui-top-window.c
+++ b/src/hid/gtk/gui-top-window.c
@@ -1758,7 +1758,6 @@ ghid_parse_arguments (int *argc, char ***argv)
   gtk_init (argc, argv);
 
   gport = &ghid_port;
-  gport->view.coord_per_px = 300.0;
   pixel_slop = 300;
 
   ghid_init_renderer (argc, argv, gport);
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index 9231e02..41d5f6d 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -61,15 +61,6 @@
 #define	FROM_PCB_UNITS(v)	coord_to_unit (Settings.grid_unit, v)
 #define	TO_PCB_UNITS(v)		unit_to_coord (Settings.grid_unit, v)
 
-#define SIDE_X(x)         ((gport->view.flip_x ? PCB->MaxWidth - (x) : (x)))
-#define SIDE_Y(y)         ((gport->view.flip_y ? PCB->MaxHeight - (y) : (y)))
-
-#define	DRAW_X(x)         (gint)((SIDE_X(x) - gport->view.x0) / gport->view.coord_per_px)
-#define	DRAW_Y(y)         (gint)((SIDE_Y(y) - gport->view.y0) / gport->view.coord_per_px)
-
-#define	EVENT_TO_PCB_X(x) SIDE_X((gint)((x) * gport->view.coord_per_px + gport->view.x0))
-#define	EVENT_TO_PCB_Y(y) SIDE_Y((gint)((y) * gport->view.coord_per_px + gport->view.y0))
-
 /*
  * Used to intercept "special" hotkeys that gtk doesn't usually pass
  * on to the menu hotkeys.  We catch them and put them back where we
@@ -153,20 +144,6 @@ GhidGui;
 
 extern GhidGui _ghidgui, *ghidgui;
 
-typedef struct
-{
-  double coord_per_px; /* Zoom level described as PCB units per screen pixel */
-
-  Coord x0;
-  Coord y0;
-  Coord width;
-  Coord height;
-
-  bool flip_x;
-  bool flip_y;
-
-} view_data;
-
   /* The output viewport
    */
 typedef struct
@@ -175,7 +152,6 @@ typedef struct
    *drawing_area;		/* and its drawing area */
   GdkPixmap *pixmap, *mask;
   GdkDrawable *drawable;	/* Current drawable for drawing routines */
-  gint width, height;
 
   struct render_priv *render_priv;
 
@@ -189,7 +165,6 @@ typedef struct
   gboolean has_entered;
   gboolean panning;
 
-  view_data view;
   Coord pcb_x, pcb_y;             /* PCB coordinates of the mouse pointer */
   Coord crosshair_x, crosshair_y; /* PCB coordinates of the crosshair     */
 }
@@ -505,6 +480,7 @@ void ghid_finish_debug_draw (void);
 bool ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y);
 bool ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y);
 void ghid_pan_view_abs (Coord pcb_x, Coord pcb_y, int widget_x, int widget_y);
+void ghid_pan_view_rel_to_visible (double fraction_x, double fraction_y);
 void ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom);
 void ghid_zoom_view_rel (Coord center_x, Coord center_y, double factor);
 void ghid_zoom_view_fit (void);
@@ -528,58 +504,4 @@ extern GdkPixmap *XC_lock_source, *XC_lock_mask;
 extern GdkPixmap *XC_clock_source, *XC_clock_mask;
 
 
-/* Coordinate conversions */
-/* Px converts view->pcb, Vx converts pcb->view */
-static inline int
-Vx (Coord x)
-{
-  int rv;
-  if (gport->view.flip_x)
-    rv = (PCB->MaxWidth - x - gport->view.x0) / gport->view.coord_per_px + 0.5;
-  else
-    rv = (x - gport->view.x0) / gport->view.coord_per_px + 0.5;
-  return rv;
-}
-
-static inline int
-Vy (Coord y)
-{
-  int rv;
-  if (gport->view.flip_y)
-    rv = (PCB->MaxHeight - y - gport->view.y0) / gport->view.coord_per_px + 0.5;
-  else
-    rv = (y - gport->view.y0) / gport->view.coord_per_px + 0.5;
-  return rv;
-}
-
-static inline int
-Vz (Coord z)
-{
-  return z / gport->view.coord_per_px + 0.5;
-}
-
-static inline Coord
-Px (int x)
-{
-  Coord rv = x * gport->view.coord_per_px + gport->view.x0;
-  if (gport->view.flip_x)
-    rv = PCB->MaxWidth - (x * gport->view.coord_per_px + gport->view.x0);
-  return  rv;
-}
-
-static inline Coord
-Py (int y)
-{
-  Coord rv = y * gport->view.coord_per_px + gport->view.y0;
-  if (gport->view.flip_y)
-    rv = PCB->MaxHeight - (y * gport->view.coord_per_px + gport->view.y0);
-  return  rv;
-}
-
-static inline Coord
-Pz (int z)
-{
-  return (z * gport->view.coord_per_px);
-}
-
 #endif /* PCB_HID_GTK_GHID_H */

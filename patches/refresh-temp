Bottom: 4d72b9c329e2118b46bcb0294445b9f22574f078
Top:    3d457f88e512a58f753ccce830bfa3c15c9f63c4
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2008-10-10 20:01:44 +0100

Refresh of add_pours

---

diff --git a/globalconst.h b/globalconst.h
index cd6f4f9..4ab3813 100755
--- a/globalconst.h
+++ b/globalconst.h
@@ -118,6 +118,8 @@
 						/* line points */
 #define	MAX_POLYGON_POINT_DISTANCE	0	/* maximum distance when searching */
 						/* polygon points */
+#define	MAX_POUR_POINT_DISTANCE	0	/* maximum distance when searching */
+						/* pour points */
 #define	MAX_ELEMENTNAMES		3	/* number of supported names of */
 						/* an element */
 #define	MAX_LIBRARY_LINE_LENGTH		255	/* maximum line length in the */
diff --git a/src/action.c b/src/action.c
index af7ba6b..1999831 100644
--- a/src/action.c
+++ b/src/action.c
@@ -57,6 +57,7 @@
 #include "misc.h"
 #include "move.h"
 #include "polygon.h"
+#include "pour.h"
 /*#include "print.h"*/
 #include "rats.h"
 #include "remove.h"
@@ -133,7 +134,7 @@ typedef enum
   F_PinByName,
   F_PinOrPadName,
   F_Pinout,
-  F_Polygon,
+  F_Pour,
   F_PreviousPoint,
   F_RatsNest,
   F_Rectangle,
@@ -284,7 +285,7 @@ static PointType InsertedPoint;
 static LayerTypePtr lastLayer;
 static struct
 {
-  PolygonTypePtr poly;
+  PourTypePtr pour;
   LineType line;
 }
 fake;
@@ -363,7 +364,8 @@ static FunctionType Functions[] = {
   {"PinByName", F_PinByName},
   {"PinOrPadName", F_PinOrPadName},
   {"Pinout", F_Pinout},
-  {"Polygon", F_Polygon},
+  {"Pour", F_Pour},
+//  {"Polygon", F_Polygon},
   {"PreviousPoint", F_PreviousPoint},
   {"RatsNest", F_RatsNest},
   {"Rectangle", F_Rectangle},
@@ -824,8 +826,8 @@ AdjustAttachedObjects (void)
       AdjustAttachedBox ();
       break;
 
-      /* polygon creation mode */
-    case POLYGON_MODE:
+      /* pour creation mode */
+    case POUR_MODE:
       AdjustAttachedLine ();
       break;
       /* line creation mode */
@@ -1334,12 +1336,12 @@ NotifyMode (void)
 	  Crosshair.AttachedBox.Point1.X != Crosshair.AttachedBox.Point2.X &&
 	  Crosshair.AttachedBox.Point1.Y != Crosshair.AttachedBox.Point2.Y)
 	{
-	  PolygonTypePtr polygon;
+	  PourTypePtr pour;
 
 	  int flags = CLEARPOLYFLAG;
 	  if (Settings.FullPoly)
 	    flags |= FULLPOLYFLAG;
-	  if ((polygon = CreateNewPolygonFromRectangle (CURRENT,
+	  if ((pour = CreateNewPourFromRectangle (CURRENT,
 							Crosshair.
 							AttachedBox.Point1.X,
 							Crosshair.
@@ -1352,10 +1354,10 @@ NotifyMode (void)
 							(flags))) !=
 	      NULL)
 	    {
-	      AddObjectToCreateUndoList (POLYGON_TYPE, CURRENT,
-					 polygon, polygon);
+	      AddObjectToCreateUndoList (POUR_TYPE, CURRENT,
+					 pour, pour);
 	      IncrementUndoSerialNumber ();
-	      DrawPolygon (CURRENT, polygon, 0);
+	      DrawPour (CURRENT, pour, 0);
 	      Draw ();
 	    }
 
@@ -1395,10 +1397,10 @@ NotifyMode (void)
 	break;
       }
 
-    case POLYGON_MODE:
+    case POUR_MODE:
       {
-	PointTypePtr points = Crosshair.AttachedPolygon.Points;
-	Cardinal n = Crosshair.AttachedPolygon.PointN;
+	PointTypePtr points = Crosshair.AttachedPour.Points;
+	Cardinal n = Crosshair.AttachedPour.PointN;
 
 	/* do update of position; use the 'LINE_MODE' mechanism */
 	NotifyLine ();
@@ -1408,7 +1410,7 @@ NotifyMode (void)
 	    points->X == Crosshair.AttachedLine.Point2.X &&
 	    points->Y == Crosshair.AttachedLine.Point2.Y)
 	  {
-	    CopyAttachedPolygonToLayer ();
+	    CopyAttachedPourToLayer ();
 	    Draw ();
 	    break;
 	  }
@@ -1420,9 +1422,9 @@ NotifyMode (void)
 	    points[n - 1].X != Crosshair.AttachedLine.Point2.X ||
 	    points[n - 1].Y != Crosshair.AttachedLine.Point2.Y)
 	  {
-	    CreateNewPointInPolygon (&Crosshair.AttachedPolygon,
-				     Crosshair.AttachedLine.Point2.X,
-				     Crosshair.AttachedLine.Point2.Y);
+	    CreateNewPointInPour (&Crosshair.AttachedPour,
+				  Crosshair.AttachedLine.Point2.X,
+				  Crosshair.AttachedLine.Point2.Y);
 
 	    /* copy the coordinates */
 	    Crosshair.AttachedLine.Point1.X = Crosshair.AttachedLine.Point2.X;
@@ -1615,15 +1617,13 @@ NotifyMode (void)
 		  /* get starting point of nearest segment */
 		  if (Crosshair.AttachedObject.Type == POLYGON_TYPE)
 		    {
-		      fake.poly =
-			(PolygonTypePtr) Crosshair.AttachedObject.Ptr2;
+		      fake.pour = (PourTypePtr) Crosshair.AttachedObject.Ptr2;
 		      polyIndex =
-			GetLowestDistancePolygonPoint (fake.poly, Note.X,
-						       Note.Y);
-		      fake.line.Point1 = fake.poly->Points[polyIndex];
+			GetLowestDistancePourPoint (fake.pour, Note.X, Note.Y);
+		      fake.line.Point1 = fake.pour->Points[polyIndex];
 		      fake.line.Point2 = (polyIndex) ?
-			fake.poly->Points[polyIndex - 1]
-			: fake.poly->Points[fake.poly->PointN - 1];
+			fake.pour->Points[polyIndex - 1]
+			: fake.pour->Points[fake.pour->PointN - 1];
 		      Crosshair.AttachedObject.Ptr2 = &fake.line;
 
 		    }
@@ -1635,9 +1635,9 @@ NotifyMode (void)
 
 	  /* second notify, insert new point into object */
 	case STATE_SECOND:
-	  if (Crosshair.AttachedObject.Type == POLYGON_TYPE)
-	    InsertPointIntoObject (POLYGON_TYPE,
-				   Crosshair.AttachedObject.Ptr1, fake.poly,
+	  if (Crosshair.AttachedObject.Type == POUR_TYPE)
+	    InsertPointIntoObject (POUR_TYPE,
+				   Crosshair.AttachedObject.Ptr1, fake.pour,
 				   &polyIndex,
 				   InsertedPoint.X, InsertedPoint.Y, False);
 	  else
@@ -2970,13 +2970,13 @@ ActionMode (int argc, char **argv, int x, int y)
 		  }
 		break;
 	  
-	      case POLYGON_MODE:
+	      case POUR_MODE:
 		if (Crosshair.AttachedLine.State == STATE_FIRST)
 		  SetMode (ARROW_MODE);
 		else
 		  {
 		    SetMode (NO_MODE);
-		    SetMode (POLYGON_MODE);
+		    SetMode (POUR_MODE);
 		  }
 		break;
 
@@ -3005,8 +3005,8 @@ ActionMode (int argc, char **argv, int x, int y)
 	case F_PasteBuffer:
 	  SetMode (PASTEBUFFER_MODE);
 	  break;
-	case F_Polygon:
-	  SetMode (POLYGON_MODE);
+	case F_Pour:
+	  SetMode (POUR_MODE);
 	  break;
 #ifndef HAVE_LIBSTROKE
 	case F_Release:
@@ -3050,9 +3050,9 @@ ActionMode (int argc, char **argv, int x, int y)
 	  else if (Settings.Mode == RECTANGLE_MODE
 		   && Crosshair.AttachedBox.State != STATE_FIRST)
 	    SetMode (RECTANGLE_MODE);
-	  else if (Settings.Mode == POLYGON_MODE
+	  else if (Settings.Mode == POUR_MODE
 		   && Crosshair.AttachedLine.State != STATE_FIRST)
-	    SetMode (POLYGON_MODE);
+	    SetMode (POUR_MODE);
 	  else
 	    {
 	      SaveMode ();
@@ -6033,9 +6033,9 @@ ActionUndo (int argc, char **argv, int x, int y)
       /* undo the last operation */
 
       HideCrosshair (True);
-      if (Settings.Mode == POLYGON_MODE && Crosshair.AttachedPolygon.PointN)
+      if (Settings.Mode == POUR_MODE && Crosshair.AttachedPour.PointN)
 	{
-	  GoToPreviousPoint ();
+	  GoToPreviousPourPoint ();
 	  RestoreCrosshair (True);
 	  return 0;
 	}
@@ -6195,8 +6195,8 @@ three "undone" lines.
 static int
 ActionRedo (int argc, char **argv, int x, int y)
 {
-  if ((Settings.Mode == POLYGON_MODE &&
-       Crosshair.AttachedPolygon.PointN) ||
+  if ((Settings.Mode == POUR_MODE &&
+       Crosshair.AttachedPour.PointN) ||
       Crosshair.AttachedLine.State == STATE_SECOND)
     return 1;
   HideCrosshair (True);
@@ -6246,19 +6246,19 @@ static int
 ActionPolygon (int argc, char **argv, int x, int y)
 {
   char *function = ARG (0);
-  if (function && Settings.Mode == POLYGON_MODE)
+  if (function && Settings.Mode == POUR_MODE)
     {
       HideCrosshair (True);
       switch (GetFunctionID (function))
 	{
-	  /* close open polygon if possible */
+	  /* close open pour if possible */
 	case F_Close:
-	  ClosePolygon ();
+	  ClosePour ();
 	  break;
 
 	  /* go back to the previous point */
 	case F_PreviousPoint:
-	  GoToPreviousPoint ();
+	  GoToPreviousPourPoint ();
 	  break;
 	}
       RestoreCrosshair (True);
diff --git a/src/autoroute.c b/src/autoroute.c
index 61ac386..f769d83 100644
--- a/src/autoroute.c
+++ b/src/autoroute.c
@@ -667,6 +667,8 @@ AddPolygon (PointerListType layergroupboxes[], Cardinal layer,
 			     polygon->BoundingBox.X2,
 			     polygon->BoundingBox.Y2,
 			     layergroup, polygon);
+#warning FIXME LATER
+#if 0
   if (polygon->PointN == 4 &&
       (polygon->Points[0].X == polygon->Points[1].X ||
        polygon->Points[0].Y == polygon->Points[1].Y) &&
@@ -677,6 +679,7 @@ AddPolygon (PointerListType layergroupboxes[], Cardinal layer,
       (polygon->Points[3].X == polygon->Points[0].X ||
        polygon->Points[3].Y == polygon->Points[0].Y))
     is_not_rectangle = 0;
+#endif
   rb->flags.nonstraight = is_not_rectangle;
   rb->layer = layer;
   if (TEST_FLAG (CLEARPOLYFLAG, polygon))
diff --git a/src/buffer.c b/src/buffer.c
index a88d11f..2405e75 100644
--- a/src/buffer.c
+++ b/src/buffer.c
@@ -50,6 +50,7 @@
 #include "misc.h"
 #include "parse_l.h"
 #include "polygon.h"
+#include "pour.h"
 #include "rats.h"
 #include "rotate.h"
 #include "remove.h"
@@ -72,7 +73,8 @@ static void *AddLineToBuffer (LayerTypePtr, LineTypePtr);
 static void *AddArcToBuffer (LayerTypePtr, ArcTypePtr);
 static void *AddRatToBuffer (RatTypePtr);
 static void *AddTextToBuffer (LayerTypePtr, TextTypePtr);
-static void *AddPolygonToBuffer (LayerTypePtr, PolygonTypePtr);
+//static void *AddPolygonToBuffer (LayerTypePtr, PolygonTypePtr);
+static void *AddPourToBuffer (LayerTypePtr, PourTypePtr);
 static void *AddElementToBuffer (ElementTypePtr);
 static void *MoveViaToBuffer (PinTypePtr);
 static void *MoveLineToBuffer (LayerTypePtr, LineTypePtr);
@@ -80,6 +82,7 @@ static void *MoveArcToBuffer (LayerTypePtr, ArcTypePtr);
 static void *MoveRatToBuffer (RatTypePtr);
 static void *MoveTextToBuffer (LayerTypePtr, TextTypePtr);
 static void *MovePolygonToBuffer (LayerTypePtr, PolygonTypePtr);
+static void *MovePourToBuffer (LayerTypePtr, PourTypePtr);
 static void *MoveElementToBuffer (ElementTypePtr);
 static void SwapBuffer (BufferTypePtr);
 
@@ -91,7 +94,9 @@ static DataTypePtr Dest, Source;
 static ObjectFunctionType AddBufferFunctions = {
   AddLineToBuffer,
   AddTextToBuffer,
-  AddPolygonToBuffer,
+#warning FIXME Later
+  NULL, //AddPolygonToBuffer,
+  AddPourToBuffer,
   AddViaToBuffer,
   AddElementToBuffer,
   NULL,
@@ -99,6 +104,7 @@ static ObjectFunctionType AddBufferFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   AddArcToBuffer,
   AddRatToBuffer
 }, MoveBufferFunctions =
@@ -107,9 +113,17 @@ static ObjectFunctionType AddBufferFunctions = {
 MoveLineToBuffer,
     MoveTextToBuffer,
     MovePolygonToBuffer,
+    MovePourToBuffer,
     MoveViaToBuffer,
     MoveElementToBuffer,
-    NULL, NULL, NULL, NULL, NULL, MoveArcToBuffer, MoveRatToBuffer};
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    MoveArcToBuffer,
+    MoveRatToBuffer};
 
 static int ExtraFlag = 0;
 
@@ -183,6 +197,8 @@ AddTextToBuffer (LayerTypePtr Layer, TextTypePtr Text)
 			 MaskFlags (Text->Flags, ExtraFlag)));
 }
 
+#warning FIXME Later
+#if 0
 /* ---------------------------------------------------------------------------
  * copies a polygon to buffer
  */
@@ -197,6 +213,22 @@ AddPolygonToBuffer (LayerTypePtr Layer, PolygonTypePtr Polygon)
   CLEAR_FLAG (FOUNDFLAG | ExtraFlag, polygon);
   return (polygon);
 }
+#endif
+
+/* ---------------------------------------------------------------------------
+ * copies a pour to buffer
+ */
+static void *
+AddPourToBuffer (LayerTypePtr Layer, PourTypePtr Pour)
+{
+  LayerTypePtr layer = &Dest->Layer[GetLayerNumber (Source, Layer)];
+  PourTypePtr pour;
+
+  pour = GetPourMemory (layer);
+  CopyPourLowLevel (pour, Pour);
+  CLEAR_FLAG (FOUNDFLAG | ExtraFlag, pour);
+  return (pour);
+}
 
 /* ---------------------------------------------------------------------------
  * copies a element to buffer
@@ -238,7 +270,7 @@ MoveViaToBuffer (PinTypePtr Via)
 {
   PinTypePtr via;
 
-  RestoreToPolygon (Source, VIA_TYPE, Via, Via);
+  RestoreToPour (Source, VIA_TYPE, Via, Via);
   r_delete_entry (Source->via_tree, (BoxType *) Via);
   via = GetViaMemory (Dest);
   *via = *Via;
@@ -250,7 +282,7 @@ MoveViaToBuffer (PinTypePtr Via)
   if (!Dest->via_tree)
     Dest->via_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (Dest->via_tree, (BoxType *) via, 0);
-  ClearFromPolygon (Dest, VIA_TYPE, via, via);
+  ClearFromPour (Dest, VIA_TYPE, via, via);
   return (via);
 }
 
@@ -285,7 +317,7 @@ MoveLineToBuffer (LayerTypePtr Layer, LineTypePtr Line)
   LayerTypePtr lay;
   LineTypePtr line;
 
-  RestoreToPolygon (Source, LINE_TYPE, Layer, Line);
+  RestoreToPour (Source, LINE_TYPE, Layer, Line);
   r_delete_entry (Layer->line_tree, (BoxTypePtr) Line);
   lay = &Dest->Layer[GetLayerNumber (Source, Layer)];
   line = GetLineMemory (lay);
@@ -299,7 +331,7 @@ MoveLineToBuffer (LayerTypePtr Layer, LineTypePtr Line)
   if (!lay->line_tree)
     lay->line_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (lay->line_tree, (BoxTypePtr) line, 0);
-  ClearFromPolygon (Dest, LINE_TYPE, lay, line);
+  ClearFromPour (Dest, LINE_TYPE, lay, line);
   return (line);
 }
 
@@ -312,7 +344,7 @@ MoveArcToBuffer (LayerTypePtr Layer, ArcTypePtr Arc)
   LayerTypePtr lay;
   ArcTypePtr arc;
 
-  RestoreToPolygon (Source, ARC_TYPE, Layer, Arc);
+  RestoreToPour (Source, ARC_TYPE, Layer, Arc);
   r_delete_entry (Layer->arc_tree, (BoxTypePtr) Arc);
   lay = &Dest->Layer[GetLayerNumber (Source, Layer)];
   arc = GetArcMemory (lay);
@@ -326,7 +358,7 @@ MoveArcToBuffer (LayerTypePtr Layer, ArcTypePtr Arc)
   if (!lay->arc_tree)
     lay->arc_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (lay->arc_tree, (BoxTypePtr) arc, 0);
-  ClearFromPolygon (Dest, ARC_TYPE, lay, arc);
+  ClearFromPour (Dest, ARC_TYPE, lay, arc);
   return (arc);
 }
 
@@ -340,7 +372,7 @@ MoveTextToBuffer (LayerTypePtr Layer, TextTypePtr Text)
   LayerTypePtr lay;
 
   r_delete_entry (Layer->text_tree, (BoxTypePtr) Text);
-  RestoreToPolygon (Source, TEXT_TYPE, Layer, Text);
+  RestoreToPour (Source, TEXT_TYPE, Layer, Text);
   lay = &Dest->Layer[GetLayerNumber (Source, Layer)];
   text = GetTextMemory (lay);
   *text = *Text;
@@ -351,7 +383,7 @@ MoveTextToBuffer (LayerTypePtr Layer, TextTypePtr Text)
   if (!lay->text_tree)
     lay->text_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (lay->text_tree, (BoxTypePtr) text, 0);
-  ClearFromPolygon (Dest, TEXT_TYPE, lay, text);
+  ClearFromPour (Dest, TEXT_TYPE, lay, text);
   return (text);
 }
 
@@ -364,7 +396,7 @@ MovePolygonToBuffer (LayerTypePtr Layer, PolygonTypePtr Polygon)
   LayerTypePtr lay;
   PolygonTypePtr polygon;
 
-  RestoreToPolygon (Source, POLYGON_TYPE, Layer, Polygon);
+  RestoreToPour (Source, POLYGON_TYPE, Layer, Polygon);
   r_delete_entry (Layer->polygon_tree, (BoxTypePtr) Polygon);
   lay = &Dest->Layer[GetLayerNumber (Source, Layer)];
   polygon = GetPolygonMemory (lay);
@@ -378,11 +410,38 @@ MovePolygonToBuffer (LayerTypePtr Layer, PolygonTypePtr Polygon)
   if (!lay->polygon_tree)
     lay->polygon_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (lay->polygon_tree, (BoxTypePtr) polygon, 0);
-  ClearFromPolygon (Source, POLYGON_TYPE, Layer, Polygon);
+  ClearFromPour (Source, POLYGON_TYPE, Layer, Polygon);
   return (polygon);
 }
 
 /* ---------------------------------------------------------------------------
+ * moves a pour to buffer. Doesn't allocate memory for the points
+ */
+static void *
+MovePourToBuffer (LayerTypePtr Layer, PourTypePtr Pour)
+{
+  LayerTypePtr lay;
+  PourTypePtr pour;
+
+  RestoreToPour (Source, POLYGON_TYPE, Layer, Pour);
+  r_delete_entry (Layer->pour_tree, (BoxTypePtr) Pour);
+  lay = &Dest->Layer[GetLayerNumber (Source, Layer)];
+  pour = GetPourMemory (lay);
+  *pour = *Pour;
+  CLEAR_FLAG (FOUNDFLAG, pour);
+  *Pour = Layer->Pour[--Layer->PourN];
+  r_substitute (Layer->pour_tree,
+		(BoxTypePtr) & Layer->Pour[Layer->PourN],
+		(BoxTypePtr) Pour);
+  memset (&Layer->Pour[Layer->PourN], 0, sizeof (PourType));
+  if (!lay->pour_tree)
+    lay->pour_tree = r_create_tree (NULL, 0, 0);
+  r_insert_entry (lay->pour_tree, (BoxTypePtr) pour, 0);
+  ClearFromPour (Source, POLYGON_TYPE, Layer, Pour);
+  return (pour);
+}
+
+/* ---------------------------------------------------------------------------
  * moves a element to buffer without allocating memory for pins/names
  */
 static void *
@@ -401,14 +460,14 @@ MoveElementToBuffer (ElementTypePtr Element)
   *element = *Element;
   PIN_LOOP (element);
   {
-    RestoreToPolygon(Source, PIN_TYPE, Element, pin);
+    RestoreToPour(Source, PIN_TYPE, Element, pin);
     CLEAR_FLAG (WARNFLAG | FOUNDFLAG, pin);
     pin->Element = element;
   }
   END_LOOP;
   PAD_LOOP (element);
   {
-    RestoreToPolygon(Source, PAD_TYPE, Element, pad);
+    RestoreToPour(Source, PAD_TYPE, Element, pad);
     CLEAR_FLAG (WARNFLAG | FOUNDFLAG, pad);
     pad->Element = element;
   }
@@ -424,12 +483,12 @@ MoveElementToBuffer (ElementTypePtr Element)
    */
   PIN_LOOP (element);
   {
-    ClearFromPolygon (Dest, PIN_TYPE, element, pin);
+    ClearFromPour (Dest, PIN_TYPE, element, pin);
   }
   END_LOOP;
   PAD_LOOP (element);
   {
-    ClearFromPolygon (Dest, PAD_TYPE, element, pad);
+    ClearFromPour (Dest, PAD_TYPE, element, pad);
   }
   END_LOOP;
 
@@ -658,6 +717,8 @@ SmashBufferElement (BufferTypePtr Buffer)
   return (True);
 }
 
+#warning FIXME Later
+#if 0
 /*---------------------------------------------------------------------------
  *
  * see if a polygon is a rectangle.  If so, canonicalize it.
@@ -694,6 +755,7 @@ polygon_is_rectangle (PolygonTypePtr poly)
     return 1;
   return 0;
 }
+#endif
 
 /*---------------------------------------------------------------------------
  *
@@ -760,6 +822,8 @@ ConvertBufferToElement (BufferTypePtr Buffer)
       hasParts = True;
     }
     END_LOOP;
+#warning FIXME Later
+#if 0
     POLYGON_LOOP (layer);
     {
       int x1, y1, x2, y2, w, h, t;
@@ -788,6 +852,7 @@ ConvertBufferToElement (BufferTypePtr Buffer)
       hasParts = True;
     }
     END_LOOP;
+#endif
   }
   END_LOOP;
   /* now get the opposite side pads */
@@ -947,6 +1012,13 @@ RotateBuffer (BufferTypePtr Buffer, BYTE Number)
     r_insert_entry (layer->polygon_tree, (BoxTypePtr) polygon, 0);
   }
   ENDALL_LOOP;
+  ALLPOUR_LOOP (Buffer->Data);
+  {
+    r_delete_entry (layer->pour_tree, (BoxTypePtr) pour);
+    RotatePourLowLevel (pour, Buffer->X, Buffer->Y, Number);
+    r_insert_entry (layer->pour_tree, (BoxTypePtr) pour, 0);
+  }
+  ENDALL_LOOP;
 
   /* finally the origin and the bounding box */
   ROTATE (Buffer->X, Buffer->Y, Buffer->X, Buffer->Y, Number);
@@ -998,7 +1070,7 @@ FreeRotateElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
     /* pre-delete the pins from the pin-tree before their coordinates change */
     if (Data)
       r_delete_entry (Data->pin_tree, (BoxType *) pin);
-    RestoreToPolygon (Data, PIN_TYPE, Element, pin);
+    RestoreToPour (Data, PIN_TYPE, Element, pin);
     free_rotate (&pin->X, &pin->Y, X, Y, cosa, sina);
     SetPinBoundingBox (pin);
   }
@@ -1008,7 +1080,7 @@ FreeRotateElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
     /* pre-delete the pads before their coordinates change */
     if (Data)
       r_delete_entry (Data->pad_tree, (BoxType *) pad);
-    RestoreToPolygon (Data, PAD_TYPE, Element, pad);
+    RestoreToPour (Data, PAD_TYPE, Element, pad);
     free_rotate (&pad->Point1.X, &pad->Point1.Y, X, Y, cosa, sina);
     free_rotate (&pad->Point2.X, &pad->Point2.Y, X, Y, cosa, sina);
     SetLineBoundingBox ((LineType *) pad);
@@ -1024,7 +1096,7 @@ FreeRotateElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
 
   free_rotate (&Element->MarkX, &Element->MarkY, X, Y, cosa, sina);
   SetElementBoundingBox (Data, Element, &PCB->Font);
-  ClearFromPolygon (Data, ELEMENT_TYPE, Element, Element);
+  ClearFromPour (Data, ELEMENT_TYPE, Element, Element);
 }
 
 void
@@ -1073,6 +1145,8 @@ FreeRotateBuffer (BufferTypePtr Buffer, double Angle)
   }
   ENDALL_LOOP;
   /* FIXME: rotate text */
+#warning FIXME Later
+#if 0
   ALLPOLYGON_LOOP (Buffer->Data);
   {
     r_delete_entry (layer->polygon_tree, (BoxTypePtr) polygon);
@@ -1085,6 +1159,19 @@ FreeRotateBuffer (BufferTypePtr Buffer, double Angle)
     r_insert_entry (layer->polygon_tree, (BoxTypePtr) polygon, 0);
   }
   ENDALL_LOOP;
+#endif
+  ALLPOUR_LOOP (Buffer->Data);
+  {
+    r_delete_entry (layer->pour_tree, (BoxTypePtr) pour);
+    POURPOINT_LOOP (pour);
+    {
+      free_rotate (&point->X, &point->Y, Buffer->X, Buffer->Y, cosa, sina);
+    }
+    END_LOOP;
+    SetPourBoundingBox (pour);
+    r_insert_entry (layer->pour_tree, (BoxTypePtr) pour, 0);
+  }
+  ENDALL_LOOP;
 
   SetBufferBoundingBox (Buffer);
 }
@@ -1165,6 +1252,8 @@ MirrorBuffer (BufferTypePtr Buffer)
     SetArcBoundingBox (arc);
   }
   ENDALL_LOOP;
+#warning FIXME Later
+#if 0
   ALLPOLYGON_LOOP (Buffer->Data);
   {
     POLYGONPOINT_LOOP (polygon);
@@ -1176,6 +1265,7 @@ MirrorBuffer (BufferTypePtr Buffer)
     SetPolygonBoundingBox (polygon);
   }
   ENDALL_LOOP;
+#endif
   SetBufferBoundingBox (Buffer);
 }
 
@@ -1230,6 +1320,8 @@ SwapBuffer (BufferTypePtr Buffer)
     r_insert_entry (layer->arc_tree, (BoxTypePtr) arc, 0);
   }
   ENDALL_LOOP;
+#warning FIXME Later
+#if 0
   ALLPOLYGON_LOOP (Buffer->Data);
   {
     r_delete_entry (layer->polygon_tree, (BoxTypePtr) polygon);
@@ -1244,6 +1336,7 @@ SwapBuffer (BufferTypePtr Buffer)
     /* hmmm, how to handle clip */
   }
   ENDALL_LOOP;
+#endif
   ALLTEXT_LOOP (Buffer->Data);
   {
     r_delete_entry (layer->text_tree, (BoxTypePtr) text);
diff --git a/src/change.c b/src/change.c
index e0ef99b..e567eec 100644
--- a/src/change.c
+++ b/src/change.c
@@ -50,6 +50,7 @@
 #include "misc.h"
 #include "mirror.h"
 #include "polygon.h"
+#include "pour.h"
 #include "rats.h"
 #include "remove.h"
 #include "rtree.h"
@@ -123,9 +124,13 @@ static void *ChangeTextJoin (LayerTypePtr, TextTypePtr);
 static void *SetTextJoin (LayerTypePtr, TextTypePtr);
 static void *ClrTextJoin (LayerTypePtr, TextTypePtr);
 static void *ChangePolyClear (LayerTypePtr, PolygonTypePtr);
+static void *ChangePourClear (LayerTypePtr, PourTypePtr);
 static void *ChangePolyJoin (LayerTypePtr, PolygonTypePtr);
+static void *ChangePourJoin (LayerTypePtr, PourTypePtr);
 static void *SetPolyJoin (LayerTypePtr, PolygonTypePtr);
+static void *SetPourJoin (LayerTypePtr, PourTypePtr);
 static void *ClrPolyJoin (LayerTypePtr, PolygonTypePtr);
+static void *ClrPourJoin (LayerTypePtr, PourTypePtr);
 
 /* ---------------------------------------------------------------------------
  * some local identifiers
@@ -137,6 +142,7 @@ static ObjectFunctionType ChangeSizeFunctions = {
   ChangeLineSize,
   ChangeTextSize,
   ChangePolyClear,
+  ChangePourClear,
   ChangeViaSize,
   ChangeElementSize,		/* changes silk screen line width */
   ChangeElementNameSize,
@@ -144,6 +150,7 @@ static ObjectFunctionType ChangeSizeFunctions = {
   ChangePadSize,
   NULL,
   NULL,
+  NULL,
   ChangeArcSize,
   NULL
 };
@@ -151,6 +158,7 @@ static ObjectFunctionType Change2ndSizeFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   ChangeVia2ndSize,
   ChangeElement2ndSize,
   NULL,
@@ -159,12 +167,14 @@ static ObjectFunctionType Change2ndSizeFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   NULL
 };
 static ObjectFunctionType ChangeThermalFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   ChangeViaThermal,
   NULL,
   NULL,
@@ -173,12 +183,14 @@ static ObjectFunctionType ChangeThermalFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   NULL
 };
 static ObjectFunctionType ChangeClearSizeFunctions = {
   ChangeLineClearSize,
   NULL,
   NULL,
+  NULL,
   ChangeViaClearSize,
   NULL,
   NULL,
@@ -186,6 +198,7 @@ static ObjectFunctionType ChangeClearSizeFunctions = {
   ChangePadClearSize,
   NULL,
   NULL,
+  NULL,
   ChangeArcClearSize,
   NULL
 };
@@ -193,6 +206,7 @@ static ObjectFunctionType ChangeNameFunctions = {
   ChangeLineName,
   ChangeTextName,
   NULL,
+  NULL,
   ChangeViaName,
   ChangeElementName,
   NULL,
@@ -201,6 +215,7 @@ static ObjectFunctionType ChangeNameFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   NULL
 };
 static ObjectFunctionType ChangeSquareFunctions = {
@@ -208,6 +223,7 @@ static ObjectFunctionType ChangeSquareFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   ChangeElementSquare,
   NULL,
   ChangePinSquare,
@@ -215,12 +231,15 @@ static ObjectFunctionType ChangeSquareFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   NULL
 };
 static ObjectFunctionType ChangeJoinFunctions = {
   ChangeLineJoin,
   ChangeTextJoin,
   ChangePolyJoin,
+  ChangePourJoin,
+  NULL,
   NULL,
   NULL,
   NULL,
@@ -235,6 +254,7 @@ static ObjectFunctionType ChangeOctagonFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   ChangeViaOctagon,
   ChangeElementOctagon,
   NULL,
@@ -243,12 +263,14 @@ static ObjectFunctionType ChangeOctagonFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   NULL
 };
 static ObjectFunctionType ChangeMaskSizeFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   ChangeViaMaskSize,
 #if 0
   ChangeElementMaskSize,
@@ -261,6 +283,7 @@ static ObjectFunctionType ChangeMaskSizeFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   NULL
 };
 static ObjectFunctionType SetSquareFunctions = {
@@ -268,6 +291,7 @@ static ObjectFunctionType SetSquareFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   SetElementSquare,
   NULL,
   SetPinSquare,
@@ -275,12 +299,15 @@ static ObjectFunctionType SetSquareFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   NULL
 };
 static ObjectFunctionType SetJoinFunctions = {
   SetLineJoin,
   SetTextJoin,
   SetPolyJoin,
+  SetPourJoin,
+  NULL,
   NULL,
   NULL,
   NULL,
@@ -295,6 +322,7 @@ static ObjectFunctionType SetOctagonFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   SetViaOctagon,
   SetElementOctagon,
   NULL,
@@ -303,6 +331,7 @@ static ObjectFunctionType SetOctagonFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   NULL
 };
 static ObjectFunctionType ClrSquareFunctions = {
@@ -310,6 +339,7 @@ static ObjectFunctionType ClrSquareFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   ClrElementSquare,
   NULL,
   ClrPinSquare,
@@ -317,12 +347,15 @@ static ObjectFunctionType ClrSquareFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   NULL
 };
 static ObjectFunctionType ClrJoinFunctions = {
   ClrLineJoin,
   ClrTextJoin,
   ClrPolyJoin,
+  ClrPourJoin,
+  NULL,
   NULL,
   NULL,
   NULL,
@@ -337,6 +370,7 @@ static ObjectFunctionType ClrOctagonFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   ClrViaOctagon,
   ClrElementOctagon,
   NULL,
@@ -345,6 +379,7 @@ static ObjectFunctionType ClrOctagonFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   NULL
 };
 
@@ -356,14 +391,14 @@ static void *
 ChangeViaThermal (PinTypePtr Via)
 {
   AddObjectToClearPolyUndoList (VIA_TYPE, Via, Via, Via, False);
-  RestoreToPolygon (PCB->Data, VIA_TYPE, CURRENT, Via);
+  RestoreToPour (PCB->Data, VIA_TYPE, CURRENT, Via);
   AddObjectToFlagUndoList (VIA_TYPE, Via, Via, Via);
   if (!Delta)			/* remove the thermals */
     CLEAR_THERM (INDEXOFCURRENT, Via);
   else
     ASSIGN_THERM (INDEXOFCURRENT, Delta, Via);
   AddObjectToClearPolyUndoList (VIA_TYPE, Via, Via, Via, True);
-  ClearFromPolygon (PCB->Data, VIA_TYPE, CURRENT, Via);
+  ClearFromPour (PCB->Data, VIA_TYPE, CURRENT, Via);
   DrawVia (Via, 0);
   return Via;
 }
@@ -376,14 +411,14 @@ static void *
 ChangePinThermal (ElementTypePtr element, PinTypePtr Pin)
 {
   AddObjectToClearPolyUndoList (PIN_TYPE, element, Pin, Pin, False);
-  RestoreToPolygon (PCB->Data, VIA_TYPE, CURRENT, Pin);
+  RestoreToPour (PCB->Data, VIA_TYPE, CURRENT, Pin);
   AddObjectToFlagUndoList (PIN_TYPE, element, Pin, Pin);
   if (!Delta)			/* remove the thermals */
     CLEAR_THERM (INDEXOFCURRENT, Pin);
   else
     ASSIGN_THERM (INDEXOFCURRENT, Delta, Pin);
   AddObjectToClearPolyUndoList (PIN_TYPE, element, Pin, Pin, True);
-  ClearFromPolygon (PCB->Data, VIA_TYPE, CURRENT, Pin);
+  ClearFromPour (PCB->Data, VIA_TYPE, CURRENT, Pin);
   DrawPin (Pin, 0);
   return Pin;
 }
@@ -407,7 +442,7 @@ ChangeViaSize (PinTypePtr Via)
       AddObjectToSizeUndoList (VIA_TYPE, Via, Via, Via);
       EraseVia (Via);
       r_delete_entry (PCB->Data->via_tree, (BoxType *) Via);
-      RestoreToPolygon (PCB->Data, PIN_TYPE, Via, Via);
+      RestoreToPour (PCB->Data, PIN_TYPE, Via, Via);
       if (Via->Mask)
 	{
 	  AddObjectToMaskSizeUndoList (VIA_TYPE, Via, Via, Via);
@@ -416,7 +451,7 @@ ChangeViaSize (PinTypePtr Via)
       Via->Thickness = value;
       SetPinBoundingBox (Via);
       r_insert_entry (PCB->Data->via_tree, (BoxType *) Via, 0);
-      ClearFromPolygon (PCB->Data, VIA_TYPE, Via, Via);
+      ClearFromPour (PCB->Data, VIA_TYPE, Via, Via);
       DrawVia (Via, 0);
       return (Via);
     }
@@ -445,10 +480,10 @@ ChangeVia2ndSize (PinTypePtr Via)
       Via->DrillingHole = value;
       if (TEST_FLAG (HOLEFLAG, Via))
 	{
-	  RestoreToPolygon (PCB->Data, VIA_TYPE, Via, Via);
+	  RestoreToPour (PCB->Data, VIA_TYPE, Via, Via);
 	  AddObjectToSizeUndoList (VIA_TYPE, Via, Via, Via);
 	  Via->Thickness = value;
-	  ClearFromPolygon (PCB->Data, VIA_TYPE, Via, Via);
+	  ClearFromPour (PCB->Data, VIA_TYPE, Via, Via);
 	}
       DrawVia (Via, 0);
       return (Via);
@@ -477,14 +512,14 @@ ChangeViaClearSize (PinTypePtr Via)
     value = PCB->Bloat * 2 + 2;
   if (Via->Clearance == value)
     return NULL;
-  RestoreToPolygon (PCB->Data, VIA_TYPE, Via, Via);
+  RestoreToPour (PCB->Data, VIA_TYPE, Via, Via);
   AddObjectToClearSizeUndoList (VIA_TYPE, Via, Via, Via);
   EraseVia (Via);
   r_delete_entry (PCB->Data->via_tree, (BoxType *) Via);
   Via->Clearance = value;
   SetPinBoundingBox (Via);
   r_insert_entry (PCB->Data->via_tree, (BoxType *) Via, 0);
-  ClearFromPolygon (PCB->Data, VIA_TYPE, Via, Via);
+  ClearFromPour (PCB->Data, VIA_TYPE, Via, Via);
   DrawVia (Via, 0);
   Via->Element = NULL;
   return (Via);
@@ -511,12 +546,12 @@ ChangePinSize (ElementTypePtr Element, PinTypePtr Pin)
       AddObjectToMaskSizeUndoList (PIN_TYPE, Element, Pin, Pin);
       ErasePin (Pin);
       r_delete_entry (PCB->Data->pin_tree, &Pin->BoundingBox);
-      RestoreToPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+      RestoreToPour (PCB->Data, PIN_TYPE, Element, Pin);
       Pin->Mask += value - Pin->Thickness;
       Pin->Thickness = value;
       /* SetElementBB updates all associated rtrees */
       SetElementBoundingBox (PCB->Data, Element, &PCB->Font);
-      ClearFromPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+      ClearFromPour (PCB->Data, PIN_TYPE, Element, Pin);
       DrawPin (Pin, 0);
       return (Pin);
     }
@@ -537,14 +572,14 @@ ChangePinClearSize (ElementTypePtr Element, PinTypePtr Pin)
   value = MIN (MAX_LINESIZE, MAX (value, PCB->Bloat * 2 + 2));
   if (Pin->Clearance == value)
     return NULL;
-  RestoreToPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+  RestoreToPour (PCB->Data, PIN_TYPE, Element, Pin);
   AddObjectToClearSizeUndoList (PIN_TYPE, Element, Pin, Pin);
   ErasePin (Pin);
   r_delete_entry (PCB->Data->pin_tree, &Pin->BoundingBox);
   Pin->Clearance = value;
   /* SetElementBB updates all associated rtrees */
   SetElementBoundingBox (PCB->Data, Element, &PCB->Font);
-  ClearFromPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+  ClearFromPour (PCB->Data, PIN_TYPE, Element, Pin);
   DrawPin (Pin, 0);
   return (Pin);
 }
@@ -564,14 +599,14 @@ ChangePadSize (ElementTypePtr Element, PadTypePtr Pad)
     {
       AddObjectToSizeUndoList (PAD_TYPE, Element, Pad, Pad);
       AddObjectToMaskSizeUndoList (PAD_TYPE, Element, Pad, Pad);
-      RestoreToPolygon (PCB->Data, PAD_TYPE, Element, Pad);
+      RestoreToPour (PCB->Data, PAD_TYPE, Element, Pad);
       ErasePad (Pad);
       r_delete_entry (PCB->Data->pad_tree, &Pad->BoundingBox);
       Pad->Mask += value - Pad->Thickness;
       Pad->Thickness = value;
       /* SetElementBB updates all associated rtrees */
       SetElementBoundingBox (PCB->Data, Element, &PCB->Font);
-      ClearFromPolygon (PCB->Data, PAD_TYPE, Element, Pad);
+      ClearFromPour (PCB->Data, PAD_TYPE, Element, Pad);
       DrawPad (Pad, 0);
       return (Pad);
     }
@@ -593,13 +628,13 @@ ChangePadClearSize (ElementTypePtr Element, PadTypePtr Pad)
   if (value <= MAX_PADSIZE && value >= MIN_PADSIZE && value != Pad->Clearance)
     {
       AddObjectToClearSizeUndoList (PAD_TYPE, Element, Pad, Pad);
-      RestoreToPolygon (PCB->Data, PAD_TYPE, Element, Pad);
+      RestoreToPour (PCB->Data, PAD_TYPE, Element, Pad);
       ErasePad (Pad);
       r_delete_entry (PCB->Data->pad_tree, &Pad->BoundingBox);
       Pad->Clearance = value;
       /* SetElementBB updates all associated rtrees */
       SetElementBoundingBox (PCB->Data, Element, &PCB->Font);
-      ClearFromPolygon (PCB->Data, PAD_TYPE, Element, Pad);
+      ClearFromPour (PCB->Data, PAD_TYPE, Element, Pad);
       DrawPad (Pad, 0);
       return (Pad);
     }
@@ -635,10 +670,10 @@ ChangeElement2ndSize (ElementTypePtr Element)
 	DrawPin (pin, 0);
 	if (TEST_FLAG (HOLEFLAG, pin))
 	  {
-	    RestoreToPolygon (PCB->Data, PIN_TYPE, Element, pin);
+	    RestoreToPour (PCB->Data, PIN_TYPE, Element, pin);
 	    AddObjectToSizeUndoList (PIN_TYPE, Element, pin, pin);
 	    pin->Thickness = value;
-	    ClearFromPolygon (PCB->Data, PIN_TYPE, Element, pin);
+	    ClearFromPour (PCB->Data, PIN_TYPE, Element, pin);
 	  }
       }
   }
@@ -672,10 +707,10 @@ ChangePin2ndSize (ElementTypePtr Element, PinTypePtr Pin)
       DrawPin (Pin, 0);
       if (TEST_FLAG (HOLEFLAG, Pin))
 	{
-	  RestoreToPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+	  RestoreToPour (PCB->Data, PIN_TYPE, Element, Pin);
 	  AddObjectToSizeUndoList (PIN_TYPE, Element, Pin, Pin);
 	  Pin->Thickness = value;
-	  ClearFromPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+	  ClearFromPour (PCB->Data, PIN_TYPE, Element, Pin);
 	}
       return (Pin);
     }
@@ -699,11 +734,11 @@ ChangeLineSize (LayerTypePtr Layer, LineTypePtr Line)
       AddObjectToSizeUndoList (LINE_TYPE, Layer, Line, Line);
       EraseLine (Line);
       r_delete_entry (Layer->line_tree, (BoxTypePtr) Line);
-      RestoreToPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+      RestoreToPour (PCB->Data, LINE_TYPE, Layer, Line);
       Line->Thickness = value;
       SetLineBoundingBox (Line);
       r_insert_entry (Layer->line_tree, (BoxTypePtr) Line, 0);
-      ClearFromPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+      ClearFromPour (PCB->Data, LINE_TYPE, Layer, Line);
       DrawLine (Layer, Line, 0);
       return (Line);
     }
@@ -725,7 +760,7 @@ ChangeLineClearSize (LayerTypePtr Layer, LineTypePtr Line)
   if (value != Line->Clearance)
     {
       AddObjectToClearSizeUndoList (LINE_TYPE, Layer, Line, Line);
-      RestoreToPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+      RestoreToPour (PCB->Data, LINE_TYPE, Layer, Line);
       EraseLine (Line);
       r_delete_entry (Layer->line_tree, (BoxTypePtr) Line);
       Line->Clearance = value;
@@ -736,7 +771,7 @@ ChangeLineClearSize (LayerTypePtr Layer, LineTypePtr Line)
 	}
       SetLineBoundingBox (Line);
       r_insert_entry (Layer->line_tree, (BoxTypePtr) Line, 0);
-      ClearFromPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+      ClearFromPour (PCB->Data, LINE_TYPE, Layer, Line);
       DrawLine (Layer, Line, 0);
       return (Line);
     }
@@ -760,11 +795,11 @@ ChangeArcSize (LayerTypePtr Layer, ArcTypePtr Arc)
       AddObjectToSizeUndoList (ARC_TYPE, Layer, Arc, Arc);
       EraseArc (Arc);
       r_delete_entry (Layer->arc_tree, (BoxTypePtr) Arc);
-      RestoreToPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
+      RestoreToPour (PCB->Data, ARC_TYPE, Layer, Arc);
       Arc->Thickness = value;
       SetArcBoundingBox (Arc);
       r_insert_entry (Layer->arc_tree, (BoxTypePtr) Arc, 0);
-      ClearFromPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
+      ClearFromPour (PCB->Data, ARC_TYPE, Layer, Arc);
       DrawArc (Layer, Arc, 0);
       return (Arc);
     }
@@ -788,7 +823,7 @@ ChangeArcClearSize (LayerTypePtr Layer, ArcTypePtr Arc)
       AddObjectToClearSizeUndoList (ARC_TYPE, Layer, Arc, Arc);
       EraseArc (Arc);
       r_delete_entry (Layer->arc_tree, (BoxTypePtr) Arc);
-      RestoreToPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
+      RestoreToPour (PCB->Data, ARC_TYPE, Layer, Arc);
       Arc->Clearance = value;
       if (Arc->Clearance == 0)
 	{
@@ -797,7 +832,7 @@ ChangeArcClearSize (LayerTypePtr Layer, ArcTypePtr Arc)
 	}
       SetArcBoundingBox (Arc);
       r_insert_entry (Layer->arc_tree, (BoxTypePtr) Arc, 0);
-      ClearFromPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
+      ClearFromPour (PCB->Data, ARC_TYPE, Layer, Arc);
       DrawArc (Layer, Arc, 0);
       return (Arc);
     }
@@ -821,11 +856,11 @@ ChangeTextSize (LayerTypePtr Layer, TextTypePtr Text)
       AddObjectToSizeUndoList (TEXT_TYPE, Layer, Text, Text);
       EraseText (Layer, Text);
       r_delete_entry (Layer->text_tree, (BoxTypePtr) Text);
-      RestoreToPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+      RestoreToPour (PCB->Data, TEXT_TYPE, Layer, Text);
       Text->Scale = value;
       SetTextBoundingBox (&PCB->Font, Text);
       r_insert_entry (Layer->text_tree, (BoxTypePtr) Text, 0);
-      ClearFromPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+      ClearFromPour (PCB->Data, TEXT_TYPE, Layer, Text);
       DrawText (Layer, Text, 0);
       return (Text);
     }
@@ -1026,12 +1061,12 @@ ChangeTextName (LayerTypePtr Layer, TextTypePtr Text)
   if (TEST_FLAG (LOCKFLAG, Text))
     return (NULL);
   EraseText (Layer, Text);
-  RestoreToPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+  RestoreToPour (PCB->Data, TEXT_TYPE, Layer, Text);
   Text->TextString = NewName;
 
   /* calculate size of the bounding box */
   SetTextBoundingBox (&PCB->Font, Text);
-  ClearFromPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+  ClearFromPour (PCB->Data, TEXT_TYPE, Layer, Text);
   DrawText (Layer, Text, 0);
   return (old);
 }
@@ -1086,14 +1121,14 @@ ChangeLineJoin (LayerTypePtr Layer, LineTypePtr Line)
   if (TEST_FLAG(CLEARLINEFLAG, Line))
   {
   AddObjectToClearPolyUndoList (LINE_TYPE, Layer, Line, Line, False);
-  RestoreToPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+  RestoreToPour (PCB->Data, LINE_TYPE, Layer, Line);
   }
   AddObjectToFlagUndoList (LINE_TYPE, Layer, Line, Line);
   TOGGLE_FLAG (CLEARLINEFLAG, Line);
   if (TEST_FLAG(CLEARLINEFLAG, Line))
   {
   AddObjectToClearPolyUndoList (LINE_TYPE, Layer, Line, Line, True);
-  ClearFromPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+  ClearFromPour (PCB->Data, LINE_TYPE, Layer, Line);
   }
   DrawLine (Layer, Line, 0);
   return (Line);
@@ -1132,14 +1167,14 @@ ChangeArcJoin (LayerTypePtr Layer, ArcTypePtr Arc)
   EraseArc (Arc);
   if (TEST_FLAG (CLEARLINEFLAG, Arc))
   {
-    RestoreToPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
+    RestoreToPour (PCB->Data, ARC_TYPE, Layer, Arc);
     AddObjectToClearPolyUndoList (ARC_TYPE, Layer, Arc, Arc, False);
     }
   AddObjectToFlagUndoList (ARC_TYPE, Layer, Arc, Arc);
   TOGGLE_FLAG (CLEARLINEFLAG, Arc);
   if (TEST_FLAG (CLEARLINEFLAG, Arc))
   {
-    ClearFromPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
+    ClearFromPour (PCB->Data, ARC_TYPE, Layer, Arc);
   AddObjectToClearPolyUndoList (ARC_TYPE, Layer, Arc, Arc, True);
   }
   DrawArc (Layer, Arc, 0);
@@ -1180,14 +1215,14 @@ ChangeTextJoin (LayerTypePtr Layer, TextTypePtr Text)
   if (TEST_FLAG(CLEARLINEFLAG, Text))
   {
   AddObjectToClearPolyUndoList (TEXT_TYPE, Layer, Text, Text, False);
-  RestoreToPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+  RestoreToPour (PCB->Data, TEXT_TYPE, Layer, Text);
   }
   AddObjectToFlagUndoList (LINE_TYPE, Layer, Text, Text);
   TOGGLE_FLAG (CLEARLINEFLAG, Text);
   if (TEST_FLAG(CLEARLINEFLAG, Text))
   {
   AddObjectToClearPolyUndoList (TEXT_TYPE, Layer, Text, Text, True);
-  ClearFromPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+  ClearFromPour (PCB->Data, TEXT_TYPE, Layer, Text);
   }
   DrawText (Layer, Text, 0);
   return (Text);
@@ -1205,20 +1240,45 @@ ChangePolyJoin (LayerTypePtr Layer, PolygonTypePtr poly)
   if (TEST_FLAG(CLEARLINEFLAG, poly))
   {
   AddObjectToClearPolyUndoList (POLYGON_TYPE, Layer, poly, poly, False);
-  RestoreToPolygon (PCB->Data, POLYGON_TYPE, Layer, poly);
+  RestoreToPour (PCB->Data, POLYGON_TYPE, Layer, poly);
   }
   AddObjectToFlagUndoList (LINE_TYPE, Layer, poly, poly);
   TOGGLE_FLAG (CLEARLINEFLAG, poly);
   if (TEST_FLAG(CLEARLINEFLAG, poly))
   {
   AddObjectToClearPolyUndoList (POLYGON_TYPE, Layer, poly, poly, True);
-  ClearFromPolygon (PCB->Data, POLYGON_TYPE, Layer, poly);
+  ClearFromPour (PCB->Data, POLYGON_TYPE, Layer, poly);
   }
   DrawPolygon (Layer, poly, 0);
   return (poly);
 }
 
 /* ---------------------------------------------------------------------------
+ * changes the clearance flag of a pour
+ */
+static void *
+ChangePourJoin (LayerTypePtr Layer, PourTypePtr pour)
+{
+  if (TEST_FLAG (LOCKFLAG, pour))
+    return (NULL);
+  ErasePour (pour);
+  if (TEST_FLAG(CLEARLINEFLAG, pour))
+  {
+  AddObjectToClearPourUndoList (POLYGON_TYPE, Layer, pour, pour, False);
+  RestoreToPour (PCB->Data, POLYGON_TYPE, Layer, pour);
+  }
+  AddObjectToFlagUndoList (LINE_TYPE, Layer, pour, pour);
+  TOGGLE_FLAG (CLEARLINEFLAG, pour);
+  if (TEST_FLAG(CLEARLINEFLAG, pour))
+  {
+  AddObjectToClearPourUndoList (POLYGON_TYPE, Layer, pour, pour, True);
+  ClearFromPour (PCB->Data, POLYGON_TYPE, Layer, pour);
+  }
+  DrawPour (Layer, pour, 0);
+  return (pour);
+}
+
+/* ---------------------------------------------------------------------------
  * sets the clearance flag of a text
  */
 static void *
@@ -1241,6 +1301,17 @@ SetPolyJoin (LayerTypePtr Layer, PolygonTypePtr poly)
 }
 
 /* ---------------------------------------------------------------------------
+ * sets the clearance flag of a pour
+ */
+static void *
+SetPourJoin (LayerTypePtr Layer, PourTypePtr pour)
+{
+  if (TEST_FLAG (LOCKFLAG, pour) || TEST_FLAG (CLEARLINEFLAG, pour))
+    return (NULL);
+  return ChangePourJoin (Layer, pour);
+}
+
+/* ---------------------------------------------------------------------------
  * clears the clearance flag of a text
  */
 static void *
@@ -1263,6 +1334,17 @@ ClrPolyJoin (LayerTypePtr Layer, PolygonTypePtr poly)
 }
 
 /* ---------------------------------------------------------------------------
+ * clears the clearance flag of a pour
+ */
+static void *
+ClrPourJoin (LayerTypePtr Layer, PourTypePtr pour)
+{
+  if (TEST_FLAG (LOCKFLAG, pour) || !TEST_FLAG (CLEARLINEFLAG, pour))
+    return (NULL);
+  return ChangePourJoin (Layer, pour);
+}
+
+/* ---------------------------------------------------------------------------
  * changes the square flag of all pins on an element
  */
 static void *
@@ -1398,11 +1480,11 @@ ChangePadSquare (ElementTypePtr Element, PadTypePtr Pad)
     return (NULL);
   ErasePad (Pad);
   AddObjectToClearPolyUndoList (PAD_TYPE, Element, Pad, Pad, False);
-  RestoreToPolygon (PCB->Data, PAD_TYPE, Element, Pad);
+  RestoreToPour (PCB->Data, PAD_TYPE, Element, Pad);
   AddObjectToFlagUndoList (PAD_TYPE, Element, Pad, Pad);
   TOGGLE_FLAG (SQUAREFLAG, Pad);
   AddObjectToClearPolyUndoList (PAD_TYPE, Element, Pad, Pad, True);
-  ClearFromPolygon (PCB->Data, PAD_TYPE, Element, Pad);
+  ClearFromPour (PCB->Data, PAD_TYPE, Element, Pad);
   DrawPad (Pad, 0);
   return (Pad);
 }
@@ -1445,11 +1527,11 @@ ChangePinSquare (ElementTypePtr Element, PinTypePtr Pin)
     return (NULL);
   ErasePin (Pin);
   AddObjectToClearPolyUndoList (PIN_TYPE, Element, Pin, Pin, False);
-  RestoreToPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+  RestoreToPour (PCB->Data, PIN_TYPE, Element, Pin);
   AddObjectToFlagUndoList (PIN_TYPE, Element, Pin, Pin);
   TOGGLE_FLAG (SQUAREFLAG, Pin);
   AddObjectToClearPolyUndoList (PIN_TYPE, Element, Pin, Pin, True);
-  ClearFromPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+  ClearFromPour (PCB->Data, PIN_TYPE, Element, Pin);
   DrawPin (Pin, 0);
   return (Pin);
 }
@@ -1488,11 +1570,11 @@ ChangeViaOctagon (PinTypePtr Via)
     return (NULL);
   EraseVia (Via);
   AddObjectToClearPolyUndoList (VIA_TYPE, Via, Via, Via, False);
-  RestoreToPolygon (PCB->Data, VIA_TYPE, Via, Via);
+  RestoreToPour (PCB->Data, VIA_TYPE, Via, Via);
   AddObjectToFlagUndoList (VIA_TYPE, Via, Via, Via);
   TOGGLE_FLAG (OCTAGONFLAG, Via);
   AddObjectToClearPolyUndoList (VIA_TYPE, Via, Via, Via, True);
-  ClearFromPolygon (PCB->Data, VIA_TYPE, Via, Via);
+  ClearFromPour (PCB->Data, VIA_TYPE, Via, Via);
   DrawVia (Via, 0);
   return (Via);
 }
@@ -1531,11 +1613,11 @@ ChangePinOctagon (ElementTypePtr Element, PinTypePtr Pin)
     return (NULL);
   ErasePin (Pin);
   AddObjectToClearPolyUndoList (PIN_TYPE, Element, Pin, Pin, False);
-  RestoreToPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+  RestoreToPour (PCB->Data, PIN_TYPE, Element, Pin);
   AddObjectToFlagUndoList (PIN_TYPE, Element, Pin, Pin);
   TOGGLE_FLAG (OCTAGONFLAG, Pin);
   AddObjectToClearPolyUndoList (PIN_TYPE, Element, Pin, Pin, True);
-  ClearFromPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+  ClearFromPour (PCB->Data, PIN_TYPE, Element, Pin);
   DrawPin (Pin, 0);
   return (Pin);
 }
@@ -1577,10 +1659,10 @@ ChangeHole (PinTypePtr Via)
   TOGGLE_FLAG (HOLEFLAG, Via);
   if (TEST_FLAG (HOLEFLAG, Via))
     {
-      RestoreToPolygon (PCB->Data, VIA_TYPE, Via, Via);
+      RestoreToPour (PCB->Data, VIA_TYPE, Via, Via);
       AddObjectToSizeUndoList (VIA_TYPE, Via, Via, Via);
       Via->Thickness = Via->Mask = Via->DrillingHole;
-      ClearFromPolygon (PCB->Data, VIA_TYPE, Via, Via);
+      ClearFromPour (PCB->Data, VIA_TYPE, Via, Via);
     }
   else
     {
@@ -1624,6 +1706,22 @@ ChangePolyClear (LayerTypePtr Layer, PolygonTypePtr Polygon)
   return (Polygon);
 }
 
+/* ---------------------------------------------------------------------------
+ * changes the CLEARPOLY flag of a pour
+ */
+static void *
+ChangePourClear (LayerTypePtr Layer, PourTypePtr Pour)
+{
+  if (TEST_FLAG (LOCKFLAG, Pour))
+    return (NULL);
+  AddObjectToClearPourUndoList (POLYGON_TYPE, Layer, Pour, Pour, True);
+  AddObjectToFlagUndoList (POLYGON_TYPE, Layer, Pour, Pour);
+  TOGGLE_FLAG (CLEARPOLYFLAG, Pour);
+  InitPourClip (PCB->Data, Layer, Pour);
+  DrawPour (Layer, Pour, 0);
+  return (Pour);
+}
+
 /* ----------------------------------------------------------------------
  * changes the side of all selected and visible elements 
  * returns True if anything has changed
diff --git a/src/const.h b/src/const.h
index 3647c3b..c2fa83b 100644
--- a/src/const.h
+++ b/src/const.h
@@ -78,7 +78,8 @@
 #define	VIA_MODE		1	/* draw vias */
 #define	LINE_MODE		2	/* draw lines */
 #define	RECTANGLE_MODE		3	/* create rectangles */
-#define	POLYGON_MODE		4	/* draw filled polygons */
+//#define	POLYGON_MODE		4	/* draw filled polygons */
+#define	POUR_MODE		4	/* draw poured areas */
 #define	PASTEBUFFER_MODE	5	/* paste objects from buffer */
 #define	TEXT_MODE		6	/* create text objects */
 #define	ROTATE_MODE		102	/* rotate objects */
@@ -303,10 +304,13 @@ New polygons are full ones.
 #define ELEMENTARC_TYPE		0x08000
 
 #define LOCKED_TYPE 		0x10000	/* used to tell search to include locked items. */
+#define POUR_TYPE 		0x20000
+#define POURPOINT_TYPE 		0x40000
 
 #define PIN_TYPES     (VIA_TYPE | PIN_TYPE)
-#define LOCK_TYPES    (VIA_TYPE | LINE_TYPE | ARC_TYPE | POLYGON_TYPE | ELEMENT_TYPE \
-                      | TEXT_TYPE | ELEMENTNAME_TYPE | LOCKED_TYPE)
+#define LOCK_TYPES    (VIA_TYPE | LINE_TYPE | ARC_TYPE | POLYGON_TYPE | \
+                       POUR_TYPE | ELEMENT_TYPE | \
+                       TEXT_TYPE | ELEMENTNAME_TYPE | LOCKED_TYPE)
 
 #define	ALL_TYPES		(~0)	/* all bits set */
 
diff --git a/src/copy.c b/src/copy.c
index 5a030c9..c315d68 100644
--- a/src/copy.c
+++ b/src/copy.c
@@ -47,7 +47,7 @@
 #include "mirror.h"
 #include "misc.h"
 #include "move.h"
-#include "polygon.h"
+#include "pour.h"
 #include "rats.h"
 #include "rtree.h"
 #include "select.h"
@@ -66,7 +66,8 @@ static void *CopyVia (PinTypePtr);
 static void *CopyLine (LayerTypePtr, LineTypePtr);
 static void *CopyArc (LayerTypePtr, ArcTypePtr);
 static void *CopyText (LayerTypePtr, TextTypePtr);
-static void *CopyPolygon (LayerTypePtr, PolygonTypePtr);
+//static void *CopyPolygon (LayerTypePtr, PolygonTypePtr);
+static void *CopyPour (LayerTypePtr, PourTypePtr);
 static void *CopyElement (ElementTypePtr);
 
 /* ---------------------------------------------------------------------------
@@ -76,7 +77,9 @@ static LocationType DeltaX, DeltaY;	/* movement vector */
 static ObjectFunctionType CopyFunctions = {
   CopyLine,
   CopyText,
-  CopyPolygon,
+#warning FIXME Later
+  NULL, //CopyPolygon,
+  CopyPour,
   CopyVia,
   CopyElement,
   NULL,
@@ -84,10 +87,13 @@ static ObjectFunctionType CopyFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   CopyArc,
   NULL
 };
 
+#warning FIXME Later
+#if 0
 /* ---------------------------------------------------------------------------
  * copies data from one polygon to another
  * 'Dest' has to exist
@@ -106,6 +112,26 @@ CopyPolygonLowLevel (PolygonTypePtr Dest, PolygonTypePtr Src)
   CLEAR_FLAG (FOUNDFLAG, Dest);
   return (Dest);
 }
+#endif
+
+/* ---------------------------------------------------------------------------
+ * copies data from one pour to another
+ * 'Dest' has to exist
+ */
+PourTypePtr
+CopyPourLowLevel (PourTypePtr Dest, PourTypePtr Src)
+{
+  /* copy all data */
+  POURPOINT_LOOP (Src);
+  {
+    CreateNewPointInPour (Dest, point->X, point->Y);
+  }
+  END_LOOP;
+  SetPourBoundingBox (Dest);
+  Dest->Flags = Src->Flags;
+  CLEAR_FLAG (FOUNDFLAG, Dest);
+  return (Dest);
+}
 
 /* ---------------------------------------------------------------------------
  * copies data from one element to another and creates the destination 
@@ -256,6 +282,8 @@ CopyText (LayerTypePtr Layer, TextTypePtr Text)
   return (text);
 }
 
+#warning FIXME Later
+#if 0
 /* ---------------------------------------------------------------------------
  * copies a polygon 
  */
@@ -275,6 +303,27 @@ CopyPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
   AddObjectToCreateUndoList (POLYGON_TYPE, Layer, polygon, polygon);
   return (polygon);
 }
+#endif
+
+/* ---------------------------------------------------------------------------
+ * copies a pour
+ */
+static void *
+CopyPour (LayerTypePtr Layer, PourTypePtr Pour)
+{
+  PourTypePtr pour;
+
+  pour = CreateNewPour (Layer, NoFlags ());
+  CopyPourLowLevel (pour, Pour);
+  MovePourLowLevel (pour, DeltaX, DeltaY);
+  if (!Layer->pour_tree)
+    Layer->pour_tree = r_create_tree (NULL, 0, 0);
+  r_insert_entry (Layer->pour_tree, (BoxTypePtr) pour, 0);
+  InitPourClip (PCB->Data, Layer, pour);
+  DrawPour (Layer, pour, 0);
+  AddObjectToCreateUndoList (POUR_TYPE, Layer, pour, pour);
+  return (pour);
+}
 
 /* ---------------------------------------------------------------------------
  * copies a element 
@@ -345,11 +394,19 @@ CopyPastebufferToLayout (LocationType X, LocationType Y)
 	    CopyText (destlayer, text);
 	  }
 	  END_LOOP;
+#warning FIXME Later
+#if 0
 	  POLYGON_LOOP (sourcelayer);
 	  {
 	    CopyPolygon (destlayer, polygon);
 	  }
 	  END_LOOP;
+#endif
+	  POUR_LOOP (sourcelayer);
+	  {
+	    CopyPour (destlayer, pour);
+	  }
+	  END_LOOP;
 	}
     }
 
diff --git a/src/copy.h b/src/copy.h
index 472fc75..9c9fb74 100644
--- a/src/copy.h
+++ b/src/copy.h
@@ -42,6 +42,7 @@
 
 
 PolygonTypePtr CopyPolygonLowLevel (PolygonTypePtr, PolygonTypePtr);
+PourTypePtr CopyPourLowLevel (PourTypePtr, PourTypePtr);
 ElementTypePtr CopyElementLowLevel (DataTypePtr, ElementTypePtr,
 				    ElementTypePtr, Boolean, LocationType, LocationType);
 Boolean CopyPastebufferToLayout (LocationType, LocationType);
diff --git a/src/create.c b/src/create.c
index d5ea0c9..8830d41 100644
--- a/src/create.c
+++ b/src/create.c
@@ -535,29 +535,28 @@ CreateNewArcOnLayer (LayerTypePtr Layer,
   return (Arc);
 }
 
-
 /* ---------------------------------------------------------------------------
- * creates a new polygon from the old formats rectangle data
+ * creates a new pour from the old formats rectangle data
  */
-PolygonTypePtr
-CreateNewPolygonFromRectangle (LayerTypePtr Layer,
+PourTypePtr
+CreateNewPourFromRectangle (LayerTypePtr Layer,
 			       LocationType X1, LocationType Y1,
 			       LocationType X2, LocationType Y2,
 			       FlagType Flags)
 {
-  PolygonTypePtr polygon = CreateNewPolygon (Layer, Flags);
-  if (!polygon)
-    return (polygon);
-
-  CreateNewPointInPolygon (polygon, X1, Y1);
-  CreateNewPointInPolygon (polygon, X2, Y1);
-  CreateNewPointInPolygon (polygon, X2, Y2);
-  CreateNewPointInPolygon (polygon, X1, Y2);
-  SetPolygonBoundingBox (polygon);
-  if (!Layer->polygon_tree)
-    Layer->polygon_tree = r_create_tree (NULL, 0, 0);
-  r_insert_entry (Layer->polygon_tree, (BoxTypePtr) polygon, 0);
-  return (polygon);
+  PourTypePtr pour = CreateNewPour (Layer, Flags);
+  if (!pour)
+    return (pour);
+
+  CreateNewPointInPour (pour, X1, Y1);
+  CreateNewPointInPour (pour, X2, Y1);
+  CreateNewPointInPour (pour, X2, Y2);
+  CreateNewPointInPour (pour, X1, Y2);
+  SetPourBoundingBox (pour);
+  if (!Layer->pour_tree)
+    Layer->pour_tree = r_create_tree (NULL, 0, 0);
+  r_insert_entry (Layer->pour_tree, (BoxTypePtr) pour, 0);
+  return (pour);
 }
 
 /* ---------------------------------------------------------------------------
@@ -605,18 +604,32 @@ CreateNewPolygon (LayerTypePtr Layer, FlagType Flags)
   polygon->Clipped = NULL;
   polygon->NoHoles = NULL;
   polygon->NoHolesValid = 0;
-  polygon->Parent = NULL;
+  polygon->ParentPour = NULL;
   return (polygon);
 }
 
 /* ---------------------------------------------------------------------------
- * creates a new point in a polygon
+ * creates a new pour on a layer
+ */
+PourTypePtr
+CreateNewPour (LayerTypePtr Layer, FlagType Flags)
+{
+  PourTypePtr pour = GetPourMemory (Layer);
+
+  /* copy values */
+  pour->Flags = Flags;
+  pour->ID = ID++;
+  return (pour);
+}
+
+/* ---------------------------------------------------------------------------
+ * creates a new point in a pour
  */
 PointTypePtr
-CreateNewPointInPolygon (PolygonTypePtr Polygon, LocationType X,
+CreateNewPointInPour (PourTypePtr Pour, LocationType X,
 			 LocationType Y)
 {
-  PointTypePtr point = GetPointMemoryInPolygon (Polygon);
+  PointTypePtr point = GetPointMemoryInPour (Pour);
 
   /* copy values */
   point->X = X;
diff --git a/src/create.h b/src/create.h
index 98bb525..7d5116e 100644
--- a/src/create.h
+++ b/src/create.h
@@ -54,13 +54,14 @@ RatTypePtr CreateNewRat (DataTypePtr, LocationType, LocationType,
 ArcTypePtr CreateNewArcOnLayer (LayerTypePtr, LocationType, LocationType,
 				BDimension, BDimension, int, int, BDimension, BDimension,
 				FlagType);
-PolygonTypePtr CreateNewPolygonFromRectangle (LayerTypePtr, LocationType,
+PourTypePtr CreateNewPourFromRectangle (LayerTypePtr, LocationType,
 					      LocationType, LocationType,
 					      LocationType, FlagType);
 TextTypePtr CreateNewText (LayerTypePtr, FontTypePtr, LocationType,
 			   LocationType, BYTE, int, char *, FlagType);
 PolygonTypePtr CreateNewPolygon (LayerTypePtr, FlagType);
-PointTypePtr CreateNewPointInPolygon (PolygonTypePtr,
+PourTypePtr CreateNewPour (LayerTypePtr, FlagType);
+PointTypePtr CreateNewPointInPour (PourTypePtr,
 				      LocationType, LocationType);
 void RefdesMapInit (void);
 ElementTypePtr CreateNewElement (DataTypePtr, ElementTypePtr,
diff --git a/src/crosshair.c b/src/crosshair.c
index 962253d..a34c86a 100644
--- a/src/crosshair.c
+++ b/src/crosshair.c
@@ -76,6 +76,7 @@ static int CrosshairStackLocation = 0;
  * some local prototypes
  */
 static void XORPolygon (PolygonTypePtr, LocationType, LocationType);
+static void XORPour (PourTypePtr, LocationType, LocationType);
 static void XORDrawElement (ElementTypePtr, LocationType, LocationType);
 static void XORDrawBuffer (BufferTypePtr);
 static void XORDrawInsertPointObject (void);
@@ -91,6 +92,8 @@ static void XORDrawAttachedArc (BDimension);
 static void
 XORPolygon (PolygonTypePtr polygon, LocationType dx, LocationType dy)
 {
+#warning FIXME Later
+#if 0
   int i;
   for (i = 0; i < polygon->PointN - 1; i++)
     gui->draw_line (Crosshair.GC,
@@ -101,6 +104,25 @@ XORPolygon (PolygonTypePtr polygon, LocationType dx, LocationType dy)
     gui->draw_line (Crosshair.GC,
 		    polygon->Points[i].X + dx, polygon->Points[i].Y + dy,
 		    polygon->Points[0].X + dx, polygon->Points[0].Y + dy);
+#endif
+}
+
+/* ---------------------------------------------------------------------------
+ * creates a tmp pour with coordinates converted to screen system
+ */
+static void
+XORPour (PourTypePtr pour, LocationType dx, LocationType dy)
+{
+  int i;
+  for (i = 0; i < pour->PointN - 1; i++)
+    gui->draw_line (Crosshair.GC,
+		    pour->Points[i].X + dx, pour->Points[i].Y + dy,
+		    pour->Points[i + 1].X + dx,
+		    pour->Points[i + 1].Y + dy);
+  if (i > 1)
+    gui->draw_line (Crosshair.GC,
+		    pour->Points[i].X + dx, pour->Points[i].Y + dy,
+		    pour->Points[0].X + dx, pour->Points[0].Y + dy);
 }
 
 /*-----------------------------------------------------------
@@ -450,6 +472,18 @@ XORDrawMoveOrCopyObject (void)
 	break;
       }
 
+    case POUR_TYPE:
+      {
+	PourTypePtr pour =
+	  (PourTypePtr) Crosshair.AttachedObject.Ptr2;
+
+	/* the tmp pour has n+1 points because the first
+	 * and the last one are set to the same coordinates
+	 */
+	XORPour (pour, dx, dy);
+	break;
+      }
+
     case LINEPOINT_TYPE:
       {
 	LineTypePtr line;
@@ -468,6 +502,8 @@ XORDrawMoveOrCopyObject (void)
 	break;
       }
 
+#warning FIXME Later
+#if 0
     case POLYGONPOINT_TYPE:
       {
 	PolygonTypePtr polygon;
@@ -502,6 +538,42 @@ XORDrawMoveOrCopyObject (void)
 			point->Y + dy, following->X, following->Y);
 	break;
       }
+#endif
+
+    case POURPOINT_TYPE:
+      {
+	PourTypePtr pour;
+	PointTypePtr point, previous, following;
+
+	pour = (PourTypePtr) Crosshair.AttachedObject.Ptr2;
+	point = (PointTypePtr) Crosshair.AttachedObject.Ptr3;
+
+	/* get previous and following point */
+	if (point == pour->Points)
+	  {
+	    previous = &pour->Points[pour->PointN - 1];
+	    following = point + 1;
+	  }
+	else if (point == &pour->Points[pour->PointN - 1])
+	  {
+	    previous = point - 1;
+	    following = &pour->Points[0];
+	  }
+	else
+	  {
+	    previous = point - 1;
+	    following = point + 1;
+	  }
+
+	/* draw the two segments */
+	gui->draw_line (Crosshair.GC,
+			previous->X,
+			previous->Y, point->X + dx, point->Y + dy);
+	gui->draw_line (Crosshair.GC,
+			point->X + dx,
+			point->Y + dy, following->X, following->Y);
+	break;
+      }
 
     case ELEMENTNAME_TYPE:
       {
@@ -596,8 +668,8 @@ DrawAttached (Boolean BlockToo)
 	}
       break;
 
-      /* the attached line is used by both LINEMODE and POLYGON_MODE */
-    case POLYGON_MODE:
+      /* the attached line is used by both LINEMODE and POUR_MODE */
+    case POUR_MODE:
       /* draw only if starting point is set */
       if (Crosshair.AttachedLine.State != STATE_FIRST)
 	gui->draw_line (Crosshair.GC,
@@ -606,10 +678,10 @@ DrawAttached (Boolean BlockToo)
 			Crosshair.AttachedLine.Point2.X,
 			Crosshair.AttachedLine.Point2.Y);
 
-      /* draw attached polygon only if in POLYGON_MODE */
-      if (Crosshair.AttachedPolygon.PointN > 1)
+      /* draw attached pour only if in POUR_MODE */
+      if (Crosshair.AttachedPour.PointN > 1)
 	{
-	  XORPolygon (&Crosshair.AttachedPolygon, 0, 0);
+	  XORPour (&Crosshair.AttachedPour, 0, 0);
 	}
       break;
 
@@ -1111,6 +1183,6 @@ void
 DestroyCrosshair (void)
 {
   CrosshairOff (True);
-  FreePolygonMemory (&Crosshair.AttachedPolygon);
+  FreePourMemory (&Crosshair.AttachedPour);
   gui->destroy_gc (Crosshair.GC);
 }
diff --git a/src/draw.c b/src/draw.c
index 0388f55..9868c95 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -101,6 +101,7 @@ static void DrawPadNameLowLevel (PadTypePtr);
 static void DrawLineLowLevel (LineTypePtr, Boolean);
 static void DrawRegularText (LayerTypePtr, TextTypePtr, int);
 static void DrawPolygonLowLevel (PolygonTypePtr, void *);
+static void DrawPourLowLevel (PourTypePtr, void *);
 static void DrawArcLowLevel (ArcTypePtr);
 static void DrawElementPackageLowLevel (ElementTypePtr Element, int);
 static void DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon);
@@ -683,6 +684,7 @@ clearPin_callback (const BoxType * b, void *cl)
     ClearOnlyPin (pin, True);
   return 1;
 }
+
 static int
 poly_callback (const BoxType * b, void *cl)
 {
@@ -693,6 +695,16 @@ poly_callback (const BoxType * b, void *cl)
 }
 
 static int
+pour_callback (const BoxType * b, void *cl)
+{
+  struct pin_info *i = (struct pin_info *) cl;
+
+//  DrawPlainPour (i->Layer, (PourTypePtr) b);
+  DrawPour (i->Layer, (PourTypePtr)b, 0);
+  return 1;
+}
+
+static int
 clearPad_callback (const BoxType * b, void *cl)
 {
   PadTypePtr pad = (PadTypePtr) b;
@@ -891,6 +903,8 @@ DrawLayer (LayerTypePtr Layer, BoxType * screen)
   clip_box = screen;
   r_search (Layer->polygon_tree, screen, NULL, poly_callback, &info);
 
+  r_search (Layer->pour_tree, screen, NULL, pour_callback, &info);
+
   /* draw all visible lines this layer */
   r_search (Layer->line_tree, screen, NULL, line_callback, Layer);
 
@@ -953,6 +967,15 @@ DrawLayerGroup (int group, const BoxType * screen)
 	      info.arg = False;
 	    }
 
+	  /* draw all pours on this layer */
+	  if (Layer->PourN)
+	    {
+	      info.Layer = Layer;
+	      info.arg = True;
+	      r_search (Layer->pour_tree, screen, NULL, pour_callback, &info);
+	      info.arg = False;
+	    }
+
 	  if (TEST_FLAG (CHECKPLANESFLAG, PCB))
 	    continue;
 
@@ -1771,6 +1794,49 @@ DrawPolygonLowLevel (PolygonTypePtr Polygon, void *data)
 }
 
 /* ---------------------------------------------------------------------------
+ * lowlevel drawing routine for pours
+ */
+static void
+DrawPourLowLevel (PourTypePtr Pour, void *data)
+{
+  int *x, *y, n, i;
+
+  if (Gathering)
+    {
+      AddPart (Pour);
+      return;
+    }
+
+  n = Pour->PointN;
+  x = (int *) malloc (n * sizeof (int));
+  y = (int *) malloc (n * sizeof (int));
+  for (i = 0; i < n; i++)
+    {
+      x[i] = Pour->Points[i].X;
+      y[i] = Pour->Points[i].Y;
+    }
+
+//  if (TEST_FLAG (THINDRAWFLAG, PCB) ||
+//      TEST_FLAG (THINDRAWPOLYFLAG, PCB) ||
+//      TEST_FLAG (CLEARLINEFLAG, Pour))
+  if (1)
+    {
+      gui->set_line_width (Output.fgGC, 2);
+//      gui->set_line_width (Output.fgGC, 1);
+      for (i = 0; i < n - 1; i++)
+	{
+	  gui->draw_line (Output.fgGC, x[i], y[i], x[i + 1], y[i + 1]);
+	  gui->fill_circle (Output.fgGC, x[i], y[i], 30);
+	}
+      gui->draw_line (Output.fgGC, x[n - 1], y[n - 1], x[0], y[0]);
+    }
+  else
+    gui->fill_polygon (Output.fgGC, n, x, y);
+  free (x);
+  free (y);
+}
+
+/* ---------------------------------------------------------------------------
  * lowlevel routine to element arcs
  */
 static void
@@ -2121,6 +2187,37 @@ DrawPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon, int unused)
     }
 }
 
+/* ---------------------------------------------------------------------------
+ * draws a pour on a layer
+ */
+void
+DrawPour (LayerTypePtr Layer, PourTypePtr Pour, int unused)
+{
+  int layernum;
+
+  if (TEST_FLAG (SELECTEDFLAG | FOUNDFLAG, Pour))
+    {
+      if (TEST_FLAG (SELECTEDFLAG, Pour))
+	gui->set_color (Output.fgGC, Layer->SelectedColor);
+      else
+	gui->set_color (Output.fgGC, PCB->ConnectedColor);
+    }
+  else
+    gui->set_color (Output.fgGC, Layer->Color);
+  layernum = GetLayerNumber (PCB->Data, Layer);
+  DrawPourLowLevel (Pour, NULL);
+#warning FIXME Later
+#if 0
+  if (TEST_FLAG (CLEARPOLYFLAG, Pour))
+    {
+      r_search (PCB->Data->pin_tree, &Pour->BoundingBox, NULL,
+		cp_callback, (void *) PIN_TYPE);
+      r_search (PCB->Data->via_tree, &Pour->BoundingBox, NULL,
+		cp_callback, (void *) VIA_TYPE);
+    }
+#endif
+}
+
 int
 thin_callback (PLINE * pl, LayerTypePtr lay, PolygonTypePtr poly)
 {
@@ -2522,6 +2619,18 @@ ErasePolygon (PolygonTypePtr Polygon)
 }
 
 /* ---------------------------------------------------------------------------
+ * erases a pour on a layer
+ */
+void
+ErasePour (PourTypePtr Pour)
+{
+  Erasing++;
+  gui->set_color (Output.fgGC, Settings.BackgroundColor);
+  DrawPourLowLevel (Pour, NULL);
+  Erasing--;
+}
+
+/* ---------------------------------------------------------------------------
  * erases an element
  */
 void
diff --git a/src/draw.h b/src/draw.h
index 47c4c7f..a0f423c 100644
--- a/src/draw.h
+++ b/src/draw.h
@@ -51,6 +51,7 @@ void DrawArc (LayerTypePtr, ArcTypePtr, int);
 void DrawText (LayerTypePtr, TextTypePtr, int);
 void DrawTextLowLevel (TextTypePtr, int);
 void DrawPolygon (LayerTypePtr, PolygonTypePtr, int);
+void DrawPour (LayerTypePtr, PourTypePtr, int);
 void DrawElement (ElementTypePtr, int);
 void DrawElementName (ElementTypePtr, int);
 void DrawElementPackage (ElementTypePtr, int);
@@ -68,6 +69,7 @@ void EraseLine (LineTypePtr);
 void EraseArc (ArcTypePtr);
 void EraseText (LayerTypePtr, TextTypePtr);
 void ErasePolygon (PolygonTypePtr);
+void ErasePour (PourTypePtr);
 void EraseElement (ElementTypePtr);
 void EraseElementPinsAndPads (ElementTypePtr);
 void EraseElementName (ElementTypePtr);
diff --git a/src/file.c b/src/file.c
index 653e1db..1072005 100644
--- a/src/file.c
+++ b/src/file.c
@@ -812,6 +812,8 @@ WriteLayerData (FILE * FP, Cardinal Number, LayerTypePtr layer)
 	  PrintQuotedString (FP, EMPTY (text->TextString));
 	  fprintf (FP, " %s]\n", F2S (text, TEXT_TYPE));
 	}
+#warning FIXME Later
+#if 0
       for (n = 0; n < layer->PolygonN; n++)
 	{
 	  PolygonTypePtr polygon = &layer->Polygon[n];
@@ -826,6 +828,21 @@ WriteLayerData (FILE * FP, Cardinal Number, LayerTypePtr layer)
 	    }
 	  fputs ("\n\t)\n", FP);
 	}
+#endif
+      for (n = 0; n < layer->PourN; n++)
+	{
+	  PourTypePtr pour = &layer->Pour[n];
+	  int p, i = 0;
+	  fprintf (FP, "\tPolygon(%s)\n\t(", F2S (pour, POUR_TYPE));
+	  for (p = 0; p < pour->PointN; p++)
+	    {
+	      PointTypePtr point = &pour->Points[p];
+	      if (i++ % 5 == 0)
+		fputs ("\n\t\t", FP);
+	      fprintf (FP, "[%i %i] ", (int) point->X, (int) point->Y);
+	    }
+	  fputs ("\n\t)\n", FP);
+	}
       fputs (")\n", FP);
     }
 }
diff --git a/src/flags.c b/src/flags.c
index d4f8a67..7491a48 100644
--- a/src/flags.c
+++ b/src/flags.c
@@ -135,7 +135,8 @@ HID_Flag flags_flag_list[] = {
   {"lockmode", FlagMode, LOCK_MODE},
   {"movemode", FlagMode, MOVE_MODE},
   {"pastebuffermode", FlagMode, PASTEBUFFER_MODE},
-  {"polygonmode", FlagMode, POLYGON_MODE},
+//  {"polygonmode", FlagMode, POLYGON_MODE},
+  {"pourmode", FlagMode, POUR_MODE},
   {"rectanglemode", FlagMode, RECTANGLE_MODE},
   {"removemode", FlagMode, REMOVE_MODE},
   {"rotatemode", FlagMode, ROTATE_MODE},
diff --git a/src/global.h b/src/global.h
index 6ad99c6..a4b2415 100644
--- a/src/global.h
+++ b/src/global.h
@@ -200,27 +200,36 @@ typedef struct
 
 typedef struct polygon_st PolygonType, *PolygonTypePtr;
 
-#if 0
 typedef struct			/* holds information about a poured area */
 {
   ANYOBJECTFIELDS;
-  Cardinal PointN,		/* number of points in pour outline */
-    PointMax;			/* max number from malloc() */
-  PolygonTypePtr polygons;	/* the resulting polygons */
+
+  Cardinal PointN;		/* number of points in pour outline */
+  Cardinal PointMax;		/* max number from malloc() */
+  PointTypePtr Points;		/* pour outline data */
+
+  Cardinal PolygonN;		/* number of polygons this pour has */
+  Cardinal PolygonMax;		/* max number from malloc() */
+  PolygonTypePtr polygons;	/* pour polygons */
+
+  /* r_tree? */
+
 } PourType, *PourTypePtr;
-#endif
 
 struct polygon_st		/* holds information about a polygon */
 {
   ANYOBJECTFIELDS;
-  Cardinal PointN,		/* number of points in polygon */
-    PointMax;			/* max number from malloc() */
+
+//  Cardinal PointN,		/* number of points in polygon */
+//  Cardinal PointMax;		/* max number from malloc() */
+  PointTypePtr Points;		/* data */
+
   POLYAREA *Clipped;		/* the clipped region of this polygon */
-  POLYAREA *NoHoles;		/* the polygon broken into hole-less regions */
+
+  POLYAREA *NoHoles;		/* the clipped polygon broken into hole-less regions */
   int NoHolesValid;		/* Is the NoHoles polygon up to date? */
-  PointTypePtr Points;		/* data */
-//  PourTypePtr Pour;		/* The pour which resulted in this polygon */
-  PolygonTypePtr *Parent;	/* The parent polygon which defined us */
+
+  PourTypePtr ParentPour;	/* The pour which resulted in this polygon */
 };
 
 typedef struct			/* holds information about arcs */
@@ -253,9 +262,9 @@ typedef struct			/* holds information about one layer */
   LineTypePtr Line;		/* pointer to additional structures */
   TextTypePtr Text;
   PolygonTypePtr Polygon;
-  PolygonTypePtr Pour;
+  PourTypePtr Pour;
   ArcTypePtr Arc;
-  rtree_t *line_tree, *text_tree, *polygon_tree, *arc_tree;
+  rtree_t *line_tree, *text_tree, *polygon_tree, *pour_tree, *arc_tree;
   Boolean On;			/* visible flag */
   char *Color,			/* color */
    *SelectedColor;
@@ -531,7 +540,8 @@ typedef struct			/* holds cursor information */
   Boolean On;			/* flag for 'is visible' */
   AttachedLineType AttachedLine;	/* data of new lines... */
   AttachedBoxType AttachedBox;
-  PolygonType AttachedPolygon;
+//  PolygonType AttachedPolygon;
+  PourType AttachedPour;
   AttachedObjectType AttachedObject;	/* data of attached objects */
 } CrosshairType, *CrosshairTypePtr;
 
@@ -645,13 +655,15 @@ typedef struct
   void *(*Line) (LayerTypePtr, LineTypePtr);
   void *(*Text) (LayerTypePtr, TextTypePtr);
   void *(*Polygon) (LayerTypePtr, PolygonTypePtr);
+  void *(*Pour) (LayerTypePtr, PourTypePtr);
   void *(*Via) (PinTypePtr);
   void *(*Element) (ElementTypePtr);
   void *(*ElementName) (ElementTypePtr);
   void *(*Pin) (ElementTypePtr, PinTypePtr);
   void *(*Pad) (ElementTypePtr, PadTypePtr);
   void *(*LinePoint) (LayerTypePtr, LineTypePtr, PointTypePtr);
-  void *(*Point) (LayerTypePtr, PolygonTypePtr, PointTypePtr);
+  void *(*PolygonPoint) (LayerTypePtr, PolygonTypePtr, PointTypePtr);
+  void *(*PourPoint) (LayerTypePtr, PourTypePtr, PointTypePtr);
   void *(*Arc) (LayerTypePtr, ArcTypePtr);
   void *(*Rat) (RatTypePtr);
 } ObjectFunctionType, *ObjectFunctionTypePtr;
diff --git a/src/gpcb-menu.res b/src/gpcb-menu.res
index 93b6073..f28bf79 100644
--- a/src/gpcb-menu.res
+++ b/src/gpcb-menu.res
@@ -490,7 +490,7 @@ PopupMenus =
        {"Arc" checked=arcmode,1 Mode(Arc) a={"F3" "<Key>F3"}}
        {"Text" checked=textmode,1 Mode(Text) a={"F4" "<Key>F4"}}
        {"Rectangle" checked=rectanglemode,1 Mode(Rectangle) a={"F5" "<Key>F5"}}
-       {"Polygon" checked=polygonmode,1 Mode(Polygon) a={"F6" "<Key>F6"}}
+       {"Polygon" checked=pourmode,1 Mode(Pour) a={"F6" "<Key>F6"}}
        {"Buffer" checked=pastebuffermode,1 Mode(PasteBuffer) a={"F7" "<Key>F7"}}
        {"Remove" checked=removemode,1 Mode(Remove) a={"F8" "<Key>F8"}}
        {"Rotate" checked=rotatemode,1 Mode(Rotate) a={"F9" "<Key>F9"}}
diff --git a/src/hid/gtk/gui-icons-mode-buttons.data b/src/hid/gtk/gui-icons-mode-buttons.data
index 1938ee2..e210157 100644
--- a/src/hid/gtk/gui-icons-mode-buttons.data
+++ b/src/hid/gtk/gui-icons-mode-buttons.data
@@ -252,7 +252,7 @@ static char *pan[] = {
 
 #endif
 /* XPM */
-static char *poly[] = {
+static char *pour[] = {
 /* columns rows colors chars-per-pixel */
 "21 21 4 1",
 "  c black",
diff --git a/src/hid/gtk/gui-misc.c b/src/hid/gtk/gui-misc.c
index e8ad916..e1b6290 100644
--- a/src/hid/gtk/gui-misc.c
+++ b/src/hid/gtk/gui-misc.c
@@ -219,7 +219,7 @@ ghid_mode_cursor (int Mode)
       gport_set_cursor (GDK_LEFT_PTR);
       break;
 
-    case POLYGON_MODE:
+    case POUR_MODE:
       gport_set_cursor (GDK_SB_UP_ARROW);
       break;
 
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index f033f0f..0878b0d 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -267,7 +267,7 @@ have_crosshair_attachments (void)
     case VIA_MODE:
       result = TRUE;
       break;
-    case POLYGON_MODE:
+    case POUR_MODE:
       if (Crosshair.AttachedLine.State != STATE_FIRST)
 	result = TRUE;
       break;
@@ -571,7 +571,7 @@ in_draw_state (void)
 	  && Crosshair.AttachedBox.State != STATE_FIRST)
       || (Settings.Mode == RECTANGLE_MODE
 	  && Crosshair.AttachedBox.State != STATE_FIRST)
-      || (Settings.Mode == POLYGON_MODE
+      || (Settings.Mode == POUR_MODE
 	  && Crosshair.AttachedLine.State != STATE_FIRST))
     return TRUE;
   return FALSE;
@@ -633,8 +633,9 @@ ghid_port_button_press_cb (GtkWidget * drawing_area,
 	    hid_actionl ("Mode", "Arc", NULL);
 	  else if (Settings.Mode == RECTANGLE_MODE)
 	    hid_actionl ("Mode", "Rectangle", NULL);
-	  else if (Settings.Mode == POLYGON_MODE)
-	    hid_actionl ("Mode", "Polygon", NULL);
+	  else if (Settings.Mode == POUR_MODE)
+	    hid_actionl ("Mode", "Pour", NULL);
+//	    hid_actionl ("Mode", "Polygon", NULL);
 
 	  hid_actionl ("Mode", "Notify", NULL);
 	  draw_state_reset = TRUE;
diff --git a/src/hid/gtk/gui-top-window.c b/src/hid/gtk/gui-top-window.c
index 8143bc8..214032d 100644
--- a/src/hid/gtk/gui-top-window.c
+++ b/src/hid/gtk/gui-top-window.c
@@ -1981,7 +1981,8 @@ static ModeButton mode_buttons[] = {
   {NULL, NULL, NULL, "arc", ARC_MODE, arc},
   {NULL, NULL, NULL, "text", TEXT_MODE, text},
   {NULL, NULL, NULL, "rectangle", RECTANGLE_MODE, rect},
-  {NULL, NULL, NULL, "polygon", POLYGON_MODE, poly},
+  {NULL, NULL, NULL, "pour", POUR_MODE, pour},
+//  {NULL, NULL, NULL, "polygon", POLYGON_MODE, poly},
   {NULL, NULL, NULL, "buffer", PASTEBUFFER_MODE, buf},
   {NULL, NULL, NULL, "remove", REMOVE_MODE, del},
   {NULL, NULL, NULL, "rotate", ROTATE_MODE, rot},
diff --git a/src/insert.c b/src/insert.c
index 3d4a2f5..6399fac 100644
--- a/src/insert.c
+++ b/src/insert.c
@@ -46,6 +46,7 @@
 #include "misc.h"
 #include "move.h"
 #include "polygon.h"
+#include "pour.h"
 #include "rtree.h"
 #include "search.h"
 #include "select.h"
@@ -65,7 +66,7 @@ RCSID ("$Id$");
  * some local prototypes
  */
 static void *InsertPointIntoLine (LayerTypePtr, LineTypePtr);
-static void *InsertPointIntoPolygon (LayerTypePtr, PolygonTypePtr);
+static void *InsertPointIntoPour (LayerTypePtr, PourTypePtr);
 static void *InsertPointIntoRat (RatTypePtr);
 
 /* ---------------------------------------------------------------------------
@@ -78,7 +79,8 @@ static Boolean Forcible;
 static ObjectFunctionType InsertFunctions = {
   InsertPointIntoLine,
   NULL,
-  InsertPointIntoPolygon,
+  NULL,
+  InsertPointIntoPour,
   NULL,
   NULL,
   NULL,
@@ -159,10 +161,10 @@ InsertPointIntoLine (LayerTypePtr Layer, LineTypePtr Line)
 }
 
 /* ---------------------------------------------------------------------------
- * inserts a point into a polygon
+ * inserts a point into a pour
  */
 static void *
-InsertPointIntoPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
+InsertPointIntoPour (LayerTypePtr Layer, PourTypePtr Pour)
 {
   PointType save;
   Cardinal n;
@@ -175,34 +177,34 @@ InsertPointIntoPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
        */
       line.Thickness = 0;
       if (InsertAt == 0)
-	line.Point1 = Polygon->Points[Polygon->PointN - 1];
+	line.Point1 = Pour->Points[Pour->PointN - 1];
       else
-	line.Point1 = Polygon->Points[InsertAt - 1];
-      line.Point2 = Polygon->Points[InsertAt];
+	line.Point1 = Pour->Points[InsertAt - 1];
+      line.Point2 = Pour->Points[InsertAt];
       if (IsPointOnLine ((float) InsertX, (float) InsertY, 0.0, &line))
 	return (NULL);
     }
   /*
    * second, shift the points up to make room for the new point
    */
-  ErasePolygon (Polygon);
-  r_delete_entry (Layer->polygon_tree, (BoxTypePtr) Polygon);
-  save = *CreateNewPointInPolygon (Polygon, InsertX, InsertY);
-  for (n = Polygon->PointN - 1; n > InsertAt; n--)
-    Polygon->Points[n] = Polygon->Points[n - 1];
-  Polygon->Points[InsertAt] = save;
+  ErasePour (Pour);
+  r_delete_entry (Layer->pour_tree, (BoxTypePtr) Pour);
+  save = *CreateNewPointInPour (Pour, InsertX, InsertY);
+  for (n = Pour->PointN - 1; n > InsertAt; n--)
+    Pour->Points[n] = Pour->Points[n - 1];
+  Pour->Points[InsertAt] = save;
   SetChangedFlag (True);
-  AddObjectToInsertPointUndoList (POLYGONPOINT_TYPE, Layer, Polygon,
-				  &Polygon->Points[InsertAt]);
-  SetPolygonBoundingBox (Polygon);
-  r_insert_entry (Layer->polygon_tree, (BoxType *) Polygon, 0);
-  InitClip (PCB->Data, Layer, Polygon);
-  if (Forcible || !RemoveExcessPolygonPoints (Layer, Polygon))
+  AddObjectToInsertPointUndoList (POURPOINT_TYPE, Layer, Pour,
+				  &Pour->Points[InsertAt]);
+  SetPourBoundingBox (Pour);
+  r_insert_entry (Layer->pour_tree, (BoxType *) Pour, 0);
+  InitPourClip (PCB->Data, Layer, Pour);
+  if (Forcible || !RemoveExcessPourPoints (Layer, Pour))
     {
-      DrawPolygon (Layer, Polygon, 0);
+      DrawPour (Layer, Pour, 0);
       Draw ();
     }
-  return (&Polygon->Points[InsertAt]);
+  return (&Pour->Points[InsertAt]);
 }
 
 /* ---------------------------------------------------------------------------
diff --git a/src/macro.h b/src/macro.h
index 5bae417..ea605a4 100644
--- a/src/macro.h
+++ b/src/macro.h
@@ -391,13 +391,6 @@ extern int mem_any_set (unsigned char *, int);
 	{						\
 		text = &(layer)->Text[n]
 
-#define	POUR_LOOP(layer) do {			\
-	Cardinal		n;			\
-	PolygonTypePtr	pour;			\
-	for (n = (layer)->PourN-1; n != -1; n--)	\
-	{						\
-		pour = &(layer)->Pour[n]
-
 #define	POLYGON_LOOP(layer) do {			\
 	Cardinal		n;			\
 	PolygonTypePtr	polygon;			\
@@ -412,6 +405,20 @@ extern int mem_any_set (unsigned char *, int);
 	{						\
 		point = &(polygon)->Points[n]
 
+#define	POUR_LOOP(layer) do {			\
+	Cardinal		n;			\
+	PourTypePtr	pour;			\
+	for (n = (layer)->PourN-1; n != -1; n--)	\
+	{						\
+		pour = &(layer)->Pour[n]
+
+#define	POURPOINT_LOOP(pour) do	{	\
+	Cardinal			n;		\
+	PointTypePtr	point;				\
+	for (n = (pour)->PointN-1; n != -1; n--)	\
+	{						\
+		point = &(pour)->Points[n]
+
 #define ENDALL_LOOP }} while (0);  }} while (0)
 
 #define	ALLPIN_LOOP(top)	\
@@ -443,6 +450,13 @@ extern int mem_any_set (unsigned char *, int);
 	{ \
 		POLYGON_LOOP(layer)
 
+#define	ALLPOUR_LOOP(top)	do {		\
+	Cardinal		l;			\
+	LayerTypePtr	layer = (top)->Layer;		\
+	for (l = 0; l < max_layer + 2; l++, layer++)	\
+	{ \
+		POUR_LOOP(layer)
+
 #define	COPPERLINE_LOOP(top) do	{		\
 	Cardinal		l;			\
 	LayerTypePtr	layer = (top)->Layer;		\
diff --git a/src/mirror.c b/src/mirror.c
index 7ef7d41..4ba63aa 100644
--- a/src/mirror.c
+++ b/src/mirror.c
@@ -46,6 +46,7 @@
 #include "mirror.h"
 #include "misc.h"
 #include "polygon.h"
+#include "pour.h"
 #include "search.h"
 #include "select.h"
 #include "set.h"
@@ -78,14 +79,14 @@ MirrorElementCoordinates (DataTypePtr Data, ElementTypePtr Element,
   END_LOOP;
   PIN_LOOP (Element);
   {
-    RestoreToPolygon (Data, PIN_TYPE, Element, pin);
+    RestoreToPour (Data, PIN_TYPE, Element, pin);
     pin->X = SWAP_X (pin->X);
     pin->Y = SWAP_Y (pin->Y) + yoff;
   }
   END_LOOP;
   PAD_LOOP (Element);
   {
-    RestoreToPolygon (Data, PAD_TYPE, Element, pad);
+    RestoreToPour (Data, PAD_TYPE, Element, pad);
     pad->Point1.X = SWAP_X (pad->Point1.X);
     pad->Point1.Y = SWAP_Y (pad->Point1.Y) + yoff;
     pad->Point2.X = SWAP_X (pad->Point2.X);
@@ -115,5 +116,5 @@ MirrorElementCoordinates (DataTypePtr Data, ElementTypePtr Element,
   TOGGLE_FLAG (ONSOLDERFLAG, Element);
   /* this inserts all of the rtree data too */
   SetElementBoundingBox (Data, Element, &PCB->Font);
-  ClearFromPolygon (Data, ELEMENT_TYPE, Element, Element);
+  ClearFromPour (Data, ELEMENT_TYPE, Element, Element);
 }
diff --git a/src/misc.c b/src/misc.c
index df34363..fb620d0 100644
--- a/src/misc.c
+++ b/src/misc.c
@@ -65,6 +65,7 @@
 #include "misc.h"
 #include "move.h"
 #include "polygon.h"
+#include "pour.h"
 #include "remove.h"
 #include "rtree.h"
 #include "rotate.h"
@@ -245,6 +246,8 @@ SetPolygonBoundingBox (PolygonTypePtr Polygon)
 {
   Polygon->BoundingBox.X1 = Polygon->BoundingBox.Y1 = MAX_COORD;
   Polygon->BoundingBox.X2 = Polygon->BoundingBox.Y2 = 0;
+#define FIXME Later
+#if 0
   POLYGONPOINT_LOOP (Polygon);
   {
     MAKEMIN (Polygon->BoundingBox.X1, point->X);
@@ -253,6 +256,25 @@ SetPolygonBoundingBox (PolygonTypePtr Polygon)
     MAKEMAX (Polygon->BoundingBox.Y2, point->Y);
   }
   END_LOOP;
+#endif
+}
+
+/* ---------------------------------------------------------------------------
+ * sets the bounding box of a pour
+ */
+void
+SetPourBoundingBox (PourTypePtr Pour)
+{
+  Pour->BoundingBox.X1 = Pour->BoundingBox.Y1 = MAX_COORD;
+  Pour->BoundingBox.X2 = Pour->BoundingBox.Y2 = 0;
+  POURPOINT_LOOP (Pour);
+  {
+    MAKEMIN (Pour->BoundingBox.X1, point->X);
+    MAKEMIN (Pour->BoundingBox.Y1, point->Y);
+    MAKEMAX (Pour->BoundingBox.X2, point->X);
+    MAKEMAX (Pour->BoundingBox.Y2, point->Y);
+  }
+  END_LOOP;
 }
 
 /* ---------------------------------------------------------------------------
@@ -1578,14 +1600,14 @@ ChangeArcAngles (LayerTypePtr Layer, ArcTypePtr a,
       new_da = 360;
       new_sa = 0;
     }
-  RestoreToPolygon (PCB->Data, ARC_TYPE, Layer, a);
+  RestoreToPour (PCB->Data, ARC_TYPE, Layer, a);
   r_delete_entry (Layer->arc_tree, (BoxTypePtr) a);
   AddObjectToChangeAnglesUndoList (ARC_TYPE, a, a, a);
   a->StartAngle = new_sa;
   a->Delta = new_da;
   SetArcBoundingBox (a);
   r_insert_entry (Layer->arc_tree, (BoxTypePtr) a, 0);
-  ClearFromPolygon (PCB->Data, ARC_TYPE, Layer, a);
+  ClearFromPour (PCB->Data, ARC_TYPE, Layer, a);
 }
 
 static char *
diff --git a/src/misc.h b/src/misc.h
index 58e75dc..6d7bc4b 100644
--- a/src/misc.h
+++ b/src/misc.h
@@ -42,6 +42,7 @@ void SetPointBoundingBox (PointTypePtr);
 void SetPinBoundingBox (PinTypePtr);
 void SetPadBoundingBox (PadTypePtr);
 void SetPolygonBoundingBox (PolygonTypePtr);
+void SetPourBoundingBox (PourTypePtr);
 void SetElementBoundingBox (DataTypePtr, ElementTypePtr, FontTypePtr);
 Boolean IsDataEmpty (DataTypePtr);
 BoxTypePtr GetDataBoundingBox (DataTypePtr);
diff --git a/src/move.c b/src/move.c
index aebfc30..53faba3 100644
--- a/src/move.c
+++ b/src/move.c
@@ -48,6 +48,7 @@
 #include "move.h"
 #include "mymem.h"
 #include "polygon.h"
+#include "pour.h"
 #include "rtree.h"
 #include "search.h"
 #include "select.h"
@@ -73,13 +74,15 @@ static void *MoveLine (LayerTypePtr, LineTypePtr);
 static void *MoveArc (LayerTypePtr, ArcTypePtr);
 static void *MoveText (LayerTypePtr, TextTypePtr);
 static void *MovePolygon (LayerTypePtr, PolygonTypePtr);
+static void *MovePour (LayerTypePtr, PourTypePtr);
 static void *MoveLinePoint (LayerTypePtr, LineTypePtr, PointTypePtr);
-static void *MovePolygonPoint (LayerTypePtr, PolygonTypePtr, PointTypePtr);
+static void *MovePourPoint (LayerTypePtr, PourTypePtr, PointTypePtr);
 static void *MoveLineToLayer (LayerTypePtr, LineTypePtr);
 static void *MoveArcToLayer (LayerTypePtr, ArcTypePtr);
 static void *MoveRatToLayer (RatTypePtr);
 static void *MoveTextToLayer (LayerTypePtr, TextTypePtr);
 static void *MovePolygonToLayer (LayerTypePtr, PolygonTypePtr);
+static void *MovePourToLayer (LayerTypePtr, PourTypePtr);
 
 /* ---------------------------------------------------------------------------
  * some local identifiers
@@ -92,13 +95,15 @@ static ObjectFunctionType MoveFunctions = {
   MoveLine,
   MoveText,
   MovePolygon,
+  MovePour,
   MoveVia,
   MoveElement,
   MoveElementName,
   NULL,
   NULL,
   MoveLinePoint,
-  MovePolygonPoint,
+  NULL,
+  MovePourPoint,
   MoveArc,
   NULL
 }, MoveToLayerFunctions =
@@ -107,7 +112,17 @@ static ObjectFunctionType MoveFunctions = {
 MoveLineToLayer,
     MoveTextToLayer,
     MovePolygonToLayer,
-    NULL, NULL, NULL, NULL, NULL, NULL, NULL, MoveArcToLayer, MoveRatToLayer};
+    MovePourToLayer,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    MoveArcToLayer,
+    MoveRatToLayer};
 
 /* ---------------------------------------------------------------------------
  * moves a element by +-X and +-Y
@@ -128,13 +143,13 @@ MoveElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
     if (Data)
       {
 	r_delete_entry (Data->pin_tree, (BoxType *) pin);
-	RestoreToPolygon (Data, PIN_TYPE, Element, pin);
+	RestoreToPour (Data, PIN_TYPE, Element, pin);
       }
     MOVE_PIN_LOWLEVEL (pin, DX, DY);
     if (Data)
       {
 	r_insert_entry (Data->pin_tree, (BoxType *) pin, 0);
-	ClearFromPolygon (Data, PIN_TYPE, Element, pin);
+	ClearFromPour (Data, PIN_TYPE, Element, pin);
       }
   }
   END_LOOP;
@@ -143,13 +158,13 @@ MoveElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
     if (Data)
       {
 	r_delete_entry (Data->pad_tree, (BoxType *) pad);
-	RestoreToPolygon (Data, PAD_TYPE, Element, pad);
+	RestoreToPour (Data, PAD_TYPE, Element, pad);
       }
     MOVE_PAD_LOWLEVEL (pad, DX, DY);
     if (Data)
       {
 	r_insert_entry (Data->pad_tree, (BoxType *) pad, 0);
-	ClearFromPolygon (Data, PAD_TYPE, Element, pad);
+	ClearFromPour (Data, PAD_TYPE, Element, pad);
       }
   }
   END_LOOP;
@@ -249,12 +264,12 @@ static void *
 MoveVia (PinTypePtr Via)
 {
   r_delete_entry (PCB->Data->via_tree, (BoxTypePtr) Via);
-  RestoreToPolygon (PCB->Data, VIA_TYPE, Via, Via);
+  RestoreToPour (PCB->Data, VIA_TYPE, Via, Via);
   MOVE_VIA_LOWLEVEL (Via, DeltaX, DeltaY);
   if (PCB->ViaOn)
     EraseVia (Via);
   r_insert_entry (PCB->Data->via_tree, (BoxTypePtr) Via, 0);
-  ClearFromPolygon (PCB->Data, VIA_TYPE, Via, Via);
+  ClearFromPour (PCB->Data, VIA_TYPE, Via, Via);
   if (PCB->ViaOn)
     {
       DrawVia (Via, 0);
@@ -271,11 +286,11 @@ MoveLine (LayerTypePtr Layer, LineTypePtr Line)
 {
   if (Layer->On)
     EraseLine (Line);
-  RestoreToPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+  RestoreToPour (PCB->Data, LINE_TYPE, Layer, Line);
   r_delete_entry (Layer->line_tree, (BoxTypePtr) Line);
   MOVE_LINE_LOWLEVEL (Line, DeltaX, DeltaY);
   r_insert_entry (Layer->line_tree, (BoxTypePtr) Line, 0);
-  ClearFromPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+  ClearFromPour (PCB->Data, LINE_TYPE, Layer, Line);
   if (Layer->On)
     {
       DrawLine (Layer, Line, 0);
@@ -290,7 +305,7 @@ MoveLine (LayerTypePtr Layer, LineTypePtr Line)
 static void *
 MoveArc (LayerTypePtr Layer, ArcTypePtr Arc)
 {
-  RestoreToPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
+  RestoreToPour (PCB->Data, ARC_TYPE, Layer, Arc);
   r_delete_entry (Layer->arc_tree, (BoxTypePtr) Arc);
   if (Layer->On)
     {
@@ -304,7 +319,7 @@ MoveArc (LayerTypePtr Layer, ArcTypePtr Arc)
       MOVE_ARC_LOWLEVEL (Arc, DeltaX, DeltaY);
     }
   r_insert_entry (Layer->arc_tree, (BoxTypePtr) Arc, 0);
-  ClearFromPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
+  ClearFromPour (PCB->Data, ARC_TYPE, Layer, Arc);
   return (Arc);
 }
 
@@ -314,7 +329,7 @@ MoveArc (LayerTypePtr Layer, ArcTypePtr Arc)
 static void *
 MoveText (LayerTypePtr Layer, TextTypePtr Text)
 {
-  RestoreToPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+  RestoreToPour (PCB->Data, TEXT_TYPE, Layer, Text);
   r_delete_entry (Layer->text_tree, (BoxTypePtr) Text);
   if (Layer->On)
     {
@@ -326,7 +341,7 @@ MoveText (LayerTypePtr Layer, TextTypePtr Text)
   else
     MOVE_TEXT_LOWLEVEL (Text, DeltaX, DeltaY);
   r_insert_entry (Layer->text_tree, (BoxTypePtr) Text, 0);
-  ClearFromPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+  ClearFromPour (PCB->Data, TEXT_TYPE, Layer, Text);
   return (Text);
 }
 
@@ -337,12 +352,30 @@ void
 MovePolygonLowLevel (PolygonTypePtr Polygon, LocationType DeltaX,
 		     LocationType DeltaY)
 {
+#warning FIXME Later
+#if 0
   POLYGONPOINT_LOOP (Polygon);
   {
     MOVE (point->X, point->Y, DeltaX, DeltaY);
   }
   END_LOOP;
   MOVE_BOX_LOWLEVEL (&Polygon->BoundingBox, DeltaX, DeltaY);
+#endif
+}
+
+/* ---------------------------------------------------------------------------
+ * low level routine to move a pour
+ */
+void
+MovePourLowLevel (PourTypePtr Pour, LocationType DeltaX,
+		     LocationType DeltaY)
+{
+  POURPOINT_LOOP (Pour);
+  {
+    MOVE (point->X, point->Y, DeltaX, DeltaY);
+  }
+  END_LOOP;
+  MOVE_BOX_LOWLEVEL (&Pour->BoundingBox, DeltaX, DeltaY);
 }
 
 /* ---------------------------------------------------------------------------
@@ -355,12 +388,12 @@ MovePolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
     {
       ErasePolygon (Polygon);
     }
-  RestoreToPolygon (PCB->Data, POLYGON_TYPE, Layer, Polygon);
+  RestoreToPour (PCB->Data, POLYGON_TYPE, Layer, Polygon);
   r_delete_entry (Layer->polygon_tree, (BoxType *) Polygon);
   MovePolygonLowLevel (Polygon, DeltaX, DeltaY);
   r_insert_entry (Layer->polygon_tree, (BoxType *) Polygon, 0);
   InitClip (PCB->Data, Layer, Polygon);
-  ClearFromPolygon (PCB->Data, POLYGON_TYPE, Layer, Polygon);
+  ClearFromPour (PCB->Data, POLYGON_TYPE, Layer, Polygon);
   if (Layer->On)
     {
       DrawPolygon (Layer, Polygon, 0);
@@ -370,6 +403,30 @@ MovePolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
 }
 
 /* ---------------------------------------------------------------------------
+ * moves a pour
+ */
+static void *
+MovePour (LayerTypePtr Layer, PourTypePtr Pour)
+{
+  if (Layer->On)
+    {
+      ErasePour (Pour);
+    }
+//  RestoreToPour (PCB->Data, POLYGON_TYPE, Layer, Pour);
+  r_delete_entry (Layer->pour_tree, (BoxType *) Pour);
+  MovePourLowLevel (Pour, DeltaX, DeltaY);
+  r_insert_entry (Layer->pour_tree, (BoxType *) Pour, 0);
+  InitPourClip (PCB->Data, Layer, Pour);
+//  ClearFromPour (PCB->Data, POLYGON_TYPE, Layer, Polygon);
+  if (Layer->On)
+    {
+      DrawPour (Layer, Pour, 0);
+      Draw ();
+    }
+  return (Pour);
+}
+
+/* ---------------------------------------------------------------------------
  * moves one end of a line
  */
 static void *
@@ -379,12 +436,12 @@ MoveLinePoint (LayerTypePtr Layer, LineTypePtr Line, PointTypePtr Point)
     {
       if (Layer->On)
 	EraseLine (Line);
-      RestoreToPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+      RestoreToPour (PCB->Data, LINE_TYPE, Layer, Line);
       r_delete_entry (Layer->line_tree, &Line->BoundingBox);
       MOVE (Point->X, Point->Y, DeltaX, DeltaY);
       SetLineBoundingBox (Line);
       r_insert_entry (Layer->line_tree, &Line->BoundingBox, 0);
-      ClearFromPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+      ClearFromPour (PCB->Data, LINE_TYPE, Layer, Line);
       if (Layer->On)
 	{
 	  DrawLine (Layer, Line, 0);
@@ -410,27 +467,26 @@ MoveLinePoint (LayerTypePtr Layer, LineTypePtr Line, PointTypePtr Point)
 }
 
 /* ---------------------------------------------------------------------------
- * moves a polygon-point
+ * moves a pour-point
  */
 static void *
-MovePolygonPoint (LayerTypePtr Layer, PolygonTypePtr Polygon,
-		  PointTypePtr Point)
+MovePourPoint (LayerTypePtr Layer, PourTypePtr Pour, PointTypePtr Point)
 {
   if (Layer->On)
     {
-      ErasePolygon (Polygon);
+      ErasePour (Pour);
     }
-  RestoreToPolygon (PCB->Data, POLYGON_TYPE, Layer, Polygon);
-  r_delete_entry (Layer->polygon_tree, (BoxType *) Polygon);
+//  RestoreToPour (PCB->Data, POLYGON_TYPE, Layer, Polygon);
+  r_delete_entry (Layer->pour_tree, (BoxType *) Pour);
   MOVE (Point->X, Point->Y, DeltaX, DeltaY);
-  SetPolygonBoundingBox (Polygon);
-  r_insert_entry (Layer->polygon_tree, (BoxType *) Polygon, 0);
-  RemoveExcessPolygonPoints (Layer, Polygon);
-  InitClip (PCB->Data, Layer, Polygon);
-  ClearFromPolygon (PCB->Data, POLYGON_TYPE, Layer, Polygon);
+  SetPourBoundingBox (Pour);
+  r_insert_entry (Layer->pour_tree, (BoxType *) Pour, 0);
+  RemoveExcessPourPoints (Layer, Pour);
+  InitPourClip (PCB->Data, Layer, Pour);
+//  ClearFromPour (PCB->Data, POLYGON_TYPE, Layer, Polygon);
   if (Layer->On)
     {
-      DrawPolygon (Layer, Polygon, 0);
+      DrawPour (Layer, Pour, 0);
       Draw ();
     }
   return (Point);
@@ -502,11 +558,11 @@ MoveArcToLayer (LayerTypePtr Layer, ArcTypePtr Arc)
   if (((long int) Dest == -1) || Dest == Layer)
     return (Arc);
   AddObjectToMoveToLayerUndoList (ARC_TYPE, Layer, Arc, Arc);
-  RestoreToPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
+  RestoreToPour (PCB->Data, ARC_TYPE, Layer, Arc);
   if (Layer->On)
     EraseArc (Arc);
   new = MoveArcToLayerLowLevel (Layer, Arc, Dest);
-  ClearFromPolygon (PCB->Data, ARC_TYPE, Dest, Arc);
+  ClearFromPour (PCB->Data, ARC_TYPE, Dest, Arc);
   if (Dest->On)
     DrawArc (Dest, new, 0);
   Draw ();
@@ -596,10 +652,10 @@ MoveLineToLayer (LayerTypePtr Layer, LineTypePtr Line)
   AddObjectToMoveToLayerUndoList (LINE_TYPE, Layer, Line, Line);
   if (Layer->On)
     EraseLine (Line);
-  RestoreToPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+  RestoreToPour (PCB->Data, LINE_TYPE, Layer, Line);
   new = MoveLineToLayerLowLevel (Layer, Line, Dest);
   Line = NULL;
-  ClearFromPolygon (PCB->Data, LINE_TYPE, Dest, new);
+  ClearFromPour (PCB->Data, LINE_TYPE, Dest, new);
   if (Dest->On)
     DrawLine (Dest, new, 0);
   Draw ();
@@ -650,7 +706,7 @@ MoveTextToLayerLowLevel (LayerTypePtr Source, TextTypePtr Text,
 {
   TextTypePtr new = GetTextMemory (Destination);
 
-  RestoreToPolygon (PCB->Data, TEXT_TYPE, Source, Text);
+  RestoreToPour (PCB->Data, TEXT_TYPE, Source, Text);
   r_delete_entry (Source->text_tree, (BoxTypePtr) Text);
   /* copy the data and remove it from the former layer */
   *new = *Text;
@@ -668,7 +724,7 @@ MoveTextToLayerLowLevel (LayerTypePtr Source, TextTypePtr Text,
   if (!Destination->text_tree)
     Destination->text_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (Destination->text_tree, (BoxTypePtr) new, 0);
-  ClearFromPolygon (PCB->Data, TEXT_TYPE, Destination, new);
+  ClearFromPour (PCB->Data, TEXT_TYPE, Destination, new);
   return (new);
 }
 
@@ -723,6 +779,29 @@ MovePolygonToLayerLowLevel (LayerTypePtr Source, PolygonTypePtr Polygon,
   return (new);
 }
 
+/* ---------------------------------------------------------------------------
+ * moves a pour between layers; lowlevel routines
+ */
+void *
+MovePourToLayerLowLevel (LayerTypePtr Source, PourTypePtr Pour,
+			    LayerTypePtr Destination)
+{
+  PourTypePtr new = GetPourMemory (Destination);
+
+  r_delete_entry (Source->pour_tree, (BoxType *) Pour);
+  /* copy the data and remove it from the former layer */
+  *new = *Pour;
+  *Pour = Source->Pour[--Source->PourN];
+  r_substitute (Source->pour_tree,
+		(BoxType *) & Source->Pour[Source->PourN],
+		(BoxType *) Pour);
+  memset (&Source->Pour[Source->PourN], 0, sizeof (PourType));
+  if (!Destination->pour_tree)
+    Destination->pour_tree = r_create_tree (NULL, 0, 0);
+  r_insert_entry (Destination->pour_tree, (BoxType *) new, 0);
+  return (new);
+}
+
 struct mptlc
 {
   Cardinal snum, dnum;
@@ -786,6 +865,46 @@ MovePolygonToLayer (LayerTypePtr Layer, PolygonTypePtr Polygon)
 }
 
 /* ---------------------------------------------------------------------------
+ * moves a pour between layers
+ */
+static void *
+MovePourToLayer (LayerTypePtr Layer, PourTypePtr Pour)
+{
+  PourTypePtr new;
+//  struct mptlc d;
+
+  if (TEST_FLAG (LOCKFLAG, Pour))
+    {
+      Message (_("Sorry, the object is locked\n"));
+      return NULL;
+    }
+  if (((long int) Dest == -1) || (Layer == Dest))
+    return (Pour);
+  AddObjectToMoveToLayerUndoList (POUR_TYPE, Layer, Pour, Pour);
+  if (Layer->On)
+    ErasePour (Pour);
+#define FIXME Later
+#if 0
+  /* Move all of the thermals with the pour */
+  d.snum = GetLayerNumber (PCB->Data, Layer);
+  d.dnum = GetLayerNumber (PCB->Data, Dest);
+  d.pour = Pour;
+  d.type = PIN_TYPE;
+  r_search (PCB->Data->pin_tree, &Pour->BoundingBox, NULL, mptl_pin_callback, &d);
+  d.type = VIA_TYPE;
+  r_search (PCB->Data->via_tree, &Pour->BoundingBox, NULL, mptl_pin_callback, &d);
+#endif
+  new = MovePourToLayerLowLevel (Layer, Pour, Dest);
+  InitPourClip (PCB->Data, Dest, new);
+  if (Dest->On)
+    {
+      DrawPour (Dest, new, 0);
+      Draw ();
+    }
+  return (new);
+}
+
+/* ---------------------------------------------------------------------------
  * moves the object identified by its data pointers and the type
  * not we don't bump the undo serial number
  */
diff --git a/src/move.h b/src/move.h
index f060ff5..5bc9f21 100644
--- a/src/move.h
+++ b/src/move.h
@@ -94,6 +94,7 @@
  * prototypes
  */
 void MovePolygonLowLevel (PolygonTypePtr, LocationType, LocationType);
+void MovePourLowLevel (PourTypePtr, LocationType, LocationType);
 void MoveElementLowLevel (DataTypePtr, ElementTypePtr, LocationType,
 			  LocationType);
 void *MoveObject (int, void *, void *, void *, LocationType, LocationType);
diff --git a/src/mymem.c b/src/mymem.c
index fba0715..1458fc6 100644
--- a/src/mymem.c
+++ b/src/mymem.c
@@ -401,28 +401,28 @@ GetTextMemory (LayerTypePtr Layer)
 /* ---------------------------------------------------------------------------
  * get next slot for a pour polygon object, allocates memory if necessary
  */
-PolygonTypePtr
+PourTypePtr
 GetPourMemory (LayerTypePtr Layer)
 {
-  PolygonTypePtr pour = Layer->Pour;
+  PourTypePtr pour = Layer->Pour;
 
   /* realloc new memory if necessary and clear it */
   if (Layer->PourN >= Layer->PourMax)
     {
       Layer->PourMax += STEP_POUR;
-//      if (Layer->polygon_tree)
-//	r_destroy_tree (&Layer->polygon_tree);
-      pour = MyRealloc (pour, Layer->PourMax * sizeof (PolygonType),
+      if (Layer->pour_tree)
+	r_destroy_tree (&Layer->pour_tree);
+      pour = MyRealloc (pour, Layer->PourMax * sizeof (PourType),
 			   "GetPourMemory()");
       Layer->Pour = pour;
       memset (pour + Layer->PourN, 0,
-	      STEP_POUR * sizeof (PolygonType));
-//      Layer->polygon_tree = r_create_tree (NULL, 0, 0);
-//      POLYGON_LOOP (Layer);
-//      {
-//	r_insert_entry (Layer->polygon_tree, (BoxType *) polygon, 0);
-//      }
-//      END_LOOP;
+	      STEP_POUR * sizeof (PourType));
+      Layer->pour_tree = r_create_tree (NULL, 0, 0);
+      POUR_LOOP (Layer);
+      {
+	r_insert_entry (Layer->pour_tree, (BoxType *) pour, 0);
+      }
+      END_LOOP;
     }
   return (pour + Layer->PourN++);
 }
@@ -463,6 +463,9 @@ GetPolygonMemory (LayerTypePtr Layer)
 PointTypePtr
 GetPointMemoryInPolygon (PolygonTypePtr Polygon)
 {
+  return NULL;
+#warning FIXME Later
+#if 0
   PointTypePtr points = Polygon->Points;
 
   /* realloc new memory if necessary and clear it */
@@ -476,6 +479,29 @@ GetPointMemoryInPolygon (PolygonTypePtr Polygon)
 	      STEP_POLYGONPOINT * sizeof (PointType));
     }
   return (points + Polygon->PointN++);
+#endif
+}
+
+/* ---------------------------------------------------------------------------
+ * gets the next slot for a point in a pour struct, allocates memory
+ * if necessary
+ */
+PointTypePtr
+GetPointMemoryInPour (PourTypePtr Pour)
+{
+  PointTypePtr points = Pour->Points;
+
+  /* realloc new memory if necessary and clear it */
+  if (Pour->PointN >= Pour->PointMax)
+    {
+      Pour->PointMax += STEP_POLYGONPOINT;
+      points = MyRealloc (points, Pour->PointMax * sizeof (PointType),
+			  "GetPointMemoryInPour()");
+      Pour->Points = points;
+      memset (points + Pour->PointN, 0,
+	      STEP_POLYGONPOINT * sizeof (PointType));
+    }
+  return (points + Pour->PointN++);
 }
 
 /* ---------------------------------------------------------------------------
@@ -763,6 +789,26 @@ FreePolygonMemory (PolygonTypePtr Polygon)
 }
 
 /* ---------------------------------------------------------------------------
+ * frees memory used by a pour
+ */
+void
+FreePourMemory (PourTypePtr Pour)
+{
+  if (Pour)
+    {
+      MYFREE (Pour->Points);
+#define FIXME Later
+#if 0
+      if (Pour->Clipped)
+	poly_Free (&Pour->Clipped);
+      if (Pour->NoHoles)
+	poly_Free (&Pour->NoHoles);
+#endif
+      memset (Pour, 0, sizeof (PourType));
+    }
+}
+
+/* ---------------------------------------------------------------------------
  * frees memory used by a box list
  */
 void
@@ -934,7 +980,7 @@ FreeDataMemory (DataTypePtr Data)
 	  MYFREE (layer->Polygon);
 	  POUR_LOOP (layer);
 	  {
-	    FreePolygonMemory (pour);
+	    FreePourMemory (pour);
 	  }
 	  END_LOOP;
 	  MYFREE (layer->Pour);
@@ -946,6 +992,8 @@ FreeDataMemory (DataTypePtr Data)
 	    r_destroy_tree (&layer->text_tree);
 	  if (layer->polygon_tree)
 	    r_destroy_tree (&layer->polygon_tree);
+	  if (layer->pour_tree)
+	    r_destroy_tree (&layer->pour_tree);
 	}
 
       if (Data->element_tree)
diff --git a/src/mymem.h b/src/mymem.h
index bbcaec4..1863ee5 100644
--- a/src/mymem.h
+++ b/src/mymem.h
@@ -82,7 +82,9 @@ ArcTypePtr GetArcMemory (LayerTypePtr);
 RatTypePtr GetRatMemory (DataTypePtr);
 TextTypePtr GetTextMemory (LayerTypePtr);
 PolygonTypePtr GetPolygonMemory (LayerTypePtr);
+PourTypePtr GetPourMemory (LayerTypePtr);
 PointTypePtr GetPointMemoryInPolygon (PolygonTypePtr);
+PointTypePtr GetPointMemoryInPour (PourTypePtr);
 ElementTypePtr GetElementMemory (DataTypePtr);
 BoxTypePtr GetBoxMemory (BoxListTypePtr);
 ConnectionTypePtr GetConnectionMemory (NetTypePtr);
@@ -101,6 +103,7 @@ char *MyStrdup (char *s, const char *);
 /* void MyFree (void **); */
 #define MYFREE(x) do { SaveFree(x); (x)=NULL; } while (0)
 void FreePolygonMemory (PolygonTypePtr);
+void FreePourMemory (PourTypePtr);
 void FreeElementMemory (ElementTypePtr);
 void FreePCBMemory (PCBTypePtr);
 void FreeBoxListMemory (BoxListTypePtr);
diff --git a/src/parse_y.y b/src/parse_y.y
index 480cad5..3881750 100644
--- a/src/parse_y.y
+++ b/src/parse_y.y
@@ -52,6 +52,7 @@
 #include "misc.h"
 #include "parse_l.h"
 #include "polygon.h"
+#include "pour.h"
 #include "remove.h"
 #include "rtree.h"
 #include "strflags.h"
@@ -64,7 +65,7 @@
 RCSID("$Id$");
 
 static	LayerTypePtr	Layer;
-static	PolygonTypePtr	Polygon;
+static	PourTypePtr	Pour;
 static	SymbolTypePtr	Symbol;
 static	int		pin_num;
 static	LibraryMenuTypePtr	Menu;
@@ -188,8 +189,8 @@ parsepcb
 			 */
 			PCB = yyPCB;
 			for (i = 0; i < yyData->LayerN+2; i++)
-			  for (j = 0; j < yyData->Layer[i].PolygonN; j++)
-			      InitClip (yyData, &yyData->Layer[i], &yyData->Layer[i].Polygon[j]);
+			  for (j = 0; j < yyData->Layer[i].PourN; j++)
+			      InitPourClip (yyData, &yyData->Layer[i], &yyData->Layer[i].Pour[j]);
 			PCB = pcb_save;
 			}
 			   
@@ -888,7 +889,7 @@ layerdefinition
 			/* x1, y1, x2, y2, flags */
 		| T_RECTANGLE '(' NUMBER NUMBER NUMBER NUMBER NUMBER ')'
 			{
-				CreateNewPolygonFromRectangle(Layer,
+				CreateNewPourFromRectangle(Layer,
 					$3*100, $4*100, ($3+$5)*100, ($4+$6)*100, OldFlags($7));
 			}
 		| text_hi_format
@@ -897,25 +898,25 @@ layerdefinition
 			/* flags are passed in */
 		| T_POLYGON '(' flags ')' '('
 			{
-				Polygon = CreateNewPolygon(Layer, $3);
+				Pour = CreateNewPour(Layer, $3);
 			}
 		  polygonpoints ')'
 		  	{
 					/* ignore junk */
-				if (Polygon->PointN >= 3)
+				if (Pour->PointN >= 3)
 				  {
-				    SetPolygonBoundingBox (Polygon);
-				    if (!Layer->polygon_tree)
-				      Layer->polygon_tree = r_create_tree (NULL, 0, 0);
-				    r_insert_entry (Layer->polygon_tree, (BoxType *) Polygon, 0);
+				    SetPourBoundingBox (Pour);
+				    if (!Layer->pour_tree)
+				      Layer->pour_tree = r_create_tree (NULL, 0, 0);
+				    r_insert_entry (Layer->pour_tree, (BoxType *) Pour, 0);
 				  }
 				else
 				{
 					Message("WARNING parsing file '%s'\n"
 						"    line:        %i\n"
-						"    description: 'ignored polygon (< 3 points)'\n",
+						"    description: 'ignored polygon pour (< 3 points)'\n",
 						yyfilename, yylineno);
-					DestroyObject(yyData, POLYGON_TYPE, Layer, Polygon, Polygon);
+					DestroyObject(yyData, POLYGON_TYPE, Layer, Pour, Pour);
 				}
 			}
 		;
@@ -1144,11 +1145,11 @@ polygonpoint
 			/* xcoord ycoord */
 		: '(' NUMBER NUMBER ')'
 			{
-				CreateNewPointInPolygon(Polygon, $2*100, $3*100);
+				CreateNewPointInPour(Pour, $2*100, $3*100);
 			}
 		| '[' NUMBER NUMBER ']'
 			{
-				CreateNewPointInPolygon(Polygon, $2, $3);
+				CreateNewPointInPour(Pour, $2, $3);
 			}
 		|
 		;
diff --git a/src/pcb-menu.res b/src/pcb-menu.res
index 1874a78..64a474b 100644
--- a/src/pcb-menu.res
+++ b/src/pcb-menu.res
@@ -166,7 +166,7 @@ MainMenu =
    {"Arc" checked=arcmode,1 Mode(Arc) a={"F3" "<Key>F3"}}
    {"Text" checked=textmode,1 Mode(Text) a={"F4" "<Key>F4"}}
    {"Rectangle" checked=rectanglemode,1 Mode(Rectangle) a={"F5" "<Key>F5"}}
-   {"Polygon" checked=polygonmode,1 Mode(Polygon) a={"F6" "<Key>F6"}}
+   {"Polygon" checked=pourmode,1 Mode(Pour) a={"F6" "<Key>F6"}}
    {"Buffer" checked=pastebuffermode,1 Mode(PasteBuffer) a={"F7" "<Key>F7"}}
    {"Remove" checked=removemode,1 Mode(Remove) a={"F8" "<Key>F8"}}
    {"Rotate" checked=rotatemode,1 Mode(Rotate) a={"F9" "<Key>F9"}}
diff --git a/src/polygon.c b/src/polygon.c
index 5c2d1f9..8d14c27 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -120,6 +120,7 @@ ComputeNoHoles (PolygonType *poly)
   poly->NoHolesValid = 1;
 }
 
+#if 0
 static POLYAREA *
 biggest (POLYAREA * p)
 {
@@ -165,6 +166,7 @@ biggest (POLYAREA * p)
   assert (p->b);
   return p;
 }
+#endif
 
 POLYAREA *
 ContourToPoly (PLINE * contour)
@@ -182,6 +184,9 @@ ContourToPoly (PLINE * contour)
 static POLYAREA *
 original_poly (PolygonType * p)
 {
+  return NULL;
+#warning FIXME Later
+#if 0
   PLINE *contour = NULL;
   POLYAREA *np = NULL;
   Vector v;
@@ -222,6 +227,7 @@ original_poly (PolygonType * p)
   poly_InclContour (np, contour);
   assert (poly_Valid (np));
   return biggest (np);
+#endif
 }
 
 static int
@@ -241,7 +247,8 @@ ClipOriginal (PolygonType * poly)
       poly->NoHoles = NULL;
       return 0;
     }
-  poly->Clipped = biggest (result);
+#warning FIXME Later
+//  poly->Clipped = biggest (result);
   assert (!poly->Clipped || poly_Valid (poly->Clipped));
   return 1;
 }
@@ -616,7 +623,9 @@ Subtract (POLYAREA * np1, PolygonType * p, Boolean fnp)
       p->NoHoles = NULL;
       return -1;
     }
-  p->Clipped = biggest (merged);
+#warning FIXME Later
+//  p->Clipped = biggest (merged);
+  p->Clipped = merged;
   assert (!p->Clipped || poly_Valid (p->Clipped));
   if (!p->Clipped)
     Message ("Polygon cleared out of existence near (%d, %d)\n",
@@ -946,7 +955,9 @@ Unsubtract (POLYAREA * np1, PolygonType * p)
       p->NoHoles = NULL;
       return 0;
     }
-  p->Clipped = biggest (merged);
+#warning FIXME Later
+//  p->Clipped = biggest (merged);
+  p->Clipped = merged;
   assert (!p->Clipped || poly_Valid (p->Clipped));
   return ClipOriginal (p);
 }
@@ -1083,205 +1094,6 @@ InitClip (DataTypePtr Data, LayerTypePtr layer, PolygonType * p)
   return 1;
 }
 
-/* --------------------------------------------------------------------------
- * remove redundant polygon points. Any point that lies on the straight
- * line between the points on either side of it is redundant.
- * returns true if any points are removed
- */
-Boolean
-RemoveExcessPolygonPoints (LayerTypePtr Layer, PolygonTypePtr Polygon)
-{
-  PointTypePtr pt1, pt2, pt3;
-  Cardinal n;
-  LineType line;
-  Boolean changed = False;
-
-  if (Undoing ())
-    return (False);
-  /* there are always at least three points in a polygon */
-  pt1 = &Polygon->Points[Polygon->PointN - 1];
-  pt2 = &Polygon->Points[0];
-  pt3 = &Polygon->Points[1];
-  for (n = 0; n < Polygon->PointN; n++, pt1++, pt2++, pt3++)
-    {
-      /* wrap around polygon */
-      if (n == 1)
-        pt1 = &Polygon->Points[0];
-      if (n == Polygon->PointN - 1)
-        pt3 = &Polygon->Points[0];
-      line.Point1 = *pt1;
-      line.Point2 = *pt3;
-      line.Thickness = 0;
-      if (IsPointOnLine ((float) pt2->X, (float) pt2->Y, 0.0, &line))
-        {
-          RemoveObject (POLYGONPOINT_TYPE, (void *) Layer, (void *) Polygon,
-                        (void *) pt2);
-          changed = True;
-        }
-    }
-  return (changed);
-}
-
-/* ---------------------------------------------------------------------------
- * returns the index of the polygon point which is the end
- * point of the segment with the lowest distance to the passed
- * coordinates
- */
-Cardinal
-GetLowestDistancePolygonPoint (PolygonTypePtr Polygon, LocationType X,
-                               LocationType Y)
-{
-  double mindistance = (double) MAX_COORD * MAX_COORD;
-  PointTypePtr ptr1 = &Polygon->Points[Polygon->PointN - 1],
-    ptr2 = &Polygon->Points[0];
-  Cardinal n, result = 0;
-
-  /* we calculate the distance to each segment and choose the
-   * shortest distance. If the closest approach between the
-   * given point and the projected line (i.e. the segment extended)
-   * is not on the segment, then the distance is the distance
-   * to the segment end point.
-   */
-
-  for (n = 0; n < Polygon->PointN; n++, ptr2++)
-    {
-      register double u, dx, dy;
-      dx = ptr2->X - ptr1->X;
-      dy = ptr2->Y - ptr1->Y;
-      if (dx != 0.0 || dy != 0.0)
-        {
-          /* projected intersection is at P1 + u(P2 - P1) */
-          u = ((X - ptr1->X) * dx + (Y - ptr1->Y) * dy) / (dx * dx + dy * dy);
-
-          if (u < 0.0)
-            {                   /* ptr1 is closest point */
-              u = SQUARE (X - ptr1->X) + SQUARE (Y - ptr1->Y);
-            }
-          else if (u > 1.0)
-            {                   /* ptr2 is closest point */
-              u = SQUARE (X - ptr2->X) + SQUARE (Y - ptr2->Y);
-            }
-          else
-            {                   /* projected intersection is closest point */
-              u = SQUARE (X - ptr1->X * (1.0 - u) - u * ptr2->X) +
-                SQUARE (Y - ptr1->Y * (1.0 - u) - u * ptr2->Y);
-            }
-          if (u < mindistance)
-            {
-              mindistance = u;
-              result = n;
-            }
-        }
-      ptr1 = ptr2;
-    }
-  return (result);
-}
-
-/* ---------------------------------------------------------------------------
- * go back to the  previous point of the polygon
- */
-void
-GoToPreviousPoint (void)
-{
-  switch (Crosshair.AttachedPolygon.PointN)
-    {
-      /* do nothing if mode has just been entered */
-    case 0:
-      break;
-
-      /* reset number of points and 'LINE_MODE' state */
-    case 1:
-      Crosshair.AttachedPolygon.PointN = 0;
-      Crosshair.AttachedLine.State = STATE_FIRST;
-      addedLines = 0;
-      break;
-
-      /* back-up one point */
-    default:
-      {
-        PointTypePtr points = Crosshair.AttachedPolygon.Points;
-        Cardinal n = Crosshair.AttachedPolygon.PointN - 2;
-
-        Crosshair.AttachedPolygon.PointN--;
-        Crosshair.AttachedLine.Point1.X = points[n].X;
-        Crosshair.AttachedLine.Point1.Y = points[n].Y;
-        break;
-      }
-    }
-}
-
-/* ---------------------------------------------------------------------------
- * close polygon if possible
- */
-void
-ClosePolygon (void)
-{
-  Cardinal n = Crosshair.AttachedPolygon.PointN;
-
-  /* check number of points */
-  if (n >= 3)
-    {
-      /* if 45 degree lines are what we want do a quick check
-       * if closing the polygon makes sense
-       */
-      if (!TEST_FLAG (ALLDIRECTIONFLAG, PCB))
-        {
-          BDimension dx, dy;
-
-          dx = abs (Crosshair.AttachedPolygon.Points[n - 1].X -
-                    Crosshair.AttachedPolygon.Points[0].X);
-          dy = abs (Crosshair.AttachedPolygon.Points[n - 1].Y -
-                    Crosshair.AttachedPolygon.Points[0].Y);
-          if (!(dx == 0 || dy == 0 || dx == dy))
-            {
-              Message
-                (_
-                 ("Cannot close polygon because 45 degree lines are requested.\n"));
-              return;
-            }
-        }
-      CopyAttachedPolygonToLayer ();
-      Draw ();
-    }
-  else
-    Message (_("A polygon has to have at least 3 points\n"));
-}
-
-/* ---------------------------------------------------------------------------
- * moves the data of the attached (new) polygon to the current layer
- */
-void
-CopyAttachedPolygonToLayer (void)
-{
-  PolygonTypePtr polygon;
-  int saveID;
-
-  /* move data to layer and clear attached struct */
-  polygon = CreateNewPolygon (CURRENT, NoFlags ());
-  saveID = polygon->ID;
-  *polygon = Crosshair.AttachedPolygon;
-  polygon->ID = saveID;
-  SET_FLAG (CLEARPOLYFLAG, polygon);
-  if (TEST_FLAG (NEWFULLPOLYFLAG, PCB))
-    SET_FLAG (FULLPOLYFLAG, polygon);
-  memset (&Crosshair.AttachedPolygon, 0, sizeof (PolygonType));
-  SetPolygonBoundingBox (polygon);
-  if (!CURRENT->polygon_tree)
-    CURRENT->polygon_tree = r_create_tree (NULL, 0, 0);
-  r_insert_entry (CURRENT->polygon_tree, (BoxType *) polygon, 0);
-  InitClip (PCB->Data, CURRENT, polygon);
-  DrawPolygon (CURRENT, polygon, 0);
-  SetChangedFlag (True);
-
-  /* reset state of attached line */
-  Crosshair.AttachedLine.State = STATE_FIRST;
-  addedLines = 0;
-
-  /* add to undo list */
-  AddObjectToCreateUndoList (POLYGON_TYPE, CURRENT, polygon, polygon);
-  IncrementUndoSerialNumber ();
-}
-
 /* find polygon holes in range, then call the callback function for
  * each hole. If the callback returns non-zero, stop
  * the search.
@@ -1572,15 +1384,17 @@ r_NoHolesPolygonDicer (PLINE * p, void (*emit) (PolygonTypePtr, void *), void *u
   if (!p->next)                 /* no holes */
     {
       PolygonType poly;
-      PointType pts[4];
+//      PointType pts[4];
 
       poly.BoundingBox.X1 = p->xmin;
       poly.BoundingBox.X2 = p->xmax;
       poly.BoundingBox.Y1 = p->ymin;
       poly.BoundingBox.Y2 = p->ymax;
-      poly.PointN = poly.PointMax = 4;
       poly.Clipped = pa;
       poly.NoHoles = NULL;
+#warning FIXME Later
+#if 0
+      poly.PointN = poly.PointMax = 4;
       poly.Points = pts;
       pts[0].X = pts[0].X2 = p->xmin;
       pts[0].Y = pts[0].Y2 = p->ymin;
@@ -1590,6 +1404,7 @@ r_NoHolesPolygonDicer (PLINE * p, void (*emit) (PolygonTypePtr, void *), void *u
       pts[2].Y = pts[2].Y2 = p->ymax;
       pts[3].X = pts[3].X2 = p->xmin;
       pts[3].Y = pts[3].Y2 = p->ymax;
+#endif
       poly.Flags = MakeFlags (CLEARPOLYFLAG);
       emit (&poly, user_data);
       poly_Free (&pa);
@@ -1675,6 +1490,9 @@ NoHolesPolygonDicer (PolygonTypePtr p, void (*emit) (PolygonTypePtr, void *),
 Boolean
 MorphPolygon (LayerTypePtr layer, PolygonTypePtr poly)
 {
+  return 0;
+#warning FIXME Later
+#if 0
   POLYAREA *p, *start;
   Boolean many = False;
   FlagType flags;
@@ -1738,4 +1556,5 @@ MorphPolygon (LayerTypePtr layer, PolygonTypePtr poly)
   inhibit = False;
   IncrementUndoSerialNumber ();
   return many;
+#endif
 }
diff --git a/src/polygon.h b/src/polygon.h
index 8f444fd..aec45ae 100644
--- a/src/polygon.h
+++ b/src/polygon.h
@@ -33,12 +33,6 @@
 
 #include "global.h"
 
-Cardinal GetLowestDistancePolygonPoint (PolygonTypePtr,
-					LocationType, LocationType);
-Boolean RemoveExcessPolygonPoints (LayerTypePtr, PolygonTypePtr);
-void GoToPreviousPoint (void);
-void ClosePolygon (void);
-void CopyAttachedPolygonToLayer (void);
 int PolygonHoles (const BoxType * range, LayerTypePtr, PolygonTypePtr,
 		  int (*callback) (PLINE *, LayerTypePtr, PolygonTypePtr));
 int PlowsPolygon (DataType *, int, void *, void *,
diff --git a/src/pour.c b/src/pour.c
index 61b5d80..d344818 100644
--- a/src/pour.c
+++ b/src/pour.c
@@ -72,32 +72,6 @@ RCSID ("$Id$");
  * local prototypes
  */
 
-#define CIRC_SEGS 36
-static double circleVerticies[] = {
-  1.0, 0.0,
-  0.98480775301221, 0.17364817766693,
-};
-
-#if 0
-int
-InitClip (DataTypePtr Data, LayerTypePtr layer, PolygonType * p)
-{
-  if (p->Clipped)
-    poly_Free (&p->Clipped);
-  p->Clipped = original_poly (p);
-  if (p->NoHoles)
-    poly_Free (&p->NoHoles);
-  p->NoHoles = NULL;
-  if (!p->Clipped)
-    return 0;
-  assert (poly_Valid (p->Clipped));
-  if (TEST_FLAG (CLEARPOLYFLAG, p))
-    clearPoly (Data, layer, p, NULL, 0);
-  else
-    p->NoHolesValid = 0;
-  return 1;
-}
-#endif
 
 /* --------------------------------------------------------------------------
  * remove redundant polygon points. Any point that lies on the straight
@@ -105,9 +79,37 @@ InitClip (DataTypePtr Data, LayerTypePtr layer, PolygonType * p)
  * returns true if any points are removed
  */
 Boolean
-RemoveExcessPourPoints (LayerTypePtr Layer, PolygonTypePtr Polygon)
+RemoveExcessPourPoints (LayerTypePtr Layer, PourTypePtr Pour)
 {
-  return RemoveExcessPolygonPoints (Layer, Polygon);
+  PointTypePtr pt1, pt2, pt3;
+  Cardinal n;
+  LineType line;
+  Boolean changed = False;
+
+  if (Undoing ())
+    return (False);
+  /* there are always at least three points in a pour */
+  pt1 = &Pour->Points[Pour->PointN - 1];
+  pt2 = &Pour->Points[0];
+  pt3 = &Pour->Points[1];
+  for (n = 0; n < Pour->PointN; n++, pt1++, pt2++, pt3++)
+    {
+      /* wrap around pour */
+      if (n == 1)
+        pt1 = &Pour->Points[0];
+      if (n == Pour->PointN - 1)
+        pt3 = &Pour->Points[0];
+      line.Point1 = *pt1;
+      line.Point2 = *pt3;
+      line.Thickness = 0;
+      if (IsPointOnLine ((float) pt2->X, (float) pt2->Y, 0.0, &line))
+        {
+          RemoveObject (POURPOINT_TYPE, (void *) Layer, (void *) Pour,
+                        (void *) pt2);
+          changed = True;
+        }
+    }
+  return (changed);
 }
 
 /* ---------------------------------------------------------------------------
@@ -116,10 +118,10 @@ RemoveExcessPourPoints (LayerTypePtr Layer, PolygonTypePtr Polygon)
  * coordinates
  */
 Cardinal
-GetLowestDistancePourPoint (PolygonTypePtr Polygon, LocationType X,
+GetLowestDistancePourPoint (PourTypePtr Pour, LocationType X,
                             LocationType Y)
 {
-  return GetLowestDistancePourPoint (Polygon, X, Y);
+  return GetLowestDistancePourPoint (Pour, X, Y);
 }
 
 /* ---------------------------------------------------------------------------
@@ -128,7 +130,7 @@ GetLowestDistancePourPoint (PolygonTypePtr Polygon, LocationType X,
 void
 GoToPreviousPourPoint (void)
 {
-  switch (Crosshair.AttachedPolygon.PointN)
+  switch (Crosshair.AttachedPour.PointN)
     {
       /* do nothing if mode has just been entered */
     case 0:
@@ -136,7 +138,7 @@ GoToPreviousPourPoint (void)
 
       /* reset number of points and 'LINE_MODE' state */
     case 1:
-      Crosshair.AttachedPolygon.PointN = 0;
+      Crosshair.AttachedPour.PointN = 0;
       Crosshair.AttachedLine.State = STATE_FIRST;
       addedLines = 0;
       break;
@@ -144,10 +146,10 @@ GoToPreviousPourPoint (void)
       /* back-up one point */
     default:
       {
-        PointTypePtr points = Crosshair.AttachedPolygon.Points;
-        Cardinal n = Crosshair.AttachedPolygon.PointN - 2;
+        PointTypePtr points = Crosshair.AttachedPour.Points;
+        Cardinal n = Crosshair.AttachedPour.PointN - 2;
 
-        Crosshair.AttachedPolygon.PointN--;
+        Crosshair.AttachedPour.PointN--;
         Crosshair.AttachedLine.Point1.X = points[n].X;
         Crosshair.AttachedLine.Point1.Y = points[n].Y;
         break;
@@ -161,7 +163,7 @@ GoToPreviousPourPoint (void)
 void
 ClosePour (void)
 {
-  Cardinal n = Crosshair.AttachedPolygon.PointN;
+  Cardinal n = Crosshair.AttachedPour.PointN;
 
   /* check number of points */
   if (n >= 3)
@@ -173,10 +175,10 @@ ClosePour (void)
         {
           BDimension dx, dy;
 
-          dx = abs (Crosshair.AttachedPolygon.Points[n - 1].X -
-                    Crosshair.AttachedPolygon.Points[0].X);
-          dy = abs (Crosshair.AttachedPolygon.Points[n - 1].Y -
-                    Crosshair.AttachedPolygon.Points[0].Y);
+          dx = abs (Crosshair.AttachedPour.Points[n - 1].X -
+                    Crosshair.AttachedPour.Points[0].X);
+          dy = abs (Crosshair.AttachedPour.Points[n - 1].Y -
+                    Crosshair.AttachedPour.Points[0].Y);
           if (!(dx == 0 || dy == 0 || dx == dy))
             {
               Message
@@ -185,7 +187,7 @@ ClosePour (void)
               return;
             }
         }
-      CopyAttachedPolygonToLayer ();
+      CopyAttachedPourToLayer ();
       Draw ();
     }
   else
@@ -198,24 +200,25 @@ ClosePour (void)
 void
 CopyAttachedPourToLayer (void)
 {
-  PolygonTypePtr polygon;
+  PourTypePtr pour;
   int saveID;
 
   /* move data to layer and clear attached struct */
-  polygon = CreateNewPolygon (CURRENT, NoFlags ());
-  saveID = polygon->ID;
-  *polygon = Crosshair.AttachedPolygon;
-  polygon->ID = saveID;
-  SET_FLAG (CLEARPOLYFLAG, polygon);
+  pour = CreateNewPour (CURRENT, NoFlags ());
+  saveID = pour->ID;
+  *pour = Crosshair.AttachedPour;
+  pour->ID = saveID;
+  SET_FLAG (CLEARPOLYFLAG, pour);
   if (TEST_FLAG (NEWFULLPOLYFLAG, PCB))
-    SET_FLAG (FULLPOLYFLAG, polygon);
-  memset (&Crosshair.AttachedPolygon, 0, sizeof (PolygonType));
-  SetPolygonBoundingBox (polygon);
-  if (!CURRENT->polygon_tree)
-    CURRENT->polygon_tree = r_create_tree (NULL, 0, 0);
-  r_insert_entry (CURRENT->polygon_tree, (BoxType *) polygon, 0);
-  InitClip (PCB->Data, CURRENT, polygon);
-  DrawPolygon (CURRENT, polygon, 0);
+    SET_FLAG (FULLPOLYFLAG, pour);
+  memset (&Crosshair.AttachedPour, 0, sizeof (PourType));
+  SetPourBoundingBox (pour);
+  if (!CURRENT->pour_tree)
+    CURRENT->pour_tree = r_create_tree (NULL, 0, 0);
+  r_insert_entry (CURRENT->pour_tree, (BoxType *) pour, 0);
+//  InitClip (PCB->Data, CURRENT, pour);
+//  DrawPolygon (CURRENT, polygon, 0);
+  DrawPour (CURRENT, pour, 0);
   SetChangedFlag (True);
 
   /* reset state of attached line */
@@ -223,7 +226,101 @@ CopyAttachedPourToLayer (void)
   addedLines = 0;
 
   /* add to undo list */
-  AddObjectToCreateUndoList (POLYGON_TYPE, CURRENT, polygon, polygon);
+  AddObjectToCreateUndoList (POUR_TYPE, CURRENT, pour, pour);
   IncrementUndoSerialNumber ();
 }
 
+static POLYAREA *
+original_pour (PourType * p)
+{
+  PLINE *contour = NULL;
+  POLYAREA *np = NULL;
+  Vector v;
+
+  /* first make initial polygon contour */
+  POLYGONPOINT_LOOP (p);
+  {
+    v[0] = point->X;
+    v[1] = point->Y;
+    if (contour == NULL)
+      {
+        if ((contour = poly_NewContour (v)) == NULL)
+          return NULL;
+      }
+    else
+      poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+  }
+  END_LOOP;
+  if (contour == NULL)
+    {
+      printf ("How did that escape - did the loop iterate zero times??\n");
+      POLYGONPOINT_LOOP (p);
+        {
+          printf ("Hello\n");
+        }
+      END_LOOP;
+      return NULL;
+    }
+  poly_PreContour (contour, TRUE);
+  /* make sure it is a positive contour */
+  if ((contour->Flags.orient) != PLF_DIR)
+    poly_InvContour (contour);
+  assert ((contour->Flags.orient) == PLF_DIR);
+  if ((np = poly_Create ()) == NULL)
+    return NULL;
+  poly_InclContour (np, contour);
+  assert (poly_Valid (np));
+#warning FIXME Later
+//  return biggest (np);
+  return np;
+}
+
+int
+InitPourClip (DataTypePtr Data, LayerTypePtr layer, PourType * p)
+{
+  POLYAREA *clipped, *pg;
+
+  printf ("InitPourClip\n");
+  /* Free any children? */
+  if (p->PolygonN)
+    {
+      printf ("We already had children. Killing them now.\n");
+      /* TODO: Free existing children, remove them from whatever r_tree etc.. */
+    }
+
+  clipped = original_pour (p);
+  if (!clipped)
+    {
+      printf ("Clipping returned NULL - can that be good?\n");
+      return 0;
+    }
+  assert (poly_Valid (clipped));
+  if (TEST_FLAG (CLEARPOLYFLAG, p))
+    {
+      /* Clip the pour against anything we can find in this layer */
+      /* TODO: Clear up API so the resulting areas are in "clipped" */
+      // e.g.: clearPour (Data, layer, p, NULL, 0);
+    }
+  pg = clipped;
+  do
+    {
+      /* TODO: For each piece of the clipped up polygon, create a new child */
+    }
+  while ((pg = pg->f) != clipped);
+
+  poly_Free (&clipped);
+  return 1;
+}
+
+void
+RestoreToPour (DataType * Data, int type, void *ptr1, void *ptr2)
+{
+  printf ("FIXME Later\n");
+}
+
+void
+ClearFromPour (DataType * Data, int type, void *ptr1, void *ptr2)
+{
+  printf ("FIXME Later\n");
+}
+
diff --git a/src/pour.h b/src/pour.h
index 0ed875e..2232df4 100644
--- a/src/pour.h
+++ b/src/pour.h
@@ -33,11 +33,15 @@
 
 #include "global.h"
 
-Cardinal GetLowestDistancePourPoint (PolygonTypePtr,
+Cardinal GetLowestDistancePourPoint (PourTypePtr,
 					LocationType, LocationType);
-Boolean RemoveExcessPourPoints (LayerTypePtr, PolygonTypePtr);
+Boolean RemoveExcessPourPoints (LayerTypePtr, PourTypePtr);
 void GoToPreviousPourPoint (void);
 void ClosePour (void);
 void CopyAttachedPourToLayer (void);
-//int InitClip(DataType *d, LayerType *l, PolygonType *p);
-#endif
+
+int InitPourClip(DataType *d, LayerType *l, PourType *p);
+void RestoreToPour(DataType *, int, void *, void *);
+void ClearFromPour(DataType *, int, void *, void *);
+
+#endif /* __POUR_INCLUDED__ */
diff --git a/src/puller.c b/src/puller.c
index 848d394..b219df5 100644
--- a/src/puller.c
+++ b/src/puller.c
@@ -1707,10 +1707,13 @@ gp_text_cb (const BoxType *b, void *cb)
 static int
 gp_poly_cb (const BoxType *b, void *cb)
 {
+#warning FIXME Later
+#if 0
   int i;
   const PolygonTypePtr p = (PolygonTypePtr) b;
   for (i=0; i<p->PointN; i++)
     gp_point (p->Points[i].X, p->Points[i].Y, 0, 0);
+#endif
   return 0;
 }
 
diff --git a/src/remove.c b/src/remove.c
index de88abe..1164fa3 100644
--- a/src/remove.c
+++ b/src/remove.c
@@ -46,6 +46,7 @@
 #include "move.h"
 #include "mymem.h"
 #include "polygon.h"
+#include "pour.h"
 #include "rats.h"
 #include "remove.h"
 #include "rtree.h"
@@ -70,11 +71,13 @@ static void *DestroyLine (LayerTypePtr, LineTypePtr);
 static void *DestroyArc (LayerTypePtr, ArcTypePtr);
 static void *DestroyText (LayerTypePtr, TextTypePtr);
 static void *DestroyPolygon (LayerTypePtr, PolygonTypePtr);
+static void *DestroyPour (LayerTypePtr, PourTypePtr);
 static void *DestroyElement (ElementTypePtr);
 static void *RemoveVia (PinTypePtr);
 static void *RemoveRat (RatTypePtr);
 static void *DestroyPolygonPoint (LayerTypePtr, PolygonTypePtr, PointTypePtr);
-static void *RemovePolygonPoint (LayerTypePtr, PolygonTypePtr, PointTypePtr);
+static void *DestroyPourPoint (LayerTypePtr, PourTypePtr, PointTypePtr);
+static void *RemovePourPoint (LayerTypePtr, PourTypePtr, PointTypePtr);
 static void *RemoveLinePoint (LayerTypePtr, LineTypePtr, PointTypePtr);
 
 /* ---------------------------------------------------------------------------
@@ -84,13 +87,15 @@ static ObjectFunctionType RemoveFunctions = {
   RemoveLine,
   RemoveText,
   RemovePolygon,
+  RemovePour,
   RemoveVia,
   RemoveElement,
   NULL,
   NULL,
   NULL,
   RemoveLinePoint,
-  RemovePolygonPoint,
+  NULL,
+  RemovePourPoint,
   RemoveArc,
   RemoveRat
 };
@@ -98,6 +103,7 @@ static ObjectFunctionType DestroyFunctions = {
   DestroyLine,
   DestroyText,
   DestroyPolygon,
+  DestroyPour,
   DestroyVia,
   DestroyElement,
   NULL,
@@ -105,6 +111,7 @@ static ObjectFunctionType DestroyFunctions = {
   NULL,
   NULL,
   DestroyPolygonPoint,
+  DestroyPourPoint,
   DestroyArc,
   DestroyRat
 };
@@ -185,12 +192,31 @@ DestroyPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
 }
 
 /* ---------------------------------------------------------------------------
+ * destroys a pour from a layer
+ */
+static void *
+DestroyPour (LayerTypePtr Layer, PourTypePtr Pour)
+{
+#warning FIXME Later
+  r_delete_entry (Layer->pour_tree, (BoxTypePtr) Pour);
+  FreePourMemory (Pour);
+  *Pour = Layer->Pour[--Layer->PourN];
+  r_substitute (Layer->pour_tree,
+                (BoxType *) & Layer->Pour[Layer->PourN],
+                (BoxType *) Pour);
+  memset (&Layer->Pour[Layer->PourN], 0, sizeof (PourType));
+  return (NULL);
+}
+
+/* ---------------------------------------------------------------------------
  * removes a polygon-point from a polygon and destroys the data
  */
 static void *
 DestroyPolygonPoint (LayerTypePtr Layer,
                      PolygonTypePtr Polygon, PointTypePtr Point)
 {
+#warning FIXME Later
+#if 0
   PointTypePtr ptr;
 
   if (Polygon->PointN <= 3)
@@ -205,10 +231,34 @@ DestroyPolygonPoint (LayerTypePtr Layer,
   SetPolygonBoundingBox (Polygon);
   r_insert_entry (Layer->polygon_tree, (BoxType *) Polygon, 0);
   InitClip (PCB->Data, Layer, Polygon);
+#endif
   return (Polygon);
 }
 
 /* ---------------------------------------------------------------------------
+ * removes a polygon-point from a polygon and destroys the data
+ */
+static void *
+DestroyPourPoint (LayerTypePtr Layer, PourTypePtr Pour, PointTypePtr Point)
+{
+  PointTypePtr ptr;
+
+  if (Pour->PointN <= 3)
+    return RemovePour(Layer, Pour);
+  r_delete_entry (Layer->pour_tree, (BoxType *) Pour);
+  for (ptr = Point + 1; ptr != &Pour->Points[Pour->PointN]; ptr++)
+    {
+      *Point = *ptr;
+      Point = ptr;
+    }
+  Pour->PointN--;
+  SetPourBoundingBox (Pour);
+  r_insert_entry (Layer->pour_tree, (BoxType *) Pour, 0);
+  InitPourClip (PCB->Data, Layer, Pour);
+  return (Pour);
+}
+
+/* ---------------------------------------------------------------------------
  * destroys a text from a layer
  */
 static void *
@@ -461,21 +511,38 @@ RemovePolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
 }
 
 /* ---------------------------------------------------------------------------
- * removes a polygon-point from a polygon
+ * removes a pour from a layer
+ */
+void *
+RemovePour (LayerTypePtr Layer, PourTypePtr Pour)
+{
+  /* erase from screen */
+  if (Layer->On)
+    {
+      ErasePour (Pour);
+      if (!Bulk)
+        Draw ();
+    }
+  MoveObjectToRemoveUndoList (POUR_TYPE, Layer, Pour, Pour);
+  return (NULL);
+}
+
+/* ---------------------------------------------------------------------------
+ * removes a pour-point from a pour
  */
 static void *
-RemovePolygonPoint (LayerTypePtr Layer,
-                    PolygonTypePtr Polygon, PointTypePtr Point)
+RemovePourPoint (LayerTypePtr Layer,
+                    PourTypePtr Pour, PointTypePtr Point)
 {
   PointTypePtr ptr;
   Cardinal index = 0;
 
-  if (Polygon->PointN <= 3)
-    return RemovePolygon(Layer, Polygon);
+  if (Pour->PointN <= 3)
+    return RemovePour(Layer, Pour);
   if (Layer->On)
-    ErasePolygon (Polygon);
-  /* insert the polygon-point into the undo list */
-  POLYGONPOINT_LOOP (Polygon);
+    ErasePour (Pour);
+  /* insert the pour-point into the undo list */
+  POLYGONPOINT_LOOP (Pour);
   {
     if (point == Point)
       {
@@ -485,24 +552,24 @@ RemovePolygonPoint (LayerTypePtr Layer,
   }
   END_LOOP;
 
-  AddObjectToRemovePointUndoList (POLYGONPOINT_TYPE, Layer, Polygon, index);
-  r_delete_entry (Layer->polygon_tree, (BoxType *) Polygon);
+  AddObjectToRemovePointUndoList (POLYGONPOINT_TYPE, Layer, Pour, index);
+  r_delete_entry (Layer->pour_tree, (BoxType *) Pour);
 
   /* remove point from list, keep point order */
-  for (ptr = Point + 1; ptr != &Polygon->Points[Polygon->PointN]; ptr++)
+  for (ptr = Point + 1; ptr != &Pour->Points[Pour->PointN]; ptr++)
     {
       *Point = *ptr;
       Point = ptr;
     }
-  Polygon->PointN--;
-  SetPolygonBoundingBox (Polygon);
-  r_insert_entry (Layer->polygon_tree, (BoxType *) Polygon, 0);
-  RemoveExcessPolygonPoints (Layer, Polygon);
-  InitClip (PCB->Data, Layer, Polygon);
-  /* redraw polygon if necessary */
+  Pour->PointN--;
+  SetPourBoundingBox (Pour);
+  r_insert_entry (Layer->pour_tree, (BoxType *) Pour, 0);
+  RemoveExcessPourPoints (Layer, Pour);
+  InitPourClip (PCB->Data, Layer, Pour);
+  /* redraw pour if necessary */
   if (Layer->On)
     {
-      DrawPolygon (Layer, Polygon, 0);
+      DrawPour (Layer, Pour, 0);
       if (!Bulk)
         Draw ();
     }
diff --git a/src/remove.h b/src/remove.h
index 8b7c166..eb8c5da 100644
--- a/src/remove.h
+++ b/src/remove.h
@@ -43,6 +43,7 @@
 void *RemoveLine (LayerTypePtr, LineTypePtr);
 void *RemoveArc (LayerTypePtr, ArcTypePtr);
 void *RemovePolygon (LayerTypePtr, PolygonTypePtr);
+void *RemovePour (LayerTypePtr, PourTypePtr);
 void *RemoveText (LayerTypePtr, TextTypePtr);
 void *RemoveElement (ElementTypePtr);
 void ClearRemoveList (void);
diff --git a/src/report.c b/src/report.c
index af9e0b3..5a19390 100644
--- a/src/report.c
+++ b/src/report.c
@@ -330,11 +330,42 @@ ReportDialog (int argc, char **argv, int x, int y)
 		 flags_to_string (Polygon->Flags, POLYGON_TYPE),
 		 Polygon->BoundingBox.X1, Polygon->BoundingBox.Y1,
 		 Polygon->BoundingBox.X2, Polygon->BoundingBox.Y2,
+     0, 0,
+#warning FIXME Later
+#if 0
 		 Polygon->PointN, Polygon->PointMax - Polygon->PointN,
+#endif
 		 GetLayerNumber (PCB->Data, (LayerTypePtr) ptr1),
 		 TEST_FLAG (LOCKFLAG, Polygon) ? "It is LOCKED\n" : "");
 	break;
       }
+    case POUR_TYPE:
+      {
+	PourTypePtr Pour;
+#ifndef NDEBUG
+	if (gui->shift_is_pressed ())
+	  {
+	    LayerTypePtr layer = (LayerTypePtr) ptr1;
+	    __r_dump_tree (layer->pour_tree->root, 0);
+	    return;
+	  }
+#endif
+	Pour = (PourTypePtr) ptr2;
+
+	sprintf (&report[0], "POUR ID# %ld   Flags:%s\n"
+		 "Its bounding box is (%d,%d) (%d,%d)\n"
+		 "It has %d points and could store %d more\n"
+		 "without using more memory.\n"
+		 "It resides on layer %d\n"
+		 "%s", Pour->ID,
+		 flags_to_string (Pour->Flags, POUR_TYPE),
+		 Pour->BoundingBox.X1, Pour->BoundingBox.Y1,
+		 Pour->BoundingBox.X2, Pour->BoundingBox.Y2,
+		 Pour->PointN, Pour->PointMax - Pour->PointN,
+		 GetLayerNumber (PCB->Data, (LayerTypePtr) ptr1),
+		 TEST_FLAG (LOCKFLAG, Pour) ? "It is LOCKED\n" : "");
+	break;
+      }
     case PAD_TYPE:
       {
 	int len, dx, dy, mgap;
diff --git a/src/rotate.c b/src/rotate.c
index 247a1a9..27f5a84 100644
--- a/src/rotate.c
+++ b/src/rotate.c
@@ -44,6 +44,7 @@
 #include "error.h"
 #include "misc.h"
 #include "polygon.h"
+#include "pour.h"
 #include "rotate.h"
 #include "rtree.h"
 #include "rubberband.h"
@@ -81,12 +82,14 @@ static ObjectFunctionType RotateFunctions = {
   RotateText,
   NULL,
   NULL,
+  NULL,
   RotateElement,
   RotateElementName,
   NULL,
   NULL,
   RotateLinePoint,
   NULL,
+  NULL,
   RotateArc,
   NULL
 };
@@ -164,12 +167,30 @@ void
 RotatePolygonLowLevel (PolygonTypePtr Polygon,
 		       LocationType X, LocationType Y, BYTE Number)
 {
+#warning FIXME Later
+#if 0
   POLYGONPOINT_LOOP (Polygon);
   {
     ROTATE (point->X, point->Y, X, Y, Number);
   }
   END_LOOP;
   RotateBoxLowLevel (&Polygon->BoundingBox, X, Y, Number);
+#endif
+}
+
+/* ---------------------------------------------------------------------------
+ * rotates a pour in 90 degree steps
+ */
+void
+RotatePourLowLevel (PourTypePtr Pour,
+		       LocationType X, LocationType Y, BYTE Number)
+{
+  POURPOINT_LOOP (Pour);
+  {
+    ROTATE (point->X, point->Y, X, Y, Number);
+  }
+  END_LOOP;
+  RotateBoxLowLevel (&Pour->BoundingBox, X, Y, Number);
 }
 
 /* ---------------------------------------------------------------------------
@@ -179,11 +200,11 @@ static void *
 RotateText (LayerTypePtr Layer, TextTypePtr Text)
 {
   EraseText (Layer, Text);
-  RestoreToPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+  RestoreToPour (PCB->Data, TEXT_TYPE, Layer, Text);
   r_delete_entry (Layer->text_tree, (BoxTypePtr) Text);
   RotateTextLowLevel (Text, CenterX, CenterY, Number);
   r_insert_entry (Layer->text_tree, (BoxTypePtr) Text, 0);
-  ClearFromPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+  ClearFromPour (PCB->Data, TEXT_TYPE, Layer, Text);
   DrawText (Layer, Text, 0);
   Draw ();
   return (Text);
@@ -241,7 +262,7 @@ RotateElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
     /* pre-delete the pins from the pin-tree before their coordinates change */
     if (Data)
       r_delete_entry (Data->pin_tree, (BoxType *) pin);
-    RestoreToPolygon (Data, PIN_TYPE, Element, pin);
+    RestoreToPour (Data, PIN_TYPE, Element, pin);
     ROTATE_PIN_LOWLEVEL (pin, X, Y, Number);
   }
   END_LOOP;
@@ -250,7 +271,7 @@ RotateElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
     /* pre-delete the pads before their coordinates change */
     if (Data)
       r_delete_entry (Data->pad_tree, (BoxType *) pad);
-    RestoreToPolygon (Data, PAD_TYPE, Element, pad);
+    RestoreToPour (Data, PAD_TYPE, Element, pad);
     ROTATE_PAD_LOWLEVEL (pad, X, Y, Number);
   }
   END_LOOP;
@@ -262,7 +283,7 @@ RotateElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
   ROTATE (Element->MarkX, Element->MarkY, X, Y, Number);
   /* SetElementBoundingBox reenters the rtree data */
   SetElementBoundingBox (Data, Element, &PCB->Font);
-  ClearFromPolygon (Data, ELEMENT_TYPE, Element, Element);
+  ClearFromPour (Data, ELEMENT_TYPE, Element, Element);
 }
 
 /* ---------------------------------------------------------------------------
@@ -274,7 +295,7 @@ RotateLinePoint (LayerTypePtr Layer, LineTypePtr Line, PointTypePtr Point)
   EraseLine (Line);
   if (Layer)
     {
-      RestoreToPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+      RestoreToPour (PCB->Data, LINE_TYPE, Layer, Line);
       r_delete_entry (Layer->line_tree, (BoxTypePtr) Line);
     }
   else
@@ -284,7 +305,7 @@ RotateLinePoint (LayerTypePtr Layer, LineTypePtr Line, PointTypePtr Point)
   if (Layer)
     {
       r_insert_entry (Layer->line_tree, (BoxTypePtr) Line, 0);
-      ClearFromPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+      ClearFromPour (PCB->Data, LINE_TYPE, Layer, Line);
       DrawLine (Layer, Line, 0);
     }
   else
@@ -388,7 +409,7 @@ RotateObject (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
       EraseLine (ptr->Line);
       if (ptr->Layer)
 	{
-	  RestoreToPolygon (PCB->Data, LINE_TYPE, ptr->Layer, ptr->Line);
+	  RestoreToPour (PCB->Data, LINE_TYPE, ptr->Layer, ptr->Line);
 	  r_delete_entry (ptr->Layer->line_tree, (BoxType *) ptr->Line);
 	}
       else
@@ -398,7 +419,7 @@ RotateObject (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
       if (ptr->Layer)
 	{
 	  r_insert_entry (ptr->Layer->line_tree, (BoxType *) ptr->Line, 0);
-	  ClearFromPolygon (PCB->Data, LINE_TYPE, ptr->Layer, ptr->Line);
+	  ClearFromPour (PCB->Data, LINE_TYPE, ptr->Layer, ptr->Line);
 	  DrawLine (ptr->Layer, ptr->Line, 0);
 	}
       else
diff --git a/src/rotate.h b/src/rotate.h
index f032fcb..d5fc399 100644
--- a/src/rotate.h
+++ b/src/rotate.h
@@ -65,6 +65,7 @@ void RotateArcLowLevel (ArcTypePtr, LocationType, LocationType, BYTE);
 void RotateBoxLowLevel (BoxTypePtr, LocationType, LocationType, BYTE);
 void RotateTextLowLevel (TextTypePtr, LocationType, LocationType, BYTE);
 void RotatePolygonLowLevel (PolygonTypePtr, LocationType, LocationType, BYTE);
+void RotatePourLowLevel (PourTypePtr, LocationType, LocationType, BYTE);
 void RotateElementLowLevel (DataTypePtr, ElementTypePtr, LocationType,
 			    LocationType, BYTE);
 void *RotateObject (int, void *, void *, void *, LocationType, LocationType,
diff --git a/src/search.c b/src/search.c
index 0d75500..56e23c5 100644
--- a/src/search.c
+++ b/src/search.c
@@ -90,7 +90,7 @@ static Boolean SearchElementNameByLocation (int, ElementTypePtr *,
 					    Boolean);
 static Boolean SearchLinePointByLocation (int, LayerTypePtr *, LineTypePtr *,
 					  PointTypePtr *);
-static Boolean SearchPointByLocation (int, LayerTypePtr *, PolygonTypePtr *,
+static Boolean SearchPourPointByLocation (int, LayerTypePtr *, PourTypePtr *,
 				      PointTypePtr *);
 static Boolean SearchElementByLocation (int, ElementTypePtr *,
 					ElementTypePtr *, ElementTypePtr *,
@@ -512,27 +512,27 @@ SearchLinePointByLocation (int locked, LayerTypePtr * Layer,
 }
 
 /* ---------------------------------------------------------------------------
- * searches a polygon-point on all layers that are switched on
+ * searches a pour-point on all layers that are switched on
  * in layerstack order
  */
 static Boolean
-SearchPointByLocation (int locked, LayerTypePtr * Layer,
-		       PolygonTypePtr * Polygon, PointTypePtr * Point)
+SearchPourPointByLocation (int locked, LayerTypePtr * Layer,
+		       PourTypePtr * Pour, PointTypePtr * Point)
 {
   float d, least;
   Boolean found = False;
 
-  least = SQUARE (SearchRadius + MAX_POLYGON_POINT_DISTANCE);
+  least = SQUARE (SearchRadius + MAX_POUR_POINT_DISTANCE);
   *Layer = SearchLayer;
-  POLYGON_LOOP (*Layer);
+  POUR_LOOP (*Layer);
   {
-    POLYGONPOINT_LOOP (polygon);
+    POURPOINT_LOOP (pour);
     {
       d = SQUARE (point->X - PosX) + SQUARE (point->Y - PosY);
       if (d < least)
 	{
 	  least = d;
-	  *Polygon = polygon;
+	  *Pour = pour;
 	  *Point = point;
 	  found = True;
 	}
@@ -1243,11 +1243,11 @@ SearchObjectByLocation (int Type,
       if (SearchLayer->On)
 	{
 	  if ((HigherAvail & (PIN_TYPE | PAD_TYPE)) == 0 &&
-	      Type & POLYGONPOINT_TYPE &&
-	      SearchPointByLocation (locked,
-				     (LayerTypePtr *) Result1,
-				     (PolygonTypePtr *) Result2,
-				     (PointTypePtr *) Result3))
+	      Type & POURPOINT_TYPE &&
+	      SearchPourPointByLocation (locked,
+					 (LayerTypePtr *) Result1,
+					 (PourTypePtr *) Result2,
+					 (PointTypePtr *) Result3))
 	    return (POLYGONPOINT_TYPE);
 
 	  if ((HigherAvail & (PIN_TYPE | PAD_TYPE)) == 0 &&
@@ -1429,7 +1429,8 @@ SearchObjectByID (DataTypePtr Base,
       }
       ENDALL_LOOP;
     }
-
+#warning FIXME Later
+#if 0
   if (type == POLYGON_TYPE || type == POLYGONPOINT_TYPE)
     {
       ALLPOLYGON_LOOP (Base);
@@ -1455,6 +1456,33 @@ SearchObjectByID (DataTypePtr Base,
       }
       ENDALL_LOOP;
     }
+#endif
+  if (type == POUR_TYPE || type == POURPOINT_TYPE)
+    {
+      ALLPOUR_LOOP (Base);
+      {
+	if (pour->ID == ID)
+	  {
+	    *Result1 = (void *) layer;
+	    *Result2 = *Result3 = (void *) pour;
+	    return (POUR_TYPE);
+	  }
+	if (type == POURPOINT_TYPE)
+	  POURPOINT_LOOP (pour);
+	{
+	  if (point->ID == ID)
+	    {
+	      *Result1 = (void *) layer;
+	      *Result2 = (void *) pour;
+	      *Result3 = (void *) point;
+	      return (POURPOINT_TYPE);
+	    }
+	}
+	END_LOOP;
+      }
+      ENDALL_LOOP;
+    }
+
   if (type == VIA_TYPE)
     {
       VIA_LOOP (Base);
diff --git a/src/select.c b/src/select.c
index 7b96fec..51cc458 100644
--- a/src/select.c
+++ b/src/select.c
@@ -513,8 +513,19 @@ ObjectOperation (ObjectFunctionTypePtr F,
       break;
 
     case POLYGONPOINT_TYPE:
-      if (F->Point)
-	return (F->Point ((LayerTypePtr) Ptr1, (PolygonTypePtr) Ptr2,
+      if (F->PolygonPoint)
+	return (F->PolygonPoint ((LayerTypePtr) Ptr1, (PolygonTypePtr) Ptr2,
+			  (PointTypePtr) Ptr3));
+      break;
+
+    case POUR_TYPE:
+      if (F->Pour)
+	return (F->Pour ((LayerTypePtr) Ptr1, (PourTypePtr) Ptr2));
+      break;
+
+    case POURPOINT_TYPE:
+      if (F->PourPoint)
+	return (F->PourPoint ((LayerTypePtr) Ptr1, (PourTypePtr) Ptr2,
 			  (PointTypePtr) Ptr3));
       break;
 
diff --git a/src/set.c b/src/set.c
index 912db04..e9ced1d 100644
--- a/src/set.c
+++ b/src/set.c
@@ -248,11 +248,11 @@ SetMode (int Mode)
   addedLines = 0;
   Crosshair.AttachedObject.Type = NO_TYPE;
   Crosshair.AttachedObject.State = STATE_FIRST;
-  Crosshair.AttachedPolygon.PointN = 0;
+  Crosshair.AttachedPour.PointN = 0;
   if (PCB->RatDraw)
     {
       if (Mode == ARC_MODE || Mode == RECTANGLE_MODE ||
-	  Mode == VIA_MODE || Mode == POLYGON_MODE ||
+	  Mode == VIA_MODE || Mode == POUR_MODE ||
 	  Mode == TEXT_MODE || Mode == INSERTPOINT_MODE ||
 	  Mode == THERMAL_MODE)
 	{
diff --git a/src/undo.c b/src/undo.c
index 998fc2c..983eaf2 100644
--- a/src/undo.c
+++ b/src/undo.c
@@ -62,6 +62,7 @@
 #include "move.h"
 #include "mymem.h"
 #include "polygon.h"
+#include "pour.h"
 #include "remove.h"
 #include "rotate.h"
 #include "rtree.h"
@@ -320,9 +321,9 @@ UndoClearPoly (UndoListTypePtr Entry)
   if (type != NO_TYPE)
     {
       if (Entry->Data.ClearPoly.Clear)
-	RestoreToPolygon (PCB->Data, type, Entry->Data.ClearPoly.Layer, ptr3);
+	RestoreToPour (PCB->Data, type, Entry->Data.ClearPoly.Layer, ptr3);
       else
-	ClearFromPolygon (PCB->Data, type, Entry->Data.ClearPoly.Layer, ptr3);
+	ClearFromPour (PCB->Data, type, Entry->Data.ClearPoly.Layer, ptr3);
       Entry->Data.ClearPoly.Clear = !Entry->Data.ClearPoly.Clear;
       return True;
     }
@@ -436,11 +437,11 @@ UndoChangeClearSize (UndoListTypePtr Entry)
       if (TEST_FLAG (LOCKFLAG, (LineTypePtr) ptr2))
 	return (False);
       swap = ((PinTypePtr) ptr2)->Clearance;
-      RestoreToPolygon (PCB->Data, type, ptr1, ptr2);
+      RestoreToPour (PCB->Data, type, ptr1, ptr2);
       if (andDraw)
 	EraseObject (type, ptr1, ptr2);
       ((PinTypePtr) ptr2)->Clearance = Entry->Data.Size;
-      ClearFromPolygon (PCB->Data, type, ptr1, ptr2);
+      ClearFromPour (PCB->Data, type, ptr1, ptr2);
       Entry->Data.Size = swap;
       if (andDraw)
 	DrawObject (type, ptr1, ptr2, 0);
@@ -504,12 +505,12 @@ UndoChangeSize (UndoListTypePtr Entry)
       /* Wow! can any object be treated as a pin type for size change?? */
       /* pins, vias, lines, and arcs can. Text can't but it has it's own mechanism */
       swap = ((PinTypePtr) ptr2)->Thickness;
-      RestoreToPolygon (PCB->Data, type, ptr1, ptr2);
+      RestoreToPour (PCB->Data, type, ptr1, ptr2);
       if (andDraw)
 	EraseObject (type, ptr1, ptr2);
       ((PinTypePtr) ptr2)->Thickness = Entry->Data.Size;
       Entry->Data.Size = swap;
-      ClearFromPolygon (PCB->Data, type, ptr1, ptr2);
+      ClearFromPour (PCB->Data, type, ptr1, ptr2);
       if (andDraw)
 	DrawObject (type, ptr1, ptr2, 0);
       return (True);
@@ -748,37 +749,37 @@ UndoRemovePoint (UndoListTypePtr Entry)
 }
 
 /* ---------------------------------------------------------------------------
- * recovers an inserted polygon point
+ * recovers an inserted pour point
  * returns true on success
  */
 static Boolean
 UndoInsertPoint (UndoListTypePtr Entry)
 {
   LayerTypePtr layer;
-  PolygonTypePtr polygon;
+  PourTypePtr pour;
   PointTypePtr pnt;
   int type;
 
-  assert (Entry->Kind == POLYGONPOINT_TYPE);
+  assert (Entry->Kind == POURPOINT_TYPE);
   /* lookup entry by it's ID */
   type =
-    SearchObjectByID (PCB->Data, (void *) &layer, (void *) &polygon,
+    SearchObjectByID (PCB->Data, (void *) &layer, (void *) &pour,
 		      (void *) &pnt, Entry->ID, Entry->Kind);
   switch (type)
     {
-    case POLYGONPOINT_TYPE:	/* removes an inserted polygon point */
+    case POURPOINT_TYPE:	/* removes an inserted pour point */
       {
-	if (TEST_FLAG (LOCKFLAG, polygon))
+	if (TEST_FLAG (LOCKFLAG, pour))
 	  return (False);
 	if (andDraw && layer->On)
-	  ErasePolygon (polygon);
+	  ErasePour (pour);
 	Entry->Data.RemovedPoint.X = pnt->X;
 	Entry->Data.RemovedPoint.Y = pnt->Y;
 	Entry->Data.RemovedPoint.ID = pnt->ID;
-	Entry->ID = polygon->ID;
-	Entry->Kind = POLYGON_TYPE;
+	Entry->ID = pour->ID;
+	Entry->Kind = POUR_TYPE;
 	Entry->Type = UNDO_REMOVE_POINT;
-	POLYGONPOINT_LOOP (polygon);
+	POURPOINT_LOOP (pour);
 	{
 	  if (pnt == point)
 	    {
@@ -787,9 +788,9 @@ UndoInsertPoint (UndoListTypePtr Entry)
 	    }
 	}
 	END_LOOP;
-	DestroyObject (PCB->Data, POLYGONPOINT_TYPE, layer, polygon, pnt);
+	DestroyObject (PCB->Data, POURPOINT_TYPE, layer, pour, pnt);
 	if (andDraw && layer->On)
-	  DrawPolygon (layer, polygon, 0);
+	  DrawPour (layer, pour, 0);
 	return (True);
       }
 
@@ -1161,6 +1162,16 @@ AddObjectToClearPolyUndoList (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
 }
 
 /* ---------------------------------------------------------------------------
+ * adds an object to the list of clearpoly objects
+ */
+void
+AddObjectToClearPourUndoList (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
+			      Boolean clear)
+{
+  printf ("FIXME Later\n");
+}
+
+/* ---------------------------------------------------------------------------
  * adds an object to the list of mirrored objects
  */
 void
@@ -1317,7 +1328,7 @@ AddObjectToCreateUndoList (int Type, void *Ptr1, void *Ptr2, void *Ptr3)
 
   if (!Locked)
     undo = GetUndoSlot (UNDO_CREATE, OBJECT_ID (Ptr3), Type);
-  ClearFromPolygon (PCB->Data, Type, Ptr1, Ptr2);
+  ClearFromPour (PCB->Data, Type, Ptr1, Ptr2);
 }
 
 /* ---------------------------------------------------------------------------
diff --git a/src/undo.h b/src/undo.h
index a138927..1ff1ca7 100644
--- a/src/undo.h
+++ b/src/undo.h
@@ -62,6 +62,7 @@ void AddObjectToClearSizeUndoList (int, void *, void *, void *);
 void AddObjectToMaskSizeUndoList (int, void *, void *, void *);
 void AddObjectToChangeAnglesUndoList (int, void *, void *, void *);
 void AddObjectToClearPolyUndoList (int, void *, void *, void *, Boolean);
+void AddObjectToClearPourUndoList (int, void *, void *, void *, Boolean);
 void AddLayerChangeToUndoList (int, int);
 void AddNetlistLibToUndoList (LibraryTypePtr);
 void LockUndo (void);

Bottom: 5650c98e1961635f23c05754016604bc3632c74e
Top:    576d980594e05270d72307d66992c1e470ed4aa6
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-06-11 00:24:08 +0100

Refresh of add-support-for-a-poured-objec-I

---

diff --git a/src/buffer.c b/src/buffer.c
index e6b530f..783671e 100644
--- a/src/buffer.c
+++ b/src/buffer.c
@@ -389,6 +389,7 @@ MovePourToBuffer (LayerTypePtr Layer, PourTypePtr Pour)
 {
   LayerTypePtr lay;
   PourTypePtr pour;
+  Cardinal i;
 
   RestoreToPours (Source, POLYGON_TYPE, Layer, Pour);
   r_delete_entry (Layer->pour_tree, (BoxTypePtr) Pour);
@@ -397,12 +398,14 @@ MovePourToBuffer (LayerTypePtr Layer, PourTypePtr Pour)
   *pour = *Pour;
   CLEAR_FLAG (FOUNDFLAG, pour);
   if (Pour != &Layer->Pour[--Layer->PourN])
-  {
-  *Pour = Layer->Pour[Layer->PourN];
-  r_substitute (Layer->pour_tree,
-		(BoxTypePtr) & Layer->Pour[Layer->PourN],
-		(BoxTypePtr) Pour);
-  }
+    {
+      *Pour = Layer->Pour[Layer->PourN];
+      r_substitute (Layer->pour_tree,
+                    (BoxTypePtr) & Layer->Pour[Layer->PourN],
+                    (BoxTypePtr) Pour);
+      for (i = 0; i < Pour->PolygonN; i++)
+        Pour->Polygons[i].ParentPour = Pour;
+    }
   memset (&Layer->Pour[Layer->PourN], 0, sizeof (PourType));
   if (!lay->pour_tree)
     lay->pour_tree = r_create_tree (NULL, 0, 0);
diff --git a/src/move.c b/src/move.c
index d2431c5..4b7b54a 100644
--- a/src/move.c
+++ b/src/move.c
@@ -718,6 +718,7 @@ MovePourToLayerLowLevel (LayerTypePtr Source, PourTypePtr Pour,
 			    LayerTypePtr Destination)
 {
   PourTypePtr new = GetPourMemory (Destination);
+  Cardinal i;
 
   r_delete_entry (Source->pour_tree, (BoxType *) Pour);
   /* copy the data and remove it from the former layer */
@@ -726,6 +727,8 @@ MovePourToLayerLowLevel (LayerTypePtr Source, PourTypePtr Pour,
   r_substitute (Source->pour_tree,
 		(BoxType *) & Source->Pour[Source->PourN],
 		(BoxType *) Pour);
+  for (i = 0; i < Pour->PolygonN; i++)
+    Pour->Polygons[i].ParentPour = Pour;
   memset (&Source->Pour[Source->PourN], 0, sizeof (PourType));
   if (!Destination->pour_tree)
     Destination->pour_tree = r_create_tree (NULL, 0, 0);
diff --git a/src/pour.c b/src/pour.c
index f878e6c..61190a4 100644
--- a/src/pour.c
+++ b/src/pour.c
@@ -988,7 +988,7 @@ original_pour_poly (PourType * p)
 
           hole++;
         }
-  }
+    }
   return np;
 }
 
@@ -1184,6 +1184,12 @@ InitPourClip (DataTypePtr Data, LayerTypePtr layer, PourType * pour)
       printf ("Clipping returned NULL - can that be good?\n");
       return 0;
     }
+  if (!pg->contours)
+    {
+      printf ("Clipping returned NULL contours - can that be good?\n");
+      printf ("Pour was %ld, %p\n", pour->ID, pour);
+      return 0;
+    }
 //  assert (poly_Valid (clipped));
   if (TEST_FLAG (CLEARPOLYFLAG, pour))
     {
@@ -1197,6 +1203,13 @@ InitPourClip (DataTypePtr Data, LayerTypePtr layer, PourType * pour)
       return 0;
     }
 
+  if (pg->contours == NULL)
+    {
+      printf ("Got pg->contours == NULL for some reason\n");
+      printf ("Pour was %ld, %p\n", pour->ID, pour);
+      return 0;
+    }
+
   count_all = count_added = 0;
   /* For each piece of the clipped up polygon, create a new child */
   start_pg = pg;
@@ -1411,12 +1424,12 @@ PolyToPoursOnLayer (DataType *Destination, LayerType *Layer,
         }
       while ((pline = pline->next) != NULL);
 
-      InitPourClip (Destination, Layer, Pour);
       SetPourBoundingBox (Pour);
       if (!Layer->pour_tree)
         Layer->pour_tree = r_create_tree (NULL, 0, 0);
       r_insert_entry (Layer->pour_tree, (BoxType *) Pour, 0);
 
+      InitPourClip (Destination, Layer, Pour);
       DrawPour (Layer, Pour, 0);
       /* add to undo list */
       AddObjectToCreateUndoList (POLYGON_TYPE, Layer, Pour, Pour);
diff --git a/src/remove.c b/src/remove.c
index a2d05cb..d124284 100644
--- a/src/remove.c
+++ b/src/remove.c
@@ -187,6 +187,8 @@ DestroyArc (LayerTypePtr Layer, ArcTypePtr Arc)
 static void *
 DestroyPour (LayerTypePtr Layer, PourTypePtr Pour)
 {
+  Cardinal i;
+
   r_delete_entry (Layer->pour_tree, (BoxTypePtr) Pour);
   FreePourMemory (Pour);
   if (Pour != &Layer->Pour[--Layer->PourN])
@@ -195,6 +197,8 @@ DestroyPour (LayerTypePtr Layer, PourTypePtr Pour)
       r_substitute (Layer->pour_tree,
                     (BoxType *) & Layer->Pour[Layer->PourN],
                     (BoxType *) Pour);
+      for (i = 0; i < Pour->PolygonN; i++)
+        Pour->Polygons[i].ParentPour = Pour;
     }
   memset (&Layer->Pour[Layer->PourN], 0, sizeof (PourType));
   return (NULL);
diff --git a/src/undo.c b/src/undo.c
index 70c8401..2dacee3 100644
--- a/src/undo.c
+++ b/src/undo.c
@@ -849,7 +849,7 @@ UndoSwapCopiedObject (UndoListTypePtr Entry)
 
   obj = MoveObjectToBuffer (PCB->Data, RemoveList, type, ptr1, ptr2, ptr3);
   if (Entry->Kind == POUR_TYPE)
-    InitPourClip (PCB->Data, ptr1b, (PolygonType *)obj);
+    InitPourClip (PCB->Data, ptr1b, (PourType *)obj);
   return (true);
 }

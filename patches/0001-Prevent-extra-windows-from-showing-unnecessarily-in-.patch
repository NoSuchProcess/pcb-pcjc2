Bottom: ff2fff53faedf3d1e970e4e57fe6b491502433aa
Top:    314c3287c22cdc91d2d42f1c68cef948d6d49cea
Author: Jared Casper <jaredcasper@gmail.com>
Date:   2010-02-22 19:24:17 -0800

From d994c124332a25bbb248d4e7dc5ee166dc2ef769 Mon Sep 17 00:00:00 2001
Subject: [PATCH] Prevent extra windows from showing unnecessarily in GTK HID.

Prevent the library, log, and netlist windows in the GTK HID from
being shown unless explicitely requested.  This is done by splitting
ghid_*_window_show into ghid_*_window_create, which creates all the
resources for the window, and ghid_*_window_show, which actually shows
the window (and optionally "presents" it, which pulls it to the
foreground and gives it focus).

Since the NetlistShow action no longer actually shows the netlist
window, but sets the node/net that is shown in the window (if and when
it is visible), this patch also adds NetlistPresent which presents the
netlist window.  This can be added to the FindConnections menu item to
restore the behavior of bringing up the netlist window on a find.

Added an action LogShowOnAppend() which can restore the old behavior
that the log window is shown whenever something is appended to it
(currently off by default).


---

diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index cd30221..81f0d77 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -1289,7 +1289,9 @@ LayerGroupsChanged (int argc, char **argv, int x, int y)
 static int
 LibraryChanged (int argc, char **argv, int x, int y)
 {
-  ghid_library_window_show (&ghid_port, FALSE);
+  /* No need to show the library window every time it changes...
+   *  ghid_library_window_show (&ghid_port, FALSE);
+   */
   return 0;
 }
 
diff --git a/src/hid/gtk/gui-library-window.c b/src/hid/gtk/gui-library-window.c
index 4396d13..8bd0d7b 100644
--- a/src/hid/gtk/gui-library-window.c
+++ b/src/hid/gtk/gui-library-window.c
@@ -139,46 +139,40 @@ library_window_callback_response (GtkDialog * dialog,
 }
 
 
-/*! \brief Opens a library dialog.
+/*! \brief Creates a library dialog.
  *  \par Function Description
- *  This function opens the library dialog for if it is not already.
- *  In this last case, it only raises the dialog.
+ *  This function create the library dialog if it is not already created.
+ *  It does not show the dialog, use ghid_library_window_show for that.
  *
  */
 void
-ghid_library_window_show (GHidPort * out, gboolean raise)
+ghid_library_window_create (GHidPort * out)
 {
   GtkWidget *current_tab, *entry_filter;
   GtkNotebook *notebook;
 
-  if (library_window == NULL)
-    {
-      library_window = g_object_new (GHID_TYPE_LIBRARY_WINDOW, NULL);
+  if (library_window)
+    return;
 
-      g_signal_connect (library_window,
-			"response",
-			G_CALLBACK (library_window_callback_response), NULL);
-      g_signal_connect (G_OBJECT (library_window), "configure_event",
-			G_CALLBACK (library_window_configure_event_cb), NULL);
-      gtk_window_set_default_size (GTK_WINDOW (library_window),
-				   ghidgui->library_window_width,
-				   ghidgui->library_window_height);
+  library_window = g_object_new (GHID_TYPE_LIBRARY_WINDOW, NULL);
 
-      gtk_window_set_title (GTK_WINDOW (library_window), _("PCB Library"));
-      gtk_window_set_wmclass (GTK_WINDOW (library_window), "PCB_Library",
-			      "PCB");
+  g_signal_connect (library_window,
+                    "response",
+                    G_CALLBACK (library_window_callback_response), NULL);
+  g_signal_connect (G_OBJECT (library_window), "configure_event",
+                    G_CALLBACK (library_window_configure_event_cb), NULL);
+  gtk_window_set_default_size (GTK_WINDOW (library_window),
+                               ghidgui->library_window_width,
+                               ghidgui->library_window_height);
 
-      gtk_widget_realize (library_window);
-      if (Settings.AutoPlace)
-	gtk_widget_set_uposition (GTK_WIDGET (library_window), 10, 10);
+  gtk_window_set_title (GTK_WINDOW (library_window), _("PCB Library"));
+  gtk_window_set_wmclass (GTK_WINDOW (library_window), "PCB_Library",
+                          "PCB");
 
-      gtk_widget_show (library_window);
+  gtk_widget_realize (library_window);
+  if (Settings.AutoPlace)
+    gtk_widget_set_uposition (GTK_WIDGET (library_window), 10, 10);
 
-    }
-  else if (raise)
-    {
-      gtk_window_present (GTK_WINDOW (library_window));
-    }
   gtk_editable_select_region (GTK_EDITABLE
 			      (GHID_LIBRARY_WINDOW (library_window)->
 			       entry_filter), 0, -1);
@@ -197,6 +191,20 @@ ghid_library_window_show (GHidPort * out, gboolean raise)
     }
 }
 
+/*! \brief Show the library dialog.
+ *  \par Function Description
+ *  This function show the library dialog, creating it if it is not
+ *  already created, and presents it to the user (brings it to the
+ *  front with focus).
+ */
+void
+ghid_library_window_show (GHidPort * out, gboolean raise)
+{
+  ghid_library_window_create (out);
+  gtk_widget_show_all (library_window);
+  if (raise)
+    gtk_window_present (GTK_WINDOW(library_window));
+}
 
 static GObjectClass *library_window_parent_class = NULL;
 
diff --git a/src/hid/gtk/gui-log-window.c b/src/hid/gtk/gui-log-window.c
index 7d11221..33e1940 100644
--- a/src/hid/gtk/gui-log-window.c
+++ b/src/hid/gtk/gui-log-window.c
@@ -42,7 +42,7 @@
 RCSID ("$Id$");
 
 static GtkWidget *log_window, *log_text;
-
+static gboolean log_show_on_append = FALSE;
 
 /* Remember user window resizes. */
 static gint
@@ -70,16 +70,12 @@ log_destroy_cb (GtkWidget * widget, gpointer data)
 }
 
 void
-ghid_log_window_show (gboolean raise)
+ghid_log_window_create ()
 {
   GtkWidget *vbox, *hbox, *button;
 
   if (log_window)
-    {
-      if (raise)
-        gtk_window_present(GTK_WINDOW(log_window));
-      return;
-    }
+    return;
 
   log_window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
   g_signal_connect (G_OBJECT (log_window), "destroy",
@@ -111,13 +107,24 @@ ghid_log_window_show (gboolean raise)
   gtk_widget_realize (log_window);
   if (Settings.AutoPlace)
     gtk_widget_set_uposition (GTK_WIDGET (log_window), 10, 10);
+}
+
+void
+ghid_log_window_show (gboolean raise)
+{
+  ghid_log_window_create ();
   gtk_widget_show_all (log_window);
+  if (raise)
+    gtk_window_present (GTK_WINDOW(log_window));
 }
 
 static void
 ghid_log_append_string (gchar * s)
 {
-  ghid_log_window_show (FALSE);
+  if (log_show_on_append)
+    ghid_log_window_show(FALSE);
+  else
+    ghid_log_window_create ();
   ghid_text_view_append (log_text, s);
 }
 
@@ -189,3 +196,34 @@ ghid_logv (const char *fmt, va_list args)
   ghid_log_append_string (msg_buffer);
 
 }
+
+static const char logshowonappend_syntax[] =
+  "LogShowOnAppend(true|false)";
+
+static const char logshowonappend_help[] =
+  "If true, the log window will be shown whenever something is appended \
+to it.  If false, the log will still be updated, but the window won't \
+be shown.";
+
+static gint
+GhidLogShowOnAppend (int argc, char **argv, int x, int y)
+{
+  char *a = argc == 1 ? argv[0] : "";
+
+  if (strncasecmp(a, "t", 1) == 0)
+    {
+      log_show_on_append = TRUE;
+    }
+  else if (strncasecmp(a, "f", 1) == 0)
+    {
+      log_show_on_append = FALSE;
+    }
+}
+
+HID_Action ghid_log_action_list[] = {
+  {"LogShowOnAppend", 0, GhidLogShowOnAppend,
+   logshowonappend_help, logshowonappend_syntax}
+  ,
+};
+
+REGISTER_ACTIONS (ghid_log_action_list)
diff --git a/src/hid/gtk/gui-netlist-window.c b/src/hid/gtk/gui-netlist-window.c
index 8fd5360..64971c3 100644
--- a/src/hid/gtk/gui-netlist-window.c
+++ b/src/hid/gtk/gui-netlist-window.c
@@ -589,11 +589,11 @@ node_get_node_from_name (gchar * node_name, LibraryMenuType ** node_net)
   if (!node_name)
     return NULL;
 
-  /* Have to force the netlist window shown because we need the treeview
+  /* Have to force the netlist window created because we need the treeview
      |  models constructed to do the search.
    */
   if (!netlist_window)
-    ghid_netlist_window_show (gport, FALSE);
+    ghid_netlist_window_create (gport);
 
   while (gtk_events_pending ())	/* Make sure everything gets built */
     gtk_main_iteration ();
@@ -648,9 +648,8 @@ netlist_destroy_cb (GtkWidget * widget, GHidPort * out)
   netlist_window = NULL;
 }
 
-
 void
-ghid_netlist_window_show (GHidPort * out, gboolean raise)
+ghid_netlist_window_create (GHidPort * out)
 {
   GtkWidget *vbox, *hbox, *button, *label, *sep;
   GtkTreeView *treeview;
@@ -665,12 +664,8 @@ ghid_netlist_window_show (GHidPort * out, gboolean raise)
     return;
 
   if (netlist_window)
-    {
-      if (raise)
-        gtk_window_present(GTK_WINDOW(netlist_window));
-      ghid_netlist_window_update (TRUE);
-      return;
-    }
+    return;
+
   netlist_window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
   g_signal_connect (G_OBJECT (netlist_window), "destroy",
 		    G_CALLBACK (netlist_destroy_cb), out);
@@ -798,7 +793,16 @@ ghid_netlist_window_show (GHidPort * out, gboolean raise)
   if (Settings.AutoPlace)
     gtk_widget_set_uposition (GTK_WIDGET (netlist_window), 10, 10);
 
+}
+
+void
+ghid_netlist_window_show (GHidPort * out, gboolean raise)
+{
+  ghid_netlist_window_create (out);
   gtk_widget_show_all (netlist_window);
+  ghid_netlist_window_update (TRUE);
+  if (raise)
+    gtk_window_present(GTK_WINDOW(netlist_window));
 }
 
 struct ggnfnn_task {
@@ -853,12 +857,12 @@ ghid_get_net_from_node_name (gchar * node_name, gboolean enabled_only)
   if (!node_name)
     return NULL;
 
-  /* Have to force the netlist window shown because we need the treeview
+  /* Have to force the netlist window created because we need the treeview
      |  models constructed so we can find the LibraryMenuType pointer the
      |  caller wants.
    */
   if (!netlist_window)
-    ghid_netlist_window_show (gport, FALSE);
+    ghid_netlist_window_create (gport);
 
   while (gtk_events_pending ())	/* Make sure everything gets built */
     gtk_main_iteration ();
@@ -951,11 +955,9 @@ ghid_netlist_window_update (gboolean init_nodes)
 {
   GtkTreeModel *model;
 
-  if (!netlist_window)
-    {
-      ghid_netlist_window_show (gport, FALSE);
-      return;
-    }
+  /* Make sure there is something to update */
+  ghid_netlist_window_create (gport);
+
   model = net_model;
   net_model = net_model_create ();
   gtk_tree_view_set_model (net_treeview, net_model);
@@ -985,18 +987,42 @@ GhidNetlistChanged (int argc, char **argv, int x, int y)
   return 0;
 }
 
+static const char netlistshow_syntax[] =
+"NetlistShow(pinname|netname)";
+
+static const char netlistshow_help[] =
+"Selects the given pinname or netname in the netlist window. Does not \
+show the window if it isn't already shown.";
+
 static gint
 GhidNetlistShow (int argc, char **argv, int x, int y)
 {
-  ghid_netlist_window_show (gport, FALSE);
+  ghid_netlist_window_create (gport);
   if (argc > 0)
     ghid_netlist_highlight_node(argv[0]);
   return 0;
 }
 
+static const char netlistpresent_syntax[] =
+"NetlistPresent()";
+
+static const char netlistpresent_help[] =
+"Presents the netlist window.";
+
+static gint
+GhidNetlistPresent (int argc, char **argv, int x, int y)
+{
+  ghid_netlist_window_show (gport, TRUE);
+  return 0;
+}
+
 HID_Action ghid_netlist_action_list[] = {
-  {"NetlistChanged", 0, GhidNetlistChanged},
-  {"NetlistShow", 0, GhidNetlistShow}
+  {"NetlistChanged", 0, GhidNetlistChanged,
+   netlistchanged_help, netlistchanged_syntax},
+  {"NetlistShow", 0, GhidNetlistShow, 
+   netlistshow_help, netlistshow_syntax},
+  {"NetlistPresent", 0, GhidNetlistPresent, 
+   netlistpresent_help, netlistpresent_syntax}
   ,
 };
 
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index deb3112..610f30e 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -475,6 +475,7 @@ void ghid_set_status_line_label (void);
 
 
 /* gui-netlist-window.c */
+void ghid_netlist_window_create (GHidPort * out);
 void ghid_netlist_window_show (GHidPort * out, gboolean raise);
 void ghid_netlist_window_update (gboolean init_nodes);
 void ghid_netlist_nodes_update (LibraryMenuType * net);
@@ -493,10 +494,12 @@ void ghid_command_use_command_window_sync (void);
 void ghid_keyref_window_show (gboolean raise);
 
 /* gui-library-window.c */
+void ghid_library_window_create (GHidPort * out);
 void ghid_library_window_show (GHidPort * out, gboolean raise);
 
 
 /* gui-log-window.c */
+void ghid_log_window_create ();
 void ghid_log_window_show (gboolean raise);
 void ghid_log (const char *fmt, ...);
 void ghid_logv (const char *fmt, va_list args);

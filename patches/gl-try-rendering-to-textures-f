Bottom: 09eb7df1911af101ffc902d93900760396947e48
Top:    303ba53fd57b842e6f75a7b73ea0229146403b36
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-11-12 14:11:33 +0000

GL: Try rendering to textures for subcompositing layers


---

diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index 6931651..76f730a 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -629,7 +629,6 @@ void
 hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale)
 {
   struct do_hole_info info;
-  int stencil_bit;
   cairo_traps_t traps;
 
   info.scale = scale;
@@ -641,53 +640,26 @@ hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale
       return;
     }
 
-  stencil_bit = hidgl_assign_clear_stencil_bit ();
-  if (!stencil_bit)
-    {
-      printf ("hidgl_fill_pcb_polygon: No free stencil bits, aborting polygon\n");
-      return;
-    }
-
   /* Flush out any existing geoemtry to be rendered */
   hidgl_flush_triangles (&buffer);
 
-  glPushAttrib (GL_STENCIL_BUFFER_BIT);                   // Save the write mask etc.. for final restore
-  glPushAttrib (GL_STENCIL_BUFFER_BIT |                   // Resave the stencil write-mask etc.., and
-                GL_COLOR_BUFFER_BIT);                     // the colour buffer write mask etc.. for part way restore
-  glStencilMask (stencil_bit);                            // Only write to our stencil bit
-  glStencilFunc (GL_ALWAYS, stencil_bit, stencil_bit);    // Always pass stencil test, ref value is our bit
-  glColorMask (0, 0, 0, 0);                               // Disable writting in color buffer
-
-  /* It will already be setup like this (so avoid prodding the state-machine):
-   * glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value
-   */
-  /* Drawing operations now set our reference bit in the stencil buffer */
-
-  r_search (poly->Clipped->contour_tree, clip_box, NULL, do_hole, &info);
-  hidgl_flush_triangles (&buffer);
-
-  /* Drawing operations as masked to areas where the stencil buffer is '0' */
-
-  glPopAttrib ();                                             // Restore the colour and stencil buffer write-mask etc..
-
-  glStencilOp (GL_KEEP, GL_KEEP, GL_INVERT); // This allows us to toggle the bit on the subcompositing bitplane
-                                             // If the stencil test has passed, we know that bit is 0, so we're
-                                             // effectively just setting it to 1.
-  glStencilFunc (GL_GEQUAL, 0, assigned_bits);
-//  glStencilFunc (GL_GREATER, assigned_bits, assigned_bits);   // Pass stencil test if all assigned bits clear,
-                                                              // reference is all assigned bits so we set
-                                                              // any bits permitted by the stencil writemask
-
   /* Draw the polygon outer */
   _cairo_traps_init (&traps);
   bo_contour_to_traps (poly->Clipped->contours, &traps);
   _cairo_traps_fini (&traps);
   hidgl_flush_triangles (&buffer);
 
-  /* Unassign our stencil buffer bit */
-  hidgl_return_stencil_bit (stencil_bit);
+  glPushAttrib (GL_CURRENT_BIT);
 
-  glPopAttrib ();                                             // Restore the stencil buffer write-mask etc..
+  glDisable (GL_BLEND);
+
+  glColor4f (0., 0., 0., 0.0);
+  r_search (poly->Clipped->contour_tree, clip_box, NULL, do_hole, &info);
+  hidgl_flush_triangles (&buffer);
+
+  glEnable (GL_BLEND);
+
+  glPopAttrib ();
 }
 
 void
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 4ae4931..1dd958c 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -27,11 +27,6 @@
 #include "../hidint.h"
 #include "hid/common/draw_helpers.h"
 
-#ifdef ENABLE_GL
-#  include <GL/gl.h>
-#  include "hid/common/hidgl.h"
-#endif
-
 #include "gui.h"
 
 #if !GTK_CHECK_VERSION(2,8,0) && defined(HAVE_GDK_GDKX_H)
@@ -67,6 +62,9 @@ static int cur_mask = -1;
 
 int ghid_flip_x = 0, ghid_flip_y = 0;
 
+GLuint fbo_name;
+GLuint tex_name;
+
 /* ------------------------------------------------------------ */
 
 static inline int 
@@ -573,7 +571,8 @@ int compute_depth (int group)
 int
 ghid_set_layer (const char *name, int group, int empty)
 {
-  static int stencil_bit = 0;
+  GLenum errCode;
+  const GLubyte *errString;
   int idx = (group >= 0 && group < max_layer) ?
               PCB->LayerGroups.Entries[group][0] : group;
 
@@ -582,17 +581,54 @@ ghid_set_layer (const char *name, int group, int empty)
 
   hidgl_set_depth (compute_depth (group));
 
-  glEnable (GL_STENCIL_TEST);                   // Enable Stencil test
-  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);   // Stencil pass => replace stencil value (with 1)
-  hidgl_return_stencil_bit (stencil_bit);       // Relinquish any bitplane we previously used
-  if (SL_TYPE (idx) != SL_FINISHED) {
-    stencil_bit = hidgl_assign_clear_stencil_bit();       // Get a new (clean) bitplane to stencil with
-    glStencilMask (stencil_bit);                          // Only write to our subcompositing stencil bitplane
-    glStencilFunc (GL_GREATER, stencil_bit, stencil_bit); // Pass stencil test if our assigned bit is clear
-  } else {
-    stencil_bit = 0;
-    glStencilMask (0);
-    glStencilFunc (GL_ALWAYS, 0, 0);  // Always pass stencil test
+  hidgl_flush_triangles (&buffer);
+  /* Composite out existing texture data */
+  glBindFramebufferEXT (GL_FRAMEBUFFER_EXT, 0);
+  glBindTexture (GL_TEXTURE_2D, tex_name);
+
+  glPushMatrix ();
+  glLoadIdentity ();
+
+  glEnable (GL_BLEND);
+  glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+
+  /* Use the texture on a big quad, onto the window */
+  glEnable (GL_TEXTURE_2D);
+  glBegin (GL_QUADS);
+//  glColor4f (1.0f, 1.0f, 1.0f, 1.0f);
+  glTexCoord2f (  0,   1);
+  glVertex2f   (  0, 0);
+  glTexCoord2f (  0,   0);
+  glVertex2f   (  0,   gport->drawing_area->allocation.height);
+  glTexCoord2f (  1,   0);
+  glVertex2f   (  gport->drawing_area->allocation.width,   gport->drawing_area->allocation.height);
+  glTexCoord2f (  1,   1);
+  glVertex2f   (  gport->drawing_area->allocation.width,   0);
+  glEnd ();
+  glDisable (GL_TEXTURE_2D);
+  glBindTexture (GL_TEXTURE_2D, 0);
+
+  glPopMatrix ();
+
+  glBlendFunc (GL_ONE, GL_ZERO);
+//  glDisable (GL_BLEND);
+
+  if ((errCode = glGetError()) != GL_NO_ERROR) {
+      errString = gluErrorString(errCode);
+     fprintf (stderr, "5OpenGL Error: %s\n", errString);
+  }
+
+  /* Setup for the next layer */
+  if (group != -99) {
+    glBindFramebufferEXT (GL_FRAMEBUFFER_EXT, fbo_name);
+    glFramebufferTexture2DEXT (GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, tex_name, 0);
+    glClear (GL_COLOR_BUFFER_BIT);
+  } else
+    return 0;
+
+  if ((errCode = glGetError()) != GL_NO_ERROR) {
+      errString = gluErrorString(errCode);
+     fprintf (stderr, "6OpenGL Error: %s\n", errString);
   }
 
   if (idx >= 0 && idx < max_layer + 2) {
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index e5ec20a..847ae0d 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -1706,13 +1706,33 @@ ghid_draw_everything (BoxTypePtr drawn_area)
   Settings.ShowSolderSide = save_show_solder;
 }
 
+void DrawAttached (Boolean);
+void draw_grid ();
+int ghid_set_layer (const char *name, int group, int empty);
+
+#define CHECK_FRAMEBUFFER_STATUS()                            \
+  do {                                                        \
+    GLenum status;                                            \
+    status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT); \
+    switch(status) {                                          \
+      case GL_FRAMEBUFFER_COMPLETE_EXT:                       \
+        break;                                                \
+      case GL_FRAMEBUFFER_UNSUPPORTED_EXT:                    \
+        /* choose different formats */                        \
+        break;                                                \
+      default:                                                \
+        /* programming error; will fail on all hardware */    \
+        exit (1);                                             \
+    }                                                         \
+  } while (0);
+
 #define Z_NEAR 3.0
 gboolean
 ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
 					GdkEventExpose * ev, GHidPort * port)
 {
-  static int one_shot = 1;
-  static int display_list;
+  GLenum errCode;
+  const GLubyte *errString;
   BoxType region;
   int eleft, eright, etop, ebottom;
   extern HID ghid_hid;
@@ -1743,7 +1763,8 @@ ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
   ghid_show_crosshair (FALSE);
 
   glEnable (GL_BLEND);
-  glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+  glBlendFunc (GL_ONE, GL_ZERO);
+//  glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
 
 //  glEnable(GL_POLYGON_SMOOTH);
 //  glHint(GL_POLYGON_SMOOTH_HINT, [GL_FASTEST, GL_NICEST, or GL_DONT_CARE]);
@@ -1766,13 +1787,6 @@ ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
   glTranslatef (-widget->allocation.width / 2., -widget->allocation.height / 2., 0);
   glGetFloatv (GL_MODELVIEW_MATRIX, (GLfloat *)last_modelview_matrix);
 
-#if 0
-  if (one_shot) {
-
-    display_list = glGenLists(1);
-    glNewList (display_list, GL_COMPILE);
-#endif
-
   glEnable (GL_STENCIL_TEST);
   glClearColor (gport->offlimits_color.red / 65535.,
                 gport->offlimits_color.green / 65535.,
@@ -1849,8 +1863,11 @@ ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
   region.Y1 = MIN (Py (min_y), Py (max_y + 1));
   region.Y2 = MAX (Py (min_y), Py (max_y + 1));
 
-  eleft = Vx (0);  eright  = Vx (PCB->MaxWidth);
-  etop  = Vy (0);  ebottom = Vy (PCB->MaxHeight);
+//  eleft = Vx (0);  eright  = Vx (PCB->MaxWidth);
+//  etop  = Vy (0);  ebottom = Vy (PCB->MaxHeight);
+
+  eleft = ev->area.x; eright = ev->area.x + ev->area.width;
+  etop = ev->area.y; ebottom = ev->area.y + ev->area.height;
 
   glColor3f (gport->bg_color.red / 65535.,
              gport->bg_color.green / 65535.,
@@ -1858,6 +1875,53 @@ ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
 
   /* TODO: Background image */
 
+  /* Setup a texture for playing each layer into */
+  glGenFramebuffersEXT (1, &fbo_name);
+  glGenTextures (1, &tex_name);
+  glBindTexture (GL_TEXTURE_2D, tex_name);
+
+  glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+
+  glTexImage2D (GL_TEXTURE_2D,
+                0, /* Level */
+                GL_RGBA8, /* Int. format */
+                widget->allocation.width, /* Width */
+                widget->allocation.height, /* Height */
+                0,      /* Border */
+                GL_RGBA, /* Format */
+                GL_UNSIGNED_BYTE, /* Type */
+                NULL);  /* Pixels */
+
+  glBindFramebufferEXT (GL_FRAMEBUFFER_EXT, fbo_name);
+  glFramebufferTexture2DEXT (GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, tex_name, 0);
+  if ((errCode = glGetError()) != GL_NO_ERROR) {
+      errString = gluErrorString(errCode);
+     fprintf (stderr, "4OpenGL Error: %s\n", errString);
+  }
+  CHECK_FRAMEBUFFER_STATUS ()
+  glBindTexture (GL_TEXTURE_2D, 0);
+
+  glClearColor (1., 1., 1., 0.);
+  glClear (GL_COLOR_BUFFER_BIT);
+
+//  glDisable (GL_BLEND);
+  glEnable (GL_BLEND);
+
+
+//  glBindFramebufferEXT (GL_FRAMEBUFFER_EXT, 0);
+#if 0
+  glBindFramebufferEXT (GL_FRAMEBUFFER_EXT, fbo_name);
+  /* RTT */
+  glBindFramebufferEXT (GL_FRAMEBUFFER_EXT, 0);
+
+  /* Composite */
+  glBindTexture (GL_TEXTURE_2D, tex_name);
+  /* Use the texture on a big quad, onto the window */
+  glBindTexture (GL_TEXTURE_2D, 0);
+#endif
+
+  /* End texture setup */
+
   hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
 
@@ -1918,6 +1982,9 @@ ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
   gui->set_layer (NULL, GetLayerGroupNumberByNumber (INDEXOFCURRENT), 0);
   gui->set_layer (NULL, SL_FINISHED, 0);
 
+  /* Hack to finish compositing */
+  ghid_set_layer ("HACK", -99, 0);
+
   draw_grid (&region);
 
   hidgl_init_triangle_array (&buffer);
@@ -1934,20 +2001,15 @@ ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
   hidgl_flush_triangles (&buffer);
   glPopMatrix ();
 
-#if 0
-    glEndList ();
-    one_shot = 0;
-  } else {
-    /* Second and subsequent times */
-    glCallList (display_list);
-  }
-#endif
-
   ghid_show_crosshair (TRUE);
 
   hidgl_flush_triangles (&buffer);
 
 
+  /* Tear down texture buffer */
+  glDeleteTextures (1, &tex_name);
+  glDeleteFramebuffersEXT (1, &fbo_name);
+
   if (gdk_gl_drawable_is_double_buffered (pGlDrawable))
     gdk_gl_drawable_swap_buffers (pGlDrawable);
   else
@@ -1956,8 +2018,6 @@ ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
   /* end drawing to current GL-context */
   gdk_gl_drawable_gl_end (pGlDrawable);
 
-  one_shot = 0;
-
   return FALSE;
 }
 
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index 81e0c09..43ee352 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -133,7 +133,6 @@ extern int ghid_flip_x, ghid_flip_y;
 #define GRID_UNITS_VALUE(mm, mil)   (Settings.grid_units_mm ? (mm) : (mil))
 
 
-
 typedef struct hid_gc_struct
 {
   HID *me_pointer;
@@ -559,6 +558,8 @@ GdkPixmap *ghid_render_pixmap (int cx,
 			       int depth);
 
 /* gtkhid-main.c */
+extern GLuint fbo_name;
+extern GLuint tex_name;
 
 void ghid_invalidate_all ();
 void ghid_global_alpha_mult (hidGC gc, double alpha_mult);

Bottom: 0965f7e6d11c9970608606f764432bfb166f679e
Top:    1a90f0e14eecefd61bec429d968c612b3d824fbc
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-10-19 17:50:16 +0100

Use trackball to allow rotation of 3D view


---

diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index 2f30d4d..784f77f 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -792,6 +792,43 @@ ghid_screen_update (void)
 void DrawAttached (Boolean);
 void draw_grid ();
 
+static GLfloat view_matrix[4][4] = {{1.0, 0.0, 0.0, 0.0},
+                                    {0.0, 1.0, 0.0, 0.0},
+                                    {0.0, 0.0, 1.0, 0.0},
+                                    {0.0, 0.0, 0.0, 1.0}};
+static int global_view_2d = 1;
+
+void
+ghid_view_2d (void *ball, gboolean view_2d, gpointer userdata)
+{
+  global_view_2d = view_2d;
+  ghid_invalidate_all ();
+}
+
+void
+ghid_port_rotate (void *ball, float *quarternion, gpointer userdata)
+{
+#ifdef DEBUG_ROTATE
+  int row, column;
+#endif
+
+  build_rotmatrix (view_matrix, quarternion);
+
+#ifdef DEBUG_ROTATE
+  for (row = 0; row < 4; row++) {
+    printf ("[ %f", view_matrix[row][0]);
+    for (column = 1; column < 4; column++) {
+      printf (",\t%f", view_matrix[row][column]);
+    }
+    printf ("\t]\n");
+  }
+  printf ("\n");
+#endif
+
+  ghid_invalidate_all ();
+}
+
+
 #define Z_NEAR 3.0
 gboolean
 ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
@@ -824,24 +861,30 @@ ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
   glEnable (GL_BLEND);
   glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
 
+//  glEnable (GL_DEPTH_TEST);
+
 //  glEnable(GL_POLYGON_SMOOTH);
 //  glHint(GL_POLYGON_SMOOTH_HINT, [GL_FASTEST, GL_NICEST, or GL_DONT_CARE]);
 
-  glViewport (ev->area.x,
-              widget->allocation.height - ev->area.height - ev->area.y,
-              ev->area.width, ev->area.height);
+  glViewport (widget->allocation.x,     widget->allocation.y,
+              widget->allocation.width, widget->allocation.height);
 
+#if 0
   glEnable (GL_SCISSOR_TEST);
   glScissor (ev->area.x,
              widget->allocation.height - ev->area.height - ev->area.y,
              ev->area.width, ev->area.height);
+#endif
 
   glMatrixMode (GL_PROJECTION);
   glLoadIdentity ();
-  glOrtho (ev->area.x, ev->area.x + ev->area.width, ev->area.y + ev->area.height, ev->area.y, 0, 100);
+  glOrtho (0, widget->allocation.width, widget->allocation.height, 0, -100000, 100000);
   glMatrixMode (GL_MODELVIEW);
   glLoadIdentity ();
-  glTranslatef (0.0f, 0.0f, -Z_NEAR);
+
+  glTranslatef (widget->allocation.width / 2., widget->allocation.height / 2., 0);
+  glMultMatrixf (view_matrix);
+  glTranslatef (-widget->allocation.width / 2., -widget->allocation.height / 2., 0);
 
   glEnable (GL_STENCIL_TEST);
   glClearColor (gport->offlimits_color.red / 65535.,
@@ -850,15 +893,17 @@ ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
                 1.);
 
   glDepthMask (0);
+//  glClearDepth (1000);
   glStencilMask (~0);
   glClearStencil (0);
-  glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
+  glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
   hidgl_reset_stencil_usage ();
 
   /* Disable the stencil test until we need it - otherwise it gets dirty */
   glDisable (GL_STENCIL_TEST);
   glStencilFunc (GL_ALWAYS, 0, 0);
 
+#if 1
   region.X1 = MIN (Px (ev->area.x), Px (ev->area.x + ev->area.width + 1));
   region.X2 = MAX (Px (ev->area.x), Px (ev->area.x + ev->area.width + 1));
   region.Y1 = MIN (Py (ev->area.y), Py (ev->area.y + ev->area.height + 1));
@@ -872,14 +917,15 @@ ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
              gport->bg_color.blue / 65535.);
 
   glBegin (GL_QUADS);
-  glVertex3i (eleft,  etop,    0);
-  glVertex3i (eright, etop,    0);
-  glVertex3i (eright, ebottom, 0);
-  glVertex3i (eleft,  ebottom, 0);
+  glVertex3i (eleft,  etop,    -50);
+  glVertex3i (eright, etop,    -50);
+  glVertex3i (eright, ebottom, -50);
+  glVertex3i (eleft,  ebottom, -50);
   glEnd ();
 
   /* TODO: Background image */
 
+#if 1
   hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
 
@@ -896,7 +942,8 @@ ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
                              -gport->view_x0,
                 ghid_flip_y ? gport->view_y0 - PCB->MaxHeight :
                              -gport->view_y0, 0);
-  hid_expose_callback (&ghid_hid, &region, 0);
+//  hid_expose_callback (&ghid_hid, &region, 0);
+  hid_expose_callback (&ghid_hid, NULL, 0);
   hidgl_flush_triangles (&buffer);
   glPopMatrix ();
 
@@ -916,10 +963,14 @@ ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
   hidgl_flush_triangles (&buffer);
   glPopMatrix ();
 
+#endif
+
   ghid_show_crosshair (TRUE);
 
   hidgl_flush_triangles (&buffer);
 
+#endif
+
   if (gdk_gl_drawable_is_double_buffered (pGlDrawable))
     gdk_gl_drawable_swap_buffers (pGlDrawable);
   else
diff --git a/src/hid/gtk/gui-top-window.c b/src/hid/gtk/gui-top-window.c
index 88920e6..38f0c13 100644
--- a/src/hid/gtk/gui-top-window.c
+++ b/src/hid/gtk/gui-top-window.c
@@ -122,6 +122,7 @@ a zoom in/out.
 
 #include "gui-icons-mode-buttons.data"
 #include "gui-icons-misc.data"
+#include "gui-trackball.h"
 
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
@@ -2155,6 +2156,7 @@ ghid_build_pcb_top_window (void)
   GtkWidget *vbox_main, *vbox_left, *hbox_middle, *hbox = NULL;
   GtkWidget *viewport, *ebox, *vbox, *frame;
   GtkWidget *label;
+  GtkWidget *trackball;
   GHidPort *port = &ghid_port;
   gchar *s;
   GtkWidget *scrolled;
@@ -2263,6 +2265,13 @@ ghid_build_pcb_top_window (void)
       GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
   make_layer_buttons(vbox, port);
 
+  trackball = ghid_trackball_new ();
+  g_signal_connect (trackball, "rotation-changed",
+                    G_CALLBACK (ghid_port_rotate), NULL);
+  g_signal_connect (trackball, "view-2d-changed",
+                    G_CALLBACK (ghid_view_2d), NULL);
+  gtk_box_pack_start (GTK_BOX (vbox_left), trackball, FALSE, FALSE, 0);
+
   vbox = gtk_vbox_new(FALSE, 0);
   gtk_box_pack_start(GTK_BOX(vbox_left), vbox, FALSE, FALSE, 0);
   ghidgui->mode_buttons0_frame_vbox = vbox;
@@ -2673,7 +2682,7 @@ ghid_parse_arguments (int *argc, char ***argv)
   /* setup GL-context */
   gport->glconfig = gdk_gl_config_new_by_mode (GDK_GL_MODE_RGBA    |
                                                GDK_GL_MODE_STENCIL |
-//                                               GDK_GL_MODE_DEPTH   |
+                                               GDK_GL_MODE_DEPTH   |
                                                GDK_GL_MODE_DOUBLE);
   if (!gport->glconfig) {
     printf("Could not setup GL-context!\n");
diff --git a/src/hid/gtk/gui-trackball.c b/src/hid/gtk/gui-trackball.c
index cd8ec44..26440bb 100644
--- a/src/hid/gtk/gui-trackball.c
+++ b/src/hid/gtk/gui-trackball.c
@@ -51,6 +51,7 @@ RCSID ("$Id$");
 
 enum {
   ROTATION_CHANGED,
+  VIEW_2D_CHANGED,
   LAST_SIGNAL
 };
 
@@ -59,17 +60,25 @@ static guint ghid_trackball_signals[ LAST_SIGNAL ] = { 0 };
 static GObjectClass *ghid_trackball_parent_class = NULL;
 
 
-
 static gboolean
 button_press_cb (GtkWidget *widget, GdkEventButton *ev, gpointer userdata)
 {
-  GhidTrackball *ball = GHID_TRACKBALL (widget);
+  GhidTrackball *ball = GHID_TRACKBALL (userdata);
+  float axis[3];
 
   ball->x1 = 2. * ev->x / widget->allocation.width - 1.;
   ball->y1 = 2. * ev->y / widget->allocation.height - 1.;
 
   ball->dragging = TRUE;
 
+  /* If we were in 2D view before, reset the rotation of the trackball */
+  if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (ball->view_2d)))
+    {
+      axis[0] = 1.; axis[1] = 0.; axis[2] = 0.;
+      axis_to_quat (axis, 0, ball->quart1);
+      gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (ball->view_2d), FALSE);
+    }
+
   return TRUE;
 }
 
@@ -77,7 +86,7 @@ button_press_cb (GtkWidget *widget, GdkEventButton *ev, gpointer userdata)
 static gboolean
 button_release_cb (GtkWidget *widget, GdkEventButton *ev, gpointer userdata)
 {
-  GhidTrackball *ball = GHID_TRACKBALL (widget);
+  GhidTrackball *ball = GHID_TRACKBALL (userdata);
 
   ball->quart1[0] = ball->quart2[0];
   ball->quart1[1] = ball->quart2[1];
@@ -93,11 +102,10 @@ button_release_cb (GtkWidget *widget, GdkEventButton *ev, gpointer userdata)
 static gboolean
 motion_notify_cb (GtkWidget *widget, GdkEventMotion *ev, gpointer userdata)
 {
-  GhidTrackball *ball = GHID_TRACKBALL (widget);
+  GhidTrackball *ball = GHID_TRACKBALL (userdata);
   double x1, y1;
   double x2, y2;
   float q[4];
-  float newq[4];
 
   if (!ball->dragging)
     return TRUE;
@@ -112,12 +120,46 @@ motion_notify_cb (GtkWidget *widget, GdkEventMotion *ev, gpointer userdata)
   trackball (q, x1, y1, x2, y2);
   add_quats (q, ball->quart1, ball->quart2);
 
-  g_signal_emit (ball, ghid_trackball_signals[ROTATION_CHANGED], 0, ball->quart2);
+  g_signal_emit (ball, ghid_trackball_signals[ROTATION_CHANGED], 0,
+                 ball->quart2);
 
   return TRUE;
 }
 
+static gboolean
+ghid_trackball_expose (GtkWidget * widget, GdkEventExpose * ev)
+{
+  gdk_draw_arc (widget->window,
+                widget->style->fg_gc[GTK_WIDGET_STATE (widget)],
+                TRUE,
+                0, 0, widget->allocation.width, widget->allocation.height,
+                0, 64 * 360);
+  return TRUE;
+}
+
+static gboolean
+view_2d_toggled_cb (GtkToggleButton *toggle, gpointer userdata)
+{
+  GhidTrackball *ball = GHID_TRACKBALL (userdata);
+  float axis[3];
+  float quart[4];
+  gboolean view_2d;
 
+  view_2d = gtk_toggle_button_get_active (toggle);
+  if (view_2d)
+    {
+      axis[0] = 1.; axis[1] = 0.; axis[2] = 0.;
+      axis_to_quat (axis, 0, quart);
+
+      g_signal_emit (ball, ghid_trackball_signals[ROTATION_CHANGED], 0, quart);
+    }
+  else
+    g_signal_emit (ball, ghid_trackball_signals[ROTATION_CHANGED], 0, ball->quart1);
+
+  g_signal_emit (ball, ghid_trackball_signals[VIEW_2D_CHANGED], 0, view_2d);
+
+  return TRUE;
+}
 /*! \brief GObject constructor
  *
  *  \par Function Description
@@ -142,19 +184,36 @@ ghid_trackball_constructor (GType type,
   ball = GHID_TRACKBALL (G_OBJECT_CLASS (ghid_trackball_parent_class)->
     constructor (type, n_construct_properties, construct_properties));
 
-  gtk_widget_set_size_request (GTK_WIDGET (ball), 100, 100);
+  gtk_widget_set_size_request (GTK_WIDGET (ball), 120, 120);
+
+  ball->view_2d = gtk_toggle_button_new_with_label (_("2D View"));
+  gtk_box_pack_start (GTK_BOX (ball), ball->view_2d, FALSE, FALSE, 0);
+  gtk_widget_show (ball->view_2d);
+  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (ball->view_2d), TRUE);
+
+  ball->drawing_area = gtk_drawing_area_new ();
+  gtk_box_pack_start (GTK_BOX (ball), ball->drawing_area, TRUE, TRUE, 0);
+  gtk_widget_show (ball->drawing_area);
 
   axis[0] = 1.; axis[1] = 0.; axis[2] = 0.;
   axis_to_quat (axis, 0, ball->quart1);
   axis_to_quat (axis, 0, ball->quart2);
 
-  g_signal_connect (ball, "button-press-event",   G_CALLBACK (button_press_cb),   NULL);
-  g_signal_connect (ball, "button-release-event", G_CALLBACK (button_release_cb), NULL);
-  g_signal_connect (ball, "motion-notify-event",  G_CALLBACK (motion_notify_cb),  NULL);
+  g_signal_connect (ball->view_2d, "toggled",
+                    G_CALLBACK (view_2d_toggled_cb), ball);
+
+  g_signal_connect (ball->drawing_area, "expose-event",
+                    G_CALLBACK (ghid_trackball_expose), ball);
+  g_signal_connect (ball->drawing_area, "button-press-event",
+                    G_CALLBACK (button_press_cb), ball);
+  g_signal_connect (ball->drawing_area, "button-release-event",
+                    G_CALLBACK (button_release_cb), ball);
+  g_signal_connect (ball->drawing_area, "motion-notify-event",
+                    G_CALLBACK (motion_notify_cb), ball);
 
-  gtk_widget_add_events (GTK_WIDGET (ball), GDK_BUTTON_PRESS_MASK   |
-                                            GDK_BUTTON_RELEASE_MASK |
-                                            GDK_POINTER_MOTION_MASK);
+  gtk_widget_add_events (ball->drawing_area, GDK_BUTTON_PRESS_MASK   |
+                                             GDK_BUTTON_RELEASE_MASK |
+                                             GDK_POINTER_MOTION_MASK);
 
   return G_OBJECT (ball);
 }
@@ -229,18 +288,6 @@ ghid_trackball_get_property (GObject * object, guint property_id,
 }
 
 
-static gboolean
-ghid_trackball_expose (GtkWidget * widget, GdkEventExpose * ev)
-{
-  gdk_draw_arc (widget->window,
-                widget->style->fg_gc[GTK_WIDGET_STATE (widget)],
-                TRUE,
-                0, 0, widget->allocation.width, widget->allocation.height,
-                0, 64 * 360);
-  return TRUE;
-}
-
-
 /*! \brief GType class initialiser for GhidTrackball
  *
  *  \par Function Description
@@ -253,15 +300,12 @@ static void
 ghid_trackball_class_init (GhidTrackballClass * klass)
 {
   GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
-  GtkWidgetClass *gtk_widget_class = GTK_WIDGET_CLASS (klass);
 
   gobject_class->constructor  = ghid_trackball_constructor;
   gobject_class->finalize     = ghid_trackball_finalize;
   gobject_class->set_property = ghid_trackball_set_property;
   gobject_class->get_property = ghid_trackball_get_property;
 
-  gtk_widget_class->expose_event = ghid_trackball_expose;
-
   ghid_trackball_parent_class = g_type_class_peek_parent (klass);
 
   ghid_trackball_signals[ROTATION_CHANGED] =
@@ -276,6 +320,19 @@ ghid_trackball_class_init (GhidTrackballClass * klass)
                   1,    /* n_params */
                   G_TYPE_POINTER
                  );
+
+  ghid_trackball_signals[VIEW_2D_CHANGED] =
+    g_signal_new ("view-2d-changed",
+                  G_OBJECT_CLASS_TYPE( gobject_class ),
+                  G_SIGNAL_RUN_FIRST,     /*signal_flags */
+                  G_STRUCT_OFFSET( GhidTrackballClass, view_2d_changed ),
+                  NULL, /* accumulator */
+                  NULL, /* accu_data */
+                  g_cclosure_marshal_VOID__BOOLEAN,
+                  G_TYPE_NONE,
+                  1,    /* n_params */
+                  G_TYPE_BOOLEAN
+                 );
 }
 
 
@@ -308,7 +365,7 @@ ghid_trackball_get_type ()
       };
 
       ghid_trackball_type =
-	g_type_register_static (GTK_TYPE_DRAWING_AREA, "GhidTrackball",
+	g_type_register_static (GTK_TYPE_VBOX, "GhidTrackball",
 				&ghid_trackball_info, 0);
     }
 
diff --git a/src/hid/gtk/gui-trackball.h b/src/hid/gtk/gui-trackball.h
index 3318695..d6bd03c 100644
--- a/src/hid/gtk/gui-trackball.h
+++ b/src/hid/gtk/gui-trackball.h
@@ -42,14 +42,18 @@ typedef struct _GhidTrackball GhidTrackball;
 
 struct _GhidTrackballClass
 {
-  GtkDrawingAreaClass parent_class;
+  GtkVBoxClass parent_class;
 
   void (*rotation_changed) (GhidTrackball *ball, gpointer rotation, gpointer user_data);
+  void (*view_2d_changed) (GhidTrackball *ball, gboolean view_2d, gpointer user_data);
 };
 
 struct _GhidTrackball
 {
-  GtkDrawingArea parent_instance;
+  GtkVBox parent_instance;
+
+  GtkWidget *drawing_area;
+  GtkWidget *view_2d;
 
   gboolean dragging;
   gdouble x1, y1;
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index cfde6a9..43553be 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -364,6 +364,8 @@ gint ghid_port_window_motion_cb (GtkWidget * widget,
 gint ghid_port_window_mouse_scroll_cb (GtkWidget * widget,
 				       GdkEventScroll * ev, GHidPort * out);
 
+void ghid_port_rotate (void *ball, float *quarternion, gpointer userdata);
+void ghid_view_2d (void *ball, gboolean view_2d, gpointer userdata);
 
 gint ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
 					     GdkEventExpose * ev,

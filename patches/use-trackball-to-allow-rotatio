Bottom: 4ea1d076c04eb54f99c9ade30aa75e713e9bb365
Top:    dabdf51abe31f986bdfc0625ead50e08b7ba5715
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2012-11-10 16:54:10 -0500

Use trackball to allow rotation of 3D view


---

diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index c66ce49..939886a 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -25,7 +25,9 @@
 
 #include <gtk/gtkgl.h>
 #include "hid/common/hidgl.h"
+
 #include "hid/common/draw_helpers.h"
+#include "hid/common/trackball.h"
 
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
@@ -40,6 +42,15 @@ static hidGC current_gc = NULL;
 #define USE_GC(gc) if (!use_gc(gc)) return
 
 static int cur_mask = -1;
+static GLfloat view_matrix[4][4] = {{1.0, 0.0, 0.0, 0.0},
+                                    {0.0, 1.0, 0.0, 0.0},
+                                    {0.0, 0.0, 1.0, 0.0},
+                                    {0.0, 0.0, 0.0, 1.0}};
+static GLfloat last_modelview_matrix[4][4] = {{1.0, 0.0, 0.0, 0.0},
+                                              {0.0, 1.0, 0.0, 0.0},
+                                              {0.0, 0.0, 1.0, 0.0},
+                                              {0.0, 0.0, 0.0, 1.0}};
+static int global_view_2d = 1;
 
 typedef struct render_priv {
   GdkGLConfig *glconfig;
@@ -74,6 +85,7 @@ hid_gc_struct;
 
 
 static void draw_lead_user (render_priv *priv);
+static void ghid_unproject_to_z_plane (int ex, int ey, Coord pcb_z, Coord *pcb_x, Coord *pcb_y);
 
 
 static void
@@ -853,6 +865,11 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   render_priv *priv = port->render_priv;
   GtkAllocation allocation;
   BoxType region;
+  Coord min_x, min_y;
+  Coord max_x, max_y;
+  Coord new_x, new_y;
+  Coord min_depth;
+  Coord max_depth;
 
   gtk_widget_get_allocation (widget, &allocation);
 
@@ -878,18 +895,20 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   glMatrixMode (GL_PROJECTION);
   glLoadIdentity ();
-  glOrtho (0, allocation.width, allocation.height, 0, 0, 100);
+  glOrtho (0, allocation.width, allocation.height, 0, -100000, 100000);
   glMatrixMode (GL_MODELVIEW);
   glLoadIdentity ();
-  glTranslatef (0.0f, 0.0f, -Z_NEAR);
-
+  glTranslatef (widget->allocation.width / 2., widget->allocation.height / 2., 0);
+  glMultMatrixf ((GLfloat *)view_matrix);
+  glTranslatef (-widget->allocation.width / 2., -widget->allocation.height / 2., 0);
   glScalef ((port->view.flip_x ? -1. : 1.) / port->view.coord_per_px,
             (port->view.flip_y ? -1. : 1.) / port->view.coord_per_px,
             ((port->view.flip_x == port->view.flip_y) ? 1. : -1.) / port->view.coord_per_px);
-  glTranslatef (port->view.flip_x ? port->view.x0 - PCB->MaxWidth  :
-                             -port->view.x0,
-                port->view.flip_y ? port->view.y0 - PCB->MaxHeight :
-                             -port->view.y0, 0);
+  glTranslatef (port->view.flip_x ?  port->view.x0 - PCB->MaxWidth  :
+                                    -port->view.x0,
+                port->view.flip_y ?  port->view.y0 - PCB->MaxHeight :
+                                    -port->view.y0, 0);
+  glGetFloatv (GL_MODELVIEW_MATRIX, (GLfloat *)last_modelview_matrix);
 
   glEnable (GL_STENCIL_TEST);
   glClearColor (port->offlimits_color.red / 65535.,
@@ -906,10 +925,64 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glStencilMask (0);
   glStencilFunc (GL_ALWAYS, 0, 0);
 
-  region.X1 = MIN (Px (ev->area.x), Px (ev->area.x + ev->area.width + 1));
-  region.X2 = MAX (Px (ev->area.x), Px (ev->area.x + ev->area.width + 1));
-  region.Y1 = MIN (Py (ev->area.y), Py (ev->area.y + ev->area.height + 1));
-  region.Y2 = MAX (Py (ev->area.y), Py (ev->area.y + ev->area.height + 1));
+  /* Test the 8 corners of a cube spanning the event */
+  min_depth = -50; /* FIXME */
+  max_depth =  0;  /* FIXME */
+
+  ghid_unproject_to_z_plane (ev->area.x,
+                             ev->area.y,
+                             min_depth, &new_x, &new_y);
+  max_x = min_x = new_x;
+  max_y = min_y = new_y;
+
+  ghid_unproject_to_z_plane (ev->area.x,
+                             ev->area.y,
+                             max_depth, &new_x, &new_y);
+  min_x = MIN (min_x, new_x);  max_x = MAX (max_x, new_x);
+  min_y = MIN (min_y, new_y);  max_y = MAX (max_y, new_y);
+
+  /* */
+  ghid_unproject_to_z_plane (ev->area.x + ev->area.width,
+                             ev->area.y,
+                             min_depth, &new_x, &new_y);
+  min_x = MIN (min_x, new_x);  max_x = MAX (max_x, new_x);
+  min_y = MIN (min_y, new_y);  max_y = MAX (max_y, new_y);
+
+  ghid_unproject_to_z_plane (ev->area.x + ev->area.width, ev->area.y,
+                             max_depth, &new_x, &new_y);
+  min_x = MIN (min_x, new_x);  max_x = MAX (max_x, new_x);
+  min_y = MIN (min_y, new_y);  max_y = MAX (max_y, new_y);
+
+  /* */
+  ghid_unproject_to_z_plane (ev->area.x + ev->area.width,
+                             ev->area.y + ev->area.height,
+                             min_depth, &new_x, &new_y);
+  min_x = MIN (min_x, new_x);  max_x = MAX (max_x, new_x);
+  min_y = MIN (min_y, new_y);  max_y = MAX (max_y, new_y);
+
+  ghid_unproject_to_z_plane (ev->area.x + ev->area.width,
+                             ev->area.y + ev->area.height,
+                             max_depth, &new_x, &new_y);
+  min_x = MIN (min_x, new_x);  max_x = MAX (max_x, new_x);
+  min_y = MIN (min_y, new_y);  max_y = MAX (max_y, new_y);
+
+  /* */
+  ghid_unproject_to_z_plane (ev->area.x,
+                             ev->area.y + ev->area.height,
+                             min_depth,
+                             &new_x, &new_y);
+  min_x = MIN (min_x, new_x);  max_x = MAX (max_x, new_x);
+  min_y = MIN (min_y, new_y);  max_y = MAX (max_y, new_y);
+
+  ghid_unproject_to_z_plane (ev->area.x,
+                             ev->area.y + ev->area.height,
+                             max_depth,
+                             &new_x, &new_y);
+  min_x = MIN (min_x, new_x);  max_x = MAX (max_x, new_x);
+  min_y = MIN (min_y, new_y);  max_y = MAX (max_y, new_y);
+
+  region.X1 = min_x;  region.X2 = max_x + 1;
+  region.Y1 = min_y;  region.Y2 = max_y + 1;
 
   region.X1 = MAX (0, MIN (PCB->MaxWidth,  region.X1));
   region.X2 = MAX (0, MIN (PCB->MaxWidth,  region.X2));
@@ -921,10 +994,10 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
              port->bg_color.blue / 65535.);
 
   glBegin (GL_QUADS);
-  glVertex3i (0,             0,              0);
-  glVertex3i (PCB->MaxWidth, 0,              0);
-  glVertex3i (PCB->MaxWidth, PCB->MaxHeight, 0);
-  glVertex3i (0,             PCB->MaxHeight, 0);
+  glVertex3i (0,             0,              -50);
+  glVertex3i (PCB->MaxWidth, 0,              -50);
+  glVertex3i (PCB->MaxWidth, PCB->MaxHeight, -50);
+  glVertex3i (0,             PCB->MaxHeight, -50);
   glEnd ();
 
   ghid_draw_bg_image ();
@@ -1029,7 +1102,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
 
   glMatrixMode (GL_PROJECTION);
   glLoadIdentity ();
-  glOrtho (0, allocation.width, allocation.height, 0, 0, 100);
+  glOrtho (0, allocation.width, allocation.height, 0, -100000, 100000);
   glMatrixMode (GL_MODELVIEW);
   glLoadIdentity ();
   glTranslatef (0.0f, 0.0f, -Z_NEAR);
@@ -1135,7 +1208,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
 
   glMatrixMode (GL_PROJECTION);
   glLoadIdentity ();
-  glOrtho (0, width, height, 0, 0, 100);
+  glOrtho (0, width, height, 0, -100000, 100000);
   glMatrixMode (GL_MODELVIEW);
   glLoadIdentity ();
   glTranslatef (0.0f, 0.0f, -Z_NEAR);
@@ -1254,11 +1327,173 @@ ghid_finish_debug_draw (void)
   ghid_end_drawing (gport);
 }
 
+static float
+determinant_2x2 (float m[2][2])
+{
+  float det;
+  det = m[0][0] * m[1][1] -
+        m[0][1] * m[1][0];
+  return det;
+}
+
+#if 0
+static float
+determinant_4x4 (float m[4][4])
+{
+  float det;
+  det = m[0][3] * m[1][2] * m[2][1] * m[3][0]-m[0][2] * m[1][3] * m[2][1] * m[3][0] -
+        m[0][3] * m[1][1] * m[2][2] * m[3][0]+m[0][1] * m[1][3] * m[2][2] * m[3][0] +
+        m[0][2] * m[1][1] * m[2][3] * m[3][0]-m[0][1] * m[1][2] * m[2][3] * m[3][0] -
+        m[0][3] * m[1][2] * m[2][0] * m[3][1]+m[0][2] * m[1][3] * m[2][0] * m[3][1] +
+        m[0][3] * m[1][0] * m[2][2] * m[3][1]-m[0][0] * m[1][3] * m[2][2] * m[3][1] -
+        m[0][2] * m[1][0] * m[2][3] * m[3][1]+m[0][0] * m[1][2] * m[2][3] * m[3][1] +
+        m[0][3] * m[1][1] * m[2][0] * m[3][2]-m[0][1] * m[1][3] * m[2][0] * m[3][2] -
+        m[0][3] * m[1][0] * m[2][1] * m[3][2]+m[0][0] * m[1][3] * m[2][1] * m[3][2] +
+        m[0][1] * m[1][0] * m[2][3] * m[3][2]-m[0][0] * m[1][1] * m[2][3] * m[3][2] -
+        m[0][2] * m[1][1] * m[2][0] * m[3][3]+m[0][1] * m[1][2] * m[2][0] * m[3][3] +
+        m[0][2] * m[1][0] * m[2][1] * m[3][3]-m[0][0] * m[1][2] * m[2][1] * m[3][3] -
+        m[0][1] * m[1][0] * m[2][2] * m[3][3]+m[0][0] * m[1][1] * m[2][2] * m[3][3];
+   return det;
+}
+#endif
+
+static void
+invert_2x2 (float m[2][2], float out[2][2])
+{
+  float scale = 1 / determinant_2x2 (m);
+  out[0][0] =  m[1][1] * scale;
+  out[0][1] = -m[0][1] * scale;
+  out[1][0] = -m[1][0] * scale;
+  out[1][1] =  m[0][0] * scale;
+}
+
+#if 0
+static void
+invert_4x4 (float m[4][4], float out[4][4])
+{
+  float scale = 1 / determinant_4x4 (m);
+
+  out[0][0] = (m[1][2] * m[2][3] * m[3][1] - m[1][3] * m[2][2] * m[3][1] +
+               m[1][3] * m[2][1] * m[3][2] - m[1][1] * m[2][3] * m[3][2] -
+               m[1][2] * m[2][1] * m[3][3] + m[1][1] * m[2][2] * m[3][3]) * scale;
+  out[0][1] = (m[0][3] * m[2][2] * m[3][1] - m[0][2] * m[2][3] * m[3][1] -
+               m[0][3] * m[2][1] * m[3][2] + m[0][1] * m[2][3] * m[3][2] +
+               m[0][2] * m[2][1] * m[3][3] - m[0][1] * m[2][2] * m[3][3]) * scale;
+  out[0][2] = (m[0][2] * m[1][3] * m[3][1] - m[0][3] * m[1][2] * m[3][1] +
+               m[0][3] * m[1][1] * m[3][2] - m[0][1] * m[1][3] * m[3][2] -
+               m[0][2] * m[1][1] * m[3][3] + m[0][1] * m[1][2] * m[3][3]) * scale;
+  out[0][3] = (m[0][3] * m[1][2] * m[2][1] - m[0][2] * m[1][3] * m[2][1] -
+               m[0][3] * m[1][1] * m[2][2] + m[0][1] * m[1][3] * m[2][2] +
+               m[0][2] * m[1][1] * m[2][3] - m[0][1] * m[1][2] * m[2][3]) * scale;
+  out[1][0] = (m[1][3] * m[2][2] * m[3][0] - m[1][2] * m[2][3] * m[3][0] -
+               m[1][3] * m[2][0] * m[3][2] + m[1][0] * m[2][3] * m[3][2] +
+               m[1][2] * m[2][0] * m[3][3] - m[1][0] * m[2][2] * m[3][3]) * scale;
+  out[1][1] = (m[0][2] * m[2][3] * m[3][0] - m[0][3] * m[2][2] * m[3][0] +
+               m[0][3] * m[2][0] * m[3][2] - m[0][0] * m[2][3] * m[3][2] -
+               m[0][2] * m[2][0] * m[3][3] + m[0][0] * m[2][2] * m[3][3]) * scale;
+  out[1][2] = (m[0][3] * m[1][2] * m[3][0] - m[0][2] * m[1][3] * m[3][0] -
+               m[0][3] * m[1][0] * m[3][2] + m[0][0] * m[1][3] * m[3][2] +
+               m[0][2] * m[1][0] * m[3][3] - m[0][0] * m[1][2] * m[3][3]) * scale;
+  out[1][3] = (m[0][2] * m[1][3] * m[2][0] - m[0][3] * m[1][2] * m[2][0] +
+               m[0][3] * m[1][0] * m[2][2] - m[0][0] * m[1][3] * m[2][2] -
+               m[0][2] * m[1][0] * m[2][3] + m[0][0] * m[1][2] * m[2][3]) * scale;
+  out[2][0] = (m[1][1] * m[2][3] * m[3][0] - m[1][3] * m[2][1] * m[3][0] +
+               m[1][3] * m[2][0] * m[3][1] - m[1][0] * m[2][3] * m[3][1] -
+               m[1][1] * m[2][0] * m[3][3] + m[1][0] * m[2][1] * m[3][3]) * scale;
+  out[2][1] = (m[0][3] * m[2][1] * m[3][0] - m[0][1] * m[2][3] * m[3][0] -
+               m[0][3] * m[2][0] * m[3][1] + m[0][0] * m[2][3] * m[3][1] +
+               m[0][1] * m[2][0] * m[3][3] - m[0][0] * m[2][1] * m[3][3]) * scale;
+  out[2][2] = (m[0][1] * m[1][3] * m[3][0] - m[0][3] * m[1][1] * m[3][0] +
+               m[0][3] * m[1][0] * m[3][1] - m[0][0] * m[1][3] * m[3][1] -
+               m[0][1] * m[1][0] * m[3][3] + m[0][0] * m[1][1] * m[3][3]) * scale;
+  out[2][3] = (m[0][3] * m[1][1] * m[2][0] - m[0][1] * m[1][3] * m[2][0] -
+               m[0][3] * m[1][0] * m[2][1] + m[0][0] * m[1][3] * m[2][1] +
+               m[0][1] * m[1][0] * m[2][3] - m[0][0] * m[1][1] * m[2][3]) * scale;
+  out[3][0] = (m[1][2] * m[2][1] * m[3][0] - m[1][1] * m[2][2] * m[3][0] -
+               m[1][2] * m[2][0] * m[3][1] + m[1][0] * m[2][2] * m[3][1] +
+               m[1][1] * m[2][0] * m[3][2] - m[1][0] * m[2][1] * m[3][2]) * scale;
+  out[3][1] = (m[0][1] * m[2][2] * m[3][0] - m[0][2] * m[2][1] * m[3][0] +
+               m[0][2] * m[2][0] * m[3][1] - m[0][0] * m[2][2] * m[3][1] -
+               m[0][1] * m[2][0] * m[3][2] + m[0][0] * m[2][1] * m[3][2]) * scale;
+  out[3][2] = (m[0][2] * m[1][1] * m[3][0] - m[0][1] * m[1][2] * m[3][0] -
+               m[0][2] * m[1][0] * m[3][1] + m[0][0] * m[1][2] * m[3][1] +
+               m[0][1] * m[1][0] * m[3][2] - m[0][0] * m[1][1] * m[3][2]) * scale;
+  out[3][3] = (m[0][1] * m[1][2] * m[2][0] - m[0][2] * m[1][1] * m[2][0] +
+               m[0][2] * m[1][0] * m[2][1] - m[0][0] * m[1][2] * m[2][1] -
+               m[0][1] * m[1][0] * m[2][2] + m[0][0] * m[1][1] * m[2][2]) * scale;
+}
+#endif
+
+
+static void
+ghid_unproject_to_z_plane (int ex, int ey, Coord pcb_z, Coord *pcb_x, Coord *pcb_y)
+{
+  float mat[2][2];
+  float inv_mat[2][2];
+  float x, y;
+
+  /*
+    ex = view_matrix[0][0] * vx +
+         view_matrix[0][1] * vy +
+         view_matrix[0][2] * vz +
+         view_matrix[0][3] * 1;
+    ey = view_matrix[1][0] * vx +
+         view_matrix[1][1] * vy +
+         view_matrix[1][2] * vz +
+         view_matrix[1][3] * 1;
+    UNKNOWN ez = view_matrix[2][0] * vx +
+                 view_matrix[2][1] * vy +
+                 view_matrix[2][2] * vz +
+                 view_matrix[2][3] * 1;
+
+    ex - view_matrix[0][3] * 1
+       - view_matrix[0][2] * vz
+      = view_matrix[0][0] * vx +
+        view_matrix[0][1] * vy;
+
+    ey - view_matrix[1][3] * 1
+       - view_matrix[1][2] * vz
+      = view_matrix[1][0] * vx +
+        view_matrix[1][1] * vy;
+  */
+
+  /* NB: last_modelview_matrix is transposed in memory! */
+  x = (float)ex - last_modelview_matrix[3][0] * 1
+                - last_modelview_matrix[2][0] * pcb_z;
+
+  y = (float)ey - last_modelview_matrix[3][1] * 1
+                - last_modelview_matrix[2][1] * pcb_z;
+
+  /*
+    x = view_matrix[0][0] * vx +
+        view_matrix[0][1] * vy;
+
+    y = view_matrix[1][0] * vx +
+        view_matrix[1][1] * vy;
+
+    [view_matrix[0][0] view_matrix[0][1]] [vx] = [x]
+    [view_matrix[1][0] view_matrix[1][1]] [vy]   [y]
+  */
+
+  mat[0][0] = last_modelview_matrix[0][0];
+  mat[0][1] = last_modelview_matrix[1][0];
+  mat[1][0] = last_modelview_matrix[0][1];
+  mat[1][1] = last_modelview_matrix[1][1];
+
+  /*    if (determinant_2x2 (mat) < 0.00001)       */
+  /*      printf ("Determinant is quite small\n"); */
+
+  invert_2x2 (mat, inv_mat);
+
+  *pcb_x = (int)(inv_mat[0][0] * x + inv_mat[0][1] * y);
+  *pcb_y = (int)(inv_mat[1][0] * x + inv_mat[1][1] * y);
+}
+
+
 bool
 ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y)
 {
-  *pcb_x = EVENT_TO_PCB_X (event_x);
-  *pcb_y = EVENT_TO_PCB_Y (event_y);
+  ghid_unproject_to_z_plane (event_x, event_y, 0, pcb_x, pcb_y);
 
   return true;
 }
@@ -1266,12 +1501,54 @@ ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y)
 bool
 ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y)
 {
-  *event_x = DRAW_X (pcb_x);
-  *event_y = DRAW_Y (pcb_y);
+  /* NB: last_modelview_matrix is transposed in memory */
+  float w = last_modelview_matrix[0][3] * (float)pcb_x +
+            last_modelview_matrix[1][3] * (float)pcb_y +
+            last_modelview_matrix[2][3] * 0. +
+            last_modelview_matrix[3][3] * 1.;
+
+  *event_x = (last_modelview_matrix[0][0] * (float)pcb_x +
+              last_modelview_matrix[1][0] * (float)pcb_y +
+              last_modelview_matrix[2][0] * 0. +
+              last_modelview_matrix[3][0] * 1.) / w;
+  *event_y = (last_modelview_matrix[0][1] * (float)pcb_x +
+              last_modelview_matrix[1][1] * (float)pcb_y +
+              last_modelview_matrix[2][1] * 0. +
+              last_modelview_matrix[3][1] * 1.) / w;
 
   return true;
 }
 
+void
+ghid_view_2d (void *ball, gboolean view_2d, gpointer userdata)
+{
+  global_view_2d = view_2d;
+  ghid_invalidate_all ();
+}
+
+void
+ghid_port_rotate (void *ball, float *quarternion, gpointer userdata)
+{
+#ifdef DEBUG_ROTATE
+  int row, column;
+#endif
+
+  build_rotmatrix (view_matrix, quarternion);
+
+#ifdef DEBUG_ROTATE
+  for (row = 0; row < 4; row++) {
+    printf ("[ %f", view_matrix[row][0]);
+    for (column = 1; column < 4; column++) {
+      printf (",\t%f", view_matrix[row][column]);
+    }
+    printf ("\t]\n");
+  }
+  printf ("\n");
+#endif
+
+  ghid_invalidate_all ();
+}
+
 
 #define LEAD_USER_WIDTH           0.2          /* millimeters */
 #define LEAD_USER_PERIOD          (1000 / 20)  /* 20fps (in ms) */
diff --git a/src/hid/gtk/gui-top-window.c b/src/hid/gtk/gui-top-window.c
index 786024e..aa6d8e6 100644
--- a/src/hid/gtk/gui-top-window.c
+++ b/src/hid/gtk/gui-top-window.c
@@ -121,6 +121,7 @@ a zoom in/out.
 
 #include "gui-icons-mode-buttons.data"
 #include "gui-icons-misc.data"
+#include "gui-trackball.h"
 
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
@@ -1241,6 +1242,10 @@ ghid_build_pcb_top_window (void)
   GtkWidget *vbox_main, *hbox_middle, *hbox;
   GtkWidget *vbox, *frame;
   GtkWidget *label;
+  /* FIXME: IFDEF HACK */
+#ifdef ENABLE_GL
+  GtkWidget *trackball;
+#endif
   GHidPort *port = &ghid_port;
   GtkWidget *scrolled;
 
@@ -1319,6 +1324,17 @@ ghid_build_pcb_top_window (void)
   gtk_box_pack_start (GTK_BOX(vbox), ghidgui->layer_selector,
                       FALSE, FALSE, 0);
 
+  /* FIXME: IFDEF HACK */
+#ifdef ENABLE_GL
+  trackball = ghid_trackball_new ();
+  g_signal_connect (trackball, "rotation-changed",
+                    G_CALLBACK (ghid_port_rotate), NULL);
+  g_signal_connect (trackball, "view-2d-changed",
+                    G_CALLBACK (ghid_view_2d), NULL);
+  gtk_box_pack_start (GTK_BOX(ghidgui->left_toolbar),
+                      trackball, FALSE, FALSE, 0);
+#endif
+
   /* ghidgui->mode_buttons_frame was created above in the call to
    * make_mode_buttons_and_toolbar (...);
    */
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index f2585f7..77fa4d4 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -296,7 +296,6 @@ gint ghid_port_window_motion_cb (GtkWidget * widget,
 gint ghid_port_window_mouse_scroll_cb (GtkWidget * widget,
 				       GdkEventScroll * ev, GHidPort * out);
 
-
 gint ghid_port_drawing_area_configure_event_cb (GtkWidget * widget,
 						GdkEventConfigure * ev,
 						GHidPort * out);
@@ -505,6 +504,8 @@ void ghid_flush_debug_draw (void);
 void ghid_finish_debug_draw (void);
 bool ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y);
 bool ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y);
+void ghid_port_rotate (void *ball, float *quarternion, gpointer userdata);
+void ghid_view_2d (void *ball, gboolean view_2d, gpointer userdata);
 
 void ghid_lead_user_to_location (Coord x, Coord y);
 void ghid_cancel_lead_user (void);

Bottom: c653a900da569390041747620ee631fb488296e2
Top:    23de850660d0eaaa5f61908439ef08c396af6eba
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-11-07 10:06:57 +0000

Cache triangulated polygons for rendering


---

diff --git a/src/create.c b/src/create.c
index cb0fb2c..c465024 100644
--- a/src/create.c
+++ b/src/create.c
@@ -618,6 +618,8 @@ CreateNewPolygon (LayerTypePtr Layer, FlagType Flags)
   polygon->Clipped = NULL;
   polygon->NoHoles = NULL;
   polygon->NoHolesValid = 0;
+  polygon->gui_cache = NULL;
+  polygon->gui_cache_valid = 0;
   return (polygon);
 }
 
diff --git a/src/global.h b/src/global.h
index bb78abc..a455d3f 100644
--- a/src/global.h
+++ b/src/global.h
@@ -264,6 +264,8 @@ struct polygon_st			/* holds information about a polygon */
   Cardinal HoleIndexN;		/* number of holes in polygon */
   Cardinal HoleIndexMax;	/* max number from malloc() */
 
+  void *gui_cache;		/* Private cache for the GUI */
+  int gui_cache_valid;		/* Reset to false when the polygon changes */
 };
 
 typedef struct			/* holds information about arcs */
diff --git a/src/hid.h b/src/hid.h
index 073dbae..d3616c8 100644
--- a/src/hid.h
+++ b/src/hid.h
@@ -540,6 +540,7 @@ typedef enum
     HID_DRC_GUI *drc_gui;
 
     void (*edit_attributes) (char *owner, AttributeListType *attrlist_);
+    void (*free_polygon_cache) (PolygonType *poly);
 
   } HID;
 
diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index ef74623..bf018ea 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -613,54 +613,22 @@ hidgl_fill_polygon (int n_coords, int *x, int *y)
   free (vertices);
 }
 
-struct do_hole_info {
-  double scale;
-};
-
-static int
-do_hole (const BoxType *b, void *cl)
-{
-  struct do_hole_info *info = cl;
-  PLINE *curc = (PLINE *) b;
-  cairo_traps_t traps;
-
-  /* Ignore the outer contour - we draw it first explicitly*/
-  if (curc->Flags.orient == PLF_DIR) {
-    return 0;
-  }
-
-  /* If the contour is round, and hidgl_fill_circle would use
-   * less slices than we have vertices to draw it, then call
-   * hidgl_fill_circle to draw this contour.
-   */
-  if (curc->is_round) {
-    double slices = calc_slices (curc->radius / info->scale, 2 * M_PI);
-    if (slices < curc->Count) {
-      hidgl_fill_circle (curc->cx, curc->cy, curc->radius, info->scale);
-      return 1;
-    }
-  }
-
-  _cairo_traps_init (&traps);
-  bo_contour_to_traps (curc, &traps);
-  _cairo_traps_fini (&traps);
-
-  return 1;
-}
-
 static GLint stencil_bits;
 static int dirty_bits = 0;
 static int assigned_bits = 0;
 
+struct polygon_cache {
+  int fill_display_list;
+};
+
 /* FIXME: JUST DRAWS THE FIRST PIECE.. TODO: SUPPORT FOR FULLPOLY POLYGONS */
 void
-hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale)
+hidgl_fill_pcb_polygon_nocache (PolygonType *poly, const BoxType *clip_box, double scale)
 {
-  struct do_hole_info info;
   cairo_traps_t traps;
 
   CHECK_IS_IN_CONTEXT ();
-  info.scale = scale;
+
   global_scale = scale;
 
   if (poly->Clipped == NULL)
@@ -669,26 +637,43 @@ hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale
       return;
     }
 
-  /* Flush out any existing geoemtry to be rendered */
-  hidgl_flush_triangles (&buffer);
-
-  /* Draw the polygon outer */
   _cairo_traps_init (&traps);
-  bo_contour_to_traps (poly->Clipped->contours, &traps);
+  bo_poly_to_traps (poly->Clipped, &traps);
   _cairo_traps_fini (&traps);
-  hidgl_flush_triangles (&buffer);
+}
 
-  glPushAttrib (GL_CURRENT_BIT);
+void
+hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale)
+{
+  struct polygon_cache *cache;
+  int new_cache = 0;
 
-  glDisable (GL_BLEND);
+  if (poly->gui_cache == NULL) {
+    poly->gui_cache = malloc (sizeof (struct polygon_cache));
+    new_cache = 1;
+  }
 
-  glColor4f (0., 0., 0., 0.0);
-  r_search (poly->Clipped->contour_tree, clip_box, NULL, do_hole, &info);
-  hidgl_flush_triangles (&buffer);
+  cache = poly->gui_cache;
 
-  glEnable (GL_BLEND);
+#if 1
+  if (!poly->gui_cache_valid) {
+    if (!new_cache)
+      glDeleteLists (cache->fill_display_list, 1);
+
+    cache->fill_display_list = glGenLists (1);
+    hidgl_flush_triangles (&buffer);
+    glNewList (cache->fill_display_list, GL_COMPILE);
+    hidgl_fill_pcb_polygon_nocache (poly, NULL /* clip_box */, scale);
+    hidgl_flush_triangles (&buffer);
+    glEndList ();
+    poly->gui_cache_valid = 1;
+  }
 
-  glPopAttrib ();
+  glCallList (cache->fill_display_list);
+
+#else
+  hidgl_fill_pcb_polygon_nocache (poly, clip_box, scale);
+#endif
 }
 
 void
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 8e4267f..10006df 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -955,6 +955,14 @@ ghid_progress (int so_far, int total, const char *message)
   return 0;
 }
 
+static void
+ghid_free_polygon_cache (PolygonType *poly)
+{
+  printf ("FIXME: Should free cached polygon data\n");
+  free (poly->gui_cache);
+  poly->gui_cache_valid = 0;
+}
+
 /* ---------------------------------------------------------------------- */
 
 
@@ -1242,7 +1250,8 @@ HID ghid_hid = {
   ghid_beep,
   ghid_progress,
   &ghid_drc_gui,
-  ghid_attributes
+  ghid_attributes,
+  ghid_free_polygon_cache,
 };
 
 /* ------------------------------------------------------------ 
diff --git a/src/mymem.c b/src/mymem.c
index bed0f9b..ecb6802 100644
--- a/src/mymem.c
+++ b/src/mymem.c
@@ -755,6 +755,10 @@ FreePolygonMemory (PolygonTypePtr Polygon)
 {
   if (Polygon)
     {
+      if (Polygon->gui_cache)
+        {
+          gui->free_polygon_cache (Polygon);
+        }
       MYFREE (Polygon->Points);
       MYFREE (Polygon->HoleIndex);
       if (Polygon->Clipped)
diff --git a/src/polygon.c b/src/polygon.c
index 774c987..74000ce 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -1071,6 +1071,7 @@ clearPoly (DataTypePtr Data, LayerTypePtr Layer, PolygonType * polygon,
       subtract_accumulated (&info, polygon);
     }
   polygon->NoHolesValid = 0;
+  polygon->gui_cache_valid = 0;
   return r;
 }
 
@@ -1216,8 +1217,9 @@ InitClip (DataTypePtr Data, LayerTypePtr layer, PolygonType * p)
   assert (poly_Valid (p->Clipped));
   if (TEST_FLAG (CLEARPOLYFLAG, p))
     clearPoly (Data, layer, p, NULL, 0);
-  else
-    p->NoHolesValid = 0;
+  /* HACK */
+  p->NoHolesValid = 0;
+  p->gui_cache_valid = 0;
   return 1;
 }
 
@@ -1468,22 +1470,27 @@ subtract_plow (DataTypePtr Data, LayerTypePtr Layer, PolygonTypePtr Polygon,
     case VIA_TYPE:
       SubtractPin (Data, (PinTypePtr) ptr2, Layer, Polygon);
       Polygon->NoHolesValid = 0;
+      Polygon->gui_cache_valid = 0;
       return 1;
     case LINE_TYPE:
       SubtractLine ((LineTypePtr) ptr2, Polygon);
       Polygon->NoHolesValid = 0;
+      Polygon->gui_cache_valid = 0;
       return 1;
     case ARC_TYPE:
       SubtractArc ((ArcTypePtr) ptr2, Polygon);
       Polygon->NoHolesValid = 0;
+      Polygon->gui_cache_valid = 0;
       return 1;
     case PAD_TYPE:
       SubtractPad ((PadTypePtr) ptr2, Polygon);
       Polygon->NoHolesValid = 0;
+      Polygon->gui_cache_valid = 0;
       return 1;
     case TEXT_TYPE:
       SubtractText ((TextTypePtr) ptr2, Polygon);
       Polygon->NoHolesValid = 0;
+      Polygon->gui_cache_valid = 0;
       return 1;
     }
   return 0;

Bottom: 00791c620c4b15331c789e25a0f914836ff31430
Top:    39a1237451c1db9c57649336a228163a621e9269
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-11-07 10:06:57 +0000

Cache triangulated polygons for rendering


---

diff --git a/src/create.c b/src/create.c
index fe9619a..9c43054 100644
--- a/src/create.c
+++ b/src/create.c
@@ -644,6 +644,8 @@ CreateNewPolygon (LayerType *Layer, FlagType Flags)
   polygon->Clipped = NULL;
   polygon->NoHoles = NULL;
   polygon->NoHolesValid = 0;
+  polygon->gui_cache = NULL;
+  polygon->gui_cache_valid = 0;
   return (polygon);
 }
 
diff --git a/src/global.h b/src/global.h
index ce67c50..de6ab5a 100644
--- a/src/global.h
+++ b/src/global.h
@@ -272,6 +272,8 @@ struct polygon_st			/* holds information about a polygon */
   Cardinal HoleIndexN;		/* number of holes in polygon */
   Cardinal HoleIndexMax;	/* max number from malloc() */
 
+  void *gui_cache;		/* Private cache for the GUI */
+  int gui_cache_valid;		/* Reset to false when the polygon changes */
 };
 
 typedef struct			/* holds information about arcs */
diff --git a/src/hid.h b/src/hid.h
index ef6edb2..66c7252 100644
--- a/src/hid.h
+++ b/src/hid.h
@@ -478,6 +478,7 @@ typedef enum
     HID_DRC_GUI *drc_gui;
 
     void (*edit_attributes) (char *owner, AttributeListType *attrlist_);
+    void (*free_polygon_cache) (PolygonType *poly);
 
     /* Debug drawing support. These APIs must be implemented (non NULL),
      * but they do not have to be functional. request_debug_draw can
diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index 97a0d3f..a686288 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -727,242 +727,67 @@ hidgl_fill_polygon (int n_coords, Coord *x, Coord *y)
   free (vertices);
 }
 
-static inline void
-stash_vertex (PLINE *contour, int *vertex_comp,
-              float x, float y, float z, float r, float s)
-{
-  contour->tristrip_vertices[(*vertex_comp)++] = x;
-  contour->tristrip_vertices[(*vertex_comp)++] = y;
-#if MEMCPY_VERTEX_DATA
-  contour->tristrip_vertices[(*vertex_comp)++] = z;
-  contour->tristrip_vertices[(*vertex_comp)++] = r;
-  contour->tristrip_vertices[(*vertex_comp)++] = s;
-#endif
-  contour->tristrip_num_vertices ++;
-}
-
-static void
-fill_contour (PLINE *contour)
-{
-  int i;
-  int vertex_comp;
-  borast_traps_t traps;
-
-  /* If the contour is round, then call hidgl_fill_circle to draw it. */
-  if (contour->is_round) {
-    hidgl_fill_circle (contour->cx, contour->cy, contour->radius);
-    return;
-  }
-
-  /* If we don't have a cached set of tri-strips, compute them */
-  if (contour->tristrip_vertices == NULL) {
-    int tristrip_space;
-    int x1, x2, x3, x4, y_top, y_bot;
-
-    _borast_traps_init (&traps);
-    bo_contour_to_traps_no_draw (contour, &traps);
-
-    tristrip_space = 0;
-
-    for (i = 0; i < traps.num_traps; i++) {
-      y_top = traps.traps[i].top;
-      y_bot = traps.traps[i].bottom;
-
-      x1 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_top);
-      x2 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_top);
-      x3 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_bot);
-      x4 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_bot);
-
-      if ((x1 == x2) || (x3 == x4)) {
-        tristrip_space += 5; /* Three vertices + repeated start and end */
-      } else {
-        tristrip_space += 6; /* Four vertices + repeated start and end */
-      }
-    }
-
-    if (tristrip_space == 0) {
-      printf ("Strange, contour didn't tesselate\n");
-      return;
-    }
-
-#if MEMCPY_VERTEX_DATA
-    /* NB: MEMCPY of vertex data causes a problem with depth being cached at the wrong level! */
-    contour->tristrip_vertices = malloc (sizeof (float) * 5 * tristrip_space);
-#else
-    contour->tristrip_vertices = malloc (sizeof (float) * 2 * tristrip_space);
-#endif
-    contour->tristrip_num_vertices = 0;
-
-    vertex_comp = 0;
-    for (i = 0; i < traps.num_traps; i++) {
-      y_top = traps.traps[i].top;
-      y_bot = traps.traps[i].bottom;
-
-      x1 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_top);
-      x2 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_top);
-      x3 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_bot);
-      x4 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_bot);
-
-      if (x1 == x2) {
-        /* NB: Repeated first virtex to separate from other tri-strip */
-        stash_vertex (contour, &vertex_comp, x1, y_top, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x1, y_top, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x3, y_bot, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x4, y_bot, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x4, y_bot, global_depth, 0.0, 0.0);
-        /* NB: Repeated last virtex to separate from other tri-strip */
-      } else if (x3 == x4) {
-        /* NB: Repeated first virtex to separate from other tri-strip */
-        stash_vertex (contour, &vertex_comp, x1, y_top, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x1, y_top, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x2, y_top, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x3, y_bot, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x3, y_bot, global_depth, 0.0, 0.0);
-        /* NB: Repeated last virtex to separate from other tri-strip */
-      } else {
-        /* NB: Repeated first virtex to separate from other tri-strip */
-        stash_vertex (contour, &vertex_comp, x2, y_top, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x2, y_top, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x3, y_bot, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x1, y_top, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x4, y_bot, global_depth, 0.0, 0.0);
-        stash_vertex (contour, &vertex_comp, x4, y_bot, global_depth, 0.0, 0.0);
-        /* NB: Repeated last virtex to separate from other tri-strip */
-      }
-    }
-
-    _borast_traps_fini (&traps);
-  }
-
-  if (contour->tristrip_num_vertices == 0)
-    return;
-
-  hidgl_ensure_vertex_space (&buffer, contour->tristrip_num_vertices);
-
-#if MEMCPY_VERTEX_DATA
-  memcpy (&buffer.triangle_array[buffer.coord_comp_count],
-          contour->tristrip_vertices,
-          sizeof (float) * 5 * contour->tristrip_num_vertices);
-  buffer.coord_comp_count += 5 * contour->tristrip_num_vertices;
-  buffer.vertex_count += contour->tristrip_num_vertices;
-
-#else
-  vertex_comp = 0;
-  for (i = 0; i < contour->tristrip_num_vertices; i++) {
-    int x, y;
-    x = contour->tristrip_vertices[vertex_comp++];
-    y = contour->tristrip_vertices[vertex_comp++];
-    hidgl_add_vertex_tex (&buffer, x, y, 0.0, 0.0);
-  }
-#endif
-
-}
-
-static int
-do_hole (const BoxType *b, void *cl)
-{
-  PLINE *curc = (PLINE *) b;
-
-  /* Ignore the outer contour - we draw it first explicitly*/
-  if (curc->Flags.orient == PLF_DIR) {
-    return 0;
-  }
-
-  fill_contour (curc);
-  return 1;
-}
-
-static bool
-polygon_contains_user_holes (PolygonType *polygon)
-{
-  return (polygon->HoleIndexN > 0);
-}
-
-
 static GLint stencil_bits;
 static int dirty_bits = 0;
 static int assigned_bits = 0;
 
-static void
-fill_polyarea (POLYAREA *pa, const BoxType *clip_box, bool use_new_stencil)
+struct polygon_cache {
+  int fill_display_list;
+};
+
+/* FIXME: JUST DRAWS THE FIRST PIECE.. TODO: SUPPORT FOR FULLPOLY POLYGONS */
+void
+hidgl_fill_pcb_polygon_nocache (PolygonType *poly, const BoxType *clip_box, double scale)
 {
-  int stencil_bit;
+  cairo_traps_t traps;
 
   CHECK_IS_IN_CONTEXT ();
 
-  /* Special case non-holed polygons which don't require a stencil bit */
-  if (pa->contour_tree->size == 1) {
-    fill_contour (pa->contours);
-    return;
-  }
-
-  /* Polygon has holes.. does it have any user-drawn holes? (caller tells us)
-   * If so, it must be masked with a _new_ stencil bit.
-   */
-  if (use_new_stencil)
-    {
-      stencil_bit = hidgl_assign_clear_stencil_bit ();
-      if (!stencil_bit)
-        {
-          printf ("hidgl_fill_pcb_polygon: No free stencil bits, aborting polygon\n");
-          /* XXX: Could use the GLU tesselator or the full BO polygon tesselator */
-          return;
-        }
-    }
+  global_scale = scale;
 
-  /* Flush out any existing geoemtry to be rendered */
-  hidgl_flush_triangles (&buffer);
-
-  glPushAttrib (GL_STENCIL_BUFFER_BIT |                 /* Resave the stencil write-mask etc.., and */
-                GL_COLOR_BUFFER_BIT |                   /* the colour buffer write mask etc.. for part way restore */
-                GL_DEPTH_BUFFER_BIT);
-  glEnable (GL_STENCIL_TEST);                           /* Enable the stencil test, just in case it wasn't already on */
-//=======
-//<<<<<<< current
-//                GL_COLOR_BUFFER_BIT);                   /* the colour buffer write mask etc.. for part way restore */
-//  glEnable (GL_STENCIL_TEST);                           /* Enable the stencil test, just in case it wasn't already on */
-//=======
-//                GL_COLOR_BUFFER_BIT |                   /* the colour buffer write mask etc.. for part way restore */
-//                GL_DEPTH_BUFFER_BIT);
-//>>>>>>> patched
-  glColorMask (0, 0, 0, 0);                             /* Disable writting in color buffer */
-  glDepthFunc (GL_ALWAYS);
-  glDepthMask (GL_FALSE);
-
-  if (use_new_stencil)
+  if (poly->Clipped == NULL)
     {
-      glStencilMask (stencil_bit);                            /* Only write to our stencil bit */
-      glStencilFunc (GL_ALWAYS, stencil_bit, stencil_bit);    /* Always pass stencil test, ref value is our bit */
-      glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);             /* Stencil pass => replace stencil value */
+      fprintf (stderr, "hidgl_fill_pcb_polygon: poly->Clipped == NULL\n");
+      return;
     }
 
-  /* Drawing operations now set our reference bit in the stencil buffer */
+  _cairo_traps_init (&traps);
+  bo_poly_to_traps (poly->Clipped, &traps);
+  _cairo_traps_fini (&traps);
+}
 
-  r_search (pa->contour_tree, clip_box, NULL, do_hole, NULL);
-  hidgl_flush_triangles (&buffer);
+void
+hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale)
+{
+  struct polygon_cache *cache;
+  int new_cache = 0;
 
-  glPopAttrib ();                               /* Restore the colour and stencil buffer write-mask etc.. */
-  glPushAttrib (GL_STENCIL_BUFFER_BIT);         /* Save the stencil op and function */
-  glEnable (GL_STENCIL_TEST);                   /* Enable the stencil test, just in case it wasn't already on */
+  if (poly->gui_cache == NULL) {
+    poly->gui_cache = malloc (sizeof (struct polygon_cache));
+    new_cache = 1;
+  }
 
-  glStencilOp (GL_KEEP, GL_KEEP, GL_INVERT);    /* This allows us to toggle the bit on the subcompositing bitplane */
-                                                /* If the stencil test has passed, we know that bit is 0, so we're */
-                                                /* effectively just setting it to 1. */
-  glStencilFunc (GL_GEQUAL, 0, assigned_bits);  /* Pass stencil test if all assigned bits clear, */
-                                                /* reference is all assigned bits so we set */
-                                                /* any bits permitted by the stencil writemask */
+  cache = poly->gui_cache;
 
-  /* Drawing operations as masked to areas where the stencil buffer is '0' */
+#if 1
+  if (!poly->gui_cache_valid) {
+    if (!new_cache)
+      glDeleteLists (cache->fill_display_list, 1);
 
-  /* Draw the polygon outer */
-  fill_contour (pa->contours);
-  hidgl_flush_triangles (&buffer);
+    cache->fill_display_list = glGenLists (1);
+    hidgl_flush_triangles (&buffer);
+    glNewList (cache->fill_display_list, GL_COMPILE);
+    hidgl_fill_pcb_polygon_nocache (poly, NULL /* clip_box */, scale);
+    hidgl_flush_triangles (&buffer);
+    glEndList ();
+    poly->gui_cache_valid = 1;
+  }
 
-  /* Unassign our stencil buffer bit */
-  if (use_new_stencil)
-    hidgl_return_stencil_bit (stencil_bit);
+  glCallList (cache->fill_display_list);
 
-  glPopAttrib ();                               /* Restore the stencil buffer op and function */
+#else
+  hidgl_fill_pcb_polygon_nocache (poly, clip_box, scale);
+#endif
 }
 
 void
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 9b0fc84..fbd9ecf 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -845,6 +845,14 @@ ghid_progress (int so_far, int total, const char *message)
           pd->response_id == GTK_RESPONSE_DELETE_EVENT) ? 1 : 0;
 }
 
+static void
+ghid_free_polygon_cache (PolygonType *poly)
+{
+  printf ("FIXME: Should free cached polygon data\n");
+  free (poly->gui_cache);
+  poly->gui_cache_valid = 0;
+}
+
 /* ---------------------------------------------------------------------- */
 
 
@@ -2180,6 +2188,7 @@ hid_gtk_init ()
 
   ghid_hid.notify_save_pcb          = ghid_notify_save_pcb;
   ghid_hid.notify_filename_changed  = ghid_notify_filename_changed;
+  ghid_hid.free_polygon_cache       = ghid_free_polygon_cache,
 
   ghid_hid.graphics                 = &ghid_graphics;
 
diff --git a/src/mymem.c b/src/mymem.c
index aff501c..b10466a 100644
--- a/src/mymem.c
+++ b/src/mymem.c
@@ -536,6 +536,9 @@ FreePolygonMemory (PolygonType *polygon)
   if (polygon == NULL)
     return;
 
+  if (Polygon->gui_cache)
+    gui->free_polygon_cache (Polygon);
+
   free (polygon->Points);
   free (polygon->HoleIndex);
 
@@ -543,7 +546,6 @@ FreePolygonMemory (PolygonType *polygon)
     poly_Free (&polygon->Clipped);
   poly_FreeContours (&polygon->NoHoles);
 
-  memset (polygon, 0, sizeof (PolygonType));
 }
 
 /* ---------------------------------------------------------------------------
diff --git a/src/polygon.c b/src/polygon.c
index 78dda51..10445ad 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -1079,6 +1079,7 @@ clearPoly (DataType *Data, LayerType *Layer, PolygonType * polygon,
       subtract_accumulated (&info, polygon);
     }
   polygon->NoHolesValid = 0;
+  polygon->gui_cache_valid = 0;
   return r;
 }
 
@@ -1226,8 +1227,9 @@ InitClip (DataType *Data, LayerType *layer, PolygonType * p)
   assert (poly_Valid (p->Clipped));
   if (TEST_FLAG (CLEARPOLYFLAG, p))
     clearPoly (Data, layer, p, NULL, 0);
-  else
-    p->NoHolesValid = 0;
+  /* HACK */
+  p->NoHolesValid = 0;
+  p->gui_cache_valid = 0;
   return 1;
 }
 
@@ -1478,22 +1480,27 @@ subtract_plow (DataType *Data, LayerType *Layer, PolygonType *Polygon,
     case VIA_TYPE:
       SubtractPin (Data, (PinType *) ptr2, Layer, Polygon);
       Polygon->NoHolesValid = 0;
+      Polygon->gui_cache_valid = 0;
       return 1;
     case LINE_TYPE:
       SubtractLine ((LineType *) ptr2, Polygon);
       Polygon->NoHolesValid = 0;
+      Polygon->gui_cache_valid = 0;
       return 1;
     case ARC_TYPE:
       SubtractArc ((ArcType *) ptr2, Polygon);
       Polygon->NoHolesValid = 0;
+      Polygon->gui_cache_valid = 0;
       return 1;
     case PAD_TYPE:
       SubtractPad ((PadType *) ptr2, Polygon);
       Polygon->NoHolesValid = 0;
+      Polygon->gui_cache_valid = 0;
       return 1;
     case TEXT_TYPE:
       SubtractText ((TextType *) ptr2, Polygon);
       Polygon->NoHolesValid = 0;
+      Polygon->gui_cache_valid = 0;
       return 1;
     }
   return 0;

Bottom: dfaec038bcd007541876607d1686f8ef767e5055
Top:    5aa8f647e686d9f7dab6e7775130882a0b666b14
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-11-04 00:31:10 +0000

Cache triangulated polygons for rendering


---

diff --git a/src/create.c b/src/create.c
index 1a6aef9..55732a7 100644
--- a/src/create.c
+++ b/src/create.c
@@ -615,6 +615,8 @@ CreateNewPolygon (LayerTypePtr Layer, FlagType Flags)
   polygon->Clipped = NULL;
   polygon->NoHoles = NULL;
   polygon->NoHolesValid = 0;
+  polygon->gui_cache = NULL;
+  polygon->gui_cache_valid = 0;
   return (polygon);
 }
 
diff --git a/src/global.h b/src/global.h
index fa9f55e..cc51af2 100644
--- a/src/global.h
+++ b/src/global.h
@@ -245,6 +245,8 @@ struct polygon_st			/* holds information about a polygon */
   PLINE *NoHoles;		/* the polygon broken into hole-less regions */
   int NoHolesValid;		/* Is the NoHoles polygon up to date? */
   PointTypePtr Points;		/* data */
+  void *gui_cache;		/* Private cache for the GUI */
+  int gui_cache_valid;		/* Reset to false when the polygon changes */
 };
 
 typedef struct			/* holds information about arcs */
diff --git a/src/hid.h b/src/hid.h
index ffb84a2..c545768 100644
--- a/src/hid.h
+++ b/src/hid.h
@@ -555,6 +555,8 @@ typedef enum
 
     HID_DRC_GUI *drc_gui;
 
+    void (*free_polygon_cache) (PolygonType *poly);
+
   } HID;
 
 /* Call this as soon as possible from main().  No other HID calls are
diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index 92f2d32..4e96a2d 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -614,12 +614,15 @@ static GLint stencil_bits;
 static int dirty_bits = 0;
 static int assigned_bits = 0;
 
+struct polygon_cache {
+  int fill_display_list;
+};
+
 /* FIXME: JUST DRAWS THE FIRST PIECE.. TODO: SUPPORT FOR FULLPOLY POLYGONS */
 void
-hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale)
+hidgl_fill_pcb_polygon_nocache (PolygonType *poly, const BoxType *clip_box, double scale)
 {
   struct do_hole_info info;
-  int stencil_bit;
   cairo_traps_t *traps;
 
   info.scale = scale;
@@ -631,52 +634,42 @@ hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale
       return;
     }
 
-  stencil_bit = hidgl_assign_clear_stencil_bit ();
-  if (!stencil_bit)
-    {
-      printf ("hidgl_fill_pcb_polygon: No free stencil bits, aborting polygon\n");
-      return;
-    }
-
-  /* Flush out any existing geoemtry to be rendered */
-  hidgl_flush_triangles (&buffer);
-
-  glPushAttrib (GL_STENCIL_BUFFER_BIT);                   // Save the write mask etc.. for final restore
-  glPushAttrib (GL_STENCIL_BUFFER_BIT |                   // Resave the stencil write-mask etc.., and
-                GL_COLOR_BUFFER_BIT);                     // the colour buffer write mask etc.. for part way restore
-  glStencilMask (stencil_bit);                            // Only write to our stencil bit
-  glStencilFunc (GL_ALWAYS, stencil_bit, stencil_bit);    // Always pass stencil test, ref value is our bit
-  glColorMask (0, 0, 0, 0);                               // Disable writting in color buffer
-
-  /* It will already be setup like this (so avoid prodding the state-machine):
-   * glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value
-   */
-  /* Drawing operations now set our reference bit in the stencil buffer */
-
-  r_search (poly->Clipped->contour_tree, clip_box, NULL, do_hole, &info);
-  hidgl_flush_triangles (&buffer);
+  traps = bo_poly_to_traps (poly->Clipped);
+  _cairo_traps_fini (traps);
+}
 
-  /* Drawing operations as masked to areas where the stencil buffer is '0' */
+void
+hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale)
+{
+  struct polygon_cache *cache;
+  int new_cache = 0;
 
-  glPopAttrib ();                                             // Restore the colour and stencil buffer write-mask etc..
+  if (poly->gui_cache == NULL) {
+    poly->gui_cache = malloc (sizeof (struct polygon_cache));
+    new_cache = 1;
+  }
 
-  glStencilOp (GL_KEEP, GL_KEEP, GL_INVERT); // This allows us to toggle the bit on the subcompositing bitplane
-                                             // If the stencil test has passed, we know that bit is 0, so we're
-                                             // effectively just setting it to 1.
-  glStencilFunc (GL_GEQUAL, 0, assigned_bits);
-//  glStencilFunc (GL_GREATER, assigned_bits, assigned_bits);   // Pass stencil test if all assigned bits clear,
-                                                              // reference is all assigned bits so we set
-                                                              // any bits permitted by the stencil writemask
+  cache = poly->gui_cache;
 
-  /* Draw the polygon outer */
-  traps = bo_contour_to_traps (poly->Clipped->contours);
-  _cairo_traps_fini (traps);
-  hidgl_flush_triangles (&buffer);
+#if 0
+  if (!poly->gui_cache_valid) {
+    if (!new_cache)
+      glDeleteLists (cache->fill_display_list, 1);
+
+    cache->fill_display_list = glGenLists (1);
+    hidgl_flush_triangles (&buffer);
+    glNewList (cache->fill_display_list, GL_COMPILE);
+    hidgl_fill_pcb_polygon_nocache (poly, NULL /* clip_box */, scale);
+    hidgl_flush_triangles (&buffer);
+    glEndList ();
+    poly->gui_cache_valid = 1;
+  }
 
-  /* Unassign our stencil buffer bit */
-  hidgl_return_stencil_bit (stencil_bit);
+  glCallList (cache->fill_display_list);
 
-  glPopAttrib ();                                             // Restore the stencil buffer write-mask etc..
+#else
+  hidgl_fill_pcb_polygon_nocache (poly, clip_box, scale);
+#endif
 }
 
 void
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 3f101be..dfb89b8 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -1473,6 +1473,14 @@ ghid_progress (int so_far, int total, const char *message)
   return 0;
 }
 
+static void
+ghid_free_polygon_cache (PolygonType *poly)
+{
+  printf ("FIXME: Should free cached polygon data\n");
+  free (poly->gui_cache);
+  poly->gui_cache_valid = 0;
+}
+
 /* ---------------------------------------------------------------------- */
 HID_DRC_GUI ghid_drc_gui = {
   1,				/* log_drc_overview */
@@ -1543,7 +1551,8 @@ HID ghid_hid = {
   ghid_show_item,
   ghid_beep,
   ghid_progress,
-  &ghid_drc_gui
+  &ghid_drc_gui,
+  ghid_free_polygon_cache,
 };
 
 HID ghid_extents = {
@@ -1606,7 +1615,8 @@ HID ghid_extents = {
   0 /* ghid_show_item */ ,
   0 /* ghid_beep */ ,
   0 /* ghid_progress */ ,
-  0 /* ghid_drc_gui */
+  0 /* ghid_drc_gui */ ,
+  0 /* ghid_free_polygon_cache */ ,
 };
 
 /* ------------------------------------------------------------ 
diff --git a/src/mymem.c b/src/mymem.c
index 4118cf0..cfdbd26 100644
--- a/src/mymem.c
+++ b/src/mymem.c
@@ -733,6 +733,10 @@ FreePolygonMemory (PolygonTypePtr Polygon)
 {
   if (Polygon)
     {
+      if (Polygon->gui_cache)
+        {
+          gui->free_polygon_cache (Polygon);
+        }
       MYFREE (Polygon->Points);
       if (Polygon->Clipped)
 	poly_Free (&Polygon->Clipped);
diff --git a/src/polygon.c b/src/polygon.c
index 0a86fa4..a39d699 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -986,6 +986,7 @@ clearPoly (DataTypePtr Data, LayerTypePtr Layer, PolygonType * polygon,
       info.accumulate = NULL;
     }
   polygon->NoHolesValid = 0;
+  polygon->gui_cache_valid = 0;
   return r;
 }
 
@@ -1131,8 +1132,9 @@ InitClip (DataTypePtr Data, LayerTypePtr layer, PolygonType * p)
   assert (poly_Valid (p->Clipped));
   if (TEST_FLAG (CLEARPOLYFLAG, p))
     clearPoly (Data, layer, p, NULL, 0);
-  else
-    p->NoHolesValid = 0;
+  /* HACK */
+  p->NoHolesValid = 0;
+  p->gui_cache_valid = 0;
   return 1;
 }
 
@@ -1387,22 +1389,27 @@ subtract_plow (DataTypePtr Data, LayerTypePtr Layer, PolygonTypePtr Polygon,
     case VIA_TYPE:
       SubtractPin (Data, (PinTypePtr) ptr2, Layer, Polygon);
       Polygon->NoHolesValid = 0;
+      Polygon->gui_cache_valid = 0;
       return 1;
     case LINE_TYPE:
       SubtractLine ((LineTypePtr) ptr2, Polygon);
       Polygon->NoHolesValid = 0;
+      Polygon->gui_cache_valid = 0;
       return 1;
     case ARC_TYPE:
       SubtractArc ((ArcTypePtr) ptr2, Polygon);
       Polygon->NoHolesValid = 0;
+      Polygon->gui_cache_valid = 0;
       return 1;
     case PAD_TYPE:
       SubtractPad ((PadTypePtr) ptr2, Polygon);
       Polygon->NoHolesValid = 0;
+      Polygon->gui_cache_valid = 0;
       return 1;
     case TEXT_TYPE:
       SubtractText ((TextTypePtr) ptr2, Polygon);
       Polygon->NoHolesValid = 0;
+      Polygon->gui_cache_valid = 0;
       return 1;
     }
   return 0;

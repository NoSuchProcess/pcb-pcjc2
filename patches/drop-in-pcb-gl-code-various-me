Bottom: 3387d46a42570b60f6a74da1c0f74c5ba76b2789
Top:    dcd2cfcdc2e27bbc101cf0549b1ad4cd81008a50
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-03-06 18:47:37 +0000

Drop in PCB+GL code + various mess. Needs splitting up























---

diff --git a/src/Makefile.am b/src/Makefile.am
index 944eea8..f90d55f 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -148,13 +148,17 @@ PCB_SRCS = \
 	hid/hidint.h 
 pcb_SOURCES = ${PCB_SRCS} core_lists.h
 
-EXTRA_pcb_SOURCES = ${DBUS_SRCS}
+EXTRA_pcb_SOURCES = ${DBUS_SRCS} ${GL_SRCS}
 DBUS_SRCS= \
 	dbus-pcbmain.c \
 	dbus-pcbmain.h \
 	dbus.h \
 	dbus.c
 
+GL_SRCS= \
+	hid/common/hidgl.c \
+	hid/common/hidgl.h
+
 BUILT_SOURCES = \
 	core_lists.h \
 	gpcb-menu.h \
@@ -270,6 +274,11 @@ BUILT_SOURCES+=	dbus-introspect.h
 
 endif
 
+# If we are building with GL support, we need some extra files
+if USE_GL
+PCB_SRCS+=	${GL_SRCS}
+endif
+
 # If we are building on win32, then compile in some icons for the
 # desktop and application toolbar
 if WIN32
diff --git a/src/crosshair.c b/src/crosshair.c
index 8321929..e1ad65c 100644
--- a/src/crosshair.c
+++ b/src/crosshair.c
@@ -44,6 +44,7 @@
 #include "data.h"
 #include "draw.h"
 #include "error.h"
+
 #include "line.h"
 #include "misc.h"
 #include "mymem.h"
@@ -84,7 +85,7 @@ static void XORDrawMoveOrCopyObject (void);
 static void XORDrawAttachedLine (LocationType, LocationType, LocationType,
 				 LocationType, BDimension);
 static void XORDrawAttachedArc (BDimension);
-static void DrawAttached (Boolean);
+/*static*/ void DrawAttached (Boolean);
 
 /* ---------------------------------------------------------------------------
  * creates a tmp polygon with coordinates converted to screen system
@@ -576,7 +577,7 @@ XORDrawMoveOrCopyObject (void)
 /* ---------------------------------------------------------------------------
  * draws additional stuff that follows the crosshair
  */
-static void
+/*static*/ void
 DrawAttached (Boolean BlockToo)
 {
   BDimension s;
@@ -747,7 +748,7 @@ HideCrosshair (Boolean BlockToo)
   CrosshairStack[CrosshairStackLocation] = Crosshair.On;
   CrosshairStackLocation++;
 
-  CrosshairOff (BlockToo);
+//  CrosshairOff (BlockToo);
 }
 
 /* ---------------------------------------------------------------------------
@@ -767,11 +768,11 @@ RestoreCrosshair (Boolean BlockToo)
 
   if (CrosshairStack[CrosshairStackLocation])
     {
-      CrosshairOn (BlockToo);
+//      CrosshairOn (BlockToo);
     }
   else
     {
-      CrosshairOff (BlockToo);
+//      CrosshairOff (BlockToo);
     }
 }
 
diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
new file mode 100644
index 0000000..143735a
--- /dev/null
+++ b/src/hid/common/hidgl.c
@@ -0,0 +1,573 @@
+/* $Id: */
+
+#if 1 /* DISABLE EVERYTHING! */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+#include <math.h>
+#include <time.h>
+#include <assert.h>
+
+/* The Linux OpenGL ABI 1.0 spec requires that we define
+ * GL_GLEXT_PROTOTYPES before including gl.h or glx.h for extensions
+ * in order to get prototypes:
+ *   http://www.opengl.org/registry/ABI/
+ */
+#define GL_GLEXT_PROTOTYPES 1
+#include <GL/gl.h>
+#include <GL/glu.h>
+
+#include "action.h"
+#include "crosshair.h"
+#include "data.h"
+#include "draw.h"
+#include "error.h"
+#include "global.h"
+#include "mymem.h"
+#include "draw.h"
+#include "clip.h"
+
+#include "hid.h"
+#include "hidgl.h"
+
+
+
+#ifdef HAVE_LIBDMALLOC
+#include <dmalloc.h>
+#endif
+
+#define PIXELS_PER_CIRCLINE 5.
+
+RCSID ("$Id: $");
+
+triangle_buffer buffer;
+
+#if 0
+triangle_array *
+hidgl_new_triangle_array (void)
+{
+  return malloc (sizeof (triangle_buffer));
+}
+#endif
+
+void
+hidgl_init_triangle_array (triangle_buffer *buffer)
+{
+  glEnableClientState (GL_VERTEX_ARRAY);
+  glVertexPointer (2, GL_FLOAT, 0, buffer->triangle_array);
+  buffer->triangle_count = 0;
+  buffer->coord_comp_count = 0;
+}
+
+void
+hidgl_flush_triangles (triangle_buffer *buffer)
+{
+  if (buffer->triangle_count == 0)
+    return;
+
+  glDrawArrays (GL_TRIANGLES, 0, buffer->triangle_count * 3);
+  buffer->triangle_count = 0;
+  buffer->coord_comp_count = 0;
+}
+
+void
+hidgl_ensure_triangle_space (triangle_buffer *buffer, int count)
+{
+  if (count > TRIANGLE_ARRAY_SIZE)
+    {
+      fprintf (stderr, "Not enough space in vertex buffer\n");
+      fprintf (stderr, "Requested %i triangles, %i available\n",
+                       count, TRIANGLE_ARRAY_SIZE);
+      exit (1);
+    }
+  if (count > TRIANGLE_ARRAY_SIZE - buffer->triangle_count)
+    hidgl_flush_triangles (buffer);
+}
+
+//static int cur_mask = -1;
+
+
+/* ------------------------------------------------------------ */
+#if 0
+/*static*/ void
+draw_grid ()
+{
+  static GLfloat *points = 0;
+  static int npoints = 0;
+  int x1, y1, x2, y2, n, i;
+  double x, y;
+
+  if (!Settings.DrawGrid)
+    return;
+  if (Vz (PCB->Grid) < MIN_GRID_DISTANCE)
+    return;
+
+  if (gdk_color_parse (Settings.GridColor, &gport->grid_color))
+    {
+      gport->grid_color.red ^= gport->bg_color.red;
+      gport->grid_color.green ^= gport->bg_color.green;
+      gport->grid_color.blue ^= gport->bg_color.blue;
+    }
+
+  hidgl_flush_triangles ();
+
+  glEnable (GL_COLOR_LOGIC_OP);
+  glLogicOp (GL_XOR);
+
+  glColor3f (gport->grid_color.red / 65535.,
+             gport->grid_color.green / 65535.,
+             gport->grid_color.blue / 65535.);
+
+  x1 = GRIDFIT_X (SIDE_X (gport->view_x0), PCB->Grid);
+  y1 = GRIDFIT_Y (SIDE_Y (gport->view_y0), PCB->Grid);
+  x2 = GRIDFIT_X (SIDE_X (gport->view_x0 + gport->view_width - 1), PCB->Grid);
+  y2 = GRIDFIT_Y (SIDE_Y (gport->view_y0 + gport->view_height - 1), PCB->Grid);
+  if (x1 > x2)
+    {
+      int tmp = x1;
+      x1 = x2;
+      x2 = tmp;
+    }
+  if (y1 > y2)
+    {
+      int tmp = y1;
+      y1 = y2;
+      y2 = tmp;
+    }
+  if (Vx (x1) < 0)
+    x1 += PCB->Grid;
+  if (Vy (y1) < 0)
+    y1 += PCB->Grid;
+  if (Vx (x2) >= gport->width)
+    x2 -= PCB->Grid;
+  if (Vy (y2) >= gport->height)
+    y2 -= PCB->Grid;
+  n = (int) ((x2 - x1) / PCB->Grid + 0.5) + 1;
+  if (n > npoints)
+    {
+      npoints = n + 10;
+      points =
+        MyRealloc (points, npoints * 2 * sizeof (GLfloat), "gtk_draw_grid");
+    }
+
+  glEnableClientState (GL_VERTEX_ARRAY);
+  glVertexPointer (2, GL_FLOAT, 0, points);
+
+  n = 0;
+  for (x = x1; x <= x2; x += PCB->Grid)
+    {
+      points[2 * n] = Vx (x);
+      n++;
+    }
+  for (y = y1; y <= y2; y += PCB->Grid)
+    {
+      int vy = Vy (y);
+      for (i = 0; i < n; i++)
+        points[2 * i + 1] = vy;
+      glDrawArrays (GL_POINTS, 0, n);
+    }
+
+  glDisableClientState (GL_VERTEX_ARRAY);
+  glDisable (GL_COLOR_LOGIC_OP);
+  glFlush ();
+}
+
+#endif
+/* ------------------------------------------------------------ */
+
+#define MIN_TRIANGLES_PER_CAP 3
+#define MAX_TRIANGLES_PER_CAP 90
+static void draw_cap (double width, int x, int y, double angle, double scale)
+{
+  float last_capx, last_capy;
+  float capx, capy;
+  float radius = width / 2.;
+  int slices = M_PI * radius / scale / PIXELS_PER_CIRCLINE;
+  int i;
+
+  if (slices < MIN_TRIANGLES_PER_CAP)
+    slices = MIN_TRIANGLES_PER_CAP;
+
+  if (slices > MAX_TRIANGLES_PER_CAP)
+    slices = MAX_TRIANGLES_PER_CAP;
+
+  hidgl_ensure_triangle_space (&buffer, slices);
+
+  last_capx =  radius * cosf (angle * M_PI / 180.) + x;
+  last_capy = -radius * sinf (angle * M_PI / 180.) + y;
+  for (i = 0; i < slices; i++) {
+    capx =  radius * cosf (angle * M_PI / 180. + ((float)(i + 1)) * M_PI / (float)slices) + x;
+    capy = -radius * sinf (angle * M_PI / 180. + ((float)(i + 1)) * M_PI / (float)slices) + y;
+    hidgl_add_triangle (&buffer, last_capx, last_capy, capx, capy, x, y);
+    last_capx = capx;
+    last_capy = capy;
+  }
+}
+
+void
+hidgl_draw_line (int cap, double width, int x1, int y1, int x2, int y2, double scale)
+{
+  double angle;
+  float deltax, deltay, length;
+  float wdx, wdy;
+  int circular_caps = 0;
+  int hairline = 0;
+
+  if (width == 0.0)
+    hairline = 1;
+
+  if (width < scale)
+    width = scale;
+
+  deltax = x2 - x1;
+  deltay = y2 - y1;
+
+  length = sqrt (deltax * deltax + deltay * deltay);
+
+  if (length == 0) {
+    /* Assume the orientation of the line is horizontal */
+    angle = 0;
+    wdx = -width / 2.;
+    wdy = 0;
+    length = 1.;
+    deltax = 1.;
+    deltay = 0.;
+  } else {
+    wdy = deltax * width / 2. / length;
+    wdx = -deltay * width / 2. / length;
+
+    if (deltay == 0.)
+      angle = (deltax < 0) ? 270. : 90.;
+    else
+      angle = 180. / M_PI * atanl (deltax / deltay);
+
+    if (deltay < 0)
+      angle += 180.;
+  }
+
+  switch (cap) {
+    case Trace_Cap:
+    case Round_Cap:
+      circular_caps = 1;
+      break;
+
+    case Square_Cap:
+    case Beveled_Cap:
+      x1 -= deltax * width / 2. / length;
+      y1 -= deltay * width / 2. / length;
+      x2 += deltax * width / 2. / length;
+      y2 += deltay * width / 2. / length;
+      break;
+  }
+
+  hidgl_ensure_triangle_space (&buffer, 2);
+  hidgl_add_triangle (&buffer, x1 - wdx, y1 - wdy,
+                               x2 - wdx, y2 - wdy,
+                               x2 + wdx, y2 + wdy);
+  hidgl_add_triangle (&buffer, x1 - wdx, y1 - wdy,
+                               x2 + wdx, y2 + wdy,
+                               x1 + wdx, y1 + wdy);
+
+  /* Don't bother capping hairlines */
+  if (circular_caps && !hairline)
+    {
+      draw_cap (width, x1, y1, angle, scale);
+      draw_cap (width, x2, y2, angle + 180., scale);
+    }
+}
+
+#define MIN_SLICES_PER_ARC 6
+#define MAX_SLICES_PER_ARC 360
+void
+hidgl_draw_arc (double width, int x, int y, int rx, int ry,
+                int start_angle, int delta_angle, double scale)
+{
+  float last_inner_x, last_inner_y;
+  float last_outer_x, last_outer_y;
+  float inner_x, inner_y;
+  float outer_x, outer_y;
+  float inner_r;
+  float outer_r;
+  float cos_ang, sin_ang;
+  float start_angle_rad;
+  float delta_angle_rad;
+  float angle_incr_rad;
+  int slices;
+  int i;
+  int hairline = 0;
+
+  if (width == 0.0)
+    hairline = 1;
+
+  if (width < scale)
+    width = scale;
+
+  inner_r = rx - width / 2.;
+  outer_r = rx + width / 2.;
+
+  slices = M_PI * (rx + width / 2.) * abs (delta_angle) / 360. /
+           scale / PIXELS_PER_CIRCLINE;
+
+  if (slices < MIN_SLICES_PER_ARC)
+    slices = MIN_SLICES_PER_ARC;
+
+  if (slices > MAX_SLICES_PER_ARC)
+    slices = MAX_SLICES_PER_ARC;
+
+  hidgl_ensure_triangle_space (&buffer, 2 * slices);
+
+  if (delta_angle < 0) {
+    start_angle += delta_angle;
+    delta_angle = - delta_angle;
+  }
+
+  start_angle_rad = start_angle * M_PI / 180.;
+  delta_angle_rad = delta_angle * M_PI / 180.;
+  angle_incr_rad = delta_angle_rad / (float)slices;
+
+  cos_ang = cosf (start_angle_rad);
+  sin_ang = sinf (start_angle_rad);
+  last_inner_x = -inner_r * cos_ang + x;  last_inner_y = inner_r * sin_ang + y;
+  last_outer_x = -outer_r * cos_ang + x;  last_outer_y = outer_r * sin_ang + y;
+  for (i = 1; i <= slices; i++) {
+    cos_ang = cosf (start_angle_rad + ((float)(i)) * angle_incr_rad);
+    sin_ang = sinf (start_angle_rad + ((float)(i)) * angle_incr_rad);
+    inner_x = -inner_r * cos_ang + x;  inner_y = inner_r * sin_ang + y;
+    outer_x = -outer_r * cos_ang + x;  outer_y = outer_r * sin_ang + y;
+    hidgl_add_triangle (&buffer, last_inner_x, last_inner_y,
+                                 last_outer_x, last_outer_y,
+                                 outer_x, outer_y);
+    hidgl_add_triangle (&buffer, last_inner_x, last_inner_y,
+                                 inner_x, inner_y,
+                                 outer_x, outer_y);
+    last_inner_x = inner_x;  last_inner_y = inner_y;
+    last_outer_x = outer_x;  last_outer_y = outer_y;
+  }
+
+  /* Don't bother capping hairlines */
+  if (hairline)
+    return;
+
+  draw_cap (width, x + rx * -cosf (start_angle_rad),
+                   y + rx *  sinf (start_angle_rad),
+                   start_angle, scale);
+  draw_cap (width, x + rx * -cosf (start_angle_rad + delta_angle_rad),
+                   y + rx *  sinf (start_angle_rad + delta_angle_rad),
+                   start_angle + delta_angle + 180., scale);
+}
+
+void
+hidgl_draw_rect (int x1, int y1, int x2, int y2)
+{
+  glBegin (GL_LINE_LOOP);
+  glVertex2f (x1, y1);
+  glVertex2f (x1, y2);
+  glVertex2f (x2, y2);
+  glVertex2f (x2, y1);
+  glEnd ();
+}
+
+
+void
+hidgl_fill_circle (int vx, int vy, int vr, double scale)
+{
+#define MIN_TRIANGLES_PER_CIRCLE 6
+#define MAX_TRIANGLES_PER_CIRCLE 360
+  float last_x, last_y;
+  float radius = vr;
+  int slices;
+  int i;
+
+  slices = M_PI * 2 * vr / scale / PIXELS_PER_CIRCLINE;
+
+  if (slices < MIN_TRIANGLES_PER_CIRCLE)
+    slices = MIN_TRIANGLES_PER_CIRCLE;
+
+  if (slices > MAX_TRIANGLES_PER_CIRCLE)
+    slices = MAX_TRIANGLES_PER_CIRCLE;
+
+  hidgl_ensure_triangle_space (&buffer, slices);
+
+  last_x = vx + vr;
+  last_y = vy;
+
+  for (i = 0; i < slices; i++) {
+    float x, y;
+    x = radius * cosf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vx;
+    y = radius * sinf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vy;
+    hidgl_add_triangle (&buffer, vx, vy, last_x, last_y, x, y);
+    last_x = x;
+    last_y = y;
+  }
+}
+
+#define MAX_COMBINED_MALLOCS 2500
+static void *combined_to_free [MAX_COMBINED_MALLOCS];
+static int combined_num_to_free = 0;
+
+static GLenum tessVertexType;
+static int stashed_vertices;
+static int triangle_comp_idx;
+
+
+static void
+myError (GLenum errno)
+{
+  printf ("gluTess error: %s\n", gluErrorString (errno));
+}
+
+static void
+myFreeCombined ()
+{
+  while (combined_num_to_free)
+    free (combined_to_free [-- combined_num_to_free]);
+}
+
+static void
+myCombine ( GLdouble coords[3], void *vertex_data[4], GLfloat weight[4], void **dataOut )
+{
+#define MAX_COMBINED_VERTICES 2500
+  static GLdouble combined_vertices [3 * MAX_COMBINED_VERTICES];
+  static int num_combined_vertices = 0;
+
+  GLdouble *new_vertex;
+
+  if (num_combined_vertices < MAX_COMBINED_VERTICES)
+    {
+      new_vertex = &combined_vertices [3 * num_combined_vertices];
+      num_combined_vertices ++;
+    }
+  else
+    {
+      new_vertex = malloc (3 * sizeof (GLdouble));
+
+      if (combined_num_to_free < MAX_COMBINED_MALLOCS)
+        combined_to_free [combined_num_to_free ++] = new_vertex;
+      else
+        printf ("myCombine leaking %i bytes of memory\n", 3 * sizeof (GLdouble));
+    }
+
+  new_vertex[0] = coords[0];
+  new_vertex[1] = coords[1];
+  new_vertex[2] = coords[2];
+
+  *dataOut = new_vertex;
+}
+
+static void
+myBegin (GLenum type)
+{
+  tessVertexType = type;
+  stashed_vertices = 0;
+  triangle_comp_idx = 0;
+}
+
+static void
+myVertex (GLdouble *vertex_data)
+{
+  static GLfloat triangle_vertices [2 * 3];
+
+  if (tessVertexType == GL_TRIANGLE_STRIP ||
+      tessVertexType == GL_TRIANGLE_FAN)
+    {
+      if (stashed_vertices < 2)
+        {
+          triangle_vertices [triangle_comp_idx ++] = vertex_data [0];
+          triangle_vertices [triangle_comp_idx ++] = vertex_data [1];
+          stashed_vertices ++;
+        }
+      else
+        {
+          hidgl_ensure_triangle_space (&buffer, 1);
+          hidgl_add_triangle (&buffer,
+                              triangle_vertices [0], triangle_vertices [1],
+                              triangle_vertices [2], triangle_vertices [3],
+                              vertex_data [0], vertex_data [1]);
+
+          if (tessVertexType == GL_TRIANGLE_STRIP)
+            {
+              /* STRIP saves the last two vertices for re-use in the next triangle */
+              triangle_vertices [0] = triangle_vertices [2];
+              triangle_vertices [1] = triangle_vertices [3];
+            }
+          /* Both FAN and STRIP save the last vertex for re-use in the next triangle */
+          triangle_vertices [2] = vertex_data [0];
+          triangle_vertices [3] = vertex_data [1];
+        }
+    }
+  else if (tessVertexType == GL_TRIANGLES)
+    {
+      triangle_vertices [triangle_comp_idx ++] = vertex_data [0];
+      triangle_vertices [triangle_comp_idx ++] = vertex_data [1];
+      stashed_vertices ++;
+      if (stashed_vertices == 3)
+        {
+          hidgl_ensure_triangle_space (&buffer, 1);
+          hidgl_add_triangle (&buffer,
+                              triangle_vertices [0], triangle_vertices [1],
+                              triangle_vertices [2], triangle_vertices [3],
+                              triangle_vertices [4], triangle_vertices [5]);
+          triangle_comp_idx = 0;
+          stashed_vertices = 0;
+        }
+    }
+  else
+    printf ("Vertex recieved with unknown type\n");
+}
+
+void
+hidgl_fill_polygon (int n_coords, int *x, int *y)
+{
+  int i;
+  GLUtesselator *tobj;
+  GLdouble *vertices;
+
+//  return;
+
+  assert (n_coords > 0);
+
+  vertices = malloc (sizeof(GLdouble) * n_coords * 3);
+
+  tobj = gluNewTess ();
+  gluTessCallback(tobj, GLU_TESS_BEGIN, myBegin);
+  gluTessCallback(tobj, GLU_TESS_VERTEX, myVertex);
+  gluTessCallback(tobj, GLU_TESS_COMBINE, myCombine);
+  gluTessCallback(tobj, GLU_TESS_ERROR, myError);
+
+  gluTessBeginPolygon (tobj, NULL);
+  gluTessBeginContour (tobj);
+
+  for (i = 0; i < n_coords; i++)
+    {
+      vertices [0 + i * 3] = x[i];
+      vertices [1 + i * 3] = y[i];
+      vertices [2 + i * 3] = 0.;
+      gluTessVertex (tobj, &vertices [i * 3], &vertices [i * 3]);
+    }
+
+  gluTessEndContour (tobj);
+  gluTessEndPolygon (tobj);
+  gluDeleteTess (tobj);
+
+  myFreeCombined ();
+  free (vertices);
+}
+
+void
+hidgl_fill_rect (int x1, int y1, int x2, int y2)
+{
+  hidgl_add_triangle (&buffer, x1, y1, x1, y2, x2, y2);
+  hidgl_add_triangle (&buffer, x2, y1, x2, y2, x1, y1);
+}
+
+/* ---------------------------------------------------------------------- */
+
+#endif /* DISABLE EVERYTHING! */
+
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
new file mode 100644
index 0000000..fc2d41a
--- /dev/null
+++ b/src/hid/common/hidgl.h
@@ -0,0 +1,69 @@
+/* $Id: gui.h,v 1.25 2008-04-13 14:15:38 petercjclifton Exp $ */
+
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 1994,1995,1996 Thomas Nau
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifndef __HIDGL_INCLUDED__
+#define __HIDGL_INCLUDED__
+
+//#define TRIANGLE_ARRAY_SIZE 5000
+#define TRIANGLE_ARRAY_SIZE 5461
+/* Assumes GLFloat is 4 bytes, and we have X,Y coords x3 for each triangle:
+   4 * 5461 * 2 * 3 = 109464 */
+#define TRIANGLE_ARRAY_BYTES 131072
+typedef struct {
+  GLfloat triangle_array [2 * 3 * TRIANGLE_ARRAY_SIZE];
+  unsigned int triangle_count;
+  unsigned int coord_comp_count;
+} triangle_buffer;
+
+extern triangle_buffer buffer;
+
+void hidgl_init_triangle_array (triangle_buffer *buffer);
+void hidgl_flush_triangles (triangle_buffer *buffer);
+void hidgl_ensure_triangle_space (triangle_buffer *buffer, int count);
+
+static inline void
+hidgl_add_triangle (triangle_buffer *buffer,
+                    GLfloat x1, GLfloat y1,
+                    GLfloat x2, GLfloat y2,
+                    GLfloat x3, GLfloat y3)
+{
+  buffer->triangle_array [buffer->coord_comp_count++] = x1;
+  buffer->triangle_array [buffer->coord_comp_count++] = y1;
+  buffer->triangle_array [buffer->coord_comp_count++] = x2;
+  buffer->triangle_array [buffer->coord_comp_count++] = y2;
+  buffer->triangle_array [buffer->coord_comp_count++] = x3;
+  buffer->triangle_array [buffer->coord_comp_count++] = y3;
+  buffer->triangle_count++;
+}
+
+// void draw_grid ()
+void hidgl_draw_line (int cap, double width, int x1, int y1, int x2, int y2, double scale);
+void hidgl_draw_arc (double width, int vx, int vy, int vrx, int vry, int start_angle, int delta_angle, double scale);
+void hidgl_draw_rect (int x1, int y1, int x2, int y2);
+void hidgl_fill_circle (int vx, int vy, int vr, double scale);
+void hidgl_fill_polygon (int n_coords, int *x, int *y);
+void hidgl_fill_rect (int x1, int y1, int x2, int y2);
+
+
+#endif /* __HIDGL_INCLUDED__  */
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 484cee0..0e3e6e3 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -25,34 +25,45 @@
 
 #include "hid.h"
 #include "../hidint.h"
-#include "gui.h"
 #include "hid/common/draw_helpers.h"
 
+#ifdef ENABLE_GL
+#  include <GL/gl.h>
+#  include "hid/common/hidgl.h"
+#endif
+
+#include "gui.h"
 
 #if !GTK_CHECK_VERSION(2,8,0) && defined(HAVE_GDK_GDKX_H)
 #include <gdk/gdkx.h>
 #endif
 
+#ifdef ENABLE_GL
+#  include <gtk/gtkgl.h>
+#endif
+
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
 #endif
 
+#define PIXELS_PER_CIRCLINE 5.
 
 RCSID ("$Id$");
 
 
 extern HID ghid_hid;
 
+static int ghid_gui_is_up = 0;
+static hidGC current_gc = NULL;
 
 static void zoom_to (double factor, int x, int y);
 static void zoom_by (double factor, int x, int y);
 
 /* Sets gport->u_gc to the "right" GC to use (wrt mask or window)
 */
-#define USE_GC(gc) if (!use_gc(gc)) return
+#define USE_GC(gc) use_gc (gc)
 
 static int cur_mask = -1;
-static int mask_seq = 0;
 
 int ghid_flip_x = 0, ghid_flip_y = 0;
 
@@ -380,10 +391,10 @@ zoom_by (double factor, int x, int y)
 
 /* ------------------------------------------------------------ */
 
-static void
+/*static*/ void
 draw_grid ()
 {
-  static GdkPoint *points = 0;
+  static GLfloat *points = 0;
   static int npoints = 0;
   int x1, y1, x2, y2, n, i;
   double x, y;
@@ -392,19 +403,23 @@ draw_grid ()
     return;
   if (Vz (PCB->Grid) < MIN_GRID_DISTANCE)
     return;
-  if (!gport->grid_gc)
+
+  if (gdk_color_parse (Settings.GridColor, &gport->grid_color))
     {
-      if (gdk_color_parse (Settings.GridColor, &gport->grid_color))
-	{
-	  gport->grid_color.red ^= gport->bg_color.red;
-	  gport->grid_color.green ^= gport->bg_color.green;
-	  gport->grid_color.blue ^= gport->bg_color.blue;
-	  gdk_color_alloc (gport->colormap, &gport->grid_color);
-	}
-      gport->grid_gc = gdk_gc_new (gport->drawable);
-      gdk_gc_set_function (gport->grid_gc, GDK_XOR);
-      gdk_gc_set_foreground (gport->grid_gc, &gport->grid_color);
+      gport->grid_color.red ^= gport->bg_color.red;
+      gport->grid_color.green ^= gport->bg_color.green;
+      gport->grid_color.blue ^= gport->bg_color.blue;
     }
+
+  hidgl_flush_triangles (&buffer);
+
+  glEnable (GL_COLOR_LOGIC_OP);
+  glLogicOp (GL_XOR);
+
+  glColor3f (gport->grid_color.red / 65535.,
+             gport->grid_color.green / 65535.,
+             gport->grid_color.blue / 65535.);
+
   x1 = GRIDFIT_X (SIDE_X (gport->view_x0), PCB->Grid);
   y1 = GRIDFIT_Y (SIDE_Y (gport->view_y0), PCB->Grid);
   x2 = GRIDFIT_X (SIDE_X (gport->view_x0 + gport->view_width - 1), PCB->Grid);
@@ -434,21 +449,29 @@ draw_grid ()
     {
       npoints = n + 10;
       points =
-	MyRealloc (points, npoints * sizeof (GdkPoint), "gtk_draw_grid");
+	MyRealloc (points, npoints * 2 * sizeof (GLfloat), "gtk_draw_grid");
     }
+
+  glEnableClientState (GL_VERTEX_ARRAY);
+  glVertexPointer (2, GL_FLOAT, 0, points);
+
   n = 0;
   for (x = x1; x <= x2; x += PCB->Grid)
     {
-      points[n].x = Vx (x);
+      points[2 * n] = Vx (x);
       n++;
     }
   for (y = y1; y <= y2; y += PCB->Grid)
     {
       int vy = Vy (y);
       for (i = 0; i < n; i++)
-	points[i].y = vy;
-      gdk_draw_points (gport->drawable, gport->grid_gc, points, n);
+	points[2 * i + 1] = vy;
+      glDrawArrays (GL_POINTS, 0, n);
     }
+
+  glDisableClientState (GL_VERTEX_ARRAY);
+  glDisable (GL_COLOR_LOGIC_OP);
+//  glFlush ();
 }
 
 /* ------------------------------------------------------------ */
@@ -472,108 +495,81 @@ ghid_invalidate_lr (int left, int right, int top, int bottom, int last)
   ghid_invalidate_all ();
 }
 
+#if 0
 static void
 ghid_draw_bg_image(void)
 {
-	static GdkPixbuf	*pixbuf;
-	GdkInterpType	interp_type;
-	gint	x, y, w, h, w_src, h_src;
-	static gint	w_scaled, h_scaled;
-
-	if (!ghidgui->bg_pixbuf)
-		return;
-
-	w = PCB->MaxWidth / gport->zoom;
-	h = PCB->MaxHeight / gport->zoom;
-	x = gport->view_x0 / gport->zoom;
-	y = gport->view_y0 / gport->zoom;
-
-	if (w_scaled != w || h_scaled != h)
-		{
-		if (pixbuf)
-			g_object_unref(G_OBJECT(pixbuf));
-
-		w_src = gdk_pixbuf_get_width(ghidgui->bg_pixbuf);
-		h_src = gdk_pixbuf_get_height(ghidgui->bg_pixbuf);
-		if (w > w_src && h > h_src)
-			interp_type = GDK_INTERP_NEAREST;
-		else
-			interp_type = GDK_INTERP_BILINEAR;
-
-		pixbuf = gdk_pixbuf_scale_simple(ghidgui->bg_pixbuf, w, h, interp_type);
-		w_scaled = w;
-		h_scaled = h;
-		}
-	if (pixbuf)
-		gdk_pixbuf_render_to_drawable(pixbuf, gport->drawable, gport->bg_gc,
-            x, y, 0, 0,
-            w - x, h - y, GDK_RGB_DITHER_NORMAL, 0, 0);
-	}
-
-void
-ghid_invalidate_all ()
-{
-  int eleft, eright, etop, ebottom;
-  BoxType region;
+  static GdkPixbuf *pixbuf = NULL;
+  static gint vw_scaled, vh_scaled, x_cached, y_cached;
+  GdkInterpType interp_type;
+  gint x, y, vw, vh, w, h, w_src, h_src;
+  int bits_per_sample;
+  gboolean has_alpha;
 
-  if (!gport->pixmap)
+  if (!ghidgui->bg_pixbuf)
     return;
 
-  region.X1 = MIN(Px(0), Px(gport->width + 1));
-  region.Y1 = MIN(Py(0), Py(gport->height + 1));
-  region.X2 = MAX(Px(0), Px(gport->width + 1));
-  region.Y2 = MAX(Py(0), Py(gport->height + 1));
+  w = PCB->MaxWidth / gport->zoom;
+  h = PCB->MaxHeight / gport->zoom;
+  x = gport->view_x0 / gport->zoom;
+  y = gport->view_y0 / gport->zoom;
+  vw = gport->view_width / gport->zoom;
+  vh = gport->view_height / gport->zoom;
 
-  eleft = Vx (0);
-  eright = Vx (PCB->MaxWidth);
-  etop = Vy (0);
-  ebottom = Vy (PCB->MaxHeight);
-  if (eleft > eright)
+  if (pixbuf == NULL || vw_scaled != vw || vh_scaled != vh)
     {
-      int tmp = eleft;
-      eleft = eright;
-      eright = tmp;
+      if (pixbuf != NULL)
+        g_object_unref(G_OBJECT(pixbuf));
+
+      bits_per_sample = gdk_pixbuf_get_bits_per_sample(ghidgui->bg_pixbuf);
+      has_alpha = gdk_pixbuf_get_has_alpha (ghidgui->bg_pixbuf);
+      pixbuf = gdk_pixbuf_new(GDK_COLORSPACE_RGB,
+                              has_alpha,
+                              bits_per_sample,
+                              vw, vh);
     }
-  if (etop > ebottom)
+
+  if (pixbuf == NULL)
+    return;
+
+  if (vw_scaled != vw || vh_scaled != vh ||
+       x_cached != x  ||  y_cached != y)
     {
-      int tmp = etop;
-      etop = ebottom;
-      ebottom = tmp;
-    }
+      w_src = gdk_pixbuf_get_width(ghidgui->bg_pixbuf);
+      h_src = gdk_pixbuf_get_height(ghidgui->bg_pixbuf);
 
-  if (eleft > 0)
-    gdk_draw_rectangle (gport->drawable, gport->offlimits_gc,
-			1, 0, 0, eleft, gport->height);
-  else
-    eleft = 0;
-  if (eright < gport->width)
-    gdk_draw_rectangle (gport->drawable, gport->offlimits_gc,
-			1, eright, 0, gport->width - eright, gport->height);
-  else
-    eright = gport->width;
-  if (etop > 0)
-    gdk_draw_rectangle (gport->drawable, gport->offlimits_gc,
-			1, eleft, 0, eright - eleft + 1, etop);
-  else
-    etop = 0;
-  if (ebottom < gport->height)
-    gdk_draw_rectangle (gport->drawable, gport->offlimits_gc,
-			1, eleft, ebottom, eright - eleft + 1,
-			gport->height - ebottom);
-  else
-    ebottom = gport->height;
+      if (w > w_src && h > h_src)
+        interp_type = GDK_INTERP_NEAREST;
+      else
+        interp_type = GDK_INTERP_BILINEAR;
 
-  gdk_draw_rectangle (gport->drawable, gport->bg_gc, 1,
-		      eleft, etop, eright - eleft + 1, ebottom - etop + 1);
+      gdk_pixbuf_scale(ghidgui->bg_pixbuf, pixbuf,
+                       0, 0, vw, vh,
+                       (double) -x,
+                       (double) -y,
+                       (double) w / w_src,
+                       (double) h / h_src,
+                       interp_type);
 
-  ghid_draw_bg_image();
+      x_cached = x;
+      y_cached = y;
+      vw_scaled = vw;
+      vh_scaled = vh;
+    }
 
-  hid_expose_callback (&ghid_hid, &region, 0);
-  draw_grid ();
+  if (pixbuf != NULL)
+    gdk_draw_pixbuf(gport->drawable, gport->bg_gc, pixbuf,
+                    0, 0, 0, 0, vw, vh, GDK_RGB_DITHER_NORMAL, 0, 0);
+}
+#endif
+
+void
+ghid_invalidate_all ()
+{
   if (ghidgui->need_restore_crosshair)
     RestoreCrosshair (FALSE);
   ghidgui->need_restore_crosshair = FALSE;
-  ghid_screen_update ();
+  gdk_window_invalidate_rect (gport->drawing_area->window, NULL, 1);
 }
 
 
@@ -584,8 +580,10 @@ ghid_set_layer (const char *name, int group, int empty)
 	     && group <
 	     max_layer) ? PCB->LayerGroups.Entries[group][0] : group;
 
-  if (idx >= 0 && idx < max_layer + 2)
+  if (idx >= 0 && idx < max_layer + 2) {
+    gport->trans_lines = TRUE;
     return /*pinout ? 1 : */ PCB->Data->Layer[idx].On;
+  }
   if (idx < 0)
     {
       switch (SL_TYPE (idx))
@@ -597,11 +595,16 @@ ghid_set_layer (const char *name, int group, int empty)
 	    return TEST_FLAG (SHOWMASKFLAG, PCB);
 	  return 0;
 	case SL_SILK:
+//          gport->trans_lines = TRUE;
+          gport->trans_lines = FALSE;
 	  if (SL_MYSIDE (idx) /*|| pinout */ )
 	    return PCB->ElementOn;
 	  return 0;
 	case SL_ASSY:
 	  return 0;
+	case SL_RATS:
+	  gport->trans_lines = TRUE;
+	  return 1;
 	case SL_PDRILL:
 	case SL_UDRILL:
 	  return 1;
@@ -610,55 +613,41 @@ ghid_set_layer (const char *name, int group, int empty)
   return 0;
 }
 
-#define WHICH_GC(gc) (cur_mask == HID_MASK_CLEAR ? gport->mask_gc : (gc)->gc)
-
 void
 ghid_use_mask (int use_it)
 {
-  static int mask_seq_id = 0;
-  GdkColor color;
-
-  if (!gport->pixmap)
-    return;
   if (use_it == cur_mask)
     return;
+
+  hidgl_flush_triangles (&buffer);
+
   switch (use_it)
     {
-    case HID_MASK_OFF:
-      gport->drawable = gport->pixmap;
-      mask_seq = 0;
-      break;
-
     case HID_MASK_BEFORE:
-      printf ("gtk doesn't support mask_before!\n");
-      abort ();
+      /* Write '1' to the stencil buffer where the solder-mask is drawn. */
+      glColorMask (0, 0, 0, 0);                   // Disable writting in color buffer
+      glEnable (GL_STENCIL_TEST);                 // Enable Stencil test
+      glStencilFunc (GL_ALWAYS, 1, 1);            // Test always passes, value written 1
+      glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value (with 1)
+      break;
 
     case HID_MASK_CLEAR:
-      if (!gport->mask)
-	gport->mask = gdk_pixmap_new (0, gport->width, gport->height, 1);
-      gport->drawable = gport->mask;
-      mask_seq = 0;
-      if (!gport->mask_gc)
-	{
-	  gport->mask_gc = gdk_gc_new (gport->drawable);
-	}
-      color.pixel = 1;
-      gdk_gc_set_foreground (gport->mask_gc, &color);
-      gdk_draw_rectangle (gport->drawable, gport->mask_gc, TRUE, 0, 0,
-			  gport->width, gport->height);
-      color.pixel = 0;
-      gdk_gc_set_foreground (gport->mask_gc, &color);
+      /* Drawing operations clear the stencil buffer to '0' */
+      glStencilFunc (GL_ALWAYS, 0, 1);            // Test always passes, value written 0
+      glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value (with 0)
       break;
 
     case HID_MASK_AFTER:
-      mask_seq_id++;
-      if (!mask_seq_id)
-	mask_seq_id = 1;
-      mask_seq = mask_seq_id;
-
-      gport->drawable = gport->pixmap;
+      /* Drawing operations as masked to areas where the stencil buffer is '1' */
+      glColorMask (1, 1, 1, 1);                   // Enable drawing of r, g, b & a
+      glStencilFunc (GL_EQUAL, 1, 1);             // Draw only where stencil buffer is 1
+      glStencilOp (GL_KEEP, GL_KEEP, GL_KEEP);    // Stencil buffer read only
       break;
 
+    case HID_MASK_OFF:
+      /* Disable stenciling */
+      glDisable (GL_STENCIL_TEST);                // Disable Stencil test
+      break;
     }
   cur_mask = use_it;
 }
@@ -675,6 +664,9 @@ typedef struct
   GdkColor color;
   int xor_set;
   GdkColor xor_color;
+  double red;
+  double green;
+  double blue;
 } ColorCache;
 
 
@@ -689,9 +681,7 @@ set_special_grid_color (void)
   gport->grid_color.red ^= gport->bg_color.red;
   gport->grid_color.green ^= gport->bg_color.green;
   gport->grid_color.blue ^= gport->bg_color.blue;
-  gdk_color_alloc (gport->colormap, &gport->grid_color);
-  if (gport->grid_gc)
-    gdk_gc_set_foreground (gport->grid_gc, &gport->grid_color);
+//  gdk_color_alloc (gport->colormap, &gport->grid_color);
 }
 
 void
@@ -699,99 +689,138 @@ ghid_set_special_colors (HID_Attribute * ha)
 {
   if (!ha->name || !ha->value)
     return;
-  if (!strcmp (ha->name, "background-color") && gport->bg_gc)
+  if (!strcmp (ha->name, "background-color"))
     {
       ghid_map_color_string (*(char **) ha->value, &gport->bg_color);
-      gdk_gc_set_foreground (gport->bg_gc, &gport->bg_color);
       set_special_grid_color ();
     }
-  else if (!strcmp (ha->name, "off-limit-color") && gport->offlimits_gc)
-    {
+  else if (!strcmp (ha->name, "off-limit-color"))
+  {
       ghid_map_color_string (*(char **) ha->value, &gport->offlimits_color);
-      gdk_gc_set_foreground (gport->offlimits_gc, &gport->offlimits_color);
     }
-  else if (!strcmp (ha->name, "grid-color") && gport->grid_gc)
+  else if (!strcmp (ha->name, "grid-color"))
     {
       ghid_map_color_string (*(char **) ha->value, &gport->grid_color);
       set_special_grid_color ();
     }
 }
 
+
 void
 ghid_set_color (hidGC gc, const char *name)
 {
-  static void *cache = 0;
+  static void *cache = NULL;
+  static char *old_name = NULL;
   hidval cval;
+  ColorCache *cc;
+  double alpha_mult = 1.0;
+  double r, g, b, a;
+  a = 1.0;
+
+  if (old_name != NULL)
+    {
+      if (strcmp (name, old_name) == 0)
+        return;
+      free (old_name);
+    }
+
+  old_name = strdup (name);
 
   if (name == NULL)
     {
       fprintf (stderr, "%s():  name = NULL, setting to magenta\n",
-	       __FUNCTION__);
+               __FUNCTION__);
       name = "magenta";
     }
 
   gc->colorname = (char *) name;
-  if (!gc->gc)
-    return;
+
   if (gport->colormap == 0)
     gport->colormap = gtk_widget_get_colormap (gport->top_window);
-
   if (strcmp (name, "erase") == 0)
     {
-      gdk_gc_set_foreground (gc->gc, &gport->bg_color);
       gc->erase = 1;
+      r = gport->bg_color.red   / 65535.;
+      g = gport->bg_color.green / 65535.;
+      b = gport->bg_color.blue  / 65535.;
     }
   else if (strcmp (name, "drill") == 0)
     {
-      gdk_gc_set_foreground (gc->gc, &gport->offlimits_color);
       gc->erase = 0;
+      alpha_mult = 0.85;
+      r = gport->offlimits_color.red   / 65535.;
+      g = gport->offlimits_color.green / 65535.;
+      b = gport->offlimits_color.blue  / 65535.;
     }
   else
     {
-      ColorCache *cc;
+      alpha_mult = 0.7;
       if (hid_cache_color (0, name, &cval, &cache))
-	cc = (ColorCache *) cval.ptr;
+        cc = (ColorCache *) cval.ptr;
       else
-	{
-	  cc = (ColorCache *) malloc (sizeof (ColorCache));
-	  memset (cc, 0, sizeof (*cc));
-	  cval.ptr = cc;
-	  hid_cache_color (1, name, &cval, &cache);
-	}
+        {
+          cc = (ColorCache *) malloc (sizeof (ColorCache));
+          memset (cc, 0, sizeof (*cc));
+          cval.ptr = cc;
+          hid_cache_color (1, name, &cval, &cache);
+        }
 
       if (!cc->color_set)
-	{
-	  if (gdk_color_parse (name, &cc->color))
-	    gdk_color_alloc (gport->colormap, &cc->color);
-	  else
-	    gdk_color_white (gport->colormap, &cc->color);
-	  cc->color_set = 1;
-	}
+        {
+          if (gdk_color_parse (name, &cc->color))
+            gdk_color_alloc (gport->colormap, &cc->color);
+          else
+            gdk_color_white (gport->colormap, &cc->color);
+          cc->red   = cc->color.red   / 65535.;
+          cc->green = cc->color.green / 65535.;
+          cc->blue  = cc->color.blue  / 65535.;
+          cc->color_set = 1;
+        }
       if (gc->xor)
-	{
-	  if (!cc->xor_set)
-	    {
-	      cc->xor_color.red = cc->color.red ^ gport->bg_color.red;
-	      cc->xor_color.green = cc->color.green ^ gport->bg_color.green;
-	      cc->xor_color.blue = cc->color.blue ^ gport->bg_color.blue;
-	      gdk_color_alloc (gport->colormap, &cc->xor_color);
-	      cc->xor_set = 1;
-	    }
-	  gdk_gc_set_foreground (gc->gc, &cc->xor_color);
-	}
-      else
-	{
-	  gdk_gc_set_foreground (gc->gc, &cc->color);
-	}
+        {
+          if (!cc->xor_set)
+            {
+              cc->xor_color.red = cc->color.red ^ gport->bg_color.red;
+              cc->xor_color.green = cc->color.green ^ gport->bg_color.green;
+              cc->xor_color.blue = cc->color.blue ^ gport->bg_color.blue;
+              gdk_color_alloc (gport->colormap, &cc->xor_color);
+              cc->red   = cc->color.red   / 65535.;
+              cc->green = cc->color.green / 65535.;
+              cc->blue  = cc->color.blue  / 65535.;
+              cc->xor_set = 1;
+            }
+        }
+      r = cc->red;
+      g = cc->green;
+      b = cc->blue;
 
       gc->erase = 0;
     }
+  if (1) {
+    double maxi, mult;
+    if (gport->trans_lines)
+      a = a * alpha_mult;
+    maxi = r;
+    if (g > maxi) maxi = g;
+    if (b > maxi) maxi = b;
+    mult = MIN (1 / alpha_mult, 1 / maxi);
+#if 1
+    r = r * mult;
+    g = g * mult;
+    b = b * mult;
+#endif
+  }
+
+  if( ! ghid_gui_is_up )
+    return;
+
+  hidgl_flush_triangles (&buffer);
+  glColor4d (r, g, b, a);
 }
 
 void
 ghid_set_line_cap (hidGC gc, EndCapStyle style)
 {
-
   switch (style)
     {
     case Trace_Cap:
@@ -805,31 +834,22 @@ ghid_set_line_cap (hidGC gc, EndCapStyle style)
       gc->join = GDK_JOIN_MITER;
       break;
     }
-  if (gc->gc)
-    gdk_gc_set_line_attributes (WHICH_GC (gc),
-				Vz (gc->width), GDK_LINE_SOLID,
-				gc->cap, gc->join);
 }
 
 void
 ghid_set_line_width (hidGC gc, int width)
 {
-
   gc->width = width;
-  if (gc->gc)
-    gdk_gc_set_line_attributes (WHICH_GC (gc),
-				Vz (gc->width), GDK_LINE_SOLID,
-				gc->cap, gc->join);
 }
 
 void
 ghid_set_draw_xor (hidGC gc, int xor)
 {
-  gc->xor = xor;
-  if (!gc->gc)
-    return;
-  gdk_gc_set_function (gc->gc, xor ? GDK_XOR : GDK_COPY);
-  ghid_set_color (gc, gc->colorname);
+  // printf ("ghid_set_draw_xor (%p, %d) -- not implemented\n", gc, xor);
+  /* NOT IMPLEMENTED */
+
+  /* Only presently called when setting up a crosshair GC.
+   * We manage our own drawing model for that anyway. */
 }
 
 void
@@ -844,200 +864,73 @@ ghid_set_line_cap_angle (hidGC gc, int x1, int y1, int x2, int y2)
   printf ("ghid_set_line_cap_angle() -- not implemented\n");
 }
 
-static int
-use_gc (hidGC gc)
+void
+ghid_invalidate_current_gc (void)
 {
-  if (!gport->pixmap)
-    return 0;
-  if (!gc->gc)
-    {
-      gc->gc = gdk_gc_new (gport->top_window->window);
-      ghid_set_color (gc, gc->colorname);
-      ghid_set_line_width (gc, gc->width);
-      ghid_set_line_cap (gc, gc->cap);
-      ghid_set_draw_xor (gc, gc->xor);
-    }
-  if (gc->mask_seq != mask_seq)
-    {
-      if (mask_seq)
-	gdk_gc_set_clip_mask (gc->gc, gport->mask);
-      else
-	gdk_gc_set_clip_mask (gc->gc, NULL);
-      gc->mask_seq = mask_seq;
-    }
-  gport->u_gc = WHICH_GC (gc);
-  return 1;
+  current_gc = NULL;
 }
 
-void
-ghid_draw_line (hidGC gc, int x1, int y1, int x2, int y2)
+static void
+use_gc (hidGC gc)
 {
-  double dx1, dy1, dx2, dy2;
+  if (current_gc == gc)
+    return;
 
-  dx1 = Vx ((double)x1);
-  dy1 = Vy ((double)y1);
-  dx2 = Vx ((double)x2);
-  dy2 = Vy ((double)y2);
+  current_gc = gc;
 
-  if (! ClipLine (0, 0, gport->width, gport->height,
-		  &dx1, &dy1, &dx2, &dy2, gc->width / gport->zoom))
-    return;
+  ghid_set_color (gc, gc->colorname);
+}
 
+void
+ghid_draw_line (hidGC gc, int x1, int y1, int x2, int y2)
+{
   USE_GC (gc);
-  gdk_draw_line (gport->drawable, gport->u_gc, dx1, dy1, dx2, dy2);
+
+  hidgl_draw_line (gc->cap, gc->width, x1, y1, x2, y2, gport->zoom);
 }
 
 void
-ghid_draw_arc (hidGC gc, int cx, int cy,
-	       int xradius, int yradius, int start_angle, int delta_angle)
+ghid_draw_arc (hidGC gc, int cx, int cy, int xradius, int yradius,
+                         int start_angle, int delta_angle)
 {
-  gint vrx, vry;
-  gint w, h, radius;
-  
-  w = gport->width * gport->zoom;
-  h = gport->height * gport->zoom;
-  radius = (xradius > yradius) ? xradius : yradius;
-  if (SIDE_X (cx) < gport->view_x0 - radius
-      || SIDE_X (cx) > gport->view_x0 + w + radius
-      || SIDE_Y (cy) < gport->view_y0 - radius 
-      || SIDE_Y (cy) > gport->view_y0 + h + radius)
-    return;
-  
   USE_GC (gc);
-  vrx = Vz (xradius);
-  vry = Vz (yradius);
 
-  if (ghid_flip_x)
-    {
-      start_angle = 180 - start_angle;
-      delta_angle = - delta_angle;
-    }
-  if (ghid_flip_y)
-    {
-      start_angle = - start_angle;
-      delta_angle = - delta_angle;					
-    }
-  /* make sure we fall in the -180 to +180 range */
-  start_angle = (start_angle + 360 + 180) % 360 - 180;
-
-  gdk_draw_arc (gport->drawable, gport->u_gc, 0,
-		Vx (cx) - vrx, Vy (cy) - vry,
-		vrx * 2, vry * 2, (start_angle + 180) * 64, delta_angle * 64);
+  hidgl_draw_arc (gc->width, cx, cy, xradius, yradius,
+                  start_angle, delta_angle, gport->zoom);
 }
 
 void
 ghid_draw_rect (hidGC gc, int x1, int y1, int x2, int y2)
 {
-  gint w, h, lw;
-
-  lw = gc->width;
-  w = gport->width * gport->zoom;
-  h = gport->height * gport->zoom;
-
-  if ((SIDE_X (x1) < gport->view_x0 - lw
-       && SIDE_X (x2) < gport->view_x0 - lw)
-      || (SIDE_X (x1) > gport->view_x0 + w + lw
-	  && SIDE_X (x2) > gport->view_x0 + w + lw)
-      || (SIDE_Y (y1) < gport->view_y0 - lw 
-	  && SIDE_Y (y2) < gport->view_y0 - lw)
-      || (SIDE_Y (y1) > gport->view_y0 + h + lw 
-	  && SIDE_Y (y2) > gport->view_y0 + h + lw))
-    return;
-
-  x1 = Vx (x1);
-  y1 = Vy (y1);
-  x2 = Vx (x2);
-  y2 = Vy (y2);
-
-  if (x1 > x2) { gint xt = x1; x1 = x2; x2 = xt; }
-  if (y1 > y2) { gint yt = y1; y1 = y2; y2 = yt; }
-
   USE_GC (gc);
-  gdk_draw_rectangle (gport->drawable, gport->u_gc, FALSE,
-		      x1, y1, x2 - x1 + 1, y2 - y1 + 1);
+
+  hidgl_draw_rect (x1, y1, x2, y2);
 }
 
 
 void
 ghid_fill_circle (hidGC gc, int cx, int cy, int radius)
 {
-  gint w, h, vr;
-
-  w = gport->width * gport->zoom;
-  h = gport->height * gport->zoom;
-  if (SIDE_X (cx) < gport->view_x0 - radius
-      || SIDE_X (cx) > gport->view_x0 + w + radius
-      || SIDE_Y (cy) < gport->view_y0 - radius 
-      || SIDE_Y (cy) > gport->view_y0 + h + radius)
-    return;
-
   USE_GC (gc);
-  vr = Vz (radius);
-  gdk_draw_arc (gport->drawable, gport->u_gc, TRUE,
-		Vx (cx) - vr, Vy (cy) - vr,
-		vr * 2, vr * 2, 0, 360 * 64);
+
+  hidgl_fill_circle (cx, cy, radius, gport->zoom);
 }
 
+
 void
 ghid_fill_polygon (hidGC gc, int n_coords, int *x, int *y)
 {
-  static GdkPoint *points = 0;
-  static int npoints = 0;
-  int i;
   USE_GC (gc);
 
-  if (npoints < n_coords)
-    {
-      npoints = n_coords + 1;
-      points = MyRealloc (points,
-			  npoints * sizeof (GdkPoint), (char *) __FUNCTION__);
-    }
-  for (i = 0; i < n_coords; i++)
-    {
-      points[i].x = Vx (x[i]);
-      points[i].y = Vy (y[i]);
-    }
-  gdk_draw_polygon (gport->drawable, gport->u_gc, 1, points, n_coords);
+  hidgl_fill_polygon (n_coords, x, y);
 }
 
 void
 ghid_fill_rect (hidGC gc, int x1, int y1, int x2, int y2)
 {
-  gint w, h, lw, xx, yy;
-
-  lw = gc->width;
-  w = gport->width * gport->zoom;
-  h = gport->height * gport->zoom;
-
-  if ((SIDE_X (x1) < gport->view_x0 - lw
-       && SIDE_X (x2) < gport->view_x0 - lw)
-      || (SIDE_X (x1) > gport->view_x0 + w + lw
-          && SIDE_X (x2) > gport->view_x0 + w + lw)
-      || (SIDE_Y (y1) < gport->view_y0 - lw
-          && SIDE_Y (y2) < gport->view_y0 - lw)
-      || (SIDE_Y (y1) > gport->view_y0 + h + lw
-          && SIDE_Y (y2) > gport->view_y0 + h + lw))
-    return;
-
-  x1 = Vx (x1);
-  y1 = Vy (y1);
-  x2 = Vx (x2);
-  y2 = Vy (y2);
-  if (x2 < x1)
-    {
-      xx = x1;
-      x1 = x2;
-      x2 = xx;
-    }
-  if (y2 < y1)
-    {
-      yy = y1;
-      y1 = y2;
-      y2 = yy;
-    }
   USE_GC (gc);
-  gdk_draw_rectangle (gport->drawable, gport->u_gc, TRUE,
-                      x1, y1, x2 - x1 + 1, y2 - y1 + 1);
+
+  hidgl_fill_rect (x1, y1, x2, y2);
 }
 
 void
@@ -1084,8 +977,6 @@ ghid_calibrate (double xval, double yval)
   printf ("ghid_calibrate() -- not implemented\n");
 }
 
-static int ghid_gui_is_up = 0;
-
 void
 ghid_notify_gui_is_up ()
 {
@@ -1527,7 +1418,7 @@ HID ghid_hid = {
   1,				/* gui */
   0,				/* printer */
   0,				/* exporter */
-  0,				/* poly before */
+  1,				/* poly before */
   1,				/* poly after */
   0,				/* poly dicer */
 
@@ -2164,11 +2055,14 @@ Benchmark (int argc, char **argv, int x, int y)
   region.X2 = PCB->MaxWidth;
   region.Y2 = PCB->MaxHeight;
 
+  
+
   gdk_display_sync (display);
   time (&start);
   do
     {
-      hid_expose_callback (&ghid_hid, &region, 0);
+      gdk_window_invalidate_rect (gport->drawing_area->window, NULL, 1);
+      gdk_window_process_updates (gport->drawing_area->window, FALSE);
       gdk_display_sync (display);
       time (&end);
       i++;
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index 1a62dd8..a4632ee 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -293,16 +293,16 @@ have_crosshair_attachments (void)
 #define VCD		8
 
 static void
-draw_right_cross (GdkGC *xor_gc, gint x, gint y)
+draw_right_cross (gint x, gint y)
 {
-  gdk_draw_line (gport->drawing_area->window, xor_gc,
-		 x, 0, x, gport->height);
-  gdk_draw_line (gport->drawing_area->window, xor_gc,
-		 0, y, gport->width, y);
+  glVertex2i (x, 0);
+  glVertex2i (x, gport->height);
+  glVertex2i (0, y);
+  glVertex2i (gport->width, y);
 }
 
 static void
-draw_slanted_cross (GdkGC *xor_gc, gint x, gint y)
+draw_slanted_cross (gint x, gint y)
 {
   gint x0, y0, x1, y1;
 
@@ -314,8 +314,9 @@ draw_slanted_cross (GdkGC *xor_gc, gint x, gint y)
   y0 = MAX(0, MIN (y0, gport->height));
   y1 = y - x;
   y1 = MAX(0, MIN (y1, gport->height));
-  gdk_draw_line (gport->drawing_area->window, xor_gc,
-		 x0, y0, x1, y1);
+  glVertex2i (x0, y0);
+  glVertex2i (x1, y1);
+
   x0 = x - (gport->height - y);
   x0 = MAX(0, MIN (x0, gport->width));
   x1 = x + y;
@@ -324,12 +325,12 @@ draw_slanted_cross (GdkGC *xor_gc, gint x, gint y)
   y0 = MAX(0, MIN (y0, gport->height));
   y1 = y - (gport->width - x);
   y1 = MAX(0, MIN (y1, gport->height));
-  gdk_draw_line (gport->drawing_area->window, xor_gc,
-		 x0, y0, x1, y1);
+  glVertex2i (x0, y0);
+  glVertex2i (x1, y1);
 }
 
 static void
-draw_dozen_cross (GdkGC *xor_gc, gint x, gint y)
+draw_dozen_cross (gint x, gint y)
 {
   gint x0, y0, x1, y1;
   gdouble tan60 = sqrt (3);
@@ -342,8 +343,8 @@ draw_dozen_cross (GdkGC *xor_gc, gint x, gint y)
   y0 = MAX(0, MIN (y0, gport->height));
   y1 = y - x * tan60;
   y1 = MAX(0, MIN (y1, gport->height));
-  gdk_draw_line (gport->drawing_area->window, xor_gc,
-		 x0, y0, x1, y1);
+  glVertex2i (x0, y0);
+  glVertex2i (x1, y1);
 
   x0 = x + (gport->height - y) * tan60;
   x0 = MAX(0, MIN (x0, gport->width));
@@ -353,8 +354,8 @@ draw_dozen_cross (GdkGC *xor_gc, gint x, gint y)
   y0 = MAX(0, MIN (y0, gport->height));
   y1 = y - x / tan60;
   y1 = MAX(0, MIN (y1, gport->height));
-  gdk_draw_line (gport->drawing_area->window, xor_gc,
-		 x0, y0, x1, y1);
+  glVertex2i (x0, y0);
+  glVertex2i (x1, y1);
 
   x0 = x - (gport->height - y) / tan60;
   x0 = MAX(0, MIN (x0, gport->width));
@@ -364,8 +365,8 @@ draw_dozen_cross (GdkGC *xor_gc, gint x, gint y)
   y0 = MAX(0, MIN (y0, gport->height));
   y1 = y - (gport->width - x) * tan60;
   y1 = MAX(0, MIN (y1, gport->height));
-  gdk_draw_line (gport->drawing_area->window, xor_gc,
-		 x0, y0, x1, y1);
+  glVertex2i (x0, y0);
+  glVertex2i (x1, y1);
 
   x0 = x - (gport->height - y) * tan60;
   x0 = MAX(0, MIN (x0, gport->width));
@@ -375,20 +376,20 @@ draw_dozen_cross (GdkGC *xor_gc, gint x, gint y)
   y0 = MAX(0, MIN (y0, gport->height));
   y1 = y - (gport->width - x) / tan60;
   y1 = MAX(0, MIN (y1, gport->height));
-  gdk_draw_line (gport->drawing_area->window, xor_gc,
-		 x0, y0, x1, y1);
+  glVertex2i (x0, y0);
+  glVertex2i (x1, y1);
 }
 
 static void
-draw_crosshair (GdkGC *xor_gc, gint x, gint y)
+draw_crosshair (gint x, gint y)
 {
   static enum crosshair_shape prev = Basic_Crosshair_Shape;
 
-  draw_right_cross (xor_gc, x, y);
+  draw_right_cross (x, y);
   if (prev == Union_Jack_Crosshair_Shape)
-    draw_slanted_cross (xor_gc, x, y);
+    draw_slanted_cross (x, y);
   if (prev == Dozen_Crosshair_Shape)
-    draw_dozen_cross (xor_gc, x, y);
+    draw_dozen_cross (x, y);
   prev = Crosshair.shape;
 }
 
@@ -397,60 +398,106 @@ ghid_show_crosshair (gboolean show)
 {
   gint x, y;
   static gint x_prev = -1, y_prev = -1;
-  static GdkGC *xor_gc;
+  static int done_once = 0;
   static GdkColor cross_color;
 
-  if (gport->x_crosshair < 0 || ghidgui->creating || !gport->has_entered)
+  if (gport->x_crosshair < 0 || ghidgui->creating) {// || !gport->has_entered) {
+    printf ("Returning\n");
     return;
+  }
 
-  if (!xor_gc)
+  if (!done_once)
     {
-      xor_gc = gdk_gc_new (ghid_port.drawing_area->window);
-      gdk_gc_copy (xor_gc, ghid_port.drawing_area->style->white_gc);
-      gdk_gc_set_function (xor_gc, GDK_XOR);
+      done_once = 1;
       /* FIXME: when CrossColor changed from config */
       ghid_map_color_string (Settings.CrossColor, &cross_color);
     }
   x = DRAW_X (gport->x_crosshair);
   y = DRAW_Y (gport->y_crosshair);
 
-  gdk_gc_set_foreground (xor_gc, &cross_color);
+  glEnable (GL_COLOR_LOGIC_OP);
+  glLogicOp (GL_XOR);
+
+  hidgl_flush_triangles (&buffer);
+
+  glColor3f (cross_color.red / 65535.,
+             cross_color.green / 65535.,
+             cross_color.blue / 65535.);
 
+  glBegin (GL_LINES);
+
+#if 1
   if (x_prev >= 0)
     {
-      draw_crosshair (xor_gc, x_prev, y_prev);
-      if (ghidgui->auto_pan_on && have_crosshair_attachments ())
-	{
-	  gdk_draw_rectangle (gport->drawing_area->window, xor_gc, TRUE,
-			      0, y_prev - VCD, VCD, VCW);
-	  gdk_draw_rectangle (gport->drawing_area->window, xor_gc, TRUE,
-			      gport->width - VCD, y_prev - VCD, VCD, VCW);
-	  gdk_draw_rectangle (gport->drawing_area->window, xor_gc, TRUE,
-			      x_prev - VCD, 0, VCW, VCD);
-	  gdk_draw_rectangle (gport->drawing_area->window, xor_gc, TRUE,
-			      x_prev - VCD, gport->height - VCD, VCW, VCD);
-	}
+      draw_crosshair (x_prev, y_prev);
+    }
+#endif
+
+  if (x >= 0 && show)
+    {
+      draw_crosshair (x, y);
+    }
+
+  glEnd ();
+
+  if (ghidgui->auto_pan_on && have_crosshair_attachments ())
+    {
+      glBegin (GL_QUADS);
+
+#if 1
+      if (x_prev >= 0)
+        {
+          glVertex2i (0,                  y_prev - VCD);
+          glVertex2i (0,                  y_prev - VCD + VCW);
+          glVertex2i (VCD,                y_prev - VCD + VCW);
+          glVertex2i (VCD,                y_prev - VCD);
+          glVertex2i (gport->width,       y_prev - VCD);
+          glVertex2i (gport->width,       y_prev - VCD + VCW);
+          glVertex2i (gport->width - VCD, y_prev - VCD + VCW);
+          glVertex2i (gport->width - VCD, y_prev - VCD);
+          glVertex2i (x_prev - VCD,       0);
+          glVertex2i (x_prev - VCD,       VCD);
+          glVertex2i (x_prev - VCD + VCW, VCD);
+          glVertex2i (x_prev - VCD + VCW, 0);
+          glVertex2i (x_prev - VCD,       gport->height - VCD);
+          glVertex2i (x_prev - VCD,       gport->height);
+          glVertex2i (x_prev - VCD + VCW, gport->height);
+          glVertex2i (x_prev - VCD + VCW, gport->height - VCD);
+        }
+#endif
+
+      if (x >= 0 && show)
+        {
+          glVertex2i (0,                  y - VCD);
+          glVertex2i (0,                  y - VCD + VCW);
+          glVertex2i (VCD,                y - VCD + VCW);
+          glVertex2i (VCD,                y - VCD);
+          glVertex2i (gport->width,       y - VCD);
+          glVertex2i (gport->width,       y - VCD + VCW);
+          glVertex2i (gport->width - VCD, y - VCD + VCW);
+          glVertex2i (gport->width - VCD, y - VCD);
+          glVertex2i (x - VCD,            0);
+          glVertex2i (x - VCD,            VCD);
+          glVertex2i (x - VCD + VCW,      VCD);
+          glVertex2i (x - VCD + VCW,      0);
+          glVertex2i (x - VCD,            gport->height - VCD);
+          glVertex2i (x - VCD,            gport->height);
+          glVertex2i (x - VCD + VCW,      gport->height);
+          glVertex2i (x - VCD + VCW,      gport->height - VCD);
+        }
+
+      glEnd ();
     }
 
   if (x >= 0 && show)
     {
-      draw_crosshair (xor_gc, x, y);
-      if (ghidgui->auto_pan_on && have_crosshair_attachments ())
-	{
-	  gdk_draw_rectangle (gport->drawing_area->window, xor_gc, TRUE,
-			      0, y - VCD, VCD, VCW);
-	  gdk_draw_rectangle (gport->drawing_area->window, xor_gc, TRUE,
-			      gport->width - VCD, y - VCD, VCD, VCW);
-	  gdk_draw_rectangle (gport->drawing_area->window, xor_gc, TRUE,
-			      x - VCD, 0, VCW, VCD);
-	  gdk_draw_rectangle (gport->drawing_area->window, xor_gc, TRUE,
-			      x - VCD, gport->height - VCD, VCW, VCD);
-	}
       x_prev = x;
       y_prev = y;
     }
   else
     x_prev = y_prev = -1;
+
+  glDisable (GL_COLOR_LOGIC_OP);
 }
 
 static gboolean
@@ -822,53 +869,235 @@ ghid_port_drawing_area_configure_event_cb (GtkWidget * widget,
   if (!first_time_done)
     {
       gport->colormap = gtk_widget_get_colormap (gport->top_window);
-      gport->bg_gc = gdk_gc_new (gport->drawable);
       if (gdk_color_parse (Settings.BackgroundColor, &gport->bg_color))
 	gdk_color_alloc (gport->colormap, &gport->bg_color);
       else
 	gdk_color_white (gport->colormap, &gport->bg_color);
-      gdk_gc_set_foreground (gport->bg_gc, &gport->bg_color);
 
-      gport->offlimits_gc = gdk_gc_new (gport->drawable);
       if (gdk_color_parse (Settings.OffLimitColor, &gport->offlimits_color))
 	gdk_color_alloc (gport->colormap, &gport->offlimits_color);
       else
 	gdk_color_white (gport->colormap, &gport->offlimits_color);
-      gdk_gc_set_foreground (gport->offlimits_gc, &gport->offlimits_color);
       first_time_done = TRUE;
       PCBChanged (0, NULL, 0, 0);
     }
-  if (gport->mask)
-    {
-      gdk_pixmap_unref (gport->mask);
-      gport->mask = gdk_pixmap_new (0, gport->width, gport->height, 1);
-    }
+//  if (gport->mask)
+//    {
+//      gdk_pixmap_unref (gport->mask);
+//      gport->mask = gdk_pixmap_new (0, gport->width, gport->height, 1);
+//    }
   ghid_port_ranges_scale (FALSE);
   ghid_invalidate_all ();
   RestoreCrosshair (TRUE);
   return 0;
 }
 
+static inline int
+Px (int x)
+{
+  int rv = x * gport->zoom + gport->view_x0;
+  if (ghid_flip_x)
+    rv = PCB->MaxWidth - (x * gport->zoom + gport->view_x0);
+  return  rv;
+}
+
+static inline int
+Py (int y)
+{
+  int rv = y * gport->zoom + gport->view_y0;
+  if (ghid_flip_y)
+    rv = PCB->MaxHeight - (y * gport->zoom + gport->view_y0);
+  return  rv;
+}
+
+static inline int
+Vx (int x)
+{
+  int rv;
+  if (ghid_flip_x) 
+    rv = (PCB->MaxWidth - x - gport->view_x0) / gport->zoom + 0.5;
+  else
+    rv = (x - gport->view_x0) / gport->zoom + 0.5;
+  return rv;
+}
+
+static inline int
+Vy (int y)
+{
+  int rv;
+  if (ghid_flip_y)
+    rv = (PCB->MaxHeight - y - gport->view_y0) / gport->zoom + 0.5;
+  else
+    rv = (y - gport->view_y0) / gport->zoom + 0.5;
+  return rv;
+}
 
 void
 ghid_screen_update (void)
 {
-
+#if 0
   ghid_show_crosshair (FALSE);
   gdk_draw_drawable (gport->drawing_area->window, gport->bg_gc, gport->pixmap,
 		     0, 0, 0, 0, gport->width, gport->height);
   ghid_show_crosshair (TRUE);
+#endif
 }
 
+void DrawAttached (Boolean);
+void draw_grid ();
+
+#define Z_NEAR 3.0
 gboolean
 ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
 					GdkEventExpose * ev, GHidPort * port)
 {
+  BoxType region;
+  int eleft, eright, etop, ebottom;
+  extern HID ghid_hid;
+  GdkGLContext* pGlContext = gtk_widget_get_gl_context (widget);
+  GdkGLDrawable* pGlDrawable = gtk_widget_get_gl_drawable (widget);
+
+  /* make GL-context "current" */
+  if (!gdk_gl_drawable_gl_begin (pGlDrawable, pGlContext)) {
+    return FALSE;
+  }
+
   ghid_show_crosshair (FALSE);
-  gdk_draw_drawable (widget->window, port->bg_gc, port->pixmap,
-		     ev->area.x, ev->area.y, ev->area.x, ev->area.y,
-		     ev->area.width, ev->area.height);
+
+  glEnable (GL_BLEND);
+  glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+
+//  glEnable(GL_POLYGON_SMOOTH);
+//  glHint(GL_POLYGON_SMOOTH_HINT, [GL_FASTEST, GL_NICEST, or GL_DONT_CARE]);
+
+  glViewport (ev->area.x,
+              widget->allocation.height - ev->area.height - ev->area.y,
+              ev->area.width, ev->area.height);
+
+  glEnable (GL_SCISSOR_TEST);
+  glScissor (ev->area.x,
+             widget->allocation.height - ev->area.height - ev->area.y,
+             ev->area.width, ev->area.height);
+
+  glMatrixMode (GL_PROJECTION);
+  glLoadIdentity ();
+  glOrtho (ev->area.x, ev->area.x + ev->area.width, ev->area.y + ev->area.height, ev->area.y, 0, 100);
+  glMatrixMode (GL_MODELVIEW);
+  glLoadIdentity ();
+  glTranslatef (0.0f, 0.0f, -Z_NEAR);
+
+  glClearColor (gport->bg_color.red / 65535.,
+                gport->bg_color.green / 65535.,
+                gport->bg_color.blue / 65535.,
+                1.);
+
+  glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
+
+  region.X1 = MIN (Px (ev->area.x), Px (ev->area.x + ev->area.width + 1));
+  region.X2 = MAX (Px (ev->area.x), Px (ev->area.x + ev->area.width + 1));
+  region.Y1 = MIN (Py (ev->area.y), Py (ev->area.y + ev->area.height + 1));
+  region.Y2 = MAX (Py (ev->area.y), Py (ev->area.y + ev->area.height + 1));
+
+  eleft = Vx (0);
+  eright = Vx (PCB->MaxWidth);
+  etop = Vy (0);
+  ebottom = Vy (PCB->MaxHeight);
+  if (eleft > eright)
+    {
+      int tmp = eleft;
+      eleft = eright;
+      eright = tmp;
+    }
+  if (etop > ebottom)
+    {
+      int tmp = etop;
+      etop = ebottom;
+      ebottom = tmp;
+    }
+
+  glColor3f (gport->offlimits_color.red / 65535.,
+             gport->offlimits_color.green / 65535.,
+             gport->offlimits_color.blue / 65535.);
+
+  glBegin (GL_QUADS);
+  if (eleft > 0)
+    {
+      glVertex2i (0, 0);
+      glVertex2i (eleft, 0);
+      glVertex2i (eleft, gport->height);
+      glVertex2i (0, gport->height);
+    }
+  else
+    eleft = 0;
+  if (eright < gport->width)
+    {
+      glVertex2i (eright, 0);
+      glVertex2i (gport->width, 0);
+      glVertex2i (gport->width, gport->height);
+      glVertex2i (eright, gport->height);
+    }
+  else
+    eright = gport->width;
+  if (etop > 0)
+    {
+      glVertex2i (eleft, 0);
+      glVertex2i (eright, 0);
+      glVertex2i (eright, etop);
+      glVertex2i (eleft, etop);
+    }
+  if (ebottom < gport->height)
+    {
+      glVertex2i (eleft, ebottom);
+      glVertex2i (eright + 1, ebottom);
+      glVertex2i (eright + 1, gport->height);
+      glVertex2i (eleft, gport->height);
+    }
+  glEnd ();
+
+  /* TODO: Background image */
+
+  hidgl_init_triangle_array (&buffer);
+  ghid_invalidate_current_gc ();
+
+  glPushMatrix ();
+  glScalef ((ghid_flip_x ? -1. : 1.) / gport->zoom,
+            (ghid_flip_y ? -1. : 1.) / gport->zoom, 1);
+  glTranslatef (ghid_flip_x ? gport->view_x0 - PCB->MaxWidth  :
+                             -gport->view_x0,
+                ghid_flip_y ? gport->view_y0 - PCB->MaxHeight :
+                             -gport->view_y0, 0);
+  hid_expose_callback (&ghid_hid, &region, 0);
+  hidgl_flush_triangles (&buffer);
+  glPopMatrix ();
+
+  draw_grid ();
+
+  hidgl_init_triangle_array (&buffer);
+  ghid_invalidate_current_gc ();
+  glPushMatrix ();
+  glScalef ((ghid_flip_x ? -1. : 1.) / gport->zoom,
+            (ghid_flip_y ? -1. : 1.) / gport->zoom, 1);
+  glTranslatef (ghid_flip_x ? gport->view_x0 - PCB->MaxWidth  :
+                             -gport->view_x0,
+                ghid_flip_y ? gport->view_y0 - PCB->MaxHeight :
+                             -gport->view_y0, 0);
+  DrawAttached (TRUE);
+  DrawMark (TRUE);
+  hidgl_flush_triangles (&buffer);
+  glPopMatrix ();
+
   ghid_show_crosshair (TRUE);
+
+  hidgl_flush_triangles (&buffer);
+
+  if (gdk_gl_drawable_is_double_buffered (pGlDrawable))
+    gdk_gl_drawable_swap_buffers (pGlDrawable);
+  else
+    glFlush ();
+
+  /* end drawing to current GL-context */
+  gdk_gl_drawable_gl_end (pGlDrawable);
+
   return FALSE;
 }
 
@@ -881,6 +1110,14 @@ ghid_port_window_motion_cb (GtkWidget * widget,
   static gint x_prev = -1, y_prev = -1;
   gboolean moved;
   GdkModifierType state;
+  GdkGLContext* pGlContext = gtk_widget_get_gl_context (widget);
+  GdkGLDrawable* pGlDrawable = gtk_widget_get_gl_drawable (widget);
+
+  /* make GL-context "current" */
+  if (!gdk_gl_drawable_gl_begin (pGlDrawable, pGlContext)) {
+    printf ("GL THingy returned\n");
+    return FALSE;
+  }
 
   state = (GdkModifierType) (ev->state);
   mk = ghid_modifier_keys_state (&state);
@@ -900,9 +1137,18 @@ ghid_port_window_motion_cb (GtkWidget * widget,
     }
   x_prev = y_prev = -1;
   moved = ghid_note_event_location (ev);
+
   ghid_show_crosshair (TRUE);
   if (moved && have_crosshair_attachments ())
     ghid_draw_area_update (gport, NULL);
+
+  if (gdk_gl_drawable_is_double_buffered (pGlDrawable))
+    gdk_gl_drawable_swap_buffers (pGlDrawable);
+  else
+    glFlush ();
+
+  /* end drawing to current GL-context */
+  gdk_gl_drawable_gl_end (pGlDrawable);
   return FALSE;
 }
 
@@ -942,7 +1188,7 @@ ghid_port_window_enter_cb (GtkWidget * widget,
       RestoreCrosshair (TRUE);
       cursor_in_viewport = TRUE;
     }
-	  
+
   return FALSE;
 }
 
diff --git a/src/hid/gtk/gui-pinout-preview.c b/src/hid/gtk/gui-pinout-preview.c
index 212d37a..f59f22b 100644
--- a/src/hid/gtk/gui-pinout-preview.c
+++ b/src/hid/gtk/gui-pinout-preview.c
@@ -150,12 +150,15 @@ pinout_set_data (GhidPinoutPreview * pinout, ElementType * element)
 }
 
 
+#define Z_NEAR 3.0
+
 static gboolean
-ghid_pinout_preview_expose (GtkWidget * widget, GdkEventExpose * event)
+ghid_pinout_preview_expose (GtkWidget * widget, GdkEventExpose * ev)
 {
   extern HID ghid_hid;
+  GdkGLContext* pGlContext = gtk_widget_get_gl_context (widget);
+  GdkGLDrawable* pGlDrawable = gtk_widget_get_gl_drawable (widget);
   GhidPinoutPreview *pinout = GHID_PINOUT_PREVIEW (widget);
-  GdkDrawable *save_drawable;
   double save_zoom;
   int da_w, da_h;
   int save_left, save_top;
@@ -171,9 +174,7 @@ ghid_pinout_preview_expose (GtkWidget * widget, GdkEventExpose * event)
   save_view_width = gport->view_width;
   save_view_height = gport->view_height;
 
-  /* Setup drawable and zoom factor for drawing routines
-   */
-  save_drawable = gport->drawable;
+  /* Setup zoom factor for drawing routines */
 
   gdk_window_get_geometry (widget->window, 0, 0, &da_w, &da_h, 0);
   xz = (double) pinout->x_max / da_w;
@@ -183,7 +184,6 @@ ghid_pinout_preview_expose (GtkWidget * widget, GdkEventExpose * event)
   else
     gport->zoom = yz;
 
-  gport->drawable = widget->window;
   gport->width = da_w;
   gport->height = da_h;
   gport->view_width = da_w * gport->zoom;
@@ -191,13 +191,59 @@ ghid_pinout_preview_expose (GtkWidget * widget, GdkEventExpose * event)
   gport->view_x0 = (pinout->x_max - gport->view_width) / 2;
   gport->view_y0 = (pinout->y_max - gport->view_height) / 2;
 
-  /* clear background */
-  gdk_draw_rectangle (widget->window, gport->bg_gc, TRUE, 0, 0, da_w, da_h);
+  /* make GL-context "current" */
+  if (!gdk_gl_drawable_gl_begin (pGlDrawable, pGlContext)) {
+    return FALSE;
+  }
+
+  glEnable (GL_BLEND);
+  glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+
+  glViewport (ev->area.x,
+              widget->allocation.height - ev->area.height - ev->area.y,
+              ev->area.width, ev->area.height);
+
+  glEnable (GL_SCISSOR_TEST);
+  glScissor (ev->area.x,
+             widget->allocation.height - ev->area.height - ev->area.y,
+             ev->area.width, ev->area.height);
+
+  glMatrixMode (GL_PROJECTION);
+  glLoadIdentity ();
+  glOrtho (ev->area.x, ev->area.x + ev->area.width, ev->area.y + ev->area.height, ev->area.y, 0, 100);
+  glMatrixMode (GL_MODELVIEW);
+  glLoadIdentity ();
+  glTranslatef (0.0f, 0.0f, -Z_NEAR);
+
+  glClearColor (gport->bg_color.red / 65535.,
+                gport->bg_color.green / 65535.,
+                gport->bg_color.blue / 65535.,
+                1.);
+
+  glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
 
   /* call the drawing routine */
+  hidgl_init_triangle_array (&buffer);
+  ghid_invalidate_current_gc ();
+  glPushMatrix ();
+  glScalef ((ghid_flip_x ? -1. : 1.) / gport->zoom,
+            (ghid_flip_y ? -1. : 1.) / gport->zoom, 1);
+  glTranslatef (ghid_flip_x ? gport->view_x0 - PCB->MaxWidth  :
+                             -gport->view_x0,
+                ghid_flip_y ? gport->view_y0 - PCB->MaxHeight :
+                             -gport->view_y0, 0);
   hid_expose_callback (&ghid_hid, NULL, &pinout->element);
+  hidgl_flush_triangles (&buffer);
+  glPopMatrix ();
+
+  if (gdk_gl_drawable_is_double_buffered (pGlDrawable))
+    gdk_gl_drawable_swap_buffers (pGlDrawable);
+  else
+    glFlush ();
+
+  /* end drawing to current GL-context */
+  gdk_gl_drawable_gl_end (pGlDrawable);
 
-  gport->drawable = save_drawable;
   gport->zoom = save_zoom;
   gport->width = save_width;
   gport->height = save_height;
@@ -219,6 +265,40 @@ enum
 static GObjectClass *ghid_pinout_preview_parent_class = NULL;
 
 
+/*! \brief GObject constructor
+ *
+ *  \par Function Description
+ *  Chain up and construct the object, then setup the
+ *  necessary state for our widget now it is constructed.
+ *
+ *  \param [in] type                    The GType of object to be constructed
+ *  \param [in] n_construct_properties  Number of construct properties
+ *  \param [in] contruct_params         The construct properties
+ *
+ *  \returns The GObject having just been constructed.
+ */
+static GObject *
+ghid_pinout_preview_constructor (GType type,
+                                 guint n_construct_properties,
+                                 GObjectConstructParam *construct_properties)
+{
+  GObject *object;
+
+  /* chain up to constructor of parent class */
+  object = G_OBJECT_CLASS (ghid_pinout_preview_parent_class)->
+    constructor (type, n_construct_properties, construct_properties);
+
+  gtk_widget_set_gl_capability (GTK_WIDGET (object),
+                                gport->glconfig,
+                                NULL,
+                                TRUE,
+                                GDK_GL_RGBA_TYPE);
+
+  return object;
+}
+
+
+
 /*! \brief GObject finalise handler
  *
  *  \par Function Description
@@ -310,6 +390,7 @@ ghid_pinout_preview_class_init (GhidPinoutPreviewClass * klass)
   GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
   GtkWidgetClass *gtk_widget_class = GTK_WIDGET_CLASS (klass);
 
+  gobject_class->constructor = ghid_pinout_preview_constructor;
   gobject_class->finalize = ghid_pinout_preview_finalize;
   gobject_class->set_property = ghid_pinout_preview_set_property;
   gobject_class->get_property = ghid_pinout_preview_get_property;
diff --git a/src/hid/gtk/gui-top-window.c b/src/hid/gtk/gui-top-window.c
index 3812e68..ff9276f 100644
--- a/src/hid/gtk/gui-top-window.c
+++ b/src/hid/gtk/gui-top-window.c
@@ -2295,6 +2295,11 @@ ghid_build_pcb_top_window (void)
   gtk_box_pack_start (GTK_BOX (hbox), viewport, TRUE, TRUE, 0);
 
   gport->drawing_area = gtk_drawing_area_new ();
+  gtk_widget_set_gl_capability (gport->drawing_area,
+                                gport->glconfig,
+                                NULL,
+                                TRUE,
+                                GDK_GL_RGBA_TYPE);
 
   gtk_widget_add_events (gport->drawing_area, GDK_EXPOSURE_MASK
 			 | GDK_LEAVE_NOTIFY_MASK | GDK_ENTER_NOTIFY_MASK
@@ -2657,11 +2662,22 @@ ghid_parse_arguments (int *argc, char ***argv)
   gtk_disable_setlocale ();
 
   gtk_init (argc, argv);
+  gtk_gl_init(argc, argv);
 
   gport = &ghid_port;
   gport->zoom = 300.0;
   pixel_slop = 300;
 
+  /* setup GL-context */
+  gport->glconfig = gdk_gl_config_new_by_mode (GDK_GL_MODE_RGBA    |
+                                               GDK_GL_MODE_STENCIL |
+//                                               GDK_GL_MODE_DEPTH   |
+                                               GDK_GL_MODE_DOUBLE);
+  if (!gport->glconfig) {
+    printf("Could not setup GL-context!\n");
+    return; /* Should we abort? */
+  }
+
   ghid_config_files_read (argc, argv);
 
   Settings.AutoPlace = 0;
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index 0b4eb21..4c0dca3 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -36,6 +36,18 @@
 
 #include <gtk/gtk.h>
 
+/* The Linux OpenGL ABI 1.0 spec requires that we define
+ * GL_GLEXT_PROTOTYPES before including gl.h or glx.h for extensions
+ * in order to get prototypes:
+ *   http://www.opengl.org/registry/ABI/
+ */
+#ifdef ENABLE_GL
+#  define GL_GLEXT_PROTOTYPES 1
+#  include <GL/gl.h>
+#  include <gtk/gtkgl.h>
+#  include "hid/common/hidgl.h"
+#endif
+
 /* Internationalization support.
 */
 #if defined (ENABLE_NLS)
@@ -131,7 +143,7 @@ typedef struct hid_gc_struct
   gint cap, join;
   gchar xor;
   gchar erase;
-  gint mask_seq;
+//  gint mask_seq;
 }
 hid_gc_struct;
 
@@ -198,7 +210,11 @@ typedef struct
   GdkDrawable *drawable;	/* Current drawable for drawing routines */
   gint width, height;
 
-  GdkGC *bg_gc, *offlimits_gc, *mask_gc, *u_gc, *grid_gc;
+  GdkGLConfig *glconfig;
+
+  gint trans_lines;
+
+//  GdkGC *bg_gc, *offlimits_gc, *mask_gc, *u_gc, *grid_gc;
 
   GdkColor bg_color, offlimits_color, grid_color;
 
@@ -314,6 +330,7 @@ void ghid_get_pointer (gint *, gint *);
 
 /* gui-output-events.c function prototypes.
 */
+
 void ghid_port_ranges_changed (void);
 void ghid_port_ranges_zoom (gdouble zoom);
 gboolean ghid_port_ranges_pan (gdouble x, gdouble y, gboolean relative);
@@ -511,7 +528,9 @@ void ghid_logv (const char *fmt, va_list args);
 void ghid_pinout_window_show (GHidPort * out, ElementTypePtr Element);
 
 /* gtkhid-main.c */
+
 void ghid_invalidate_all ();
+void ghid_invalidate_current_gc ();
 void ghid_get_coords (const char *msg, int *x, int *y);
 gint PCBChanged (int argc, char **argv, int x, int y);

Bottom: ce1995e36befa71914979c91e70f3d9b8b250202
Top:    d673b1cd3f5f387bf72f9e6b5b5cda2ee4cc9bff
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-08-28 15:37:55 +0100

Chaos


---

diff --git a/src/crosshair.c b/src/crosshair.c
index d927cf8..d26c3cf 100644
--- a/src/crosshair.c
+++ b/src/crosshair.c
@@ -80,7 +80,7 @@ thindraw_moved_pv (PinType *pv, Coord x, Coord y)
   moved_pv.X += x;
   moved_pv.Y += y;
 
-  gui->thindraw_pcb_pv (Crosshair.GC, Crosshair.GC, &moved_pv, true, false);
+//  gui->thindraw_pcb_pv (Crosshair.GC, Crosshair.GC, &moved_pv, true, false);
 }
 
 /* ---------------------------------------------------------------------------
@@ -256,7 +256,7 @@ XORDrawElement (ElementTypePtr Element, Coord DX, Coord DY)
         moved_pad.Point1.X += DX; moved_pad.Point1.Y += DY;
         moved_pad.Point2.X += DX; moved_pad.Point2.Y += DY;
 
-        gui->thindraw_pcb_pad (Crosshair.GC, &moved_pad, false, false);
+//        gui->thindraw_pcb_pad (Crosshair.GC, &moved_pad, false, false);
       }
   }
   END_LOOP;
@@ -555,14 +555,14 @@ DrawAttached (void)
         via.Mask = 0;
         via.Flags = NoFlags ();
 
-        gui->thindraw_pcb_pv (Crosshair.GC, Crosshair.GC, &via, true, false);
+//        gui->thindraw_pcb_pv (Crosshair.GC, Crosshair.GC, &via, true, false);
 
         if (TEST_FLAG (SHOWDRCFLAG, PCB))
           {
             /* XXX: Naughty cheat - use the mask to draw DRC clearance! */
             via.Mask = Settings.ViaThickness + PCB->Bloat * 2;
             gui->set_color (Crosshair.GC, Settings.CrossColor);
-            gui->thindraw_pcb_pv (Crosshair.GC, Crosshair.GC, &via, false, true);
+//            gui->thindraw_pcb_pv (Crosshair.GC, Crosshair.GC, &via, false, true);
             gui->set_color (Crosshair.GC, Settings.CrosshairColor);
           }
         break;
diff --git a/src/draw.c b/src/draw.c
index 5dd4091..bad5901 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -82,10 +82,7 @@ static bool doing_assy = false;
 /* ---------------------------------------------------------------------------
  * some local prototypes
  */
-static void DrawEverything (const BoxType *);
-static void AddPart (void *);
-static void DrawEMark (ElementTypePtr, Coord, Coord, bool);
-static void DrawRats (const BoxType *);
+static void DrawEverything (BoxTypePtr);
 
 
 /*---------------------------------------------------------------------------
@@ -125,160 +122,6 @@ Redraw (void)
   gui->invalidate_all ();
 }
 
-static void
-set_pv_color (PinType *pv, int type)
-{
-  if (TEST_FLAG (WARNFLAG, pv))          gui->set_color (Output.fgGC, PCB->WarnColor);
-  else if (TEST_FLAG (SELECTEDFLAG, pv)) gui->set_color (Output.fgGC, (type == VIA_TYPE) ? PCB->ViaSelectedColor
-                                                                                         : PCB->PinSelectedColor);
-  else if (TEST_FLAG (FOUNDFLAG, pv))    gui->set_color (Output.fgGC, PCB->ConnectedColor);
-  else                                   gui->set_color (Output.fgGC, (type == VIA_TYPE) ? PCB->ViaColor
-                                                                                         : PCB->PinColor);
-}
-
-static int
-pad_callback (const BoxType * b, void *cl)
-{
-  PadTypePtr pad = (PadTypePtr) b;
-  int *side = cl;
-
-  if (ON_SIDE (pad, *side))
-    {
-      if (TEST_FLAG (WARNFLAG, pad))          gui->set_color (Output.fgGC, PCB->WarnColor);
-      else if (TEST_FLAG (SELECTEDFLAG, pad)) gui->set_color (Output.fgGC, PCB->PinSelectedColor);
-      else if (TEST_FLAG (FOUNDFLAG, pad))    gui->set_color (Output.fgGC, PCB->ConnectedColor);
-      else if (FRONT (pad))                   gui->set_color (Output.fgGC, PCB->PinColor);
-      else                                    gui->set_color (Output.fgGC, PCB->InvisibleObjectsColor);
-
-      dapi->draw_pad (pad, NULL, NULL);
-    }
-  return 1;
-}
-
-static void
-draw_element_name (ElementType *element)
-{
-  if ((TEST_FLAG (HIDENAMESFLAG, PCB) && gui->gui) ||
-      TEST_FLAG (HIDENAMEFLAG, element))
-    return;
-  if (doing_pinout || doing_assy)
-    gui->set_color (Output.fgGC, PCB->ElementColor);
-  else if (TEST_FLAG (SELECTEDFLAG, &ELEMENT_TEXT (PCB, element)))
-    gui->set_color (Output.fgGC, PCB->ElementSelectedColor);
-  else if (FRONT (element))
-    gui->set_color (Output.fgGC, PCB->ElementColor);
-  else
-    gui->set_color (Output.fgGC, PCB->InvisibleObjectsColor);
-  DrawTextLowLevel (&ELEMENT_TEXT (PCB, element), PCB->minSlk);
-}
-
-static int
-name_callback (const BoxType * b, void *cl)
-{
-  TextTypePtr text = (TextTypePtr) b;
-  ElementTypePtr element = (ElementTypePtr) text->Element;
-  int *side = cl;
-
-  if (TEST_FLAG (HIDENAMEFLAG, element))
-    return 0;
-
-  if (ON_SIDE (element, *side))
-    draw_element_name (element);
-  return 0;
-}
-
-static void
-draw_element_pins_and_pads (ElementType *element)
-{
-  PAD_LOOP (element);
-  {
-    if (doing_pinout || doing_assy || FRONT (pad) || PCB->InvisibleObjectsOn)
-      {
-        if (TEST_FLAG (WARNFLAG, pad))          gui->set_color (Output.fgGC, PCB->WarnColor);
-        else if (TEST_FLAG (SELECTEDFLAG, pad)) gui->set_color (Output.fgGC, PCB->PinSelectedColor);
-        else if (TEST_FLAG (FOUNDFLAG, pad))    gui->set_color (Output.fgGC, PCB->ConnectedColor);
-        else if (FRONT (pad))                   gui->set_color (Output.fgGC, PCB->PinColor);
-        else                                    gui->set_color (Output.fgGC, PCB->InvisibleObjectsColor);
-
-        dapi->draw_pad (pad, NULL, NULL);
-      }
-  }
-  END_LOOP;
-  PIN_LOOP (element);
-  {
-    set_pv_color (pin, PIN_TYPE);
-    dapi->draw_pin (pin, NULL, NULL);
-
-    if (TEST_FLAG (WARNFLAG, pin))          gui->set_color (Output.fgGC, PCB->WarnColor);
-    else if (TEST_FLAG (SELECTEDFLAG, pin)) gui->set_color (Output.fgGC, PCB->PinSelectedColor);
-    else                                    gui->set_color (Output.fgGC, Settings.BlackColor);
-
-    dapi->draw_pin_hole (pin, NULL, NULL);
-  }
-  END_LOOP;
-}
-
-static int
-EMark_callback (const BoxType * b, void *cl)
-{
-  ElementTypePtr element = (ElementTypePtr) b;
-
-  DrawEMark (element, element->MarkX, element->MarkY, !FRONT (element));
-  return 1;
-}
-
-static int
-rat_callback (const BoxType * b, void *cl)
-{
-  RatType *rat = (RatType *)b;
-
-  if (TEST_FLAG (SELECTEDFLAG, rat))   gui->set_color (Output.fgGC, PCB->RatSelectedColor);
-  else if (TEST_FLAG (FOUNDFLAG, rat)) gui->set_color (Output.fgGC, PCB->ConnectedColor);
-  else                                 gui->set_color (Output.fgGC, PCB->RatColor);
-
-  dapi->draw_rat (rat, NULL, NULL);
-  return 1;
-}
-
-static void
-draw_element_package (ElementType *element)
-{
-  /* set color and draw lines, arcs, text and pins */
-  if (doing_pinout || doing_assy)
-    gui->set_color (Output.fgGC, PCB->ElementColor);
-  else if (TEST_FLAG (SELECTEDFLAG, element))
-    gui->set_color (Output.fgGC, PCB->ElementSelectedColor);
-  else if (FRONT (element))
-    gui->set_color (Output.fgGC, PCB->ElementColor);
-  else
-    gui->set_color (Output.fgGC, PCB->InvisibleObjectsColor);
-
-  /* draw lines, arcs, text and pins */
-  ELEMENTLINE_LOOP (element);
-  {
-    //_draw_line (line);
-    dapi->draw_line (line, NULL, NULL);
-  }
-  END_LOOP;
-  ARC_LOOP (element);
-  {
-    //_draw_arc (arc);
-    dapi->draw_arc (arc, NULL, NULL);
-  }
-  END_LOOP;
-}
-
-static int
-element_callback (const BoxType * b, void *cl)
-{
-  ElementTypePtr element = (ElementTypePtr) b;
-  int *side = cl;
-
-  if (ON_SIDE (element, *side))
-    draw_element_package (element);
-  return 1;
-}
-
 /* ---------------------------------------------------------------------------
  * prints assembly drawing.
  */
@@ -286,6 +129,7 @@ element_callback (const BoxType * b, void *cl)
 void
 PrintAssembly (int side, const BoxType * drawn_area)
 {
+#if 0
   int side_group = GetLayerGroupNumberByNumber (max_copper_layer + side);
 
   doing_assy = true;
@@ -296,6 +140,7 @@ PrintAssembly (int side, const BoxType * drawn_area)
   /* draw package */
   DrawSilk (side, drawn_area);
   doing_assy = false;
+#endif
 }
 
 /* ---------------------------------------------------------------------------
@@ -304,6 +149,7 @@ PrintAssembly (int side, const BoxType * drawn_area)
 static void
 DrawEverything (const BoxType *drawn_area)
 {
+#if 0
   int i, ngroups, side;
   int component, solder;
   /* This is the list of layer groups we will draw.  */
@@ -453,224 +299,7 @@ DrawEverything (const BoxType *drawn_area)
       PrintFab (Output.fgGC);
       gui->end_layer ();
     }
-}
-
-static void
-DrawEMark (ElementTypePtr e, Coord X, Coord Y, bool invisible)
-{
-  Coord mark_size = EMARK_SIZE;
-  if (!PCB->InvisibleObjectsOn && invisible)
-    return;
-
-  if (e->Pin != NULL)
-    {
-      PinType *pin0 = e->Pin->data;
-      if (TEST_FLAG (HOLEFLAG, pin0))
-	mark_size = MIN (mark_size, pin0->DrillingHole / 2);
-      else
-	mark_size = MIN (mark_size, pin0->Thickness / 2);
-    }
-
-  if (e->Pad != NULL)
-    {
-      PadType *pad0 = e->Pad->data;
-      mark_size = MIN (mark_size, pad0->Thickness / 2);
-    }
-
-  gui->set_color (Output.fgGC,
-		  invisible ? PCB->InvisibleMarkColor : PCB->ElementColor);
-  gui->set_line_cap (Output.fgGC, Trace_Cap);
-  gui->set_line_width (Output.fgGC, 0);
-  gui->draw_line (Output.fgGC, X - mark_size, Y, X, Y - mark_size);
-  gui->draw_line (Output.fgGC, X + mark_size, Y, X, Y - mark_size);
-  gui->draw_line (Output.fgGC, X - mark_size, Y, X, Y + mark_size);
-  gui->draw_line (Output.fgGC, X + mark_size, Y, X, Y + mark_size);
-
-  /*
-   * If an element is locked, place a "L" on top of the "diamond".
-   * This provides a nice visual indication that it is locked that
-   * works even for color blind users.
-   */
-  if (TEST_FLAG (LOCKFLAG, e) )
-    {
-      gui->draw_line (Output.fgGC, X, Y, X + 2 * mark_size, Y);
-      gui->draw_line (Output.fgGC, X, Y, X, Y - 4* mark_size);
-    }
-}
-
-static int
-pin_mask_callback (const BoxType * b, void *cl)
-{
-  dapi->draw_pin_mask ((PinType *) b, NULL, NULL);
-  return 1;
-}
-
-static int
-via_mask_callback (const BoxType * b, void *cl)
-{
-  dapi->draw_via_mask ((PinType *) b, NULL, NULL);
-  return 1;
-}
-
-static int
-pad_mask_callback (const BoxType * b, void *cl)
-{
-  PadTypePtr pad = (PadTypePtr) b;
-  int *side = cl;
-  if (ON_SIDE (pad, *side))
-    dapi->draw_pad_mask (pad, NULL, NULL);
-  return 1;
-}
-
-/* ---------------------------------------------------------------------------
- * Draws silk layer.
- */
-
-void
-DrawSilk (int side, const BoxType * drawn_area)
-{
-#if 0
-  /* This code is used when you want to mask silk to avoid exposed
-     pins and pads.  We decided it was a bad idea to do this
-     unconditionally, but the code remains.  */
-#endif
-
-#if 0
-  if (gui->poly_before)
-    {
-      gui->use_mask (HID_MASK_BEFORE);
 #endif
-      dapi->draw_layer (LAYER_PTR (max_copper_layer + side), drawn_area, NULL);
-      /* draw package */
-      r_search (PCB->Data->element_tree, drawn_area, NULL, element_callback, &side);
-      r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], drawn_area, NULL, name_callback, &side);
-#if 0
-    }
-
-  gui->use_mask (HID_MASK_CLEAR);
-  r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_mask_callback, NULL);
-  r_search (PCB->Data->via_tree, drawn_area, NULL, via_mask_callback, NULL);
-  r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_mask_callback, &side);
-
-  if (gui->poly_after)
-    {
-      gui->use_mask (HID_MASK_AFTER);
-      dapi->draw_layer (LAYER_PTR (max_copper_layer + layer), drawn_area, NULL);
-      /* draw package */
-      r_search (PCB->Data->element_tree, drawn_area, NULL, element_callback, &side);
-      r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], drawn_area, NULL, name_callback, &side);
-    }
-  gui->use_mask (HID_MASK_OFF);
-#endif
-}
-
-
-static void
-DrawMaskBoardArea (int mask_type, const BoxType *drawn_area)
-{
-  /* Skip the mask drawing if the GUI doesn't want this type */
-  if ((mask_type == HID_MASK_BEFORE && !gui->poly_before) ||
-      (mask_type == HID_MASK_AFTER  && !gui->poly_after))
-    return;
-
-  gui->use_mask (mask_type);
-  gui->set_color (Output.fgGC, PCB->MaskColor);
-  if (drawn_area == NULL)
-    gui->fill_rect (Output.fgGC, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
-  else
-    gui->fill_rect (Output.fgGC, drawn_area->X1, drawn_area->Y1,
-                                 drawn_area->X2, drawn_area->Y2);
-}
-
-/* ---------------------------------------------------------------------------
- * draws solder mask layer - this will cover nearly everything
- */
-void
-DrawMask (int side, const BoxType *screen)
-{
-  int thin = TEST_FLAG(THINDRAWFLAG, PCB) || TEST_FLAG(THINDRAWPOLYFLAG, PCB);
-
-  if (thin)
-    gui->set_color (Output.pmGC, PCB->MaskColor);
-  else
-    {
-      DrawMaskBoardArea (HID_MASK_BEFORE, screen);
-      gui->use_mask (HID_MASK_CLEAR);
-    }
-
-  r_search (PCB->Data->pin_tree, screen, NULL, pin_mask_callback, NULL);
-  r_search (PCB->Data->via_tree, screen, NULL, via_mask_callback, NULL);
-  r_search (PCB->Data->pad_tree, screen, NULL, pad_mask_callback, &side);
-
-  if (thin)
-    gui->set_color (Output.pmGC, "erase");
-  else
-    {
-      DrawMaskBoardArea (HID_MASK_AFTER, screen);
-      gui->use_mask (HID_MASK_OFF);
-    }
-}
-
-/* ---------------------------------------------------------------------------
- * draws solder paste layer for a given side of the board
- */
-void
-DrawPaste (int side, const BoxType *drawn_area)
-{
-  gui->set_color (Output.fgGC, PCB->ElementColor);
-  ALLPAD_LOOP (PCB->Data);
-  {
-    if (ON_SIDE (pad, side))
-      dapi->draw_pad_paste (pad, NULL, NULL);
-  }
-  ENDALL_LOOP;
-}
-
-static void
-DrawRats (const BoxType *drawn_area)
-{
-  /*
-   * XXX lesstif allows positive AND negative drawing in HID_MASK_CLEAR.
-   * XXX gtk only allows negative drawing.
-   * XXX using the mask here is to get rat transparency
-   */
-  int can_mask = strcmp(gui->name, "lesstif") == 0;
-
-  if (can_mask)
-    gui->use_mask (HID_MASK_CLEAR);
-  r_search (PCB->Data->rat_tree, drawn_area, NULL, rat_callback, NULL);
-  if (can_mask)
-    gui->use_mask (HID_MASK_OFF);
-}
-
-/* ---------------------------------------------------------------------------
- * draws one layer group.  If the exporter is not a GUI,
- * also draws the pins / pads / vias in this layer group.
- */
-void
-DrawLayerGroup (int group, const BoxType *drawn_area)
-{
-  int i, rv = 1;
-  int layernum;
-  LayerTypePtr Layer;
-  int n_entries = PCB->LayerGroups.Number[group];
-  Cardinal *layers = PCB->LayerGroups.Entries[group];
-
-  for (i = n_entries - 1; i >= 0; i--)
-    {
-      layernum = layers[i];
-      Layer = PCB->Data->Layer + layers[i];
-      if (strcmp (Layer->Name, "outline") == 0 ||
-          strcmp (Layer->Name, "route") == 0)
-        rv = 0;
-      if (layernum < max_copper_layer && Layer->On)
-        dapi->draw_layer (Layer, drawn_area, NULL);
-    }
-  if (n_entries > 1)
-    rv = 1;
-
-  if (rv && !gui->gui)
-    dapi->draw_ppv (group, drawn_area, NULL);
 }
 
 static void
@@ -1273,14 +902,6 @@ DrawObject (int type, void *ptr1, void *ptr2)
     }
 }
 
-static void
-draw_element (ElementTypePtr element)
-{
-  draw_element_package (element);
-  draw_element_name (element);
-  draw_element_pins_and_pads (element);
-}
-
 /* ---------------------------------------------------------------------------
  * HID drawing callback.
  */
@@ -1288,6 +909,7 @@ draw_element (ElementTypePtr element)
 void
 hid_expose_callback (HID * hid, BoxType * region, void *item)
 {
+#if 0
   HID *old_gui = gui;
 
   gui = hid;
@@ -1311,4 +933,5 @@ hid_expose_callback (HID * hid, BoxType * region, void *item)
   gui->destroy_gc (Output.bgGC);
   gui->destroy_gc (Output.pmGC);
   gui = old_gui;
+#endif
 }
diff --git a/src/draw_funcs.c b/src/draw_funcs.c
index 28ab8d4..d5155fe 100644
--- a/src/draw_funcs.c
+++ b/src/draw_funcs.c
@@ -1,3 +1,4 @@
+#if 0
 
 #include "global.h"
 #include "data.h"
@@ -499,3 +500,4 @@ struct draw_funcs d_f = {
 };
 
 struct draw_funcs *dapi = &d_f;
+#endif
diff --git a/src/hid.h b/src/hid.h
index b1f532f..16567d0 100644
--- a/src/hid.h
+++ b/src/hid.h
@@ -371,14 +371,6 @@ typedef enum
     void (*draw_rect) (hidGC gc_, Coord x1_, Coord y1_, Coord x2_, Coord y2_);
     void (*fill_circle) (hidGC gc_, Coord cx_, Coord cy_, Coord radius_);
     void (*fill_polygon) (hidGC gc_, int n_coords_, Coord *x_, Coord *y_);
-    void (*fill_pcb_polygon) (hidGC gc_, PolygonType *poly,
-                              const BoxType *clip_box);
-    void (*thindraw_pcb_polygon) (hidGC gc_, PolygonType *poly,
-                                  const BoxType *clip_box);
-    void (*fill_pcb_pad) (hidGC gc_, PadType *pad, bool clip, bool mask);
-    void (*thindraw_pcb_pad) (hidGC gc_, PadType *pad, bool clip, bool mask);
-    void (*fill_pcb_pv) (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool mask);
-    void (*thindraw_pcb_pv) (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool mask);
     void (*fill_rect) (hidGC gc_, Coord x1_, Coord y1_, Coord x2_, Coord y2_);
 
 
diff --git a/src/hid/common/draw_helpers.c b/src/hid/common/draw_helpers.c
index 03e82d8..3421b39 100644
--- a/src/hid/common/draw_helpers.c
+++ b/src/hid/common/draw_helpers.c
@@ -2,6 +2,8 @@
 #include "hid.h"
 #include "polygon.h"
 
+#if 0
+
 static void
 fill_contour (hidGC gc, PLINE *pl)
 {
@@ -107,7 +109,7 @@ fill_clipped_contour (hidGC gc, PLINE *pl, const BoxType *clip_box)
  * lets compute the complete no-holes polygon.
  */
 #define BOUNDS_INSIDE_CLIP_THRESHOLD 0.5
-static int
+static bool
 should_compute_no_holes (PolygonType *poly, const BoxType *clip_box)
 {
   Coord x1, x2, y1, y2;
@@ -116,7 +118,7 @@ should_compute_no_holes (PolygonType *poly, const BoxType *clip_box)
 
   /* If there is no passed clip box, compute the whole thing */
   if (clip_box == NULL)
-    return 1;
+    return true;
 
   x1 = MAX (poly->BoundingBox.X1, clip_box->X1);
   x2 = MIN (poly->BoundingBox.X2, clip_box->X2);
@@ -125,7 +127,7 @@ should_compute_no_holes (PolygonType *poly, const BoxType *clip_box)
 
   /* Check if the polygon is outside the clip box */
   if ((x2 <= x1) || (y2 <= y1))
-    return 0;
+    return false;
 
   poly_bounding_area = (double)(poly->BoundingBox.X2 - poly->BoundingBox.X1) *
                        (double)(poly->BoundingBox.Y2 - poly->BoundingBox.Y1);
@@ -133,14 +135,14 @@ should_compute_no_holes (PolygonType *poly, const BoxType *clip_box)
   clipped_poly_area = (double)(x2 - x1) * (double)(y2 - y1);
 
   if (clipped_poly_area / poly_bounding_area >= BOUNDS_INSIDE_CLIP_THRESHOLD)
-    return 1;
+    return true;
 
-  return 0;
+  return false;
 }
 #undef BOUNDS_INSIDE_CLIP_THRESHOLD
 
-void
-common_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+static void
+fill_poly (hidGC gc, PolygonType *poly, const BoxType *clip_box)
 {
   if (!poly->NoHolesValid)
     {
@@ -187,16 +189,15 @@ thindraw_hole_cb (PLINE *pl, void *user_data)
   return 0;
 }
 
-void
-common_thindraw_pcb_polygon (hidGC gc, PolygonType *poly,
-                             const BoxType *clip_box)
+static void
+thindraw_poly (hidGC gc, PolygonType *poly, const BoxType *clip_box)
 {
   thindraw_contour (gc, poly->Clipped->contours);
   PolygonHoles (poly, clip_box, thindraw_hole_cb, gc);
 }
 
-void
-common_thindraw_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask)
+static void
+thindraw_pad (hidGC gc, PadType *pad, bool clear, bool mask)
 {
   Coord w = clear ? (mask ? pad->Mask
                           : pad->Thickness + pad->Clearance)
@@ -264,8 +265,8 @@ common_thindraw_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask)
     }
 }
 
-void
-common_fill_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask)
+static void
+fill_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask)
 {
   Coord w = clear ? (mask ? pad->Mask
                           : pad->Thickness + pad->Clearance)
@@ -371,8 +372,8 @@ draw_octagon_poly (hidGC gc, Coord X, Coord Y,
     gui->fill_polygon (gc, 8, polygon_x, polygon_y);
 }
 
-void
-common_fill_pcb_pv (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool mask)
+static void
+fill_pv (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool mask)
 {
   Coord w = mask ? pv->Mask : pv->Thickness;
   Coord r = w / 2;
@@ -410,8 +411,8 @@ common_fill_pcb_pv (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool m
     gui->fill_circle (bg_gc, pv->X, pv->Y, pv->DrillingHole / 2);
 }
 
-void
-common_thindraw_pcb_pv (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool mask)
+static void
+thindraw_pv (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool mask)
 {
   Coord w = mask ? pv->Mask : pv->Thickness;
   Coord r = w / 2;
@@ -466,13 +467,227 @@ common_thindraw_pcb_pv (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bo
     }
 }
 
+static void
+_gui_draw_pv (PinType *pv, bool draw_hole)
+{
+  if (TEST_FLAG (THINDRAWFLAG, PCB))
+    thindraw_pv (Output.fgGC, Output.fgGC, pv, draw_hole, false);
+  else
+    fill_pv (Output.fgGC, Output.bgGC, pv, draw_hole, false);
+}
+
+void
+common_draw_pin (PinType *pin, const BoxType *drawn_area, void *userdata)
+{
+  _draw_pv (pin, false);
+}
+
+void
+common_draw_pin_mask (PinType *pin, const BoxType *drawn_area, void *userdata)
+{
+  if (TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG (THINDRAWPOLYFLAG, PCB))
+    thindraw_pcb_pv (Output.pmGC, Output.pmGC, pin, false, true);
+  else
+    fill_pcb_pv (Output.pmGC, Output.pmGC, pin, false, true);
+}
+
+static void
+draw_hole (PinType *pv, const BoxType *drawn_area, void *userdata)
+{
+  if (!TEST_FLAG (THINDRAWFLAG, PCB))
+    gui->fill_circle (Output.bgGC, pv->X, pv->Y, pv->DrillingHole / 2);
+
+  if (TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG (HOLEFLAG, pv))
+    {
+      gui->set_line_cap (Output.fgGC, Round_Cap);
+      gui->set_line_width (Output.fgGC, 0);
+
+      gui->draw_arc (Output.fgGC, pv->X, pv->Y,
+                     pv->DrillingHole / 2, pv->DrillingHole / 2, 0, 360);
+    }
+}
+
+void
+common_draw_pin_hole (PinType *pin, const BoxType *drawn_area, void *userdata)
+{
+  draw_hole (pin, drawn_area, userdata);
+}
+
+void
+common_draw_via (PinType *pin, const BoxType *drawn_area, void *userdata)
+{
+  _draw_pv (via, false);
+}
+
+void
+common_draw_via_mask (PinType *pin, const BoxType *drawn_area, void *userdata)
+{
+  if (TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG (THINDRAWPOLYFLAG, PCB))
+    gui->thindraw_pcb_pv (Output.pmGC, Output.pmGC, via, false, true);
+  else
+    gui->fill_pcb_pv (Output.pmGC, Output.pmGC, via, false, true);
+}
+
+void
+common_draw_via_hole (PinType *via, const BoxType *drawn_area, void *userdata)
+{
+  draw_hole (via, drawn_area, userdata);
+}
+
+static void
+_draw_pad (hidGC gc, PadType *pad, bool clear, bool mask)
+{
+  if (clear && !mask && pad->Clearance <= 0)
+    return;
+
+  if (TEST_FLAG (THINDRAWFLAG, PCB) ||
+      (clear && TEST_FLAG (THINDRAWPOLYFLAG, PCB)))
+    gui->thindraw_pcb_pad (gc, pad, clear, mask);
+  else
+    gui->fill_pcb_pad (gc, pad, clear, mask);
+}
+
+void
+common_draw_pad (PadType *pad, const BoxType *drawn_area, void *userdata)
+{
+  _draw_pad (Output.fgGC, pad, false, false);
+}
+
+void
+common_draw_pad_mask (PadType *pad, const BoxType *drawn_area, void *userdata)
+{
+  if (pad->Mask <= 0)
+    return;
+
+  _draw_pad (Output.pmGC, pad, true, true);
+}
+
+void
+common_draw_pad_paste (PadType *pad, const BoxType *drawn_area, void *userdata)
+{
+  if (TEST_FLAG (NOPASTEFLAG, pad) || pad->Mask <= 0)
+    return;
+
+  if (pad->Mask < pad->Thickness)
+    _draw_pad (Output.fgGC, pad, true, true);
+  else
+    _draw_pad (Output.fgGC, pad, false, false);
+}
+
+static void
+_draw_line (LineType *line)
+{
+  gui->set_line_cap (Output.fgGC, Trace_Cap);
+  if (TEST_FLAG (THINDRAWFLAG, PCB))
+    gui->set_line_width (Output.fgGC, 0);
+  else
+    gui->set_line_width (Output.fgGC, line->Thickness);
+
+  gui->draw_line (Output.fgGC,
+                  line->Point1.X, line->Point1.Y,
+                  line->Point2.X, line->Point2.Y);
+}
+
+void
+common_draw_line (LineType *line, const BoxType *drawn_area, void *userdata)
+{
+  _draw_line (line);
+}
+
+void
+common_draw_arc (ArcType *arc , const BoxType *drawn_area, void *userdata)
+{
+  if (!arc->Thickness)
+    return;
+
+  if (TEST_FLAG (THINDRAWFLAG, PCB))
+    gui->set_line_width (Output.fgGC, 0);
+  else
+    gui->set_line_width (Output.fgGC, arc->Thickness);
+  gui->set_line_cap (Output.fgGC, Trace_Cap);
+
+  gui->draw_arc (Output.fgGC, arc->X, arc->Y, arc->Width,
+                 arc->Height, arc->StartAngle, arc->Delta);
+}
+
+void
+common_draw_poly (PolygonType *poly, const BoxType *drawn_area, void *userdata)
+{
+  if (!polygon->Clipped)
+    return;
+
+  if (gui->thindraw_pcb_polygon != NULL &&
+      (TEST_FLAG (THINDRAWFLAG, PCB) ||
+       TEST_FLAG (THINDRAWPOLYFLAG, PCB)))
+    thindraw_poly (Output.fgGC, polygon, drawn_area);
+  else
+    fill_poly (Output.fgGC, polygon, drawn_area);
+
+  /* If checking planes, thin-draw any pieces which have been clipped away */
+  if (gui->thindraw_pcb_polygon != NULL &&
+      TEST_FLAG (CHECKPLANESFLAG, PCB) &&
+      !TEST_FLAG (FULLPOLYFLAG, polygon))
+    {
+      PolygonType poly = *polygon;
+
+      for (poly.Clipped = polygon->Clipped->f;
+           poly.Clipped != polygon->Clipped;
+           poly.Clipped = poly.Clipped->f)
+        thindraw_poly (Output.fgGC, &poly, drawn_area);
+    }
+}
+
+void
+common_draw_rat (RatType *rat, const BoxType *drawn_area, void *userdata)
+{
+  if (Settings.RatThickness < 20)
+    rat->Thickness = pixel_slop * Settings.RatThickness;
+  /* rats.c set VIAFLAG if this rat goes to a containing poly: draw a donut */
+  if (TEST_FLAG(VIAFLAG, rat))
+    {
+      int w = rat->Thickness;
+
+      if (TEST_FLAG (THINDRAWFLAG, PCB))
+        gui->set_line_width (Output.fgGC, 0);
+      else
+        gui->set_line_width (Output.fgGC, w);
+      gui->draw_arc (Output.fgGC, rat->Point1.X, rat->Point1.Y,
+                     w * 2, w * 2, 0, 360);
+    }
+  else
+    _draw_line ((LineType *) rat);
+}
+
+void
+common_draw_ppv (bool UNKNOWN, const BoxType *drawn_area, void *userdata)
+{
+
+}
+
+void
+common_draw_holes (bool UNKNOWN, const BoxType *drawn_area, void *userdata)
+{
+
+}
+
+void
+common_draw_layer (LayerType *layer, const BoxType *drawn_area, void *userdata)
+{
+
+}
+
+#endif
+
+
 void
 common_draw_helpers_init (HID *hid)
 {
+#if 0
   hid->fill_pcb_polygon     = common_fill_pcb_polygon;
   hid->thindraw_pcb_polygon = common_thindraw_pcb_polygon;
   hid->fill_pcb_pad         = common_fill_pcb_pad;
   hid->thindraw_pcb_pad     = common_thindraw_pcb_pad;
   hid->fill_pcb_pv          = common_fill_pcb_pv;
   hid->thindraw_pcb_pv      = common_thindraw_pcb_pv;
+#endif
 }
diff --git a/src/hid/common/draw_helpers.h b/src/hid/common/draw_helpers.h
index 8243fe4..4eb3bb7 100644
--- a/src/hid/common/draw_helpers.h
+++ b/src/hid/common/draw_helpers.h
@@ -1,9 +1,23 @@
-void common_fill_pcb_polygon (hidGC gc, PolygonType *poly,
-                              const BoxType *clip_box);
-void common_thindraw_pcb_polygon (hidGC gc, PolygonType *poly,
-                                  const BoxType *clip_box);
-void common_fill_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask);
-void common_thindraw_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask);
-void common_fill_pcb_pv (hidGC gc, PinType *pv, bool drawHole, bool mask);
-void common_thindraw_pcb_pv (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool mask);
+
+void common_draw_pin       (PinType *,     const BoxType *, void *);
+void common_draw_pin_mask  (PinType *,     const BoxType *, void *);
+void common_draw_pin_hole  (PinType *,     const BoxType *, void *);
+void common_draw_via       (PinType *,     const BoxType *, void *);
+void common_draw_via_mask  (PinType *,     const BoxType *, void *);
+void common_draw_via_hole  (PinType *,     const BoxType *, void *);
+void common_draw_pad       (PadType *,     const BoxType *, void *);
+void common_draw_pad_mask  (PadType *,     const BoxType *, void *);
+void common_draw_pad_paste (PadType *,     const BoxType *, void *);
+void common_draw_line      (LineType *,    const BoxType *, void *);
+void common_draw_arc       (ArcType *,     const BoxType *, void *);
+void common_draw_poly      (PolygonType *, const BoxType *, void *);
+
+void common_draw_rat       (RatType *,     const BoxType *, void *);
+
+void common_draw_ppv       (int,           const BoxType *, void *);
+void common_draw_holes     (int,           const BoxType *, void *);
+void common_draw_layer     (LayerType *,   const BoxType *, void *);
+
+
+
 void common_draw_helpers_init (HID *hid);
diff --git a/src/hid/common/hidnogui.c b/src/hid/common/hidnogui.c
index 9d88086..7b2a8a0 100644
--- a/src/hid/common/hidnogui.c
+++ b/src/hid/common/hidnogui.c
@@ -151,36 +151,6 @@ nogui_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
 }
 
 static void
-nogui_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
-{
-  CRASH;
-}
-
-static void
-nogui_fill_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask)
-{
-  CRASH;
-}
-
-static void
-nogui_thindraw_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask)
-{
-  CRASH;
-}
-
-static void
-nogui_fill_pcb_pv (hidGC fg_gc, hidGC bg_gc, PinType *pad, bool drawHole, bool mask)
-{
-  CRASH;
-}
-
-static void
-nogui_thindraw_pcb_pv (hidGC fg_gc, hidGC bg_gc, PinType *pad, bool drawHole, bool mask)
-{
-  CRASH;
-}
-
-static void
 nogui_fill_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
   CRASH;
@@ -471,11 +441,6 @@ common_nogui_init (HID *hid)
   hid->draw_rect =            nogui_draw_rect;
   hid->fill_circle =          nogui_fill_circle;
   hid->fill_polygon =         nogui_fill_polygon;
-  hid->fill_pcb_polygon =     nogui_fill_pcb_polygon;
-  hid->fill_pcb_pad =         nogui_fill_pcb_pad;
-  hid->thindraw_pcb_pad =     nogui_thindraw_pcb_pad;
-  hid->fill_pcb_pv =          nogui_fill_pcb_pv;
-  hid->thindraw_pcb_pv =      nogui_thindraw_pcb_pv;
   hid->fill_rect =            nogui_fill_rect;
   hid->calibrate =            nogui_calibrate;
   hid->shift_is_pressed =     nogui_shift_is_pressed;
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 21a22e8..7870ef4 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -577,6 +577,7 @@ ghid_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
   hidgl_fill_polygon (n_coords, x, y);
 }
 
+#if 0
 void
 ghid_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
 {
@@ -593,6 +594,7 @@ ghid_thindraw_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
   ghid_fill_pcb_polygon (gc, poly, clip_box);
   ghid_set_alpha_mult (gc, 1.0);
 }
+#endif
 
 void
 ghid_fill_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
@@ -830,8 +832,8 @@ ghid_init_renderer (int *argc, char ***argv, GHidPort *port)
 
   /* Setup HID function pointers specific to the GL renderer*/
   ghid_hid.end_layer = ghid_end_layer;
-  ghid_hid.fill_pcb_polygon = ghid_fill_pcb_polygon;
-  ghid_hid.thindraw_pcb_polygon = ghid_thindraw_pcb_polygon;
+//  ghid_hid.fill_pcb_polygon = ghid_fill_pcb_polygon;
+//  ghid_hid.thindraw_pcb_polygon = ghid_thindraw_pcb_polygon;
 }
 
 void
@@ -913,8 +915,8 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   /* If we don't have any stencil bits available,
      we can't use the hidgl polygon drawing routine */
   /* TODO: We could use the GLU tessellator though */
-  if (hidgl_stencil_bits() == 0)
-    ghid_hid.fill_pcb_polygon = common_fill_pcb_polygon;
+//  if (hidgl_stencil_bits() == 0)
+//    ghid_hid.fill_pcb_polygon = common_fill_pcb_polygon;
 
   glEnable (GL_BLEND);
   glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
diff --git a/src/hid/ps/ps.c b/src/hid/ps/ps.c
index 7f2ae8b..0fbe5de 100644
--- a/src/hid/ps/ps.c
+++ b/src/hid/ps/ps.c
@@ -393,8 +393,6 @@ static struct {
 
   double scale_factor;
 
-  BoxType region;
-
   HID_Attr_Val ps_values[NUM_OPTIONS];
 
   bool is_mask;
@@ -678,11 +676,6 @@ ps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
   ps_set_layer (NULL, 0, -1);
   use_gc (NULL);
 
-  global.region.X1 = 0;
-  global.region.Y1 = 0;
-  global.region.X2 = PCB->MaxWidth;
-  global.region.Y2 = PCB->MaxHeight;
-
   if (!global.multi_file)
     {
       /* %%Page DSC requires both a label and an ordinal */
@@ -694,13 +687,13 @@ ps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
 
       global.doing_toc = 1;
       global.pagecount = 1;  /* 'pagecount' is modified by hid_expose_callback() call */
-      hid_expose_callback (&ps_hid, &global.region, 0);
+      expose ();
     }
 
   global.pagecount = 1; /* Reset 'pagecount' if single file */
   global.doing_toc = 0;
   ps_set_layer (NULL, 0, -1);  /* reset static vars */
-  hid_expose_callback (&ps_hid, &global.region, 0);
+  expose (&ps_hid, &global.region);
 
   if (the_file)
     fprintf (the_file, "showpage\n");
@@ -1007,7 +1000,7 @@ ps_set_layer (const char *name, int group, int empty)
       strcmp (name, "route") != 0
       )
     {
-      dapi->draw_layer (global.outline_layer, &global.region, NULL);
+      draw_layer (global.outline_layer, NULL, NULL);
     }
 
   return 1;
@@ -1512,7 +1505,6 @@ void ps_ps_init (HID *hid)
   hid->draw_rect          = ps_draw_rect;
   hid->fill_circle        = ps_fill_circle;
   hid->fill_polygon       = ps_fill_polygon;
-  hid->fill_pcb_polygon   = ps_fill_pcb_polygon;
   hid->fill_rect          = ps_fill_rect;
   hid->calibrate          = ps_calibrate;
   hid->set_crosshair      = ps_set_crosshair;

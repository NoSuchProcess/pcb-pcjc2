Bottom: d9ca792132580d3d49790c6aefa2d8ffaf3fecd7
Top:    2f86ba9e0b681acc15a7af870d26a1c4745df2cc
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-06-02 21:08:38 +0100

Fix poly_ComputeInteriorPoint() to work correctly for holes

The step where the algorithm finds a convex node to start from must
take into account whether the polygon vertices are ordered as a hole
or an outer contour. We now correctly compute a point inside the hole,
rather than possibly outside it.

This fixes an assertion on the following test-case. Prior to this
commit, the incorrect "interior" point tested for the concave hole
happens to lie inside the polygon's other hole, causing it to fail
an assert during processing.

Layer(2 "solder")
(
  Line[340000 160000 183700 108000 1500 3000 "clearline"]
  Line[92000 121000 120000 90000 1500 3000 "clearline"]
  Line[270000 90000 120000 90000 1500 3000 "clearline"]
  Polygon("clearpoly")
  (
    [40000 40000] [320000 40000] [320000 200000] [40000 200000]
  )
)

The bug was created in my attempt to speed up poly_ContourInContour:
commit 3d0a8bd1dae0816d364a774bf9b958faf2983ec7


---

diff --git a/src/polygon1.c b/src/polygon1.c
index 31b71f1..f8ed16b 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -2333,6 +2333,7 @@ poly_ComputeInteriorPoint (PLINE *poly, Vector v)
   VNODE *min_q = NULL;
   double dist;
   double min_dist;
+  double dir = (poly->Flags.orient == PLF_DIR) ? 1. : -1;
 
   /* Find a convex node on the polygon */
   pt1 = &poly->head;
@@ -2346,7 +2347,7 @@ poly_ComputeInteriorPoint (PLINE *poly, Vector v)
       dot_product = dot_orthogonal_to_direction (pt1->point, pt2->point,
                                                  pt3->point, pt2->point);
 
-      if (dot_product > 0.)
+      if (dot_product * dir > 0.)
         break;
     }
   while ((pt1 = pt1->next) != &poly->head);

Bottom: 646710953cf331ffa3c1dd9926a085c0a25683fb
Top:    f5e6cbdc25b0cee8cf505f23a3f0365bebfdc048
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2015-01-11 15:20:04 +0000

Attempt at re-writing drawing routines to pass state via hidGC

Note, this appears to break clearing out of pin and via holes at the moment
Note, 3D event projection and unprojection is broken
Note, autoroute.c debug drawing cleanup is probably broken (ordering)


---

diff --git a/src/autoroute.c b/src/autoroute.c
index 0b4b9e9..e38247f 100644
--- a/src/autoroute.c
+++ b/src/autoroute.c
@@ -3673,7 +3673,7 @@ TracePath (routedata_t * rd, routebox_t * path, const routebox_t * target,
 
 #ifdef ROUTE_DEBUG
   if (ddraw != NULL)
-    gui->flush_debug_draw ();
+    gui->flush_debug_draw (ar_gc);
 #endif
 }
 
@@ -5333,8 +5333,8 @@ donerouting:
 #ifdef ROUTE_DEBUG
   if (ddraw != NULL)
     {
+      gui->finish_debug_draw (ar_gc);
       hid_draw_destroy_gc (ar_gc);
-      gui->finish_debug_draw ();
     }
 #endif
 
diff --git a/src/draw.c b/src/draw.c
index 0641799..bd9594c 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -80,13 +80,13 @@ static bool doing_assy = false;
 /* ---------------------------------------------------------------------------
  * some local prototypes
  */
-static void DrawEverything (const BoxType *);
+static void DrawEverything (hidGC gc);
 static void AddPart (void *);
-/* static */ void DrawEMark (ElementType *, Coord, Coord, bool);
-/* static */ void DrawRats (const BoxType *);
+/* static */ void DrawEMark (hidGC gc, ElementType *, Coord, Coord, bool);
+/* static */ void DrawRats (hidGC gc);
 
 static void
-set_object_color (AnyObjectType *obj, char *warn_color, char *selected_color,
+set_object_color (hidGC gc, AnyObjectType *obj, char *warn_color, char *selected_color,
                   char *connected_color, char *found_color, char *normal_color)
 {
   char *color;
@@ -97,7 +97,7 @@ set_object_color (AnyObjectType *obj, char *warn_color, char *selected_color,
   else if (found_color     != NULL && TEST_FLAG (FOUNDFLAG,     obj)) color = found_color;
   else                                                                color = normal_color;
 
-  hid_draw_set_color (Output.fgGC, color);
+  hid_draw_set_color (gc, color);
 }
 
 /*---------------------------------------------------------------------------
@@ -137,39 +137,44 @@ Redraw (void)
   gui->invalidate_all ();
 }
 
+struct side_info {
+  hidGC gc;
+  int side;
+};
+
 static int
 pad_callback (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *) b;
-  int *side = cl;
+  struct side_info *info = cl;
 
-  if (ON_SIDE (pad, *side))
+  if (ON_SIDE (pad, info->side))
     {
-      set_object_color ((AnyObjectType *)pad, PCB->WarnColor,
+      set_object_color (info->gc, (AnyObjectType *)pad, PCB->WarnColor,
                         PCB->PinSelectedColor, PCB->ConnectedColor, PCB->FoundColor,
                         FRONT (pad) ? PCB->PinColor : PCB->InvisibleObjectsColor);
 
-      dapi->draw_pad (pad, NULL, NULL);
+      dapi->draw_pad (info->gc, pad, NULL);
     }
   return 1;
 }
 
 static void
-draw_element_name (ElementType *element)
+draw_element_name (hidGC gc, ElementType *element)
 {
   if ((TEST_FLAG (HIDENAMESFLAG, PCB) && gui->gui) ||
       TEST_FLAG (HIDENAMEFLAG, element))
     return;
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)element);
+  ghid_set_lock_effects (gc, (AnyObjectType *)element);
   if (doing_pinout || doing_assy)
-    hid_draw_set_color (Output.fgGC, PCB->ElementColor);
+    hid_draw_set_color (gc, PCB->ElementColor);
   else if (TEST_FLAG (SELECTEDFLAG, &ELEMENT_TEXT (PCB, element)))
-    hid_draw_set_color (Output.fgGC, PCB->ElementSelectedColor);
+    hid_draw_set_color (gc, PCB->ElementSelectedColor);
   else if (FRONT (element))
-    hid_draw_set_color (Output.fgGC, PCB->ElementColor);
+    hid_draw_set_color (gc, PCB->ElementColor);
   else
-    hid_draw_set_color (Output.fgGC, PCB->InvisibleObjectsColor);
-  hid_draw_pcb_text (Output.fgGC, &ELEMENT_TEXT (PCB, element), PCB->minSlk);
+    hid_draw_set_color (gc, PCB->InvisibleObjectsColor);
+  hid_draw_pcb_text (gc, &ELEMENT_TEXT (PCB, element), PCB->minSlk);
 }
 
 static int
@@ -177,42 +182,42 @@ name_callback (const BoxType * b, void *cl)
 {
   TextType *text = (TextType *) b;
   ElementType *element = (ElementType *) text->Element;
-  int *side = cl;
+  struct side_info *info = cl;
 
   if (TEST_FLAG (HIDENAMEFLAG, element))
     return 0;
 
-  if (ON_SIDE (element, *side))
-    draw_element_name (element);
+  if (ON_SIDE (element, info->side))
+    draw_element_name (info->gc, element);
   return 0;
 }
 
 static void
-draw_element_pins_and_pads (ElementType *element)
+draw_element_pins_and_pads (hidGC gc, ElementType *element)
 {
   PAD_LOOP (element);
   {
     if (doing_pinout || doing_assy || FRONT (pad) || PCB->InvisibleObjectsOn)
       {
-        set_object_color ((AnyObjectType *)pad, PCB->WarnColor,
+        set_object_color (gc, (AnyObjectType *)pad, PCB->WarnColor,
                           PCB->PinSelectedColor, PCB->ConnectedColor, PCB->FoundColor,
                           FRONT (pad) ? PCB->PinColor : PCB->InvisibleObjectsColor);
 
-        dapi->draw_pad (pad, NULL, NULL);
+        dapi->draw_pad (gc, pad, NULL);
       }
   }
   END_LOOP;
   PIN_LOOP (element);
   {
-    set_object_color ((AnyObjectType *)pin, PCB->WarnColor, PCB->PinSelectedColor,
+    set_object_color (gc, (AnyObjectType *)pin, PCB->WarnColor, PCB->PinSelectedColor,
                       PCB->ConnectedColor, PCB->FoundColor, PCB->PinColor);
 
-    dapi->draw_pin (pin, NULL, NULL);
+    dapi->draw_pin (gc, pin, NULL);
 
-    set_object_color ((AnyObjectType *)pin, PCB->WarnColor,
+    set_object_color (gc, (AnyObjectType *)pin, PCB->WarnColor,
                       PCB->PinSelectedColor, NULL, NULL, Settings.BlackColor);
 
-    dapi->draw_pin_hole (pin, NULL, NULL);
+    dapi->draw_pin_hole (gc, pin, NULL);
   }
   END_LOOP;
 }
@@ -221,8 +226,9 @@ static int
 EMark_callback (const BoxType * b, void *cl)
 {
   ElementType *element = (ElementType *) b;
+  hidGC gc = cl;
 
-  DrawEMark (element, element->MarkX, element->MarkY, !FRONT (element));
+  DrawEMark (gc, element, element->MarkX, element->MarkY, !FRONT (element));
   return 1;
 }
 
@@ -230,39 +236,40 @@ static int
 rat_callback (const BoxType * b, void *cl)
 {
   RatType *rat = (RatType *)b;
+  hidGC gc = cl;
 
-  set_object_color ((AnyObjectType *) rat, NULL, PCB->RatSelectedColor,
+  set_object_color (gc, (AnyObjectType *) rat, NULL, PCB->RatSelectedColor,
                     PCB->ConnectedColor, PCB->FoundColor, PCB->RatColor);
 
-  dapi->draw_rat (rat, NULL, NULL);
+  dapi->draw_rat (gc, rat, NULL);
   return 1;
 }
 
 static void
-draw_element_package (ElementType *element)
+draw_element_package (hidGC gc, ElementType *element)
 {
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)element);
+  ghid_set_lock_effects (gc, (AnyObjectType *)element);
   /* set color and draw lines, arcs, text and pins */
   if (doing_pinout || doing_assy)
-    hid_draw_set_color (Output.fgGC, PCB->ElementColor);
+    hid_draw_set_color (gc, PCB->ElementColor);
   else if (TEST_FLAG (SELECTEDFLAG, element))
-    hid_draw_set_color (Output.fgGC, PCB->ElementSelectedColor);
+    hid_draw_set_color (gc, PCB->ElementSelectedColor);
   else if (FRONT (element))
-    hid_draw_set_color (Output.fgGC, PCB->ElementColor);
+    hid_draw_set_color (gc, PCB->ElementColor);
   else
-    hid_draw_set_color (Output.fgGC, PCB->InvisibleObjectsColor);
+    hid_draw_set_color (gc, PCB->InvisibleObjectsColor);
 
   /* draw lines, arcs, text and pins */
   ELEMENTLINE_LOOP (element);
   {
-    //hid_draw_pcb_line (Output.fgGC, line);
-    dapi->draw_line (line, NULL, NULL);
+    //hid_draw_pcb_line (gc, line);
+    dapi->draw_line (gc, line, NULL);
   }
   END_LOOP;
   ARC_LOOP (element);
   {
-    //hid_draw_pcb_arc (Output.fgGC, arc);
-    dapi->draw_arc (arc, NULL, NULL);
+    //hid_draw_pcb_arc (gc, arc);
+    dapi->draw_arc (gc, arc, NULL);
   }
   END_LOOP;
 }
@@ -271,10 +278,10 @@ static int
 element_callback (const BoxType * b, void *cl)
 {
   ElementType *element = (ElementType *) b;
-  int *side = cl;
+  struct side_info *info = cl;
 
-  if (ON_SIDE (element, *side))
-    draw_element_package (element);
+  if (ON_SIDE (element, info->side))
+    draw_element_package (info->gc, element);
   return 1;
 }
 
@@ -283,17 +290,17 @@ element_callback (const BoxType * b, void *cl)
  */
 
 void
-PrintAssembly (int side, const BoxType * drawn_area)
+PrintAssembly (hidGC gc, int side)
 {
   int side_group = GetLayerGroupNumberBySide (side);
 
   doing_assy = true;
-  hid_draw_set_draw_faded (Output.fgGC, 1);
-  DrawLayerGroup (side_group, drawn_area);
-  hid_draw_set_draw_faded (Output.fgGC, 0);
+  hid_draw_set_draw_faded (gc, 1);
+  DrawLayerGroup (gc, side_group);
+  hid_draw_set_draw_faded (gc, 0);
 
   /* draw package */
-  DrawSilk (side, drawn_area);
+  DrawSilk (gc, side);
   doing_assy = false;
 }
 
@@ -301,9 +308,9 @@ PrintAssembly (int side, const BoxType * drawn_area)
  * initializes some identifiers for a new zoom factor and redraws whole screen
  */
 static void
-DrawEverything (const BoxType *drawn_area)
+DrawEverything (hidGC gc)
 {
-  int i, ngroups, side;
+  int i, ngroups;
   int top_group, bottom_group;
   /* This is the list of layer groups we will draw.  */
   int do_group[MAX_GROUP];
@@ -311,6 +318,9 @@ DrawEverything (const BoxType *drawn_area)
   int drawn_groups[MAX_GROUP];
   int plated, unplated;
   bool paste_empty;
+  struct side_info info;
+
+  info.gc = gc;
 
   PCB->Data->SILKLAYER.Color = PCB->ElementColor;
   PCB->Data->BACKSILKLAYER.Color = PCB->InvisibleObjectsColor;
@@ -334,17 +344,17 @@ DrawEverything (const BoxType *drawn_area)
    * first draw all 'invisible' stuff
    */
   if (!TEST_FLAG (CHECKPLANESFLAG, PCB)
-      && gui->set_layer ("invisible", SL (INVISIBLE, 0), 0))
+      && gui->set_layer (gc, "invisible", SL (INVISIBLE, 0), 0))
     {
-      side = SWAP_IDENT ? TOP_SIDE : BOTTOM_SIDE;
+      info.side = SWAP_IDENT ? TOP_SIDE : BOTTOM_SIDE;
       if (PCB->ElementOn)
 	{
-	  r_search (PCB->Data->element_tree, drawn_area, NULL, element_callback, &side);
-	  r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], drawn_area, NULL, name_callback, &side);
-	  dapi->draw_layer (&(PCB->Data->Layer[max_copper_layer + side]), drawn_area, NULL);
+	  r_search (PCB->Data->element_tree, gc->clip_box, NULL, element_callback, &info);
+	  r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], gc->clip_box, NULL, name_callback, &info);
+	  dapi->draw_layer (gc, &(PCB->Data->Layer[max_copper_layer + info.side]), NULL);
 	}
-      r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, &side);
-      gui->end_layer ();
+      r_search (PCB->Data->pad_tree, gc->clip_box, NULL, pad_callback, &info);
+      gui->end_layer (gc);
     }
 
   /* draw all layers in layerstack order */
@@ -352,10 +362,10 @@ DrawEverything (const BoxType *drawn_area)
     {
       int group = drawn_groups[i];
 
-      if (gui->set_layer (0, group, 0))
+      if (gui->set_layer (gc, 0, group, 0))
         {
-          DrawLayerGroup (group, drawn_area);
-          gui->end_layer ();
+          DrawLayerGroup (gc, group);
+          gui->end_layer (gc);
         }
     }
 
@@ -364,98 +374,97 @@ DrawEverything (const BoxType *drawn_area)
 
   /* Draw pins, pads, vias below silk */
   if (gui->gui)
-    dapi->draw_ppv (SWAP_IDENT ? bottom_group : top_group, drawn_area, NULL);
+    dapi->draw_ppv (gc, SWAP_IDENT ? bottom_group : top_group, NULL);
   else
     {
-      CountHoles (&plated, &unplated, drawn_area);
+      CountHoles (&plated, &unplated, gc->clip_box);
 
-      if (plated && gui->set_layer ("plated-drill", SL (PDRILL, 0), 0))
+      if (plated && gui->set_layer (gc, "plated-drill", SL (PDRILL, 0), 0))
         {
-          dapi->draw_holes (1, drawn_area, NULL);
-          gui->end_layer ();
+          dapi->draw_holes (gc, 1, NULL);
+          gui->end_layer (gc);
         }
 
-      if (unplated && gui->set_layer ("unplated-drill", SL (UDRILL, 0), 0))
+      if (unplated && gui->set_layer (gc, "unplated-drill", SL (UDRILL, 0), 0))
         {
-          dapi->draw_holes (0, drawn_area, NULL);
-          gui->end_layer ();
+          dapi->draw_holes (gc, 0, NULL);
+          gui->end_layer (gc);
         }
     }
 
   /* Draw the solder mask if turned on */
-  if (gui->set_layer ("componentmask", SL (MASK, TOP), 0))
+  if (gui->set_layer (gc, "componentmask", SL (MASK, TOP), 0))
     {
-      DrawMask (TOP_SIDE, drawn_area);
-      gui->end_layer ();
+      DrawMask (gc, TOP_SIDE);
+      gui->end_layer (gc);
     }
 
-  if (gui->set_layer ("soldermask", SL (MASK, BOTTOM), 0))
+  if (gui->set_layer (gc, "soldermask", SL (MASK, BOTTOM), 0))
     {
-      DrawMask (BOTTOM_SIDE, drawn_area);
-      gui->end_layer ();
+      DrawMask (gc, BOTTOM_SIDE);
+      gui->end_layer (gc);
     }
 
-  if (gui->set_layer ("topsilk", SL (SILK, TOP), 0))
+  if (gui->set_layer (gc, "topsilk", SL (SILK, TOP), 0))
     {
-      DrawSilk (TOP_SIDE, drawn_area);
-      gui->end_layer ();
+      DrawSilk (gc, TOP_SIDE);
+      gui->end_layer (gc);
     }
 
-  if (gui->set_layer ("bottomsilk", SL (SILK, BOTTOM), 0))
+  if (gui->set_layer (gc, "bottomsilk", SL (SILK, BOTTOM), 0))
     {
-      DrawSilk (BOTTOM_SIDE, drawn_area);
-      gui->end_layer ();
+      DrawSilk (gc, BOTTOM_SIDE);
+      gui->end_layer (gc);
     }
 
   if (gui->gui)
     {
       /* Draw element Marks */
       if (PCB->PinOn)
-	r_search (PCB->Data->element_tree, drawn_area, NULL, EMark_callback,
-		  NULL);
+	r_search (PCB->Data->element_tree, gc->clip_box, NULL, EMark_callback, gc);
       /* Draw rat lines on top */
-      if (gui->set_layer ("rats", SL (RATS, 0), 0))
+      if (gui->set_layer (gc, "rats", SL (RATS, 0), 0))
         {
-          DrawRats(drawn_area);
-          gui->end_layer ();
+          DrawRats (gc);
+          gui->end_layer (gc);
         }
     }
 
   paste_empty = IsPasteEmpty (TOP_SIDE);
-  if (gui->set_layer ("toppaste", SL (PASTE, TOP), paste_empty))
+  if (gui->set_layer (gc, "toppaste", SL (PASTE, TOP), paste_empty))
     {
-      DrawPaste (TOP_SIDE, drawn_area);
-      gui->end_layer ();
+      DrawPaste (gc, TOP_SIDE);
+      gui->end_layer (gc);
     }
 
   paste_empty = IsPasteEmpty (BOTTOM_SIDE);
-  if (gui->set_layer ("bottompaste", SL (PASTE, BOTTOM), paste_empty))
+  if (gui->set_layer (gc, "bottompaste", SL (PASTE, BOTTOM), paste_empty))
     {
-      DrawPaste (BOTTOM_SIDE, drawn_area);
-      gui->end_layer ();
+      DrawPaste (gc, BOTTOM_SIDE);
+      gui->end_layer (gc);
     }
 
-  if (gui->set_layer ("topassembly", SL (ASSY, TOP), 0))
+  if (gui->set_layer (gc, "topassembly", SL (ASSY, TOP), 0))
     {
-      PrintAssembly (TOP_SIDE, drawn_area);
-      gui->end_layer ();
+      PrintAssembly (gc, TOP_SIDE);
+      gui->end_layer (gc);
     }
 
-  if (gui->set_layer ("bottomassembly", SL (ASSY, BOTTOM), 0))
+  if (gui->set_layer (gc, "bottomassembly", SL (ASSY, BOTTOM), 0))
     {
-      PrintAssembly (BOTTOM_SIDE, drawn_area);
-      gui->end_layer ();
+      PrintAssembly (gc, BOTTOM_SIDE);
+      gui->end_layer (gc);
     }
 
-  if (gui->set_layer ("fab", SL (FAB, 0), 0))
+  if (gui->set_layer (gc, "fab", SL (FAB, 0), 0))
     {
-      PrintFab (Output.fgGC);
-      gui->end_layer ();
+      PrintFab (gc);
+      gui->end_layer (gc);
     }
 }
 
 /* static */ void
-DrawEMark (ElementType *e, Coord X, Coord Y, bool invisible)
+DrawEMark (hidGC gc, ElementType *e, Coord X, Coord Y, bool invisible)
 {
   Coord mark_size = EMARK_SIZE;
   if (!PCB->InvisibleObjectsOn && invisible)
@@ -476,14 +485,14 @@ DrawEMark (ElementType *e, Coord X, Coord Y, bool invisible)
       mark_size = MIN (mark_size, pad0->Thickness / 2);
     }
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)e);
-  hid_draw_set_color (Output.fgGC, invisible ? PCB->InvisibleMarkColor : PCB->ElementColor);
-  hid_draw_set_line_cap (Output.fgGC, Trace_Cap);
-  hid_draw_set_line_width (Output.fgGC, 0);
-  hid_draw_line (Output.fgGC, X - mark_size, Y, X, Y - mark_size);
-  hid_draw_line (Output.fgGC, X + mark_size, Y, X, Y - mark_size);
-  hid_draw_line (Output.fgGC, X - mark_size, Y, X, Y + mark_size);
-  hid_draw_line (Output.fgGC, X + mark_size, Y, X, Y + mark_size);
+  ghid_set_lock_effects (gc, (AnyObjectType *)e);
+  hid_draw_set_color (gc, invisible ? PCB->InvisibleMarkColor : PCB->ElementColor);
+  hid_draw_set_line_cap (gc, Trace_Cap);
+  hid_draw_set_line_width (gc, 0);
+  hid_draw_line (gc, X - mark_size, Y, X, Y - mark_size);
+  hid_draw_line (gc, X + mark_size, Y, X, Y - mark_size);
+  hid_draw_line (gc, X - mark_size, Y, X, Y + mark_size);
+  hid_draw_line (gc, X + mark_size, Y, X, Y + mark_size);
 
   /*
    * If an element is locked, place a "L" on top of the "diamond".
@@ -492,22 +501,26 @@ DrawEMark (ElementType *e, Coord X, Coord Y, bool invisible)
    */
   if (TEST_FLAG (LOCKFLAG, e) )
     {
-      hid_draw_line (Output.fgGC, X, Y, X + 2 * mark_size, Y);
-      hid_draw_line (Output.fgGC, X, Y, X, Y - 4* mark_size);
+      hid_draw_line (gc, X, Y, X + 2 * mark_size, Y);
+      hid_draw_line (gc, X, Y, X, Y - 4* mark_size);
     }
 }
 
 static int
 pin_mask_callback (const BoxType * b, void *cl)
 {
-  dapi->draw_pin_mask ((PinType *) b, NULL, NULL);
+  hidGC gc = cl;
+
+  dapi->draw_pin_mask (gc, (PinType *) b, NULL);
   return 1;
 }
 
 static int
 via_mask_callback (const BoxType * b, void *cl)
 {
-  dapi->draw_via_mask ((PinType *) b, NULL, NULL);
+  hidGC gc = cl;
+
+  dapi->draw_via_mask (gc, (PinType *) b, NULL);
   return 1;
 }
 
@@ -515,9 +528,10 @@ static int
 pad_mask_callback (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *) b;
-  int *side = cl;
-  if (ON_SIDE (pad, *side))
-    dapi->draw_pad_mask (pad, NULL, NULL);
+  struct side_info *info = cl;
+
+  if (ON_SIDE (pad, info->side))
+    dapi->draw_pad_mask (info->gc, pad, NULL);
   return 1;
 }
 
@@ -526,8 +540,13 @@ pad_mask_callback (const BoxType * b, void *cl)
  */
 
 void
-DrawSilk (int side, const BoxType * drawn_area)
+DrawSilk (hidGC gc, int side)
 {
+  struct side_info info;
+
+  info.gc = gc;
+  info.side = side;
+
 #if 0
   /* This code is used when you want to mask silk to avoid exposed
      pins and pads.  We decided it was a bad idea to do this
@@ -537,62 +556,57 @@ DrawSilk (int side, const BoxType * drawn_area)
 #if 0
   if (gui->poly_before)
     {
-      hid_draw_use_mask (Output.fgGC, HID_MASK_BEFORE);
+      hid_draw_use_mask (gc, HID_MASK_BEFORE);
 #endif
-      dapi->draw_layer (LAYER_PTR (max_copper_layer + side), drawn_area, NULL);
+      dapi->draw_layer (gc, LAYER_PTR (max_copper_layer + side), NULL);
       /* draw package */
-      r_search (PCB->Data->element_tree, drawn_area, NULL, element_callback, &side);
-      r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], drawn_area, NULL, name_callback, &side);
+      r_search (PCB->Data->element_tree, gc->clip_box, NULL, element_callback, &info);
+      r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], gc->clip_box, NULL, name_callback, &info);
 #if 0
     }
 
-  hid_draw_use_mask (Output.fgGC, HID_MASK_CLEAR);
-  r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_mask_callback, NULL);
-  r_search (PCB->Data->via_tree, drawn_area, NULL, via_mask_callback, NULL);
-  r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_mask_callback, &side);
+  hid_draw_use_mask (gc, HID_MASK_CLEAR);
+  r_search (PCB->Data->pin_tree, gc->clip_box, NULL, pin_mask_callback, gc);
+  r_search (PCB->Data->via_tree, gc->clip_box, NULL, via_mask_callback, gc);
+  r_search (PCB->Data->pad_tree, gc->clip_box, NULL, pad_mask_callback, &info);
 
   if (gui->poly_after)
     {
-      hid_draw_use_mask (Output.fgGC, HID_MASK_AFTER);
-      dapi->draw_layer (LAYER_PTR (max_copper_layer + layer), drawn_area, NULL);
+      hid_draw_use_mask (gc, HID_MASK_AFTER);
+      dapi->draw_layer (gc, LAYER_PTR (max_copper_layer + layer), NULL);
       /* draw package */
-      r_search (PCB->Data->element_tree, drawn_area, NULL, element_callback, &side);
-      r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], drawn_area, NULL, name_callback, &side);
+      r_search (PCB->Data->element_tree, gc->clip_box, NULL, element_callback, &side);
+      r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], gc->clip_box, NULL, name_callback, &info);
     }
-  hid_draw_use_mask (Output.fgGC, HID_MASK_OFF);
+  hid_draw_use_mask (gc, HID_MASK_OFF);
 #endif
 }
 
 
 static void
-DrawMaskBoardArea (int mask_type, const BoxType *drawn_area)
+DrawMaskBoardArea (hidGC gc, int mask_type)
 {
   /* Skip the mask drawing if the GUI doesn't want this type */
   if ((mask_type == HID_MASK_BEFORE && !gui->poly_before) ||
       (mask_type == HID_MASK_AFTER  && !gui->poly_after))
     return;
 
-  hid_draw_use_mask (Output.fgGC, mask_type);
-  hid_draw_set_color (Output.fgGC, PCB->MaskColor);
-  if (drawn_area == NULL)
-    hid_draw_fill_rect (Output.fgGC, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
+  hid_draw_use_mask (gc, mask_type);
+  hid_draw_set_color (gc, PCB->MaskColor);
+  if (gc->clip_box == NULL)
+    hid_draw_fill_rect (gc, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
   else
-    hid_draw_fill_rect (Output.fgGC, drawn_area->X1, drawn_area->Y1,
-                                     drawn_area->X2, drawn_area->Y2);
+    hid_draw_fill_rect (gc, gc->clip_box->X1, gc->clip_box->Y1,
+                            gc->clip_box->X2, gc->clip_box->Y2);
 }
 
-struct poly_info {
-  const const BoxType *drawn_area;
-  LayerType *layer;
-};
-
 static int
 mask_poly_callback (const BoxType * b, void *cl)
 {
-  struct poly_info *i = cl;
   PolygonType *polygon = (PolygonType *)b;
+  hidGC gc = cl;
 
-  hid_draw_pcb_polygon (Output.pmGC, polygon, i->drawn_area);
+  hid_draw_pcb_polygon (Output.pmGC, polygon);
   return 1;
 }
 
@@ -600,6 +614,7 @@ static int
 mask_line_callback (const BoxType * b, void *cl)
 {
   LineType *line = (LineType *)b;
+  hidGC gc = cl;
 
   hid_draw_pcb_line (Output.pmGC, line);
   return 1;
@@ -609,6 +624,7 @@ static int
 mask_arc_callback (const BoxType * b, void *cl)
 {
   ArcType *arc = (ArcType *)b;
+  hidGC gc = cl;
 
   hid_draw_pcb_arc (Output.pmGC, arc);
   return 1;
@@ -617,16 +633,13 @@ mask_arc_callback (const BoxType * b, void *cl)
 static int
 mask_text_callback (const BoxType * b, void *cl)
 {
-  LayerType *layer = cl;
   TextType *text = (TextType *)b;
+  hidGC gc = cl;
   int min_silk_line;
 
-  if (layer == &PCB->Data->SILKLAYER ||
-      layer == &PCB->Data->BACKSILKLAYER)
-    min_silk_line = PCB->minSlk;
-  else
-    min_silk_line = PCB->minWid;
-  hid_draw_pcb_text (Output.fgGC, text, min_silk_line);
+  min_silk_line = PCB->minSlk;
+
+  hid_draw_pcb_text (gc, text, min_silk_line);
   return 1;
 }
 
@@ -634,37 +647,38 @@ mask_text_callback (const BoxType * b, void *cl)
  * draws solder mask layer - this will cover nearly everything
  */
 void
-DrawMask (int side, const BoxType *screen)
+DrawMask (hidGC gc, int side)
 {
   int thin = TEST_FLAG(THINDRAWFLAG, PCB) || TEST_FLAG(THINDRAWPOLYFLAG, PCB);
   LayerType *Layer = LAYER_PTR (side == TOP_SIDE ? top_soldermask_layer : bottom_soldermask_layer);
-  struct poly_info info;
+  struct side_info info;
+
+  info.gc = gc;
+  info.side = side;
 
   if (thin)
     hid_draw_set_color (Output.pmGC, PCB->MaskColor);
   else
     {
-      DrawMaskBoardArea (HID_MASK_BEFORE, screen);
-      hid_draw_use_mask (Output.fgGC, HID_MASK_CLEAR);
+      DrawMaskBoardArea (gc, HID_MASK_BEFORE);
+      hid_draw_use_mask (gc, HID_MASK_CLEAR);
     }
 
-  info.layer = Layer;
-  info.drawn_area = screen;
-  r_search (Layer->polygon_tree, screen, NULL, mask_poly_callback, &info);
-  r_search (Layer->line_tree,    screen, NULL, mask_line_callback, Layer);
-  r_search (Layer->arc_tree,     screen, NULL, mask_arc_callback,  Layer);
-  r_search (Layer->text_tree,    screen, NULL, mask_text_callback, Layer);
+  r_search (Layer->polygon_tree, gc->clip_box, NULL, mask_poly_callback, gc);
+  r_search (Layer->line_tree,    gc->clip_box, NULL, mask_line_callback, gc);
+  r_search (Layer->arc_tree,     gc->clip_box, NULL, mask_arc_callback,  gc);
+  r_search (Layer->text_tree,    gc->clip_box, NULL, mask_text_callback, gc);
 
-  r_search (PCB->Data->pin_tree, screen, NULL, pin_mask_callback, NULL);
-  r_search (PCB->Data->via_tree, screen, NULL, via_mask_callback, NULL);
-  r_search (PCB->Data->pad_tree, screen, NULL, pad_mask_callback, &side);
+  r_search (PCB->Data->pin_tree, gc->clip_box, NULL, pin_mask_callback, gc);
+  r_search (PCB->Data->via_tree, gc->clip_box, NULL, via_mask_callback, gc);
+  r_search (PCB->Data->pad_tree, gc->clip_box, NULL, pad_mask_callback, &info);
 
   if (thin)
     hid_draw_set_color (Output.pmGC, "erase");
   else
     {
-      DrawMaskBoardArea (HID_MASK_AFTER, screen);
-      hid_draw_use_mask (Output.fgGC, HID_MASK_OFF);
+      DrawMaskBoardArea (gc, HID_MASK_AFTER);
+      hid_draw_use_mask (gc, HID_MASK_OFF);
     }
 }
 
@@ -672,19 +686,19 @@ DrawMask (int side, const BoxType *screen)
  * draws solder paste layer for a given side of the board
  */
 void
-DrawPaste (int side, const BoxType *drawn_area)
+DrawPaste (hidGC gc, int side)
 {
-  hid_draw_set_color (Output.fgGC, PCB->ElementColor);
+  hid_draw_set_color (gc, PCB->ElementColor);
   ALLPAD_LOOP (PCB->Data);
   {
     if (ON_SIDE (pad, side))
-      dapi->draw_pad_paste (pad, NULL, NULL);
+      dapi->draw_pad_paste (gc, pad, NULL);
   }
   ENDALL_LOOP;
 }
 
 /* static */ void
-DrawRats (const BoxType *drawn_area)
+DrawRats (hidGC gc)
 {
   /*
    * XXX lesstif allows positive AND negative drawing in HID_MASK_CLEAR.
@@ -694,10 +708,10 @@ DrawRats (const BoxType *drawn_area)
   int can_mask = strcmp(gui->name, "lesstif") == 0;
 
   if (can_mask)
-    hid_draw_use_mask (Output.fgGC, HID_MASK_CLEAR);
-  r_search (PCB->Data->rat_tree, drawn_area, NULL, rat_callback, NULL);
+    hid_draw_use_mask (gc, HID_MASK_CLEAR);
+  r_search (PCB->Data->rat_tree, gc->clip_box, NULL, rat_callback, gc);
   if (can_mask)
-    hid_draw_use_mask (Output.fgGC, HID_MASK_OFF);
+    hid_draw_use_mask (gc, HID_MASK_OFF);
 }
 
 /* ---------------------------------------------------------------------------
@@ -705,7 +719,7 @@ DrawRats (const BoxType *drawn_area)
  * also draws the pins / pads / vias in this layer group.
  */
 void
-DrawLayerGroup (int group, const BoxType *drawn_area)
+DrawLayerGroup (hidGC gc, int group)
 {
   int i, rv = 1;
   int layernum;
@@ -721,13 +735,13 @@ DrawLayerGroup (int group, const BoxType *drawn_area)
           strcmp (Layer->Name, "route") == 0)
         rv = 0;
       if (layernum < max_copper_layer && Layer->On)
-        dapi->draw_layer (Layer, drawn_area, NULL);
+        dapi->draw_layer (gc, Layer, NULL);
     }
   if (n_entries > 1)
     rv = 1;
 
   if (rv && !gui->gui)
-    dapi->draw_ppv (group, drawn_area, NULL);
+    dapi->draw_ppv (gc, group, NULL);
 }
 
 static void
@@ -1234,11 +1248,11 @@ DrawObject (int type, void *ptr1, void *ptr2)
 }
 
 static void
-draw_element (ElementType *element)
+draw_element (hidGC gc, ElementType *element)
 {
-  draw_element_package (element);
-  draw_element_name (element);
-  draw_element_pins_and_pads (element);
+  draw_element_package (gc, element);
+  draw_element_name (gc, element);
+  draw_element_pins_and_pads (gc, element);
 }
 
 /* ---------------------------------------------------------------------------
@@ -1246,12 +1260,13 @@ draw_element (ElementType *element)
  */
 
 void
-hid_expose_callback (HID * hid, BoxType * region, void *item)
+hid_expose_callback (HID * hid, void *item)
 {
   HID *old_gui = gui;
+  hidGC gc;
 
   gui = hid;
-  Output.fgGC = hid_draw_make_gc (hid->graphics);
+  gc = hid_draw_make_gc (hid->graphics);
   Output.bgGC = hid_draw_make_gc (hid->graphics);
   Output.pmGC = hid_draw_make_gc (hid->graphics);
 
@@ -1261,13 +1276,13 @@ hid_expose_callback (HID * hid, BoxType * region, void *item)
   if (item)
     {
       doing_pinout = true;
-      draw_element ((ElementType *)item);
+      draw_element (gc, (ElementType *)item);
       doing_pinout = false;
     }
   else
-    DrawEverything (region);
+    DrawEverything (gc);
 
-  hid_draw_destroy_gc (Output.fgGC);
+  hid_draw_destroy_gc (gc);
   hid_draw_destroy_gc (Output.bgGC);
   hid_draw_destroy_gc (Output.pmGC);
   gui = old_gui;
diff --git a/src/draw.h b/src/draw.h
index a5a49ab..e49e39f 100644
--- a/src/draw.h
+++ b/src/draw.h
@@ -66,22 +66,22 @@ void EraseElementPinsAndPads (ElementType *);
 void EraseElementName (ElementType *);
 void EraseObject (int, void *, void *);
 
-void DrawLayerGroup (int side, const BoxType *drawn_area);
-void DrawPaste (int side, const BoxType *drawn_area);
-void DrawSilk (int side, const BoxType *drawn_area);
-void DrawMask (int side, const BoxType *drawn_area);
-void DrawHoles (bool draw_plated, bool draw_unplated, const BoxType *drawn_area);
-void PrintAssembly (int side, const BoxType *drawn_area);
+void DrawLayerGroup (hidGC gc, int side);
+void DrawPaste (hidGC gc, int side);
+void DrawSilk (hidGC gc, int side);
+void DrawMask (hidGC gc, int side);
+void DrawHoles (hidGC gc, bool draw_plated, bool draw_unplated);
+void PrintAssembly (hidGC gc, int side);
 
 /* TEMPORARY */
-void ClearPad (PadType *, bool);
-void DrawPinOrViaLowLevel (PinType *, bool);
-void DrawPlainPin (PinType *, bool);
-void DrawPlainVia (PinType *, bool);
-void DrawRegularText (LayerType *, TextType *);
-void DrawEMark (ElementType *, Coord, Coord, bool);
-void DrawHole (PinType *);
-void DrawRats (const BoxType *);
+//void ClearPad (hidGC gc, PadType *, bool);
+//void DrawPinOrViaLowLevel (hidGC gc, PinType *, bool);
+//void DrawPlainPin (hidGC gc, PinType *, bool);
+//void DrawPlainVia (hidGC gc, PinType *, bool);
+//void DrawRegularText (hidGC gc, LayerType *, TextType *);
+void DrawEMark (hidGC gc, ElementType *, Coord, Coord, bool);
+//void DrawHole (hidGC gc, PinType *);
+void DrawRats (hidGC gc);
 /* TEMPORARY */
 
 #endif
diff --git a/src/draw_funcs.c b/src/draw_funcs.c
index af411f7..b47e1ff 100644
--- a/src/draw_funcs.c
+++ b/src/draw_funcs.c
@@ -10,41 +10,41 @@
 void ghid_set_lock_effects (hidGC gc, AnyObjectType *object);
 
 static void
-draw_pin (PinType *pin, const BoxType *drawn_area, void *userdata)
+draw_pin (hidGC gc, PinType *pin, void *userdata)
 {
-  hid_draw_pcb_pv (Output.fgGC, pin, false);
+  hid_draw_pcb_pv (gc, pin, false);
 }
 
 static void
-draw_pin_mask (PinType *pin, const BoxType *drawn_area, void *userdata)
+draw_pin_mask (hidGC gc, PinType *pin, void *userdata)
 {
   hid_draw_pcb_pv (Output.pmGC, pin, true);
 }
 
 static void
-draw_via (PinType *via, const BoxType *drawn_area, void *userdata)
+draw_via (hidGC gc, PinType *via, void *userdata)
 {
-  hid_draw_pcb_pv (Output.fgGC, via, false);
+  hid_draw_pcb_pv (gc, via, false);
 }
 
 static void
-draw_via_mask (PinType *via, const BoxType *drawn_area, void *userdata)
+draw_via_mask (hidGC gc, PinType *via, void *userdata)
 {
   hid_draw_pcb_pv (Output.pmGC, via, true);
 }
 
 static void
-draw_hole (PinType *pv, const BoxType *drawn_area, void *userdata)
+draw_hole (hidGC gc, PinType *pv, void *userdata)
 {
   if (!TEST_FLAG (THINDRAWFLAG, PCB))
     hid_draw_fill_circle (Output.bgGC, pv->X, pv->Y, pv->DrillingHole / 2);
 
   if (TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG (HOLEFLAG, pv))
     {
-      hid_draw_set_line_cap (Output.fgGC, Round_Cap);
-      hid_draw_set_line_width (Output.fgGC, 0);
+      hid_draw_set_line_cap (gc, Round_Cap);
+      hid_draw_set_line_width (gc, 0);
 
-      hid_draw_arc (Output.fgGC, pv->X, pv->Y, pv->DrillingHole / 2, pv->DrillingHole / 2, 0, 360);
+      hid_draw_arc (gc, pv->X, pv->Y, pv->DrillingHole / 2, pv->DrillingHole / 2, 0, 360);
     }
 }
 
@@ -58,13 +58,13 @@ _draw_pad (hidGC gc, PadType *pad, bool clear, bool mask)
 }
 
 static void
-draw_pad (PadType *pad, const BoxType *drawn_area, void *userdata)
+draw_pad (hidGC gc, PadType *pad, void *userdata)
 {
-  _draw_pad (Output.fgGC, pad, false, false);
+  _draw_pad (gc, pad, false, false);
 }
 
 static void
-draw_pad_mask (PadType *pad, const BoxType *drawn_area, void *userdata)
+draw_pad_mask (hidGC gc, PadType *pad, void *userdata)
 {
   if (pad->Mask <= 0)
     return;
@@ -73,25 +73,25 @@ draw_pad_mask (PadType *pad, const BoxType *drawn_area, void *userdata)
 }
 
 static void
-draw_pad_paste (PadType *pad, const BoxType *drawn_area, void *userdata)
+draw_pad_paste (hidGC gc, PadType *pad, void *userdata)
 {
   if (TEST_FLAG (NOPASTEFLAG, pad) || pad->Mask <= 0)
     return;
 
   if (pad->Mask < pad->Thickness)
-    _draw_pad (Output.fgGC, pad, true, true);
+    _draw_pad (gc, pad, true, true);
   else
-    _draw_pad (Output.fgGC, pad, false, false);
+    _draw_pad (gc, pad, false, false);
 }
 
 static void
-draw_line (LineType *line, const BoxType *drawn_area, void *userdata)
+draw_line (hidGC gc, LineType *line, void *userdata)
 {
-  hid_draw_pcb_line (Output.fgGC, line);
+  hid_draw_pcb_line (gc, line);
 }
 
 static void
-draw_rat (RatType *rat, const BoxType *drawn_area, void *userdata)
+draw_rat (hidGC gc, RatType *rat, void *userdata)
 {
   if (Settings.RatThickness < 100)
     rat->Thickness = pixel_slop * Settings.RatThickness;
@@ -101,29 +101,29 @@ draw_rat (RatType *rat, const BoxType *drawn_area, void *userdata)
       int w = rat->Thickness;
 
       if (TEST_FLAG (THINDRAWFLAG, PCB))
-        hid_draw_set_line_width (Output.fgGC, 0);
+        hid_draw_set_line_width (gc, 0);
       else
-        hid_draw_set_line_width (Output.fgGC, w);
-      hid_draw_arc (Output.fgGC, rat->Point1.X, rat->Point1.Y, w * 2, w * 2, 0, 360);
+        hid_draw_set_line_width (gc, w);
+      hid_draw_arc (gc, rat->Point1.X, rat->Point1.Y, w * 2, w * 2, 0, 360);
     }
   else
-    hid_draw_pcb_line (Output.fgGC, (LineType *) rat);
+    hid_draw_pcb_line (gc, (LineType *) rat);
 }
 
 static void
-draw_arc (ArcType *arc, const BoxType *drawn_area, void *userdata)
+draw_arc (hidGC gc, ArcType *arc, void *userdata)
 {
-  hid_draw_pcb_arc (Output.fgGC, arc);
+  hid_draw_pcb_arc (gc, arc);
 }
 
 static void
-draw_poly (PolygonType *polygon, const BoxType *drawn_area, void *userdata)
+draw_poly (hidGC gc, PolygonType *polygon, void *userdata)
 {
-  hid_draw_pcb_polygon (Output.fgGC, polygon, drawn_area);
+  hid_draw_pcb_polygon (gc, polygon);
 }
 
 static void
-set_object_color (AnyObjectType *obj, char *warn_color, char *selected_color,
+set_object_color (hidGC gc, AnyObjectType *obj, char *warn_color, char *selected_color,
                   char *connected_color, char *found_color, char *normal_color)
 {
   char *color;
@@ -134,142 +134,153 @@ set_object_color (AnyObjectType *obj, char *warn_color, char *selected_color,
   else if (found_color     != NULL && TEST_FLAG (FOUNDFLAG,     obj)) color = found_color;
   else                                                                color = normal_color;
 
-  hid_draw_set_color (Output.fgGC, color);
+  hid_draw_set_color (gc, color);
 }
 
 static void
-set_layer_object_color (LayerType *layer, AnyObjectType *obj)
+set_layer_object_color (hidGC gc, LayerType *layer, AnyObjectType *obj)
 {
-  set_object_color (obj, NULL, layer->SelectedColor, PCB->ConnectedColor, PCB->FoundColor, layer->Color);
+  set_object_color (gc, obj, NULL, layer->SelectedColor, PCB->ConnectedColor, PCB->FoundColor, layer->Color);
 }
 
+struct layer_info {
+  hidGC gc;
+  LayerType *layer;
+};
+
 static int
 line_callback (const BoxType * b, void *cl)
 {
-  LayerType *layer = cl;
   LineType *line = (LineType *)b;
+  struct layer_info *info = cl;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)line);
-  set_layer_object_color (layer, (AnyObjectType *) line);
-  dapi->draw_line (line, NULL, NULL);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *)line);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) line);
+  dapi->draw_line (info->gc, line, NULL);
   return 1;
 }
 
 static int
 arc_callback (const BoxType * b, void *cl)
 {
-  LayerType *layer = cl;
   ArcType *arc = (ArcType *)b;
+  struct layer_info *info = cl;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)arc);
-  set_layer_object_color (layer, (AnyObjectType *) arc);
-  dapi->draw_arc (arc, NULL, NULL);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *)arc);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) arc);
+  dapi->draw_arc (info->gc, arc, NULL);
   return 1;
 }
 
-struct poly_info {
-  const const BoxType *drawn_area;
-  LayerType *layer;
-};
-
 static int
 poly_callback (const BoxType * b, void *cl)
 {
-  struct poly_info *i = cl;
   PolygonType *polygon = (PolygonType *)b;
+  struct layer_info *info = cl;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)polygon);
-  set_layer_object_color (i->layer, (AnyObjectType *) polygon);
-  dapi->draw_poly (polygon, i->drawn_area, NULL);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *)polygon);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) polygon);
+  dapi->draw_poly (info->gc, polygon, NULL);
   return 1;
 }
 
 static int
 text_callback (const BoxType * b, void *cl)
 {
-  LayerType *layer = cl;
   TextType *text = (TextType *)b;
+  struct layer_info *info = cl;
   int min_silk_line;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)text);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *)text);
   if (TEST_FLAG (SELECTEDFLAG, text))
-    hid_draw_set_color (Output.fgGC, layer->SelectedColor);
+    hid_draw_set_color (info->gc, info->layer->SelectedColor);
   else
-    hid_draw_set_color (Output.fgGC, layer->Color);
-  if (layer == &PCB->Data->SILKLAYER ||
-      layer == &PCB->Data->BACKSILKLAYER)
+    hid_draw_set_color (info->gc, info->layer->Color);
+  if (info->layer == &PCB->Data->SILKLAYER ||
+      info->layer == &PCB->Data->BACKSILKLAYER)
     min_silk_line = PCB->minSlk;
   else
     min_silk_line = PCB->minWid;
-  hid_draw_pcb_text (Output.fgGC, text, min_silk_line);
+  hid_draw_pcb_text (info->gc, text, min_silk_line);
   return 1;
 }
 
 static void
-set_pv_inlayer_color (PinType *pv, LayerType *layer, int type)
+set_pv_inlayer_color (hidGC gc, PinType *pv, LayerType *layer, int type)
 {
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pv);
-  if (TEST_FLAG (WARNFLAG, pv))          hid_draw_set_color (Output.fgGC, PCB->WarnColor);
-  else if (TEST_FLAG (SELECTEDFLAG, pv)) hid_draw_set_color (Output.fgGC, (type == VIA_TYPE) ? PCB->ViaSelectedColor
-                                                                                             : PCB->PinSelectedColor);
-  else if (TEST_FLAG (FOUNDFLAG, pv))    hid_draw_set_color (Output.fgGC, PCB->ConnectedColor);
-  else                                   hid_draw_set_color (Output.fgGC, layer->Color);
+  ghid_set_lock_effects (gc, (AnyObjectType *)pv);
+  if (TEST_FLAG (WARNFLAG, pv))          hid_draw_set_color (gc, PCB->WarnColor);
+  else if (TEST_FLAG (SELECTEDFLAG, pv)) hid_draw_set_color (gc, (type == VIA_TYPE) ? PCB->ViaSelectedColor
+                                                                                    : PCB->PinSelectedColor);
+  else if (TEST_FLAG (FOUNDFLAG, pv))    hid_draw_set_color (gc, PCB->ConnectedColor);
+  else                                   hid_draw_set_color (gc, layer->Color);
 }
 
 static int
 pin_inlayer_callback (const BoxType * b, void *cl)
 {
-  set_pv_inlayer_color ((PinType *)b, cl, PIN_TYPE);
-  dapi->draw_pin ((PinType *)b, NULL, NULL);
+  struct layer_info *info = cl;
+
+  set_pv_inlayer_color (info->gc, (PinType *)b, info->layer, PIN_TYPE);
+  dapi->draw_pin (info->gc, (PinType *)b, NULL);
   return 1;
 }
 
 static int
 via_inlayer_callback (const BoxType * b, void *cl)
 {
-  set_pv_inlayer_color ((PinType *)b, cl, VIA_TYPE);
-  dapi->draw_via ((PinType *)b, NULL, NULL);
+  struct layer_info *info = cl;
+
+  set_pv_inlayer_color (info->gc, (PinType *)b, info->layer, VIA_TYPE);
+  dapi->draw_via (info->gc, (PinType *)b, NULL);
   return 1;
 }
 
+struct side_info {
+  hidGC gc;
+  LayerType *layer;
+  int side;
+};
+
 static int
 pad_inlayer_callback (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *)b;
-  LayerType *layer = cl;
-  int bottom_group = GetLayerGroupNumberBySide (BOTTOM_SIDE);
-  int group = GetLayerGroupNumberByPointer (layer);
+  struct side_info *info = cl;
 
-  int side = (group == bottom_group) ? BOTTOM_SIDE : TOP_SIDE;
-
-  if (ON_SIDE (pad, side))
+  if (ON_SIDE (pad, info->side))
     {
-      ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pad);
-      if (TEST_FLAG (WARNFLAG, pad))          hid_draw_set_color (Output.fgGC, PCB->WarnColor);
-      else if (TEST_FLAG (SELECTEDFLAG, pad)) hid_draw_set_color (Output.fgGC, PCB->PinSelectedColor);
-      else if (TEST_FLAG (FOUNDFLAG, pad))    hid_draw_set_color (Output.fgGC, PCB->ConnectedColor);
-      else                                    hid_draw_set_color (Output.fgGC, layer->Color);
+      ghid_set_lock_effects (info->gc, (AnyObjectType *)pad);
+      if (TEST_FLAG (WARNFLAG, pad))          hid_draw_set_color (info->gc, PCB->WarnColor);
+      else if (TEST_FLAG (SELECTEDFLAG, pad)) hid_draw_set_color (info->gc, PCB->PinSelectedColor);
+      else if (TEST_FLAG (FOUNDFLAG, pad))    hid_draw_set_color (info->gc, PCB->ConnectedColor);
+      else                                    hid_draw_set_color (info->gc, info->layer->Color);
 
-      dapi->draw_pad (pad, NULL, NULL);
+      dapi->draw_pad (info->gc, pad, NULL);
     }
   return 1;
 }
 
+struct hole_info {
+  hidGC gc;
+  int plated;
+};
+
 static int
 pin_hole_callback (const BoxType * b, void *cl)
 {
   PinType *pin = (PinType *)b;
-  int plated = cl ? *(int *) cl : -1;
+  struct hole_info *info = cl;
 
-  if ((plated == 0 && !TEST_FLAG (HOLEFLAG, pin)) ||
-      (plated == 1 &&  TEST_FLAG (HOLEFLAG, pin)))
+  if ((info->plated == 0 && !TEST_FLAG (HOLEFLAG, pin)) ||
+      (info->plated == 1 &&  TEST_FLAG (HOLEFLAG, pin)))
     return 1;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pin);
-  set_object_color ((AnyObjectType *) pin, PCB->WarnColor,
+  ghid_set_lock_effects (info->gc, (AnyObjectType *)pin);
+  set_object_color (info->gc, (AnyObjectType *) pin, PCB->WarnColor,
                     PCB->PinSelectedColor, NULL, NULL, Settings.BlackColor);
 
-  dapi->draw_pin_hole (pin, NULL, NULL);
+  dapi->draw_pin_hole (info->gc, pin, NULL);
   return 1;
 }
 
@@ -277,41 +288,45 @@ static int
 via_hole_callback (const BoxType * b, void *cl)
 {
   PinType *via = (PinType *)b;
-  int plated = cl ? *(int *) cl : -1;
+  struct hole_info *info = cl;
 
-  if ((plated == 0 && !TEST_FLAG (HOLEFLAG, via)) ||
-      (plated == 1 &&  TEST_FLAG (HOLEFLAG, via)))
+  if ((info->plated == 0 && !TEST_FLAG (HOLEFLAG, via)) ||
+      (info->plated == 1 &&  TEST_FLAG (HOLEFLAG, via)))
     return 1;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)via);
-  set_object_color ((AnyObjectType *) via, PCB->WarnColor,
+  ghid_set_lock_effects (info->gc, (AnyObjectType *)via);
+  set_object_color (info->gc, (AnyObjectType *) via, PCB->WarnColor,
                     PCB->ViaSelectedColor, NULL, NULL, Settings.BlackColor);
 
-  dapi->draw_via_hole (via, NULL, NULL);
+  dapi->draw_via_hole (info->gc, via, NULL);
   return 1;
 }
 
 static int
 pin_callback (const BoxType * b, void *cl)
 {
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)b);
-  set_object_color ((AnyObjectType *)b,
+  hidGC gc = cl;
+
+  ghid_set_lock_effects (gc, (AnyObjectType *)b);
+  set_object_color (gc, (AnyObjectType *)b,
                     PCB->WarnColor, PCB->PinSelectedColor,
                     PCB->ConnectedColor, PCB->FoundColor, PCB->PinColor);
 
-  dapi->draw_pin ((PinType *)b, NULL, NULL);
+  dapi->draw_pin (gc, (PinType *)b, NULL);
   return 1;
 }
 
 static int
 via_callback (const BoxType * b, void *cl)
 {
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)b);
-  set_object_color ((AnyObjectType *)b,
+  hidGC gc = cl;
+
+  ghid_set_lock_effects (gc, (AnyObjectType *)b);
+  set_object_color (gc, (AnyObjectType *)b,
                     PCB->WarnColor, PCB->ViaSelectedColor,
                     PCB->ConnectedColor, PCB->FoundColor, PCB->ViaColor);
 
-  dapi->draw_via ((PinType *)b, NULL, NULL);
+  dapi->draw_via (gc, (PinType *)b, NULL);
   return 1;
 }
 
@@ -319,91 +334,106 @@ static int
 pad_callback (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *) b;
-  int *side = cl;
+  struct side_info *info = cl;
 
-  if (ON_SIDE (pad, *side))
+  if (ON_SIDE (pad, info->side))
     {
-      ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pad);
-      set_object_color ((AnyObjectType *)pad, PCB->WarnColor,
+      ghid_set_lock_effects (info->gc, (AnyObjectType *)pad);
+      set_object_color (info->gc, (AnyObjectType *)pad, PCB->WarnColor,
                         PCB->PinSelectedColor, PCB->ConnectedColor, PCB->FoundColor,
                         FRONT (pad) ? PCB->PinColor : PCB->InvisibleObjectsColor);
 
-      dapi->draw_pad (pad, NULL, NULL);
+      dapi->draw_pad (info->gc, pad, NULL);
     }
   return 1;
 }
 
 static void
-draw_ppv (int group, const BoxType *drawn_area, void *userdata)
+draw_ppv (hidGC gc, int group, void *userdata)
 {
   int top_group = GetLayerGroupNumberBySide (TOP_SIDE);
   int bottom_group = GetLayerGroupNumberBySide (BOTTOM_SIDE);
-  int side;
 
   if (PCB->PinOn || !gui->gui)
     {
+      struct side_info info;
+
       /* draw element pins */
-      r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_callback, NULL);
+      r_search (PCB->Data->pin_tree, gc->clip_box, NULL, pin_callback, gc);
+
+      info.gc = gc;
+      info.layer = NULL; /* Nasty, but saves creating a load of different info types */
 
       /* draw element pads */
       if (group == top_group)
         {
-          side = TOP_SIDE;
-          r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, &side);
+          info.side = TOP_SIDE;
+          r_search (PCB->Data->pad_tree, gc->clip_box, NULL, pad_callback, &info);
         }
 
       if (group == bottom_group)
         {
-          side = BOTTOM_SIDE;
-          r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, &side);
+          info.side = BOTTOM_SIDE;
+          r_search (PCB->Data->pad_tree, gc->clip_box, NULL, pad_callback, &info);
         }
     }
 
   /* draw vias */
   if (PCB->ViaOn)
-    r_search (PCB->Data->via_tree, drawn_area, NULL, via_callback, NULL);
+    r_search (PCB->Data->via_tree, gc->clip_box, NULL, via_callback, gc);
 
-  dapi->draw_holes (-1, drawn_area, NULL);
+  dapi->draw_holes (gc, -1, NULL);
 }
 
 static void
-draw_holes (int plated, const BoxType *drawn_area, void *userdata)
+draw_holes (hidGC gc, int plated, void *userdata)
 {
+  struct hole_info info;
+
+  info.gc = gc;
+  info.plated = plated;
+
   if (PCB->PinOn)
-    r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_hole_callback, &plated);
+    r_search (PCB->Data->pin_tree, gc->clip_box, NULL, pin_hole_callback, &info);
   if (PCB->ViaOn)
-    r_search (PCB->Data->via_tree, drawn_area, NULL, via_hole_callback, &plated);
+    r_search (PCB->Data->via_tree, gc->clip_box, NULL, via_hole_callback, &info);
 }
 
 static void
-draw_layer (LayerType *layer, const BoxType *drawn_area, void *userdata)
+draw_layer (hidGC gc, LayerType *layer, void *userdata)
 {
   int top_group = GetLayerGroupNumberBySide (TOP_SIDE);
   int bottom_group = GetLayerGroupNumberBySide (BOTTOM_SIDE);
   int layer_num = GetLayerNumber (PCB->Data, layer);
   int group = GetLayerGroupNumberByPointer (layer);
-  struct poly_info info = {drawn_area, layer};
   bool is_outline;
+  struct hole_info h_info;
+  struct layer_info l_info;
+
+  h_info.gc = gc;
+  h_info.plated = -1; /* Draw both plated and unplated holes */
+  l_info.gc = gc;
+  l_info.layer = layer;
 
   is_outline = strcmp (layer->Name, "outline") == 0 ||
                strcmp (layer->Name, "route") == 0;
 
   if (layer_num < max_copper_layer && !is_outline)
     {
-      r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_hole_callback, NULL);
-      r_search (PCB->Data->via_tree, drawn_area, NULL, via_hole_callback, NULL);
+      r_search (PCB->Data->pin_tree, gc->clip_box, NULL, pin_hole_callback, &h_info);
+      r_search (PCB->Data->via_tree, gc->clip_box, NULL, via_hole_callback, &h_info);
     }
 
   /* print the non-clearing polys */
-  r_search (layer->polygon_tree, drawn_area, NULL, poly_callback, &info);
+  r_search (layer->polygon_tree, gc->clip_box, NULL, poly_callback, &l_info);
 
   if (TEST_FLAG (CHECKPLANESFLAG, PCB))
     return;
 
   /* draw all visible lines this layer */
-  r_search (layer->line_tree, drawn_area, NULL, line_callback, layer);
-  r_search (layer->arc_tree,  drawn_area, NULL, arc_callback,  layer);
-  r_search (layer->text_tree, drawn_area, NULL, text_callback, layer);
+  r_search (layer->line_tree, gc->clip_box, NULL, line_callback, &l_info);
+  r_search (layer->arc_tree,  gc->clip_box, NULL, arc_callback,  &l_info);
+  r_search (layer->text_tree, gc->clip_box, NULL, text_callback, &l_info);
 
   /* We should check for gui->gui here, but it's kinda cool seeing the
      auto-outline magically disappear when you first add something to
@@ -413,9 +443,9 @@ draw_layer (LayerType *layer, const BoxType *drawn_area, void *userdata)
     {
       if (IsLayerEmpty (layer))
         {
-          hid_draw_set_color (Output.fgGC, layer->Color);
-          hid_draw_set_line_width (Output.fgGC, PCB->minWid);
-          hid_draw_rect (Output.fgGC, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
+          hid_draw_set_color (gc, layer->Color);
+          hid_draw_set_line_width (gc, PCB->minWid);
+          hid_draw_rect (gc, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
         }
       return;
     }
@@ -428,17 +458,22 @@ draw_layer (LayerType *layer, const BoxType *drawn_area, void *userdata)
   if (!gui->gui)
     return;
 
-  r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_inlayer_callback, layer);
+  r_search (PCB->Data->pin_tree, gc->clip_box, NULL, pin_inlayer_callback, &l_info);
 
   /* draw element pads */
-  if (group == top_group)
-    r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_inlayer_callback, layer);
+  if (group == top_group ||
+      group == bottom_group)
+    {
+      struct side_info s_info;
 
-  if (group == bottom_group)
-    r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_inlayer_callback, layer);
+      s_info.gc = gc;
+      s_info.layer = layer;
+      s_info.side = (group == bottom_group) ? BOTTOM_SIDE : TOP_SIDE;
+      r_search (PCB->Data->pad_tree, gc->clip_box, NULL, pad_inlayer_callback, &s_info);
+    }
 
   /* draw vias */
-  r_search (PCB->Data->via_tree, drawn_area, NULL, via_inlayer_callback, layer);
+  r_search (PCB->Data->via_tree, gc->clip_box, NULL, via_inlayer_callback, &l_info);
 }
 
 struct draw_funcs d_f = {
diff --git a/src/draw_funcs.h b/src/draw_funcs.h
index ba4982d..677b397 100644
--- a/src/draw_funcs.h
+++ b/src/draw_funcs.h
@@ -1,20 +1,20 @@
 struct draw_funcs {
-  void (*draw_pin)       (PinType *,     const BoxType *, void *);
-  void (*draw_pin_mask)  (PinType *,     const BoxType *, void *);
-  void (*draw_pin_hole)  (PinType *,     const BoxType *, void *);
-  void (*draw_via)       (PinType *,     const BoxType *, void *);
-  void (*draw_via_mask)  (PinType *,     const BoxType *, void *);
-  void (*draw_via_hole)  (PinType *,     const BoxType *, void *);
-  void (*draw_pad)       (PadType *,     const BoxType *, void *);
-  void (*draw_pad_mask)  (PadType *,     const BoxType *, void *);
-  void (*draw_pad_paste) (PadType *,     const BoxType *, void *);
-  void (*draw_line)      (LineType *,    const BoxType *, void *);
-  void (*draw_rat)       (RatType *,     const BoxType *, void *);
-  void (*draw_arc)       (ArcType *,     const BoxType *, void *);
-  void (*draw_poly)      (PolygonType *, const BoxType *, void *);
-  void (*draw_ppv)       (int,           const BoxType *, void *);
-  void (*draw_holes)     (int,           const BoxType *, void *);
-  void (*draw_layer)     (LayerType *,   const BoxType *, void *);
+  void (*draw_pin)       (hidGC, PinType *,     void *);
+  void (*draw_pin_mask)  (hidGC, PinType *,     void *);
+  void (*draw_pin_hole)  (hidGC, PinType *,     void *);
+  void (*draw_via)       (hidGC, PinType *,     void *);
+  void (*draw_via_mask)  (hidGC, PinType *,     void *);
+  void (*draw_via_hole)  (hidGC, PinType *,     void *);
+  void (*draw_pad)       (hidGC, PadType *,     void *);
+  void (*draw_pad_mask)  (hidGC, PadType *,     void *);
+  void (*draw_pad_paste) (hidGC, PadType *,     void *);
+  void (*draw_line)      (hidGC, LineType *,    void *);
+  void (*draw_rat)       (hidGC, RatType *,     void *);
+  void (*draw_arc)       (hidGC, ArcType *,     void *);
+  void (*draw_poly)      (hidGC, PolygonType *, void *);
+  void (*draw_ppv)       (hidGC, int,           void *);
+  void (*draw_holes)     (hidGC, int,           void *);
+  void (*draw_layer)     (hidGC, LayerType *,   void *);
 };
 
 extern struct draw_funcs *dapi;
diff --git a/src/global.h b/src/global.h
index b36aebf..050d804 100644
--- a/src/global.h
+++ b/src/global.h
@@ -182,8 +182,7 @@ typedef struct
  */
 typedef struct			/* holds information about output window */
 {
-  hidGC bgGC,			/* background and foreground; */
-    fgGC,			/* changed from some routines */
+  hidGC bgGC,			/* background GC */
     pmGC;			/* depth 1 pixmap GC to store clip */
 }
 OutputType;
diff --git a/src/hid.h b/src/hid.h
index 5ff7814..25263ff 100644
--- a/src/hid.h
+++ b/src/hid.h
@@ -314,10 +314,10 @@ typedef enum
        layer groups, you may pass NULL for name to have a name fetched
        from the PCB struct.  The EMPTY argument is a hint - if set, the
        layer is empty, if zero it may be non-empty.  */
-    int (*set_layer) (const char *name_, int group_, int _empty);
+    int (*set_layer) (hidGC gc, const char *name_, int group_, int _empty);
 
     /* Tell the GUI the layer last selected has been finished with */
-    void (*end_layer) (void);
+    void (*end_layer) (hidGC gc);
 
 
     HID_DRAW *graphics;
@@ -500,13 +500,13 @@ typedef enum
      * May be implemented as a NOOP if the GUI has chosen to send the
      * debug drawing directly to the screen.
      */
-    void (*flush_debug_draw)   (void);
+    void (*flush_debug_draw)   (hidGC gc);
 
     /* When finished, the user must inform the GUI to clean up resources
      *
      * Any remaining rendering will be flushed to the screen.
      */
-    void (*finish_debug_draw)  (void);
+    void (*finish_debug_draw)  (hidGC gc);
 
     /* Notification to the GUI around saving the PCB file.
      *
@@ -561,7 +561,7 @@ typedef enum
    Do *not* assume that the hid that is passed is the GUI hid.  This
    callback is also used for printing and exporting. */
   struct BoxType;
-  void hid_expose_callback (HID * hid_, struct BoxType *region_, void *item_);
+  void hid_expose_callback (HID * hid_, void *item_);
 
 /* This is initially set to a "no-gui" gui, and later reset by
    main. hid_expose_callback also temporarily set it for drawing. */
diff --git a/src/hid/batch/batch.c b/src/hid/batch/batch.c
index e164bef..c121032 100644
--- a/src/hid/batch/batch.c
+++ b/src/hid/batch/batch.c
@@ -160,7 +160,7 @@ batch_invalidate_all (void)
 }
 
 static int
-batch_set_layer (const char *name, int idx, int empty)
+batch_set_layer (hidGC gc, const char *name, int idx, int empty)
 {
   return 0;
 }
diff --git a/src/hid/common/draw_helpers.c b/src/hid/common/draw_helpers.c
index 670dde0..e6de055 100644
--- a/src/hid/common/draw_helpers.c
+++ b/src/hid/common/draw_helpers.c
@@ -7,6 +7,20 @@
 #include "draw_helpers.h"
 
 
+/* Takes a copy of clip_box so we own it */
+void
+common_set_clip_box (hidGC gc, BoxType *clip_box)
+{
+  free (gc->clip_box);
+  gc->clip_box = NULL;
+
+  if (clip_box == NULL)
+    return;
+
+  gc->clip_box = malloc (sizeof (BoxType));
+  *gc->clip_box = *clip_box;
+}
+
 static void
 common_draw_pcb_line (hidGC gc, LineType *line)
 {
@@ -189,7 +203,7 @@ fill_contour_cb (PLINE *pl, void *user_data)
 }
 
 static void
-fill_clipped_contour (hidGC gc, PLINE *pl, const BoxType *clip_box)
+fill_clipped_contour (hidGC gc, PLINE *pl)
 {
   PLINE *pl_copy;
   POLYAREA *clip_poly;
@@ -198,8 +212,8 @@ fill_clipped_contour (hidGC gc, PLINE *pl, const BoxType *clip_box)
   POLYAREA *draw_piece;
   int x;
 
-  clip_poly = RectPoly (clip_box->X1, clip_box->X2,
-                        clip_box->Y1, clip_box->Y2);
+  clip_poly = RectPoly (gc->clip_box->X1, gc->clip_box->X2,
+                        gc->clip_box->Y1, gc->clip_box->Y2);
   poly_CopyContour (&pl_copy, pl);
   piece_poly = poly_Create ();
   poly_InclContour (piece_poly, pl_copy);
@@ -223,20 +237,20 @@ fill_clipped_contour (hidGC gc, PLINE *pl, const BoxType *clip_box)
  */
 #define BOUNDS_INSIDE_CLIP_THRESHOLD 0.5
 static int
-should_compute_no_holes (PolygonType *poly, const BoxType *clip_box)
+should_compute_no_holes (hidGC gc, PolygonType *poly)
 {
   Coord x1, x2, y1, y2;
   double poly_bounding_area;
   double clipped_poly_area;
 
   /* If there is no passed clip box, compute the whole thing */
-  if (clip_box == NULL)
+  if (gc->clip_box == NULL)
     return 1;
 
-  x1 = MAX (poly->BoundingBox.X1, clip_box->X1);
-  x2 = MIN (poly->BoundingBox.X2, clip_box->X2);
-  y1 = MAX (poly->BoundingBox.Y1, clip_box->Y1);
-  y2 = MIN (poly->BoundingBox.Y2, clip_box->Y2);
+  x1 = MAX (poly->BoundingBox.X1, gc->clip_box->X1);
+  x2 = MIN (poly->BoundingBox.X2, gc->clip_box->X2);
+  y1 = MAX (poly->BoundingBox.Y1, gc->clip_box->Y1);
+  y2 = MIN (poly->BoundingBox.Y2, gc->clip_box->Y2);
 
   /* Check if the polygon is outside the clip box */
   if ((x2 <= x1) || (y2 <= y1))
@@ -255,15 +269,15 @@ should_compute_no_holes (PolygonType *poly, const BoxType *clip_box)
 #undef BOUNDS_INSIDE_CLIP_THRESHOLD
 
 void
-common_gui_draw_pcb_polygon (hidGC gc, PolygonType *polygon, const BoxType *clip_box)
+common_gui_draw_pcb_polygon (hidGC gc, PolygonType *polygon)
 {
   if (polygon->Clipped == NULL)
     return;
 
   if (TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG (THINDRAWPOLYFLAG, PCB))
-    hid_draw__thin_pcb_polygon (gc, polygon, clip_box);
+    hid_draw__thin_pcb_polygon (gc, polygon);
   else
-    hid_draw__fill_pcb_polygon (gc, polygon, clip_box);
+    hid_draw__fill_pcb_polygon (gc, polygon);
 
   /* If checking planes, thin-draw any pieces which have been clipped away */
   if (TEST_FLAG (CHECKPLANESFLAG, PCB) && !TEST_FLAG (FULLPOLYFLAG, polygon))
@@ -273,12 +287,12 @@ common_gui_draw_pcb_polygon (hidGC gc, PolygonType *polygon, const BoxType *clip
       for (poly.Clipped = polygon->Clipped->f;
            poly.Clipped != polygon->Clipped;
            poly.Clipped = poly.Clipped->f)
-        hid_draw__thin_pcb_polygon (gc, &poly, clip_box);
+        hid_draw__thin_pcb_polygon (gc, &poly);
     }
 }
 
 void
-common_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+common_fill_pcb_polygon (hidGC gc, PolygonType *poly)
 {
   if (poly->Clipped == NULL)
     return;
@@ -289,10 +303,10 @@ common_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
        * NoHoles version and cache it for later rendering, otherwise
        * just compute what we need to render now.
        */
-      if (should_compute_no_holes (poly, clip_box))
+      if (should_compute_no_holes (gc, poly))
         ComputeNoHoles (poly);
       else
-        NoHolesPolygonDicer (poly, clip_box, fill_contour_cb, gc);
+        NoHolesPolygonDicer (poly, gc->clip_box, fill_contour_cb, gc);
     }
   if (poly->NoHolesValid && poly->NoHoles)
     {
@@ -300,10 +314,10 @@ common_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
 
       for (pl = poly->NoHoles; pl != NULL; pl = pl->next)
         {
-          if (clip_box == NULL)
+          if (gc->clip_box == NULL)
             fill_contour (gc, pl);
           else
-            fill_clipped_contour (gc, pl, clip_box);
+            fill_clipped_contour (gc, pl);
         }
     }
 
@@ -316,7 +330,7 @@ common_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
       for (p.Clipped = poly->Clipped->f;
            p.Clipped != poly->Clipped;
            p.Clipped = p.Clipped->f)
-        NoHolesPolygonDicer (&p, clip_box, fill_contour_cb, gc);
+        NoHolesPolygonDicer (&p, gc->clip_box, fill_contour_cb, gc);
     }
 }
 
@@ -329,14 +343,13 @@ thindraw_hole_cb (PLINE *pl, void *user_data)
 }
 
 void
-common_thindraw_pcb_polygon (hidGC gc, PolygonType *poly,
-                             const BoxType *clip_box)
+common_thindraw_pcb_polygon (hidGC gc, PolygonType *poly)
 {
   if (poly->Clipped == NULL)
     return;
 
   thindraw_contour (gc, poly->Clipped->contours);
-  PolygonHoles (poly, clip_box, thindraw_hole_cb, gc);
+  PolygonHoles (poly, gc->clip_box, thindraw_hole_cb, gc);
 
   /* Draw other parts of the polygon if fullpoly flag is set */
   if (TEST_FLAG (FULLPOLYFLAG, poly))
@@ -348,7 +361,7 @@ common_thindraw_pcb_polygon (hidGC gc, PolygonType *poly,
            p.Clipped = p.Clipped->f)
         {
           thindraw_contour (gc, p.Clipped->contours);
-          PolygonHoles (&p, clip_box, thindraw_hole_cb, gc);
+          PolygonHoles (&p, gc->clip_box, thindraw_hole_cb, gc);
         }
     }
 }
diff --git a/src/hid/common/draw_helpers.h b/src/hid/common/draw_helpers.h
index 4c4a5bc..fe09c80 100644
--- a/src/hid/common/draw_helpers.h
+++ b/src/hid/common/draw_helpers.h
@@ -1,6 +1,7 @@
-void common_gui_draw_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box);
-void common_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box);
-void common_thindraw_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box);
+void common_set_clip_box (hidGC gc, BoxType *clip_box);
+void common_gui_draw_pcb_polygon (hidGC gc, PolygonType *poly);
+void common_fill_pcb_polygon (hidGC gc, PolygonType *poly);
+void common_thindraw_pcb_polygon (hidGC gc, PolygonType *poly);
 void common_gui_draw_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask);
 void common_fill_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask);
 void common_thindraw_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask);
diff --git a/src/hid/common/extents.c b/src/hid/common/extents.c
index af3f33b..cee9d37 100644
--- a/src/hid/common/extents.c
+++ b/src/hid/common/extents.c
@@ -29,7 +29,7 @@ typedef struct extents_gc_struct
 } *extentsGC;
 
 static int
-extents_set_layer (const char *name, int group, int empty)
+extents_set_layer (hidGC gc, const char *name, int group, int empty)
 {
   int idx = group;
   if (idx >= 0 && idx < max_group)
@@ -208,11 +208,15 @@ hid_extents_init (void)
 BoxType *
 hid_get_extents (void *item)
 {
+  hidGC gc;
   BoxType region;
 
   /* As this isn't a real "HID", we need to ensure we are initialised. */
   hid_extents_init ();
 
+#warning NULL gc
+  gc = NULL;
+
   box.X1 = COORD_MAX;
   box.Y1 = COORD_MAX;
   box.X2 = -COORD_MAX - 1;
@@ -222,7 +226,9 @@ hid_get_extents (void *item)
   region.Y1 = -COORD_MAX - 1;
   region.X2 = COORD_MAX;
   region.Y2 = COORD_MAX;
-  hid_expose_callback (&extents_hid, &region, item);
+
+  common_set_clip_box (gc, &region);
+  hid_expose_callback (&extents_hid, item);
 
   return &box;
 }
diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index e6b1eaf..77d8a42 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -294,7 +294,7 @@ hidgl_set_depth (hidGC gc, float depth)
 }
 
 void
-hidgl_draw_grid (hidGC gc, BoxType *drawn_area)
+hidgl_draw_grid (hidGC gc)
 {
   hidglGC hidgl_gc = (hidglGC)gc;
 
@@ -306,10 +306,10 @@ hidgl_draw_grid (hidGC gc, BoxType *drawn_area)
   if (!Settings.DrawGrid)
     return;
 
-  x1 = GridFit (MAX (0, drawn_area->X1), PCB->Grid, PCB->GridOffsetX);
-  y1 = GridFit (MAX (0, drawn_area->Y1), PCB->Grid, PCB->GridOffsetY);
-  x2 = GridFit (MIN (PCB->MaxWidth,  drawn_area->X2), PCB->Grid, PCB->GridOffsetX);
-  y2 = GridFit (MIN (PCB->MaxHeight, drawn_area->Y2), PCB->Grid, PCB->GridOffsetY);
+  x1 = GridFit (MAX (0, gc->clip_box->X1), PCB->Grid, PCB->GridOffsetX);
+  y1 = GridFit (MAX (0, gc->clip_box->Y1), PCB->Grid, PCB->GridOffsetY);
+  x2 = GridFit (MIN (PCB->MaxWidth,  gc->clip_box->X2), PCB->Grid, PCB->GridOffsetX);
+  y2 = GridFit (MIN (PCB->MaxHeight, gc->clip_box->Y2), PCB->Grid, PCB->GridOffsetY);
 
   if (x1 > x2)
     {
@@ -753,6 +753,7 @@ hidgl_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
 
   myFreeCombined ();
   free (vertices);
+  tesselator_gc = NULL;
 }
 
 static inline void
@@ -913,7 +914,7 @@ polygon_contains_user_holes (PolygonType *polygon)
 }
 
 static void
-fill_polyarea (hidGC gc, POLYAREA *pa, const BoxType *clip_box, bool use_new_stencil)
+fill_polyarea (hidGC gc, POLYAREA *pa, bool use_new_stencil)
 {
   hidglGC hidgl_gc = (hidglGC)gc;
   hidgl_instance *hidgl = hidgl_gc->hidgl;
@@ -970,20 +971,19 @@ fill_polyarea (hidGC gc, POLYAREA *pa, const BoxType *clip_box, bool use_new_ste
 
   /* Drawing operations now set our reference bit in the stencil buffer */
 
-  r_search (pa->contour_tree, clip_box, NULL, do_hole, gc);
+  r_search (pa->contour_tree, gc->clip_box, NULL, do_hole, gc);
   hidgl_flush_triangles (hidgl);
 
-  glPopAttrib ();                               /* Restore the colour and stencil buffer write-mask etc.. */
-  glPushAttrib (GL_STENCIL_BUFFER_BIT);         /* Save the stencil op and function */
-  glEnable (GL_STENCIL_TEST);                   /* Enable the stencil test, just in case it wasn't already on */
-
-  glStencilOp (GL_KEEP, GL_KEEP, GL_INVERT);    /* This allows us to toggle the bit on the subcompositing bitplane */
-                                                /* If the stencil test has passed, we know that bit is 0, so we're */
-                                                /* effectively just setting it to 1. */
+  glPopAttrib ();                                   /* Restore the colour and stencil buffer write-mask etc.. */
+  glPushAttrib (GL_STENCIL_BUFFER_BIT);             /* Save the stencil op and function */
+  glEnable (GL_STENCIL_TEST);                       /* Enable the stencil test, just in case it wasn't already on */
 
-  glStencilFunc (GL_GEQUAL, 0, priv->assigned_bits);  /* Pass stencil test if all assigned bits clear, */
-                                                /* reference is all assigned bits so we set */
-                                                /* any bits permitted by the stencil writemask */
+  glStencilOp (GL_KEEP, GL_KEEP, GL_INVERT);        /* This allows us to toggle the bit on the subcompositing bitplane */
+                                                    /* If the stencil test has passed, we know that bit is 0, so we're */
+                                                    /* effectively just setting it to 1. */
+  glStencilFunc (GL_GEQUAL, 0, priv->assigned_bits);/* Pass stencil test if all assigned bits clear, */
+                                                    /* reference is all assigned bits so we set */
+                                                    /* any bits permitted by the stencil writemask */
 
   /* Drawing operations as masked to areas where the stencil buffer is '0' */
 
@@ -999,7 +999,7 @@ fill_polyarea (hidGC gc, POLYAREA *pa, const BoxType *clip_box, bool use_new_ste
 }
 
 void
-hidgl_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+hidgl_fill_pcb_polygon (hidGC gc, PolygonType *poly)
 {
   bool use_new_stencil;
 
@@ -1009,14 +1009,14 @@ hidgl_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
   use_new_stencil = polygon_contains_user_holes (poly) ||
                     TEST_FLAG (FULLPOLYFLAG, poly);
 
-  fill_polyarea (gc, poly->Clipped, clip_box, use_new_stencil);
+  fill_polyarea (gc, poly->Clipped, use_new_stencil);
 
   if (TEST_FLAG (FULLPOLYFLAG, poly))
     {
       POLYAREA *pa;
 
       for (pa = poly->Clipped->f; pa != poly->Clipped; pa = pa->f)
-        fill_polyarea (gc, pa, clip_box, use_new_stencil);
+        fill_polyarea (gc, pa, use_new_stencil);
     }
 }
 
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index e2d7f67..1e691ce 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -155,14 +155,14 @@ hidgl_add_triangle (hidGC gc,
                              x3, y3, hidgl_gc->depth);
 }
 
-void hidgl_draw_grid (hidGC gc, BoxType *drawn_area);
+void hidgl_draw_grid (hidGC gc);
 void hidgl_set_depth (hidGC gc, float depth);
 void hidgl_draw_line (hidGC gc, int cap, Coord width, Coord x1, Coord y1, Coord x2, Coord y2, double scale);
 void hidgl_draw_arc (hidGC gc, Coord width, Coord vx, Coord vy, Coord vrx, Coord vry, Angle start_angle, Angle delta_angle, double scale);
 void hidgl_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2);
 void hidgl_fill_circle (hidGC gc, Coord vx, Coord vy, Coord vr);
 void hidgl_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y);
-void hidgl_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box);
+void hidgl_fill_pcb_polygon (hidGC gc, PolygonType *poly);
 void hidgl_fill_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2);
 
 void hidgl_init (void);
diff --git a/src/hid/common/hidnogui.c b/src/hid/common/hidnogui.c
index 14788b2..91b048e 100644
--- a/src/hid/common/hidnogui.c
+++ b/src/hid/common/hidnogui.c
@@ -54,14 +54,14 @@ nogui_invalidate_all (void)
 }
 
 static int
-nogui_set_layer (const char *name, int idx, int empty)
+nogui_set_layer (hidGC gc, const char *name, int idx, int empty)
 {
   CRASH;
   return 0;
 }
 
 static void
-nogui_end_layer (void)
+nogui_end_layer (hidGC gc)
 {
 }
 
@@ -143,7 +143,7 @@ nogui_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
 }
 
 static void
-nogui_draw_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+nogui_draw_pcb_polygon (hidGC gc, PolygonType *poly)
 {
   CRASH;
 }
@@ -425,12 +425,12 @@ nogui_request_debug_draw (void)
 }
 
 static void
-nogui_flush_debug_draw (void)
+nogui_flush_debug_draw (hidGC gc)
 {
 }
 
 static void
-nogui_finish_debug_draw (void)
+nogui_finish_debug_draw (hidGC gc)
 {
 }
 
diff --git a/src/hid/gcode/gcode.c b/src/hid/gcode/gcode.c
index 9631210..90df998 100644
--- a/src/hid/gcode/gcode.c
+++ b/src/hid/gcode/gcode.c
@@ -466,10 +466,13 @@ gcode_start_png_export ()
   region.X2 = PCB->MaxWidth;
   region.Y2 = PCB->MaxHeight;
 
+#warning NULL gc
+  common_set_clip_box (NULL, &region);
+
   linewidth = -1;
   lastbrush = (gdImagePtr)((void *) -1);
 
-  hid_expose_callback (&gcode_hid, &region, 0);
+  hid_expose_callback (&gcode_hid, 0);
 }
 
 static FILE *
@@ -1135,7 +1138,7 @@ error:
 /* *** PNG export (slightly modified code from PNG export HID) ************* */
 
 static int
-gcode_set_layer (const char *name, int group, int empty)
+gcode_set_layer (hidGC gc, const char *name, int group, int empty)
 {
   int idx = (group >= 0 && group < max_group) ?
     PCB->LayerGroups.Entries[group][0] : group;
diff --git a/src/hid/gerber/gerber.c b/src/hid/gerber/gerber.c
index a2efb02..589a13f 100644
--- a/src/hid/gerber/gerber.c
+++ b/src/hid/gerber/gerber.c
@@ -47,7 +47,6 @@
 static HID_Attribute * gerber_get_export_options (int *n);
 static void gerber_do_export (HID_Attr_Val * options);
 static void gerber_parse_arguments (int *argc, char ***argv);
-static int gerber_set_layer (const char *name, int group, int empty);
 static hidGC gerber_make_gc (void);
 static void gerber_destroy_gc (hidGC gc);
 static void gerber_set_color (hidGC gc, const char *name);
@@ -676,17 +675,20 @@ gerber_do_export (HID_Attr_Val * options)
   region.X2 = PCB->MaxWidth;
   region.Y2 = PCB->MaxHeight;
 
+#warning NULL gc
+  common_set_clip_box (NULL, &region);
+
   pagecount = 1;
   resetApertures ();
 
   lastgroup = -1;
   layer_list_idx = 0;
   finding_apertures = 1;
-  hid_expose_callback (&gerber_hid, &region, 0);
+  hid_expose_callback (&gerber_hid, 0);
 
   layer_list_idx = 0;
   finding_apertures = 0;
-  hid_expose_callback (&gerber_hid, &region, 0);
+  hid_expose_callback (&gerber_hid, 0);
 
   memcpy (LayerStack, saved_layer_stack, sizeof (LayerStack));
 
@@ -716,7 +718,7 @@ drill_sort (const void *va, const void *vb)
 }
 
 static int
-gerber_set_layer (const char *name, int group, int empty)
+gerber_set_layer (hidGC gc, const char *name, int group, int empty)
 {
   int want_outline;
   char *cp;
@@ -910,12 +912,12 @@ gerber_set_layer (const char *name, int group, int empty)
       && strcmp (name, "outline")
       && strcmp (name, "route"))
     {
+      hidGC gc = hid_draw_make_gc (&gerber_graphics);
       if (outline_layer
 	  && outline_layer != PCB->Data->Layer+idx)
-	dapi->draw_layer (outline_layer, &region, NULL);
+	dapi->draw_layer (gc, outline_layer, NULL);
       else if (!outline_layer)
 	{
-	  hidGC gc = hid_draw_make_gc (&gerber_graphics);
 	  printf("name %s idx %d\n", name, idx);
 	  if (SL_TYPE (idx) == SL_SILK)
 	    hid_draw_set_line_width (gc, PCB->minSlk);
@@ -927,8 +929,8 @@ gerber_set_layer (const char *name, int group, int empty)
 	  hid_draw_line (gc, 0, 0, 0, PCB->MaxHeight);
 	  hid_draw_line (gc, PCB->MaxWidth, 0, PCB->MaxWidth, PCB->MaxHeight);
 	  hid_draw_line (gc, 0, PCB->MaxHeight, PCB->MaxWidth, PCB->MaxHeight);
-	  hid_draw_destroy_gc (gc);
 	}
+      hid_draw_destroy_gc (gc);
     }
 
   return 1;
diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index 36e1acc..c95cd12 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -137,7 +137,7 @@ is_layer_group_visible (int group)
 }
 
 int
-ghid_set_layer (const char *name, int group, int empty)
+ghid_set_layer (hidGC gc, const char *name, int group, int empty)
 {
   if (group >= 0 && group < max_group)
     return is_layer_group_visible (group);
@@ -816,6 +816,9 @@ redraw_region (GdkRectangle *rect)
   region.Y1 = MAX (0, MIN (PCB->MaxHeight, region.Y1));
   region.Y2 = MAX (0, MIN (PCB->MaxHeight, region.Y2));
 
+#warning NULL gc
+//  common_set_clip_box (NULL, &region);
+
   eleft = Vx (0);
   eright = Vx (PCB->MaxWidth);
   etop = Vy (0);
@@ -860,7 +863,7 @@ redraw_region (GdkRectangle *rect)
 
   ghid_draw_bg_image();
 
-  hid_expose_callback (&ghid_hid, &region, 0);
+  hid_expose_callback (&ghid_hid, 0);
   ghid_draw_grid ();
 
   /* In some cases we are called with the crosshair still off */
@@ -1238,7 +1241,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
                       0, 0, allocation.width, allocation.height);
 
   /* call the drawing routine */
-  hid_expose_callback (&ghid_hid, NULL, pinout->element);
+  hid_expose_callback (&ghid_hid, pinout->element);
 
   gport->drawable = save_drawable;
   gport->view = save_view;
@@ -1295,7 +1298,10 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   region.Y1 = MAX (0, MIN (PCB->MaxHeight, region.Y1));
   region.Y2 = MAX (0, MIN (PCB->MaxHeight, region.Y2));
 
-  hid_expose_callback (&ghid_hid, &region, NULL);
+#warning NULL gc
+  common_set_clip_box (NULL, &region);
+
+  hid_expose_callback (&ghid_hid, NULL);
 
   gport->drawable = save_drawable;
   gport->view = save_view;
@@ -1314,16 +1320,16 @@ ghid_request_debug_draw (void)
 }
 
 void
-ghid_flush_debug_draw (void)
+ghid_flush_debug_draw (hidGC gc)
 {
   ghid_screen_update ();
   gdk_flush ();
 }
 
 void
-ghid_finish_debug_draw (void)
+ghid_finish_debug_draw (hidGC gc)
 {
-  ghid_flush_debug_draw ();
+  ghid_flush_debug_draw (gc);
   /* No special tear down requirements
    */
 }
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 85d5e8e..b28929f 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -54,8 +54,6 @@ extern PFNGLUSEPROGRAMPROC         glUseProgram;
 extern HID ghid_hid;
 extern HID_DRAW ghid_graphics;
 
-static hidGC current_gc = NULL;
-
 /* Sets gport->u_gc to the "right" GC to use (wrt mask or window)
 */
 #define USE_GC(gc) if (!use_gc(gc)) return
@@ -303,7 +301,7 @@ is_layer_group_visible (int group)
 }
 
 int
-ghid_set_layer (const char *name, int group, int empty)
+ghid_set_layer (hidGC gc, const char *name, int group, int empty)
 {
   render_priv *priv = gport->render_priv;
   hidgl_instance *hidgl = priv->hidgl;
@@ -363,7 +361,7 @@ ghid_set_layer (const char *name, int group, int empty)
 }
 
 static void
-ghid_end_layer ()
+ghid_end_layer (hidGC gc)
 {
   render_priv *priv = gport->render_priv;
   hidgl_instance *hidgl = priv->hidgl;
@@ -405,7 +403,7 @@ ghid_make_gc (void)
 }
 
 static void
-ghid_draw_grid (hidGC gc, BoxType *drawn_area)
+ghid_draw_grid (hidGC gc)
 {
   if (Vz (PCB->Grid) < MIN_GRID_DISTANCE)
     return;
@@ -427,7 +425,7 @@ ghid_draw_grid (hidGC gc, BoxType *drawn_area)
              gport->grid_color.green / 65535.,
              gport->grid_color.blue / 65535.);
 
-  hidgl_draw_grid (gc, drawn_area);
+  hidgl_draw_grid (gc);
 
   glDisable (GL_COLOR_LOGIC_OP);
   glEnable (GL_STENCIL_TEST);
@@ -813,12 +811,6 @@ ghid_set_line_cap_angle (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
   printf ("ghid_set_line_cap_angle() -- not implemented\n");
 }
 
-static void
-ghid_invalidate_current_gc (void)
-{
-  current_gc = NULL;
-}
-
 static int
 use_gc (hidGC gc)
 {
@@ -828,10 +820,10 @@ use_gc (hidGC gc)
       abort ();
     }
 
-  if (current_gc == gc)
-    return 1;
+//  if (current_gc == gc)
+//    return 1;
 
-  current_gc = gc;
+//  current_gc = gc;
 
   set_gl_color_for_gc (gc);
   return 1;
@@ -884,22 +876,22 @@ ghid_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
 }
 
 void
-ghid_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+ghid_fill_pcb_polygon (hidGC gc, PolygonType *poly)
 {
   USE_GC (gc);
 
-  hidgl_fill_pcb_polygon (gc, poly, clip_box);
+  hidgl_fill_pcb_polygon (gc, poly);
 }
 
 void
-ghid_thindraw_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+ghid_thindraw_pcb_polygon (hidGC gc, PolygonType *poly)
 {
   gtkGC gtk_gc = (gtkGC)gc;
 
   double old_alpha_mult = gtk_gc->alpha_mult;
-  common_thindraw_pcb_polygon (gc, poly, clip_box);
+  common_thindraw_pcb_polygon (gc, poly);
   ghid_set_alpha_mult (gc, gtk_gc->alpha_mult * 0.25);
-  hid_draw__fill_pcb_polygon (gc, poly, clip_box);
+  hid_draw__fill_pcb_polygon (gc, poly);
   ghid_set_alpha_mult (gc, old_alpha_mult);
 }
 
@@ -1044,6 +1036,7 @@ static void
 draw_crosshair (hidGC gc, render_priv *priv)
 {
   gtkGC gtk_gc = (gtkGC)gc;
+
   gint x, y, z;
   static int done_once = 0;
   static GdkColor cross_color;
@@ -1195,13 +1188,14 @@ static int
 EMark_callback (const BoxType * b, void *cl)
 {
   ElementType *element = (ElementType *) b;
+  hidGC gc = cl;
 
-  DrawEMark (element, element->MarkX, element->MarkY, !FRONT (element));
+  DrawEMark (gc, element, element->MarkX, element->MarkY, !FRONT (element));
   return 1;
 }
 
 static void
-set_object_color (AnyObjectType *obj, char *warn_color, char *selected_color,
+set_object_color (hidGC gc, AnyObjectType *obj, char *warn_color, char *selected_color,
                   char *connected_color, char *found_color, char *normal_color)
 {
   char *color;
@@ -1212,42 +1206,42 @@ set_object_color (AnyObjectType *obj, char *warn_color, char *selected_color,
   else if (found_color     != NULL && TEST_FLAG (FOUNDFLAG,     obj)) color = found_color;
   else                                                                color = normal_color;
 
-  ghid_set_lock_effects (Output.fgGC, obj);
-  hid_draw_set_color (Output.fgGC, color);
+  ghid_set_lock_effects (gc, obj);
+  hid_draw_set_color (gc, color);
 }
 
 static void
-set_layer_object_color (LayerType *layer, AnyObjectType *obj)
+set_layer_object_color (hidGC gc, LayerType *layer, AnyObjectType *obj)
 {
-  set_object_color (obj, NULL, layer->SelectedColor, PCB->ConnectedColor, PCB->FoundColor, layer->Color);
+  set_object_color (gc, obj, NULL, layer->SelectedColor, PCB->ConnectedColor, PCB->FoundColor, layer->Color);
 }
 
 static void
-set_pv_inlayer_color (PinType *pv, LayerType *layer, int type)
+set_pv_inlayer_color (hidGC gc, PinType *pv, LayerType *layer, int type)
 {
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *) pv);
+  ghid_set_lock_effects (gc, (AnyObjectType *) pv);
 
-  if (TEST_FLAG (WARNFLAG, pv))           hid_draw_set_color (Output.fgGC, PCB->WarnColor);
-  else if (TEST_FLAG (SELECTEDFLAG, pv))  hid_draw_set_color (Output.fgGC, (type == VIA_TYPE) ? PCB->ViaSelectedColor
-                                                                                              : PCB->PinSelectedColor);
-  else if (TEST_FLAG (CONNECTEDFLAG, pv)) hid_draw_set_color (Output.fgGC, PCB->ConnectedColor);
-  else if (TEST_FLAG (FOUNDFLAG, pv))     hid_draw_set_color (Output.fgGC, PCB->FoundColor);
+  if (TEST_FLAG (WARNFLAG, pv))           hid_draw_set_color (gc, PCB->WarnColor);
+  else if (TEST_FLAG (SELECTEDFLAG, pv))  hid_draw_set_color (gc, (type == VIA_TYPE) ? PCB->ViaSelectedColor
+                                                                                     : PCB->PinSelectedColor);
+  else if (TEST_FLAG (CONNECTEDFLAG, pv)) hid_draw_set_color (gc, PCB->ConnectedColor);
+  else if (TEST_FLAG (FOUNDFLAG, pv))     hid_draw_set_color (gc, PCB->FoundColor);
   else
     {
-      int top_group = GetLayerGroupNumberBySide (TOP_SIDE);
+      int top_group    = GetLayerGroupNumberBySide (TOP_SIDE);
       int bottom_group = GetLayerGroupNumberBySide (BOTTOM_SIDE);
-      int this_group      = GetLayerGroupNumberByPointer (layer);
+      int this_group   = GetLayerGroupNumberByPointer (layer);
 
       if (this_group == top_group || this_group == bottom_group)
-        hid_draw_set_color (Output.fgGC, (SWAP_IDENT == (this_group == bottom_group)) ?
-                                         PCB->ViaColor : PCB->InvisibleObjectsColor);
+        hid_draw_set_color (gc, (SWAP_IDENT == (this_group == bottom_group)) ?
+                                PCB->ViaColor : PCB->InvisibleObjectsColor);
       else
-        hid_draw_set_color (Output.fgGC, layer->Color);
+        hid_draw_set_color (gc, layer->Color);
     }
 }
 
 static void
-_draw_pv_name (PinType *pv)
+_draw_pv_name (hidGC gc, PinType *pv)
 {
   BoxType box;
   bool vert;
@@ -1271,8 +1265,8 @@ _draw_pv_name (PinType *pv)
       box.Y1 = pv->Y - pv->Thickness    / 2 + Settings.PinoutTextOffsetY;
     }
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pv);
-  hid_draw_set_color (Output.fgGC, PCB->PinNameColor);
+  ghid_set_lock_effects (gc, (AnyObjectType *)pv);
+  hid_draw_set_color (gc, PCB->PinNameColor);
 
   text.Flags = NoFlags ();
   /* Set font height to approx 56% of pin thickness */
@@ -1281,46 +1275,47 @@ _draw_pv_name (PinType *pv)
   text.Y = box.Y1;
   text.Direction = vert ? 1 : 0;
 
-  hid_draw_pcb_text (Output.fgGC, &text, 0);
+  hid_draw_pcb_text (gc, &text, 0);
 }
 
 static void
-_draw_pv (PinType *pv, bool draw_hole)
+_draw_pv (hidGC gc, PinType *pv, bool draw_hole)
 {
   if (TEST_FLAG (THINDRAWFLAG, PCB))
     {
-      hid_draw__thin_pcb_pv (Output.fgGC, pv, false);
+      hid_draw__thin_pcb_pv (gc, pv, false);
       if (draw_hole)
-        hid_draw__thin_pcb_pv_hole (Output.fgGC, pv);
+        hid_draw__thin_pcb_pv_hole (gc, pv);
     }
   else
     {
-      hid_draw__fill_pcb_pv (Output.fgGC, pv, false);
+      hid_draw__fill_pcb_pv (gc, pv, false);
       if (draw_hole)
         hid_draw__fill_pcb_pv_hole (Output.bgGC, pv);
     }
 
   if (!TEST_FLAG (HOLEFLAG, pv) && TEST_FLAG (DISPLAYNAMEFLAG, pv))
-    _draw_pv_name (pv);
+    _draw_pv_name (gc, pv);
 }
 
 static void
-draw_pin (PinType *pin, bool draw_hole)
+draw_pin (hidGC gc, PinType *pin, bool draw_hole)
 {
-  set_object_color ((AnyObjectType *) pin, PCB->WarnColor, PCB->PinSelectedColor,
+  set_object_color (gc, (AnyObjectType *) pin, PCB->WarnColor, PCB->PinSelectedColor,
                     PCB->ConnectedColor, PCB->FoundColor, PCB->PinColor);
 
-  _draw_pv (pin, draw_hole);
+  _draw_pv (gc, pin, draw_hole);
 }
 
 static int
 pin_callback (const BoxType * b, void *cl)
 {
   PinType *pin = (PinType *) b;
+  hidGC gc = cl;
 
   if (!TEST_FLAG (HOLEFLAG, pin) && TEST_FLAG (DISPLAYNAMEFLAG, pin))
-    _draw_pv_name (pin);
-  draw_pin (pin, TEST_FLAG (THINDRAWFLAG, PCB));
+    _draw_pv_name (gc, pin);
+  draw_pin (gc, pin, TEST_FLAG (THINDRAWFLAG, PCB));
   return 1;
 }
 
@@ -1328,46 +1323,59 @@ static int
 pin_name_callback (const BoxType * b, void *cl)
 {
   PinType *pin = (PinType *) b;
+  hidGC gc = cl;
 
   if (!TEST_FLAG (HOLEFLAG, pin) && TEST_FLAG (DISPLAYNAMEFLAG, pin))
-    _draw_pv_name (pin);
+    _draw_pv_name (gc, pin);
   return 1;
 }
 
+struct layer_info
+{
+  hidGC gc;
+  LayerType *layer;
+};
+
 static int
 pin_inlayer_callback (const BoxType * b, void *cl)
 {
-  set_pv_inlayer_color ((PinType *) b, cl, PIN_TYPE);
-  _draw_pv ((PinType *) b, false);
+  struct layer_info *info = cl;
+
+  set_pv_inlayer_color (info->gc, (PinType *) b, info->layer, PIN_TYPE);
+  _draw_pv (info->gc, (PinType *) b, false);
   return 1;
 }
 
 static void
-draw_via (PinType *via, bool draw_hole)
+draw_via (hidGC gc, PinType *via, bool draw_hole)
 {
-  set_object_color ((AnyObjectType *) via, PCB->WarnColor, PCB->ViaSelectedColor,
+  set_object_color (gc, (AnyObjectType *) via, PCB->WarnColor, PCB->ViaSelectedColor,
                     PCB->ConnectedColor, PCB->FoundColor, PCB->ViaColor);
 
-  _draw_pv (via, draw_hole);
+  _draw_pv (gc, via, draw_hole);
 }
 
 static int
 via_callback (const BoxType * b, void *cl)
 {
-  draw_via ((PinType *)b, TEST_FLAG (THINDRAWFLAG, PCB));
+  hidGC gc = cl;
+
+  draw_via (gc, (PinType *)b, TEST_FLAG (THINDRAWFLAG, PCB));
   return 1;
 }
 
 static int
 via_inlayer_callback (const BoxType * b, void *cl)
 {
-  set_pv_inlayer_color ((PinType *) b, cl, VIA_TYPE);
-  _draw_pv ((PinType *) b, TEST_FLAG (THINDRAWFLAG, PCB));
+  struct layer_info *info = cl;
+
+  set_pv_inlayer_color (info->gc, (PinType *) b, info->layer, VIA_TYPE);
+  _draw_pv (info->gc, (PinType *) b, TEST_FLAG (THINDRAWFLAG, PCB));
   return 1;
 }
 
 static void
-draw_pad_name (PadType *pad)
+draw_pad_name (hidGC gc, PadType *pad)
 {
   BoxType box;
   bool vert;
@@ -1396,8 +1404,8 @@ draw_pad_name (PadType *pad)
       box.Y1 += Settings.PinoutTextOffsetY;
     }
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pad);
-  hid_draw_set_color (Output.fgGC, PCB->PinNameColor);
+  ghid_set_lock_effects (gc, (AnyObjectType *)pad);
+  hid_draw_set_color (gc, PCB->PinNameColor);
 
   text.Flags = NoFlags ();
   /* Set font height to approx 90% of pad thickness */
@@ -1406,7 +1414,7 @@ draw_pad_name (PadType *pad)
   text.Y = box.Y1;
   text.Direction = vert ? 1 : 0;
 
-  hid_draw_pcb_text (Output.fgGC, &text, 0);
+  hid_draw_pcb_text (gc, &text, 0);
 }
 
 static void
@@ -1423,29 +1431,34 @@ _draw_pad (hidGC gc, PadType *pad, bool clear, bool mask)
 }
 
 static void
-draw_pad (PadType *pad)
+draw_pad (hidGC gc, PadType *pad)
 {
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pad);
-  set_object_color ((AnyObjectType *)pad, PCB->WarnColor,
+  ghid_set_lock_effects (gc, (AnyObjectType *)pad);
+  set_object_color (gc, (AnyObjectType *)pad, PCB->WarnColor,
                     PCB->PinSelectedColor, PCB->ConnectedColor, PCB->FoundColor,
                     FRONT (pad) ? PCB->PinColor : PCB->InvisibleObjectsColor);
 
-  _draw_pad (Output.fgGC, pad, false, false);
+  _draw_pad (gc, pad, false, false);
 
   if (TEST_FLAG (DISPLAYNAMEFLAG, pad))
-    draw_pad_name (pad);
+    draw_pad_name (gc, pad);
 }
 
+struct side_info {
+  hidGC gc;
+  int side;
+};
+
 static int
 pad_callback (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *) b;
-  int *side = cl;
+  struct side_info *info = cl;
 
-  if (ON_SIDE (pad, *side)) {
+  if (ON_SIDE (pad, info->side)) {
     if (TEST_FLAG (DISPLAYNAMEFLAG, pad))
-      draw_pad_name (pad);
-    draw_pad (pad);
+      draw_pad_name (info->gc, pad);
+    draw_pad (info->gc, pad);
   }
   return 1;
 }
@@ -1455,7 +1468,9 @@ static int
 hole_callback (const BoxType * b, void *cl)
 {
   PinType *pv = (PinType *) b;
-  int plated = cl ? *(int *) cl : -1;
+  hidGC gc = cl;
+//  int plated = cl ? *(int *) cl : -1;
+  int plated = -1;
 
   if ((plated == 0 && !TEST_FLAG (HOLEFLAG, pv)) ||
       (plated == 1 &&  TEST_FLAG (HOLEFLAG, pv)))
@@ -1465,10 +1480,9 @@ hole_callback (const BoxType * b, void *cl)
     {
       if (!TEST_FLAG (HOLEFLAG, pv))
         {
-          hid_draw_set_line_cap (Output.fgGC, Round_Cap);
-          hid_draw_set_line_width (Output.fgGC, 0);
-          hid_draw_arc (Output.fgGC, pv->X, pv->Y,
-                        pv->DrillingHole / 2, pv->DrillingHole / 2, 0, 360);
+          hid_draw_set_line_cap (gc, Round_Cap);
+          hid_draw_set_line_width (gc, 0);
+          hid_draw_arc (gc, pv->X, pv->Y, pv->DrillingHole / 2, pv->DrillingHole / 2, 0, 360);
         }
     }
   else
@@ -1476,14 +1490,13 @@ hole_callback (const BoxType * b, void *cl)
 
   if (TEST_FLAG (HOLEFLAG, pv))
     {
-      ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pv);
-      set_object_color ((AnyObjectType *) pv, PCB->WarnColor,
+      ghid_set_lock_effects (gc, (AnyObjectType *)pv);
+      set_object_color (gc, (AnyObjectType *) pv, PCB->WarnColor,
                         PCB->ViaSelectedColor, NULL, NULL, Settings.BlackColor);
 
-      hid_draw_set_line_cap (Output.fgGC, Round_Cap);
-      hid_draw_set_line_width (Output.fgGC, 0);
-      hid_draw_arc (Output.fgGC, pv->X, pv->Y,
-                    pv->DrillingHole / 2, pv->DrillingHole / 2, 0, 360);
+      hid_draw_set_line_cap (gc, Round_Cap);
+      hid_draw_set_line_width (gc, 0);
+      hid_draw_arc (gc, pv->X, pv->Y, pv->DrillingHole / 2, pv->DrillingHole / 2, 0, 360);
     }
   return 1;
 }
@@ -1491,92 +1504,86 @@ hole_callback (const BoxType * b, void *cl)
 static int
 line_callback (const BoxType * b, void *cl)
 {
-  LayerType *layer = cl;
   LineType *line = (LineType *)b;
+  struct layer_info *info = cl;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *) line);
-  set_layer_object_color (layer, (AnyObjectType *) line);
-  hid_draw_pcb_line (Output.fgGC, line);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *) line);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) line);
+  hid_draw_pcb_line (info->gc, line);
   return 1;
 }
 
 static int
 arc_callback (const BoxType * b, void *cl)
 {
-  LayerType *layer = cl;
   ArcType *arc = (ArcType *)b;
+  struct layer_info *info = cl;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *) arc);
-  set_layer_object_color (layer, (AnyObjectType *) arc);
-  hid_draw_pcb_arc (Output.fgGC, arc);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *) arc);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) arc);
+  hid_draw_pcb_arc (info->gc, arc);
   return 1;
 }
 
 static int
 text_callback (const BoxType * b, void *cl)
 {
-  LayerType *layer = cl;
   TextType *text = (TextType *)b;
+  struct layer_info *info = cl;
   int min_silk_line;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)text);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *)text);
   if (TEST_FLAG (SELECTEDFLAG, text))
-    hid_draw_set_color (Output.fgGC, layer->SelectedColor);
+    hid_draw_set_color (info->gc, info->layer->SelectedColor);
   else
-    hid_draw_set_color (Output.fgGC, layer->Color);
-  if (layer == &PCB->Data->SILKLAYER ||
-      layer == &PCB->Data->BACKSILKLAYER)
+    hid_draw_set_color (info->gc, info->layer->Color);
+  if (info->layer == &PCB->Data->SILKLAYER ||
+      info->layer == &PCB->Data->BACKSILKLAYER)
     min_silk_line = PCB->minSlk;
   else
     min_silk_line = PCB->minWid;
-  hid_draw_pcb_text (Output.fgGC, text, min_silk_line);
+  hid_draw_pcb_text (info->gc, text, min_silk_line);
   return 1;
 }
 
-struct poly_info
-{
-  LayerType *layer;
-  const BoxType *drawn_area;
-};
-
 static int
 poly_callback (const BoxType * b, void *cl)
 {
-  struct poly_info *i = (struct poly_info *) cl;
   PolygonType *polygon = (PolygonType *) b;
+  struct layer_info *info = cl;
 
-  set_layer_object_color (i->layer, (AnyObjectType *) polygon);
-  hid_draw_pcb_polygon (Output.fgGC, polygon, i->drawn_area);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) polygon);
+  hid_draw_pcb_polygon (info->gc, polygon);
   return 1;
 }
 
 static int
 poly_callback_no_clear (const BoxType * b, void *cl)
 {
-  struct poly_info *i = (struct poly_info *) cl;
   PolygonType *polygon = (PolygonType *) b;
+  struct layer_info *info = cl;
 
   if (TEST_FLAG (CLEARPOLYFLAG, polygon))
     return 0;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *) polygon);
-  set_layer_object_color (i->layer, (AnyObjectType *) polygon);
-  hid_draw_pcb_polygon (Output.fgGC, polygon, i->drawn_area);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *) polygon);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) polygon);
+  hid_draw_pcb_polygon (info->gc, polygon);
   return 1;
 }
 
 static int
 poly_callback_clearing (const BoxType * b, void *cl)
 {
-  struct poly_info *i = (struct poly_info *) cl;
   PolygonType *polygon = (PolygonType *) b;
+  struct layer_info *info = cl;
 
   if (!TEST_FLAG (CLEARPOLYFLAG, polygon))
     return 0;
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *) polygon);
-  set_layer_object_color (i->layer, (AnyObjectType *) polygon);
-  hid_draw_pcb_polygon (Output.fgGC, polygon, i->drawn_area);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *) polygon);
+  set_layer_object_color (info->gc, info->layer, (AnyObjectType *) polygon);
+  hid_draw_pcb_polygon (info->gc, polygon);
   return 1;
 }
 
@@ -1595,8 +1602,9 @@ static int
 clearPad_callback (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *) b;
-  int *side = cl;
-  if (ON_SIDE (pad, *side) && pad->Mask)
+  struct side_info *info = cl;
+
+  if (ON_SIDE (pad, info->side) && pad->Mask)
     _draw_pad (Output.pmGC, pad, true, true);
   return 1;
 }
@@ -1613,8 +1621,9 @@ static int
 clearPad_callback_solid (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *) b;
-  int *side = cl;
-  if (ON_SIDE (pad, *side) && pad->Mask)
+  struct side_info *info = cl;
+
+  if (ON_SIDE (pad, info->side) && pad->Mask)
     hid_draw__fill_pcb_pad (Output.pmGC, pad, true, true);
   return 1;
 }
@@ -1633,7 +1642,7 @@ ensure_board_outline (void)
 }
 
 static void
-fill_board_outline (hidGC gc, const BoxType *drawn_area)
+fill_board_outline (hidGC gc)
 {
   PolygonType polygon;
 
@@ -1641,11 +1650,11 @@ fill_board_outline (hidGC gc, const BoxType *drawn_area)
 
   memset (&polygon, 0, sizeof (polygon));
   polygon.Clipped = PCB->Data->outline;
-  if (drawn_area)
-    polygon.BoundingBox = *drawn_area;
+  if (gc->clip_box)
+    polygon.BoundingBox = *gc->clip_box;
   polygon.Flags = NoFlags ();
   SET_FLAG (FULLPOLYFLAG, &polygon);
-  hid_draw__fill_pcb_polygon (gc, &polygon, drawn_area);
+  hid_draw__fill_pcb_polygon (gc, &polygon);
   poly_FreeContours (&polygon.NoHoles);
 }
 
@@ -1676,8 +1685,8 @@ fill_outline_hole_cb (PLINE *pl, void *user_data)
   SET_FLAG (FULLPOLYFLAG, &polygon);
 
   /* XXX: For some reason, common_fill_pcb_polygon doesn't work for all contours here.. not sure why */
-//  common_fill_pcb_polygon (info->gc, &polygon, NULL);
-  hid_draw__fill_pcb_polygon (info->gc, &polygon, NULL);
+//  common_fill_pcb_polygon (info->gc, &polygon);
+  hid_draw__fill_pcb_polygon (info->gc, &polygon);
 
   poly_FreeContours (&polygon.NoHoles);
 
@@ -1687,7 +1696,7 @@ fill_outline_hole_cb (PLINE *pl, void *user_data)
 }
 
 static void
-fill_board_outline_holes (hidGC gc, const BoxType *drawn_area)
+fill_board_outline_holes (hidGC gc)
 {
   render_priv *priv = gport->render_priv;
   PolygonType polygon, p;
@@ -1697,20 +1706,20 @@ fill_board_outline_holes (hidGC gc, const BoxType *drawn_area)
 
   memset (&polygon, 0, sizeof (polygon));
   polygon.Clipped = PCB->Data->outline;
-  if (drawn_area)
-    polygon.BoundingBox = *drawn_area;
+  if (gc->clip_box)
+    polygon.BoundingBox = *gc->clip_box;
   polygon.Flags = NoFlags ();
   SET_FLAG (FULLPOLYFLAG, &polygon);
 
   info.gc = gc;
 
-  PolygonHoles (&polygon, drawn_area, fill_outline_hole_cb, &info);
+  PolygonHoles (&polygon, gc->clip_box, fill_outline_hole_cb, &info);
 
   p = polygon;
   for (p.Clipped = polygon.Clipped->f;
        p.Clipped != polygon.Clipped;
        p.Clipped = p.Clipped->f) {
-    PolygonHoles (&p, drawn_area, fill_outline_hole_cb, &info);
+    PolygonHoles (&p, gc->clip_box, fill_outline_hole_cb, &info);
   }
 
 //  poly_FreeContours (&polygon.NoHoles);
@@ -1719,42 +1728,44 @@ fill_board_outline_holes (hidGC gc, const BoxType *drawn_area)
 }
 
 static void
-GhidDrawMask (int side, BoxType * screen)
+GhidDrawMask (hidGC gc, int side)
 {
 //  static bool first_run = true;
 //  static GLuint texture;
   int thin = TEST_FLAG(THINDRAWFLAG, PCB) || TEST_FLAG(THINDRAWPOLYFLAG, PCB);
   LayerType *Layer = LAYER_PTR (side == TOP_SIDE ? top_soldermask_layer : bottom_soldermask_layer);
-  struct poly_info info;
+  struct layer_info l_info;
+  struct side_info s_info;
 
-  OutputType *out = &Output;
+  l_info.gc = gc;
+  l_info.layer = Layer;
+  s_info.gc = gc;
+  s_info.side = side;
 
   if (thin)
     {
       hid_draw_set_line_width (Output.pmGC, 0);
       hid_draw_set_color (Output.pmGC, PCB->MaskColor);
-      r_search (PCB->Data->pin_tree, screen, NULL, clearPin_callback, NULL);
-      r_search (PCB->Data->via_tree, screen, NULL, clearPin_callback, NULL);
-      r_search (PCB->Data->pad_tree, screen, NULL, clearPad_callback, &side);
+      r_search (PCB->Data->pin_tree, gc->clip_box, NULL, clearPin_callback, NULL);
+      r_search (PCB->Data->via_tree, gc->clip_box, NULL, clearPin_callback, NULL);
+      r_search (PCB->Data->pad_tree, gc->clip_box, NULL, clearPad_callback, &s_info);
       hid_draw_set_color (Output.pmGC, "erase");
     }
 
-  hid_draw_use_mask (Output.fgGC, HID_MASK_CLEAR);
+  hid_draw_use_mask (gc, HID_MASK_CLEAR);
 
-  info.layer = Layer;
-  info.drawn_area = screen;
-  r_search (Layer->polygon_tree, screen, NULL, poly_callback, &info);
-  r_search (Layer->line_tree, screen, NULL, line_callback, Layer);
-  r_search (Layer->arc_tree, screen, NULL, arc_callback, Layer);
-  r_search (Layer->text_tree, screen, NULL, text_callback, Layer);
+  r_search (Layer->polygon_tree, gc->clip_box, NULL, poly_callback, &s_info);
+  r_search (Layer->line_tree, gc->clip_box, NULL, line_callback, &l_info);
+  r_search (Layer->arc_tree, gc->clip_box, NULL, arc_callback, &l_info);
+  r_search (Layer->text_tree, gc->clip_box, NULL, text_callback, &l_info);
 
-  r_search (PCB->Data->pin_tree, screen, NULL, clearPin_callback_solid, NULL);
-  r_search (PCB->Data->via_tree, screen, NULL, clearPin_callback_solid, NULL);
-  r_search (PCB->Data->pad_tree, screen, NULL, clearPad_callback_solid, &side);
+  r_search (PCB->Data->pin_tree, gc->clip_box, NULL, clearPin_callback_solid, NULL);
+  r_search (PCB->Data->via_tree, gc->clip_box, NULL, clearPin_callback_solid, NULL);
+  r_search (PCB->Data->pad_tree, gc->clip_box, NULL, clearPad_callback_solid, &s_info);
 
-  hid_draw_use_mask (Output.fgGC, HID_MASK_AFTER);
-  hid_draw_set_color (out->fgGC, PCB->MaskColor);
-  ghid_set_alpha_mult (out->fgGC, thin ? 0.35 : 1.0);
+  hid_draw_use_mask (gc, HID_MASK_AFTER);
+  hid_draw_set_color (gc, PCB->MaskColor);
+  ghid_set_alpha_mult (gc, thin ? 0.35 : 1.0);
 
 #if 0
   if (first_run) {
@@ -1791,17 +1802,17 @@ GhidDrawMask (int side, BoxType * screen)
 
   memset (&polygon, 0, sizeof (polygon));
   polygon.Clipped = PCB->Data->outline;
-  if (screen)
-    polygon.BoundingBox = *screen;
+  if (gc->clip_box)
+    polygon.BoundingBox = *gc->clip_box;
   polygon.Flags = NoFlags ();
   SET_FLAG (FULLPOLYFLAG, &polygon);
-  hid_draw__fill_pcb_polygon (out->fgGC, &polygon, screen);
+  hid_draw__fill_pcb_polygon (gc, &polygon);
   poly_FreeContours (&polygon.NoHoles);
 #endif
 
-  fill_board_outline (out->fgGC, screen);
+  fill_board_outline (gc);
 
-  ghid_set_alpha_mult (out->fgGC, 1.0);
+  ghid_set_alpha_mult (gc, 1.0);
 //  hidgl_flush_triangles (priv->hidgl);
 #if 0
   glDisable (GL_TEXTURE_GEN_S);
@@ -1811,7 +1822,7 @@ GhidDrawMask (int side, BoxType * screen)
 #endif
   hidgl_shader_activate (circular_program);
 
-  hid_draw_use_mask (out->fgGC, HID_MASK_OFF);
+  hid_draw_use_mask (gc, HID_MASK_OFF);
 
 //  first_run = false;
 }
@@ -1859,7 +1870,7 @@ outline_hole_cb (PLINE *pl, void *user_data)
 }
 
 static void
-ghid_draw_outline_between_layers (int from_layer, int to_layer, BoxType *drawn_area)
+ghid_draw_outline_between_layers (hidGC gc, int from_layer, int to_layer)
 {
   render_priv *priv = gport->render_priv;
   PolygonType polygon, p;
@@ -1869,24 +1880,24 @@ ghid_draw_outline_between_layers (int from_layer, int to_layer, BoxType *drawn_a
 
   memset (&polygon, 0, sizeof (polygon));
   polygon.Clipped = PCB->Data->outline;
-  if (drawn_area)
-    polygon.BoundingBox = *drawn_area;
+  if (gc->clip_box)
+    polygon.BoundingBox = *gc->clip_box;
   polygon.Flags = NoFlags ();
   SET_FLAG (FULLPOLYFLAG, &polygon);
 
-  info.gc = Output.fgGC;
+  info.gc = gc;
   info.z1 = compute_depth (from_layer);
   info.z2 = compute_depth (to_layer);
 
   draw_outline_contour (info.gc, polygon.Clipped->contours, info.z1, info.z2);
-  PolygonHoles (&polygon, drawn_area, outline_hole_cb, &info);
+  PolygonHoles (&polygon, gc->clip_box, outline_hole_cb, &info);
 
   p = polygon;
   for (p.Clipped = polygon.Clipped->f;
        p.Clipped != polygon.Clipped;
        p.Clipped = p.Clipped->f) {
     draw_outline_contour (info.gc, p.Clipped->contours, info.z1, info.z2);
-    PolygonHoles (&p, drawn_area, outline_hole_cb, &info);
+    PolygonHoles (&p, gc->clip_box, outline_hole_cb, &info);
   }
 
   poly_FreeContours (&polygon.NoHoles);
@@ -1895,13 +1906,11 @@ ghid_draw_outline_between_layers (int from_layer, int to_layer, BoxType *drawn_a
 }
 
 static int
-GhidDrawLayerGroup (int group, const BoxType * screen)
+GhidDrawLayerGroup (hidGC gc, int group)
 {
   render_priv *priv = gport->render_priv;
   int i;
   int layernum;
-  int side;
-  struct poly_info info;
   LayerType *Layer;
   int n_entries = PCB->LayerGroups.Number[group];
   Cardinal *layers = PCB->LayerGroups.Entries[group];
@@ -1909,8 +1918,13 @@ GhidDrawLayerGroup (int group, const BoxType * screen)
   int top_group = GetLayerGroupNumberBySide (TOP_SIDE);
   int bottom_group = GetLayerGroupNumberBySide (BOTTOM_SIDE);
   bool is_outline;
+  struct layer_info l_info;
+  struct side_info s_info;
 
-  if (!gui->set_layer (0, group, 0))
+  l_info.gc = gc;
+  s_info.gc = gc;
+
+  if (!gui->set_layer (gc, 0, group, 0))
     return 0;
 
   /* HACK: Subcomposite each layer in a layer group separately */
@@ -1921,10 +1935,13 @@ GhidDrawLayerGroup (int group, const BoxType * screen)
     is_outline = strcmp (Layer->Name, "outline") == 0 ||
                  strcmp (Layer->Name, "route") == 0;
 
+    l_info.layer = Layer;
+
+
     if (layernum < max_copper_layer && Layer->On) {
 
       if (!first_run)
-        gui->set_layer (0, group, 0);
+        gui->set_layer (gc, 0, group, 0);
 
       first_run = 0;
 
@@ -1935,24 +1952,23 @@ GhidDrawLayerGroup (int group, const BoxType * screen)
         glColorMask (0, 0, 0, 0);
         glDepthMask (GL_FALSE);
         hid_draw_set_color (Output.bgGC, PCB->MaskColor);
-        if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
-        if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
-        fill_board_outline_holes (Output.bgGC, screen);
+        if (PCB->PinOn) r_search (PCB->Data->pin_tree, gc->clip_box, NULL, hole_callback, gc);
+        if (PCB->ViaOn) r_search (PCB->Data->via_tree, gc->clip_box, NULL, hole_callback, gc);
+        fill_board_outline_holes (Output.bgGC);
         hidgl_flush_triangles (priv->hidgl);
         glPopAttrib ();
       }
 
       /* draw all polygons on this layer */
       if (Layer->PolygonN) {
-        info.layer = Layer;
-        info.drawn_area = screen;
-        r_search (Layer->polygon_tree, screen, NULL, poly_callback_no_clear, &info);
-        r_search (Layer->polygon_tree, screen, NULL, poly_callback_clearing, &info);
+        l_info.layer = Layer;
+        r_search (Layer->polygon_tree, gc->clip_box, NULL, poly_callback_no_clear, &l_info);
+        r_search (Layer->polygon_tree, gc->clip_box, NULL, poly_callback_clearing, &l_info);
 
         /* HACK: Subcomposite polygons separately from other layer primitives */
         /* Reset the compositing */
-        gui->end_layer ();
-        gui->set_layer (0, group, 0);
+        gui->end_layer (gc);
+        gui->set_layer (gc, 0, group, 0);
 
         if (!is_outline && !TEST_FLAG (THINDRAWFLAG, PCB)) {
           hidgl_flush_triangles (priv->hidgl);
@@ -1960,9 +1976,9 @@ GhidDrawLayerGroup (int group, const BoxType * screen)
           glColorMask (0, 0, 0, 0);
           glDepthMask (GL_FALSE);
           /* Mask out drilled holes on this layer */
-          if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
-          if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
-          fill_board_outline_holes (Output.bgGC, screen);
+          if (PCB->PinOn) r_search (PCB->Data->pin_tree, gc->clip_box, NULL, hole_callback, gc);
+          if (PCB->ViaOn) r_search (PCB->Data->via_tree, gc->clip_box, NULL, hole_callback, gc);
+          fill_board_outline_holes (Output.bgGC);
           hidgl_flush_triangles (priv->hidgl);
           glPopAttrib ();
         }
@@ -1972,31 +1988,31 @@ GhidDrawLayerGroup (int group, const BoxType * screen)
       if (!global_view_2d && !is_outline) {
         if (PCB->PinOn &&
             (group == bottom_group || group == top_group))
-          r_search (PCB->Data->pin_tree, screen, NULL, pin_name_callback, Layer);
-        if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, pin_inlayer_callback, Layer);
-        if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, via_inlayer_callback, Layer);
+          r_search (PCB->Data->pin_tree, gc->clip_box, NULL, pin_name_callback, gc);
+        if (PCB->PinOn) r_search (PCB->Data->pin_tree, gc->clip_box, NULL, pin_inlayer_callback, &l_info);
+        if (PCB->ViaOn) r_search (PCB->Data->via_tree, gc->clip_box, NULL, via_inlayer_callback, &l_info);
         if (PCB->PinOn && group == top_group)
           {
-            side = TOP_SIDE;
-            r_search (PCB->Data->pad_tree, screen, NULL, pad_callback, &side);
+            s_info.side = TOP_SIDE;
+            r_search (PCB->Data->pad_tree, gc->clip_box, NULL, pad_callback, &s_info);
           }
         if (PCB->PinOn && group == bottom_group)
           {
-            side = BOTTOM_SIDE;
-            r_search (PCB->Data->pad_tree, screen, NULL, pad_callback, &side);
+            s_info.side = BOTTOM_SIDE;
+            r_search (PCB->Data->pad_tree, gc->clip_box, NULL, pad_callback, &s_info);
           }
       }
 
       if (TEST_FLAG (CHECKPLANESFLAG, PCB))
         continue;
 
-      r_search (Layer->line_tree, screen, NULL, line_callback, Layer);
-      r_search (Layer->arc_tree, screen, NULL, arc_callback, Layer);
-      r_search (Layer->text_tree, screen, NULL, text_callback, Layer);
+      r_search (Layer->line_tree, gc->clip_box, NULL, line_callback, &l_info);
+      r_search (Layer->arc_tree, gc->clip_box, NULL, arc_callback, &l_info);
+      r_search (Layer->text_tree, gc->clip_box, NULL, text_callback, &l_info);
     }
   }
 
-  gui->end_layer ();
+  gui->end_layer (gc);
 
   return (n_entries > 1);
 }
@@ -2047,6 +2063,7 @@ DrawDrillChannel (hidGC gc, int vx, int vy, int vr, int from_layer, int to_layer
 }
 
 struct cyl_info {
+  hidGC gc;
   int from_layer;
   int to_layer;
   double scale;
@@ -2068,9 +2085,9 @@ draw_hole_cyl (PinType *Pin, struct cyl_info *info, int Type)
   else
     color = "drill";
 
-  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)Pin);
-  hid_draw_set_color (Output.fgGC, color);
-  DrawDrillChannel (Output.fgGC, Pin->X, Pin->Y, Pin->DrillingHole / 2, info->from_layer, info->to_layer, info->scale);
+  ghid_set_lock_effects (info->gc, (AnyObjectType *)Pin);
+  hid_draw_set_color (info->gc, color);
+  DrawDrillChannel (info->gc, Pin->X, Pin->Y, Pin->DrillingHole / 2, info->from_layer, info->to_layer, info->scale);
   return 0;
 }
 
@@ -2130,19 +2147,18 @@ frontE_package_callback (const BoxType * b, void *cl)
 }
 
 static void
-ghid_draw_packages (BoxType *drawn_area)
+ghid_draw_packages (hidGC gc)
 {
   /* XXX: Just the front elements for now */
-  r_search (PCB->Data->element_tree, drawn_area, NULL, frontE_package_callback, NULL);
+  r_search (PCB->Data->element_tree, gc->clip_box, NULL, frontE_package_callback, NULL);
 }
 
 void
-ghid_draw_everything (BoxType *drawn_area)
+ghid_draw_everything (hidGC gc)
 {
   render_priv *priv = gport->render_priv;
   int i, ngroups;
   int number_phys_on_top;
-  int side;
   /* This is the list of layer groups we will draw.  */
   int do_group[MAX_LAYER];
   /* This is the reverse of the order in which we draw them.  */
@@ -2154,6 +2170,10 @@ ghid_draw_everything (BoxType *drawn_area)
   int bottom_group;
   int min_phys_group;
   int max_phys_group;
+  struct side_info info;
+
+  cyl_info.gc = gc;
+  info.gc = gc;
 
   priv->current_colorname = NULL;
 
@@ -2203,23 +2223,23 @@ ghid_draw_everything (BoxType *drawn_area)
   /*
    * first draw all 'invisible' stuff
    */
-  side = SWAP_IDENT ? TOP_SIDE : BOTTOM_SIDE;
+  info.side = SWAP_IDENT ? TOP_SIDE : BOTTOM_SIDE;
 
   if (!TEST_FLAG (CHECKPLANESFLAG, PCB) &&
-      gui->set_layer ("invisible", SL (INVISIBLE, 0), 0)) {
-    DrawSilk (side, drawn_area);
+      gui->set_layer (gc, "invisible", SL (INVISIBLE, 0), 0)) {
+    DrawSilk (gc, info.side);
 
     if (global_view_2d)
-      r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, &side);
+      r_search (PCB->Data->pad_tree, gc->clip_box, NULL, pad_callback, &info);
 
-    gui->end_layer ();
+    gui->end_layer (gc);
 
     /* Draw the reverse-side solder mask if turned on */
     if (!global_view_2d &&
-        gui->set_layer (SWAP_IDENT ? "componentmask" : "soldermask",
-                        SWAP_IDENT ? SL (MASK, TOP) : SL (MASK, BOTTOM), 0)) {
-        GhidDrawMask (side, drawn_area);
-        gui->end_layer ();
+        gui->set_layer (gc, SWAP_IDENT ? "componentmask" : "soldermask",
+                            SWAP_IDENT ? SL (MASK, TOP) : SL (MASK, BOTTOM), 0)) {
+        GhidDrawMask (gc, info.side);
+        gui->end_layer (gc);
       }
   }
 
@@ -2239,30 +2259,30 @@ ghid_draw_everything (BoxType *drawn_area)
     if (is_this_physical)
       number_phys_on_top --;
 
-    ghid_set_alpha_mult (Output.fgGC, alpha_mult);
-    GhidDrawLayerGroup (drawn_groups [i], drawn_area);
+    ghid_set_alpha_mult (gc, alpha_mult);
+    GhidDrawLayerGroup (gc, drawn_groups [i]);
 
 #if 1
     if (!global_view_2d && is_this_physical && is_next_physical) {
       cyl_info.from_layer = drawn_groups[i];
       cyl_info.to_layer = drawn_groups[i - 1];
       cyl_info.scale = gport->view.coord_per_px;
-      hid_draw_set_color (Output.fgGC, "drill");
-      ghid_set_alpha_mult (Output.fgGC, alpha_mult * 0.75);
-      ghid_draw_outline_between_layers (cyl_info.from_layer, cyl_info.to_layer, drawn_area);
-      if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_hole_cyl_callback, &cyl_info);
-      if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, via_hole_cyl_callback, &cyl_info);
+      hid_draw_set_color (gc, "drill");
+      ghid_set_alpha_mult (gc, alpha_mult * 0.75);
+      ghid_draw_outline_between_layers (gc, cyl_info.from_layer, cyl_info.to_layer);
+      if (PCB->PinOn) r_search (PCB->Data->pin_tree, gc->clip_box, NULL, pin_hole_cyl_callback, &cyl_info);
+      if (PCB->ViaOn) r_search (PCB->Data->via_tree, gc->clip_box, NULL, via_hole_cyl_callback, &cyl_info);
     }
 #endif
   }
 #undef FADE_FACTOR
 
-  ghid_set_alpha_mult (Output.fgGC, 1.0);
+  ghid_set_alpha_mult (gc, 1.0);
 
   if (TEST_FLAG (CHECKPLANESFLAG, PCB))
     return;
 
-  side = SWAP_IDENT ? BOTTOM_SIDE : TOP_SIDE;
+  info.side = SWAP_IDENT ? BOTTOM_SIDE : TOP_SIDE;
 
   /* Draw pins, pads, vias below silk */
   if (global_view_2d) {
@@ -2274,41 +2294,41 @@ ghid_draw_everything (BoxType *drawn_area)
       glPushAttrib (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
       glColorMask (0, 0, 0, 0);
       glDepthMask (GL_FALSE);
-      if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, hole_callback, NULL);
-      if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, hole_callback, NULL);
-      fill_board_outline_holes (Output.bgGC, drawn_area);
+      if (PCB->PinOn) r_search (PCB->Data->pin_tree, gc->clip_box, NULL, hole_callback, gc);
+      if (PCB->ViaOn) r_search (PCB->Data->via_tree, gc->clip_box, NULL, hole_callback, gc);
+      fill_board_outline_holes (Output.bgGC);
       hidgl_flush_triangles (priv->hidgl);
       glPopAttrib ();
     }
 
-    if (PCB->PinOn) r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, &side);
-    if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_callback, NULL);
-    if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, via_callback, NULL);
+    if (PCB->PinOn) r_search (PCB->Data->pad_tree, gc->clip_box, NULL, pad_callback, &info);
+    if (PCB->PinOn) r_search (PCB->Data->pin_tree, gc->clip_box, NULL, pin_callback, gc);
+    if (PCB->ViaOn) r_search (PCB->Data->via_tree, gc->clip_box, NULL, via_callback, gc);
 
     end_subcomposite (priv->hidgl);
   }
 
   /* Draw the solder mask if turned on */
-  if (gui->set_layer (SWAP_IDENT ? "soldermask" : "componentmask",
-                      SWAP_IDENT ? SL (MASK, BOTTOM) : SL (MASK, TOP), 0)) {
-    GhidDrawMask (side, drawn_area);
-    gui->end_layer ();
+  if (gui->set_layer (gc, SWAP_IDENT ? "soldermask" : "componentmask",
+                          SWAP_IDENT ? SL (MASK, BOTTOM) : SL (MASK, TOP), 0)) {
+    GhidDrawMask (gc, info.side);
+    gui->end_layer (gc);
   }
 
-  if (gui->set_layer (SWAP_IDENT ? "bottomsilk" : "topsilk",
-                      SWAP_IDENT ? SL (SILK, BOTTOM) : SL (SILK, TOP), 0)) {
-      DrawSilk (side, drawn_area);
-      gui->end_layer ();
+  if (gui->set_layer (gc, SWAP_IDENT ? "bottomsilk" : "topsilk",
+                          SWAP_IDENT ? SL (SILK, BOTTOM) : SL (SILK, TOP), 0)) {
+      DrawSilk (gc, info.side);
+      gui->end_layer (gc);
   }
 
   /* Draw element Marks */
   if (PCB->PinOn)
-    r_search (PCB->Data->element_tree, drawn_area, NULL, EMark_callback, NULL);
+    r_search (PCB->Data->element_tree, gc->clip_box, NULL, EMark_callback, gc);
 
   /* Draw rat lines on top */
-  if (PCB->RatOn && gui->set_layer ("rats", SL (RATS, 0), 0)) {
-    DrawRats(drawn_area);
-    gui->end_layer ();
+  if (PCB->RatOn && gui->set_layer (gc, "rats", SL (RATS, 0), 0)) {
+    DrawRats(gc);
+    gui->end_layer (gc);
   }
 
   Settings.ShowBottomSide = save_show_solder;
@@ -2335,6 +2355,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
                      0, 0, 0, 1};
   bool horizon_problem = false;
   static bool do_once = true;
+  hidGC gc;
 
   if (do_once) {
     do_once = false;
@@ -2345,7 +2366,8 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   ghid_start_drawing (port, widget);
 
-  Output.fgGC = hid_draw_make_gc (&ghid_graphics);
+#warning FUBAR
+  gc = hid_draw_make_gc (&ghid_graphics);
   Output.bgGC = hid_draw_make_gc (&ghid_graphics);
   Output.pmGC = hid_draw_make_gc (&ghid_graphics);
 
@@ -2533,12 +2555,12 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   region.Y1 = MAX (0, MIN (PCB->MaxHeight, region.Y1));
   region.Y2 = MAX (0, MIN (PCB->MaxHeight, region.Y2));
 
+  common_set_clip_box (gc, &region);
+
   glColor3f (port->bg_color.red / 65535.,
              port->bg_color.green / 65535.,
              port->bg_color.blue / 65535.);
 
-  ghid_invalidate_current_gc ();
-
   /* Setup stenciling */
   /* Drawing operations set the stencil buffer to '1' */
   glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); /* Stencil pass => replace stencil value (with 1) */
@@ -2581,8 +2603,8 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   ghid_draw_bg_image ();
 
-  /* hid_expose_callback (&ghid_hid, &region, 0); */
-  ghid_draw_everything (&region);
+  /* hid_expose_callback (&ghid_hid, 0); */
+  ghid_draw_everything (gc);
   hidgl_flush_triangles (priv->hidgl);
 
   glTexCoord2f (0., 0.);
@@ -2627,14 +2649,12 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   /* Set the current depth to the right value for the layer we are editing */
   priv->edit_depth = compute_depth (GetLayerGroupNumberByNumber (INDEXOFCURRENT));
-  hidgl_set_depth (Output.fgGC, priv->edit_depth);
-
-  ghid_draw_grid (Output.fgGC, &region);
+  hidgl_set_depth (gc, priv->edit_depth);
 
-  ghid_invalidate_current_gc ();
+  ghid_draw_grid (gc);
 
-  DrawAttached (Output.fgGC);
-  DrawMark (Output.fgGC);
+  DrawAttached (gc);
+  DrawMark (gc);
   hidgl_flush_triangles (priv->hidgl);
 
   glEnable (GL_LIGHTING);
@@ -2687,7 +2707,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   }
 
   if (!global_view_2d)
-    ghid_draw_packages (&region);
+    ghid_draw_packages (gc);
 
   glDisable (GL_CULL_FACE);
   glDisable (GL_DEPTH_TEST);
@@ -2695,20 +2715,19 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glDisable (GL_COLOR_MATERIAL);
   glDisable (GL_LIGHTING);
 
-  draw_crosshair (Output.fgGC, priv);
+  draw_crosshair (gc, priv);
   object3d_draw_debug ();
 
   hidgl_flush_triangles (priv->hidgl);
 
-  draw_lead_user (Output.fgGC, priv);
+  draw_lead_user (gc, priv);
 
   ghid_end_drawing (port, widget);
 
-  hid_draw_destroy_gc (Output.fgGC);
+  hid_draw_destroy_gc (gc);
   hid_draw_destroy_gc (Output.bgGC);
   hid_draw_destroy_gc (Output.pmGC);
 
-  Output.fgGC = NULL;
   Output.bgGC = NULL;
   Output.pmGC = NULL;
   g_timer_start (priv->time_since_expose);
@@ -2746,6 +2765,10 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   Coord save_max_width;
   Coord save_max_height;
   double xz, yz;
+  hidGC gc;
+
+#warning FUBAR NULL gc
+  gc = NULL;
 
   save_view = gport->view;
   save_width = gport->width;
@@ -2837,7 +2860,6 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   glStencilFunc (GL_ALWAYS, 0, 0);
 
   /* call the drawing routine */
-  ghid_invalidate_current_gc ();
   glPushMatrix ();
   glScalef ((gport->view.flip_x ? -1. : 1.) / gport->view.coord_per_px,
             (gport->view.flip_y ? -1. : 1.) / gport->view.coord_per_px,
@@ -2847,7 +2869,8 @@ ghid_pinout_preview_expose (GtkWidget *widget,
                 gport->view.flip_y ? gport->view.y0 - PCB->MaxHeight :
                                     -gport->view.y0, 0);
 
-  hid_expose_callback (&ghid_hid, NULL, pinout->element);
+  hidgl_set_depth (gc, 0.);
+  hid_expose_callback (&ghid_hid, pinout->element);
   hidgl_flush_triangles (priv->hidgl);
   glPopMatrix ();
 
@@ -2876,6 +2899,10 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   view_data save_view;
   int save_width, save_height;
   BoxType region;
+  hidGC gc;
+
+#warning FUBAR null GC
+  gc = NULL;
 
   save_view = gport->view;
   save_width = gport->width;
@@ -2949,7 +2976,6 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   glStencilFunc (GL_ALWAYS, 0, 0);
 
   /* call the drawing routine */
-  ghid_invalidate_current_gc ();
   glPushMatrix ();
   glScalef ((gport->view.flip_x ? -1. : 1.) / gport->view.coord_per_px,
             (gport->view.flip_y ? -1. : 1.) / gport->view.coord_per_px,
@@ -2969,7 +2995,9 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   region.Y1 = MAX (0, MIN (PCB->MaxHeight, region.Y1));
   region.Y2 = MAX (0, MIN (PCB->MaxHeight, region.Y2));
 
-  hid_expose_callback (&ghid_hid, &region, NULL);
+  common_set_clip_box (gc, &region);
+
+  hid_expose_callback (&ghid_hid, NULL);
   hidgl_flush_triangles (priv->hidgl);
   glPopMatrix ();
 
@@ -3013,8 +3041,6 @@ ghid_request_debug_draw (void)
   glLoadIdentity ();
   glTranslatef (0.0f, 0.0f, -Z_NEAR);
 
-  ghid_invalidate_current_gc ();
-
   /* Setup stenciling */
   glDisable (GL_STENCIL_TEST);
 
@@ -3031,7 +3057,7 @@ ghid_request_debug_draw (void)
 }
 
 void
-ghid_flush_debug_draw (void)
+ghid_flush_debug_draw (hidGC gc)
 {
   render_priv *priv = gport->render_priv;
   GtkWidget *widget = gport->drawing_area;
@@ -3046,11 +3072,12 @@ ghid_flush_debug_draw (void)
 }
 
 void
-ghid_finish_debug_draw (void)
+ghid_finish_debug_draw (hidGC gc)
 {
-  render_priv *priv = gport->render_priv;
+  gtkGC gtk_gc = (gtkGC)gc;
+  hidgl_instance *hidgl = gtk_gc->hidgl_gc.hidgl;
 
-  hidgl_flush_triangles (priv->hidgl);
+  hidgl_flush_triangles (hidgl);
   glPopMatrix ();
 
   ghid_end_drawing (gport, gport->drawing_area);
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index a14372c..cacc60f 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -473,9 +473,9 @@ void ghid_logv (const char *fmt, va_list args);
 void ghid_pinout_window_show (GHidPort *out, ElementType *Element);
 
 /* gtkhid-gdk.c AND gtkhid-gl.c */
-int ghid_set_layer (const char *name, int group, int empty);
+int ghid_set_layer (hidGC gc, const char *name, int group, int empty);
 hidGC ghid_make_gc (void);
-void ghid_destroy_gc (hidGC);
+void ghid_destroy_gc (hidGC gc);
 void ghid_use_mask (hidGC gc, enum mask_mode mode);
 void ghid_set_color (hidGC gc, const char *name);
 void ghid_set_line_cap (hidGC gc, EndCapStyle style);
@@ -504,8 +504,8 @@ gboolean ghid_pinout_preview_expose (GtkWidget * widget, GdkEventExpose * ev);
 GdkPixmap *ghid_render_pixmap (int cx, int cy, double zoom,
                                int width, int height, int depth);
 HID_DRAW *ghid_request_debug_draw (void);
-void ghid_flush_debug_draw (void);
-void ghid_finish_debug_draw (void);
+void ghid_flush_debug_draw (hidGC gc);
+void ghid_finish_debug_draw (hidGC gc);
 bool ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y);
 bool ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y);
 void ghid_port_rotate (void *ball, float *quarternion, gpointer userdata);
diff --git a/src/hid/lesstif/main.c b/src/hid/lesstif/main.c
index 42f32a8..feab786 100644
--- a/src/hid/lesstif/main.c
+++ b/src/hid/lesstif/main.c
@@ -815,6 +815,7 @@ Benchmark (int argc, char **argv, Coord x, Coord y)
   time_t start, end;
   BoxType region;
   Drawable save_main;
+  hidGC gc;
 
   save_main = main_pixmap;
   main_pixmap = window;
@@ -824,13 +825,18 @@ Benchmark (int argc, char **argv, Coord x, Coord y)
   region.X2 = PCB->MaxWidth;
   region.Y2 = PCB->MaxHeight;
 
+#warning NULL gc
+  gc = NULL;
+
+  common_set_clip_box (gc, &region);
+
   pixmap = window;
   XSync (display, 0);
   time (&start);
   do
     {
       XFillRectangle (display, pixmap, bg_gc, 0, 0, view_width, view_height);
-      hid_expose_callback (&lesstif_hid, &region, 0);
+      hid_expose_callback (&lesstif_hid, 0);
       XSync (display, 0);
       time (&end);
       i++;
@@ -2495,12 +2501,16 @@ static int need_redraw = 0;
 static Boolean
 idle_proc (XtPointer dummy)
 {
+  hidGC gc;
+
+#warning NULL gc
+  gc = NULL;
+
   if (need_redraw)
     {
       int mx, my;
       BoxType region;
-#warning NULL gc
-      lesstif_use_mask (NULL, HID_MASK_OFF);
+      lesstif_use_mask (gc, HID_MASK_OFF);
       pixmap = main_pixmap;
       mx = view_width;
       my = view_height;
@@ -2578,11 +2588,13 @@ idle_proc (XtPointer dummy)
 			      rightmost-leftmost+1, view_height-bottommost+1);
 	    }
 	}
+
+      common_set_clip_box (gc, &region);
+
       DrawBackgroundImage();
-      hid_expose_callback (&lesstif_hid, &region, 0);
+      hid_expose_callback (&lesstif_hid, 0);
       draw_grid ();
-#warning NULL gc
-      lesstif_use_mask (NULL, HID_MASK_OFF);
+      lesstif_use_mask (gc, HID_MASK_OFF);
       show_crosshair (0); /* To keep the drawn / not drawn info correct */
       XSetFunction (display, my_gc, GXcopy);
       XCopyArea (display, main_pixmap, window, my_gc, 0, 0, view_width,
@@ -3001,7 +3013,7 @@ lesstif_notify_mark_change (bool changes_complete)
 }
 
 static int
-lesstif_set_layer (const char *name, int group, int empty)
+lesstif_set_layer (hidGC gc, const char *name, int group, int empty)
 {
   int idx = group;
   if (idx >= 0 && idx < max_group)
@@ -3755,6 +3767,7 @@ pinout_callback (Widget da, PinoutData * pd,
   double save_vz;
   Pixmap save_px;
   int reason = cbs ? cbs->reason : 0;
+  hidGC gc;
 
   if (pd->window == 0 && reason == XmCR_RESIZE)
     return;
@@ -3803,8 +3816,13 @@ pinout_callback (Widget da, PinoutData * pd,
   region.X2 = PCB->MaxWidth;
   region.Y2 = PCB->MaxHeight;
 
+#warning NULL gc
+  gc = NULL;
+
+  common_set_clip_box (gc, &region);
+
   XFillRectangle (display, pixmap, bg_gc, 0, 0, pd->v_width, pd->v_height);
-  hid_expose_callback (&lesstif_hid, &region, pd->item);
+  hid_expose_callback (&lesstif_hid, pd->item);
 
   pinout = 0;
   view_left_x = save_vx;
@@ -4035,7 +4053,7 @@ lesstif_request_debug_draw (void)
 }
 
 static void
-lesstif_flush_debug_draw (void)
+lesstif_flush_debug_draw (hidGC gc)
 {
   /* Copy the backing pixmap to the display and redraw any attached objects */
   XSetFunction (display, my_gc, GXcopy);
@@ -4051,9 +4069,9 @@ lesstif_flush_debug_draw (void)
 }
 
 static void
-lesstif_finish_debug_draw (void)
+lesstif_finish_debug_draw (hidGC gc)
 {
-  lesstif_flush_debug_draw ();
+  lesstif_flush_debug_draw (gc);
   /* No special tear down requirements
    */
 }
diff --git a/src/hid/nelma/nelma.c b/src/hid/nelma/nelma.c
index 18174a5..a97b526 100644
--- a/src/hid/nelma/nelma.c
+++ b/src/hid/nelma/nelma.c
@@ -645,10 +645,13 @@ nelma_start_png_export()
 	region.X2 = PCB->MaxWidth;
 	region.Y2 = PCB->MaxHeight;
 
+#warning NULL gc
+  common_set_clip_box (NULL, &region);
+
 	linewidth = -1;
 	lastbrush = (gdImagePtr)((void *) -1);
 
-	hid_expose_callback(&nelma_hid, &region, 0);
+	hid_expose_callback(&nelma_hid, 0);
 }
 
 static void 
@@ -728,7 +731,7 @@ nelma_do_export(HID_Attr_Val * options)
 /* *** PNG export (slightly modified code from PNG export HID) ************* */
 
 static int 
-nelma_set_layer(const char *name, int group, int empty)
+nelma_set_layer(hidGC gc, const char *name, int group, int empty)
 {
 	int             idx = (group >= 0 && group < max_group) ?
 	PCB->LayerGroups.Entries[group][0] : group;
diff --git a/src/hid/png/png.c b/src/hid/png/png.c
index 08701fe..4bb1962 100644
--- a/src/hid/png/png.c
+++ b/src/hid/png/png.c
@@ -549,6 +549,10 @@ png_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
   int saved_show_bottom_side;
   BoxType region;
   FlagType save_flags;
+  hidGC gc;
+
+#warning NULL gc
+  gc = NULL;
 
   f = the_file;
 
@@ -562,6 +566,8 @@ png_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
   else
     bounds = &region;
 
+  common_set_clip_box (gc, bounds);
+
   memset (print_group, 0, sizeof (print_group));
   memset (print_layer, 0, sizeof (print_layer));
 
@@ -654,7 +660,7 @@ png_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
 	}
     }
 
-  hid_expose_callback (&png_hid, bounds, 0);
+  hid_expose_callback (&png_hid, 0);
 
   memcpy (LayerStack, saved_layer_stack, sizeof (LayerStack));
   PCB->Flags = save_flags;
@@ -1199,7 +1205,7 @@ static int is_drill;
 static int is_copper;
 
 static int
-png_set_layer (const char *name, int group, int empty)
+png_set_layer (hidGC gc, const char *name, int group, int empty)
 {
   int idx = (group >= 0
 	     && group <
diff --git a/src/hid/ps/eps.c b/src/hid/ps/eps.c
index 2d2b089..20f7f77 100644
--- a/src/hid/ps/eps.c
+++ b/src/hid/ps/eps.c
@@ -33,7 +33,6 @@
 static HID_Attribute * eps_get_export_options (int *n);
 static void eps_do_export (HID_Attr_Val * options);
 static void eps_parse_arguments (int *argc, char ***argv);
-static int eps_set_layer (const char *name, int group, int empty);
 static hidGC eps_make_gc (void);
 static void eps_destroy_gc (hidGC gc);
 static void eps_set_color (hidGC gc, const char *name);
@@ -200,6 +199,9 @@ eps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
   else
     bounds = &region;
 
+#warning NULL gc
+  common_set_clip_box (NULL, bounds);
+
   memset (print_group, 0, sizeof (print_group));
   memset (print_layer, 0, sizeof (print_layer));
 
@@ -301,7 +303,7 @@ eps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
   fprintf (f,
 	   "/a { gsave setlinewidth translate scale 0 0 1 5 3 roll arc stroke grestore} bind def\n");
 
-  hid_expose_callback (&eps_hid, bounds, 0);
+  hid_expose_callback (&eps_hid, 0);
 
   fprintf (f, "showpage\n");
 
@@ -362,7 +364,7 @@ static int is_paste;
 static int is_drill;
 
 static int
-eps_set_layer (const char *name, int group, int empty)
+eps_set_layer (hidGC gc, const char *name, int group, int empty)
 {
   int idx = (group >= 0
 	     && group <
diff --git a/src/hid/ps/ps.c b/src/hid/ps/ps.c
index 544be9a..ee79a33 100644
--- a/src/hid/ps/ps.c
+++ b/src/hid/ps/ps.c
@@ -32,7 +32,7 @@
 
 #define CRASH fprintf(stderr, "HID error: pcb called unimplemented PS function %s.\n", __FUNCTION__); abort()
 
-static int ps_set_layer (const char *name, int group, int empty);
+static int ps_set_layer (hidGC gc, const char *name, int group, int empty);
 static void use_gc (hidGC gc);
 
 typedef struct ps_gc_struct
@@ -398,8 +398,6 @@ static struct {
 
   double scale_factor;
 
-  BoxType region;
-
   HID_Attr_Val ps_values[NUM_OPTIONS];
 
   bool is_mask;
@@ -597,6 +595,11 @@ ps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
   int i;
   static int saved_layer_stack[MAX_LAYER];
   FlagType save_thindraw;
+  BoxType region;
+  hidGC gc;
+
+#warning NULL gc
+  gc = NULL;
 
   save_thindraw = PCB->Flags;
   CLEAR_FLAG(THINDRAWFLAG, PCB);
@@ -674,13 +677,15 @@ ps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
 
   global.linewidth = -1;
   /* reset static vars */
-  ps_set_layer (NULL, 0, -1);
+  ps_set_layer (gc, NULL, 0, -1);
   use_gc (NULL);
 
-  global.region.X1 = 0;
-  global.region.Y1 = 0;
-  global.region.X2 = PCB->MaxWidth;
-  global.region.Y2 = PCB->MaxHeight;
+  region.X1 = 0;
+  region.Y1 = 0;
+  region.X2 = PCB->MaxWidth;
+  region.Y2 = PCB->MaxHeight;
+
+  common_set_clip_box (gc, &region);
 
   if (!global.multi_file)
     {
@@ -693,13 +698,13 @@ ps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
 
       global.doing_toc = 1;
       global.pagecount = 1;  /* 'pagecount' is modified by hid_expose_callback() call */
-      hid_expose_callback (&ps_hid, &global.region, 0);
+      hid_expose_callback (&ps_hid, 0);
     }
 
   global.pagecount = 1; /* Reset 'pagecount' if single file */
   global.doing_toc = 0;
-  ps_set_layer (NULL, 0, -1);  /* reset static vars */
-  hid_expose_callback (&ps_hid, &global.region, 0);
+  ps_set_layer (gc, NULL, 0, -1);  /* reset static vars */
+  hid_expose_callback (&ps_hid, 0);
 
   if (the_file)
     fprintf (the_file, "showpage\n");
@@ -785,7 +790,7 @@ corner (FILE *fh, Coord x, Coord y, int dx, int dy)
 }
 
 static int
-ps_set_layer (const char *name, int group, int empty)
+ps_set_layer (hidGC gc, const char *name, int group, int empty)
 {
   static int lastgroup = -1;
   time_t currenttime;
@@ -1007,7 +1012,7 @@ ps_set_layer (const char *name, int group, int empty)
       strcmp (name, "route") != 0
       )
     {
-      dapi->draw_layer (global.outline_layer, &global.region, NULL);
+      dapi->draw_layer (gc, global.outline_layer, NULL);
     }
 
   return 1;
@@ -1265,7 +1270,7 @@ ps_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
 }
 
 static void
-fill_polyarea (hidGC gc, POLYAREA * pa, const BoxType * clip_box)
+fill_polyarea (hidGC gc, POLYAREA * pa)
 {
   /* Ignore clip_box, just draw everything */
 
@@ -1294,15 +1299,15 @@ fill_polyarea (hidGC gc, POLYAREA * pa, const BoxType * clip_box)
 }
 
 static void
-ps_draw_pcb_polygon (hidGC gc, PolygonType * poly, const BoxType * clip_box)
+ps_draw_pcb_polygon (hidGC gc, PolygonType * poly)
 {
-  fill_polyarea (gc, poly->Clipped, clip_box);
+  fill_polyarea (gc, poly->Clipped);
   if (TEST_FLAG (FULLPOLYFLAG, poly))
     {
       POLYAREA *pa;
 
       for (pa = poly->Clipped->f; pa != poly->Clipped; pa = pa->f)
-        fill_polyarea (gc, pa, clip_box);
+        fill_polyarea (gc, pa);
     }
 }
 
diff --git a/src/hid_draw.h b/src/hid_draw.h
index 840cb32..a654686 100644
--- a/src/hid_draw.h
+++ b/src/hid_draw.h
@@ -54,14 +54,14 @@ struct hid_draw_st
   void (*draw_pcb_line) (hidGC gc, LineType *line);
   void (*draw_pcb_arc) (hidGC gc, ArcType *arc);
   void (*draw_pcb_text) (hidGC gc, TextType *, Coord);
-  void (*draw_pcb_polygon) (hidGC gc, PolygonType *poly, const BoxType *clip_box);
+  void (*draw_pcb_polygon) (hidGC gc, PolygonType *poly);
   void (*draw_pcb_pad) (hidGC gc, PadType *pad, bool clip, bool mask);
   void (*draw_pcb_pv) (hidGC gc, PinType *pv, bool mask);
   void (*draw_pcb_pv_hole) (hidGC gc, PinType *pv);
 
   /* The following are not meant to be called outside of the GUI implementations of the above APIs */
-  void (*_fill_pcb_polygon) (hidGC gc, PolygonType *poly, const BoxType *clip_box);
-  void (*_thindraw_pcb_polygon) (hidGC gc, PolygonType *poly, const BoxType *clip_box);
+  void (*_fill_pcb_polygon) (hidGC gc, PolygonType *poly);
+  void (*_thindraw_pcb_polygon) (hidGC gc, PolygonType *poly);
   void (*_fill_pcb_pad) (hidGC gc, PadType *pad, bool clip, bool mask);
   void (*_thindraw_pcb_pad) (hidGC gc, PadType *pad, bool clip, bool mask);
   void (*_fill_pcb_pv) (hidGC gc, PinType *pv, bool mask);
@@ -75,6 +75,7 @@ struct hid_draw_st
 struct hid_gc_struct {
   HID *hid;   /* Used by HIDs to validate the GCs passed belong to them */
   HID_DRAW *hid_draw;
+  BoxType *clip_box; /* Used by HIDs and draw.c to restrict rendering to a given region */
 };
 
 /* Calling wrappers to access the vfunc table */
@@ -183,9 +184,9 @@ hid_draw_pcb_text (hidGC gc, TextType *text, Coord min_width)
 }
 
 inline void
-hid_draw_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+hid_draw_pcb_polygon (hidGC gc, PolygonType *poly)
 {
-  gc->hid_draw->draw_pcb_polygon (gc, poly, clip_box);
+  gc->hid_draw->draw_pcb_polygon (gc, poly);
 }
 
 inline void
@@ -208,15 +209,15 @@ hid_draw_pcb_pv_hole (hidGC gc, PinType *pv)
 
 
 inline void
-hid_draw__fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+hid_draw__fill_pcb_polygon (hidGC gc, PolygonType *poly)
 {
-  gc->hid_draw->_fill_pcb_polygon (gc, poly, clip_box);
+  gc->hid_draw->_fill_pcb_polygon (gc, poly);
 }
 
 inline void
-hid_draw__thin_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+hid_draw__thin_pcb_polygon (hidGC gc, PolygonType *poly)
 {
-  gc->hid_draw->_thindraw_pcb_polygon (gc, poly, clip_box);
+  gc->hid_draw->_thindraw_pcb_polygon (gc, poly);
 }
 
 inline void

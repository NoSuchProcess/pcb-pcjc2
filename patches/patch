Bottom: b966b261ccd1a82255f83c5c47acfcde1f604e7f
Top:    867712ea8853622f71c69e8c4c77d7060e806b05
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-11-25 20:09:33 +0000

FBOs differently


---

diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 3f02ff7..9c55b3a 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -70,6 +70,16 @@ static int global_view_2d = 1;
 typedef struct render_priv {
   GdkGLConfig *glconfig;
   bool trans_lines;
+  int no_layers;
+  GLuint *layer_texture;
+  bool *layer_rendered;
+  GLuint depth_stencil_buffer;
+  GLuint fbo_no_stencil;
+  GLuint fbo_with_stencil;
+  int fbo_width;
+  int fbo_height;
+  int textures_ok;
+  hidgl_shader *stack_program;
 } render_priv;
 
 
@@ -157,6 +167,7 @@ ghid_set_layer (const char *name, int group, int empty)
   render_priv *priv = gport->render_priv;
   static int stencil_bit = 0;
   bool group_visible = false;
+  bool fbo_composited = false;
   int idx = group;
   if (idx >= 0 && idx < max_group)
     {
@@ -180,6 +191,7 @@ ghid_set_layer (const char *name, int group, int empty)
     {
       priv->trans_lines = true;
       group_visible = PCB->Data->Layer[idx].On;
+      fbo_composited = true;
     }
   else if (idx < 0)
     {
@@ -211,10 +223,11 @@ ghid_set_layer (const char *name, int group, int empty)
 	}
     }
 
+#if 1
   glEnable (GL_STENCIL_TEST);                   // Enable Stencil test
   glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);   // Stencil pass => replace stencil value (with 1)
   hidgl_return_stencil_bit (stencil_bit);       // Relinquish any bitplane we previously used
-  if (group_visible) {
+  if (group_visible && !fbo_composited) {
     stencil_bit = hidgl_assign_clear_stencil_bit();       // Get a new (clean) bitplane to stencil with
     glStencilMask (stencil_bit);                          // Only write to our subcompositing stencil bitplane
     glStencilFunc (GL_GREATER, stencil_bit, stencil_bit); // Pass stencil test if our assigned bit is clear
@@ -223,6 +236,7 @@ ghid_set_layer (const char *name, int group, int empty)
     glStencilMask (0);
     glStencilFunc (GL_ALWAYS, 0, 0);  // Always pass stencil test
   }
+#endif
 
   return group_visible;
 }
@@ -304,7 +318,7 @@ ghid_draw_grid (BoxTypePtr drawn_area)
              gport->grid_color.blue / 65535.);
   glTexCoord2f (0., 0.);
 
-  glDisable (GL_STENCIL_TEST);
+//  glDisable (GL_STENCIL_TEST);
   glEnable (GL_COLOR_LOGIC_OP);
   glLogicOp (GL_XOR);
   glEnableClientState (GL_VERTEX_ARRAY);
@@ -326,7 +340,7 @@ ghid_draw_grid (BoxTypePtr drawn_area)
 
   glDisableClientState (GL_VERTEX_ARRAY);
   glDisable (GL_COLOR_LOGIC_OP);
-  glEnable (GL_STENCIL_TEST);
+//  glEnable (GL_STENCIL_TEST);
 }
 
 #if 0
@@ -550,10 +564,12 @@ ghid_set_color (hidGC gc, const char *name)
       r = gport->offlimits_color.red   / 65535.;
       g = gport->offlimits_color.green / 65535.;
       b = gport->offlimits_color.blue  / 65535.;
+      alpha_mult = 1.;
     }
   else
     {
-      alpha_mult = 0.7;
+//      alpha_mult = 0.7;
+      alpha_mult = 1.;
       if (hid_cache_color (0, name, &cval, &cache))
         cc = (ColorCache *) cval.ptr;
       else
@@ -1007,6 +1023,38 @@ ghid_init_renderer (int *argc, char ***argv, GHidPort *port)
 }
 
 void
+ghid_init_gl (GHidPort *port)
+{
+  render_priv *priv = port->render_priv;
+  char *stack_fs_source =
+           "sampler2D foobar;\n"
+           "sampler2D layer_texture[16];\n"
+           "\n"
+           "void main()\n"
+           "{\n"
+           "  vec4 layer_value[16];\n"
+           "  int layer_num;\n"
+           "\n"
+           "  for (layer_num = 0; layer_num < 16; layer_num++) {\n"
+           //"    layer_value[ layer_num ] = texture2D (layer_texture[ layer_num ], gl_TexCoord[0].st);\n"
+           "    layer_value[ layer_num ] = texture2D (foobar, gl_TexCoord[0].st);\n"
+           "  }\n"
+           "\n"
+           "  vec4 accum = layer_value[0] * layer_value[0].a;\n"
+           "\n"
+           "  for (layer_num = 1; layer_num < 16; layer_num++) {\n"
+           "    float one_minus_sa = 1. - layer_value[ layer_num ].a;\n"
+           "    accum = accum * one_minus_sa + layer_value[ layer_num ] * layer_value[0].a;\n"
+           "  }\n"
+           "\n"
+           "  gl_FragColor = accum;\n"
+           "}\n";
+
+  priv->stack_program =
+    hidgl_shader_new ("layerstack_rendering", NULL, stack_fs_source);
+}
+
+void
 ghid_init_drawing_widget (GtkWidget *widget, GHidPort *port)
 {
   render_priv *priv = port->render_priv;
@@ -1189,8 +1237,8 @@ pad_callback (const BoxType * b, void *cl)
 static int
 hole_callback (const BoxType * b, void *cl)
 {
-#if 0
   PinTypePtr pin = (PinTypePtr) b;
+#if 0
   int plated = cl ? *(int *) cl : -1;
 
   switch (plated)
@@ -1207,7 +1255,25 @@ hole_callback (const BoxType * b, void *cl)
       break;
     }
 #endif
-  DrawHole ((PinTypePtr) b);
+//  DrawHole ((PinTypePtr) b);
+
+#if 0
+  if (TEST_FLAG (THINDRAWFLAG, PCB))
+    {
+      if (!TEST_FLAG (HOLEFLAG, Ptr))
+	{
+	  gui->set_line_cap (Output.fgGC, Round_Cap);
+	  gui->set_line_width (Output.fgGC, 0);
+	  gui->draw_arc (Output.fgGC,
+			 Ptr->X, Ptr->Y, Ptr->DrillingHole / 2,
+			 Ptr->DrillingHole / 2, 0, 360);
+	}
+    }
+  else
+#endif
+    {
+      hidgl_fill_circle (pin->X, pin->Y, pin->DrillingHole / 2);
+    }
   return 1;
 }
 
@@ -1470,18 +1536,6 @@ DrawLayerGroup (int group, const BoxType * screen)
 
       first_run = 0;
 
-      if (rv) {
-        /* Mask out drilled holes on this layer */
-        hidgl_flush_triangles (&buffer);
-        glPushAttrib (GL_COLOR_BUFFER_BIT);
-        glColorMask (0, 0, 0, 0);
-        gui->set_color (Output.bgGC, PCB->MaskColor);
-        if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
-        if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
-        hidgl_flush_triangles (&buffer);
-        glPopAttrib ();
-      }
-
       /* draw all polygons on this layer */
       if (Layer->PolygonN) {
         info.Layer = Layer;
@@ -1490,36 +1544,8 @@ DrawLayerGroup (int group, const BoxType * screen)
 
         /* HACK: Subcomposite polygons separately from other layer primitives */
         /* Reset the compositing */
-        gui->set_layer (NULL, SL (FINISHED, 0), 0);
-        gui->set_layer (0, group, 0);
-
-        if (rv) {
-          hidgl_flush_triangles (&buffer);
-          glPushAttrib (GL_COLOR_BUFFER_BIT);
-          glColorMask (0, 0, 0, 0);
-          /* Mask out drilled holes on this layer */
-          if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
-          if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
-          hidgl_flush_triangles (&buffer);
-          glPopAttrib ();
-        }
-      }
-
-      /* Draw pins, vias and pads on this layer */
-      if (!global_view_2d && rv) {
-        if (PCB->PinOn &&
-            (group == solder_group || group == component_group))
-          r_search (PCB->Data->pin_tree, screen, NULL, pin_name_callback, Layer);
-        if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, pin_inlayer_callback, Layer);
-        if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, via_inlayer_callback, Layer);
-        if ((group == component_group && !SWAP_IDENT) ||
-            (group == solder_group    &&  SWAP_IDENT))
-          if (PCB->PinOn)
-            r_search (PCB->Data->pad_tree, screen, NULL, pad_callback, Layer);
-        if ((group == solder_group    && !SWAP_IDENT) ||
-            (group == component_group &&  SWAP_IDENT))
-          if (PCB->PinOn)
-            r_search (PCB->Data->pad_tree, screen, NULL, backPad_callback, Layer);
+//        gui->set_layer (NULL, SL (FINISHED, 0), 0);
+//        gui->set_layer (0, group, 0);
       }
 
       if (TEST_FLAG (CHECKPLANESFLAG, PCB))
@@ -1528,10 +1554,37 @@ DrawLayerGroup (int group, const BoxType * screen)
       r_search (Layer->line_tree, screen, NULL, line_callback, Layer);
       r_search (Layer->arc_tree, screen, NULL, arc_callback, Layer);
       r_search (Layer->text_tree, screen, NULL, text_callback, Layer);
+
+      /* Draw pins, vias and pads on this layer */
+      if (rv) {
+        if (!global_view_2d) {
+          if (PCB->PinOn &&
+              (group == solder_group || group == component_group))
+            r_search (PCB->Data->pin_tree, screen, NULL, pin_name_callback, Layer);
+          if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, pin_inlayer_callback, Layer);
+          if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, via_inlayer_callback, Layer);
+          if ((group == component_group && !SWAP_IDENT) ||
+              (group == solder_group    &&  SWAP_IDENT))
+            if (PCB->PinOn)
+              r_search (PCB->Data->pad_tree, screen, NULL, pad_callback, Layer);
+          if ((group == solder_group    && !SWAP_IDENT) ||
+              (group == component_group &&  SWAP_IDENT))
+            if (PCB->PinOn)
+              r_search (PCB->Data->pad_tree, screen, NULL, backPad_callback, Layer);
+        }
+        /* Erase drilled holes on this layer */
+        hidgl_flush_triangles (&buffer);
+        glPushAttrib (GL_CURRENT_BIT);
+        glColor4f (0., 0., 0., 0.);
+        if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
+        if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
+        hidgl_flush_triangles (&buffer);
+        glPopAttrib ();
+      }
     }
   }
 
-  gui->set_layer (NULL, SL (FINISHED, 0), 0);
+//  gui->set_layer (NULL, SL (FINISHED, 0), 0);
 
   return (n_entries > 1);
 }
@@ -1588,17 +1641,190 @@ struct cyl_info {
 };
 
 static int
-hole_cyl_callback (const BoxType * b, void *cl)
+draw_hole_cyl (PinType *Pin, struct cyl_info *info, int Type)
 {
-  PinTypePtr Pin = (PinTypePtr) b;
-  struct cyl_info *info = cl;
+  char *color;
+
+  if (TEST_FLAG (WARNFLAG, Pin))
+    color = PCB->WarnColor;
+  else if (TEST_FLAG (SELECTEDFLAG, Pin))
+    color = (Type == VIA_TYPE) ? PCB->ViaSelectedColor : PCB->PinSelectedColor;
+  else if (TEST_FLAG (FOUNDFLAG, Pin))
+    color = PCB->ConnectedColor;
+  else
+    color = "drill";
+
+  gui->set_color (Output.fgGC, color);
   DrawDrillChannel (Pin->X, Pin->Y, Pin->DrillingHole / 2, info->from_layer, info->to_layer, info->scale);
   return 0;
 }
 
+static int
+pin_hole_cyl_callback (const BoxType * b, void *cl)
+{
+  return draw_hole_cyl ((PinType *)b, (struct cyl_info *)cl, PIN_TYPE);
+}
+
+static int
+via_hole_cyl_callback (const BoxType * b, void *cl)
+{
+  return draw_hole_cyl ((PinType *)b, (struct cyl_info *)cl, VIA_TYPE);
+}
+
+static void
+setup_fbo (GHidPort *port, int width, int height, int no_layers)
+{
+  render_priv *priv = port->render_priv;
+  int layer;
+
+  priv->fbo_width = width;
+  priv->fbo_height = height;
+  priv->no_layers = no_layers;
+
+  /* Setup an FBO to render into (without depth / stencil) */
+  glGenFramebuffersEXT (1, &priv->fbo_no_stencil);
+  glBindFramebufferEXT (GL_FRAMEBUFFER_EXT, priv->fbo_no_stencil);
+
+  /* Setup an FBO to render into (with depth / stencil) */
+  glGenFramebuffersEXT (1, &priv->fbo_with_stencil);
+  glBindFramebufferEXT (GL_FRAMEBUFFER_EXT, priv->fbo_with_stencil);
+
+  /* Create and bind a packed depth / stencil renderbuffer */
+  glGenRenderbuffersEXT (1, &priv->depth_stencil_buffer);
+  glBindRenderbufferEXT (GL_RENDERBUFFER_EXT, priv->depth_stencil_buffer);
+  glRenderbufferStorageEXT (GL_RENDERBUFFER_EXT, GL_DEPTH24_STENCIL8_EXT,
+                            priv->fbo_width, priv->fbo_height);
+
+  /* Attach the stencil renderbuffer to the FBO */
+  glFramebufferRenderbufferEXT (GL_FRAMEBUFFER_EXT, GL_STENCIL_ATTACHMENT_EXT,
+                                GL_RENDERBUFFER_EXT, priv->depth_stencil_buffer);
+
+  /* Create some textures to render our layers into */
+  priv->layer_rendered = malloc (priv->no_layers * sizeof (bool));
+  priv->layer_texture = malloc (priv->no_layers * sizeof (GLuint));
+  for (layer = 0; layer < priv->no_layers; layer++) {
+    glGenTextures (1, &priv->layer_texture[layer]);
+    glBindTexture (GL_TEXTURE_2D, priv->layer_texture[layer]);
+
+    glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
+    glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
+    glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+    glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR_MIPMAP_LINEAR);
+
+    /* Allocate storage for each texture. The texels are undefined. */
+    glTexImage2D (GL_TEXTURE_2D, 0, GL_RGBA8,
+                  priv->fbo_width, priv->fbo_height, 0,
+                  GL_RGBA, GL_UNSIGNED_BYTE, NULL);
+  }
+  /* For sake of cleanliness, unbind the texture we last used */
+  glBindTexture (GL_TEXTURE_2D, 0);
+
+  /* Unbind the FBO for now */
+  glBindFramebufferEXT (GL_FRAMEBUFFER_EXT, 0);
+
+  /* Mark textures as needing rendering */
+  priv->textures_ok = 0;
+}
+
+
+static void
+cleanup_fbo (GHidPort *port)
+{
+  int layer;
+  render_priv *priv = port->render_priv;
+
+  glDeleteFramebuffersEXT (1, &priv->fbo_no_stencil);
+
+  glDeleteFramebuffersEXT (1, &priv->fbo_with_stencil);
+  glDeleteRenderbuffersEXT (1, &priv->depth_stencil_buffer);
+
+  for (layer = 0; layer < priv->no_layers; layer++) {
+    glDeleteTextures (1, &priv->layer_texture[layer]);
+  }
+
+  free (priv->layer_texture);
+  priv->layer_texture = NULL;
+  priv->textures_ok = 0;
+}
+
+
+static void
+setup_fbo_layer (GHidPort *port, int layer, int with_stencil)
+{
+  render_priv *priv = port->render_priv;
+  GLenum status;
+  GLuint fbo = with_stencil ? priv->fbo_with_stencil : priv->fbo_no_stencil;
+
+  /* Bind the FBO into active usage */
+  glBindFramebufferEXT (GL_FRAMEBUFFER_EXT, fbo);
+
+  /* Bind one of the textures to the FBO for rendering into */
+  glFramebufferTexture2DEXT (GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D,
+                             priv->layer_texture[layer], 0);
+
+  /* Check the OpenGL driver is happy with our FBO setup */
+  status = glCheckFramebufferStatusEXT (GL_FRAMEBUFFER_EXT);
+
+  if (status != GL_FRAMEBUFFER_COMPLETE_EXT) {
+    fprintf (stderr, "Oppos, couldn't create a complete FBO, quitting\n");
+    fprintf (stderr, "Width: %i, height: %i\n", priv->fbo_width, priv->fbo_height);
+    exit (-1);
+  }
+
+#if 0
+  glPushAttrib (GL_VIEWPORT_BIT);
+  glViewport (0, 0, priv->fbo_width, priv->fbo_height);
+  glMatrixMode (GL_PROJECTION);
+  glPushMatrix ();
+  glLoadIdentity ();
+  glOrtho (0, priv->fbo_width, priv->fbo_height, 0, -100000, 100000);
+  glMatrixMode (GL_MODELVIEW);
+  glPushMatrix ();
+  glLoadIdentity ();
+
+  glScalef ( 1. / port->zoom,
+            -1. / port->zoom,
+             1.);
+  glTranslatef (0., -PCB->MaxHeight, 0.);
+//  glTranslatef (-port->view_x0, port->view_y0 - PCB->MaxHeight, 0.);
+#endif
+
+  glClearColor (0., 0., 0., 0.);
+  if (with_stencil) {
+    glStencilMask (~0);
+    glClearStencil (0);
+    glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
+  } else {
+    glClear (GL_COLOR_BUFFER_BIT);
+  }
+  hidgl_reset_stencil_usage (); /* FIXME: This state is "global", not specific to the FBO! */
+  glDisable (GL_BLEND);
+}
+
+
+static void
+cleanup_fbo_layer (GHidPort *port)
+{
+#if 0
+  glMatrixMode (GL_MODELVIEW);
+  glPopMatrix ();
+  glMatrixMode (GL_PROJECTION);
+  glPopMatrix ();
+  glMatrixMode (GL_MODELVIEW);
+  glPopAttrib ();
+#endif
+  glBindFramebufferEXT (GL_FRAMEBUFFER_EXT, 0);
+  /* Ubind the texture from the FBO */
+  glFramebufferTexture2DEXT (GL_FRAMEBUFFER_EXT,
+                             GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, 0, 0);
+  glEnable (GL_BLEND);
+}
+
+
 void
 ghid_draw_everything (BoxTypePtr drawn_area)
 {
+  render_priv *priv = gport->render_priv;
   int i, ngroups;
   /* This is the list of layer groups we will draw.  */
   int do_group[MAX_LAYER];
@@ -1665,11 +1891,11 @@ ghid_draw_everything (BoxTypePtr drawn_area)
    */
   if (!TEST_FLAG (CHECKPLANESFLAG, PCB) &&
       gui->set_layer ("invisible", SL (INVISIBLE, 0), 0)) {
+#if 1
     if (PCB->ElementOn) {
       r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], drawn_area, NULL, backN_callback, NULL);
       DrawLayer (&(PCB->Data->BACKSILKLAYER), drawn_area);
     }
-#if 1
     if (!global_view_2d) {
       /* Draw the solder mask if turned on */
       if (gui->set_layer ("soldermask", SL (MASK, BOTTOM), 0)) {
@@ -1704,7 +1930,64 @@ ghid_draw_everything (BoxTypePtr drawn_area)
 
   /* draw all layers in layerstack order */
   for (i = ngroups - 1; i >= 0; i--) {
-    DrawLayerGroup (drawn_groups [i], drawn_area);
+    int depth = compute_depth (i);
+    int layer_visible;
+
+    /* TODO: Cache these textures between frames to avoid the overhead of recomputing */
+    if (!priv->textures_ok) {
+      /* Draw the layer into a texture */
+      setup_fbo_layer (gport, drawn_groups [i], TRUE); /* TRUE is for yes, we want a stencil buffer */
+      //setup_fbo_layer (gport, drawn_groups [i], false);
+      DrawLayerGroup (drawn_groups [i], drawn_area);
+      cleanup_fbo_layer (gport);
+      priv->layer_rendered[i] = TRUE;
+    }
+
+    hidgl_set_depth (0);
+
+    {
+      int group = drawn_groups [i];
+      int idx;
+      for (idx = 0; idx < PCB->LayerGroups.Number[group] - 1; idx ++)
+        {
+          int ni = PCB->LayerGroups.Entries[group][idx];
+          if (ni >= 0 && ni < max_copper_layer + 2
+              && PCB->Data->Layer[ni].On)
+            break;
+        }
+      idx = PCB->LayerGroups.Entries[group][idx];
+      if (idx >= 0 && idx < max_copper_layer)
+        layer_visible = PCB->Data->Layer[idx].On;
+      else
+        layer_visible = 0;
+    }
+
+#if 0
+    if (priv->layer_rendered[i] && layer_visible) {
+      float aspect = (float)priv->fbo_width / (float)priv->fbo_height;
+      /* Now render from the textures */
+      hidgl_shader_activate (NULL);
+      glColor4f (1., 1., 1., 0.7);
+      glEnable (GL_TEXTURE_2D);
+
+      glPushMatrix ();
+      glLoadIdentity ();
+
+      glBindTexture (GL_TEXTURE_2D, priv->layer_texture[drawn_groups [i]]);
+      glBegin (GL_QUADS);
+      glTexCoord2d (0.0, 1.0); glVertex3f (-aspect, -1.0, -1.);
+      glTexCoord2d (1.0, 1.0); glVertex3f ( aspect, -1.0, -1.);
+      glTexCoord2d (1.0, 0.0); glVertex3f ( aspect,  1.0, -1.);
+      glTexCoord2d (0.0, 0.0); glVertex3f (-aspect,  1.0, -1.);
+      glEnd ();
+
+      glPopMatrix ();
+
+      glBindTexture (GL_TEXTURE_2D, 0);
+      glDisable (GL_TEXTURE_2D);
+      hidgl_shader_activate (circular_program);
+    }
+#endif
 
 #if 1
     if (!global_view_2d && i > 0 &&
@@ -1718,13 +2001,78 @@ ghid_draw_everything (BoxTypePtr drawn_area)
       //      gui->set_color (Output.fgGC, PCB->MaskColor);
       gui->set_color (Output.fgGC, "drill");
       ghid_global_alpha_mult (Output.fgGC, 0.75);
-      if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, hole_cyl_callback, &cyl_info);
-      if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, hole_cyl_callback, &cyl_info);
+      if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_hole_cyl_callback, &cyl_info);
+      if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, via_hole_cyl_callback, &cyl_info);
       ghid_global_alpha_mult (Output.fgGC, 1.0);
     }
 #endif
   }
 
+// HELLO
+  hidgl_shader_activate (priv->stack_program);
+  {
+#define NO_SAMPLERS 16
+    GLint tex_ids[NO_SAMPLERS];
+    GLuint sp = hidgl_shader_get_program (priv->stack_program);
+    //GLint loc = glGetUniformLocation (sp, "layer_texture");
+    GLint loc = glGetUniformLocation (sp, "foobar");
+    int layer;
+
+    for (layer = 0; layer < NO_SAMPLERS; layer++) {
+      glActiveTexture (GL_TEXTURE0 + layer);
+      if (layer < priv->no_layers)
+        glBindTexture (GL_TEXTURE_2D, priv->layer_texture [layer]);
+      else
+        glBindTexture (GL_TEXTURE_2D, 0);
+      tex_ids [layer] = layer;
+    }
+//    glUniform1iv (loc, NO_SAMPLERS, tex_ids);
+    glUniform1i (loc, 0);
+#undef NO_SAMPLERS
+    glActiveTexture (GL_TEXTURE0);
+  }
+  glPushMatrix ();
+  glLoadIdentity ();
+//  glEnable (GL_TEXTURE_2D);
+  glColor4f (1., 1., 1., 0.7);
+
+  /* draw all layers in layerstack order */
+  for (i = ngroups - 1; i >= 0; i--) {
+    int layer_visible;
+    int group = drawn_groups [i];
+    int idx;
+
+    for (idx = 0; idx < PCB->LayerGroups.Number[group] - 1; idx ++) {
+      int ni = PCB->LayerGroups.Entries[group][idx];
+      if (ni >= 0 && ni < max_copper_layer + 2
+          && PCB->Data->Layer[ni].On)
+        break;
+    }
+    idx = PCB->LayerGroups.Entries[group][idx];
+    if (idx >= 0 && idx < max_copper_layer)
+      layer_visible = PCB->Data->Layer[idx].On;
+    else
+      layer_visible = 0;
+
+    if (priv->layer_rendered[i] && layer_visible) {
+      float aspect = (float)priv->fbo_width / (float)priv->fbo_height;
+
+      glBindTexture (GL_TEXTURE_2D, priv->layer_texture[drawn_groups [i]]);
+      glBegin (GL_QUADS);
+      glTexCoord2d (0.0, 1.0); glVertex3f (-aspect, -1.0, -1.);
+      glTexCoord2d (1.0, 1.0); glVertex3f ( aspect, -1.0, -1.);
+      glTexCoord2d (1.0, 0.0); glVertex3f ( aspect,  1.0, -1.);
+      glTexCoord2d (0.0, 0.0); glVertex3f (-aspect,  1.0, -1.);
+      glEnd ();
+    }
+  }
+
+  glBindTexture (GL_TEXTURE_2D, 0);
+  glDisable (GL_TEXTURE_2D);
+  glPopMatrix ();
+  hidgl_shader_activate (circular_program);
+// GOODBYE
+
   if (TEST_FLAG (CHECKPLANESFLAG, PCB))
     return;
 
@@ -1737,18 +2085,18 @@ ghid_draw_everything (BoxTypePtr drawn_area)
 
   if (global_view_2d)
     {
-      /* Mask out drilled holes */
+      if (PCB->PinOn) r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, NULL);
+      if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_callback, NULL);
+      if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, via_callback, NULL);
+
+      /* Erase drilled holes */
       hidgl_flush_triangles (&buffer);
-      glPushAttrib (GL_COLOR_BUFFER_BIT);
-      glColorMask (0, 0, 0, 0);
+      glPushAttrib (GL_CURRENT_BIT);
+      glColor4f (0., 0., 0., 0.);
       if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, hole_callback, NULL);
       if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, hole_callback, NULL);
       hidgl_flush_triangles (&buffer);
       glPopAttrib ();
-
-      if (PCB->PinOn) r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, NULL);
-      if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_callback, NULL);
-      if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, via_callback, NULL);
     }
 
   gui->set_layer (NULL, SL (FINISHED, 0), 0);
@@ -1792,6 +2140,7 @@ ghid_draw_everything (BoxTypePtr drawn_area)
   Gathering = true;
 
   Settings.ShowSolderSide = save_show_solder;
+  priv->textures_ok = 0;
 }
 
 #define Z_NEAR 3.0
@@ -1800,8 +2149,8 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
                              GdkEventExpose *ev,
                              GHidPort *port)
 {
-#ifdef ONE_SHOT
   static int one_shot = 1;
+#ifdef ONE_SHOT
   static int display_list;
 #endif
   BoxType region;
@@ -1817,14 +2166,43 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
                      0, 0, 0, 1};
   bool horizon_problem = false;
   extern int debug_stencil_clears;
+  int fbo_width;
+  int fbo_height;
+  int no_layers;
+  static int old_fbo_width = -1;
+  static int old_fbo_height = -1;
+  static int old_no_layers = -1;
 
   buffer.total_triangles = 0;
   buffer.total_vertices = 0;
 
   ghid_start_drawing (port);
 
+  /* Compute the size we're going to use for the layer textures */
+//  fbo_width  = PCB->MaxWidth  / gport->zoom;
+//  fbo_height = PCB->MaxHeight / gport->zoom;
+  fbo_width = widget->allocation.width;
+  fbo_height = widget->allocation.height;
+
+  /* Work out how many layers are going to be rendered */
+  no_layers = MAX (max_copper_layer, max_group); /* FIXME: HACK */
+
+  if (old_fbo_width != fbo_width ||
+      old_fbo_height != fbo_height ||
+      old_no_layers != no_layers) {
+    /* Setup the FBO for rending to textures */
+    cleanup_fbo (port);
+    setup_fbo (port, fbo_width, fbo_height, no_layers);
+    old_fbo_width = fbo_width;
+    old_fbo_height = fbo_height;
+    old_no_layers = no_layers;
+  }
+
   hidgl_in_context (true);
   hidgl_init ();
+  if (one_shot)
+    ghid_init_gl (port);
+
   check_gl_drawing_ok_hack = true;
   debug_stencil_clears = 0;
 
@@ -1905,7 +2283,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
     glNewList (display_list, GL_COMPILE);
 #endif
 
-  glEnable (GL_STENCIL_TEST);
+//  glEnable (GL_STENCIL_TEST);
   glClearColor (port->bg_color.red / 65535.,
                 port->bg_color.green / 65535.,
                 port->bg_color.blue / 65535.,
@@ -2057,7 +2435,6 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
 #ifdef ONE_SHOT
     glEndList ();
-    one_shot = 0;
   }
 
   glCallList (display_list);
@@ -2068,6 +2445,8 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   hidgl_flush_triangles (&buffer);
   hidgl_finish_triangle_array (&buffer);
 
+//  cleanup_fbo (port);
+
   check_gl_drawing_ok_hack = false;
   hidgl_in_context (false);
   ghid_end_drawing (port);
@@ -2076,6 +2455,8 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 //  printf ("Vertex count was %i\n", buffer.total_vertices);
 //  printf ("Stencil clears in frame: %i\n", debug_stencil_clears);
 
+  one_shot = 0;
+
   return FALSE;
 }

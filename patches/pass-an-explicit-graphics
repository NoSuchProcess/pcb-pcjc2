Bottom: 973826849f1c5d5dde2b046b551bd9a02f337a65
Top:    4dd634c0aad27b11383af4bdfeab12a7a7fbf89c
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2015-01-03 14:24:53 +0000

Pass an explicit graphics context to DrawAttached and DrawMark


---

diff --git a/src/crosshair.c b/src/crosshair.c
index 73ec90a..78b8111 100644
--- a/src/crosshair.c
+++ b/src/crosshair.c
@@ -57,39 +57,29 @@ typedef struct
   int x, y;
 } point;
 
-/* ---------------------------------------------------------------------------
- * some local prototypes
- */
-static void XORPolygon (PolygonType *, Coord, Coord);
-static void XORDrawElement (ElementType *, Coord, Coord);
-static void XORDrawBuffer (BufferType *);
-static void XORDrawInsertPointObject (void);
-static void XORDrawMoveOrCopyObject (void);
-static void XORDrawAttachedLine (Coord, Coord, Coord, Coord, Coord);
-static void XORDrawAttachedArc (Coord);
 
 static void
-thindraw_moved_pv (PinType *pv, Coord x, Coord y)
+thindraw_moved_pv (hidGC gc, PinType *pv, Coord x, Coord y)
 {
   /* Make a copy of the pin structure, moved to the correct position */
   PinType moved_pv = *pv;
   moved_pv.X += x;
   moved_pv.Y += y;
 
-  gui->graphics->thindraw_pcb_pv (Crosshair.GC, Crosshair.GC, &moved_pv, true, false);
+  gui->graphics->thindraw_pcb_pv (gc, gc, &moved_pv, true, false);
 }
 
 /* ---------------------------------------------------------------------------
  * creates a tmp polygon with coordinates converted to screen system
  */
 static void
-XORPolygon (PolygonType *polygon, Coord dx, Coord dy)
+XORPolygon (hidGC gc, PolygonType *polygon, Coord dx, Coord dy)
 {
   Cardinal i;
   for (i = 0; i < polygon->PointN; i++)
     {
       Cardinal next = next_contour_point (polygon, i);
-      gui->graphics->draw_line (Crosshair.GC,
+      gui->graphics->draw_line (gc,
                                 polygon->Points[i].X + dx,
                                 polygon->Points[i].Y + dy,
                                 polygon->Points[next].X + dx,
@@ -101,7 +91,7 @@ XORPolygon (PolygonType *polygon, Coord dx, Coord dy)
  * Draws the outline of an arc
  */
 static void
-XORDrawAttachedArc (Coord thick)
+XORDrawAttachedArc (hidGC gc, Coord thick)
 {
   ArcType arc;
   BoxType *bx;
@@ -144,12 +134,12 @@ XORDrawAttachedArc (Coord thick)
   arc.Width = arc.Height = wy;
   bx = GetArcEnds (&arc);
   /*  sa = sa - 180; */
-  gui->graphics->draw_arc (Crosshair.GC, arc.X, arc.Y, wy + wid, wy + wid, sa, dir);
+  gui->graphics->draw_arc (gc, arc.X, arc.Y, wy + wid, wy + wid, sa, dir);
   if (wid > pixel_slop)
     {
-      gui->graphics->draw_arc (Crosshair.GC, arc.X, arc.Y, wy - wid, wy - wid, sa, dir);
-      gui->graphics->draw_arc (Crosshair.GC, bx->X1, bx->Y1, wid, wid, sa,      -180 * SGN (dir));
-      gui->graphics->draw_arc (Crosshair.GC, bx->X2, bx->Y2, wid, wid, sa + dir, 180 * SGN (dir));
+      gui->graphics->draw_arc (gc, arc.X, arc.Y, wy - wid, wy - wid, sa, dir);
+      gui->graphics->draw_arc (gc, bx->X1, bx->Y1, wid, wid, sa,      -180 * SGN (dir));
+      gui->graphics->draw_arc (gc, bx->X2, bx->Y2, wid, wid, sa + dir, 180 * SGN (dir));
     }
 }
 
@@ -157,7 +147,7 @@ XORDrawAttachedArc (Coord thick)
  * Draws the outline of a line
  */
 static void
-XORDrawAttachedLine (Coord x1, Coord y1, Coord x2, Coord y2, Coord thick)
+XORDrawAttachedLine (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2, Coord thick)
 {
   Coord dx, dy, ox, oy;
   double h;
@@ -170,13 +160,13 @@ XORDrawAttachedLine (Coord x1, Coord y1, Coord x2, Coord y2, Coord thick)
     h = 0.0;
   ox = dy * h + 0.5 * SGN (dy);
   oy = -(dx * h + 0.5 * SGN (dx));
-  gui->graphics->draw_line (Crosshair.GC, x1 + ox, y1 + oy, x2 + ox, y2 + oy);
+  gui->graphics->draw_line (gc, x1 + ox, y1 + oy, x2 + ox, y2 + oy);
   if (abs (ox) >= pixel_slop || abs (oy) >= pixel_slop)
     {
       Angle angle = atan2 (dx, dy) * 57.295779;
-      gui->graphics->draw_line (Crosshair.GC, x1 - ox, y1 - oy, x2 - ox, y2 - oy);
-      gui->graphics->draw_arc (Crosshair.GC, x1, y1, thick / 2, thick / 2, angle - 180, 180);
-      gui->graphics->draw_arc (Crosshair.GC, x2, y2, thick / 2, thick / 2, angle, 180);
+      gui->graphics->draw_line (gc, x1 - ox, y1 - oy, x2 - ox, y2 - oy);
+      gui->graphics->draw_arc (gc, x1, y1, thick / 2, thick / 2, angle - 180, 180);
+      gui->graphics->draw_arc (gc, x2, y2, thick / 2, thick / 2, angle, 180);
     }
 }
 
@@ -184,27 +174,27 @@ XORDrawAttachedLine (Coord x1, Coord y1, Coord x2, Coord y2, Coord thick)
  * draws the elements of a loaded circuit which is to be merged in
  */
 static void
-XORDrawElement (ElementType *Element, Coord DX, Coord DY)
+XORDrawElement (hidGC gc, ElementType *Element, Coord DX, Coord DY)
 {
   /* if no silkscreen, draw the bounding box */
   if (Element->ArcN == 0 && Element->LineN == 0)
     {
-      gui->graphics->draw_line (Crosshair.GC,
+      gui->graphics->draw_line (gc,
                                 DX + Element->BoundingBox.X1,
                                 DY + Element->BoundingBox.Y1,
                                 DX + Element->BoundingBox.X1,
                                 DY + Element->BoundingBox.Y2);
-      gui->graphics->draw_line (Crosshair.GC,
+      gui->graphics->draw_line (gc,
                                 DX + Element->BoundingBox.X1,
                                 DY + Element->BoundingBox.Y2,
                                 DX + Element->BoundingBox.X2,
                                 DY + Element->BoundingBox.Y2);
-      gui->graphics->draw_line (Crosshair.GC,
+      gui->graphics->draw_line (gc,
                                 DX + Element->BoundingBox.X2,
                                 DY + Element->BoundingBox.Y2,
                                 DX + Element->BoundingBox.X2,
                                 DY + Element->BoundingBox.Y1);
-      gui->graphics->draw_line (Crosshair.GC,
+      gui->graphics->draw_line (gc,
                                 DX + Element->BoundingBox.X2,
                                 DY + Element->BoundingBox.Y1,
                                 DX + Element->BoundingBox.X1,
@@ -214,7 +204,7 @@ XORDrawElement (ElementType *Element, Coord DX, Coord DY)
     {
       ELEMENTLINE_LOOP (Element);
       {
-        gui->graphics->draw_line (Crosshair.GC,
+        gui->graphics->draw_line (gc,
                                   DX + line->Point1.X,
                                   DY + line->Point1.Y,
                                   DX + line->Point2.X,
@@ -225,7 +215,7 @@ XORDrawElement (ElementType *Element, Coord DX, Coord DY)
       /* arc coordinates and angles have to be converted to X11 notation */
       ARC_LOOP (Element);
       {
-        gui->graphics->draw_arc (Crosshair.GC,
+        gui->graphics->draw_arc (gc,
                                  DX + arc->X,
                                  DY + arc->Y,
                                  arc->Width, arc->Height, arc->StartAngle, arc->Delta);
@@ -235,7 +225,7 @@ XORDrawElement (ElementType *Element, Coord DX, Coord DY)
   /* pin coordinates and angles have to be converted to X11 notation */
   PIN_LOOP (Element);
   {
-    thindraw_moved_pv (pin, DX, DY);
+    thindraw_moved_pv (gc, pin, DX, DY);
   }
   END_LOOP;
 
@@ -250,27 +240,27 @@ XORDrawElement (ElementType *Element, Coord DX, Coord DY)
         moved_pad.Point1.X += DX; moved_pad.Point1.Y += DY;
         moved_pad.Point2.X += DX; moved_pad.Point2.Y += DY;
 
-        gui->graphics->thindraw_pcb_pad (Crosshair.GC, &moved_pad, false, false);
+        gui->graphics->thindraw_pcb_pad (gc, &moved_pad, false, false);
       }
   }
   END_LOOP;
   /* mark */
-  gui->graphics->draw_line (Crosshair.GC,
+  gui->graphics->draw_line (gc,
                             Element->MarkX + DX - EMARK_SIZE,
                             Element->MarkY + DY,
                             Element->MarkX + DX,
                             Element->MarkY + DY - EMARK_SIZE);
-  gui->graphics->draw_line (Crosshair.GC,
+  gui->graphics->draw_line (gc,
                             Element->MarkX + DX + EMARK_SIZE,
                             Element->MarkY + DY,
                             Element->MarkX + DX,
                             Element->MarkY + DY - EMARK_SIZE);
-  gui->graphics->draw_line (Crosshair.GC,
+  gui->graphics->draw_line (gc,
                             Element->MarkX + DX - EMARK_SIZE,
                             Element->MarkY + DY,
                             Element->MarkX + DX,
                             Element->MarkY + DY + EMARK_SIZE);
-  gui->graphics->draw_line (Crosshair.GC,
+  gui->graphics->draw_line (gc,
                             Element->MarkX + DX + EMARK_SIZE,
                             Element->MarkY + DY,
                             Element->MarkX + DX,
@@ -281,7 +271,7 @@ XORDrawElement (ElementType *Element, Coord DX, Coord DY)
  * draws all visible and attached objects of the pastebuffer
  */
 static void
-XORDrawBuffer (BufferType *Buffer)
+XORDrawBuffer (hidGC gc, BufferType *Buffer)
 {
   Cardinal i;
   Coord x, y;
@@ -303,14 +293,14 @@ XORDrawBuffer (BufferType *Buffer)
 					y +line->Point1.Y, x +line->Point2.X,
 					y +line->Point2.Y, line->Thickness);
 */
-	gui->graphics->draw_line (Crosshair.GC,
+	gui->graphics->draw_line (gc,
 	                          x + line->Point1.X, y + line->Point1.Y,
 	                          x + line->Point2.X, y + line->Point2.Y);
 	}
 	END_LOOP;
 	ARC_LOOP (layer);
 	{
-	  gui->graphics->draw_arc (Crosshair.GC,
+	  gui->graphics->draw_arc (gc,
 	                           x + arc->X,
 	                           y + arc->Y,
 	                           arc->Width,
@@ -320,7 +310,7 @@ XORDrawBuffer (BufferType *Buffer)
 	TEXT_LOOP (layer);
 	{
 	  BoxType *box = &text->BoundingBox;
-	  gui->graphics->draw_rect (Crosshair.GC,
+	  gui->graphics->draw_rect (gc,
 	                            x + box->X1, y + box->Y1, x + box->X2, y + box->Y2);
 	}
 	END_LOOP;
@@ -329,7 +319,7 @@ XORDrawBuffer (BufferType *Buffer)
 	 */
 	POLYGON_LOOP (layer);
 	{
-	  XORPolygon (polygon, x, y);
+	  XORPolygon (gc, polygon, x, y);
 	}
 	END_LOOP;
       }
@@ -339,7 +329,7 @@ XORDrawBuffer (BufferType *Buffer)
     ELEMENT_LOOP (Buffer->Data);
   {
     if (FRONT (element) || PCB->InvisibleObjectsOn)
-      XORDrawElement (element, x, y);
+      XORDrawElement (gc, element, x, y);
   }
   END_LOOP;
 
@@ -347,7 +337,7 @@ XORDrawBuffer (BufferType *Buffer)
   if (PCB->ViaOn)
     VIA_LOOP (Buffer->Data);
   {
-    thindraw_moved_pv (via, x, y);
+    thindraw_moved_pv (gc, via, x, y);
   }
   END_LOOP;
 }
@@ -356,15 +346,15 @@ XORDrawBuffer (BufferType *Buffer)
  * draws the rubberband to insert points into polygons/lines/...
  */
 static void
-XORDrawInsertPointObject (void)
+XORDrawInsertPointObject (hidGC gc)
 {
   LineType *line = (LineType *) Crosshair.AttachedObject.Ptr2;
   PointType *point = (PointType *) Crosshair.AttachedObject.Ptr3;
 
   if (Crosshair.AttachedObject.Type != NO_TYPE)
     {
-      gui->graphics->draw_line (Crosshair.GC, point->X, point->Y, line->Point1.X, line->Point1.Y);
-      gui->graphics->draw_line (Crosshair.GC, point->X, point->Y, line->Point2.X, line->Point2.Y);
+      gui->graphics->draw_line (gc, point->X, point->Y, line->Point1.X, line->Point1.Y);
+      gui->graphics->draw_line (gc, point->X, point->Y, line->Point2.X, line->Point2.Y);
     }
 }
 
@@ -372,7 +362,7 @@ XORDrawInsertPointObject (void)
  * draws the attached object while in MOVE_MODE or COPY_MODE
  */
 static void
-XORDrawMoveOrCopyObject (void)
+XORDrawMoveOrCopyObject (hidGC gc)
 {
   RubberbandType *ptr;
   Cardinal i;
@@ -384,7 +374,7 @@ XORDrawMoveOrCopyObject (void)
     case VIA_TYPE:
       {
         PinType *via = (PinType *) Crosshair.AttachedObject.Ptr1;
-        thindraw_moved_pv (via, dx, dy);
+        thindraw_moved_pv (gc, via, dx, dy);
         break;
       }
 
@@ -392,9 +382,9 @@ XORDrawMoveOrCopyObject (void)
       {
 	LineType *line = (LineType *) Crosshair.AttachedObject.Ptr2;
 
-	XORDrawAttachedLine (line->Point1.X + dx, line->Point1.Y + dy,
-			     line->Point2.X + dx, line->Point2.Y + dy,
-			     line->Thickness);
+	XORDrawAttachedLine (gc, line->Point1.X + dx, line->Point1.Y + dy,
+	                         line->Point2.X + dx, line->Point2.Y + dy,
+	                     line->Thickness);
 	break;
       }
 
@@ -402,7 +392,7 @@ XORDrawMoveOrCopyObject (void)
       {
 	ArcType *Arc = (ArcType *) Crosshair.AttachedObject.Ptr2;
 
-	gui->graphics->draw_arc (Crosshair.GC,
+	gui->graphics->draw_arc (gc,
 	                         Arc->X + dx,
 	                         Arc->Y + dy,
 	                         Arc->Width, Arc->Height, Arc->StartAngle, Arc->Delta);
@@ -417,7 +407,7 @@ XORDrawMoveOrCopyObject (void)
 	/* the tmp polygon has n+1 points because the first
 	 * and the last one are set to the same coordinates
 	 */
-	XORPolygon (polygon, dx, dy);
+	XORPolygon (gc, polygon, dx, dy);
 	break;
       }
 
@@ -429,13 +419,11 @@ XORDrawMoveOrCopyObject (void)
 	line = (LineType *) Crosshair.AttachedObject.Ptr2;
 	point = (PointType *) Crosshair.AttachedObject.Ptr3;
 	if (point == &line->Point1)
-	  XORDrawAttachedLine (point->X + dx,
-			       point->Y + dy, line->Point2.X,
-			       line->Point2.Y, line->Thickness);
+	  XORDrawAttachedLine (gc, point->X + dx, point->Y + dy,
+	                       line->Point2.X, line->Point2.Y, line->Thickness);
 	else
-	  XORDrawAttachedLine (point->X + dx,
-			       point->Y + dy, line->Point1.X,
-			       line->Point1.Y, line->Thickness);
+	  XORDrawAttachedLine (gc, point->X + dx, point->Y + dy,
+			       line->Point1.X, line->Point1.Y, line->Thickness);
 	break;
       }
 
@@ -454,10 +442,10 @@ XORDrawMoveOrCopyObject (void)
 	next = next_contour_point (polygon, point_idx);
 
 	/* draw the two segments */
-	gui->graphics->draw_line (Crosshair.GC,
+	gui->graphics->draw_line (gc,
 	                          polygon->Points[prev].X, polygon->Points[prev].Y,
 	                          point->X + dx, point->Y + dy);
-	gui->graphics->draw_line (Crosshair.GC,
+	gui->graphics->draw_line (gc,
 	                          point->X + dx, point->Y + dy,
 	                          polygon->Points[next].X, polygon->Points[next].Y);
 	break;
@@ -469,7 +457,7 @@ XORDrawMoveOrCopyObject (void)
 	ElementType *element =
 	  (ElementType *) Crosshair.AttachedObject.Ptr1;
 
-	gui->graphics->draw_line (Crosshair.GC,
+	gui->graphics->draw_line (gc,
 	                          element->MarkX,
 	                          element->MarkY, Crosshair.X, Crosshair.Y);
 	/* fall through to move the text as a box outline */
@@ -478,7 +466,7 @@ XORDrawMoveOrCopyObject (void)
       {
 	TextType *text = (TextType *) Crosshair.AttachedObject.Ptr2;
 	BoxType *box = &text->BoundingBox;
-	gui->graphics->draw_rect (Crosshair.GC,
+	gui->graphics->draw_rect (gc,
 	                          box->X1 + dx,
 	                          box->Y1 + dy, box->X2 + dx, box->Y2 + dy);
 	break;
@@ -488,7 +476,7 @@ XORDrawMoveOrCopyObject (void)
     case PAD_TYPE:
     case PIN_TYPE:
     case ELEMENT_TYPE:
-      XORDrawElement ((ElementType *) Crosshair.AttachedObject.Ptr2, dx, dy);
+      XORDrawElement (gc, (ElementType *) Crosshair.AttachedObject.Ptr2, dx, dy);
       break;
     }
 
@@ -516,15 +504,16 @@ XORDrawMoveOrCopyObject (void)
 	      point1 = &ptr->Line->Point1;
 	      point2 = &ptr->Line->Point2;
 	    }
-	  XORDrawAttachedLine (point1->X,
-			       point1->Y, point2->X + dx,
-			       point2->Y + dy, ptr->Line->Thickness);
+	  XORDrawAttachedLine (gc, point1->X, point1->Y,
+	                       point2->X + dx, point2->Y + dy,
+	                       ptr->Line->Thickness);
 	}
       else if (ptr->MovedPoint == &ptr->Line->Point1)
-	XORDrawAttachedLine (ptr->Line->Point1.X + dx,
-			     ptr->Line->Point1.Y + dy,
-			     ptr->Line->Point2.X + dx,
-			     ptr->Line->Point2.Y + dy, ptr->Line->Thickness);
+	XORDrawAttachedLine (gc,
+	                     ptr->Line->Point1.X + dx,
+	                     ptr->Line->Point1.Y + dy,
+	                     ptr->Line->Point2.X + dx,
+	                     ptr->Line->Point2.Y + dy, ptr->Line->Thickness);
 
       ptr++;
       i--;
@@ -535,8 +524,13 @@ XORDrawMoveOrCopyObject (void)
  * draws additional stuff that follows the crosshair
  */
 void
-DrawAttached (void)
+DrawAttached (hidGC gc)
 {
+  gui->graphics->set_color (gc, Settings.CrosshairColor);
+  gui->graphics->set_draw_xor (gc, 1);
+  gui->graphics->set_line_cap (gc, Trace_Cap);
+  gui->graphics->set_line_width (gc, 1);
+
   switch (Settings.Mode)
     {
     case VIA_MODE:
@@ -551,16 +545,16 @@ DrawAttached (void)
         via.Mask = 0;
         via.Flags = NoFlags ();
 
-        gui->graphics->thindraw_pcb_pv (Crosshair.GC, Crosshair.GC, &via, true, false);
+        gui->graphics->thindraw_pcb_pv (gc, gc, &via, true, false);
 
         if (TEST_FLAG (SHOWDRCFLAG, PCB))
           {
             Coord mask_r = Settings.ViaThickness / 2 + PCB->Bloat;
-            gui->graphics->set_color (Crosshair.GC, Settings.CrossColor);
-            gui->graphics->set_line_cap (Crosshair.GC, Round_Cap);
-            gui->graphics->set_line_width (Crosshair.GC, 0);
-            gui->graphics->draw_arc (Crosshair.GC, via.X, via.Y, mask_r, mask_r, 0, 360);
-            gui->graphics->set_color (Crosshair.GC, Settings.CrosshairColor);
+            gui->graphics->set_color (gc, Settings.CrossColor);
+            gui->graphics->set_line_cap (gc, Round_Cap);
+            gui->graphics->set_line_width (gc, 0);
+            gui->graphics->draw_arc (gc, via.X, via.Y, mask_r, mask_r, 0, 360);
+            gui->graphics->set_color (gc, Settings.CrosshairColor);
           }
         break;
       }
@@ -570,7 +564,7 @@ DrawAttached (void)
     case POLYGONHOLE_MODE:
       /* draw only if starting point is set */
       if (Crosshair.AttachedLine.State != STATE_FIRST)
-        gui->graphics->draw_line (Crosshair.GC,
+        gui->graphics->draw_line (gc,
                                   Crosshair.AttachedLine.Point1.X,
                                   Crosshair.AttachedLine.Point1.Y,
                                   Crosshair.AttachedLine.Point2.X,
@@ -579,20 +573,19 @@ DrawAttached (void)
       /* draw attached polygon only if in POLYGON_MODE or POLYGONHOLE_MODE */
       if (Crosshair.AttachedPolygon.PointN > 1)
 	{
-	  XORPolygon (&Crosshair.AttachedPolygon, 0, 0);
+	  XORPolygon (gc, &Crosshair.AttachedPolygon, 0, 0);
 	}
       break;
 
     case ARC_MODE:
       if (Crosshair.AttachedBox.State != STATE_FIRST)
 	{
-	  XORDrawAttachedArc (Settings.LineThickness);
+	  XORDrawAttachedArc (gc, Settings.LineThickness);
 	  if (TEST_FLAG (SHOWDRCFLAG, PCB))
 	    {
-	      gui->graphics->set_color (Crosshair.GC, Settings.CrossColor);
-	      XORDrawAttachedArc (Settings.LineThickness +
-				  2 * (PCB->Bloat + 1));
-	      gui->graphics->set_color (Crosshair.GC, Settings.CrosshairColor);
+	      gui->graphics->set_color (gc, Settings.CrossColor);
+	      XORDrawAttachedArc (gc, Settings.LineThickness + 2 * (PCB->Bloat + 1));
+	      gui->graphics->set_color (gc, Settings.CrosshairColor);
 	    }
 
 	}
@@ -603,48 +596,48 @@ DrawAttached (void)
       if (Crosshair.AttachedLine.State != STATE_FIRST &&
 	  Crosshair.AttachedLine.draw)
 	{
-	  XORDrawAttachedLine (Crosshair.AttachedLine.Point1.X,
-			       Crosshair.AttachedLine.Point1.Y,
-			       Crosshair.AttachedLine.Point2.X,
-			       Crosshair.AttachedLine.Point2.Y,
-			       PCB->RatDraw ? 10 : Settings.LineThickness);
+	  XORDrawAttachedLine (gc, Crosshair.AttachedLine.Point1.X,
+	                           Crosshair.AttachedLine.Point1.Y,
+	                           Crosshair.AttachedLine.Point2.X,
+	                           Crosshair.AttachedLine.Point2.Y,
+	                           PCB->RatDraw ? 10 : Settings.LineThickness);
 	  /* draw two lines ? */
 	  if (PCB->Clipping)
-	    XORDrawAttachedLine (Crosshair.AttachedLine.Point2.X,
-				 Crosshair.AttachedLine.Point2.Y,
-				 Crosshair.X, Crosshair.Y,
-				 PCB->RatDraw ? 10 : Settings.LineThickness);
+	    XORDrawAttachedLine (gc, Crosshair.AttachedLine.Point2.X,
+	                             Crosshair.AttachedLine.Point2.Y,
+	                         Crosshair.X, Crosshair.Y,
+	                         PCB->RatDraw ? 10 : Settings.LineThickness);
 	  if (TEST_FLAG (SHOWDRCFLAG, PCB))
 	    {
-	      gui->graphics->set_color (Crosshair.GC, Settings.CrossColor);
-	      XORDrawAttachedLine (Crosshair.AttachedLine.Point1.X,
-				   Crosshair.AttachedLine.Point1.Y,
-				   Crosshair.AttachedLine.Point2.X,
-				   Crosshair.AttachedLine.Point2.Y,
-				   PCB->RatDraw ? 10 : Settings.LineThickness
-				   + 2 * (PCB->Bloat + 1));
+	      gui->graphics->set_color (gc, Settings.CrossColor);
+	      XORDrawAttachedLine (gc, Crosshair.AttachedLine.Point1.X,
+	                               Crosshair.AttachedLine.Point1.Y,
+	                           Crosshair.AttachedLine.Point2.X,
+	                           Crosshair.AttachedLine.Point2.Y,
+	                           PCB->RatDraw ? 10 : Settings.LineThickness
+	                           + 2 * (PCB->Bloat + 1));
 	      if (PCB->Clipping)
-		XORDrawAttachedLine (Crosshair.AttachedLine.Point2.X,
-				     Crosshair.AttachedLine.Point2.Y,
-				     Crosshair.X, Crosshair.Y,
-				     PCB->RatDraw ? 10 : Settings.
-				     LineThickness + 2 * (PCB->Bloat + 1));
-	      gui->graphics->set_color (Crosshair.GC, Settings.CrosshairColor);
+		XORDrawAttachedLine (gc, Crosshair.AttachedLine.Point2.X,
+		                         Crosshair.AttachedLine.Point2.Y,
+		                     Crosshair.X, Crosshair.Y,
+		                     PCB->RatDraw ? 10 : Settings.
+		                     LineThickness + 2 * (PCB->Bloat + 1));
+	      gui->graphics->set_color (gc, Settings.CrosshairColor);
 	    }
 	}
       break;
 
     case PASTEBUFFER_MODE:
-      XORDrawBuffer (PASTEBUFFER);
+      XORDrawBuffer (gc, PASTEBUFFER);
       break;
 
     case COPY_MODE:
     case MOVE_MODE:
-      XORDrawMoveOrCopyObject ();
+      XORDrawMoveOrCopyObject (gc);
       break;
 
     case INSERTPOINT_MODE:
-      XORDrawInsertPointObject ();
+      XORDrawInsertPointObject (gc);
       break;
     }
 
@@ -658,7 +651,7 @@ DrawAttached (void)
       y1 = Crosshair.AttachedBox.Point1.Y;
       x2 = Crosshair.AttachedBox.Point2.X;
       y2 = Crosshair.AttachedBox.Point2.Y;
-      gui->graphics->draw_rect (Crosshair.GC, x1, y1, x2, y2);
+      gui->graphics->draw_rect (gc, x1, y1, x2, y2);
     }
 }
 
@@ -667,17 +660,22 @@ DrawAttached (void)
  * draw the marker position
  */
 void
-DrawMark (void)
+DrawMark (hidGC gc)
 {
+  gui->graphics->set_color (gc, Settings.CrosshairColor);
+  gui->graphics->set_draw_xor (gc, 1);
+  gui->graphics->set_line_cap (gc, Trace_Cap);
+  gui->graphics->set_line_width (gc, 1);
+
   /* Mark is not drawn when it is not set */
   if (!Marked.status)
     return;
 
-  gui->graphics->draw_line (Crosshair.GC,
+  gui->graphics->draw_line (gc,
                   Marked.X - MARK_SIZE,
                   Marked.Y - MARK_SIZE,
                   Marked.X + MARK_SIZE, Marked.Y + MARK_SIZE);
-  gui->graphics->draw_line (Crosshair.GC,
+  gui->graphics->draw_line (gc,
                   Marked.X + MARK_SIZE,
                   Marked.Y - MARK_SIZE,
                   Marked.X - MARK_SIZE, Marked.Y + MARK_SIZE);
@@ -1167,13 +1165,6 @@ SetCrosshairRange (Coord MinX, Coord MinY, Coord MaxX, Coord MaxY)
 void
 InitCrosshair (void)
 {
-  Crosshair.GC = gui->graphics->make_gc ();
-
-  gui->graphics->set_color (Crosshair.GC, Settings.CrosshairColor);
-  gui->graphics->set_draw_xor (Crosshair.GC, 1);
-  gui->graphics->set_line_cap (Crosshair.GC, Trace_Cap);
-  gui->graphics->set_line_width (Crosshair.GC, 1);
-
   /* set initial shape */
   Crosshair.shape = Basic_Crosshair_Shape;
 
@@ -1193,5 +1184,4 @@ void
 DestroyCrosshair (void)
 {
   FreePolygonMemory (&Crosshair.AttachedPolygon);
-  gui->graphics->destroy_gc (Crosshair.GC);
 }
diff --git a/src/crosshair.h b/src/crosshair.h
index 87564f0..a037a10 100644
--- a/src/crosshair.h
+++ b/src/crosshair.h
@@ -44,8 +44,8 @@ void notify_crosshair_change (bool changes_complete);
 void notify_mark_change (bool changes_complete);
 void HideCrosshair (void);
 void RestoreCrosshair (void);
-void DrawAttached (void);
-void DrawMark (void);
+void DrawAttached (hidGC gc);
+void DrawMark (hidGC gc);
 bool MoveCrosshairAbsolute (Coord, Coord);
 void SetCrosshairRange (Coord, Coord, Coord, Coord);
 void InitCrosshair (void);
diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index a247576..dcaf26d 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -42,6 +42,7 @@ typedef struct render_priv {
   Coord lead_user_x;
   Coord lead_user_y;
 
+  hidGC crosshair_gc;
 } render_priv;
 
 
@@ -790,11 +791,11 @@ redraw_region (GdkRectangle *rect)
 
   /* In some cases we are called with the crosshair still off */
   if (priv->attached_invalidate_depth == 0)
-    DrawAttached ();
+    DrawAttached (priv->crosshair_gc);
 
   /* In some cases we are called with the mark still off */
   if (priv->mark_invalidate_depth == 0)
-    DrawMark ();
+    DrawMark (priv->crosshair_gc);
 
   draw_lead_user (priv);
 
@@ -863,7 +864,7 @@ ghid_notify_crosshair_change (bool changes_complete)
     }
 
   if (priv->attached_invalidate_depth == 0)
-    DrawAttached ();
+    DrawAttached (priv->crosshair_gc);
 
   if (!changes_complete)
     {
@@ -901,7 +902,7 @@ ghid_notify_mark_change (bool changes_complete)
     }
 
   if (priv->mark_invalidate_depth == 0)
-    DrawMark ();
+    DrawMark (priv->crosshair_gc);
 
   if (!changes_complete)
     {
@@ -1038,11 +1039,15 @@ ghid_init_renderer (int *argc, char ***argv, GHidPort *port)
 {
   /* Init any GC's required */
   port->render_priv = g_new0 (render_priv, 1);
+  port->render_priv->crosshair_gc = gui->graphics->make_gc ();
 }
 
 void
 ghid_shutdown_renderer (GHidPort *port)
 {
+  render_priv *priv = port->render_priv;
+
+  gui->graphics->destroy_gc (priv->crosshair_gc);
   ghid_cancel_lead_user ();
   g_free (port->render_priv);
   port->render_priv = NULL;
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 1a95bcd..cfb647e 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -70,6 +70,7 @@ typedef struct render_priv {
   Coord lead_user_x;
   Coord lead_user_y;
 
+  hidGC crosshair_gc;
 } render_priv;
 
 
@@ -773,6 +774,7 @@ ghid_init_renderer (int *argc, char ***argv, GHidPort *port)
   render_priv *priv;
 
   port->render_priv = priv = g_new0 (render_priv, 1);
+  port->render_priv->crosshair_gc = gui->graphics->make_gc ();
 
   priv->time_since_expose = g_timer_new ();
 
@@ -797,6 +799,9 @@ ghid_init_renderer (int *argc, char ***argv, GHidPort *port)
 void
 ghid_shutdown_renderer (GHidPort *port)
 {
+  render_priv *priv = port->render_priv;
+
+  gui->graphics->destroy_gc (priv->crosshair_gc);
   ghid_cancel_lead_user ();
   g_free (port->render_priv);
   port->render_priv = NULL;
@@ -1008,8 +1013,8 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   ghid_invalidate_current_gc ();
 
-  DrawAttached ();
-  DrawMark ();
+  DrawAttached (priv->crosshair_gc);
+  DrawMark (priv->crosshair_gc);
   hidgl_flush_triangles (&buffer);
 
   draw_crosshair (priv);
diff --git a/src/hid/lesstif/main.c b/src/hid/lesstif/main.c
index 0ff0940..c351a48 100644
--- a/src/hid/lesstif/main.c
+++ b/src/hid/lesstif/main.c
@@ -99,6 +99,8 @@ static int bgred, bggreen, bgblue;
 
 static GC arc1_gc, arc2_gc;
 
+static hidGC crosshair_gc;
+
 /* These are for the pinout windows. */
 typedef struct PinoutData
 {
@@ -141,6 +143,11 @@ static bool flip_x = 0, flip_y = 0;
 static bool autofade = 0;
 static bool crosshair_on = true;
 
+/* ---------------------------------------------------------------------------
+ * some local prototypes
+ */
+static hidGC lesstif_make_gc (void);
+
 static void
 ShowCrosshair (bool show)
 {
@@ -1797,6 +1804,8 @@ lesstif_do_export (HID_Attr_Val * options)
   Widget menu;
   Widget work_area_frame;
 
+  crosshair_gc = lesstif_make_gc ();
+
   n = 0;
   stdarg (XtNwidth, &width);
   stdarg (XtNheight, &height);
@@ -2578,8 +2587,8 @@ idle_proc (XtPointer dummy)
       pixmap = window;
       if (crosshair_on)
         {
-          DrawAttached ();
-          DrawMark ();
+          DrawAttached (crosshair_gc);
+          DrawMark (crosshair_gc);
         }
       need_redraw = 0;
     }
@@ -2947,7 +2956,7 @@ lesstif_notify_crosshair_change (bool changes_complete)
     {
       save_pixmap = pixmap;
       pixmap = window;
-      DrawAttached ();
+      DrawAttached (crosshair_gc);
       pixmap = save_pixmap;
     }
 
@@ -2980,7 +2989,7 @@ lesstif_notify_mark_change (bool changes_complete)
     {
       save_pixmap = pixmap;
       pixmap = window;
-      DrawMark ();
+      DrawMark (crosshair_gc);
       pixmap = save_pixmap;
     }
 
@@ -4013,8 +4022,8 @@ lesstif_flush_debug_draw (void)
   pixmap = window;
   if (crosshair_on)
     {
-      DrawAttached ();
-      DrawMark ();
+      DrawAttached (crosshair_gc);
+      DrawMark (crosshair_gc);
     }
   pixmap = main_pixmap;
 }

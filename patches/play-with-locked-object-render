Bottom: 9f1f4c782d708f0c7e67d6ff4af6e982954662f0
Top:    43bc0d426ef89b99ff28d14e2551fc491797750f
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2012-11-18 20:53:26 +0000

Play with locked object rendering

(HACK HACK HACK HACK HACK)

Did I mention this was a hacky pile of rubbish code.. the main point of
the exercise is to determine whether the usability is better or not.


---

diff --git a/src/action.c b/src/action.c
index 81e7c1f..a70e4dd 100644
--- a/src/action.c
+++ b/src/action.c
@@ -1131,7 +1131,6 @@ NotifyMode (void)
 	    DrawElement (element);
 	    Draw ();
 	    SetChangedFlag (true);
-	    hid_actionl ("Report", "Object", NULL);
 	  }
 	else if (type != NO_TYPE)
 	  {
@@ -1146,7 +1145,6 @@ NotifyMode (void)
 		Draw ();
 	      }
 	    SetChangedFlag (true);
-	    hid_actionl ("Report", "Object", NULL);
 	  }
 	break;
       }
diff --git a/src/draw.c b/src/draw.c
index 4306462..b1bf5f0 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -177,12 +177,15 @@ DrawStrippedText (ElementType *Element, int min_width)
   DrawTextLowLevel (text_ptr, min_width);
 }
 
+void ghid_set_lock_effects (hidGC gc, AnyObjectType *object);
+
 static void
 draw_element_name (ElementType *element)
 {
   if ((TEST_FLAG (HIDENAMESFLAG, PCB) && gui->gui) ||
       TEST_FLAG (HIDENAMEFLAG, element))
     return;
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)element);
   if (doing_pinout || doing_assy)
     gui->graphics->set_color (Output.fgGC, PCB->ElementColor);
   else if (TEST_FLAG (SELECTEDFLAG, &ELEMENT_TEXT (PCB, element)))
@@ -265,6 +268,7 @@ rat_callback (const BoxType * b, void *cl)
 static void
 draw_element_package (ElementType *element)
 {
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)element);
   /* set color and draw lines, arcs, text and pins */
   if (doing_pinout || doing_assy)
     gui->graphics->set_color (Output.fgGC, PCB->ElementColor);
@@ -499,6 +503,7 @@ DrawEMark (ElementType *e, Coord X, Coord Y, bool invisible)
       mark_size = MIN (mark_size, pad0->Thickness / 2);
     }
 
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)e);
   gui->graphics->set_color (Output.fgGC, invisible ? PCB->InvisibleMarkColor : PCB->ElementColor);
   gui->graphics->set_line_cap (Output.fgGC, Trace_Cap);
   gui->graphics->set_line_width (Output.fgGC, 0);
diff --git a/src/draw_funcs.c b/src/draw_funcs.c
index 1e8c4ac..a7e8465 100644
--- a/src/draw_funcs.c
+++ b/src/draw_funcs.c
@@ -6,6 +6,8 @@
 #include "draw_funcs.h"
 #include "draw.h"
 
+void ghid_set_lock_effects (hidGC gc, AnyObjectType *object);
+
 static void
 _draw_pv (PinType *pv, bool draw_hole)
 {
@@ -191,6 +193,7 @@ line_callback (const BoxType * b, void *cl)
   LayerType *layer = cl;
   LineType *line = (LineType *)b;
 
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)line);
   if (TEST_FLAG (SELECTEDFLAG, line))   gui->graphics->set_color (Output.fgGC, layer->SelectedColor);
   else if (TEST_FLAG (FOUNDFLAG, line)) gui->graphics->set_color (Output.fgGC, PCB->ConnectedColor);
   else                                  gui->graphics->set_color (Output.fgGC, layer->Color);
@@ -205,6 +208,7 @@ arc_callback (const BoxType * b, void *cl)
   LayerType *layer = cl;
   ArcType *arc = (ArcType *)b;
 
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)arc);
   if (TEST_FLAG (SELECTEDFLAG, arc))   gui->graphics->set_color (Output.fgGC, layer->SelectedColor);
   else if (TEST_FLAG (FOUNDFLAG, arc)) gui->graphics->set_color (Output.fgGC, PCB->ConnectedColor);
   else                                 gui->graphics->set_color (Output.fgGC, layer->Color);
@@ -224,6 +228,7 @@ poly_callback (const BoxType * b, void *cl)
   struct poly_info *i = cl;
   PolygonType *polygon = (PolygonType *)b;
 
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)polygon);
   if (TEST_FLAG (SELECTEDFLAG, polygon))   gui->graphics->set_color (Output.fgGC, i->layer->SelectedColor);
   else if (TEST_FLAG (FOUNDFLAG, polygon)) gui->graphics->set_color (Output.fgGC, PCB->ConnectedColor);
   else                                     gui->graphics->set_color (Output.fgGC, i->layer->Color);
@@ -239,6 +244,7 @@ text_callback (const BoxType * b, void *cl)
   TextType *text = (TextType *)b;
   int min_silk_line;
 
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)text);
   if (TEST_FLAG (SELECTEDFLAG, text))
     gui->graphics->set_color (Output.fgGC, layer->SelectedColor);
   else
@@ -255,6 +261,7 @@ text_callback (const BoxType * b, void *cl)
 static void
 set_pv_inlayer_color (PinType *pv, LayerType *layer, int type)
 {
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pv);
   if (TEST_FLAG (WARNFLAG, pv))          gui->graphics->set_color (Output.fgGC, PCB->WarnColor);
   else if (TEST_FLAG (SELECTEDFLAG, pv)) gui->graphics->set_color (Output.fgGC, (type == VIA_TYPE) ? PCB->ViaSelectedColor
                                                                                                    : PCB->PinSelectedColor);
@@ -290,6 +297,7 @@ pad_inlayer_callback (const BoxType * b, void *cl)
 
   if (ON_SIDE (pad, side))
     {
+      ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pad);
       if (TEST_FLAG (WARNFLAG, pad))          gui->graphics->set_color (Output.fgGC, PCB->WarnColor);
       else if (TEST_FLAG (SELECTEDFLAG, pad)) gui->graphics->set_color (Output.fgGC, PCB->PinSelectedColor);
       else if (TEST_FLAG (FOUNDFLAG, pad))    gui->graphics->set_color (Output.fgGC, PCB->ConnectedColor);
@@ -310,6 +318,7 @@ pin_hole_callback (const BoxType * b, void *cl)
       (plated == 1 &&  TEST_FLAG (HOLEFLAG, pin)))
     return 1;
 
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pin);
   if (TEST_FLAG (WARNFLAG, pin))          gui->graphics->set_color (Output.fgGC, PCB->WarnColor);
   else if (TEST_FLAG (SELECTEDFLAG, pin)) gui->graphics->set_color (Output.fgGC, PCB->PinSelectedColor);
   else                                    gui->graphics->set_color (Output.fgGC, Settings.BlackColor);
@@ -328,6 +337,7 @@ via_hole_callback (const BoxType * b, void *cl)
       (plated == 1 &&  TEST_FLAG (HOLEFLAG, via)))
     return 1;
 
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)via);
   if (TEST_FLAG (WARNFLAG, via))          gui->graphics->set_color (Output.fgGC, PCB->WarnColor);
   else if (TEST_FLAG (SELECTEDFLAG, via)) gui->graphics->set_color (Output.fgGC, PCB->ViaSelectedColor);
   else                                    gui->graphics->set_color (Output.fgGC, Settings.BlackColor);
@@ -339,6 +349,7 @@ via_hole_callback (const BoxType * b, void *cl)
 static void
 set_pv_color (PinType *pv, int type)
 {
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pv);
   if (TEST_FLAG (WARNFLAG, pv))          gui->graphics->set_color (Output.fgGC, PCB->WarnColor);
   else if (TEST_FLAG (SELECTEDFLAG, pv)) gui->graphics->set_color (Output.fgGC, (type == VIA_TYPE) ? PCB->ViaSelectedColor
                                                                                                    : PCB->PinSelectedColor);
@@ -371,6 +382,7 @@ pad_callback (const BoxType * b, void *cl)
 
   if (ON_SIDE (pad, *side))
     {
+      ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pad);
       if (TEST_FLAG (WARNFLAG, pad))          gui->graphics->set_color (Output.fgGC, PCB->WarnColor);
       else if (TEST_FLAG (SELECTEDFLAG, pad)) gui->graphics->set_color (Output.fgGC, PCB->PinSelectedColor);
       else if (TEST_FLAG (FOUNDFLAG, pad))    gui->graphics->set_color (Output.fgGC, PCB->ConnectedColor);
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 302f93b..a12c665 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -70,6 +70,8 @@ typedef struct render_priv {
   int subcomposite_stencil_bit;
   char *current_colorname;
   double current_alpha_mult;
+  double current_brightness;
+  double current_saturation;
   GTimer *time_since_expose;
 
   /* Feature for leading the user to a particular location */
@@ -89,6 +91,8 @@ typedef struct hid_gc_struct
 
   const char *colorname;
   double alpha_mult;
+  double brightness;
+  double saturation;
   Coord width;
   gint cap, join;
 }
@@ -306,6 +310,8 @@ ghid_make_gc (void)
   rv->me_pointer = &ghid_hid;
   rv->colorname = Settings.BackgroundColor;
   rv->alpha_mult = 1.0;
+  rv->brightness = 1.0;
+  rv->saturation = 1.0;
   return rv;
 }
 
@@ -496,10 +502,13 @@ set_gl_color_for_gc (hidGC gc)
   hidval cval;
   ColorCache *cc;
   double r, g, b, a;
+  double luminance;
 
   if (priv->current_colorname != NULL &&
       strcmp (priv->current_colorname, gc->colorname) == 0 &&
-      priv->current_alpha_mult == gc->alpha_mult)
+      priv->current_alpha_mult == gc->alpha_mult &&
+      priv->current_brightness == gc->brightness &&
+      priv->current_saturation == gc->saturation)
     return;
 
   free (priv->current_colorname);
@@ -514,6 +523,8 @@ set_gl_color_for_gc (hidGC gc)
 
   priv->current_colorname = strdup (gc->colorname);
   priv->current_alpha_mult = gc->alpha_mult;
+  priv->current_brightness = gc->brightness;
+  priv->current_saturation = gc->saturation;
 
   if (gport->colormap == NULL)
     gport->colormap = gtk_widget_get_colormap (gport->top_window);
@@ -575,6 +586,18 @@ set_gl_color_for_gc (hidGC gc)
 #endif
   }
 
+  r *= gc->brightness;
+  g *= gc->brightness;
+  b *= gc->brightness;
+
+  /* B/W Equivalent brightness */
+  luminance = (r + g + b) / 3.0;
+
+  /* Fade between B/W and colour */
+  r = r * gc->saturation + luminance * (1.0 - gc->saturation);
+  g = g * gc->saturation + luminance * (1.0 - gc->saturation);
+  b = b * gc->saturation + luminance * (1.0 - gc->saturation);
+
   hidgl_flush_triangles (&buffer);
   glColor4d (r, g, b, a);
 }
@@ -593,6 +616,20 @@ ghid_set_alpha_mult (hidGC gc, double alpha_mult)
   set_gl_color_for_gc (gc);
 }
 
+static void
+ghid_set_saturation (hidGC gc, double saturation)
+{
+  gc->saturation = saturation;
+  set_gl_color_for_gc (gc);
+}
+
+static void
+ghid_set_brightness (hidGC gc, double brightness)
+{
+  gc->brightness = brightness;
+  set_gl_color_for_gc (gc);
+}
+
 void
 ghid_set_line_cap (hidGC gc, EndCapStyle style)
 {
@@ -1002,6 +1039,25 @@ ghid_screen_update (void)
 {
 }
 
+void
+ghid_set_lock_effects (hidGC gc, AnyObjectType *object)
+{
+  /* Only apply effects to locked objects when in "lock" mode */
+  if (Settings.Mode == LOCK_MODE &&
+      TEST_FLAG (LOCKFLAG, object))
+    {
+      ghid_set_alpha_mult (gc, 0.8);
+      ghid_set_saturation (gc, 0.3);
+      ghid_set_brightness (gc, 0.7);
+    }
+  else
+    {
+      ghid_set_alpha_mult (gc, 1.0);
+      ghid_set_saturation (gc, 1.0);
+      ghid_set_brightness (gc, 1.0);
+    }
+}
+
 static int
 EMark_callback (const BoxType * b, void *cl)
 {
@@ -1045,6 +1101,7 @@ SetPVColor (PinType *Pin, int Type)
 	color = PCB->PinColor;
     }
 
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)Pin);
   gui->graphics->set_color (Output.fgGC, color);
 }
 
@@ -1072,6 +1129,7 @@ SetPVColor_inlayer (PinType *Pin, LayerType *Layer, int Type)
         color = Layer->Color;
     }
 
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)Pin);
   gui->graphics->set_color (Output.fgGC, color);
 }
 
@@ -1100,6 +1158,7 @@ _draw_pv_name (PinType *pv)
       box.Y1 = pv->Y - pv->Thickness    / 2 + Settings.PinoutTextOffsetY;
     }
 
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pv);
   gui->graphics->set_color (Output.fgGC, PCB->PinNameColor);
 
   text.Flags = NoFlags ();
@@ -1212,6 +1271,7 @@ draw_pad_name (PadType *pad)
       box.Y1 += Settings.PinoutTextOffsetY;
     }
 
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pad);
   gui->graphics->set_color (Output.fgGC, PCB->PinNameColor);
 
   text.Flags = NoFlags ();
@@ -1240,6 +1300,7 @@ _draw_pad (hidGC gc, PadType *pad, bool clear, bool mask)
 static void
 draw_pad (PadType *pad)
 {
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pad);
   if (TEST_FLAG (WARNFLAG | SELECTEDFLAG | FOUNDFLAG, pad))
    {
      if (TEST_FLAG (WARNFLAG, pad))
@@ -1301,6 +1362,7 @@ hole_callback (const BoxType * b, void *cl)
 
   if (TEST_FLAG (HOLEFLAG, pv))
     {
+    ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)pv);
       if (TEST_FLAG (WARNFLAG, pv))
         gui->graphics->set_color (Output.fgGC, PCB->WarnColor);
       else if (TEST_FLAG (SELECTEDFLAG, pv))
@@ -1334,6 +1396,7 @@ _draw_line (LineType *line)
 static void
 draw_line (LayerType *layer, LineType *line)
 {
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)line);
   if (TEST_FLAG (SELECTEDFLAG | FOUNDFLAG, line))
     {
       if (TEST_FLAG (SELECTEDFLAG, line))
@@ -1372,6 +1435,7 @@ _draw_arc (ArcType *arc)
 static void
 draw_arc (LayerType *layer, ArcType *arc)
 {
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)arc);
   if (TEST_FLAG (SELECTEDFLAG | FOUNDFLAG, arc))
     {
       if (TEST_FLAG (SELECTEDFLAG, arc))
@@ -1399,6 +1463,7 @@ text_callback (const BoxType * b, void *cl)
   TextType *text = (TextType *)b;
   int min_silk_line;
 
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)text);
   if (TEST_FLAG (SELECTEDFLAG, text))
     gui->graphics->set_color (Output.fgGC, layer->SelectedColor);
   else
@@ -1426,6 +1491,7 @@ DrawPlainPolygon (LayerType *Layer, PolygonType *Polygon, const BoxType *drawn_a
     color = PCB->ConnectedColor;
   else
     color = Layer->Color;
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)Polygon);
   gui->graphics->set_color (Output.fgGC, color);
 
   if (gui->thindraw_pcb_polygon != NULL &&
@@ -1732,6 +1798,7 @@ draw_hole_cyl (PinType *Pin, struct cyl_info *info, int Type)
   else
     color = "drill";
 
+  ghid_set_lock_effects (Output.fgGC, (AnyObjectType *)Pin);
   gui->graphics->set_color (Output.fgGC, color);
   DrawDrillChannel (Pin->X, Pin->Y, Pin->DrillingHole / 2, info->from_layer, info->to_layer, info->scale);
   return 0;

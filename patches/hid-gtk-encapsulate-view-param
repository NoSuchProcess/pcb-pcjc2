Bottom: 1cc2646ded699ac4ef64b5a6de66269acd1f4acd
Top:    a40e625037bf0a6e49f312e334f8193501053535
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-08-27 14:53:20 +0100

hid/gtk: Encapsulate view parameters in a structure


---

diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index 817a0fa..631e5b7 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -172,11 +172,11 @@ ghid_draw_grid (void)
       gdk_gc_set_clip_origin (priv->grid_gc, 0, 0);
       set_clip (priv, priv->grid_gc);
     }
-  x1 = GridFit (SIDE_X (gport->view_x0), PCB->Grid, PCB->GridOffsetX);
-  y1 = GridFit (SIDE_Y (gport->view_y0), PCB->Grid, PCB->GridOffsetY);
-  x2 = GridFit (SIDE_X (gport->view_x0 + gport->view_width - 1),
+  x1 = GridFit (SIDE_X (gport->view.x0), PCB->Grid, PCB->GridOffsetX);
+  y1 = GridFit (SIDE_Y (gport->view.y0), PCB->Grid, PCB->GridOffsetY);
+  x2 = GridFit (SIDE_X (gport->view.x0 + gport->view.width - 1),
                 PCB->Grid, PCB->GridOffsetX);
-  y2 = GridFit (SIDE_Y (gport->view_y0 + gport->view_height - 1),
+  y2 = GridFit (SIDE_Y (gport->view.y0 + gport->view.height - 1),
                 PCB->Grid, PCB->GridOffsetY);
   if (x1 > x2)
     {
@@ -233,10 +233,10 @@ ghid_draw_bg_image (void)
   if (!ghidgui->bg_pixbuf)
     return;
 
-  w = PCB->MaxWidth / gport->zoom;
-  h = PCB->MaxHeight / gport->zoom;
-  x = gport->view_x0 / gport->zoom;
-  y = gport->view_y0 / gport->zoom;
+  w = PCB->MaxWidth / gport->view.coord_per_px;
+  h = PCB->MaxHeight / gport->view.coord_per_px;
+  x = gport->view.x0 / gport->view.coord_per_px;
+  y = gport->view.y0 / gport->view.coord_per_px;
 
   if (w_scaled != w || h_scaled != h)
     {
@@ -529,7 +529,7 @@ ghid_draw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
   dy2 = Vy ((double) y2);
 
   if (!ClipLine (0, 0, gport->width, gport->height,
-		 &dx1, &dy1, &dx2, &dy2, gc->width / gport->zoom))
+		 &dx1, &dy1, &dx2, &dy2, gc->width / gport->view.coord_per_px))
     return;
 
   USE_GC (gc);
@@ -544,25 +544,25 @@ ghid_draw_arc (hidGC gc, Coord cx, Coord cy,
   gint w, h, radius;
   render_priv *priv = gport->render_priv;
 
-  w = gport->width * gport->zoom;
-  h = gport->height * gport->zoom;
+  w = gport->width * gport->view.coord_per_px;
+  h = gport->height * gport->view.coord_per_px;
   radius = (xradius > yradius) ? xradius : yradius;
-  if (SIDE_X (cx) < gport->view_x0 - radius
-      || SIDE_X (cx) > gport->view_x0 + w + radius
-      || SIDE_Y (cy) < gport->view_y0 - radius
-      || SIDE_Y (cy) > gport->view_y0 + h + radius)
+  if (SIDE_X (cx) < gport->view.x0 - radius
+      || SIDE_X (cx) > gport->view.x0 + w + radius
+      || SIDE_Y (cy) < gport->view.y0 - radius
+      || SIDE_Y (cy) > gport->view.y0 + h + radius)
     return;
 
   USE_GC (gc);
   vrx = Vz (xradius);
   vry = Vz (yradius);
 
-  if (ghid_flip_x)
+  if (gport->view.flip_x)
     {
       start_angle = 180 - start_angle;
       delta_angle = -delta_angle;
     }
-  if (ghid_flip_y)
+  if (gport->view.flip_y)
     {
       start_angle = -start_angle;
       delta_angle = -delta_angle;
@@ -583,17 +583,17 @@ ghid_draw_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
   render_priv *priv = gport->render_priv;
 
   lw = gc->width;
-  w = gport->width * gport->zoom;
-  h = gport->height * gport->zoom;
-
-  if ((SIDE_X (x1) < gport->view_x0 - lw
-       && SIDE_X (x2) < gport->view_x0 - lw)
-      || (SIDE_X (x1) > gport->view_x0 + w + lw
-	  && SIDE_X (x2) > gport->view_x0 + w + lw)
-      || (SIDE_Y (y1) < gport->view_y0 - lw
-	  && SIDE_Y (y2) < gport->view_y0 - lw)
-      || (SIDE_Y (y1) > gport->view_y0 + h + lw
-	  && SIDE_Y (y2) > gport->view_y0 + h + lw))
+  w = gport->width * gport->view.coord_per_px;
+  h = gport->height * gport->view.coord_per_px;
+
+  if ((SIDE_X (x1) < gport->view.x0 - lw
+       && SIDE_X (x2) < gport->view.x0 - lw)
+      || (SIDE_X (x1) > gport->view.x0 + w + lw
+	  && SIDE_X (x2) > gport->view.x0 + w + lw)
+      || (SIDE_Y (y1) < gport->view.y0 - lw
+	  && SIDE_Y (y2) < gport->view.y0 - lw)
+      || (SIDE_Y (y1) > gport->view.y0 + h + lw
+	  && SIDE_Y (y2) > gport->view.y0 + h + lw))
     return;
 
   x1 = Vx (x1);
@@ -626,12 +626,12 @@ ghid_fill_circle (hidGC gc, Coord cx, Coord cy, Coord radius)
   gint w, h, vr;
   render_priv *priv = gport->render_priv;
 
-  w = gport->width * gport->zoom;
-  h = gport->height * gport->zoom;
-  if (SIDE_X (cx) < gport->view_x0 - radius
-      || SIDE_X (cx) > gport->view_x0 + w + radius
-      || SIDE_Y (cy) < gport->view_y0 - radius
-      || SIDE_Y (cy) > gport->view_y0 + h + radius)
+  w = gport->width * gport->view.coord_per_px;
+  h = gport->height * gport->view.coord_per_px;
+  if (SIDE_X (cx) < gport->view.x0 - radius
+      || SIDE_X (cx) > gport->view.x0 + w + radius
+      || SIDE_Y (cy) < gport->view.y0 - radius
+      || SIDE_Y (cy) > gport->view.y0 + h + radius)
     return;
 
   USE_GC (gc);
@@ -669,17 +669,17 @@ ghid_fill_rect (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
   render_priv *priv = gport->render_priv;
 
   lw = gc->width;
-  w = gport->width * gport->zoom;
-  h = gport->height * gport->zoom;
-
-  if ((SIDE_X (x1) < gport->view_x0 - lw
-       && SIDE_X (x2) < gport->view_x0 - lw)
-      || (SIDE_X (x1) > gport->view_x0 + w + lw
-	  && SIDE_X (x2) > gport->view_x0 + w + lw)
-      || (SIDE_Y (y1) < gport->view_y0 - lw
-	  && SIDE_Y (y2) < gport->view_y0 - lw)
-      || (SIDE_Y (y1) > gport->view_y0 + h + lw
-	  && SIDE_Y (y2) > gport->view_y0 + h + lw))
+  w = gport->width * gport->view.coord_per_px;
+  h = gport->height * gport->view.coord_per_px;
+
+  if ((SIDE_X (x1) < gport->view.x0 - lw
+       && SIDE_X (x2) < gport->view.x0 - lw)
+      || (SIDE_X (x1) > gport->view.x0 + w + lw
+	  && SIDE_X (x2) > gport->view.x0 + w + lw)
+      || (SIDE_Y (y1) < gport->view.y0 - lw
+	  && SIDE_Y (y2) < gport->view.y0 - lw)
+      || (SIDE_Y (y1) > gport->view.y0 + h + lw
+	  && SIDE_Y (y2) > gport->view.y0 + h + lw))
     return;
 
   x1 = Vx (x1);
@@ -1173,13 +1173,13 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   double xz, yz;
   render_priv *priv = gport->render_priv;
 
-  save_zoom = gport->zoom;
+  save_zoom = gport->view.coord_per_px;
   save_width = gport->width;
   save_height = gport->height;
-  save_left = gport->view_x0;
-  save_top = gport->view_y0;
-  save_view_width = gport->view_width;
-  save_view_height = gport->view_height;
+  save_left = gport->view.x0;
+  save_top = gport->view.y0;
+  save_view_width = gport->view.width;
+  save_view_height = gport->view.height;
 
   /* Setup drawable and zoom factor for drawing routines
    */
@@ -1189,17 +1189,17 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   xz = (double) pinout->x_max / da_w;
   yz = (double) pinout->y_max / da_h;
   if (xz > yz)
-    gport->zoom = xz;
+    gport->view.coord_per_px = xz;
   else
-    gport->zoom = yz;
+    gport->view.coord_per_px = yz;
 
   gport->drawable = widget->window;
   gport->width = da_w;
   gport->height = da_h;
-  gport->view_width = da_w * gport->zoom;
-  gport->view_height = da_h * gport->zoom;
-  gport->view_x0 = (pinout->x_max - gport->view_width) / 2;
-  gport->view_y0 = (pinout->y_max - gport->view_height) / 2;
+  gport->view.width = da_w * gport->view.coord_per_px;
+  gport->view.height = da_h * gport->view.coord_per_px;
+  gport->view.x0 = (pinout->x_max - gport->view.width) / 2;
+  gport->view.y0 = (pinout->y_max - gport->view.height) / 2;
 
   /* clear background */
   gdk_draw_rectangle (widget->window, priv->bg_gc, TRUE, 0, 0, da_w, da_h);
@@ -1208,13 +1208,13 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   hid_expose_callback (&ghid_hid, NULL, &pinout->element);
 
   gport->drawable = save_drawable;
-  gport->zoom = save_zoom;
+  gport->view.coord_per_px = save_zoom;
   gport->width = save_width;
   gport->height = save_height;
-  gport->view_x0 = save_left;
-  gport->view_y0 = save_top;
-  gport->view_width = save_view_width;
-  gport->view_height = save_view_height;
+  gport->view.x0 = save_left;
+  gport->view.y0 = save_top;
+  gport->view.width = save_view_width;
+  gport->view.height = save_view_height;
 
   return FALSE;
 }
@@ -1232,13 +1232,13 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   render_priv *priv = gport->render_priv;
 
   save_drawable = gport->drawable;
-  save_zoom = gport->zoom;
+  save_zoom = gport->view.coord_per_px;
   save_width = gport->width;
   save_height = gport->height;
-  save_left = gport->view_x0;
-  save_top = gport->view_y0;
-  save_view_width = gport->view_width;
-  save_view_height = gport->view_height;
+  save_left = gport->view.x0;
+  save_top = gport->view.y0;
+  save_view_width = gport->view.width;
+  save_view_height = gport->view.height;
 
   pixmap = gdk_pixmap_new (NULL, width, height, depth);
 
@@ -1246,15 +1246,15 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
    */
 
   gport->drawable = pixmap;
-  gport->zoom = zoom;
+  gport->view.coord_per_px = zoom;
   gport->width = width;
   gport->height = height;
-  gport->view_width = width * gport->zoom;
-  gport->view_height = height * gport->zoom;
-  gport->view_x0 = ghid_flip_x ? PCB->MaxWidth - cx : cx;
-  gport->view_x0 -= gport->view_height / 2;
-  gport->view_y0 = ghid_flip_y ? PCB->MaxHeight - cy : cy;
-  gport->view_y0 -= gport->view_width  / 2;
+  gport->view.width = width * gport->view.coord_per_px;
+  gport->view.height = height * gport->view.coord_per_px;
+  gport->view.x0 = gport->view.flip_x ? PCB->MaxWidth - cx : cx;
+  gport->view.x0 -= gport->view.height / 2;
+  gport->view.y0 = gport->view.flip_y ? PCB->MaxHeight - cy : cy;
+  gport->view.y0 -= gport->view.width  / 2;
 
   /* clear background */
   gdk_draw_rectangle (pixmap, priv->bg_gc, TRUE, 0, 0, width, height);
@@ -1273,13 +1273,13 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   hid_expose_callback (&ghid_hid, &region, NULL);
 
   gport->drawable = save_drawable;
-  gport->zoom = save_zoom;
+  gport->view.coord_per_px = save_zoom;
   gport->width = save_width;
   gport->height = save_height;
-  gport->view_x0 = save_left;
-  gport->view_y0 = save_top;
-  gport->view_width = save_view_width;
-  gport->view_height = save_view_height;
+  gport->view.x0 = save_left;
+  gport->view.y0 = save_top;
+  gport->view.width = save_view_width;
+  gport->view.height = save_view_height;
 
   return pixmap;
 }
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 8c1e8a2..ea8dd40 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -538,7 +538,7 @@ ghid_draw_line (hidGC gc, Coord x1, Coord y1, Coord x2, Coord y2)
 {
   USE_GC (gc);
 
-  hidgl_draw_line (gc->cap, gc->width, x1, y1, x2, y2, gport->zoom);
+  hidgl_draw_line (gc->cap, gc->width, x1, y1, x2, y2, gport->view.coord_per_px);
 }
 
 void
@@ -548,7 +548,7 @@ ghid_draw_arc (hidGC gc, Coord cx, Coord cy, Coord xradius, Coord yradius,
   USE_GC (gc);
 
   hidgl_draw_arc (gc->width, cx, cy, xradius, yradius,
-                  start_angle, delta_angle, gport->zoom);
+                  start_angle, delta_angle, gport->view.coord_per_px);
 }
 
 void
@@ -565,7 +565,7 @@ ghid_fill_circle (hidGC gc, Coord cx, Coord cy, Coord radius)
 {
   USE_GC (gc);
 
-  hidgl_fill_circle (cx, cy, radius, gport->zoom);
+  hidgl_fill_circle (cx, cy, radius, gport->view.coord_per_px);
 }
 
 
@@ -582,7 +582,7 @@ ghid_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
 {
   USE_GC (gc);
 
-  hidgl_fill_pcb_polygon (poly, clip_box, gport->zoom);
+  hidgl_fill_pcb_polygon (poly, clip_box, gport->view.coord_per_px);
 }
 
 void
@@ -745,8 +745,8 @@ ghid_show_crosshair (gboolean paint_new_location)
 {
   gint x, y, z;
   gboolean draw_markers;
-  int vcw = VCW * gport->zoom;
-  int vcd = VCD * gport->zoom;
+  int vcw = VCW * gport->view.coord_per_px;
+  int vcd = VCD * gport->view.coord_per_px;
   static int done_once = 0;
   static GdkColor cross_color;
 
@@ -783,25 +783,25 @@ ghid_show_crosshair (gboolean paint_new_location)
   if (x >= 0 && paint_new_location && draw_markers)
     {
       glBegin (GL_QUADS);
-      glVertex3i (SIDE_X (gport->view_x0),                            y - vcd,       z);
-      glVertex3i (SIDE_X (gport->view_x0),                            y - vcd + vcw, z);
-      glVertex3i (SIDE_X (gport->view_x0 + vcd),                      y - vcd + vcw, z);
-      glVertex3i (SIDE_X (gport->view_x0 + vcd),                      y - vcd,       z);
-
-      glVertex3i (SIDE_X (gport->view_x0 + gport->view_width),        y - vcd,       z);
-      glVertex3i (SIDE_X (gport->view_x0 + gport->view_width),        y - vcd + vcw, z);
-      glVertex3i (SIDE_X (gport->view_x0 + gport->view_width - vcd),  y - vcd + vcw, z);
-      glVertex3i (SIDE_X (gport->view_x0 + gport->view_width - vcd),  y - vcd,       z);
-
-      glVertex3i (x - vcd,       SIDE_Y (gport->view_y0),                            z);
-      glVertex3i (x - vcd,       SIDE_Y (gport->view_y0 + vcd),                      z);
-      glVertex3i (x - vcd + vcw, SIDE_Y (gport->view_y0 + vcd),                      z);
-      glVertex3i (x - vcd + vcw, SIDE_Y (gport->view_y0),                            z);
-
-      glVertex3i (x - vcd,       SIDE_Y (gport->view_y0 + gport->view_height - vcd), z);
-      glVertex3i (x - vcd,       SIDE_Y (gport->view_y0 + gport->view_height),       z);
-      glVertex3i (x - vcd + vcw, SIDE_Y (gport->view_y0 + gport->view_height),       z);
-      glVertex3i (x - vcd + vcw, SIDE_Y (gport->view_y0 + gport->view_height - vcd), z);
+      glVertex3i (SIDE_X (gport->view.x0),                            y - vcd,       z);
+      glVertex3i (SIDE_X (gport->view.x0),                            y - vcd + vcw, z);
+      glVertex3i (SIDE_X (gport->view.x0 + vcd),                      y - vcd + vcw, z);
+      glVertex3i (SIDE_X (gport->view.x0 + vcd),                      y - vcd,       z);
+
+      glVertex3i (SIDE_X (gport->view.x0 + gport->view.width),        y - vcd,       z);
+      glVertex3i (SIDE_X (gport->view.x0 + gport->view.width),        y - vcd + vcw, z);
+      glVertex3i (SIDE_X (gport->view.x0 + gport->view.width - vcd),  y - vcd + vcw, z);
+      glVertex3i (SIDE_X (gport->view.x0 + gport->view.width - vcd),  y - vcd,       z);
+
+      glVertex3i (x - vcd,       SIDE_Y (gport->view.y0),                            z);
+      glVertex3i (x - vcd,       SIDE_Y (gport->view.y0 + vcd),                      z);
+      glVertex3i (x - vcd + vcw, SIDE_Y (gport->view.y0 + vcd),                      z);
+      glVertex3i (x - vcd + vcw, SIDE_Y (gport->view.y0),                            z);
+
+      glVertex3i (x - vcd,       SIDE_Y (gport->view.y0 + gport->view.height - vcd), z);
+      glVertex3i (x - vcd,       SIDE_Y (gport->view.y0 + gport->view.height),       z);
+      glVertex3i (x - vcd + vcw, SIDE_Y (gport->view.y0 + gport->view.height),       z);
+      glVertex3i (x - vcd + vcw, SIDE_Y (gport->view.y0 + gport->view.height - vcd), z);
 
       glEnd ();
     }
@@ -933,13 +933,13 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glLoadIdentity ();
   glTranslatef (0.0f, 0.0f, -Z_NEAR);
 
-  glScalef ((ghid_flip_x ? -1. : 1.) / port->zoom,
-            (ghid_flip_y ? -1. : 1.) / port->zoom,
-            ((ghid_flip_x == ghid_flip_y) ? 1. : -1.) / port->zoom);
-  glTranslatef (ghid_flip_x ? port->view_x0 - PCB->MaxWidth  :
-                             -port->view_x0,
-                ghid_flip_y ? port->view_y0 - PCB->MaxHeight :
-                             -port->view_y0, 0);
+  glScalef ((port->view.flip_x ? -1. : 1.) / port->view.coord_per_px,
+            (port->view.flip_y ? -1. : 1.) / port->view.coord_per_px,
+            ((port->view.flip_x == port->view.flip_y) ? 1. : -1.) / port->view.coord_per_px);
+  glTranslatef (port->view.flip_x ? port->view.x0 - PCB->MaxWidth  :
+                             -port->view.x0,
+                port->view.flip_y ? port->view.y0 - PCB->MaxHeight :
+                             -port->view.y0, 0);
 
   glEnable (GL_STENCIL_TEST);
   glClearColor (port->offlimits_color.red / 65535.,
@@ -1035,13 +1035,13 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   int save_view_width, save_view_height;
   double xz, yz;
 
-  save_zoom = gport->zoom;
+  save_zoom = gport->view.coord_per_px;
   save_width = gport->width;
   save_height = gport->height;
-  save_left = gport->view_x0;
-  save_top = gport->view_y0;
-  save_view_width = gport->view_width;
-  save_view_height = gport->view_height;
+  save_left = gport->view.x0;
+  save_top = gport->view.y0;
+  save_view_width = gport->view.width;
+  save_view_height = gport->view.height;
 
   /* Setup zoom factor for drawing routines */
 
@@ -1049,16 +1049,16 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   xz = (double) pinout->x_max / da_w;
   yz = (double) pinout->y_max / da_h;
   if (xz > yz)
-    gport->zoom = xz;
+    gport->view.coord_per_px = xz;
   else
-    gport->zoom = yz;
+    gport->view.coord_per_px = yz;
 
   gport->width = da_w;
   gport->height = da_h;
-  gport->view_width = da_w * gport->zoom;
-  gport->view_height = da_h * gport->zoom;
-  gport->view_x0 = (pinout->x_max - gport->view_width) / 2;
-  gport->view_y0 = (pinout->y_max - gport->view_height) / 2;
+  gport->view.width = da_w * gport->view.coord_per_px;
+  gport->view.height = da_h * gport->view.coord_per_px;
+  gport->view.x0 = (pinout->x_max - gport->view.width) / 2;
+  gport->view.y0 = (pinout->y_max - gport->view.height) / 2;
 
   /* make GL-context "current" */
   if (!gdk_gl_drawable_gl_begin (pGlDrawable, pGlContext)) {
@@ -1097,12 +1097,12 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
   glPushMatrix ();
-  glScalef ((ghid_flip_x ? -1. : 1.) / gport->zoom,
-            (ghid_flip_y ? -1. : 1.) / gport->zoom, 1);
-  glTranslatef (ghid_flip_x ? gport->view_x0 - PCB->MaxWidth  :
-                             -gport->view_x0,
-                ghid_flip_y ? gport->view_y0 - PCB->MaxHeight :
-                             -gport->view_y0, 0);
+  glScalef ((gport->view.flip_x ? -1. : 1.) / gport->view.coord_per_px,
+            (gport->view.flip_y ? -1. : 1.) / gport->view.coord_per_px, 1);
+  glTranslatef (gport->view.flip_x ? gport->view.x0 - PCB->MaxWidth  :
+                                    -gport->view.x0,
+                gport->view.flip_y ? gport->view.y0 - PCB->MaxHeight :
+                                    -gport->view.y0, 0);
   hid_expose_callback (&ghid_hid, NULL, &pinout->element);
   hidgl_flush_triangles (&buffer);
   glPopMatrix ();
@@ -1116,13 +1116,13 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   gport->render_priv->in_context = false;
   gdk_gl_drawable_gl_end (pGlDrawable);
 
-  gport->zoom = save_zoom;
+  gport->view.coord_per_px = save_zoom;
   gport->width = save_width;
   gport->height = save_height;
-  gport->view_x0 = save_left;
-  gport->view_y0 = save_top;
-  gport->view_width = save_view_width;
-  gport->view_height = save_view_height;
+  gport->view.x0 = save_left;
+  gport->view.y0 = save_top;
+  gport->view.width = save_view_width;
+  gport->view.height = save_view_height;
 
   return FALSE;
 }
@@ -1142,13 +1142,13 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   int save_view_width, save_view_height;
   BoxType region;
 
-  save_zoom = gport->zoom;
+  save_zoom = gport->view.coord_per_px;
   save_width = gport->width;
   save_height = gport->height;
-  save_left = gport->view_x0;
-  save_top = gport->view_y0;
-  save_view_width = gport->view_width;
-  save_view_height = gport->view_height;
+  save_left = gport->view.x0;
+  save_top = gport->view.y0;
+  save_view_width = gport->view.width;
+  save_view_height = gport->view.height;
 
   /* Setup rendering context for drawing routines
    */
@@ -1164,15 +1164,15 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
 
   /* Setup zoom factor for drawing routines */
 
-  gport->zoom = zoom;
+  gport->view.coord_per_px = zoom;
   gport->width = width;
   gport->height = height;
-  gport->view_width = width * gport->zoom;
-  gport->view_height = height * gport->zoom;
-  gport->view_x0 = ghid_flip_x ? PCB->MaxWidth - cx : cx;
-  gport->view_x0 -= gport->view_height / 2;
-  gport->view_y0 = ghid_flip_y ? PCB->MaxHeight - cy : cy;
-  gport->view_y0 -= gport->view_width  / 2;
+  gport->view.width = width * gport->view.coord_per_px;
+  gport->view.height = height * gport->view.coord_per_px;
+  gport->view.x0 = gport->view.flip_x ? PCB->MaxWidth - cx : cx;
+  gport->view.x0 -= gport->view.height / 2;
+  gport->view.y0 = gport->view.flip_y ? PCB->MaxHeight - cy : cy;
+  gport->view.y0 -= gport->view.width / 2;
 
   /* make GL-context "current" */
   if (!gdk_gl_drawable_gl_begin (gldrawable, glcontext)) {
@@ -1208,12 +1208,12 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
   glPushMatrix ();
-  glScalef ((ghid_flip_x ? -1. : 1.) / gport->zoom,
-            (ghid_flip_y ? -1. : 1.) / gport->zoom, 1);
-  glTranslatef (ghid_flip_x ? gport->view_x0 - PCB->MaxWidth  :
-                             -gport->view_x0,
-                ghid_flip_y ? gport->view_y0 - PCB->MaxHeight :
-                             -gport->view_y0, 0);
+  glScalef ((gport->view.flip_x ? -1. : 1.) / gport->view.coord_per_px,
+            (gport->view.flip_y ? -1. : 1.) / gport->view.coord_per_px, 1);
+  glTranslatef (gport->view.flip_x ? gport->view.x0 - PCB->MaxWidth  :
+                                    -gport->view.x0,
+                gport->view.flip_y ? gport->view.y0 - PCB->MaxHeight :
+                                    -gport->view.y0, 0);
 
   region.X1 = MIN(Px(0), Px(gport->width + 1));
   region.Y1 = MIN(Py(0), Py(gport->height + 1));
@@ -1240,13 +1240,13 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   g_object_unref (glconfig);
   g_object_unref (glcontext);
 
-  gport->zoom = save_zoom;
+  gport->view.coord_per_px = save_zoom;
   gport->width = save_width;
   gport->height = save_height;
-  gport->view_x0 = save_left;
-  gport->view_y0 = save_top;
-  gport->view_width = save_view_width;
-  gport->view_height = save_view_height;
+  gport->view.x0 = save_left;
+  gport->view.y0 = save_top;
+  gport->view.width = save_view_width;
+  gport->view.height = save_view_height;
 
   return pixmap;
 }
@@ -1275,13 +1275,13 @@ ghid_request_debug_draw (void)
   glDisable (GL_STENCIL_TEST);
 
   glPushMatrix ();
-  glScalef ((ghid_flip_x ? -1. : 1.) / port->zoom,
-            (ghid_flip_y ? -1. : 1.) / port->zoom,
-            (ghid_flip_x == ghid_flip_y) ? 1. : -1.);
-  glTranslatef (ghid_flip_x ? port->view_x0 - PCB->MaxWidth  :
-                             -port->view_x0,
-                ghid_flip_y ? port->view_y0 - PCB->MaxHeight :
-                             -port->view_y0, 0);
+  glScalef ((port->view.flip_x ? -1. : 1.) / port->view.coord_per_px,
+            (port->view.flip_y ? -1. : 1.) / port->view.coord_per_px,
+            (port->view.flip_x == port->view.flip_y) ? 1. : -1.);
+  glTranslatef (port->view.flip_x ? port->view.x0 - PCB->MaxWidth  :
+                             -port->view.x0,
+                port->view.flip_y ? port->view.y0 - PCB->MaxHeight :
+                             -port->view.y0, 0);
 
   return &ghid_hid;
 }
@@ -1364,7 +1364,7 @@ draw_lead_user (render_priv *priv)
 
       /* Draw an arc at radius */
       hidgl_draw_arc (width, priv->lead_user_x, priv->lead_user_y,
-                      radius, radius, 0, 360, gport->zoom);
+                      radius, radius, 0, 360, gport->view.coord_per_px);
     }
 
   hidgl_flush_triangles (&buffer);
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index b1af557..0c9019d 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -30,8 +30,6 @@
 RCSID ("$Id$");
 
 
-bool ghid_flip_x = false, ghid_flip_y = false;
-
 static void
 pan_common (GHidPort *port)
 {
@@ -42,10 +40,10 @@ pan_common (GHidPort *port)
   ghid_pcb_to_event_coords (gport->pcb_x, gport->pcb_y, &event_x, &event_y);
 
   /* Don't pan so far the board is completely off the screen */
-  port->view_x0 = MAX (-port->view_width,  port->view_x0);
-  port->view_y0 = MAX (-port->view_height, port->view_y0);
-  port->view_x0 = MIN ( port->view_x0, PCB->MaxWidth);
-  port->view_y0 = MIN ( port->view_y0, PCB->MaxHeight);
+  port->view.x0 = MAX (-port->view.width,  port->view.x0);
+  port->view.y0 = MAX (-port->view.height, port->view.y0);
+  port->view.x0 = MIN ( port->view.x0, PCB->MaxWidth);
+  port->view.y0 = MIN ( port->view.y0, PCB->MaxHeight);
 
   /* Fix up noted event coordinates to match where we clamped. Alternatively
    * we could call ghid_note_event_location (NULL); to get a new pointer
@@ -54,8 +52,8 @@ pan_common (GHidPort *port)
   ghid_event_to_pcb_coords (event_x, event_y, &gport->pcb_x, &gport->pcb_y);
 
   ghidgui->adjustment_changed_holdoff = TRUE;
-  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view_x0);
-  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view_y0);
+  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view.x0);
+  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view.y0);
   ghidgui->adjustment_changed_holdoff = FALSE;
 
   ghid_port_ranges_changed();
@@ -64,8 +62,8 @@ pan_common (GHidPort *port)
 static void
 ghid_pan_view_abs (Coord pcb_x, Coord pcb_y, int widget_x, int widget_y)
 {
-  gport->view_x0 = SIDE_X (pcb_x) - widget_x * gport->zoom;
-  gport->view_y0 = SIDE_Y (pcb_y) - widget_y * gport->zoom;
+  gport->view.x0 = SIDE_X (pcb_x) - widget_x * gport->view.coord_per_px;
+  gport->view.y0 = SIDE_Y (pcb_y) - widget_y * gport->view.coord_per_px;
 
   pan_common (gport);
 }
@@ -73,14 +71,14 @@ ghid_pan_view_abs (Coord pcb_x, Coord pcb_y, int widget_x, int widget_y)
 void
 ghid_pan_view_rel (Coord dx, Coord dy)
 {
-  gport->view_x0 += dx;
-  gport->view_y0 += dy;
+  gport->view.x0 += dx;
+  gport->view.y0 += dy;
 
   pan_common (gport);
 }
 
 
-/* gport->zoom:
+/* gport->view.coord_per_px:
  * zoom value is PCB units per screen pixel.  Larger numbers mean zooming
  * out - the largest value means you are looking at the whole board.
  *
@@ -103,18 +101,18 @@ ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
                   PCB->MaxHeight / gport->height) * ALLOW_ZOOM_OUT_BY;
   new_zoom = MIN (MAX (min_zoom, new_zoom), max_zoom);
 
-  if (gport->zoom == new_zoom)
+  if (gport->view.coord_per_px == new_zoom)
     return;
 
-  xtmp = (SIDE_X (center_x) - gport->view_x0) / (double)gport->view_width;
-  ytmp = (SIDE_Y (center_y) - gport->view_y0) / (double)gport->view_height;
+  xtmp = (SIDE_X (center_x) - gport->view.x0) / (double)gport->view.width;
+  ytmp = (SIDE_Y (center_y) - gport->view.y0) / (double)gport->view.height;
 
-  gport->zoom = new_zoom;
+  gport->view.coord_per_px = new_zoom;
   pixel_slop = new_zoom;
   ghid_port_ranges_scale ();
 
-  gport->view_x0 = SIDE_X (center_x) - xtmp * gport->view_width;
-  gport->view_y0 = SIDE_Y (center_y) - ytmp * gport->view_height;
+  gport->view.x0 = SIDE_X (center_x) - xtmp * gport->view.width;
+  gport->view.y0 = SIDE_Y (center_y) - ytmp * gport->view.height;
 
   pan_common (gport);
 
@@ -124,7 +122,7 @@ ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
 static void
 ghid_zoom_view_rel (Coord center_x, Coord center_y, double factor)
 {
-  ghid_zoom_view_abs (center_x, center_y, gport->zoom * factor);
+  ghid_zoom_view_abs (center_x, center_y, gport->view.coord_per_px * factor);
 }
 
 static void
@@ -143,8 +141,8 @@ ghid_flip_view (Coord center_x, Coord center_y, bool flip_x, bool flip_y)
   /* Work out where on the screen the flip point is */
   ghid_pcb_to_event_coords (center_x, center_y, &widget_x, &widget_y);
 
-  ghid_flip_x = ghid_flip_x != flip_x;
-  ghid_flip_y = ghid_flip_y != flip_y;
+  gport->view.flip_x = gport->view.flip_x != flip_x;
+  gport->view.flip_y = gport->view.flip_y != flip_y;
 
   /* Pan the board so the center location remains in the same place */
   ghid_pan_view_abs (center_x, center_y, widget_x, widget_y);
@@ -1653,13 +1651,13 @@ CursorAction(int argc, char **argv, Coord x, Coord y)
 {
   UnitList extra_units_x = {
     { "grid",  PCB->Grid, 0 },
-    { "view",  gport->view_width, UNIT_PERCENT },
+    { "view",  gport->view.width, UNIT_PERCENT },
     { "board", PCB->MaxWidth, UNIT_PERCENT },
     { "", 0, 0 }
   };
   UnitList extra_units_y = {
     { "grid",  PCB->Grid, 0 },
-    { "view",  gport->view_height, UNIT_PERCENT },
+    { "view",  gport->view.height, UNIT_PERCENT },
     { "board", PCB->MaxHeight, UNIT_PERCENT },
     { "", 0, 0 }
   };
@@ -1677,10 +1675,10 @@ CursorAction(int argc, char **argv, Coord x, Coord y)
     AFAIL (cursor);
 
   dx = GetValueEx (argv[1], argv[3], NULL, extra_units_x, "");
-  if (ghid_flip_x)
+  if (gport->view.flip_x)
     dx = -dx;
   dy = GetValueEx (argv[2], argv[3], NULL, extra_units_y, "");
-  if (!ghid_flip_y)
+  if (!gport->view.flip_y)
     dy = -dy;
 
   EventMoveCrosshair (Crosshair.X + dx, Crosshair.Y + dy);
@@ -1848,13 +1846,13 @@ ScrollAction (int argc, char **argv, Coord x, Coord y)
     div = atoi(argv[1]);
 
   if (strcasecmp (argv[0], "up") == 0)
-    dy = -gport->view_height / div;
+    dy = -gport->view.height / div;
   else if (strcasecmp (argv[0], "down") == 0)
-    dy = gport->view_height / div;
+    dy = gport->view.height / div;
   else if (strcasecmp (argv[0], "right") == 0)
-    dx = gport->view_width / div;
+    dx = gport->view.width / div;
   else if (strcasecmp (argv[0], "left") == 0)
-    dx = -gport->view_width / div;
+    dx = -gport->view.width / div;
   else
     AFAIL (scroll);
 
@@ -2064,19 +2062,20 @@ REGISTER_ACTIONS (ghid_main_action_list)
 
 static int
 flag_flipx (int x)
-{ 
-  return ghid_flip_x;
-} 
-static int  
+{
+  return gport->view.flip_x;
+}
+
+static int
 flag_flipy (int x)
-{ 
-  return ghid_flip_y;
-} 
+{
+  return gport->view.flip_y;
+}
 
 HID_Flag ghid_main_flag_list[] = {
   {"flip_x", flag_flipx, 0},
   {"flip_y", flag_flipy, 0}
-};  
+};
 
 REGISTER_FLAGS (ghid_main_flag_list)
 
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index 81dcd45..5929a37 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -60,8 +60,8 @@ ghid_port_ranges_changed (void)
 
   h_adj = gtk_range_get_adjustment (GTK_RANGE (ghidgui->h_range));
   v_adj = gtk_range_get_adjustment (GTK_RANGE (ghidgui->v_range));
-  gport->view_x0 = h_adj->value;
-  gport->view_y0 = v_adj->value;
+  gport->view.x0 = h_adj->value;
+  gport->view.y0 = v_adj->value;
 
   ghid_invalidate_all ();
 }
@@ -78,21 +78,21 @@ ghid_port_ranges_scale (void)
      |  drawing area size in pixels to PCB units and that will be
      |  the page size for the Gtk adjustment.
    */
-  gport->view_width = gport->width * gport->zoom;
-  gport->view_height = gport->height * gport->zoom;
+  gport->view.width = gport->width * gport->view.coord_per_px;
+  gport->view.height = gport->height * gport->view.coord_per_px;
 
   adj = gtk_range_get_adjustment (GTK_RANGE (ghidgui->h_range));
-  adj->page_size = MIN (gport->view_width, PCB->MaxWidth);
+  adj->page_size = MIN (gport->view.width, PCB->MaxWidth);
   adj->page_increment = adj->page_size / 10.0;
   adj->step_increment = adj->page_size / 100.0;
-  adj->lower = -gport->view_width;
+  adj->lower = -gport->view.width;
   adj->upper = PCB->MaxWidth + adj->page_size;
 
   adj = gtk_range_get_adjustment (GTK_RANGE (ghidgui->v_range));
-  adj->page_size = MIN (gport->view_height, PCB->MaxHeight);
+  adj->page_size = MIN (gport->view.height, PCB->MaxHeight);
   adj->page_increment = adj->page_size / 10.0;
   adj->step_increment = adj->page_size / 100.0;
-  adj->lower = -gport->view_height;
+  adj->lower = -gport->view.height;
   adj->upper = PCB->MaxHeight + adj->page_size;
 }
 
@@ -547,8 +547,8 @@ ghid_port_window_motion_cb (GtkWidget * widget,
 
   if (out->panning)
     {
-      dx = gport->zoom * (x_prev - ev->x);
-      dy = gport->zoom * (y_prev - ev->y);
+      dx = gport->view.coord_per_px * (x_prev - ev->x);
+      dy = gport->view.coord_per_px * (y_prev - ev->y);
       if (x_prev > 0)
         ghid_pan_view_rel (dx, dy);
       x_prev = ev->x;
@@ -604,8 +604,8 @@ ghid_pan_idle_cb (gpointer data)
   if (gport->has_entered)
     return FALSE;
 
-  dy = gport->zoom * y_pan_speed;
-  dx = gport->zoom * x_pan_speed;
+  dy = gport->view.coord_per_px * y_pan_speed;
+  dx = gport->view.coord_per_px * x_pan_speed;
   ghid_pan_view_rel (dx, dy);
   return TRUE;
 }
@@ -639,8 +639,8 @@ ghid_port_window_leave_cb (GtkWidget * widget,
 	  /* GdkEvent coords are set to 0,0 at leave events, so must figure
 	     |  out edge the cursor left.
 	   */
-	  w = ghid_port.width * gport->zoom;
-	  h = ghid_port.height * gport->zoom;
+	  w = ghid_port.width * out->view.coord_per_px;
+	  h = ghid_port.height * out->view.coord_per_px;
 
 	  x0 = EVENT_TO_PCB_X (0);
 	  y0 = EVENT_TO_PCB_Y (0);
@@ -648,9 +648,9 @@ ghid_port_window_leave_cb (GtkWidget * widget,
 	  x -= x0;
 	  y -= y0;
 
-	  if (ghid_flip_x )
+	  if (gport->view.flip_x)
 	      x = -x;
-	  if (ghid_flip_y )
+	  if (gport->view.flip_y)
 	      y = -y;
 
 	  dx = w - x;
diff --git a/src/hid/gtk/gui-top-window.c b/src/hid/gtk/gui-top-window.c
index f8674e6..e2beb3c 100644
--- a/src/hid/gtk/gui-top-window.c
+++ b/src/hid/gtk/gui-top-window.c
@@ -1986,7 +1986,7 @@ ghid_parse_arguments (int *argc, char ***argv)
   gtk_init (argc, argv);
 
   gport = &ghid_port;
-  gport->zoom = 300.0;
+  gport->view.coord_per_px = 300.0;
   pixel_slop = 300;
 
   ghid_init_renderer (argc, argv, gport);
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index c3f00a3..ad2a112 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -62,15 +62,14 @@
 #define	FROM_PCB_UNITS(v)	coord_to_unit (Settings.grid_unit, v)
 #define	TO_PCB_UNITS(v)		unit_to_coord (Settings.grid_unit, v)
 
-extern bool ghid_flip_x, ghid_flip_y;
-#define SIDE_X(x)   ((ghid_flip_x ? PCB->MaxWidth - (x) : (x)))
-#define SIDE_Y(y)   ((ghid_flip_y ? PCB->MaxHeight - (y) : (y)))
+#define SIDE_X(x)         ((gport->view.flip_x ? PCB->MaxWidth - (x) : (x)))
+#define SIDE_Y(y)         ((gport->view.flip_y ? PCB->MaxHeight - (y) : (y)))
 
-#define	DRAW_X(x)	(gint)((SIDE_X(x) - gport->view_x0) / gport->zoom)
-#define	DRAW_Y(y)	(gint)((SIDE_Y(y) - gport->view_y0) / gport->zoom)
+#define	DRAW_X(x)         (gint)((SIDE_X(x) - gport->view.x0) / gport->view.coord_per_px)
+#define	DRAW_Y(y)         (gint)((SIDE_Y(y) - gport->view.y0) / gport->view.coord_per_px)
 
-#define	EVENT_TO_PCB_X(x)	SIDE_X((gint)((x) * gport->zoom + gport->view_x0))
-#define	EVENT_TO_PCB_Y(y)	SIDE_Y((gint)((y) * gport->zoom + gport->view_y0))
+#define	EVENT_TO_PCB_X(x) SIDE_X((gint)((x) * gport->view.coord_per_px + gport->view.x0))
+#define	EVENT_TO_PCB_Y(y) SIDE_Y((gint)((y) * gport->view.coord_per_px + gport->view.y0))
 
 /*
  * Used to intercept "special" hotkeys that gtk doesn't usually pass
@@ -145,6 +144,19 @@ GhidGui;
 
 extern GhidGui _ghidgui, *ghidgui;
 
+typedef struct
+{
+  double coord_per_px; /* Zoom level described as PCB units per screen pixel */
+
+  Coord x0;
+  Coord y0;
+  Coord width;
+  Coord height;
+
+  bool flip_x;
+  bool flip_y;
+
+} view_data;
 
   /* The output viewport
    */
@@ -168,15 +180,9 @@ typedef struct
   gboolean has_entered;
   gboolean panning;
 
-/* zoom value is PCB units per screen pixel.  Larger numbers mean zooming
-|  out - the largest value means you are looking at the whole board.
-*/
-  gdouble zoom;			/* PCB units per screen pixel.  Larger */
-                                /* numbers mean zooming out. */
-  /* Viewport in PCB coordinates */
-  Coord view_x0, view_y0, view_width, view_height;
-  Coord pcb_x, pcb_y;
-  Coord crosshair_x, crosshair_y;
+  view_data view;
+  Coord pcb_x, pcb_y;             /* PCB coordinates of the mouse pointer */
+  Coord crosshair_x, crosshair_y; /* PCB coordinates of the crosshair     */
 }
 GHidPort;
 
@@ -520,10 +526,10 @@ static inline int
 Vx (Coord x)
 {
   int rv;
-  if (ghid_flip_x)
-    rv = (PCB->MaxWidth - x - gport->view_x0) / gport->zoom + 0.5;
+  if (gport->view.flip_x)
+    rv = (PCB->MaxWidth - x - gport->view.x0) / gport->view.coord_per_px + 0.5;
   else
-    rv = (x - gport->view_x0) / gport->zoom + 0.5;
+    rv = (x - gport->view.x0) / gport->view.coord_per_px + 0.5;
   return rv;
 }
 
@@ -531,41 +537,41 @@ static inline int
 Vy (Coord y)
 {
   int rv;
-  if (ghid_flip_y)
-    rv = (PCB->MaxHeight - y - gport->view_y0) / gport->zoom + 0.5;
+  if (gport->view.flip_y)
+    rv = (PCB->MaxHeight - y - gport->view.y0) / gport->view.coord_per_px + 0.5;
   else
-    rv = (y - gport->view_y0) / gport->zoom + 0.5;
+    rv = (y - gport->view.y0) / gport->view.coord_per_px + 0.5;
   return rv;
 }
 
 static inline int
 Vz (Coord z)
 {
-  return z / gport->zoom + 0.5;
+  return z / gport->view.coord_per_px + 0.5;
 }
 
 static inline Coord
 Px (int x)
 {
-  Coord rv = x * gport->zoom + gport->view_x0;
-  if (ghid_flip_x)
-    rv = PCB->MaxWidth - (x * gport->zoom + gport->view_x0);
+  Coord rv = x * gport->view.coord_per_px + gport->view.x0;
+  if (gport->view.flip_x)
+    rv = PCB->MaxWidth - (x * gport->view.coord_per_px + gport->view.x0);
   return  rv;
 }
 
 static inline Coord
 Py (int y)
 {
-  Coord rv = y * gport->zoom + gport->view_y0;
-  if (ghid_flip_y)
-    rv = PCB->MaxHeight - (y * gport->zoom + gport->view_y0);
+  Coord rv = y * gport->view.coord_per_px + gport->view.y0;
+  if (gport->view.flip_y)
+    rv = PCB->MaxHeight - (y * gport->view.coord_per_px + gport->view.y0);
   return  rv;
 }
 
 static inline Coord
 Pz (int z)
 {
-  return (z * gport->zoom);
+  return (z * gport->view.coord_per_px);
 }
 
 #endif /* PCB_HID_GTK_GHID_H */

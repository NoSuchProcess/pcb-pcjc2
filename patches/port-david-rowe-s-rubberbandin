Bottom: e40feebab113552a97485b3c40be2ce8acf3c1bd
Top:    e6ae3a49fc6360ac79a6d8201a122977cbfa363a
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-02-01 21:58:58 +0000

Port David Rowe's rubberbanding patch to git HEAD


---

diff --git a/src/action.c b/src/action.c
index d0e0ca3..e638fa4 100644
--- a/src/action.c
+++ b/src/action.c
@@ -192,6 +192,7 @@ typedef enum
   F_ToggleShowDRC,
   F_ToggleLiveRoute,
   F_ToggleRubberBandMode,
+  F_ToggleAllDirectionsRubberBandMode,
   F_ToggleStartDirection,
   F_ToggleSnapPin,
   F_ToggleThindraw,
@@ -422,6 +423,7 @@ static FunctionType Functions[] = {
   {"ToggleName", F_ToggleName},
   {"ToggleObject", F_ToggleObject},
   {"ToggleRubberBandMode", F_ToggleRubberBandMode},
+  {"ToggleAllDirectionsRubberBandMode", F_ToggleAllDirectionsRubberBandMode},
   {"ToggleStartDirection", F_ToggleStartDirection},
   {"ToggleSnapPin", F_ToggleSnapPin},
   {"ToggleThindraw", F_ToggleThindraw},
@@ -2456,6 +2458,7 @@ static const char display_syntax[] =
   "Display(Grid|Redraw)\n"
   "Display(CycleClip|CycleCrosshair|Toggle45Degree|ToggleStartDirection)\n"
   "Display(ToggleGrid|ToggleRubberBandMode|ToggleUniqueNames)\n"
+  "Display(ToggleAllDirectionsRubberBandMode)\n"
   "Display(ToggleMask|ToggleName|ToggleClearLine|ToggleFullPoly|ToggleSnapPin)\n"
   "Display(ToggleThindraw|ToggleThindrawPoly|ToggleOrthoMove|ToggleLocalRef)\n"
   "Display(ToggleCheckPlanes|ToggleShowDRC|ToggleAutoDRC)\n"
@@ -2493,6 +2496,10 @@ Changes crosshair drawing.  Crosshair may accept form of 4-ray,
 @item ToggleRubberBandMode
 If set, moving an object moves all the lines attached to it too.
 
+@item ToggleAllDirectionsRubberBandMode
+In RubberBand mode, lines can be moved in all directions.  If unset lines
+are restricted to 45 degrees when moving.
+
 @item ToggleStartDirection
 If set, each time you set a point in a line, the Clip toggles between
 orth-angle and angle-ortho.
@@ -2690,6 +2697,10 @@ ActionDisplay (int argc, char **argv, Coord childX, Coord childY)
 	  notify_crosshair_change (true);
 	  break;
 
+	case F_ToggleAllDirectionsRubberBandMode:
+	  TOGGLE_FLAG (ALLDIRECTIONSRUBBERBANDFLAG, PCB);
+	  break;
+
 	case F_ToggleStartDirection:
 	  notify_crosshair_change (false);
 	  TOGGLE_FLAG (SWAPSTARTDIRFLAG, PCB);
diff --git a/src/const.h b/src/const.h
index 7d732e8..87034b4 100644
--- a/src/const.h
+++ b/src/const.h
@@ -296,6 +296,7 @@ When set, element names are not drawn.
 #define ONLYNAMESFLAG           0x00080000
 #define NEWFULLPOLYFLAG         0x00100000
 #define HIDENAMESFLAG           0x00200000
+#define ALLDIRECTIONSRUBBERBANDFLAG 0x400000
 
 /* ---------------------------------------------------------------------------
  * object types
diff --git a/src/create.c b/src/create.c
index b39ff65..5c1301a 100644
--- a/src/create.c
+++ b/src/create.c
@@ -162,6 +162,8 @@ CreateNewPCB (bool SetDefaultNames)
   ptr->Clipping = 1;		/* this is the most useful starting point for now */
   if (Settings.RubberBandMode)
     SET_FLAG (RUBBERBANDFLAG, ptr);
+  if (Settings.AllDirectionsRubberBandMode)
+    SET_FLAG (ALLDIRECTIONSRUBBERBANDFLAG, ptr);
   if (Settings.SwapStartDirection)
     SET_FLAG (SWAPSTARTDIRFLAG, ptr);
   if (Settings.UniqueNames)
@@ -949,7 +951,7 @@ CreateNewRubberbandEntry (LayerType *Layer,
 
   /* we toggle the RUBBERENDFLAG of the line to determine if */
   /* both points are being moved. */
-  TOGGLE_FLAG (RUBBERENDFLAG, Line);
+  SET_FLAG (RUBBERENDFLAG, Line);
   ptr->Layer = Layer;
   ptr->Line = Line;
   ptr->MovedPoint = MovedPoint;
diff --git a/src/crosshair.c b/src/crosshair.c
index 937e506..9f53f44 100644
--- a/src/crosshair.c
+++ b/src/crosshair.c
@@ -44,13 +44,17 @@
 #include "line.h"
 #include "misc.h"
 #include "mymem.h"
+#include "rubberband.h"
 #include "search.h"
 #include "polygon.h"
+#include "pcb-printf.h"
 
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
 #endif
 
+#define dprintf if (0) pcb_printf
+
 typedef struct
 {
   int x, y;
@@ -375,8 +379,10 @@ XORDrawMoveOrCopyObject (void)
 {
   RubberbandType *ptr;
   Cardinal i;
+  LineType  LineOut;
+  PointType PointOut;
   Coord dx = Crosshair.X - Crosshair.AttachedObject.X,
-    dy = Crosshair.Y - Crosshair.AttachedObject.Y;
+        dy = Crosshair.Y - Crosshair.AttachedObject.Y;
 
   switch (Crosshair.AttachedObject.Type)
     {
@@ -390,10 +396,18 @@ XORDrawMoveOrCopyObject (void)
     case LINE_TYPE:
       {
 	LineType *line = (LineType *) Crosshair.AttachedObject.Ptr2;
+	dprintf("line->Point1.X = %d line->Point1.Y = %d RubberbandN = %d\n",
+	        line->Point1.X, line->Point1.Y,
+	        Crosshair.AttachedObject.RubberbandN);
+
+	/* work out coords of line to draw given rubber mode */
+
+	RestrictMovementGivenRubberBandMode (line, &dx, &dy);
+	MoveLineGivenRubberBandMode (&LineOut, line, dx, dy, Crosshair);
 
-	XORDrawAttachedLine (line->Point1.X + dx, line->Point1.Y + dy,
-			     line->Point2.X + dx, line->Point2.Y + dy,
-			     line->Thickness);
+	XORDrawAttachedLine (LineOut.Point1.X, LineOut.Point1.Y,
+			     LineOut.Point2.X, LineOut.Point2.Y,
+			     LineOut.Thickness);
 	break;
       }
 
@@ -515,9 +529,14 @@ XORDrawMoveOrCopyObject (void)
 	      point1 = &ptr->Line->Point1;
 	      point2 = &ptr->Line->Point2;
 	    }
-	  XORDrawAttachedLine (point1->X,
-			       point1->Y, point2->X + dx,
-			       point2->Y + dy, ptr->Line->Thickness);
+
+	  MovePointGivenRubberBandMode (&PointOut, point2, ptr->Line, dx, dy,
+					Crosshair.AttachedObject.Type, 0);
+
+	  XORDrawAttachedLine (point1->X, point1->Y,
+			       PointOut.X, PointOut.Y,
+			       ptr->Line->Thickness);
+
 	}
       else if (ptr->MovedPoint == &ptr->Line->Point1)
 	XORDrawAttachedLine (ptr->Line->Point1.X + dx,
diff --git a/src/global.h b/src/global.h
index 7b966dc..46b29f8 100644
--- a/src/global.h
+++ b/src/global.h
@@ -684,6 +684,7 @@ typedef struct			/* some resources... */
     StipplePolygons,		/* draw polygons with stipple */
     AllDirectionLines,		/* enable lines to all directions */
     RubberBandMode,		/* move, rotate use rubberband connections */
+    AllDirectionsRubberBandMode,/* rubberband tracks can move in all directions  */
     SwapStartDirection,		/* change starting direction after each click */
     ShowDRC,			/* show drc region on crosshair */
     AutoDRC,			/* */
diff --git a/src/gpcb-menu.res.in b/src/gpcb-menu.res.in
index 6cf7f19..25a46fa 100644
--- a/src/gpcb-menu.res.in
+++ b/src/gpcb-menu.res.in
@@ -209,6 +209,7 @@ MainMenu =
    {"Hide Names" checked=hidenames Display(ToggleHideNames)}
    -
    {"Rubber band mode" checked=rubberband Display(ToggleRubberBandMode)}
+   {"All Directions Rubber band mode" checked=alldirectionsrubberband Display(ToggleAllDirectionsRubberBandMode)}
    {"Require unique element names" checked=uniquename Display(ToggleUniqueNames)}
    {"Auto-zero delta measurements" checked=localref Display(ToggleLocalRef)}
    {"New lines, arcs clear polygons" checked=clearnew Display(ToggleClearLine)}
diff --git a/src/move.c b/src/move.c
index d785823..00659f2 100644
--- a/src/move.c
+++ b/src/move.c
@@ -32,6 +32,7 @@
 #include "config.h"
 #endif
 
+#include <assert.h>
 #include <setjmp.h>
 #include <stdlib.h>
 
@@ -47,15 +48,20 @@
 #include "mymem.h"
 #include "polygon.h"
 #include "rtree.h"
+#include "rubberband.h"
+#include "remove.h"
 #include "search.h"
 #include "select.h"
 #include "thermal.h"
 #include "undo.h"
+#include "pcb-printf.h"
 
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
 #endif
 
+#define dprintf if (0) pcb_printf
+
 /* ---------------------------------------------------------------------------
  * some local prototypes
  */
@@ -266,6 +272,7 @@ MoveLine (LayerType *Layer, LineType *Line)
   RestoreToPolygon (PCB->Data, LINE_TYPE, Layer, Line);
   r_delete_entry (Layer->line_tree, (BoxType *)Line);
   MOVE_LINE_LOWLEVEL (Line, DeltaX, DeltaY);
+  SetLineBoundingBox (Line);
   r_insert_entry (Layer->line_tree, (BoxType *)Line, 0);
   ClearFromPolygon (PCB->Data, LINE_TYPE, Layer, Line);
   if (Layer->On)
@@ -789,34 +796,325 @@ MoveObjectAndRubberband (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
 {
   RubberbandType *ptr;
   void *ptr2;
+  int   n;
+
+  dprintf("MoveObjectAndRubberband\n");
+  if (Type == LINE_TYPE) {
+    dprintf("  Line Type\n");
+    RestrictMovementGivenRubberBandMode ((LineType *)Ptr3, &DX, &DY);
+  }
 
   /* setup offset */
   DeltaX = DX;
   DeltaY = DY;
 
-  /* move all the lines... and reset the counter */
+  /* regular rubberband move of attached point in attached lines */
+
   ptr = Crosshair.AttachedObject.Rubberband;
-  while (Crosshair.AttachedObject.RubberbandN)
+  n = Crosshair.AttachedObject.RubberbandN;
+  while (n)
     {
+      Coord dX, dY;
+
       /* first clear any marks that we made in the line flags */
       CLEAR_FLAG (RUBBERENDFLAG, ptr->Line);
-      /* only update undo list if an actual movement happened */
-      if (DX != 0 || DY != 0)
+
+      dX = DX; dY = DY;
+
+      /*
+	 Centre each moved points in pin/pad.  This has the nice side effect
+	 or reducing the length of any stub tracks to zero so they will get
+	 deleted later.
+      */
+      dprintf("Point Number %d--------------------------------\n",n);
+      dprintf("  MovedPoint (%d,%d)\n", ptr->MovedPoint->X, ptr->MovedPoint->Y);
+      dprintf("  Line       (%d,%d) (%d,%d)\n",
+	      ptr->Line->Point1.X, ptr->Line->Point1.Y,
+	     ptr->Line->Point2.X, ptr->Line->Point2.Y);
+
+      if ((Type == PIN_TYPE) || (Type == VIA_TYPE)) {
+	PinType *PinPtr = (PinType *)Ptr1;
+        dprintf("       Pin   (%d,%d)\n", PinPtr->X, PinPtr->Y);
+        dprintf("       dX dY (%d,%d)\n", dX, dY);
+	dX += PinPtr->X - ptr->MovedPoint->X;
+	dY += PinPtr->Y - ptr->MovedPoint->Y;
+        dprintf("       dX dY (%d,%d)\n", dX, dY);
+      }
+      if (Type == PAD_TYPE) {
+	PadType *PadPtr = (PadType *)Ptr1;
+	PointType PadCentre;
+
+	PadCentre.X = (PadPtr->Point1.X + PadPtr->Point1.X)/2;
+	PadCentre.Y = (PadPtr->Point2.Y + PadPtr->Point2.Y)/2;
+	dX += PadCentre.X - ptr->MovedPoint->X;
+	dY += PadCentre.Y - ptr->MovedPoint->Y;
+      }
+
+      DeltaX = dX; DeltaY = dY;
+      if (dX != 0 || dY != 0)
         {
           AddObjectToMoveUndoList (LINEPOINT_TYPE,
                                    ptr->Layer, ptr->Line,
-                                   ptr->MovedPoint, DX, DY);
+                                   ptr->MovedPoint, dX, dY);
           MoveLinePoint (ptr->Layer, ptr->Line, ptr->MovedPoint);
         }
-      Crosshair.AttachedObject.RubberbandN--;
+
+      n--;
       ptr++;
     }
 
   if (DX == 0 && DY == 0)
     return (NULL);
 
+  /* move the actual object */
+
+  DeltaX = DX;
+  DeltaY = DY;
   AddObjectToMoveUndoList (Type, Ptr1, Ptr2, Ptr3, DX, DY);
   ptr2 = ObjectOperation (&MoveFunctions, Type, Ptr1, Ptr2, Ptr3);
+
+  /* now we do fixups to maintain 45 deg angles during rubberband
+     drags */
+
+  switch (Type) {
+
+  case LINE_TYPE:
+    {
+
+      /* In rubberband mode we nudge one end of the line we just moved
+	 to keep joined lines aligned 45 degrees  */
+
+      n = Crosshair.AttachedObject.RubberbandN;
+      ptr = Crosshair.AttachedObject.Rubberband;
+      while(n) {
+	Coord nudgeX, nudgeY;
+	LineType *line = (LineType *)Ptr3;
+	PointType PointOut;
+	PointType *nudge;
+
+	dprintf("  Nudging a line attached to line %d\n", n);
+
+	MovePointGivenRubberBandMode(&PointOut, ptr->MovedPoint, ptr->Line,
+				     DX, DY, Crosshair.AttachedObject.Type,
+				     IsDiagonal(line));
+
+	nudgeX = PointOut.X - ptr->MovedPoint->X - DX;
+	nudgeY = PointOut.Y - ptr->MovedPoint->Y - DY;
+	dprintf("  nudgeX = %d  nudgeY = %d\n", nudgeX, nudgeY);
+	DeltaX = nudgeX; DeltaY = nudgeY;
+
+	/* nudge point on attached line */
+
+	/* nudge point on line */
+
+	if ((ptr->MovedPoint->X == line->Point1.X) &&
+	    (ptr->MovedPoint->Y == line->Point1.Y)) {
+	  nudge = &line->Point1;
+	  dprintf("    nudge point1\n");
+	}
+	else {
+	  dprintf("    nudge point2\n");
+	  nudge = &line->Point2;
+	}
+
+	AddObjectToMoveUndoList (LINEPOINT_TYPE,
+				 ptr->Layer, ptr->Line, ptr->MovedPoint, nudgeX,
+				 nudgeY);
+	MoveLinePoint (ptr->Layer, ptr->Line, ptr->MovedPoint);
+
+	AddObjectToMoveUndoList (LINEPOINT_TYPE, Ptr1, Ptr2, nudge,
+				 nudgeX,nudgeY);
+	MoveLinePoint (Ptr1, Ptr2, nudge);
+	ptr++;
+	n--;
+      }
+    }
+    break;
+
+  case VIA_TYPE:
+  case PAD_TYPE:
+  case PIN_TYPE:
+  case ELEMENT_TYPE:
+    {
+      /*
+	 Generalised rubber band dragging of lines attached objects.  At
+	 the start start of this code we have a non-45 line 'A' between
+	 p1-p3. At the end of this code we want something like:
+
+
+	      p2________p3
+	     /    A
+	    /B
+           /
+	 p1
+
+	 To make nice angles we need an two lines.  If A is already
+	 attached to another line we use that as B.  If A is not
+	 attached we create a line.
+
+	 So the steps are (i) find or create B (ii) determine p2 and
+	 (iii) move B to p1-p2, and A to p2-p3.
+
+	 There are actually lots of ways to route lines between p1
+	 and p3 using an intermediate point p2.  If we wanted to
+	 be really clever we could test if B and A touch any other
+	 objects, if so try some other routing methods.
+      */
+
+      n = Crosshair.AttachedObject.RubberbandN;
+      ptr = Crosshair.AttachedObject.Rubberband;
+      while(n) {
+	PointType p1, p2, p3;
+	PointType *lineA_p2, *lineB_p2; /* inital p2 points before move */
+	LineType *lineA = ptr->Line;
+	LineType *lineB;
+	Coord dX, dY;
+	int ignore;
+
+	ignore = 0;
+
+	dprintf("  Line attached to an object %d---------------\n", n);
+
+	if (!TEST_FLAG (RUBBERBANDFLAG, PCB))
+	  ignore = 1;
+	if (TEST_FLAG (ALLDIRECTIONSRUBBERBANDFLAG, PCB))
+	  ignore = 1;
+
+	/* ignore any xero length objects */
+
+	if ((lineA->Point1.X == lineA->Point2.X) &&
+	    (lineA->Point1.Y == lineA->Point2.Y))
+	  ignore = 1;
+
+	if (!ignore) {
+
+	  /* map current points at end of line to our model */
+
+	  if ((ptr->MovedPoint->X == lineA->Point1.X) &&
+	      (ptr->MovedPoint->Y == lineA->Point1.Y))
+	    {
+	      p3 = lineA->Point1;
+	      lineA_p2 = &lineA->Point2;
+	    }
+	  else
+	    {
+	      lineA_p2 = &lineA->Point1;
+	      p3 = lineA->Point2;
+	    }
+
+	  dprintf("    Initial lineA\n");
+	  dprintf("      p3.X = %d  p3.Y = %d\n", p3.X, p3.Y);
+	  dprintf("      p2.X = %d  p2.Y = %d\n", lineA_p2->X, lineA_p2->Y);
+
+	  /* now lets find/create line B  */
+
+	  if ((lineB = FindLineAttachedToPoint (ptr->Layer, lineA, lineA_p2))
+	      != NULL)
+	    {
+	      dprintf("    lineB found!\n");
+	      if ((lineA_p2->X == lineB->Point1.X) &&
+		  (lineA_p2->Y == lineB->Point1.Y))
+		{
+		  p1 = lineB->Point2;
+		  lineB_p2 = &lineB->Point1;
+		}
+	      else
+		{
+		  p1 = lineB->Point1;
+		  lineB_p2 = &lineB->Point2;
+		}
+	    }
+	  else
+	    {
+	      /* No attached line found, lets create one, coords dont matter
+		 for now as it will be moved shortly */
+
+	      dprintf("    lineB created!\n");
+	      lineB = CreateNewLineOnLayer (ptr->Layer,
+					    lineA_p2->X,
+					    lineA_p2->Y, p3.X, p3.Y,
+					    lineA->Thickness,
+					    2 * lineA->Clearance,
+					    lineA->Flags);
+	      AddObjectToCreateUndoList (LINE_TYPE, CURRENT, lineB, lineB);
+	      p1.X = lineA_p2->X; p1.Y = lineA_p2->Y;
+	      lineB_p2 = &lineB->Point2;
+	    }
+
+	  dprintf("    Initial lineB\n");
+	  dprintf("      p1.X = %d  p1.Y = %d\n", p1.X, p1.Y);
+	  dprintf("      p2.X = %d  p2.Y = %d\n", lineB_p2->X, lineB_p2->Y);
+
+	  /* OK, we now have lineA and lineB, p1, and p3 are set, need to
+	     determine p2 such that we are routing lines at 45 deg. */
+
+	  dY = abs(p3.Y - p1.Y);
+	  dX = abs(p3.X - p1.X);
+	  dprintf("    Final dX = %d  dY = %d\n", dX, dY);
+
+	  if (dX < dY) {
+	    p2.X = p1.X + SGN(p3.X - p1.X)*dX;
+	    p2.Y = p1.Y + SGN(p3.Y - p1.Y)*dX;
+	  }
+	  else {
+	    p2.X = p1.X + SGN(p3.X - p1.X)*dY;
+	    p2.Y = p1.Y + SGN(p3.Y - p1.Y)*dY;
+	  }
+
+	  dprintf("    New p2:\n");
+	  dprintf("      p2.X = %d  p2.Y = %d\n", p2.X, p2.Y);
+
+	  /* Move lineA so it starts at p2 */
+
+	  DeltaX = p2.X - lineA_p2->X; DeltaY = p2.Y - lineA_p2->Y;
+	  dprintf("    lineA:\n");
+	  dprintf("      DeltaX = %d   DeltaY = %d\n", DeltaX,  DeltaY);
+	  AddObjectToMoveUndoList (LINEPOINT_TYPE,
+				   ptr->Layer, lineA, lineA_p2, DeltaX,
+				   DeltaY);
+	  MoveLinePoint (ptr->Layer, lineA, lineA_p2);
+
+	  /* Move lineB so it ends at p2 */
+
+	  DeltaX = p2.X - lineB_p2->X; DeltaY = p2.Y - lineB_p2->Y;
+	  dprintf("    lineB:\n");
+	  dprintf("      DeltaX = %d   DeltaY = %d\n", DeltaX,  DeltaY);
+	  AddObjectToMoveUndoList (LINEPOINT_TYPE,
+				   ptr->Layer, lineB, lineB_p2, DeltaX,
+				   DeltaY);
+	  MoveLinePoint (ptr->Layer, lineB, lineB_p2);
+	}
+
+	/* next attached line to object */
+
+        ptr++;
+	n--;
+      }
+    }
+  }
+
+  /* final loop to reset counter and clear flags */
+
+  ptr = Crosshair.AttachedObject.Rubberband;
+  n = Crosshair.AttachedObject.RubberbandN;
+  while (n)
+    {
+      LineType *line = (LineType *)ptr->Line;
+      CLEAR_FLAG (RUBBERENDFLAG, ptr->Line);
+      Crosshair.AttachedObject.RubberbandN--;
+
+      /* clean up - delete any zero length lines */
+
+      if ((line->Point1.X == line->Point2.X) &&
+	  (line->Point1.Y == line->Point2.Y))
+	{
+	  RemoveLine (ptr->Layer, line);
+	}
+
+      n--;
+      ptr++;
+    }
+
   IncrementUndoSerialNumber ();
   return (ptr2);
 }
diff --git a/src/pcb-menu.res.in b/src/pcb-menu.res.in
index 84c4a45..5a75ed8 100644
--- a/src/pcb-menu.res.in
+++ b/src/pcb-menu.res.in
@@ -195,6 +195,7 @@ MainMenu =
    {"Auto enforce DRC clearance" checked=autodrc Display(ToggleAutoDRC)}
    -
    {"Rubber band mode" checked=rubberband Display(ToggleRubberBandMode)}
+   {"All Directions Rubber band mode" checked=alldirectionsrubberband Display(ToggleAllDirectionsRubberBandMode)}
    {"Require unique element names" checked=uniquename Display(ToggleUniqueNames)}
    {"Auto-zero delta measurements" checked=localref Display(ToggleLocalRef)}
    {"New lines, arcs clear polygons" checked=clearnew Display(ToggleClearLine)}
diff --git a/src/rubberband.c b/src/rubberband.c
index cd2c4f6..398c072 100644
--- a/src/rubberband.c
+++ b/src/rubberband.c
@@ -32,6 +32,7 @@
 #include "config.h"
 #endif
 
+#include <math.h>
 #include <stdlib.h>
 #ifdef HAVE_STRING_H
 #include <string.h>
@@ -52,11 +53,14 @@
 #include "rubberband.h"
 #include "rtree.h"
 #include "search.h"
+#include "pcb-printf.h"
 
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
 #endif
 
+#define dprintf if (0) pcb_printf
+
 /* ---------------------------------------------------------------------------
  * some local prototypes
  */
@@ -70,6 +74,8 @@ static void CheckPolygonForRubberbandConnection (LayerType *,
 						 PolygonType *);
 static void CheckLinePointForRat (LayerType *, PointType *);
 static int rubber_callback (const BoxType * b, void *cl);
+static int rb_sign(Coord x);
+static int LineAttachedCallback (const BoxType * b, void *cl);
 
 struct rubber_info
 {
@@ -80,6 +86,17 @@ struct rubber_info
   LayerType *layer;
 };
 
+struct AttachedInfo
+{
+  int radius;
+  Coord X, Y;
+  LineType    *line;
+  BoxType      box;
+  LayerType   *layer;
+  int          nAttached;
+  LineType    *AttachedLine;
+};
+
 static int
 rubber_callback (const BoxType * b, void *cl)
 {
@@ -578,3 +595,404 @@ LookupRatLines (int Type, void *Ptr1, void *Ptr2, void *Ptr3)
       break;
     }
 }
+
+/* centre zero rubber band sign function */
+
+int
+rbsgn(Coord x)
+{
+  if (x > 0) return  1;
+  if (x < 0) return -1;
+  return 0;
+}
+
+int
+IsHorizontal(LineType *Line)
+{
+  if (Line->Point1.Y == Line->Point2.Y)
+    return 1;
+  else
+    return 0;
+}
+
+int
+IsVertical(LineType *Line)
+{
+  if (Line->Point1.X == Line->Point2.X)
+    return 1;
+  else
+    return 0;
+}
+
+int
+IsDiagonal(LineType *Line)
+{
+  if (!(IsHorizontal(Line) || IsVertical(Line)))
+    return 1;
+  else
+    return 0;
+}
+
+void
+MovePointGivenRubberBandMode(PointType *PointOut,
+			    PointType *Point,
+			    LineType *Line,
+			    Coord dx,
+			    Coord dy,
+			    int Type,
+			    int Diagonal)
+{
+  PointType *point1, *point2;
+
+  dprintf("MovePointGivenRubberBandMode\n");
+
+  /* default move */
+
+  memmove(PointOut, Point, sizeof(PointType));
+  PointOut->X += dx;
+  PointOut->Y += dy;
+
+  /* return default when rubberband mode off */
+
+  if (!TEST_FLAG (RUBBERBANDFLAG, PCB)) {
+    return;
+  }
+
+  /* or when in rubber band mode and all directions enabled */
+
+  if (TEST_FLAG (ALLDIRECTIONSRUBBERBANDFLAG, PCB)) {
+    return;
+  }
+
+  /* or if the object being moved is not a line, as we can't handle
+     general objects (yet), only lines */
+
+  if (Type != LINE_TYPE)
+    return;
+
+  /* or if this line is not horizontal or vertical, we dont handle
+     diagonals */
+
+  if (Diagonal)
+    return;
+
+  /*
+     Determine:
+       - point1 is the fixed point of the attached line
+       - point2 is where the attached line and line being moved join
+  */
+
+  if ((Point->X == Line->Point1.X) && (Point->Y == Line->Point2.Y))
+    {
+      point1 = &Line->Point2;
+      point2 = &Line->Point1;
+    }
+  else
+    {
+      point1 = &Line->Point1;
+      point2 = &Line->Point2;
+    }
+
+  /* Then adjust according to relative direction of joined lines */
+
+  dprintf("  dx: %mD dy : %mD\n", dx, dy);
+  dprintf("  point2->X %mD point1->X %mD corr: %mD\n", point2->X, point1->X,
+	   dx*rbsgn(point2->X - point1->X));
+  dprintf("  point2->Y %mD point1->Y %mD corr: %mD\n", point2->Y, point1->Y,
+	  dx*rbsgn(point2->Y - point1->Y));
+  dprintf(" Before: Point1->X %mD Point1->Y %mD\n", PointOut->X,
+	  PointOut->Y);
+
+  /* I am sure there is some elegant matrix algebra going on here, but
+     I used the "get something simple going and iterate" algorithm,
+     and by lots of scribbling of bent lines on paper! */
+
+  PointOut->Y += dx*rbsgn(point2->X - point1->X)*rbsgn(point2->Y - point1->Y);
+  PointOut->X += dy*rbsgn(point2->Y - point1->Y)*rbsgn(point2->X - point1->X);
+
+  #ifdef RUBBER_DEBUG
+  dprintf(" After.: PointOut->X %d PointOut->Y %d\n", PointOut->X,
+	  PointOut->Y);
+  #endif
+}
+
+
+void
+MoveLineGivenRubberBandMode(LineType *LineOut,
+			    LineType *Line,
+			    Coord dx,
+			    Coord dy,
+			    CrosshairType CrossHair
+)
+{
+  PointType *point1, *point2, *nudge;
+  RubberbandType *AttachedLine;
+  int n;
+
+  dprintf("MoveLineGivenRubberBandMode\n");
+  dprintf("  dx: %d dy : %d\n", dx, dy);
+
+  /* default move */
+
+  memmove(LineOut, Line, sizeof(LineType));
+  LineOut->Point1.X += dx;
+  LineOut->Point1.Y += dy;
+  LineOut->Point2.X += dx;
+  LineOut->Point2.Y += dy;
+
+  /* return default when rubberband mode off */
+
+  if (!TEST_FLAG (RUBBERBANDFLAG, PCB)) {
+    return;
+  }
+
+  /* or when in rubber band mode and all directions enabled */
+
+  if (TEST_FLAG (ALLDIRECTIONSRUBBERBANDFLAG, PCB)) {
+    return;
+  }
+
+  /* or if this line is not horizontal or vertical, we dont handle
+     diagonals */
+
+  if (IsDiagonal(Line))
+    return;
+
+  /* we should return unless there are attached lines */
+
+  if(Crosshair.AttachedObject.RubberbandN == 0)
+    return;
+
+  dprintf("    Line->Point1.X = %d\n", Line->Point1.X);
+  dprintf("    Line->Point1.Y = %d\n", Line->Point1.Y );
+  dprintf("    Line->Point2.X = %d\n", Line->Point2.X);
+  dprintf("    Line->Point2.Y = %d\n", Line->Point2.Y);
+
+  n = Crosshair.AttachedObject.RubberbandN;
+  AttachedLine = Crosshair.AttachedObject.Rubberband;
+  while(n) {
+    dprintf("  %d attached Lines\n", n);
+
+    /*
+       Determine:
+       - point1 is the fixed point of the attached line
+       - point2 is where the attached line and line being moved join
+    */
+
+    if (AttachedLine->MovedPoint == &AttachedLine->Line->Point1)
+      {
+	point1 = &AttachedLine->Line->Point2;
+	point2 = &AttachedLine->Line->Point1;
+      }
+    else
+      {
+	point1 = &AttachedLine->Line->Point1;
+	point2 = &AttachedLine->Line->Point2;
+      }
+
+    /* work out which point of moved line to nudge */
+
+    dprintf("    MovedPoint.X   = %d\n", AttachedLine->MovedPoint->X);
+    dprintf("    MovedPoint.Y   = %d\n", AttachedLine->MovedPoint->Y);
+    dprintf("    point2->Y      = %d\n", point2->Y);
+    dprintf("    point2->X      = %d\n", point2->X);
+    dprintf("    point2->Y      = %d\n", point2->Y);
+
+    if ((point2->X == Line->Point1.X) && (point2->Y == Line->Point1.Y)) {
+      nudge = &LineOut->Point1;
+      dprintf("    nudge point1\n");
+    }
+    else {
+      dprintf("    nudge point2\n");
+      nudge = &LineOut->Point2;
+    }
+
+    /* Then adjust to preserve 45 deg angles */
+
+    nudge->Y += dx*rbsgn(point2->X - point1->X)*rbsgn(point2->Y - point1->Y);
+    nudge->X += dy*rbsgn(point2->Y - point1->Y)*rbsgn(point2->X - point1->X);
+
+    AttachedLine++;
+    n--;
+  }
+}
+
+void RestrictMovementGivenRubberBandMode(LineType *Line,
+					 Coord *dx,
+					 Coord *dy)
+{
+  /* return default when rubberband mode off */
+
+  if (!TEST_FLAG (RUBBERBANDFLAG, PCB)) {
+    return;
+  }
+
+  /* or when in rubber band mode and all directions enabled */
+
+  if (TEST_FLAG (ALLDIRECTIONSRUBBERBANDFLAG, PCB)) {
+    return;
+  }
+
+  if (IsHorizontal(Line)) *dx = 0;
+  if (IsVertical(Line)) *dy = 0;
+}
+
+static int
+LineAttachedCallback (const BoxType * b, void *cl)
+{
+  LineType *line = (LineType *) b;
+  struct AttachedInfo *info = (struct AttachedInfo *) cl;
+
+  dprintf("  LineAttachedCallback\n");
+
+  if (line == info->line) {
+    dprintf("    ourself\n");
+    return 0;
+  }
+
+  /* note we only store last attached line found, not sure how to
+     handle multiple attached lines yet */
+
+  info->nAttached++;
+  info->AttachedLine = line;
+  dprintf("    (%d,%d) - (%d, %d)\n", line->Point1.X, line->Point1.Y,
+	  line->Point2.X, line->Point2.Y);
+  return 1;
+}
+
+LineType *
+FindLineAttachedToPoint (LayerType *Layer,
+			 LineType  *Line,
+			 PointType *LinePoint)
+{
+  LineType *AttachedLine;
+  Cardinal group;
+  struct AttachedInfo info;
+  Coord t = Line->Thickness / 2;
+
+  /* lookup layergroup and check all visible lines in this group */
+  info.radius = Line->Thickness / 2;
+  info.box.X1 = LinePoint->X - t;
+  info.box.X2 = LinePoint->X + t;;
+  info.box.Y1 = LinePoint->Y - t;
+  info.box.Y2 = LinePoint->Y + t;
+  info.line = Line;
+  info.X = LinePoint->X;
+  info.Y = LinePoint->Y;
+  info.nAttached = 0;
+  group = GetLayerGroupNumberByPointer (Layer);
+
+  dprintf("FindLineAttachedToPoint\n");
+
+  GROUP_LOOP (PCB->Data, group);
+  {
+    /* check all visible lines of the group member */
+    if (layer->On)
+      {
+	info.layer = layer;
+	r_search (layer->line_tree, &info.box, NULL, LineAttachedCallback, &info);
+      }
+  }
+  END_LOOP;
+
+  dprintf("info.nAttached = %d\n", info.nAttached);
+  AttachedLine = info.AttachedLine;
+
+  if (info.nAttached) {
+
+    /* Make sure the AttachedPoint is at one end of the line (e.g. not in the
+       middle) */
+
+    if ((LinePoint->X == AttachedLine->Point1.X) &&
+	(LinePoint->Y == AttachedLine->Point1.Y))
+      {
+	return AttachedLine;
+      }
+
+    if ((LinePoint->X == AttachedLine->Point2.X) &&
+	(LinePoint->Y == AttachedLine->Point2.Y))
+      {
+	return AttachedLine;
+      }
+  }
+
+  return NULL; /* no attached line at LinePoint */
+}
+
+int PointInsidePin(PinType *Pin, Coord x, Coord y)
+{
+  float dist;
+  Coord x1,x2,y1,y2;
+  Coord t = Pin->Thickness / 2;
+
+  dprintf("  PointInsidePin\n");
+  dprintf("    (%d,%d) r = %d\n", Pin->X, Pin->Y, t);
+
+  if (TEST_FLAG (SQUAREFLAG, Pin)) {
+    dprintf("  square\n");
+
+    x1 = Pin->X - t;
+    x2 = Pin->X + t;
+    y1 = Pin->Y - t;
+    y2 = Pin->Y + t;
+
+    if ((x >= x1) && (x <= x2) &&
+        (y >= y1) && (y <= y2))
+
+      return 1;
+    else
+      return 0;
+  }
+  else {
+    dprintf("    round - ");
+
+    dist = sqrt(pow(x - Pin->X, 2.0) +
+		pow(y - Pin->Y, 2.0));
+
+    dprintf("dist %f  ", dist);
+    if (dist < t) {
+      dprintf("YES\n");
+      return 1;
+    }
+    else {
+      dprintf("NO\n");
+      return 0;
+    }
+  }
+
+  return 0;
+}
+
+int BothEndsWithinPad(PadType *Pad, LineType *Line) {
+#ifdef LATER
+    /* make sure x2 > x1 and y2 > y1 */
+
+    if (x1 > x2) {
+      tmp = x2;
+      x2 = x1;
+      x1 = tmp;
+    }
+    if (y1 > y2) {
+      tmp = y2;
+      y2 = y1;
+      y1 = tmp;
+    }
+#endif
+  return 0;
+}
+
+/*
+int PointIsInsidePin(PinType *Pin)
+{
+  struct rubber_info info;
+  Cardinal n;
+  Coord t = Pin->Thickness / 2;
+
+  info.box.X1 = Pin->X - t;
+  info.box.X2 = Pin->X + t;
+  info.box.Y1 = Pin->Y - t;
+  info.box.Y2 = Pin->Y + t;
+  info.line = NULL;
+  if (TEST_FLAG (SQUAREFLAG, Pin))
+    info.radius = 0;
+*/
diff --git a/src/rubberband.h b/src/rubberband.h
index e281f3f..837d62e 100644
--- a/src/rubberband.h
+++ b/src/rubberband.h
@@ -34,5 +34,31 @@
 
 void LookupRubberbandLines (int, void *, void *, void *);
 void LookupRatLines (int, void *, void *, void *);
+void MovePointGivenRubberBandMode(PointType *PointOut,
+			          PointType *Point,
+				  LineType *Line,
+			          Coord dx,
+			          Coord dy,
+				  int Type,
+				  int Diagonal);
+void MoveLineGivenRubberBandMode(LineType *LineOut,
+				 LineType *Line,
+				 Coord dx,
+				 Coord dy,
+				 CrosshairType CrossHair);
+int IsHorizontal(LineType *Line);
+int IsVertical(LineType *Line);
+int IsDiagonal(LineType *Line);
+void RestrictMovementGivenRubberBandMode(LineType *Line,
+					 Coord *dx,
+					 Coord *dy);
+LineType *
+FindLineAttachedToPoint (LayerType *Layer,
+			 LineType  *Line,
+			 PointType *LinePoint);
+int
+PointInsidePin(PinType *Pin, Coord x, Coord y);
+int
+BothEndsWithinPad(PadType *Pad, LineType *Line);
 
 #endif

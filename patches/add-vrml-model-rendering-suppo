Bottom: 2e1a5ae759bedf48e73b35748a1ffb7d44a6012c
Top:    c248c9466bb0c424d4772c5aad40704acb2b0e00
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-11-19 05:07:13 +0000

Add VRML model rendering support


---

diff --git a/src/Makefile.am b/src/Makefile.am
index 655cb06..7c122bd 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -186,6 +186,9 @@ GL_SRCS= \
 	hid/common/hidgl.c \
 	hid/common/hidgl.h \
 	hid/common/hidgl_package_acy_resistor.c \
+	hid/common/hidgl_package_vrml.c \
+	hid/common/hidgl_package_vrml_y.y \
+	hid/common/hidgl_package_vrml_l.l \
 	hid/common/trackball.c \
 	hid/common/trackball.h
 
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index 7c76b42..6f32a30 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -138,4 +138,7 @@ void hidgl_set_depth (float depth);
 /* hidgl_pacakge_acy_resistor.c */
 void hidgl_draw_acy_resistor (ElementType *element, float surface_depth, float board_thickness);
 
+/* hidgl_pacakge_vrml.c */
+void hidgl_draw_vrml (ElementType *element, float surface_depth, float board_thickness, char *vrml_file);
+
 #endif /* __HIDGL_INCLUDED__  */
diff --git a/src/hid/common/hidgl_package_vrml.c b/src/hid/common/hidgl_package_vrml.c
new file mode 100644
index 0000000..9091a52
--- /dev/null
+++ b/src/hid/common/hidgl_package_vrml.c
@@ -0,0 +1,435 @@
+/* $Id$ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+#include <stdbool.h>
+#include <gdk-pixbuf/gdk-pixbuf.h>
+#include "data.h"
+
+/* The Linux OpenGL ABI 1.0 spec requires that we define
+ * GL_GLEXT_PROTOTYPES before including gl.h or glx.h for extensions
+ * in order to get prototypes:
+ *   http://www.opengl.org/registry/ABI/
+ */
+#define GL_GLEXT_PROTOTYPES 1
+#include <GL/gl.h>
+
+#ifdef HAVE_LIBDMALLOC
+#include <dmalloc.h>
+#endif
+
+static void
+load_texture_from_png (char *filename)
+{
+  GError *error = NULL;
+  GdkPixbuf *pixbuf;
+  int width;
+  int height;
+  int rowstride;
+  int has_alpha;
+  int bits_per_sample;
+  int n_channels;
+  unsigned char *pixels;
+
+  pixbuf = gdk_pixbuf_new_from_file (filename, &error);
+
+  if (pixbuf == NULL) {
+    g_error ("%s", error->message);
+    g_error_free (error);
+    error = NULL;
+    return;
+  }
+
+  width = gdk_pixbuf_get_width (pixbuf);
+  height = gdk_pixbuf_get_height (pixbuf);
+  rowstride = gdk_pixbuf_get_rowstride (pixbuf);
+  has_alpha = gdk_pixbuf_get_has_alpha (pixbuf);
+  bits_per_sample = gdk_pixbuf_get_bits_per_sample (pixbuf);
+  n_channels = gdk_pixbuf_get_n_channels (pixbuf);
+  pixels = gdk_pixbuf_get_pixels (pixbuf);
+
+  g_warn_if_fail (bits_per_sample == 8);
+  g_warn_if_fail (n_channels == 4);
+  g_warn_if_fail (rowstride == width * n_channels);
+
+  glTexImage2D (GL_TEXTURE_2D, 0, GL_RGB, width, height, 0,
+                (n_channels == 4) ? GL_RGBA : GL_RGB, GL_UNSIGNED_BYTE, pixels);
+
+  g_object_unref (pixbuf);
+}
+
+
+static void invert_4x4 (float m[4][4], float out[4][4]);
+
+static GLfloat *debug_lines = NULL;
+static int no_debug_lines = 0;
+static int max_debug_lines = 0;
+
+//#define LENG 1000
+#define LENG 0.6
+#define STRIDE_FLOATS 6
+static void
+debug_basis_vector (float x,   float y,   float z,
+                    float b1x, float b1y, float b1z,
+                    float b2x, float b2y, float b2z,
+                    float b3x, float b3y, float b3z)
+{
+  int comp_count;
+  float lenb1, lenb2, lenb3;
+
+  if (no_debug_lines + 3 > max_debug_lines) {
+    max_debug_lines += 10;
+    debug_lines = realloc (debug_lines, max_debug_lines * sizeof (GLfloat) * 2 * STRIDE_FLOATS);
+  }
+
+  lenb1 = sqrt (b1x * b1x + b1y * b1y + b1z * b1z);
+  lenb2 = sqrt (b2x * b2x + b2y * b2y + b2z * b2z);
+  lenb3 = sqrt (b3x * b3x + b3y * b3y + b3z * b3z);
+  b1x /= lenb1;  b1y /= lenb1;  b1z /= lenb1;
+  b2x /= lenb2;  b2y /= lenb2;  b2z /= lenb2;
+  b3x /= lenb3;  b3y /= lenb3;  b3z /= lenb3;
+
+  comp_count = 0;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = x;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = y;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = z;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 1.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = x + b1x * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = y + b1y * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = z + b1z * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 1.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  no_debug_lines++;
+
+  comp_count = 0;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = x;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = y;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = z;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 1.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = x + b2x * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = y + b2y * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = z + b2z * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 1.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  no_debug_lines++;
+
+  comp_count = 0;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = x;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = y;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = z;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 1.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = x + b3x * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = y + b3y * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = z + b3z * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 1.;
+  no_debug_lines++;
+}
+
+static void
+debug_basis_display ()
+{
+  if (no_debug_lines == 0)
+    return;
+
+#if 1
+  glPushAttrib (GL_CURRENT_BIT);
+  glColor4f (1., 1., 1., 1.);
+  glVertexPointer (3, GL_FLOAT, STRIDE_FLOATS * sizeof (GLfloat), &debug_lines[0]);
+  glColorPointer (3, GL_FLOAT, STRIDE_FLOATS * sizeof (GLfloat), &debug_lines[3]);
+  glEnableClientState (GL_VERTEX_ARRAY);
+  glEnableClientState (GL_COLOR_ARRAY);
+  glDrawArrays (GL_LINES, 0, no_debug_lines * 2);
+  glDisableClientState (GL_COLOR_ARRAY);
+  glDisableClientState (GL_VERTEX_ARRAY);
+  glPopAttrib ();
+#endif
+
+  free (debug_lines);
+  debug_lines = NULL;
+  no_debug_lines = 0;
+  max_debug_lines = 0;
+}
+
+/* b1{x,y,z} is the basis vector along "s" texture space */
+/* b2{x,y,z} is the basis vector along "t" texture space */
+static void
+compute_light_vector (float b1x, float b1y, float b1z,
+                      float b2x, float b2y, float b2z,
+                      float *lx, float *ly, float *lz,
+                      float *hx, float *hy, float *hz,
+                      float x,   float y,   float z)
+{
+  float b3x, b3y, b3z;
+  float tb1x, tb1y, tb1z;
+  float tb2x, tb2y, tb2z;
+  float tb3x, tb3y, tb3z;
+  float mvm[16]; /* NB: TRANSPOSED IN MEMORY */
+  /* NB: light_direction is a vector _TOWARDS_ the light source position */
+//  float light_direction[] = {-0.5, 1., -1.}; /* XXX: HARDCODEED! */
+  float light_direction[] = {0.0, 0.0, 1.0}; /* XXX: HARDCODEED! */
+  float half_direction[3];
+  float texspace_to_eye[4][4];
+  float eye_to_texspace[4][4];
+  float lenb1, lenb2, lenb3;
+  float len_half;
+  float len_light;
+
+  /* Normalise the light vector */
+  len_light = sqrt (light_direction[0] * light_direction[0] +
+                    light_direction[1] * light_direction[1] +
+                    light_direction[2] * light_direction[2]);
+  light_direction[0] /= len_light;
+  light_direction[1] /= len_light;
+  light_direction[2] /= len_light;
+
+  /* Sum with the unit vector towards the viewer */
+  half_direction[0] = light_direction[0] + 0.;
+  half_direction[1] = light_direction[1] + 0.;
+  half_direction[2] = light_direction[2] + 1.;
+
+  /* XXX: Should cache this ourselves */
+  glGetFloatv (GL_MODELVIEW_MATRIX, (GLfloat *)mvm);
+
+  if (0)
+    debug_basis_vector ((mvm[0] * x + mvm[4] * y + mvm[ 8] * z + mvm[12]) / mvm[15],
+                        (mvm[1] * x + mvm[5] * y + mvm[ 9] * z + mvm[13]) / mvm[15],
+                        (mvm[2] * x + mvm[6] * y + mvm[10] * z + mvm[14]) / mvm[15],
+                        0., 0., 1.,
+                        light_direction[0], light_direction[1], light_direction[2],
+                        half_direction[0], half_direction[1], half_direction[2]);
+
+  /* Third basis vector is the cross product of tb1 and tb2 */
+  b3x = (b2y * b1z - b2z * b1y);
+  b3y = (b2z * b1x - b2x * b1z);
+  b3z = (b2x * b1y - b2y * b1x);
+
+  /* Transform the S, T texture space bases into eye coordinates */
+  tb1x = mvm[0] * b1x + mvm[4] * b1y + mvm[ 8] * b1z;
+  tb1y = mvm[1] * b1x + mvm[5] * b1y + mvm[ 9] * b1z;
+  tb1z = mvm[2] * b1x + mvm[6] * b1y + mvm[10] * b1z;
+
+  tb2x = mvm[0] * b2x + mvm[4] * b2y + mvm[ 8] * b2z;
+  tb2y = mvm[1] * b2x + mvm[5] * b2y + mvm[ 9] * b2z;
+  tb2z = mvm[2] * b2x + mvm[6] * b2y + mvm[10] * b2z;
+
+  tb3x = mvm[0] * b3x + mvm[4] * b3y + mvm[ 8] * b3z;
+  tb3y = mvm[1] * b3x + mvm[5] * b3y + mvm[ 9] * b3z;
+  tb3z = mvm[2] * b3x + mvm[6] * b3y + mvm[10] * b3z;
+
+#if 1
+  /* Normalise tb1, tb2 and tb3 */
+  lenb1 = sqrt (tb1x * tb1x + tb1y * tb1y + tb1z * tb1z);
+  lenb2 = sqrt (tb2x * tb2x + tb2y * tb2y + tb2z * tb2z);
+  lenb3 = sqrt (tb3x * tb3x + tb3y * tb3y + tb3z * tb3z);
+  tb1x /= lenb1;  tb1y /= lenb1;  tb1z /= lenb1;
+  tb2x /= lenb2;  tb2y /= lenb2;  tb2z /= lenb2;
+  tb3x /= lenb3;  tb3y /= lenb3;  tb3z /= lenb3;
+#endif
+
+  if (0)
+    debug_basis_vector ((mvm[0] * x + mvm[4] * y + mvm[ 8] * z + mvm[12]) / mvm[15],
+                        (mvm[1] * x + mvm[5] * y + mvm[ 9] * z + mvm[13]) / mvm[15],
+                        (mvm[2] * x + mvm[6] * y + mvm[10] * z + mvm[14]) / mvm[15],
+                         tb1x, tb1y, tb1z, tb2x, tb2y, tb2z, tb3x, tb3y, tb3z);
+
+  texspace_to_eye[0][0] = tb1x; texspace_to_eye[0][1] = tb2x; texspace_to_eye[0][2] = tb3x;  texspace_to_eye[0][3] = 0.0;
+  texspace_to_eye[1][0] = tb1y; texspace_to_eye[1][1] = tb2y; texspace_to_eye[1][2] = tb3y;  texspace_to_eye[1][3] = 0.0;
+  texspace_to_eye[2][0] = tb1z; texspace_to_eye[2][1] = tb2z; texspace_to_eye[2][2] = tb3z;  texspace_to_eye[2][3] = 0.0;
+  texspace_to_eye[3][0] = 0.0;  texspace_to_eye[3][1] = 0.0;  texspace_to_eye[3][2] = 0.0;   texspace_to_eye[3][3] = 1.0;
+
+  invert_4x4 (texspace_to_eye, eye_to_texspace);
+
+  /* light_direction is in eye space, we need to transform this into texture space */
+  *lx = eye_to_texspace[0][0] * light_direction[0] +
+        eye_to_texspace[0][1] * light_direction[1] +
+        eye_to_texspace[0][2] * light_direction[2];
+  *ly = eye_to_texspace[1][0] * light_direction[0] +
+        eye_to_texspace[1][1] * light_direction[1] +
+        eye_to_texspace[1][2] * light_direction[2];
+  *lz = eye_to_texspace[2][0] * light_direction[0] +
+        eye_to_texspace[2][1] * light_direction[1] +
+        eye_to_texspace[2][2] * light_direction[2];
+
+  /* half_direction is in eye space, we need to transform this into texture space */
+  *hx = eye_to_texspace[0][0] * half_direction[0] +
+        eye_to_texspace[0][1] * half_direction[1] +
+        eye_to_texspace[0][2] * half_direction[2];
+  *hy = eye_to_texspace[1][0] * half_direction[0] +
+        eye_to_texspace[1][1] * half_direction[1] +
+        eye_to_texspace[1][2] * half_direction[2];
+  *hz = eye_to_texspace[2][0] * half_direction[0] +
+        eye_to_texspace[2][1] * half_direction[1] +
+        eye_to_texspace[2][2] * half_direction[2];
+
+  {
+    len_light = sqrt (*lx * *lx + *ly * *ly + *lz * *lz);
+    *lx /= len_light;
+    *ly /= len_light;
+    *lz /= len_light;
+
+    *lx = *lx / 2. + 0.5;
+    *ly = *ly / 2. + 0.5;
+    *lz = *lz / 2. + 0.5;
+
+    len_half = sqrt (*hx * *hx + *hy * *hy + *hz * *hz);
+    *hx /= len_half;
+    *hy /= len_half;
+    *hz /= len_half;
+
+    *hx = *hx / 2. + 0.5;
+    *hy = *hy / 2. + 0.5;
+    *hz = *hz / 2. + 0.5;
+  }
+}
+
+static void
+emit_vertex (float x,   float y,   float z,
+             float b1x, float b1y, float b1z,
+             float b2x, float b2y, float b2z,
+             float tex0_s, float tex1_s, float tex1_t)
+{
+  GLfloat lx, ly, lz;
+  GLfloat hx, hy, hz;
+  compute_light_vector (b1x, b1y, b1z, b2x, b2y, b2z, &lx, &ly, &lz, &hx, &hy, &hz, x, y, z);
+  glColor3f (lx, ly, lz);
+  glMultiTexCoord1f (GL_TEXTURE0, tex0_s);
+  glMultiTexCoord2f (GL_TEXTURE1, tex1_s, tex1_t);
+  glMultiTexCoord3f (GL_TEXTURE2, hx, hy, hz);
+  glVertex3f (x, y, z);
+}
+
+enum geom_pos {
+  FIRST,
+  MIDDLE,
+  LAST
+};
+
+static void
+emit_pair (float ang_edge1, float cos_edge1, float sin_edge1,
+           float ang_edge2, float cos_edge2, float sin_edge2,
+           float prev_r, float prev_z,
+           float      r, float      z,
+           float next_r, float next_z,
+           float tex0_s, float resistor_width,
+           enum geom_pos pos)
+{
+  int repeat;
+
+  tex0_s = z / resistor_width + 0.5;
+
+  for (repeat = 0; repeat < ((pos == FIRST) ? 2 : 1); repeat++)
+    emit_vertex (r * cos_edge1, r * sin_edge1, z,
+                 sin_edge1, -cos_edge1, 0,
+                 cos_edge1 * (next_r - prev_r) / 2., sin_edge1 * (next_r - prev_r) / 2., (next_z - prev_z) / 2.,
+                 tex0_s, ang_edge1 / 2. / M_PI, tex0_s);
+
+  for (repeat = 0; repeat < ((pos == LAST) ? 2 : 1); repeat++)
+    emit_vertex (r * cos_edge2, r * sin_edge2, z,
+                 sin_edge2, -cos_edge2, 0,
+                 cos_edge2 * (next_r - prev_r) / 2., sin_edge2 * (next_r - prev_r) / 2., (next_z - prev_z) / 2.,
+                 tex0_s, ang_edge2 / 2. / M_PI, tex0_s);
+}
+
+
+#define NUM_RESISTOR_STRIPS 100
+#define NUM_PIN_RINGS 15
+#define MIL_TO_INTERNAL 100.
+
+extern int hidgl_parse_vrml (char *filename);
+
+void
+hidgl_draw_vrml (ElementType *element, float surface_depth, float board_thickness, char *vrml_file)
+{
+  printf ("hidgl_draw_vrml\n");
+  hidgl_parse_vrml ("test.wrl");
+  return;
+}
+
+static float
+determinant_4x4 (float m[4][4])
+{
+  float det;
+  det = m[0][3] * m[1][2] * m[2][1] * m[3][0]-m[0][2] * m[1][3] * m[2][1] * m[3][0] -
+        m[0][3] * m[1][1] * m[2][2] * m[3][0]+m[0][1] * m[1][3] * m[2][2] * m[3][0] +
+        m[0][2] * m[1][1] * m[2][3] * m[3][0]-m[0][1] * m[1][2] * m[2][3] * m[3][0] -
+        m[0][3] * m[1][2] * m[2][0] * m[3][1]+m[0][2] * m[1][3] * m[2][0] * m[3][1] +
+        m[0][3] * m[1][0] * m[2][2] * m[3][1]-m[0][0] * m[1][3] * m[2][2] * m[3][1] -
+        m[0][2] * m[1][0] * m[2][3] * m[3][1]+m[0][0] * m[1][2] * m[2][3] * m[3][1] +
+        m[0][3] * m[1][1] * m[2][0] * m[3][2]-m[0][1] * m[1][3] * m[2][0] * m[3][2] -
+        m[0][3] * m[1][0] * m[2][1] * m[3][2]+m[0][0] * m[1][3] * m[2][1] * m[3][2] +
+        m[0][1] * m[1][0] * m[2][3] * m[3][2]-m[0][0] * m[1][1] * m[2][3] * m[3][2] -
+        m[0][2] * m[1][1] * m[2][0] * m[3][3]+m[0][1] * m[1][2] * m[2][0] * m[3][3] +
+        m[0][2] * m[1][0] * m[2][1] * m[3][3]-m[0][0] * m[1][2] * m[2][1] * m[3][3] -
+        m[0][1] * m[1][0] * m[2][2] * m[3][3]+m[0][0] * m[1][1] * m[2][2] * m[3][3];
+   return det;
+}
+
+static void
+invert_4x4 (float m[4][4], float out[4][4])
+{
+  float scale = 1 / determinant_4x4 (m);
+
+  out[0][0] = (m[1][2] * m[2][3] * m[3][1] - m[1][3] * m[2][2] * m[3][1] +
+               m[1][3] * m[2][1] * m[3][2] - m[1][1] * m[2][3] * m[3][2] -
+               m[1][2] * m[2][1] * m[3][3] + m[1][1] * m[2][2] * m[3][3]) * scale;
+  out[0][1] = (m[0][3] * m[2][2] * m[3][1] - m[0][2] * m[2][3] * m[3][1] -
+               m[0][3] * m[2][1] * m[3][2] + m[0][1] * m[2][3] * m[3][2] +
+               m[0][2] * m[2][1] * m[3][3] - m[0][1] * m[2][2] * m[3][3]) * scale;
+  out[0][2] = (m[0][2] * m[1][3] * m[3][1] - m[0][3] * m[1][2] * m[3][1] +
+               m[0][3] * m[1][1] * m[3][2] - m[0][1] * m[1][3] * m[3][2] -
+               m[0][2] * m[1][1] * m[3][3] + m[0][1] * m[1][2] * m[3][3]) * scale;
+  out[0][3] = (m[0][3] * m[1][2] * m[2][1] - m[0][2] * m[1][3] * m[2][1] -
+               m[0][3] * m[1][1] * m[2][2] + m[0][1] * m[1][3] * m[2][2] +
+               m[0][2] * m[1][1] * m[2][3] - m[0][1] * m[1][2] * m[2][3]) * scale;
+  out[1][0] = (m[1][3] * m[2][2] * m[3][0] - m[1][2] * m[2][3] * m[3][0] -
+               m[1][3] * m[2][0] * m[3][2] + m[1][0] * m[2][3] * m[3][2] +
+               m[1][2] * m[2][0] * m[3][3] - m[1][0] * m[2][2] * m[3][3]) * scale;
+  out[1][1] = (m[0][2] * m[2][3] * m[3][0] - m[0][3] * m[2][2] * m[3][0] +
+               m[0][3] * m[2][0] * m[3][2] - m[0][0] * m[2][3] * m[3][2] -
+               m[0][2] * m[2][0] * m[3][3] + m[0][0] * m[2][2] * m[3][3]) * scale;
+  out[1][2] = (m[0][3] * m[1][2] * m[3][0] - m[0][2] * m[1][3] * m[3][0] -
+               m[0][3] * m[1][0] * m[3][2] + m[0][0] * m[1][3] * m[3][2] +
+               m[0][2] * m[1][0] * m[3][3] - m[0][0] * m[1][2] * m[3][3]) * scale;
+  out[1][3] = (m[0][2] * m[1][3] * m[2][0] - m[0][3] * m[1][2] * m[2][0] +
+               m[0][3] * m[1][0] * m[2][2] - m[0][0] * m[1][3] * m[2][2] -
+               m[0][2] * m[1][0] * m[2][3] + m[0][0] * m[1][2] * m[2][3]) * scale;
+  out[2][0] = (m[1][1] * m[2][3] * m[3][0] - m[1][3] * m[2][1] * m[3][0] +
+               m[1][3] * m[2][0] * m[3][1] - m[1][0] * m[2][3] * m[3][1] -
+               m[1][1] * m[2][0] * m[3][3] + m[1][0] * m[2][1] * m[3][3]) * scale;
+  out[2][1] = (m[0][3] * m[2][1] * m[3][0] - m[0][1] * m[2][3] * m[3][0] -
+               m[0][3] * m[2][0] * m[3][1] + m[0][0] * m[2][3] * m[3][1] +
+               m[0][1] * m[2][0] * m[3][3] - m[0][0] * m[2][1] * m[3][3]) * scale;
+  out[2][2] = (m[0][1] * m[1][3] * m[3][0] - m[0][3] * m[1][1] * m[3][0] +
+               m[0][3] * m[1][0] * m[3][1] - m[0][0] * m[1][3] * m[3][1] -
+               m[0][1] * m[1][0] * m[3][3] + m[0][0] * m[1][1] * m[3][3]) * scale;
+  out[2][3] = (m[0][3] * m[1][1] * m[2][0] - m[0][1] * m[1][3] * m[2][0] -
+               m[0][3] * m[1][0] * m[2][1] + m[0][0] * m[1][3] * m[2][1] +
+               m[0][1] * m[1][0] * m[2][3] - m[0][0] * m[1][1] * m[2][3]) * scale;
+  out[3][0] = (m[1][2] * m[2][1] * m[3][0] - m[1][1] * m[2][2] * m[3][0] -
+               m[1][2] * m[2][0] * m[3][1] + m[1][0] * m[2][2] * m[3][1] +
+               m[1][1] * m[2][0] * m[3][2] - m[1][0] * m[2][1] * m[3][2]) * scale;
+  out[3][1] = (m[0][1] * m[2][2] * m[3][0] - m[0][2] * m[2][1] * m[3][0] +
+               m[0][2] * m[2][0] * m[3][1] - m[0][0] * m[2][2] * m[3][1] -
+               m[0][1] * m[2][0] * m[3][2] + m[0][0] * m[2][1] * m[3][2]) * scale;
+  out[3][2] = (m[0][2] * m[1][1] * m[3][0] - m[0][1] * m[1][2] * m[3][0] -
+               m[0][2] * m[1][0] * m[3][1] + m[0][0] * m[1][2] * m[3][1] +
+               m[0][1] * m[1][0] * m[3][2] - m[0][0] * m[1][1] * m[3][2]) * scale;
+  out[3][3] = (m[0][1] * m[1][2] * m[2][0] - m[0][2] * m[1][1] * m[2][0] +
+               m[0][2] * m[1][0] * m[2][1] - m[0][0] * m[1][2] * m[2][1] -
+               m[0][1] * m[1][0] * m[2][2] + m[0][0] * m[1][1] * m[2][2]) * scale;
+}
diff --git a/src/hid/common/hidgl_package_vrml_l.l b/src/hid/common/hidgl_package_vrml_l.l
new file mode 100644
index 0000000..8ffe2b4
--- /dev/null
+++ b/src/hid/common/hidgl_package_vrml_l.l
@@ -0,0 +1,214 @@
+%{
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Contact addresses for paper mail and Email:
+ *  Thomas Nau, Schlehenweg 15, 88471 Baustetten, Germany
+ *  Thomas.Nau@rz.uni-ulm.de
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <ctype.h>
+
+#if defined(_POSIX_SOURCE) || defined(_HPUX_SOURCE)
+#include <unistd.h>
+#endif
+
+#include "global.h"
+
+#ifdef HAVE_LIBDMALLOC
+# include <dmalloc.h> /* see http://dmalloc.com */
+#endif
+
+
+#include "global.h"
+#include "crosshair.h"
+#include "data.h"
+#include "error.h"
+#include "file.h"
+#include "mymem.h"
+#include "misc.h"
+#include "strflags.h"
+#include "hidgl_package_vrml_y.h"
+
+/* ---------------------------------------------------------------------------
+ * some shared parser identifiers
+ */
+#ifdef FLEX_SCANNER
+int vrml_yylineno;  /* linenumber */
+#define yyunput ATTRIBUTE_UNUSED yyunput
+#endif
+
+char *vrml_yyfilename; /* in this file */
+
+/* ---------------------------------------------------------------------------
+ * an external prototype
+ */
+extern int	vrml_yyparse(void);
+
+
+%}
+
+IDFIRSTCHAR		[^0-9 "#'+,-.\[\\\]{}]
+IDRESTCHARS		[^ "#',.\[\\\]{}]
+FLOAT			([+/-]?((([0-9]+(\.)?)|([0-9]*\.[0-9]+))([eE][+\-]?[0-9]+)?))
+DOUBLE			([+/-]?((([0-9]+(\.)?)|([0-9]*\.[0-9]+))([eE][+\-]?[0-9]+)?))
+INT32			([+\-]?(([0-9]+)|(0[xX][0-9a-fA-F]+)))
+STRING			".*" ... double-quotes must be \", backslashes must be \\...
+
+DECIMAL                 -?[1-9][0-9]*|0
+STRINGCHAR              ([^"\n\r\\]|\\.)
+
+%option prefix="vrml_yy"
+%option outfile="lex.yy.c"
+%option yylineno
+
+%%
+
+DEF		{ return T_DEF; }
+EXTERNPROTO	{ return T_EXTERNPROTO; }
+FALSE		{ return T_FALSE; }
+IS		{ return T_IS; }
+NULL		{ return T_NULL; }
+PROTO		{ return T_PROTO; }
+ROUTE		{ return T_ROUTE; }
+TO		{ return T_TO; }
+TRUE		{ return T_TRUE; }
+USE		{ return T_USE; }
+eventIn		{ return T_EVENTIN; }
+eventOut	{ return T_EVENTOUT; }
+exposedField	{ return T_EXPOSEDFIELD; }
+field		{ return T_FIELD; }
+
+Script		{ return T_SCRIPT; }
+
+{DOUBLE}		{
+					vrml_yylval.floating = strtod (vrml_yytext, NULL);
+					return DOUBLE;
+			}
+
+
+\"{STRINGCHAR}*\"	{
+						char	*p1, *p2;
+
+							/* return NULL on empty string */
+						if (vrml_yyleng == 2)
+						{
+							vrml_yylval.string = NULL;
+							return(STRING);
+						}
+
+							/* allocate memory and copy string;
+							 * stringlength is counted and copied without
+							 * leading and trailing '"'
+							 */
+						vrml_yyleng -= 2;
+						vrml_yylval.string = MyCalloc(vrml_yyleng+1, sizeof(char), "LEX");
+						p1 = (char *) (vrml_yytext +1);
+						p2 = vrml_yylval.string;
+						while(vrml_yyleng--)
+						{
+								/* check for special character */
+							if (*p1 == '\\')
+							{
+								vrml_yyleng--;
+								p1++;
+
+							}
+							*p2++ = *p1++;
+						}
+						*p2 = '\0';
+						return(STRING);
+					}
+#.*					{}
+[ \t,]+				{}
+[\n]				{
+#ifndef FLEX_SCANNER
+						vrml_yylineno++;
+#endif
+					}
+[\r]				{}
+.					{ return(*vrml_yytext); }
+
+%%
+
+extern int vrml_yydebug;
+
+/* ---------------------------------------------------------------------------
+ * sets up the preprocessor command
+ */
+static int Parse(char *filename)
+{
+  int retval;
+#ifdef FLEX_SCANNER
+  static	bool	firsttime = true;
+#endif
+
+  yyin = fopen (filename, "r");
+  if (!yyin)
+    return 1;
+
+#ifdef FLEX_SCANNER
+  /* reset parser if not called the first time */
+  if (!firsttime)
+    vrml_yyrestart(yyin);
+  firsttime = false;
+#endif
+
+  /* init linenumber and filename for vrml_yyerror() */
+  vrml_yylineno = 1;
+  vrml_yyfilename = filename;
+
+  /* We need to save the data temporarily because lex-yacc are able
+   * to break the application if the input file has an illegal format.
+   * It's not necessary if the system supports the call of functions
+   * on termination.
+   */
+
+  vrml_yydebug = 1;
+  printf ("Entering parser\n");
+#if !defined(HAS_ATEXIT) && !defined(HAS_ON_EXIT)
+  if (PCB)
+    SaveTMPData();
+  retval = vrml_yyparse();
+  RemoveTMPData();
+#else
+  retval = vrml_yyparse();
+#endif
+  printf ("Leaving parser\n");
+
+  /* clean up parse buffer */
+  vrml_yy_delete_buffer (YY_CURRENT_BUFFER);
+
+  return (fclose (vrml_yyin) ? 1 : retval);
+}
+
+/* ---------------------------------------------------------------------------
+ * initializes LEX and calls parser for a single element file
+ */
+int hidgl_parse_vrml (char *filename)
+{
+  return (Parse (filename));
+}
diff --git a/src/hid/common/hidgl_package_vrml_y.y b/src/hid/common/hidgl_package_vrml_y.y
new file mode 100644
index 0000000..8d15de4
--- /dev/null
+++ b/src/hid/common/hidgl_package_vrml_y.y
@@ -0,0 +1,442 @@
+%{
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Contact addresses for paper mail and Email:
+ *  Thomas Nau, Schlehenweg 15, 88471 Baustetten, Germany
+ *  Thomas.Nau@rz.uni-ulm.de
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "global.h"
+#include "create.h"
+#include "data.h"
+#include "error.h"
+#include "file.h"
+#include "mymem.h"
+#include "misc.h"
+#include "parse_l.h"
+#include "polygon.h"
+#include "remove.h"
+#include "rtree.h"
+#include "strflags.h"
+#include "thermal.h"
+
+#ifdef HAVE_LIBDMALLOC
+# include <dmalloc.h> /* see http://dmalloc.com */
+#endif
+
+#define YYDEBUG 1
+
+int vrml_yyerror(const char *s);
+extern int vrml_yylex();
+extern int vrml_yylineno;
+extern char *vrml_yyfilename;
+
+%}
+
+%name-prefix="vrml_yy"
+
+%union									/* define YYSTACK type */
+{
+	int		number;
+	double		floating;
+	char		*string;
+	FlagType	flagtype;
+}
+
+%token T_DEF
+%token T_EXTERNPROTO
+%token T_FALSE
+%token T_IS
+%token T_NULL
+%token T_PROTO
+%token T_ROUTE
+%token T_TO
+%token T_TRUE
+%token T_USE
+%token T_EVENTIN
+%token T_EVENTOUT
+%token T_EXPOSEDFIELD
+%token T_FIELD
+
+%token T_SCRIPT
+
+%token MFColor
+%token MFFloat
+%token MFInt32
+%token MFNode
+%token MFRotation
+%token MFString
+%token MFTime
+%token MFVec2f
+%token MFVec3f
+%token SFBool
+%token SFColor
+%token SFFloat
+%token SFImage
+%token SFInt32
+%token SFNode
+%token SFRotation
+%token SFString
+%token SFTime
+%token SFVec2f
+%token SFVec3f
+
+%token T_ID
+%token T_FIELDTYPE
+
+%token <floating>      FLOAT
+%token <floating>      DOUBLE
+%token <number>        INT32
+
+%token <string>        STRING
+%token <string>        IDFIRSTCHAR
+%token <string>        IDRESTCHARS
+
+%%
+
+/* General VRML stuff */
+
+parse				: vrmlScene
+				| { printf ("HELLO\n"); }
+				| error { YYABORT; }
+
+vrmlScene			: statements
+				;
+
+statements			: statement
+				| statement statements
+				| empty
+				;
+
+statement			: nodeStatement
+				| protoStatement
+				| routeStatement
+				;
+
+nodeStatement			: node
+				| T_DEF nodeNameId { printf ("Hello world\n");} node
+				| T_USE nodeNameId
+				;
+
+rootNodeStatement		: node
+				| T_DEF nodeNameId node
+				;
+
+protoStatement			: proto
+				| externproto
+				;
+
+protoStatements			: protoStatement
+				| protoStatement protoStatements
+				| empty
+				;
+
+proto				: T_PROTO nodeTypeId '[' interfaceDeclarations ']' '{' protoBody '}'
+				;
+
+protoBody			: protoStatements rootNodeStatement statements
+				;
+
+interfaceDeclarations		: interfaceDeclaration
+				| interfaceDeclaration interfaceDeclarations
+				| empty
+				;
+
+restrictedInterfaceDeclaration	: T_EVENTIN fieldType eventInId
+				| T_EVENTOUT fieldType eventOutId
+				| T_FIELD fieldType fieldId fieldValue
+				;
+
+interfaceDeclaration		: restrictedInterfaceDeclaration
+				| T_EXPOSEDFIELD fieldType fieldId fieldValue
+				;
+
+externproto			: T_EXTERNPROTO nodeTypeId '[' externInterfaceDeclarations ']' URLList
+				;
+
+externInterfaceDeclarations	: externInterfaceDeclaration
+				| externInterfaceDeclaration externInterfaceDeclarations
+				| empty
+				;
+
+externInterfaceDeclaration	: T_EVENTIN fieldType eventInId
+				| T_EVENTOUT fieldType eventOutId
+				| T_FIELD fieldType fieldId
+				| T_EXPOSEDFIELD fieldType fieldId
+				;
+
+routeStatement			: T_ROUTE nodeNameId '.' eventOutId T_TO nodeNameId '.' eventInId
+				;
+
+URLList				: mfstringValue
+				;
+
+empty				:
+				;
+
+
+/* NODES */
+
+node				: nodeTypeId '{' nodeBody '}'
+				| T_SCRIPT '{' scriptBody '}'
+				;
+
+nodeBody			: nodeBodyElement
+				| nodeBodyElement nodeBody
+				| empty
+				;
+
+scriptBody			: scriptBodyElement
+				| scriptBodyElement scriptBody
+				| empty
+				;
+
+scriptBodyElement		: nodeBodyElement
+				| restrictedInterfaceDeclaration
+				| T_EVENTIN fieldType eventInId T_IS eventInId
+				| T_EVENTOUT fieldType eventOutId T_IS eventOutId
+				| T_FIELD fieldType fieldId T_IS fieldId
+				;
+
+nodeBodyElement			: fieldId fieldValue
+				| fieldId T_IS fieldId
+				| eventInId T_IS eventInId
+				| eventOutId T_IS eventOutId
+				| routeStatement
+				| protoStatement
+				;
+
+nodeNameId			: Id
+				;
+
+nodeTypeId			: Id
+				;
+
+fieldId				: Id
+				;
+
+eventInId			: Id
+				;
+
+eventOutId			: Id
+				;
+
+Id				: IDFIRSTCHAR
+				| IDFIRSTCHAR IDRESTCHARS
+				;
+
+/* FIELDS */
+
+fieldType			: MFColor
+				| MFFloat
+				| MFInt32
+				| MFNode
+				| MFRotation
+				| MFString
+				| MFTime
+				| MFVec2f
+				| MFVec3f
+				| SFBool
+				| SFColor
+				| SFFloat
+				| SFImage
+				| SFInt32
+				| SFNode
+				| SFRotation
+				| SFString
+				| SFTime
+				| SFVec2f
+				| SFVec3f
+				;
+
+fieldValue			:
+				| sfboolValue
+				| sfcolorValue
+				| sffloatValue
+				| sfimageValue
+				| sfint32Value
+				| sfnodeValue
+				| sfrotationValue
+				| sfstringValue
+				| sftimeValue
+				| sfvec2fValue
+				| sfvec3fValue
+				| mfcolorValue
+				| mffloatValue
+				| mfint32Value
+				| mfnodeValue
+				| mfrotationValue
+				| mfstringValue
+				| mftimeValue
+				| mfvec2fValue
+				| mfvec3fValue
+				;
+
+sfboolValue			: T_TRUE
+				| T_FALSE
+				;
+
+sfcolorValue			: FLOAT FLOAT FLOAT
+				;
+
+sffloatValue			: FLOAT
+				;
+
+sfimageValue			: image_data
+				;
+
+image_data			: INT32
+				| image_data INT32
+				;
+
+sfint32Value			: INT32
+				;
+
+sfnodeValue			: nodeStatement
+				| T_NULL
+				;
+
+sfrotationValue			: FLOAT FLOAT FLOAT FLOAT
+				;
+
+sfstringValue			: string
+				;
+
+string				: STRING
+				;
+
+sftimeValue			: double
+				;
+
+double				: DOUBLE
+				;
+
+mftimeValue			: sftimeValue
+				| '[' ']'
+				| '[' sftimeValues ']'
+				;
+
+sftimeValues			: sftimeValue
+				| sftimeValue sftimeValues
+				;
+
+sfvec2fValue			: FLOAT FLOAT
+				;
+
+sfvec3fValue			: FLOAT FLOAT FLOAT
+				;
+
+mfcolorValue			: sfcolorValue
+				| '[' ']'
+				| '[' sfcolorValues ']'
+				;
+
+sfcolorValues			: sfcolorValue
+				| sfcolorValue sfcolorValues
+				;
+
+mffloatValue			: sffloatValue
+				| '[' ']'
+				| '[' sffloatValues ']'
+				;
+
+sffloatValues			: sffloatValue
+				| sffloatValue sffloatValues
+				;
+
+mfint32Value			: sfint32Value
+				| '[' ']'
+				| '[' sfint32Values ']'
+				;
+
+sfint32Values			: sfint32Value
+				| sfint32Value sfint32Values
+				;
+
+mfnodeValue			: nodeStatement
+				| '[' ']'
+				| '[' nodeStatements ']'
+				;
+
+nodeStatements			: nodeStatement
+				| nodeStatement nodeStatements
+				;
+
+mfrotationValue			: sfrotationValue
+				| '[' ']'
+				| '[' sfrotationValues ']'
+				;
+
+sfrotationValues		: sfrotationValue
+				| sfrotationValue sfrotationValues
+				;
+
+mfstringValue			: sfstringValue
+				| '[' ']'
+				| '[' sfstringValues ']'
+				;
+
+sfstringValues			: sfstringValue
+				| sfstringValue sfstringValues
+				;
+
+mfvec2fValue			: sfvec2fValue
+				| '[' ']'
+				| '[' sfvec2fValues ']'
+				;
+
+sfvec2fValues			: sfvec2fValue
+				| sfvec2fValue sfvec2fValues
+				;
+
+mfvec3fValue			: sfvec3fValue
+				| '[' ']'
+				| '[' sfvec3fValues ']'
+				;
+
+sfvec3fValues			: sfvec3fValue
+				| sfvec3fValue sfvec3fValues
+				;
+
+
+%%
+
+/* ---------------------------------------------------------------------------
+ * error routine called by parser library
+ */
+int vrml_yyerror(s)
+const char *s;
+{
+	Message("ERROR parsing file (%s)\n"
+		"    line number: %i\n"
+		"    description: '%s'\n",
+		vrml_yyfilename, vrml_yylineno, s);
+	return(0);
+}
+
+int vrml_yywrap()
+{
+  return 1;
+}
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index cabe705..73197ef 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -1692,6 +1692,11 @@ frontE_package_callback (const BoxType * b, void *cl)
         int layer_group = FRONT (element) ? 0 : max_copper_layer - 1; /* XXX: FIXME */
         hidgl_draw_acy_resistor (element, compute_depth (layer_group), BOARD_THICKNESS);
       }
+
+      if (strcmp (element->Name[DESCRIPTION_INDEX].TextString, "VRML_TEST") == 0) {
+        int layer_group = FRONT (element) ? 0 : max_copper_layer - 1; /* XXX: FIXME */
+        hidgl_draw_vrml (element, compute_depth (layer_group), BOARD_THICKNESS, "dummy_filename.wrl");
+      }
     }
   return 1;
 }

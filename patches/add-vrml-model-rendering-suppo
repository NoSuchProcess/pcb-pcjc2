Bottom: c4b4cd275b201c3ea9f4d1c5a0d009759cc6794f
Top:    8014ab00da11b4e8f475a4425148bee042d907ca
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-11-19 05:07:13 +0000

Add VRML model rendering support


---

diff --git a/src/Makefile.am b/src/Makefile.am
index 6b83665..71e3d0c 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -185,9 +185,14 @@ LIBGTK_GL_SRCS= \
 GL_SRCS= \
 	hid/common/hidgl.c \
 	hid/common/hidgl.h \
+	hid/common/hidgl_material.c \
+	hid/common/hidgl_material.h \
+	hid/common/hidgl_package_acy_resistor.c \
+	hid/common/hidgl_package_vrml.c \
+	hid/common/hidgl_package_vrml_y.y \
+	hid/common/hidgl_package_vrml_l.l \
 	hid/common/hidgl_shaders.c \
 	hid/common/hidgl_shaders.h \
-	hid/common/hidgl_package_acy_resistor.c \
 	hid/common/trackball.c \
 	hid/common/trackball.h
 
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index 7c76b42..834f606 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -23,6 +23,8 @@
 #ifndef __HIDGL_INCLUDED__
 #define __HIDGL_INCLUDED__
 
+#include "hidgl_shaders.h"
+
 #define TRIANGLE_ARRAY_SIZE 30000
 typedef struct {
   GLfloat *triangle_array;
@@ -39,6 +41,9 @@ typedef struct {
 extern triangle_buffer buffer;
 extern float global_depth;
 
+extern hidgl_shader *circular_program;
+extern hidgl_shader *resistor_program;
+
 void hidgl_in_context (bool is_in_context);
 void hidgl_init_triangle_array (triangle_buffer *buffer);
 void hidgl_finish_triangle_array (triangle_buffer *buffer);
@@ -138,4 +143,7 @@ void hidgl_set_depth (float depth);
 /* hidgl_pacakge_acy_resistor.c */
 void hidgl_draw_acy_resistor (ElementType *element, float surface_depth, float board_thickness);
 
+/* hidgl_pacakge_vrml.c */
+void hidgl_draw_vrml (ElementType *element, float surface_depth, float board_thickness, char *vrml_file);
+
 #endif /* __HIDGL_INCLUDED__  */
diff --git a/src/hid/common/hidgl_package_acy_resistor.c b/src/hid/common/hidgl_package_acy_resistor.c
index 17eb17c..0fd4ffc 100644
--- a/src/hid/common/hidgl_package_acy_resistor.c
+++ b/src/hid/common/hidgl_package_acy_resistor.c
@@ -19,6 +19,9 @@
 #define GL_GLEXT_PROTOTYPES 1
 #include <GL/gl.h>
 
+#include "hidgl.h"
+#include "hidgl_material.h"
+
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
 #endif
@@ -614,8 +617,8 @@ hidgl_draw_acy_resistor (ElementType *element, float surface_depth, float board_
 
   float center_x, center_y;
   float angle;
-  GLfloat resistor_body_color[] = {0.31, 0.47, 0.64};
-  GLfloat resistor_pin_color[] = {0.82, 0.82, 0.82};
+  GLfloat resistor_body_color[] = {0.31, 0.47, 0.64, 1.0};
+  GLfloat resistor_pin_color[] = {0.55, 0.55, 0.55, 1.0};
 
   int strip;
   int no_strips = NUM_RESISTOR_STRIPS;
@@ -630,7 +633,6 @@ hidgl_draw_acy_resistor (ElementType *element, float surface_depth, float board_
   static GLuint texture2_zero_ohms;
 
   GLuint restore_sp;
-  extern GLuint sp2;
 
   /* XXX: Hard-coded magic */
   float resistor_pin_radius = 12. * MIL_TO_INTERNAL;
@@ -663,11 +665,12 @@ hidgl_draw_acy_resistor (ElementType *element, float surface_depth, float board_
 
   /* TEXTURE SETUP */
   glGetIntegerv (GL_CURRENT_PROGRAM, (GLint*)&restore_sp);
-  glUseProgram (sp2);
+  hidgl_shader_activate (resistor_program);
 
   {
-    int tex0_location = glGetUniformLocation (sp2, "detail_tex");
-    int tex1_location = glGetUniformLocation (sp2, "bump_tex");
+    GLuint program = hidgl_shader_get_program (resistor_program);
+    int tex0_location = glGetUniformLocation (program, "detail_tex");
+    int tex1_location = glGetUniformLocation (program, "bump_tex");
     glUniform1i (tex0_location, 0);
     glUniform1i (tex1_location, 1);
   }
@@ -721,10 +724,15 @@ hidgl_draw_acy_resistor (ElementType *element, float surface_depth, float board_
   if (1) {
     GLfloat emission[] = {0.0f, 0.0f, 0.0f, 1.0f};
     GLfloat specular[] = {0.5f, 0.5f, 0.5f, 1.0f};
-    GLfloat shininess = 20.;
-    glMaterialfv (GL_FRONT_AND_BACK, GL_EMISSION, emission);
-    glMaterialfv (GL_FRONT_AND_BACK, GL_SPECULAR, specular);
-    glMaterialfv (GL_FRONT_AND_BACK, GL_SHININESS, &shininess);
+    hidgl_material *material;
+
+    material = hidgl_material_new ("resistor_body");
+    hidgl_material_set_emission_color (material, emission);
+    hidgl_material_set_specular_color (material, specular);
+    hidgl_material_set_shininess (material, 20.0f);
+    hidgl_material_set_shader (material, resistor_program);
+    hidgl_material_activate (material);
+    hidgl_material_free (material);
   }
 
 #if 1
@@ -797,22 +805,20 @@ hidgl_draw_acy_resistor (ElementType *element, float surface_depth, float board_
 
   glEnable (GL_LIGHTING);
 
-  glUseProgram (0);
-
-  glColor3f (resistor_pin_color[0] / 1.5,
-             resistor_pin_color[1] / 1.5,
-             resistor_pin_color[2] / 1.5);
-
   /* COLOR / MATERIAL SETUP */
-  glColorMaterial (GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
-  glEnable (GL_COLOR_MATERIAL);
-
   if (1) {
-//    GLfloat ambient[] = {0.0, 0.0, 0.0, 1.0};
-    GLfloat specular[] = {0.5, 0.5, 0.5, 1.0};
-    GLfloat shininess = 120.;
-    glMaterialfv (GL_FRONT_AND_BACK, GL_SPECULAR, specular);
-    glMaterialfv (GL_FRONT_AND_BACK, GL_SHININESS, &shininess);
+    GLfloat emission[] = {0.0f, 0.0f, 0.0f, 1.0f};
+    GLfloat specular[] = {0.5f, 0.5f, 0.5f, 1.0f};
+    hidgl_material *material;
+
+    material = hidgl_material_new ("resistor_pin");
+    hidgl_material_set_ambient_color (material, resistor_pin_color);
+    hidgl_material_set_diffuse_color (material, resistor_pin_color);
+    hidgl_material_set_emission_color (material, emission);
+    hidgl_material_set_specular_color (material, specular);
+    hidgl_material_set_shininess (material, 120.0f);
+    hidgl_material_activate (material);
+    hidgl_material_free (material);
   }
 
   for (end = 0; end < 2; end++) {
diff --git a/src/hid/common/hidgl_package_vrml.c b/src/hid/common/hidgl_package_vrml.c
new file mode 100644
index 0000000..5ae16ad
--- /dev/null
+++ b/src/hid/common/hidgl_package_vrml.c
@@ -0,0 +1,440 @@
+/* $Id$ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+#include <stdbool.h>
+#include <gdk-pixbuf/gdk-pixbuf.h>
+#include "data.h"
+
+/* The Linux OpenGL ABI 1.0 spec requires that we define
+ * GL_GLEXT_PROTOTYPES before including gl.h or glx.h for extensions
+ * in order to get prototypes:
+ *   http://www.opengl.org/registry/ABI/
+ */
+#define GL_GLEXT_PROTOTYPES 1
+#include <GL/gl.h>
+
+#ifdef HAVE_LIBDMALLOC
+#include <dmalloc.h>
+#endif
+
+static void
+load_texture_from_png (char *filename)
+{
+  GError *error = NULL;
+  GdkPixbuf *pixbuf;
+  int width;
+  int height;
+  int rowstride;
+  int has_alpha;
+  int bits_per_sample;
+  int n_channels;
+  unsigned char *pixels;
+
+  pixbuf = gdk_pixbuf_new_from_file (filename, &error);
+
+  if (pixbuf == NULL) {
+    g_error ("%s", error->message);
+    g_error_free (error);
+    error = NULL;
+    return;
+  }
+
+  width = gdk_pixbuf_get_width (pixbuf);
+  height = gdk_pixbuf_get_height (pixbuf);
+  rowstride = gdk_pixbuf_get_rowstride (pixbuf);
+  has_alpha = gdk_pixbuf_get_has_alpha (pixbuf);
+  bits_per_sample = gdk_pixbuf_get_bits_per_sample (pixbuf);
+  n_channels = gdk_pixbuf_get_n_channels (pixbuf);
+  pixels = gdk_pixbuf_get_pixels (pixbuf);
+
+  g_warn_if_fail (bits_per_sample == 8);
+  g_warn_if_fail (n_channels == 4);
+  g_warn_if_fail (rowstride == width * n_channels);
+
+  glTexImage2D (GL_TEXTURE_2D, 0, GL_RGB, width, height, 0,
+                (n_channels == 4) ? GL_RGBA : GL_RGB, GL_UNSIGNED_BYTE, pixels);
+
+  g_object_unref (pixbuf);
+}
+
+
+static void invert_4x4 (float m[4][4], float out[4][4]);
+
+static GLfloat *debug_lines = NULL;
+static int no_debug_lines = 0;
+static int max_debug_lines = 0;
+
+//#define LENG 1000
+#define LENG 0.6
+#define STRIDE_FLOATS 6
+static void
+debug_basis_vector (float x,   float y,   float z,
+                    float b1x, float b1y, float b1z,
+                    float b2x, float b2y, float b2z,
+                    float b3x, float b3y, float b3z)
+{
+  int comp_count;
+  float lenb1, lenb2, lenb3;
+
+  if (no_debug_lines + 3 > max_debug_lines) {
+    max_debug_lines += 10;
+    debug_lines = realloc (debug_lines, max_debug_lines * sizeof (GLfloat) * 2 * STRIDE_FLOATS);
+  }
+
+  lenb1 = sqrt (b1x * b1x + b1y * b1y + b1z * b1z);
+  lenb2 = sqrt (b2x * b2x + b2y * b2y + b2z * b2z);
+  lenb3 = sqrt (b3x * b3x + b3y * b3y + b3z * b3z);
+  b1x /= lenb1;  b1y /= lenb1;  b1z /= lenb1;
+  b2x /= lenb2;  b2y /= lenb2;  b2z /= lenb2;
+  b3x /= lenb3;  b3y /= lenb3;  b3z /= lenb3;
+
+  comp_count = 0;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = x;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = y;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = z;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 1.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = x + b1x * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = y + b1y * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = z + b1z * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 1.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  no_debug_lines++;
+
+  comp_count = 0;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = x;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = y;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = z;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 1.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = x + b2x * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = y + b2y * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = z + b2z * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 1.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  no_debug_lines++;
+
+  comp_count = 0;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = x;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = y;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = z;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 1.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = x + b3x * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = y + b3y * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = z + b3z * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 1.;
+  no_debug_lines++;
+}
+
+static void
+debug_basis_display ()
+{
+  if (no_debug_lines == 0)
+    return;
+
+#if 1
+  glPushAttrib (GL_CURRENT_BIT);
+  glColor4f (1., 1., 1., 1.);
+  glVertexPointer (3, GL_FLOAT, STRIDE_FLOATS * sizeof (GLfloat), &debug_lines[0]);
+  glColorPointer (3, GL_FLOAT, STRIDE_FLOATS * sizeof (GLfloat), &debug_lines[3]);
+  glEnableClientState (GL_VERTEX_ARRAY);
+  glEnableClientState (GL_COLOR_ARRAY);
+  glDrawArrays (GL_LINES, 0, no_debug_lines * 2);
+  glDisableClientState (GL_COLOR_ARRAY);
+  glDisableClientState (GL_VERTEX_ARRAY);
+  glPopAttrib ();
+#endif
+
+  free (debug_lines);
+  debug_lines = NULL;
+  no_debug_lines = 0;
+  max_debug_lines = 0;
+}
+
+/* b1{x,y,z} is the basis vector along "s" texture space */
+/* b2{x,y,z} is the basis vector along "t" texture space */
+static void
+compute_light_vector (float b1x, float b1y, float b1z,
+                      float b2x, float b2y, float b2z,
+                      float *lx, float *ly, float *lz,
+                      float *hx, float *hy, float *hz,
+                      float x,   float y,   float z)
+{
+  float b3x, b3y, b3z;
+  float tb1x, tb1y, tb1z;
+  float tb2x, tb2y, tb2z;
+  float tb3x, tb3y, tb3z;
+  float mvm[16]; /* NB: TRANSPOSED IN MEMORY */
+  /* NB: light_direction is a vector _TOWARDS_ the light source position */
+//  float light_direction[] = {-0.5, 1., -1.}; /* XXX: HARDCODEED! */
+  float light_direction[] = {0.0, 0.0, 1.0}; /* XXX: HARDCODEED! */
+  float half_direction[3];
+  float texspace_to_eye[4][4];
+  float eye_to_texspace[4][4];
+  float lenb1, lenb2, lenb3;
+  float len_half;
+  float len_light;
+
+  /* Normalise the light vector */
+  len_light = sqrt (light_direction[0] * light_direction[0] +
+                    light_direction[1] * light_direction[1] +
+                    light_direction[2] * light_direction[2]);
+  light_direction[0] /= len_light;
+  light_direction[1] /= len_light;
+  light_direction[2] /= len_light;
+
+  /* Sum with the unit vector towards the viewer */
+  half_direction[0] = light_direction[0] + 0.;
+  half_direction[1] = light_direction[1] + 0.;
+  half_direction[2] = light_direction[2] + 1.;
+
+  /* XXX: Should cache this ourselves */
+  glGetFloatv (GL_MODELVIEW_MATRIX, (GLfloat *)mvm);
+
+  if (0)
+    debug_basis_vector ((mvm[0] * x + mvm[4] * y + mvm[ 8] * z + mvm[12]) / mvm[15],
+                        (mvm[1] * x + mvm[5] * y + mvm[ 9] * z + mvm[13]) / mvm[15],
+                        (mvm[2] * x + mvm[6] * y + mvm[10] * z + mvm[14]) / mvm[15],
+                        0., 0., 1.,
+                        light_direction[0], light_direction[1], light_direction[2],
+                        half_direction[0], half_direction[1], half_direction[2]);
+
+  /* Third basis vector is the cross product of tb1 and tb2 */
+  b3x = (b2y * b1z - b2z * b1y);
+  b3y = (b2z * b1x - b2x * b1z);
+  b3z = (b2x * b1y - b2y * b1x);
+
+  /* Transform the S, T texture space bases into eye coordinates */
+  tb1x = mvm[0] * b1x + mvm[4] * b1y + mvm[ 8] * b1z;
+  tb1y = mvm[1] * b1x + mvm[5] * b1y + mvm[ 9] * b1z;
+  tb1z = mvm[2] * b1x + mvm[6] * b1y + mvm[10] * b1z;
+
+  tb2x = mvm[0] * b2x + mvm[4] * b2y + mvm[ 8] * b2z;
+  tb2y = mvm[1] * b2x + mvm[5] * b2y + mvm[ 9] * b2z;
+  tb2z = mvm[2] * b2x + mvm[6] * b2y + mvm[10] * b2z;
+
+  tb3x = mvm[0] * b3x + mvm[4] * b3y + mvm[ 8] * b3z;
+  tb3y = mvm[1] * b3x + mvm[5] * b3y + mvm[ 9] * b3z;
+  tb3z = mvm[2] * b3x + mvm[6] * b3y + mvm[10] * b3z;
+
+#if 1
+  /* Normalise tb1, tb2 and tb3 */
+  lenb1 = sqrt (tb1x * tb1x + tb1y * tb1y + tb1z * tb1z);
+  lenb2 = sqrt (tb2x * tb2x + tb2y * tb2y + tb2z * tb2z);
+  lenb3 = sqrt (tb3x * tb3x + tb3y * tb3y + tb3z * tb3z);
+  tb1x /= lenb1;  tb1y /= lenb1;  tb1z /= lenb1;
+  tb2x /= lenb2;  tb2y /= lenb2;  tb2z /= lenb2;
+  tb3x /= lenb3;  tb3y /= lenb3;  tb3z /= lenb3;
+#endif
+
+  if (0)
+    debug_basis_vector ((mvm[0] * x + mvm[4] * y + mvm[ 8] * z + mvm[12]) / mvm[15],
+                        (mvm[1] * x + mvm[5] * y + mvm[ 9] * z + mvm[13]) / mvm[15],
+                        (mvm[2] * x + mvm[6] * y + mvm[10] * z + mvm[14]) / mvm[15],
+                         tb1x, tb1y, tb1z, tb2x, tb2y, tb2z, tb3x, tb3y, tb3z);
+
+  texspace_to_eye[0][0] = tb1x; texspace_to_eye[0][1] = tb2x; texspace_to_eye[0][2] = tb3x;  texspace_to_eye[0][3] = 0.0;
+  texspace_to_eye[1][0] = tb1y; texspace_to_eye[1][1] = tb2y; texspace_to_eye[1][2] = tb3y;  texspace_to_eye[1][3] = 0.0;
+  texspace_to_eye[2][0] = tb1z; texspace_to_eye[2][1] = tb2z; texspace_to_eye[2][2] = tb3z;  texspace_to_eye[2][3] = 0.0;
+  texspace_to_eye[3][0] = 0.0;  texspace_to_eye[3][1] = 0.0;  texspace_to_eye[3][2] = 0.0;   texspace_to_eye[3][3] = 1.0;
+
+  invert_4x4 (texspace_to_eye, eye_to_texspace);
+
+  /* light_direction is in eye space, we need to transform this into texture space */
+  *lx = eye_to_texspace[0][0] * light_direction[0] +
+        eye_to_texspace[0][1] * light_direction[1] +
+        eye_to_texspace[0][2] * light_direction[2];
+  *ly = eye_to_texspace[1][0] * light_direction[0] +
+        eye_to_texspace[1][1] * light_direction[1] +
+        eye_to_texspace[1][2] * light_direction[2];
+  *lz = eye_to_texspace[2][0] * light_direction[0] +
+        eye_to_texspace[2][1] * light_direction[1] +
+        eye_to_texspace[2][2] * light_direction[2];
+
+  /* half_direction is in eye space, we need to transform this into texture space */
+  *hx = eye_to_texspace[0][0] * half_direction[0] +
+        eye_to_texspace[0][1] * half_direction[1] +
+        eye_to_texspace[0][2] * half_direction[2];
+  *hy = eye_to_texspace[1][0] * half_direction[0] +
+        eye_to_texspace[1][1] * half_direction[1] +
+        eye_to_texspace[1][2] * half_direction[2];
+  *hz = eye_to_texspace[2][0] * half_direction[0] +
+        eye_to_texspace[2][1] * half_direction[1] +
+        eye_to_texspace[2][2] * half_direction[2];
+
+  {
+    len_light = sqrt (*lx * *lx + *ly * *ly + *lz * *lz);
+    *lx /= len_light;
+    *ly /= len_light;
+    *lz /= len_light;
+
+    *lx = *lx / 2. + 0.5;
+    *ly = *ly / 2. + 0.5;
+    *lz = *lz / 2. + 0.5;
+
+    len_half = sqrt (*hx * *hx + *hy * *hy + *hz * *hz);
+    *hx /= len_half;
+    *hy /= len_half;
+    *hz /= len_half;
+
+    *hx = *hx / 2. + 0.5;
+    *hy = *hy / 2. + 0.5;
+    *hz = *hz / 2. + 0.5;
+  }
+}
+
+static void
+emit_vertex (float x,   float y,   float z,
+             float b1x, float b1y, float b1z,
+             float b2x, float b2y, float b2z,
+             float tex0_s, float tex1_s, float tex1_t)
+{
+  GLfloat lx, ly, lz;
+  GLfloat hx, hy, hz;
+  compute_light_vector (b1x, b1y, b1z, b2x, b2y, b2z, &lx, &ly, &lz, &hx, &hy, &hz, x, y, z);
+  glColor3f (lx, ly, lz);
+  glMultiTexCoord1f (GL_TEXTURE0, tex0_s);
+  glMultiTexCoord2f (GL_TEXTURE1, tex1_s, tex1_t);
+  glMultiTexCoord3f (GL_TEXTURE2, hx, hy, hz);
+  glVertex3f (x, y, z);
+}
+
+enum geom_pos {
+  FIRST,
+  MIDDLE,
+  LAST
+};
+
+static void
+emit_pair (float ang_edge1, float cos_edge1, float sin_edge1,
+           float ang_edge2, float cos_edge2, float sin_edge2,
+           float prev_r, float prev_z,
+           float      r, float      z,
+           float next_r, float next_z,
+           float tex0_s, float resistor_width,
+           enum geom_pos pos)
+{
+  int repeat;
+
+  tex0_s = z / resistor_width + 0.5;
+
+  for (repeat = 0; repeat < ((pos == FIRST) ? 2 : 1); repeat++)
+    emit_vertex (r * cos_edge1, r * sin_edge1, z,
+                 sin_edge1, -cos_edge1, 0,
+                 cos_edge1 * (next_r - prev_r) / 2., sin_edge1 * (next_r - prev_r) / 2., (next_z - prev_z) / 2.,
+                 tex0_s, ang_edge1 / 2. / M_PI, tex0_s);
+
+  for (repeat = 0; repeat < ((pos == LAST) ? 2 : 1); repeat++)
+    emit_vertex (r * cos_edge2, r * sin_edge2, z,
+                 sin_edge2, -cos_edge2, 0,
+                 cos_edge2 * (next_r - prev_r) / 2., sin_edge2 * (next_r - prev_r) / 2., (next_z - prev_z) / 2.,
+                 tex0_s, ang_edge2 / 2. / M_PI, tex0_s);
+}
+
+
+#define NUM_RESISTOR_STRIPS 100
+#define NUM_PIN_RINGS 15
+#define MIL_TO_INTERNAL 100.
+
+extern int hidgl_parse_vrml (char *filename);
+
+void
+hidgl_draw_vrml (ElementType *element, float surface_depth, float board_thickness, char *vrml_file)
+{
+  static bool one_shot = true;
+
+  if (!one_shot)
+    return;
+
+  printf ("hidgl_draw_vrml\n");
+  hidgl_parse_vrml ("test.wrl");
+  one_shot = false;
+}
+
+static float
+determinant_4x4 (float m[4][4])
+{
+  float det;
+  det = m[0][3] * m[1][2] * m[2][1] * m[3][0]-m[0][2] * m[1][3] * m[2][1] * m[3][0] -
+        m[0][3] * m[1][1] * m[2][2] * m[3][0]+m[0][1] * m[1][3] * m[2][2] * m[3][0] +
+        m[0][2] * m[1][1] * m[2][3] * m[3][0]-m[0][1] * m[1][2] * m[2][3] * m[3][0] -
+        m[0][3] * m[1][2] * m[2][0] * m[3][1]+m[0][2] * m[1][3] * m[2][0] * m[3][1] +
+        m[0][3] * m[1][0] * m[2][2] * m[3][1]-m[0][0] * m[1][3] * m[2][2] * m[3][1] -
+        m[0][2] * m[1][0] * m[2][3] * m[3][1]+m[0][0] * m[1][2] * m[2][3] * m[3][1] +
+        m[0][3] * m[1][1] * m[2][0] * m[3][2]-m[0][1] * m[1][3] * m[2][0] * m[3][2] -
+        m[0][3] * m[1][0] * m[2][1] * m[3][2]+m[0][0] * m[1][3] * m[2][1] * m[3][2] +
+        m[0][1] * m[1][0] * m[2][3] * m[3][2]-m[0][0] * m[1][1] * m[2][3] * m[3][2] -
+        m[0][2] * m[1][1] * m[2][0] * m[3][3]+m[0][1] * m[1][2] * m[2][0] * m[3][3] +
+        m[0][2] * m[1][0] * m[2][1] * m[3][3]-m[0][0] * m[1][2] * m[2][1] * m[3][3] -
+        m[0][1] * m[1][0] * m[2][2] * m[3][3]+m[0][0] * m[1][1] * m[2][2] * m[3][3];
+   return det;
+}
+
+static void
+invert_4x4 (float m[4][4], float out[4][4])
+{
+  float scale = 1 / determinant_4x4 (m);
+
+  out[0][0] = (m[1][2] * m[2][3] * m[3][1] - m[1][3] * m[2][2] * m[3][1] +
+               m[1][3] * m[2][1] * m[3][2] - m[1][1] * m[2][3] * m[3][2] -
+               m[1][2] * m[2][1] * m[3][3] + m[1][1] * m[2][2] * m[3][3]) * scale;
+  out[0][1] = (m[0][3] * m[2][2] * m[3][1] - m[0][2] * m[2][3] * m[3][1] -
+               m[0][3] * m[2][1] * m[3][2] + m[0][1] * m[2][3] * m[3][2] +
+               m[0][2] * m[2][1] * m[3][3] - m[0][1] * m[2][2] * m[3][3]) * scale;
+  out[0][2] = (m[0][2] * m[1][3] * m[3][1] - m[0][3] * m[1][2] * m[3][1] +
+               m[0][3] * m[1][1] * m[3][2] - m[0][1] * m[1][3] * m[3][2] -
+               m[0][2] * m[1][1] * m[3][3] + m[0][1] * m[1][2] * m[3][3]) * scale;
+  out[0][3] = (m[0][3] * m[1][2] * m[2][1] - m[0][2] * m[1][3] * m[2][1] -
+               m[0][3] * m[1][1] * m[2][2] + m[0][1] * m[1][3] * m[2][2] +
+               m[0][2] * m[1][1] * m[2][3] - m[0][1] * m[1][2] * m[2][3]) * scale;
+  out[1][0] = (m[1][3] * m[2][2] * m[3][0] - m[1][2] * m[2][3] * m[3][0] -
+               m[1][3] * m[2][0] * m[3][2] + m[1][0] * m[2][3] * m[3][2] +
+               m[1][2] * m[2][0] * m[3][3] - m[1][0] * m[2][2] * m[3][3]) * scale;
+  out[1][1] = (m[0][2] * m[2][3] * m[3][0] - m[0][3] * m[2][2] * m[3][0] +
+               m[0][3] * m[2][0] * m[3][2] - m[0][0] * m[2][3] * m[3][2] -
+               m[0][2] * m[2][0] * m[3][3] + m[0][0] * m[2][2] * m[3][3]) * scale;
+  out[1][2] = (m[0][3] * m[1][2] * m[3][0] - m[0][2] * m[1][3] * m[3][0] -
+               m[0][3] * m[1][0] * m[3][2] + m[0][0] * m[1][3] * m[3][2] +
+               m[0][2] * m[1][0] * m[3][3] - m[0][0] * m[1][2] * m[3][3]) * scale;
+  out[1][3] = (m[0][2] * m[1][3] * m[2][0] - m[0][3] * m[1][2] * m[2][0] +
+               m[0][3] * m[1][0] * m[2][2] - m[0][0] * m[1][3] * m[2][2] -
+               m[0][2] * m[1][0] * m[2][3] + m[0][0] * m[1][2] * m[2][3]) * scale;
+  out[2][0] = (m[1][1] * m[2][3] * m[3][0] - m[1][3] * m[2][1] * m[3][0] +
+               m[1][3] * m[2][0] * m[3][1] - m[1][0] * m[2][3] * m[3][1] -
+               m[1][1] * m[2][0] * m[3][3] + m[1][0] * m[2][1] * m[3][3]) * scale;
+  out[2][1] = (m[0][3] * m[2][1] * m[3][0] - m[0][1] * m[2][3] * m[3][0] -
+               m[0][3] * m[2][0] * m[3][1] + m[0][0] * m[2][3] * m[3][1] +
+               m[0][1] * m[2][0] * m[3][3] - m[0][0] * m[2][1] * m[3][3]) * scale;
+  out[2][2] = (m[0][1] * m[1][3] * m[3][0] - m[0][3] * m[1][1] * m[3][0] +
+               m[0][3] * m[1][0] * m[3][1] - m[0][0] * m[1][3] * m[3][1] -
+               m[0][1] * m[1][0] * m[3][3] + m[0][0] * m[1][1] * m[3][3]) * scale;
+  out[2][3] = (m[0][3] * m[1][1] * m[2][0] - m[0][1] * m[1][3] * m[2][0] -
+               m[0][3] * m[1][0] * m[2][1] + m[0][0] * m[1][3] * m[2][1] +
+               m[0][1] * m[1][0] * m[2][3] - m[0][0] * m[1][1] * m[2][3]) * scale;
+  out[3][0] = (m[1][2] * m[2][1] * m[3][0] - m[1][1] * m[2][2] * m[3][0] -
+               m[1][2] * m[2][0] * m[3][1] + m[1][0] * m[2][2] * m[3][1] +
+               m[1][1] * m[2][0] * m[3][2] - m[1][0] * m[2][1] * m[3][2]) * scale;
+  out[3][1] = (m[0][1] * m[2][2] * m[3][0] - m[0][2] * m[2][1] * m[3][0] +
+               m[0][2] * m[2][0] * m[3][1] - m[0][0] * m[2][2] * m[3][1] -
+               m[0][1] * m[2][0] * m[3][2] + m[0][0] * m[2][1] * m[3][2]) * scale;
+  out[3][2] = (m[0][2] * m[1][1] * m[3][0] - m[0][1] * m[1][2] * m[3][0] -
+               m[0][2] * m[1][0] * m[3][1] + m[0][0] * m[1][2] * m[3][1] +
+               m[0][1] * m[1][0] * m[3][2] - m[0][0] * m[1][1] * m[3][2]) * scale;
+  out[3][3] = (m[0][1] * m[1][2] * m[2][0] - m[0][2] * m[1][1] * m[2][0] +
+               m[0][2] * m[1][0] * m[2][1] - m[0][0] * m[1][2] * m[2][1] -
+               m[0][1] * m[1][0] * m[2][2] + m[0][0] * m[1][1] * m[2][2]) * scale;
+}
diff --git a/src/hid/common/hidgl_package_vrml_l.l b/src/hid/common/hidgl_package_vrml_l.l
new file mode 100644
index 0000000..b308527
--- /dev/null
+++ b/src/hid/common/hidgl_package_vrml_l.l
@@ -0,0 +1,276 @@
+%{
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Contact addresses for paper mail and Email:
+ *  Thomas Nau, Schlehenweg 15, 88471 Baustetten, Germany
+ *  Thomas.Nau@rz.uni-ulm.de
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <ctype.h>
+
+#if defined(_POSIX_SOURCE) || defined(_HPUX_SOURCE)
+#include <unistd.h>
+#endif
+
+#include "global.h"
+
+#ifdef HAVE_LIBDMALLOC
+# include <dmalloc.h> /* see http://dmalloc.com */
+#endif
+
+
+#include "global.h"
+#include "crosshair.h"
+#include "data.h"
+#include "error.h"
+#include "file.h"
+#include "mymem.h"
+#include "misc.h"
+#include "strflags.h"
+#include "hidgl_package_vrml_y.h"
+
+/* ---------------------------------------------------------------------------
+ * some shared parser identifiers
+ */
+#ifdef FLEX_SCANNER
+int vrml_yylineno;  /* linenumber */
+#define yyunput ATTRIBUTE_UNUSED yyunput
+#endif
+
+char *vrml_yyfilename; /* in this file */
+
+/* ---------------------------------------------------------------------------
+ * an external prototype
+ */
+extern int	vrml_yyparse(void);
+
+/*STRING			".*" ... double-quotes must be \", backslashes must be \\... */
+/*IDFIRSTCHAR		[^0-9 "#'+,-.\[\\\]{}] */
+/*IDRESTCHARS		[^ "#',.\[\\\]{}] */
+
+/*STRINGCHAR              ([^"\n\r\\]|\\.) */
+/* \"{STRINGCHAR}*\"	{printf ("DEAD RULE?\n");} */
+/* {STRINGCHAR}+		{ */
+
+%}
+
+INT32			([+\-]?(([0-9]+)|(0[xX][0-9a-fA-F]+)))
+FLOATING		([+/-]?((([0-9]+(\.)?)|([0-9]*\.[0-9]+))([eE][+\-]?[0-9]+)?))
+
+DECIMAL                 -?[1-9][0-9]*|0
+
+STRINGCHAR              ([^, "\n\r\\{}\[\]]|\\.)
+
+%option prefix="vrml_yy"
+%option outfile="lex.yy.c"
+%option yylineno
+
+%%
+
+DEF		{ return T_DEF; }
+EXTERNPROTO	{ return T_EXTERNPROTO; }
+FALSE		{ return T_FALSE; }
+IS		{ return T_IS; }
+NULL		{ return T_NULL; }
+PROTO		{ return T_PROTO; }
+ROUTE		{ return T_ROUTE; }
+TO		{ return T_TO; }
+TRUE		{ return T_TRUE; }
+USE		{ return T_USE; }
+eventIn		{ return T_EVENTIN; }
+eventOut	{ return T_EVENTOUT; }
+exposedField	{ return T_EXPOSEDFIELD; }
+field		{ return T_FIELD; }
+
+Script		{ return T_SCRIPT; }
+
+"#VRML V2.0 utf8"	{ return T_VRMLHEADER; }
+
+%{ /* Fields for any grouping node */ %}
+children		{ return T_children; }
+
+%{ /* Transform node and its fields */ %}
+Transform		{ return T_TRANSFORM; }
+center			{ return T_center; }
+rotation		{ return T_rotation; }
+scale			{ return T_scale; }
+scaleOrientation	{ return T_scale_orientation; }
+translation		{ return T_translation; }
+bboxCenter		{ return T_bbox_center; }
+bboxSize		{ return T_bbox_size; }
+
+%{ /* Shape node and its fields */ %}
+Shape			{ return T_SHAPE; }
+appearance		{ return T_appearance; }
+geometry		{ return T_geometry; }
+
+%{ /* Appearance node and its fields */ %}
+Appearance		{ return T_APPEARANCE; }
+material		{ return T_material; }
+texture			{ return T_texture; }
+textureTransform	{ return T_texture_transform; }
+
+%{ /* Material node and its fields */ %}
+Material		{ return T_MATERIAL; }
+ambientIntensity	{ return T_ambient_intensity; }
+diffuseColor		{ return T_diffuse_color; }
+emissiveColor		{ return T_emissive_color; }
+shininess		{ return T_shininess; }
+specularColor		{ return T_specular_color; }
+transparency		{ return T_transparency; }
+
+%{ /* IndexedFaceSet node and its fields */ %}
+IndexedFaceSet		{ return T_INDEXED_FACE_SET; }
+color			{ return T_color; }
+coord			{ return T_coord; }
+normal			{ return T_normal; }
+texCoord		{ return T_tex_coord; }
+ccw			{ return T_ccw; }
+colorIndex		{ return T_color_index; }
+colorPerVertex		{ return T_color_per_vertex; }
+convex			{ return T_convex; }
+coordIndex		{ return T_coord_index; }
+creaseAngle		{ return T_crease_angle; }
+normalIndex		{ return T_normal_index; }
+normalPerVertex		{ return T_normal_per_vertex; }
+solid			{ return T_solid; }
+texCoord		{ return T_tex_coord_index; }
+
+%{ /* Coordinate node and its field */ %}
+Coordinate		{ return T_COORDINATE; }
+point			{ return T_point; }
+
+%{ /* Normal node and its field */ %}
+Normal			{ return T_NORMAL; }
+vector			{ return T_vector; }
+
+
+{INT32}		{
+					vrml_yylval.int32 = atoi(vrml_yytext);
+					return INT32;
+			}
+
+{FLOATING}		{
+					vrml_yylval.floating = strtod (vrml_yytext, NULL);
+					return FLOATING;
+			}
+
+#.*					{}
+
+{STRINGCHAR}*	{
+
+						char	*p1, *p2;
+
+							/* allocate memory and copy string;
+							 * stringlength is counted and copied without
+							 * leading and trailing '"'
+							 */
+						vrml_yylval.string = MyCalloc(vrml_yyleng+1, sizeof(char), "LEX");
+						p1 = (char *) (vrml_yytext);
+						p2 = vrml_yylval.string;
+						while(vrml_yyleng--)
+						{
+								/* check for special character */
+							if (*p1 == '\\')
+							{
+								vrml_yyleng--;
+								p1++;
+
+							}
+							*p2++ = *p1++;
+						}
+						*p2 = '\0';
+//						printf ("Returning a string token %s\n", vrml_yylval.string);
+						return(STRING);
+					}
+[ \t,]+				{}
+[\n]				{
+#ifndef FLEX_SCANNER
+						vrml_yylineno++;
+#endif
+					}
+[\r]				{}
+.					{ return(*vrml_yytext); }
+
+%%
+
+/* ---------------------------------------------------------------------------
+ * sets up the preprocessor command
+ */
+static int Parse(char *filename)
+{
+  int retval;
+  extern int vrml_yydebug;
+
+#ifdef FLEX_SCANNER
+  static	bool	firsttime = true;
+#endif
+
+  yyin = fopen (filename, "r");
+  if (!yyin)
+    return 1;
+
+#ifdef FLEX_SCANNER
+  /* reset parser if not called the first time */
+  if (!firsttime)
+    vrml_yyrestart(yyin);
+  firsttime = false;
+#endif
+
+  /* init linenumber and filename for vrml_yyerror() */
+  vrml_yylineno = 1;
+  vrml_yyfilename = filename;
+//  vrml_yydebug = 1;
+
+  /* We need to save the data temporarily because lex-yacc are able
+   * to break the application if the input file has an illegal format.
+   * It's not necessary if the system supports the call of functions
+   * on termination.
+   */
+
+#if !defined(HAS_ATEXIT) && !defined(HAS_ON_EXIT)
+  if (PCB)
+    SaveTMPData();
+  retval = vrml_yyparse();
+  RemoveTMPData();
+#else
+  retval = vrml_yyparse();
+#endif
+
+  /* clean up parse buffer */
+  vrml_yy_delete_buffer (YY_CURRENT_BUFFER);
+
+  return (fclose (vrml_yyin) ? 1 : retval);
+}
+
+/* ---------------------------------------------------------------------------
+ * initializes LEX and calls parser for a single element file
+ */
+int hidgl_parse_vrml (char *filename)
+{
+  return (Parse (filename));
+}
diff --git a/src/hid/common/hidgl_package_vrml_y.y b/src/hid/common/hidgl_package_vrml_y.y
new file mode 100644
index 0000000..0a59fbe
--- /dev/null
+++ b/src/hid/common/hidgl_package_vrml_y.y
@@ -0,0 +1,631 @@
+%{
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Contact addresses for paper mail and Email:
+ *  Thomas Nau, Schlehenweg 15, 88471 Baustetten, Germany
+ *  Thomas.Nau@rz.uni-ulm.de
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "global.h"
+
+#ifdef HAVE_LIBDMALLOC
+# include <dmalloc.h> /* see http://dmalloc.com */
+#endif
+
+#define YYDEBUG 1
+
+int vrml_yyerror(const char *s);
+extern int vrml_yylex();
+extern int vrml_yylineno;
+extern char *vrml_yyfilename;
+
+%}
+
+%name-prefix="vrml_yy"
+
+%union									/* define YYSTACK type */
+{
+	int		int32;
+	double		floating;
+	char		*string;
+}
+
+%token T_DEF
+%token T_EXTERNPROTO
+%token T_FALSE
+%token T_IS
+%token T_NULL
+%token T_PROTO
+%token T_ROUTE
+%token T_TO
+%token T_TRUE
+%token T_USE
+%token T_EVENTIN
+%token T_EVENTOUT
+%token T_EXPOSEDFIELD
+%token T_FIELD
+
+%token MFColor
+%token MFFloat
+%token MFInt32
+%token MFNode
+%token MFRotation
+%token MFString
+%token MFTime
+%token MFVec2f
+%token MFVec3f
+%token SFBool
+%token SFColor
+%token SFFloat
+%token SFImage
+%token SFInt32
+%token SFNode
+%token SFRotation
+%token SFString
+%token SFTime
+%token SFVec2f
+%token SFVec3f
+
+%token T_VRMLHEADER
+%token T_SCRIPT
+%token T_ID
+%token T_FIELDTYPE
+
+
+/* Fields for any grouping node */
+%token T_children
+
+/* Transform node and its fields */
+%token T_TRANSFORM
+%token T_center
+%token T_rotation
+%token T_scale
+%token T_scale_orientation
+%token T_translation
+%token T_bbox_center
+%token T_bbox_size
+
+/* Shape node and its fields */
+%token T_SHAPE
+%token T_appearance
+%token T_geometry
+
+/* Appearance node and its fields */
+%token T_APPEARANCE
+%token T_material
+%token T_texture
+%token T_texture_transform
+
+/* Material node and its fields */
+%token T_MATERIAL
+%token T_ambient_intensity
+%token T_diffuse_color
+%token T_emissive_color
+%token T_shininess
+%token T_specular_color
+%token T_transparency
+
+/* IndexedFaceSet node and its fields */
+%token T_INDEXED_FACE_SET
+%token T_color
+%token T_coord
+%token T_normal
+%token T_tex_coord
+%token T_ccw
+%token T_color_index
+%token T_color_per_vertex
+%token T_convex
+%token T_coord_index
+%token T_crease_angle
+%token T_normal_index
+%token T_normal_per_vertex
+%token T_solid
+%token T_tex_coord_index
+
+/* Coordinate node and its field */
+%token T_COORDINATE
+%token T_point
+
+/* Normal node and its field */
+%token T_NORMAL
+%token T_vector
+
+
+%token <floating>      FLOATING
+%token <number>        INT32
+
+%token <string>        STRING
+//%token <string>        IDFIRSTCHAR
+//%token <string>        IDRESTCHARS
+
+%%
+
+/* General VRML stuff */
+
+parse				: vrmlHeader
+				  vrmlScene
+				| error { YYABORT; }
+				;
+
+vrmlHeader			: T_VRMLHEADER { printf ("Got header\n"); }
+				  vrmlHeaderComment
+				;
+
+vrmlHeaderComment		: sfstringValues
+				| empty
+				;
+
+vrmlScene			: statements
+				;
+
+statements			: statement
+				| statement statements
+				| empty
+				;
+
+statement			: nodeStatement
+//				| protoStatement
+//				| routeStatement
+				;
+
+nodeStatement			: node
+				| T_DEF nodeNameId node
+				| T_USE nodeNameId
+				;
+
+/*
+rootNodeStatement		: node
+				| T_DEF nodeNameId node { printf ("Got a root Node Statement\n"); }
+				;
+
+protoStatement			: proto
+				| externproto
+				;
+
+protoStatements			: protoStatement
+				| protoStatement protoStatements
+				| empty
+				;
+
+proto				: T_PROTO nodeTypeId '[' interfaceDeclarations ']' '{' protoBody '}'
+				;
+
+protoBody			: protoStatements rootNodeStatement statements
+				;
+
+interfaceDeclarations		: interfaceDeclaration
+				| interfaceDeclaration interfaceDeclarations
+				| empty
+				;
+
+restrictedInterfaceDeclaration	: T_EVENTIN fieldType eventInId
+				| T_EVENTOUT fieldType eventOutId
+				| T_FIELD fieldType fieldId fieldValue
+				;
+
+interfaceDeclaration		: restrictedInterfaceDeclaration
+				| T_EXPOSEDFIELD fieldType fieldId fieldValue
+				;
+
+externproto			: T_EXTERNPROTO nodeTypeId '[' externInterfaceDeclarations ']' URLList
+				;
+
+externInterfaceDeclarations	: externInterfaceDeclaration
+				| externInterfaceDeclaration externInterfaceDeclarations
+				| empty
+				;
+
+externInterfaceDeclaration	: T_EVENTIN fieldType eventInId
+				| T_EVENTOUT fieldType eventOutId
+				| T_FIELD fieldType fieldId
+				| T_EXPOSEDFIELD fieldType fieldId
+				;
+
+routeStatement			: T_ROUTE nodeNameId '.' eventOutId T_TO nodeNameId '.' eventInId
+				;
+
+URLList				: mfstringValue
+				;
+*/
+
+empty				:
+				;
+
+
+/* NODES */
+
+/*
+node				: nodeTypeId '{' nodeBody '}'
+				| T_SCRIPT '{' scriptBody '}'
+				;
+*/
+
+node				: T_TRANSFORM        '{' Transform_nodeBody      '}' { printf ("Got a transform node\n");}
+				| T_SHAPE            '{' Shape_nodeBody          '}' { printf ("Got a shape node\n");}
+				| T_APPEARANCE       '{' Appearance_nodeBody     '}' { printf ("Got an appearance node\n");}
+				| T_MATERIAL         '{' Material_nodeBody       '}' { printf ("Got a material node\n");}
+				| T_INDEXED_FACE_SET '{' IndexedFaceSet_nodeBody '}' { printf ("Got an indexed face set node\n");}
+				| T_COORDINATE       '{' Coordinate_nodeBody     '}' { printf ("Got a coordinate node\n");}
+				| T_NORMAL           '{' Normal_nodeBody         '}' { printf ("Got a normal node\n");}
+				| T_SCRIPT           '{' scriptBody '}'
+				;
+
+/* NORMAL NODE ------------------------------------------------------------- */
+Transform_nodeBody		: Transform_nodeBodyElements
+				| empty;
+
+Transform_nodeBodyElements	: Transform_nodeBodyElement
+				| Transform_nodeBodyElement Transform_nodeBodyElements;
+
+Transform_nodeBodyElement	: T_center sfvec3fValue
+				| T_children '[' statements ']'
+				| T_rotation sfvec3fValue
+				| T_scale sfvec3fValue
+				| T_scale_orientation sfrotationValue
+				| T_translation sfvec3fValue
+				| T_bbox_center sfvec3fValue
+				| T_bbox_size sfvec3fValue
+				;
+
+/* SHAPE NODE -------------------------------------------------------------- */
+Shape_nodeBody			: Shape_nodeBodyElements
+				| empty;
+
+Shape_nodeBodyElements		: Shape_nodeBodyElement
+				| Shape_nodeBodyElement Shape_nodeBodyElements;
+
+Shape_nodeBodyElement		: T_appearance statements
+				| T_geometry statements
+				;
+
+/* APPEARANCE NODE --------------------------------------------------------- */
+Appearance_nodeBody		: Appearance_nodeBodyElements
+				| empty;
+
+Appearance_nodeBodyElements	: Appearance_nodeBodyElement
+				| Appearance_nodeBodyElement Appearance_nodeBodyElements;
+
+Appearance_nodeBodyElement	: T_material statements
+				| T_texture statements
+				| T_texture_transform statements
+				;
+
+/* MATERIAL NODE ----------------------------------------------------------- */
+Material_nodeBody		: Material_nodeBodyElements
+				| empty;
+
+Material_nodeBodyElements	: Material_nodeBodyElement
+				| Material_nodeBodyElement Material_nodeBodyElements;
+
+Material_nodeBodyElement	: T_ambient_intensity sffloatValue
+				| T_diffuse_color sfcolorValue
+				| T_emissive_color sfcolorValue
+				| T_shininess sffloatValue
+				| T_specular_color sfcolorValue
+				| T_transparency sffloatValue
+				;
+
+/* INDEXED_FACE_SET NODE --------------------------------------------------- */
+IndexedFaceSet_nodeBody		: IndexedFaceSet_nodeBodyElements
+				| empty;
+
+IndexedFaceSet_nodeBodyElements	: IndexedFaceSet_nodeBodyElement
+				| IndexedFaceSet_nodeBodyElement IndexedFaceSet_nodeBodyElements;
+
+IndexedFaceSet_nodeBodyElement	: T_color statement
+				| T_coord statement
+				| T_normal statement
+				| T_tex_coord statement
+				| T_ccw sfboolValue
+				| T_color_index mfint32Value
+				| T_color_per_vertex sfboolValue
+				| T_convex sfboolValue
+				| T_coord_index mfint32Value
+				| T_crease_angle sffloatValue
+				| T_normal_index mfint32Value
+				| T_normal_per_vertex sfboolValue
+				| T_solid sfboolValue
+				| T_tex_coord_index mfint32Value
+				;
+
+/* COORDINATE NODE --------------------------------------------------------- */
+Coordinate_nodeBody		: Coordinate_nodeBodyElements
+				| empty;
+
+Coordinate_nodeBodyElements	: Coordinate_nodeBodyElement
+				| Coordinate_nodeBodyElement Coordinate_nodeBodyElements;
+
+Coordinate_nodeBodyElement	: T_point mfvec3fValue
+				;
+
+/* NORMAL NODE ------------------------------------------------------------- */
+Normal_nodeBody			: Normal_nodeBodyElements
+				| empty;
+
+Normal_nodeBodyElements		: Normal_nodeBodyElement
+				| Normal_nodeBodyElement Normal_nodeBodyElements;
+
+Normal_nodeBodyElement		: T_vector mfvec3fValue
+				;
+
+/* GENERIC NODE ------------------------------------------------------------ */
+/*
+nodeBody			: nodeBodyElement
+				| nodeBodyElement nodeBody
+				| empty
+				;
+*/
+
+scriptBody			: // scriptBodyElement
+//				| scriptBodyElement scriptBody
+/*				| */ empty
+				;
+
+/*
+scriptBodyElement		: nodeBodyElement
+				| restrictedInterfaceDeclaration
+				| T_EVENTIN fieldType eventInId T_IS eventInId
+				| T_EVENTOUT fieldType eventOutId T_IS eventOutId
+				| T_FIELD fieldType fieldId T_IS fieldId
+				;
+
+nodeBodyElement			: //fieldId fieldValue
+//				| fieldId T_IS fieldId
+//				| eventInId T_IS eventInId
+//				| eventOutId T_IS eventOutId
+//				| routeStatement
+//				| protoStatement
+				;
+*/
+
+nodeNameId			: Id
+				;
+
+/*
+nodeTypeId			: Id
+				;
+
+fieldId				: Id
+				;
+
+eventInId			: Id
+				;
+
+eventOutId			: Id
+				;
+*/
+
+/*
+Id				: IDFIRSTCHAR
+				| IDFIRSTCHAR IDRESTCHARS
+				;
+*/
+
+Id				: STRING
+				;
+
+/* FIELDS */
+
+/*
+fieldType			: MFColor
+				| MFFloat
+				| MFInt32
+				| MFNode
+				| MFRotation
+				| MFString
+				| MFTime
+				| MFVec2f
+				| MFVec3f
+				| SFBool
+				| SFColor
+				| SFFloat
+				| SFImage
+				| SFInt32
+				| SFNode
+				| SFRotation
+				| SFString
+				| SFTime
+				| SFVec2f
+				| SFVec3f
+				;
+
+fieldValue			:
+				| sfboolValue
+				| sfcolorValue
+				| sffloatValue
+				| sfimageValue
+				| sfint32Value
+				| sfnodeValue
+				| sfrotationValue
+				| sfstringValue
+				| sftimeValue
+				| sfvec2fValue
+				| sfvec3fValue
+				| mfcolorValue
+				| mffloatValue
+				| mfint32Value
+				| mfnodeValue
+				| mfrotationValue
+				| mfstringValue
+				| mftimeValue
+				| mfvec2fValue
+				| mfvec3fValue
+				;
+*/
+
+sfboolValue			: T_TRUE
+				| T_FALSE
+				;
+
+sfcolorValue			: FLOATING FLOATING FLOATING
+				;
+
+sffloatValue			: FLOATING
+				;
+
+/*
+sfimageValue			: image_data
+				;
+
+image_data			: INT32
+				| image_data INT32
+				;
+*/
+
+sfint32Value			: INT32
+				;
+
+/*
+sfnodeValue			: nodeStatement
+				| T_NULL
+				;
+*/
+
+sfrotationValue			: FLOATING FLOATING FLOATING FLOATING
+				;
+
+sfstringValue			: STRING
+				;
+
+/*
+sftimeValue			: DOUBLE
+				;
+
+mftimeValue			: sftimeValue
+				| '[' ']'
+				| '[' sftimeValues ']'
+				;
+
+sftimeValues			: sftimeValue
+				| sftimeValue sftimeValues
+				;
+
+sfvec2fValue			: FLOATING FLOATING
+				;
+*/
+
+sfvec3fValue			: FLOATING FLOATING FLOATING
+				;
+
+/*
+mfcolorValue			: sfcolorValue
+				| '[' ']'
+				| '[' sfcolorValues ']'
+				;
+
+sfcolorValues			: sfcolorValue
+				| sfcolorValue sfcolorValues
+				;
+
+mffloatValue			: sffloatValue
+				| '[' ']'
+				| '[' sffloatValues ']'
+				;
+
+sffloatValues			: sffloatValue
+				| sffloatValue sffloatValues
+				;
+*/
+
+mfint32Value			: sfint32Value
+				| '[' ']'
+				| '[' sfint32Values ']'
+				;
+
+sfint32Values			: sfint32Value
+				| sfint32Value sfint32Values
+				;
+
+/*
+mfnodeValue			: nodeStatement
+				| '[' ']'
+				| '[' nodeStatements ']'
+				;
+
+nodeStatements			: nodeStatement
+				| nodeStatement nodeStatements
+				;
+
+mfrotationValue			: sfrotationValue
+				| '[' ']'
+				| '[' sfrotationValues ']'
+				;
+
+sfrotationValues		: sfrotationValue
+				| sfrotationValue sfrotationValues
+				;
+*/
+
+/*
+mfstringValue			: sfstringValue
+				| '[' ']'
+				| '[' sfstringValues ']'
+				;
+*/
+
+sfstringValues			: sfstringValue
+				| sfstringValue sfstringValues
+				;
+
+/*
+mfvec2fValue			: sfvec2fValue
+				| '[' ']'
+				| '[' sfvec2fValues ']'
+				;
+
+sfvec2fValues			: sfvec2fValue
+				| sfvec2fValue sfvec2fValues
+				;
+*/
+
+mfvec3fValue			: sfvec3fValue
+				| '[' ']'
+				| '[' sfvec3fValues ']'
+				;
+
+sfvec3fValues			: sfvec3fValue
+				| sfvec3fValue sfvec3fValues
+				;
+
+
+%%
+
+/* ---------------------------------------------------------------------------
+ * error routine called by parser library
+ */
+int vrml_yyerror(s)
+const char *s;
+{
+	printf("ERROR parsing file (%s)\n"
+		"    line number: %i\n"
+		"    description: '%s'\n",
+		vrml_yyfilename, vrml_yylineno, s);
+	return(0);
+}
+
+int vrml_yywrap()
+{
+  return 1;
+}
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index cabe705..e1b30f5 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -1429,7 +1429,6 @@ DrawMask (BoxType * screen)
 {
   static bool first_run = true;
   static GLuint texture;
-  extern GLuint sp;
 
   struct pin_info info;
   int thin = TEST_FLAG(THINDRAWFLAG, PCB) || TEST_FLAG(THINDRAWPOLYFLAG, PCB);
@@ -1470,7 +1469,7 @@ DrawMask (BoxType * screen)
   } else {
     glBindTexture (GL_TEXTURE_2D, texture);
   }
-  glUseProgram (0);
+  hidgl_shader_activate (NULL);
 
   if (1) {
     GLfloat s_params[] = {0.0001, 0., 0., 0.};
@@ -1509,7 +1508,7 @@ DrawMask (BoxType * screen)
   glDisable (GL_TEXTURE_GEN_T);
   glBindTexture (GL_TEXTURE_2D, 0);
   glDisable (GL_TEXTURE_2D);
-  glUseProgram (sp);
+  hidgl_shader_activate (circular_program);
 
   gui->use_mask (HID_MASK_OFF);
 
@@ -1692,6 +1691,11 @@ frontE_package_callback (const BoxType * b, void *cl)
         int layer_group = FRONT (element) ? 0 : max_copper_layer - 1; /* XXX: FIXME */
         hidgl_draw_acy_resistor (element, compute_depth (layer_group), BOARD_THICKNESS);
       }
+
+      if (strcmp (element->Name[DESCRIPTION_INDEX].TextString, "VRML_TEST") == 0) {
+        int layer_group = FRONT (element) ? 0 : max_copper_layer - 1; /* XXX: FIXME */
+        hidgl_draw_vrml (element, compute_depth (layer_group), BOARD_THICKNESS, "dummy_filename.wrl");
+      }
     }
   return 1;
 }
@@ -1919,9 +1923,6 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   int new_x, new_y;
   int min_depth;
   int max_depth;
-  static float wavetime = 0;
-  extern GLuint sp;
-  GLint waveTimeLoc = glGetUniformLocation (sp, "waveTime");
   float aspect;
   GLfloat scale[] = {1, 0, 0, 0,
                      0, 1, 0, 0,
@@ -1938,9 +1939,6 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   hidgl_init ();
   check_gl_drawing_ok_hack = true;
 
-  wavetime += 0.1;
-  glUniform1f (waveTimeLoc, wavetime);
-
   /* If we don't have any stencil bits available,
      we can't use the hidgl polygon drawing routine */
   /* TODO: We could use the GLU tessellator though */

Bottom: d4e6a547957aa257a74e0a3531c5a68f364a5645
Top:    3aee3aea00a9271119e54e33242088822c236416
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2008-10-12 17:33:51 +0100

Try something with the rtrees




---

diff --git a/src/pour.c b/src/pour.c
index 03c3911..3e272ac 100644
--- a/src/pour.c
+++ b/src/pour.c
@@ -294,7 +294,40 @@ DestroyPolygonInPour (PourTypePtr pour, PolygonTypePtr polygon)
   return (NULL);
 }
 
-static int
+/*static*/ int
+subtract_wonkyline_poly (POLYAREA * np1, POLYAREA **pg)
+{
+  POLYAREA *merged = NULL, *np = np1;
+  int x;
+
+  assert (np);
+  assert (pg);
+  assert (*pg);
+
+  if (pg == NULL)
+    {
+      printf ("Hmm, got pg == NULL in subtract_poly\n");
+      poly_Free (&np);
+      return -1;
+    }
+
+  assert (poly_Valid (*pg));
+  assert (poly_Valid (np));
+  x = poly_Boolean_free (*pg, np, &merged, PBO_SUB);
+  if (x != err_ok)
+    {
+      fprintf (stderr, "Error while clipping PBO_SUB: %d\n", x);
+      poly_Free (&merged);
+      return -1;
+    }
+
+  assert (!merged || poly_Valid (merged));
+
+  *pg = merged;
+  return 1;
+}
+
+/*static*/ int
 subtract_poly (POLYAREA * np1, POLYAREA **pg)
 {
   POLYAREA *merged = NULL, *np = np1;
@@ -536,8 +569,17 @@ line_sub_callback (const BoxType * b, void *cl)
   if (np == NULL)
     return 0;
 
-  if (subtract_poly (np, &info->pg) < 0)
-    longjmp (info->env, 1);
+  if (line->Point1.X == line->Point2.X ||
+      line->Point1.Y == line->Point2.Y)
+    {
+      if (subtract_poly (np, &info->pg) < 0)
+        longjmp (info->env, 1);
+    }
+  else
+    {
+      if (subtract_wonkyline_poly (np, &info->pg) < 0)
+        longjmp (info->env, 1);
+    }
   return 1;
 }
 
@@ -637,11 +679,21 @@ ClearPour (DataTypePtr Data, LayerTypePtr Layer, PourType * pour,
 
   if (setjmp (info.env) == 0)
     {
-      r  = r_search (Data->via_tree, &region, NULL, pin_sub_callback, &info);
+#warning I KNOW THIS IS THE SLOW PATH, profile it first so I can stop part way
+#if 1
+      GROUP_LOOP (Data, group);
+      {
+        r = r_search (layer->line_tree, &region, NULL, line_sub_callback, &info);
+      }
+      END_LOOP;
+#endif
+
+//      r = 0;
+      r += r_search (Data->via_tree, &region, NULL, pin_sub_callback, &info);
       r += r_search (Data->pin_tree, &region, NULL, pin_sub_callback, &info);
       GROUP_LOOP (Data, group);
       {
-        r += r_search (layer->line_tree, &region, NULL, line_sub_callback, &info);
+//        r += r_search (layer->line_tree, &region, NULL, line_sub_callback, &info);
         r += r_search (layer->arc_tree,  &region, NULL, arc_sub_callback,  &info);
         r += r_search (layer->text_tree, &region, NULL, text_sub_callback, &info);
         r += r_search (layer->pour_tree, &region, NULL, pour_sub_callback, &info);
diff --git a/src/rtree.c b/src/rtree.c
index 662c581..36d9f60 100644
--- a/src/rtree.c
+++ b/src/rtree.c
@@ -61,6 +61,33 @@
 
 RCSID ("$Id$");
 
+/* G_LIKELY and G_UNLIKLEY macros taken from GLib 2.16.3, LGPL */
+/*
+ * The G_LIKELY and G_UNLIKELY macros let the programmer give hints to 
+ * the compiler about the expected result of an expression. Some compilers
+ * can use this information for optimizations.
+ *
+ * The _G_BOOLEAN_EXPR macro is intended to trigger a gcc warning when
+ * putting assignments in g_return_if_fail ().  
+ */
+#if defined(__GNUC__) && (__GNUC__ > 2) && defined(__OPTIMIZE__)
+#define _G_BOOLEAN_EXPR(expr)                   \
+ __extension__ ({                               \
+   int _g_boolean_var_;                         \
+   if (expr)                                    \
+      _g_boolean_var_ = 1;                      \
+   else                                         \
+      _g_boolean_var_ = 0;                      \
+   _g_boolean_var_;                             \
+})
+#define G_LIKELY(expr) (__builtin_expect (_G_BOOLEAN_EXPR(expr), 1))
+#define G_UNLIKELY(expr) (__builtin_expect (_G_BOOLEAN_EXPR(expr), 0))
+#else
+#define G_LIKELY(expr) (expr)
+#define G_UNLIKELY(expr) (expr)
+#warning NOT OPTIMISING
+#endif
+
 
 #define SLOW_ASSERTS
 /* All rectangles are closed on the bottom left and open on the
@@ -913,7 +940,8 @@ __r_insert_node (struct rtree_node *node, const BoxType * query,
     {
       register int i;
 
-      if (manage)
+#warning UNLIKELY BASED ON QTY OF CALLERS PASSING manage=0 IN PCB, NOT PROFILING
+      if (G_UNLIKELY (manage))
         {
           register int flag = 1;

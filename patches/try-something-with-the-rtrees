Bottom: 58f2fb7f1fd36ba702b6157f4026205ade283ce0
Top:    b08c0727728eb3d5f8449ae6c754af58d7da154f
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-02-10 13:24:22 +0000

Try optimising polygon operations by keeping an rtree with their contours

InsertHoles() already creates an rtree of contours to do its internal
processing, and it is possible that intersect() could be sped up by
its existance as well.





---

diff --git a/src/global.h b/src/global.h
index 991b60c..d6b773c 100644
--- a/src/global.h
+++ b/src/global.h
@@ -40,7 +40,6 @@
 
 #include "const.h"
 #include "macro.h"
-#include "polyarea.h"
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -53,6 +52,10 @@
 
 #include "hid.h"
 
+typedef struct rtree rtree_t;
+
+#include "polyarea.h" /* Needs rtree_t defined */
+
 #define _(S) (S)
 
 typedef int LocationType;
diff --git a/src/polyarea.h b/src/polyarea.h
index 42acc1a..ee185a9 100644
--- a/src/polyarea.h
+++ b/src/polyarea.h
@@ -98,7 +98,7 @@ struct PLINE
     VNODE head;
     unsigned int Count;
     double area;
-    void *tree;
+    rtree_t *tree;
     struct {
       unsigned int status:3;
       unsigned int orient:1;
@@ -128,6 +128,7 @@ struct POLYAREA
 {
     POLYAREA *f, *b;
     PLINE *contours;
+    rtree_t *contour_tree;
 };
 
 BOOLp poly_M_Copy0(POLYAREA ** dst, const POLYAREA * srcfst);
diff --git a/src/polygon.c b/src/polygon.c
index 181a6c3..71d1b2e 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -130,10 +130,12 @@ add_noholes_polyarea (PolygonType *noholes_poly, void *user_data)
   POLYAREA *new_area;
 
   new_area = malloc (sizeof (POLYAREA) * 1);
+  new_area->contour_tree = r_create_tree (NULL, 0, 0);
 
   /* Allocate a new PLINE, COPY the PLINE from the passed polygon */
   poly_CopyContour (&pline, noholes_poly->Clipped->contours);
   new_area->contours = pline;
+  r_insert_entry (new_area->contour_tree, (BoxType *)pline, 0);
 
   /* Link the new POLYAREA into the NoHoles circularaly linked list */
   if (poly->NoHoles)
@@ -1607,14 +1609,23 @@ IsRectangleInPolygon (LocationType X1, LocationType Y1, LocationType X2,
 }
 
 static void
-r_NoHolesPolygonDicer (PLINE * p, void (*emit) (PolygonTypePtr, void *), void *user_data)
+r_NoHolesPolygonDicer (POLYAREA * pa, void (*emit) (PolygonTypePtr, void *), void *user_data)
 {
+  PLINE *p = pa->contours;
+#if 0
   POLYAREA *pa;
 
   pa = (POLYAREA *) malloc (sizeof (*pa));
+#endif
+#warning DO WE NEED TO SAVE THIS POINTER?
   pa->b = pa->f = pa;
-  pa->contours = p;
-  if (!p->next)                 /* no holes */
+#if 0
+  pa->contours = inp->contours;
+  pa->contour_tree = r_create_tree (NULL, 0, 0);
+#endif
+
+
+  if (!pa->contours->next)                 /* no holes */
     {
       PolygonType poly;
       PointType pts[4];
@@ -1651,30 +1662,33 @@ r_NoHolesPolygonDicer (PLINE * p, void (*emit) (PolygonTypePtr, void *), void *u
       poly_AndSubtract_free (pa, poly2, &left, &right);
       if (left)
         {
-          POLYAREA *x, *y;
-          x = left;
+          POLYAREA *cur, *next;
+          cur = left;
           do
             {
-              PLINE *pl = x->contours;
-              r_NoHolesPolygonDicer (pl, emit, user_data);
-              y = x->f;
+              next = cur->f;
+//              PLINE *pl = x->contours;
+              r_NoHolesPolygonDicer (cur, emit, user_data);
+//              y = x->f;
               /* the pline was already freed by its use int he recursive dicer */
-              free (x);
+//              free (x);
             }
-          while ((x = y) != left);
+          while ((cur = next) != left);
+//          while ((x = y) != left);
         }
       if (right)
         {
-          POLYAREA *x, *y;
-          x = right;
+          POLYAREA *cur, *next;
+          cur = right;
           do
             {
-              PLINE *pl = x->contours;
-              r_NoHolesPolygonDicer (pl, emit, user_data);
-              y = x->f;
-              free (x);
+              next = cur->f;
+//              PLINE *pl = x->contours;
+              r_NoHolesPolygonDicer (cur, emit, user_data);
+//              y = x->f;
+//              free (x);
             }
-          while ((x = y) != right);
+          while ((cur = next) != right);
         }
     }
 }
@@ -1705,13 +1719,15 @@ NoHolesPolygonDicer (PolygonTypePtr p, void (*emit) (PolygonTypePtr, void *),
   /* now dice it up */
   do
     {
-      POLYAREA *prev;
-      r_NoHolesPolygonDicer (save->contours, emit, user_data);
+      POLYAREA *next;
+      next = save->f;
+
+      r_NoHolesPolygonDicer (save, emit, user_data);
       /* go to next poly (could be one because of clip) */
-      prev = save;
-      save = prev->f;
+
+      save = next;
       /* free the previouse POLYAREA. Note the contour was consumed in the dicer */
-      free (prev);
+//      free (prev);
     }
   while (save != ans);
 }
diff --git a/src/polygon1.c b/src/polygon1.c
index 7eabb81..7f5db0b 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -38,13 +38,15 @@
       all cases where original (Klamer Schutte) code is present
       are marked
 */
-
+//#define NDEBUG
 #include	<assert.h>
 #include	<stdlib.h>
 #include	<stdio.h>
 #include	<setjmp.h>
 #include	<math.h>
 #include	<string.h>
+
+#include "global.h"
 #include "polyarea.h"
 #include "rtree.h"
 #include "heap.h"
@@ -101,7 +103,7 @@ if (((ptr) = malloc(sizeof(type))) == NULL) \
 #undef DEBUG_LABEL
 #undef DEBUG_ALL_LABELS
 #undef DEBUG_JUMP
-#undef DEBUG_GATHER
+#define DEBUG_GATHER
 #undef DEBUG_ANGLE
 #undef DEBUG
 #ifdef DEBUG
@@ -647,7 +649,7 @@ seg_in_seg (const BoxType * b, void *cl)
       if (res & 2)
 	{
 	  cntrbox_adjust (i->s->p, cnt > 1 ? s2 : s1);
-	  if (adjust_tree ((rtree_t *) (i->s->p->tree), i->s))
+	  if (adjust_tree (i->s->p->tree, i->s))
 	    return 1;
 	}
       /* if we added a node in the tree we need to change the tree */
@@ -790,12 +792,12 @@ contour_bounds_touch (const BoxType * b, void *cl)
       /* fill in the segment in info corresponding to this node */
       if (setjmp (info.sego) == 0)
         {
-          r_search ((rtree_t *) (looping_over->tree), &box, NULL, get_seg, &info);
+          r_search (looping_over->tree, &box, NULL, get_seg, &info);
           assert (0);
         }
 
         /* NB: If this actually hits anything, we are teleported back to the beginning */
-        info.tree = (rtree_t *) rtree_over->tree;
+        info.tree = rtree_over->tree;
         if (info.tree)
           if (UNLIKELY (r_search (info.tree, &info.s->box,
                                   seg_in_region, seg_in_seg, &info)))
@@ -809,44 +811,20 @@ static int
 intersect (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
 {
   POLYAREA *t;
-  PLINE *pa, *pb;
-  int ca = 0, cb = 0;
+  PLINE *pa;
   contour_info c_info;
-  rtree_t *b_contour_tree = NULL;
 
-  /* count the contours in a and b */
-  for (pa = a->contours; pa; pa = pa->next, ca++);
-  for (pb = b->contours; pb; pb = pb->next, cb++);
-
-  /* Make the contour r-tree from the one with fewest contours */
-  /* Inserting entries is more expensive than searching
-   * the r-tree. We do one ca times, the other cb times. */
-  if (ca < cb)
+  /* Search the r-tree of the object with most contours
+   * We loop over the contours of "a". Swap if necessary.
+   */
+  if (a->contour_tree->size > b->contour_tree->size)
     {
       t = b;
       b = a;
       a = t;
     }
 
-#if 0
-  setjmp (c_info.restart);		/* we loop back here whenever a vertex is inserted */
-
-  /* Since we may have already executed the function body already, we need to clean up */
-  if (b_contour_tree != NULL)
-    r_destroy_tree (&b_contour_tree);
-#endif
-
-  /* make an rtree of b's contours */
-  b_contour_tree = r_create_tree (NULL, 0, 0);
-  for (pb = b->contours; pb != NULL; pb = pb->next)
-    r_insert_entry (b_contour_tree, (const BoxType *) pb, 0);
-
-#if 1
-#warning We might actually need to re-build the r_tree if the geometry changes
   setjmp (c_info.restart);		/* we loop back here whenever a vertex is inserted */
-#endif
-
-//  printf ("Done making r-tree of b's contours\n");
 
   for (pa = a->contours; pa; pa = pa->next)     /* Loop over the contours of POLYAREA "a" */
     {
@@ -864,8 +842,6 @@ intersect (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
             {
               /* The intersection test short-circuited back here,
                * we need to clean up, then longjmp to jb */
-//                printf ("short circuited here\n");
-              r_destroy_tree (&b_contour_tree);
               longjmp (*jb, retval);
             }
           c_info.getout = &out;
@@ -876,7 +852,7 @@ intersect (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
       sb.X2 = pa->xmax + 1;
       sb.Y2 = pa->ymax + 1;
 
-      r_search ((rtree_t *) (b_contour_tree), &sb, NULL, contour_bounds_touch, &c_info);
+      r_search (b->contour_tree, &sb, NULL, contour_bounds_touch, &c_info);
     }
 
   return 0;
@@ -889,8 +865,10 @@ M_POLYAREA_intersect (jmp_buf * e, POLYAREA * afst, POLYAREA * bfst, int add)
   PLINE *curcA, *curcB;
   CVCList *the_list = NULL;
 
-  if (a == NULL || b == NULL)
+  if (a == NULL || b == NULL) {
+    printf ("a or b is null in M_POLYAREA_intersect\n");
     error (err_bad_parm);
+  }
   do
     {
       do
@@ -1112,6 +1090,7 @@ M_POLYAREA_label (POLYAREA * afst, POLYAREA * b, BOOLp touch)
 
 /****************************************************************/
 
+#warning are contour r-trees needed for the temporary polyareas?
 /* routines for temporary storing resulting contours */
 static void
 InsCntr (jmp_buf * e, PLINE * c, POLYAREA ** dst)
@@ -1132,31 +1111,48 @@ InsCntr (jmp_buf * e, PLINE * c, POLYAREA ** dst)
       newp->f->b = newp->b->f = newp;
     }
   newp->contours = c;
+  newp->contour_tree = r_create_tree (NULL, 0, 0);
+  r_insert_entry (newp->contour_tree, (BoxTypePtr) c, 0);
   c->next = NULL;
 }				/* InsCntr */
 
 static void
 PutContour (jmp_buf * e, PLINE * cntr, POLYAREA ** contours, PLINE ** holes,
-	    PLINE * parent)
+            POLYAREA *owner, POLYAREA * parent, PLINE * parent_contour)
 {
   assert (cntr != NULL);
   assert (cntr->Count > 2);
   cntr->next = NULL;
+
   if (cntr->Flags.orient == PLF_DIR)
-    InsCntr (e, cntr, contours);
+    {
+      if (owner != NULL)
+        r_delete_entry (owner->contour_tree, (BoxType *)cntr);
+      InsCntr (e, cntr, contours);
+    }
   /* put hole into temporary list */
   else
     {
       /* if we know this belongs inside the parent, put it there now */
-      if (parent)
+      if (parent_contour)
 	{
-	  cntr->next = parent->next;
-	  parent->next = cntr;
+	  cntr->next = parent_contour->next;
+	  parent_contour->next = cntr;
+          if (owner != parent)
+            {
+              if (owner != NULL)
+                r_delete_entry (owner->contour_tree, (BoxType *)cntr);
+              r_insert_entry (parent->contour_tree, (BoxType *)cntr, 0);
+            }
 	}
       else
 	{
 	  cntr->next = *holes;
 	  *holes = cntr;	/* let cntr be 1st hole in list */
+          /* We don't insert the holes into an r-tree,
+           * they just form a linked list */
+          if (owner != NULL)
+            r_delete_entry (owner->contour_tree, (BoxType *)cntr);
 	}
     }
 }				/* PutContour */
@@ -1182,9 +1178,12 @@ InsertHoles (jmp_buf * e, POLYAREA * dest, PLINE ** src)
 
   if (*src == NULL)
     return;			/* empty hole list */
-  if (dest == NULL)
+  if (dest == NULL) {
+    printf ("dest is null un InsertHoles\n");
     error (err_bad_parm);	/* empty contour list */
+  }
 
+#warning IF Passed a PourType, we would get this r-tree for free??
   /* make an rtree of contours */
   tree = r_create_tree (NULL, 0, 0);
   curc = dest;
@@ -1210,6 +1209,7 @@ InsertHoles (jmp_buf * e, POLYAREA * dest, PLINE ** src)
 #endif
 #endif
 	  poly_DelContour (&curh);
+    printf ("Badparm hi there\n");
 	  error (err_bad_parm);
 	}
       /* Now search the heap for the container. If there was only one item
@@ -1248,6 +1248,7 @@ InsertHoles (jmp_buf * e, POLYAREA * dest, PLINE ** src)
 #endif
 	  curh->next = NULL;
 	  poly_DelContour (&curh);
+    printf ("Howdy\n");
 	  error (err_bad_parm);
 	}
       else
@@ -1256,6 +1257,21 @@ InsertHoles (jmp_buf * e, POLYAREA * dest, PLINE ** src)
 	  tmp = container->next;
 	  container->next = curh;
 	  curh->next = tmp;
+
+#warning WHICH POLYAREA GOT THIS - STUPID LONG SEARCH - STORE IN HEAP STRUCTURE INSTEAD!!
+          curc = dest;
+          do
+            {
+              if (curc->contours == container)
+                break;
+            }
+          while ((curc = curc->f) != dest);
+          if (curc->contours == container)
+            {
+              r_insert_entry (curc->contour_tree, (BoxTypePtr) curh, 0);
+            }
+          else
+            printf ("Badness\n");
 	}
     }
   r_destroy_tree (&tree);
@@ -1490,7 +1506,7 @@ Collect1 (jmp_buf * e, VNODE *cur, DIRECTION dir, POLYAREA **contours, PLINE **
 	    DEBUGP ("adding contour with %d verticies and direction %c\n",
 		    p->Count, p->Flags.orient ? 'F' : 'B');
 #endif
-	    PutContour (e, p, contours, holes, NULL);
+	    PutContour (e, p, contours, holes, NULL, NULL, NULL);
 	  }
 	else
 	  {
@@ -1507,7 +1523,7 @@ Collect (jmp_buf * e, PLINE * a, POLYAREA ** contours, PLINE ** holes,
 	 S_Rule s_rule, J_Rule j_rule)
 {
   VNODE *cur, *other;
-  DIRECTION dir;
+  DIRECTION dir = FORW; /* Not sure, but stops valgrind complaining */
 
   cur = &a->head;
   do
@@ -1524,7 +1540,7 @@ Collect (jmp_buf * e, PLINE * a, POLYAREA ** contours, PLINE ** holes,
 
 static int
 cntr_Collect (jmp_buf * e, PLINE ** A, POLYAREA ** contours, PLINE ** holes,
-	      int action, PLINE * parent)
+	      int action, POLYAREA *owner, POLYAREA * parent, PLINE *parent_contour)
 {
   PLINE *tmprev;
 
@@ -1554,10 +1570,10 @@ cntr_Collect (jmp_buf * e, PLINE ** A, POLYAREA ** contours, PLINE ** holes,
 	  if ((*A)->Flags.status == INSIDE)
 	    {
 	      tmprev = *A;
-	      /* disappear this contour */
+	      /* disappear this contour (rtree entry remove int PutContour) */
 	      *A = tmprev->next;
 	      tmprev->next = NULL;
-	      PutContour (e, tmprev, contours, holes, NULL);
+	      PutContour (e, tmprev, contours, holes, owner, NULL, NULL);
 	      return TRUE;
 	    }
 	  break;
@@ -1565,11 +1581,11 @@ cntr_Collect (jmp_buf * e, PLINE ** A, POLYAREA ** contours, PLINE ** holes,
 	  if ((*A)->Flags.status == INSIDE)
 	    {
 	      tmprev = *A;
-	      /* disappear this contour */
+	      /* disappear this contour (rtree entry remove int PutContour) */
 	      *A = tmprev->next;
 	      tmprev->next = NULL;
 	      poly_InvContour (tmprev);
-	      PutContour (e, tmprev, contours, holes, NULL);
+	      PutContour (e, tmprev, contours, holes, owner, NULL, NULL);
 	      return TRUE;
 	    }
 	  break;
@@ -1578,10 +1594,10 @@ cntr_Collect (jmp_buf * e, PLINE ** A, POLYAREA ** contours, PLINE ** holes,
 	  if ((*A)->Flags.status == OUTSIDE)
 	    {
 	      tmprev = *A;
-	      /* disappear this contour */
+	      /* disappear this contour (rtree entry remove int PutContour) */
 	      *A = tmprev->next;
 	      tmprev->next = NULL;
-	      PutContour (e, tmprev, contours, holes, parent);
+	      PutContour (e, tmprev, contours, holes, owner, parent, parent_contour);
 	      return TRUE;
 	    }
 	  break;
@@ -1618,7 +1634,7 @@ M_B_AREA_Collect (jmp_buf * e, POLYAREA * bfst, POLYAREA ** contours,
 		next = cur;
 		tmp->next = NULL;
 		tmp->Flags.status = UNKNWN;
-		PutContour (e, tmp, contours, holes, NULL);
+		PutContour (e, tmp, contours, holes, NULL, NULL, NULL); /* b */
 		break;
 	      case PBO_UNITE:
 		break;		/* nothing to do - already included */
@@ -1634,7 +1650,7 @@ M_B_AREA_Collect (jmp_buf * e, POLYAREA * bfst, POLYAREA ** contours,
 		next = cur;
 		tmp->next = NULL;
 		tmp->Flags.status = UNKNWN;
-		PutContour (e, tmp, contours, holes, NULL);
+		PutContour (e, tmp, contours, holes, NULL, NULL, NULL); /* b */
 		break;
 	      case PBO_ISECT:
 	      case PBO_SUB:
@@ -1651,7 +1667,8 @@ M_POLYAREA_Collect (jmp_buf * e, POLYAREA * afst, POLYAREA ** contours,
 		    PLINE ** holes, int action, BOOLp maybe)
 {
   POLYAREA *a = afst;
-  PLINE **cur, **next, *parent;
+  POLYAREA *parent = NULL; /* Quiet GCC warning */
+  PLINE **cur, **next, *parent_contour;
 
   assert (a != NULL);
   while ((a = a->f) != afst);
@@ -1659,18 +1676,37 @@ M_POLYAREA_Collect (jmp_buf * e, POLYAREA * afst, POLYAREA ** contours,
   do
     {
       if (maybe && a->contours->Flags.status != ISECTED)
-	parent = a->contours;
+          parent_contour = a->contours;
       else
-	parent = NULL;
-      for (cur = &a->contours; *cur != NULL; cur = next)
-	{
-	  next = &((*cur)->next);
-	  /* if we disappear a contour, don't advance twice */
-	  if (cntr_Collect
-	      (e, cur, contours, holes, action,
-	       *cur == parent ? NULL : parent))
-	    next = cur;
-	}
+          parent_contour = NULL;
+
+      /* Take care of the first contour - so we know if we
+       * can shortcut reparenting some of its children
+       */
+      cur = &a->contours;
+      if (*cur != NULL)
+        {
+          next = &((*cur)->next);
+          /* if we disappear a contour, don't advance twice */
+          if (cntr_Collect (e, cur, contours, holes, action, a, NULL, NULL))
+            {
+              parent = (*contours)->b; /* InsCntr inserts behind the head */
+              next = cur;
+            }
+          else
+            parent = a;
+          cur = next;
+        }
+      for ( ; *cur != NULL; cur = next)
+        {
+          next = &((*cur)->next);
+          /* if we disappear a contour, don't advance twice */
+          if (*cur == parent_contour)
+            printf ("WTF??\n");
+          if (cntr_Collect (e, cur, contours, holes, action, a, parent,
+                            (*cur == parent_contour) ? NULL : parent_contour))
+            next = cur;
+        }
     }
   while ((a = a->f) != afst);
 }
@@ -2091,7 +2127,7 @@ poly_InvContour (PLINE * c)
   c->Flags.orient ^= 1;
   if (c->tree)
     {
-      r = r_search ((rtree_t *) (c->tree), NULL, NULL, flip_cb, NULL);
+      r = r_search (c->tree, NULL, NULL, flip_cb, NULL);
       assert (r == c->Count);
     }
 }
@@ -2174,6 +2210,7 @@ poly_Copy0 (POLYAREA ** dst, const POLYAREA * src)
     *dst = calloc (1, sizeof (POLYAREA));
   if (*dst == NULL)
     return FALSE;
+  (*dst)->contour_tree = r_create_tree (NULL, 0, 0);
 
   return poly_Copy1 (*dst, src);
 }
@@ -2190,6 +2227,7 @@ poly_Copy1 (POLYAREA * dst, const POLYAREA * src)
     {
       if (!poly_CopyContour (last, cur))
 	return FALSE;
+      r_insert_entry (dst->contour_tree, (BoxTypePtr) *last, 0);
       last = &(*last)->next;
     }
   return TRUE;
@@ -2239,6 +2277,7 @@ poly_InclContour (POLYAREA * p, PLINE * c)
       if (p->contours != NULL)
 	return FALSE;
       p->contours = c;
+      r_insert_entry (p->contour_tree, (BoxTypePtr) c, 0);
     }
   else
     {
@@ -2248,6 +2287,7 @@ poly_InclContour (POLYAREA * p, PLINE * c)
       tmp = p->contours->next;
       p->contours->next = c;
       c->next = tmp;
+      r_insert_entry (p->contour_tree, (BoxTypePtr) c, 0);
     }
   return TRUE;
 }
@@ -2319,7 +2359,7 @@ poly_InsideContour (PLINE * c, Vector p)
   ray.X2 = 0x7fffffff;
   ray.Y2 = p[1] + 1;
   if (setjmp (info.env) == 0)
-    r_search ((rtree_t *) c->tree, &ray, NULL, crossing, &info);
+    r_search (c->tree, &ray, NULL, crossing, &info);
   return info.f;
 }
 
@@ -2373,6 +2413,7 @@ poly_Init (POLYAREA * p)
 {
   p->f = p->b = p;
   p->contours = NULL;
+  p->contour_tree = r_create_tree (NULL, 0, 0);
 }
 
 POLYAREA *
@@ -2396,13 +2437,13 @@ poly_Clear (POLYAREA * P)
       P->contours = p->next;
       poly_DelContour (&p);
     }
+  r_destroy_tree (&P->contour_tree);
 }
 
 void
 poly_Free (POLYAREA ** p)
 {
   POLYAREA *cur;
-
   if (*p == NULL)
     return;
   for (cur = (*p)->f; cur != *p; cur = (*p)->f)
diff --git a/src/report.c b/src/report.c
index af9e0b3..66cfb51 100644
--- a/src/report.c
+++ b/src/report.c
@@ -315,7 +315,7 @@ ReportDialog (int argc, char **argv, int x, int y)
 	if (gui->shift_is_pressed ())
 	  {
 	    LayerTypePtr layer = (LayerTypePtr) ptr1;
-	    __r_dump_tree (layer->polygon_tree->root, 0);
+//	    __r_dump_tree (layer->polygon_tree->root, 0);
 	    return;
 	  }
 #endif
diff --git a/src/rtree.c b/src/rtree.c
index 3b30a56..f186edc 100644
--- a/src/rtree.c
+++ b/src/rtree.c
@@ -217,7 +217,8 @@ __r_tree_is_good (struct rtree_node *node)
   return 1;
 }
 #endif
-#ifndef NDEBUG
+
+#if 1 //ndef NDEBUG
 /* print out the tree */
 void
 __r_dump_tree (struct rtree_node *node, int depth)

Bottom: e0866230453bfc82b705950349844a4715d15c7c
Top:    6f22d8801eb0c12043db0aa33a7b3c58a73fcd12
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2008-10-12 22:19:59 +0100

Try something with the rtrees







---

diff --git a/src/find.c b/src/find.c
index 563819e..fb06e23 100644
--- a/src/find.c
+++ b/src/find.c
@@ -2478,10 +2478,9 @@ LookupLOConnectionsToPolygon (PolygonTypePtr Polygon, Cardinal LayerGroup)
   Cardinal entry;
   struct lo_info info;
 
-  if (!Polygon->Clipped){
-    printf ("Returning because polygon wasn't clipped in LookupLOConnectionsToPolygon\n");
+  if (!Polygon->Clipped)
     return False;
-  }
+
   info.polygon = *Polygon;
   EXPAND_BOUNDS (&info.polygon);
   info.layer = LayerGroup;
@@ -2537,6 +2536,7 @@ LookupLOConnectionsToPolygon (PolygonTypePtr Polygon, Cardinal LayerGroup)
             }
         }
     }
+
   return (False);
 }
 
diff --git a/src/polyarea.h b/src/polyarea.h
index 42acc1a..819b074 100644
--- a/src/polyarea.h
+++ b/src/polyarea.h
@@ -128,6 +128,7 @@ struct POLYAREA
 {
     POLYAREA *f, *b;
     PLINE *contours;
+    void *contour_tree;
 };
 
 BOOLp poly_M_Copy0(POLYAREA ** dst, const POLYAREA * srcfst);
diff --git a/src/polygon1.c b/src/polygon1.c
index 1b4f7fb..870500f 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -529,6 +529,12 @@ cntrbox_adjust (PLINE * c, Vector p)
 
 /* some structures for handling segment intersections using the rtrees */
 
+typedef struct contour
+{
+  BoxType box;
+  PLINE *p;
+} contour;
+
 typedef struct seg
 {
   BoxType box;
@@ -1882,7 +1888,7 @@ poly_AndSubtract_free (POLYAREA * ai, POLYAREA * bi,
       poly_Free (&b);
       assert (poly_Valid (*aminusb));
     }
-  /* delete holes if any left */
+  /* delete holes if any left *poly_DelContour */
   while ((p = holes) != NULL)
     {
       holes = p->next;
@@ -2426,13 +2432,14 @@ inside_sector (VNODE * pn, Vector p2)
 BOOLp
 poly_ChkContour (PLINE * a)
 {
-#warning FIXME Later: Deliberately disabled this test - seems something strange is going on
-  return FALSE;
   VNODE *a1, *a2, *a2_start, *hit1, *hit2;
   Vector i1, i2;
   int icnt;
   double d1,d2;
 
+#warning FIXME Later: Deliberately disabled this test - seems something strange is going on
+  return FALSE;
+
   assert (a != NULL);
   a1 = &a->head;
   do
diff --git a/src/pour.c b/src/pour.c
index 03c3911..3e272ac 100644
--- a/src/pour.c
+++ b/src/pour.c
@@ -294,7 +294,40 @@ DestroyPolygonInPour (PourTypePtr pour, PolygonTypePtr polygon)
   return (NULL);
 }
 
-static int
+/*static*/ int
+subtract_wonkyline_poly (POLYAREA * np1, POLYAREA **pg)
+{
+  POLYAREA *merged = NULL, *np = np1;
+  int x;
+
+  assert (np);
+  assert (pg);
+  assert (*pg);
+
+  if (pg == NULL)
+    {
+      printf ("Hmm, got pg == NULL in subtract_poly\n");
+      poly_Free (&np);
+      return -1;
+    }
+
+  assert (poly_Valid (*pg));
+  assert (poly_Valid (np));
+  x = poly_Boolean_free (*pg, np, &merged, PBO_SUB);
+  if (x != err_ok)
+    {
+      fprintf (stderr, "Error while clipping PBO_SUB: %d\n", x);
+      poly_Free (&merged);
+      return -1;
+    }
+
+  assert (!merged || poly_Valid (merged));
+
+  *pg = merged;
+  return 1;
+}
+
+/*static*/ int
 subtract_poly (POLYAREA * np1, POLYAREA **pg)
 {
   POLYAREA *merged = NULL, *np = np1;
@@ -536,8 +569,17 @@ line_sub_callback (const BoxType * b, void *cl)
   if (np == NULL)
     return 0;
 
-  if (subtract_poly (np, &info->pg) < 0)
-    longjmp (info->env, 1);
+  if (line->Point1.X == line->Point2.X ||
+      line->Point1.Y == line->Point2.Y)
+    {
+      if (subtract_poly (np, &info->pg) < 0)
+        longjmp (info->env, 1);
+    }
+  else
+    {
+      if (subtract_wonkyline_poly (np, &info->pg) < 0)
+        longjmp (info->env, 1);
+    }
   return 1;
 }
 
@@ -637,11 +679,21 @@ ClearPour (DataTypePtr Data, LayerTypePtr Layer, PourType * pour,
 
   if (setjmp (info.env) == 0)
     {
-      r  = r_search (Data->via_tree, &region, NULL, pin_sub_callback, &info);
+#warning I KNOW THIS IS THE SLOW PATH, profile it first so I can stop part way
+#if 1
+      GROUP_LOOP (Data, group);
+      {
+        r = r_search (layer->line_tree, &region, NULL, line_sub_callback, &info);
+      }
+      END_LOOP;
+#endif
+
+//      r = 0;
+      r += r_search (Data->via_tree, &region, NULL, pin_sub_callback, &info);
       r += r_search (Data->pin_tree, &region, NULL, pin_sub_callback, &info);
       GROUP_LOOP (Data, group);
       {
-        r += r_search (layer->line_tree, &region, NULL, line_sub_callback, &info);
+//        r += r_search (layer->line_tree, &region, NULL, line_sub_callback, &info);
         r += r_search (layer->arc_tree,  &region, NULL, arc_sub_callback,  &info);
         r += r_search (layer->text_tree, &region, NULL, text_sub_callback, &info);
         r += r_search (layer->pour_tree, &region, NULL, pour_sub_callback, &info);
diff --git a/src/rtree.c b/src/rtree.c
index 662c581..36d9f60 100644
--- a/src/rtree.c
+++ b/src/rtree.c
@@ -61,6 +61,33 @@
 
 RCSID ("$Id$");
 
+/* G_LIKELY and G_UNLIKLEY macros taken from GLib 2.16.3, LGPL */
+/*
+ * The G_LIKELY and G_UNLIKELY macros let the programmer give hints to 
+ * the compiler about the expected result of an expression. Some compilers
+ * can use this information for optimizations.
+ *
+ * The _G_BOOLEAN_EXPR macro is intended to trigger a gcc warning when
+ * putting assignments in g_return_if_fail ().  
+ */
+#if defined(__GNUC__) && (__GNUC__ > 2) && defined(__OPTIMIZE__)
+#define _G_BOOLEAN_EXPR(expr)                   \
+ __extension__ ({                               \
+   int _g_boolean_var_;                         \
+   if (expr)                                    \
+      _g_boolean_var_ = 1;                      \
+   else                                         \
+      _g_boolean_var_ = 0;                      \
+   _g_boolean_var_;                             \
+})
+#define G_LIKELY(expr) (__builtin_expect (_G_BOOLEAN_EXPR(expr), 1))
+#define G_UNLIKELY(expr) (__builtin_expect (_G_BOOLEAN_EXPR(expr), 0))
+#else
+#define G_LIKELY(expr) (expr)
+#define G_UNLIKELY(expr) (expr)
+#warning NOT OPTIMISING
+#endif
+
 
 #define SLOW_ASSERTS
 /* All rectangles are closed on the bottom left and open on the
@@ -913,7 +940,8 @@ __r_insert_node (struct rtree_node *node, const BoxType * query,
     {
       register int i;
 
-      if (manage)
+#warning UNLIKELY BASED ON QTY OF CALLERS PASSING manage=0 IN PCB, NOT PROFILING
+      if (G_UNLIKELY (manage))
         {
           register int flag = 1;

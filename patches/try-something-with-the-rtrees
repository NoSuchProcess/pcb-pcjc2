Bottom: b07d6d4e92a96fef9d52a389c9485bbe3ec1b013
Top:    67e1c38be7b269bda52cc61f6e45e04bf97f9453
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2008-10-15 07:54:07 +0100

Try optimising polygon operations by keeping an rtree with their contours

InsertHoles() already creates an rtree of contours to do its internal
processing, and it is possible that intersect() could be sped up by
its existance as well.





---

diff --git a/src/polyarea.h b/src/polyarea.h
index 42acc1a..819b074 100644
--- a/src/polyarea.h
+++ b/src/polyarea.h
@@ -128,6 +128,7 @@ struct POLYAREA
 {
     POLYAREA *f, *b;
     PLINE *contours;
+    void *contour_tree;
 };
 
 BOOLp poly_M_Copy0(POLYAREA ** dst, const POLYAREA * srcfst);
diff --git a/src/polygon.c b/src/polygon.c
index 0f95bbb..f38a610 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -83,10 +83,12 @@ add_noholes_polyarea (PolygonType *noholes_poly, void *user_data)
   POLYAREA *new_area;
 
   new_area = malloc (sizeof (POLYAREA) * 1);
+  new_area->contour_tree = r_create_tree (NULL, 0, 0);
 
   /* Allocate a new PLINE, COPY the PLINE from the passed polygon */
   poly_CopyContour (&pline, noholes_poly->Clipped->contours);
   new_area->contours = pline;
+  r_insert_entry (new_area->contour_tree, (BoxType *)pline, 0);
 
   /* Link the new POLYAREA into the NoHoles circularaly linked list */
   if (poly->NoHoles)
@@ -905,14 +907,23 @@ IsRectangleInPolygon (LocationType X1, LocationType Y1, LocationType X2,
 }
 
 static void
-r_NoHolesPolygonDicer (PLINE * p, void (*emit) (PolygonTypePtr, void *), void *user_data)
+r_NoHolesPolygonDicer (POLYAREA * pa, void (*emit) (PolygonTypePtr, void *), void *user_data)
 {
+  PLINE *p = pa->contours;
+#if 0
   POLYAREA *pa;
 
   pa = (POLYAREA *) malloc (sizeof (*pa));
+#endif
+#warning DO WE NEED TO SAVE THIS POINTER?
   pa->b = pa->f = pa;
-  pa->contours = p;
-  if (!p->next)                 /* no holes */
+#if 0
+  pa->contours = inp->contours;
+  pa->contour_tree = r_create_tree (NULL, 0, 0);
+#endif
+
+
+  if (!pa->contours->next)                 /* no holes */
     {
       PolygonType poly;
 //      PointType pts[4];
@@ -952,30 +963,33 @@ r_NoHolesPolygonDicer (PLINE * p, void (*emit) (PolygonTypePtr, void *), void *u
       poly_AndSubtract_free (pa, poly2, &left, &right);
       if (left)
         {
-          POLYAREA *x, *y;
-          x = left;
+          POLYAREA *cur, *next;
+          cur = left;
           do
             {
-              PLINE *pl = x->contours;
-              r_NoHolesPolygonDicer (pl, emit, user_data);
-              y = x->f;
+              next = cur->f;
+//              PLINE *pl = x->contours;
+              r_NoHolesPolygonDicer (cur, emit, user_data);
+//              y = x->f;
               /* the pline was already freed by its use int he recursive dicer */
-              free (x);
+//              free (x);
             }
-          while ((x = y) != left);
+          while ((cur = next) != left);
+//          while ((x = y) != left);
         }
       if (right)
         {
-          POLYAREA *x, *y;
-          x = right;
+          POLYAREA *cur, *next;
+          cur = right;
           do
             {
-              PLINE *pl = x->contours;
-              r_NoHolesPolygonDicer (pl, emit, user_data);
-              y = x->f;
-              free (x);
+              next = cur->f;
+//              PLINE *pl = x->contours;
+              r_NoHolesPolygonDicer (cur, emit, user_data);
+//              y = x->f;
+//              free (x);
             }
-          while ((x = y) != right);
+          while ((cur = next) != right);
         }
     }
 }
@@ -1006,13 +1020,15 @@ NoHolesPolygonDicer (PolygonTypePtr p, void (*emit) (PolygonTypePtr, void *),
   /* now dice it up */
   do
     {
-      POLYAREA *prev;
-      r_NoHolesPolygonDicer (save->contours, emit, user_data);
+      POLYAREA *next;
+      next = save->f;
+
+      r_NoHolesPolygonDicer (save, emit, user_data);
       /* go to next poly (could be one because of clip) */
-      prev = save;
-      save = prev->f;
+
+      save = next;
       /* free the previouse POLYAREA. Note the contour was consumed in the dicer */
-      free (prev);
+//      free (prev);
     }
   while (save != ans);
 }
diff --git a/src/polygon1.c b/src/polygon1.c
index 62e0705..c2f1eec 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -38,7 +38,7 @@
       all cases where original (Klamer Schutte) code is present
       are marked
 */
-
+//#define NDEBUG
 #include	<assert.h>
 #include	<stdlib.h>
 #include	<stdio.h>
@@ -101,7 +101,7 @@ if (((ptr) = malloc(sizeof(type))) == NULL) \
 #undef DEBUG_LABEL
 #undef DEBUG_ALL_LABELS
 #undef DEBUG_JUMP
-#undef DEBUG_GATHER
+#define DEBUG_GATHER
 #undef DEBUG_ANGLE
 #undef DEBUG
 #ifdef DEBUG
@@ -810,43 +810,19 @@ intersect (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
 {
   POLYAREA *t;
   PLINE *pa, *pb;
-  int ca = 0, cb = 0;
   contour_info c_info;
-  rtree_t *b_contour_tree = NULL;
-
-  /* count the contours in a and b */
-  for (pa = a->contours; pa; pa = pa->next, ca++);
-  for (pb = b->contours; pb; pb = pb->next, cb++);
 
-  /* Make the contour r-tree from the one with fewest contours */
-  /* Inserting entries is more expensive than searching
-   * the r-tree. We do one ca times, the other cb times. */
-  if (ca < cb)
+  /* Search the r-tree of the object with most contours
+   * We loop over the contours of "a". Swap if necessary.
+   */
+  if (((rtree_t *)a->contour_tree)->size > ((rtree_t *)b->contour_tree)->size)
     {
       t = b;
       b = a;
       a = t;
     }
 
-#if 0
-  setjmp (c_info.restart);		/* we loop back here whenever a vertex is inserted */
-
-  /* Since we may have already executed the function body already, we need to clean up */
-  if (b_contour_tree != NULL)
-    r_destroy_tree (&b_contour_tree);
-#endif
-
-  /* make an rtree of b's contours */
-  b_contour_tree = r_create_tree (NULL, 0, 0);
-  for (pb = b->contours; pb != NULL; pb = pb->next)
-    r_insert_entry (b_contour_tree, (const BoxType *) pb, 0);
-
-#if 1
-#warning We might actually need to re-build the r_tree if the geometry changes
   setjmp (c_info.restart);		/* we loop back here whenever a vertex is inserted */
-#endif
-
-//  printf ("Done making r-tree of b's contours\n");
 
   for (pa = a->contours; pa; pa = pa->next)     /* Loop over the contours of POLYAREA "a" */
     {
@@ -864,8 +840,6 @@ intersect (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
             {
               /* The intersection test short-circuited back here,
                * we need to clean up, then longjmp to jb */
-//                printf ("short circuited here\n");
-              r_destroy_tree (&b_contour_tree);
               longjmp (*jb, retval);
             }
           c_info.getout = &out;
@@ -876,7 +850,7 @@ intersect (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
       sb.X2 = pa->xmax + 1;
       sb.Y2 = pa->ymax + 1;
 
-      r_search ((rtree_t *) (b_contour_tree), &sb, NULL, contour_bounds_touch, &c_info);
+      r_search ((rtree_t *) (b->contour_tree), &sb, NULL, contour_bounds_touch, &c_info);
     }
 
   return 0;
@@ -889,8 +863,10 @@ M_POLYAREA_intersect2 (jmp_buf * e, POLYAREA * afst, POLYAREA * bfst, int add)
   PLINE *curcA, *curcB;
   CVCList *the_list = NULL;
 
-  if (a == NULL || b == NULL)
+  if (a == NULL || b == NULL) {
+    printf ("a or b is null in M_POLYAREA_intersect2\n");
     error (err_bad_parm);
+  }
   do
     {
       do
@@ -934,8 +910,10 @@ M_POLYAREA_intersect (jmp_buf * e, POLYAREA * afst, POLYAREA * bfst, int add)
   PLINE *curcA, *curcB;
   CVCList *the_list = NULL;
 
-  if (a == NULL || b == NULL)
+  if (a == NULL || b == NULL) {
+    printf ("a or b is null in M_POLYAREA_intersect\n");
     error (err_bad_parm);
+  }
   do
     {
       do
@@ -1151,6 +1129,7 @@ M_POLYAREA_label (POLYAREA * afst, POLYAREA * b, BOOLp touch)
 
 /****************************************************************/
 
+#warning are contour r-trees needed for the temporary polyareas?
 /* routines for temporary storing resulting contours */
 static void
 InsCntr (jmp_buf * e, PLINE * c, POLYAREA ** dst)
@@ -1171,31 +1150,41 @@ InsCntr (jmp_buf * e, PLINE * c, POLYAREA ** dst)
       newp->f->b = newp->b->f = newp;
     }
   newp->contours = c;
+  newp->contour_tree = r_create_tree (NULL, 0, 0);
+  r_insert_entry (newp->contour_tree, (BoxTypePtr) c, 0);
   c->next = NULL;
 }				/* InsCntr */
 
 static void
 PutContour (jmp_buf * e, PLINE * cntr, POLYAREA ** contours, PLINE ** holes,
-	    PLINE * parent)
+	    POLYAREA * parent, PLINE * parent_contour)
 {
   assert (cntr != NULL);
   assert (cntr->Count > 2);
   cntr->next = NULL;
+
   if (cntr->Flags.orient == PLF_DIR)
     InsCntr (e, cntr, contours);
   /* put hole into temporary list */
   else
     {
+#warning THIS SPEEDUP SHORTCUT IS HARD TO FIGURE OUT WITH r_trees
+#if 0
       /* if we know this belongs inside the parent, put it there now */
-      if (parent)
+      if (parent_contour)
 	{
-	  cntr->next = parent->next;
-	  parent->next = cntr;
+	  cntr->next = parent_contour->next;
+	  parent_contour->next = cntr;
+#warning FIXME HARDER, the r_tree entry needs to go wherever the parent contour got / will get attached.
+          r_insert_entry ((rtree_t *)parent, (BoxType *)cntr, 0);
 	}
       else
+#endif
 	{
 	  cntr->next = *holes;
 	  *holes = cntr;	/* let cntr be 1st hole in list */
+          /* We don't insert the holes into an r-tree,
+           * they just form a linked list */
 	}
     }
 }				/* PutContour */
@@ -1221,9 +1210,12 @@ InsertHoles (jmp_buf * e, POLYAREA * dest, PLINE ** src)
 
   if (*src == NULL)
     return;			/* empty hole list */
-  if (dest == NULL)
+  if (dest == NULL) {
+    printf ("dest is null un InsertHoles\n");
     error (err_bad_parm);	/* empty contour list */
+  }
 
+#warning IF Passed a PourType, we would get this r-tree for free??
   /* make an rtree of contours */
   tree = r_create_tree (NULL, 0, 0);
   curc = dest;
@@ -1249,6 +1241,7 @@ InsertHoles (jmp_buf * e, POLYAREA * dest, PLINE ** src)
 #endif
 #endif
 	  poly_DelContour (&curh);
+    printf ("Badparm hi there\n");
 	  error (err_bad_parm);
 	}
       /* Now search the heap for the container. If there was only one item
@@ -1287,6 +1280,7 @@ InsertHoles (jmp_buf * e, POLYAREA * dest, PLINE ** src)
 #endif
 	  curh->next = NULL;
 	  poly_DelContour (&curh);
+    printf ("Howdy\n");
 	  error (err_bad_parm);
 	}
       else
@@ -1295,6 +1289,21 @@ InsertHoles (jmp_buf * e, POLYAREA * dest, PLINE ** src)
 	  tmp = container->next;
 	  container->next = curh;
 	  curh->next = tmp;
+
+#warning WHICH POLYAREA GOT THIS - STUPID LONG SEARCH!!
+          curc = dest;
+          do
+            {
+              if (curc->contours == container)
+                break;
+            }
+          while ((curc = curc->f) != dest);
+          if (curc->contours == container)
+            {
+              r_insert_entry (curc->contour_tree, (BoxTypePtr) curh, 0);
+            }
+          else
+            printf ("Badness\n");
 	}
     }
   r_destroy_tree (&tree);
@@ -1529,7 +1538,7 @@ Collect1 (jmp_buf * e, VNODE *cur, DIRECTION dir, POLYAREA **contours, PLINE **
 	    DEBUGP ("adding contour with %d verticies and direction %c\n",
 		    p->Count, p->Flags.orient ? 'F' : 'B');
 #endif
-	    PutContour (e, p, contours, holes, NULL);
+	    PutContour (e, p, contours, holes, NULL, NULL);
 	  }
 	else
 	  {
@@ -1546,7 +1555,7 @@ Collect (jmp_buf * e, PLINE * a, POLYAREA ** contours, PLINE ** holes,
 	 S_Rule s_rule, J_Rule j_rule)
 {
   VNODE *cur, *other;
-  DIRECTION dir;
+  DIRECTION dir = FORW; /* Not sure, but stops valgrind complaining */
 
   cur = &a->head;
   do
@@ -1563,7 +1572,7 @@ Collect (jmp_buf * e, PLINE * a, POLYAREA ** contours, PLINE ** holes,
 
 static int
 cntr_Collect (jmp_buf * e, PLINE ** A, POLYAREA ** contours, PLINE ** holes,
-	      int action, PLINE * parent)
+	      int action, POLYAREA * parent, PLINE *parent_contour)
 {
   PLINE *tmprev;
 
@@ -1594,9 +1603,10 @@ cntr_Collect (jmp_buf * e, PLINE ** A, POLYAREA ** contours, PLINE ** holes,
 	    {
 	      tmprev = *A;
 	      /* disappear this contour */
+#warning Remove from RTREE?
 	      *A = tmprev->next;
 	      tmprev->next = NULL;
-	      PutContour (e, tmprev, contours, holes, NULL);
+	      PutContour (e, tmprev, contours, holes, NULL, NULL);
 	      return TRUE;
 	    }
 	  break;
@@ -1605,10 +1615,11 @@ cntr_Collect (jmp_buf * e, PLINE ** A, POLYAREA ** contours, PLINE ** holes,
 	    {
 	      tmprev = *A;
 	      /* disappear this contour */
+#warning Remove from RTREE?
 	      *A = tmprev->next;
 	      tmprev->next = NULL;
 	      poly_InvContour (tmprev);
-	      PutContour (e, tmprev, contours, holes, NULL);
+	      PutContour (e, tmprev, contours, holes, NULL, NULL);
 	      return TRUE;
 	    }
 	  break;
@@ -1618,9 +1629,10 @@ cntr_Collect (jmp_buf * e, PLINE ** A, POLYAREA ** contours, PLINE ** holes,
 	    {
 	      tmprev = *A;
 	      /* disappear this contour */
+#warning Remove from RTREE?
 	      *A = tmprev->next;
 	      tmprev->next = NULL;
-	      PutContour (e, tmprev, contours, holes, parent);
+	      PutContour (e, tmprev, contours, holes, parent, parent_contour);
 	      return TRUE;
 	    }
 	  break;
@@ -1657,7 +1669,7 @@ M_B_AREA_Collect (jmp_buf * e, POLYAREA * bfst, POLYAREA ** contours,
 		next = cur;
 		tmp->next = NULL;
 		tmp->Flags.status = UNKNWN;
-		PutContour (e, tmp, contours, holes, NULL);
+		PutContour (e, tmp, contours, holes, NULL, NULL);
 		break;
 	      case PBO_UNITE:
 		break;		/* nothing to do - already included */
@@ -1673,7 +1685,7 @@ M_B_AREA_Collect (jmp_buf * e, POLYAREA * bfst, POLYAREA ** contours,
 		next = cur;
 		tmp->next = NULL;
 		tmp->Flags.status = UNKNWN;
-		PutContour (e, tmp, contours, holes, NULL);
+		PutContour (e, tmp, contours, holes, NULL, NULL);
 		break;
 	      case PBO_ISECT:
 	      case PBO_SUB:
@@ -1690,7 +1702,8 @@ M_POLYAREA_Collect (jmp_buf * e, POLYAREA * afst, POLYAREA ** contours,
 		    PLINE ** holes, int action, BOOLp maybe)
 {
   POLYAREA *a = afst;
-  PLINE **cur, **next, *parent;
+  POLYAREA *parent;
+  PLINE **cur, **next, *parent_contours;
 
   assert (a != NULL);
   while ((a = a->f) != afst);
@@ -1698,17 +1711,31 @@ M_POLYAREA_Collect (jmp_buf * e, POLYAREA * afst, POLYAREA ** contours,
   do
     {
       if (maybe && a->contours->Flags.status != ISECTED)
-	parent = a->contours;
+        {
+          parent = a;
+          parent_contours = a->contours;
+        }
       else
-	parent = NULL;
+        {
+          parent = NULL;
+          parent_contours = NULL;
+        }
       for (cur = &a->contours; *cur != NULL; cur = next)
 	{
+          PLINE *tmp;
+          tmp = *cur;
 	  next = &((*cur)->next);
+#warning PERHAPS WE NEED TO REMOVE THE CONTOUR FROM THE RTREE BECORE CALLING THIS?
 	  /* if we disappear a contour, don't advance twice */
 	  if (cntr_Collect
-	      (e, cur, contours, holes, action,
-	       *cur == parent ? NULL : parent))
-	    next = cur;
+	      (e, cur, contours, holes, action, parent,
+	       *cur == parent_contours ? NULL : parent_contours))
+            {
+              next = cur;
+#warning SHOULD BE IN cntr_Collect??
+              r_delete_entry ((rtree_t *)a->contour_tree, (BoxType *)tmp);
+            }
+
 	}
     }
   while ((a = a->f) != afst);
@@ -2214,6 +2241,7 @@ poly_Copy0 (POLYAREA ** dst, const POLYAREA * src)
     *dst = calloc (1, sizeof (POLYAREA));
   if (*dst == NULL)
     return FALSE;
+  (*dst)->contour_tree = r_create_tree (NULL, 0, 0);
 
   return poly_Copy1 (*dst, src);
 }
@@ -2230,6 +2258,7 @@ poly_Copy1 (POLYAREA * dst, const POLYAREA * src)
     {
       if (!poly_CopyContour (last, cur))
 	return FALSE;
+      r_insert_entry (dst->contour_tree, (BoxTypePtr) *last, 0);
       last = &(*last)->next;
     }
   return TRUE;
@@ -2279,6 +2308,7 @@ poly_InclContour (POLYAREA * p, PLINE * c)
       if (p->contours != NULL)
 	return FALSE;
       p->contours = c;
+      r_insert_entry (p->contour_tree, (BoxTypePtr) c, 0);
     }
   else
     {
@@ -2288,6 +2318,7 @@ poly_InclContour (POLYAREA * p, PLINE * c)
       tmp = p->contours->next;
       p->contours->next = c;
       c->next = tmp;
+      r_insert_entry (p->contour_tree, (BoxTypePtr) c, 0);
     }
   return TRUE;
 }
@@ -2413,6 +2444,7 @@ poly_Init (POLYAREA * p)
 {
   p->f = p->b = p;
   p->contours = NULL;
+  p->contour_tree = r_create_tree (NULL, 0, 0);
 }
 
 POLYAREA *
@@ -2436,13 +2468,13 @@ poly_Clear (POLYAREA * P)
       P->contours = p->next;
       poly_DelContour (&p);
     }
+  r_destroy_tree ((rtree_t **)&P->contour_tree);
 }
 
 void
 poly_Free (POLYAREA ** p)
 {
   POLYAREA *cur;
-
   if (*p == NULL)
     return;
   for (cur = (*p)->f; cur != *p; cur = (*p)->f)
diff --git a/src/pour.c b/src/pour.c
index 1bdb1f9..bf56de4 100644
--- a/src/pour.c
+++ b/src/pour.c
@@ -318,6 +318,7 @@ subtract_poly (POLYAREA * np1, POLYAREA **pg)
     {
       fprintf (stderr, "Error while clipping PBO_SUB: %d\n", x);
       poly_Free (&merged);
+      *pg = NULL;
       return -1;
     }
 
@@ -340,6 +341,7 @@ unite_poly (POLYAREA * np, POLYAREA ** pg)
     {
       fprintf (stderr, "Error while clipping PBO_UNITE: %d\n", x);
       poly_Free (&merged);
+      *pg = NULL;
       return 0;
     }
   assert (!merged || poly_Valid (merged));
@@ -360,6 +362,7 @@ intersect_poly (POLYAREA * np, POLYAREA ** pg)
     {
       fprintf (stderr, "Error while clipping PBO_ISECT: %d\n", x);
       poly_Free (&merged);
+      *pg = NULL;
       return 0;
     }
   assert (!merged || poly_Valid (merged));
@@ -1176,13 +1179,19 @@ InitPourClip (DataTypePtr Data, LayerTypePtr layer, PourType * pour)
       printf ("Clipping returned NULL - can that be good?\n");
       return 0;
     }
-  assert (poly_Valid (clipped));
+//  assert (poly_Valid (clipped));
   if (TEST_FLAG (CLEARPOLYFLAG, pour))
     {
       /* Clip the pour against anything we can find in this layer */
       ClearPour (Data, layer, pour, &pg, NULL, UNSUBTRACT_BLOAT);
     }
 
+  if (pg == NULL)
+    {
+      printf ("Got pg == NULL for some reason\n");
+      return;
+    }
+
   count_all = count_added = 0;
   /* For each piece of the clipped up polygon, create a new child */
   start_pg = pg;
diff --git a/src/report.c b/src/report.c
index af1b67d..7c9011b 100644
--- a/src/report.c
+++ b/src/report.c
@@ -315,7 +315,7 @@ ReportDialog (int argc, char **argv, int x, int y)
 	if (gui->shift_is_pressed ())
 	  {
 	    LayerTypePtr layer = (LayerTypePtr) ptr1;
-	    __r_dump_tree (layer->polygon_tree->root, 0);
+//	    __r_dump_tree (layer->polygon_tree->root, 0);
 	    return;
 	  }
 #endif
diff --git a/src/rtree.c b/src/rtree.c
index 3b30a56..f186edc 100644
--- a/src/rtree.c
+++ b/src/rtree.c
@@ -217,7 +217,8 @@ __r_tree_is_good (struct rtree_node *node)
   return 1;
 }
 #endif
-#ifndef NDEBUG
+
+#if 1 //ndef NDEBUG
 /* print out the tree */
 void
 __r_dump_tree (struct rtree_node *node, int depth)

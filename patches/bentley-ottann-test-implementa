Bottom: 7625f2cbf529c07b1d0b9506d0e6d40862c00da7
Top:    ffcf5d6025a8cdbad7b37106d5c8d84fbf38b0c2
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-11-06 15:07:00 +0000

Bentley-Ottann test implementation


---

diff --git a/configure.ac b/configure.ac
index d7b0198..3ec426e 100644
--- a/configure.ac
+++ b/configure.ac
@@ -7,6 +7,8 @@ AM_INIT_AUTOMAKE([1.9])
 AC_GNU_SOURCE
 AM_CONFIG_HEADER([config.h])
 
+m4_include(configure.ac.system)	dnl checks for system functions, headers, libs
+
 ##########################################################################
 #
 # Try to figure out if we are building from git sources.
diff --git a/configure.ac.system b/configure.ac.system
new file mode 100644
index 0000000..3f6ab7e
--- /dev/null
+++ b/configure.ac.system
@@ -0,0 +1,164 @@
+dnl
+dnl Non-failing checks for functions, headers, libraries, etc go here
+dnl
+
+dnl ====================================================================
+dnl Feature checks
+dnl ====================================================================
+
+AM_CONDITIONAL(CROSS_COMPILING, test "x$cross_compiling" = "xyes")
+CAIRO_BIGENDIAN
+AC_ARG_ENABLE(atomic,
+	      [AS_HELP_STRING([--disable-atomic],
+			      [disable use of native atomic operations])],
+	      [use_atomic=$enableval], [use_atomic=yes])
+AS_IF([test "x$use_atomic" = "xyes"], [
+  CAIRO_CHECK_NATIVE_ATOMIC_PRIMITIVES
+  CAIRO_CHECK_ATOMIC_OP_NEEDS_MEMORY_BARRIER
+])
+AC_CHECK_SIZEOF(void *)
+AC_CHECK_SIZEOF(int)
+AC_CHECK_SIZEOF(long)
+AC_CHECK_SIZEOF(long long)
+AC_CHECK_SIZEOF(size_t)
+
+AC_MSG_CHECKING([for native Win32])
+case "$host" in
+  *-*-mingw*)
+    cairo_os_win32=yes
+    ;;
+  *)
+    cairo_os_win32=no
+    ;;
+esac
+AC_MSG_RESULT([$cairo_os_win32])
+AM_CONDITIONAL(OS_WIN32, test "$cairo_os_win32" = "yes")
+
+AC_MSG_CHECKING([for Sun Solaris (non-POSIX ctime_r)])
+case "$host" in
+    *-*-solaris*)
+	CFLAGS="$CFLAGS -D_POSIX_PTHREAD_SEMANTICS"
+	solaris_posix_pthread=yes
+	;;
+    *)
+	solaris_posix_pthread=no
+	;;
+esac
+AC_MSG_RESULT([$solaris_posix_pthread])
+
+dnl ====================================================================
+dnl Library checks
+dnl ====================================================================
+
+AC_CHECK_LIBM
+LIBS="$LIBS $LIBM"
+
+AC_CHECK_LIB(rt, sched_yield, [RT_LIBS=-lrt], [RT_LIBS=])
+CAIROPERF_LIBS=$RT_LIBS
+AC_SUBST(CAIROPERF_LIBS)
+
+has_shm_open=
+AC_CHECK_LIB(rt, shm_open, [
+	     SHM_LIBS=-lrt
+	     has_shm_open=yes
+	     ], [SHM_LIBS=])
+AM_CONDITIONAL(HAVE_SHM, test "x$has_shm_open" = "xyes")
+AC_SUBST(SHM_LIBS)
+
+AC_CHECK_LIB(socket, connect, [SOCKET_LIBS=-lsocket], [SOCKET_LIBS=])
+CAIROBOILERPLATE_LIBS=$SOCKET_LIBS
+AC_SUBST(CAIROBOILERPLATE_LIBS)
+
+dnl ====================================================================
+dnl Header/function checks
+dnl ====================================================================
+
+dnl check if we have a __builtin_return_address for the cairo-trace
+dnl utility.
+AC_MSG_CHECKING([for __builtin_return_address(0)])
+AC_TRY_COMPILE([],[__builtin_return_address(0);],
+		[have_builtin_return_address=yes],
+		[have_builtin_return_address=no])
+AC_MSG_RESULT($have_builtin_return_address)
+if test "x$have_builtin_return_address" = "xyes"; then
+    AC_DEFINE(HAVE_BUILTIN_RETURN_ADDRESS, 1,
+	[Define to 1 if your compiler supports the __builtin_return_address() intrinsic.])
+fi
+
+dnl Checks for precise integer types
+AC_CHECK_HEADERS([stdint.h inttypes.h sys/int_types.h])
+AC_CHECK_TYPES([uint64_t, uint128_t, __uint128_t])
+
+dnl Check for socket support for any2ppm daemon
+AC_CHECK_HEADERS([fcntl.h unistd.h signal.h sys/stat.h sys/socket.h sys/poll.h sys/un.h])
+
+dnl Check for infinite loops
+AC_CHECK_FUNCS([alarm])
+
+dnl check for CPU affinity support
+AC_CHECK_HEADERS([sched.h], [AC_CHECK_FUNCS([sched_getaffinity])])
+
+dnl check for mmap support
+AC_CHECK_HEADERS([sys/mman.h], [AC_CHECK_FUNCS([mmap])])
+
+dnl check for clock_gettime() support
+save_LIBS="$LIBS"
+LIBS="$LIBS $RT_LIBS"
+AC_CHECK_HEADERS([time.h], [AC_CHECK_FUNCS([clock_gettime])])
+LIBS="$save_LIBS"
+
+dnl check for GNU-extensions to fenv
+AC_CHECK_HEADER(fenv.h,
+	[AC_CHECK_FUNCS(feenableexcept fedisableexcept feclearexcept)])
+
+dnl check for misc headers and functions
+AC_CHECK_HEADERS([libgen.h byteswap.h signal.h setjmp.h fenv.h])
+AC_CHECK_FUNCS([vasnprintf link ctime_r drand48 flockfile ffs])
+
+dnl check for win32 headers (this detects mingw as well)
+AC_CHECK_HEADERS([windows.h], have_windows=yes, have_windows=no)
+
+
+dnl Possible headers for mkdir
+AC_CHECK_HEADERS([sys/stat.h io.h])
+AC_CHECK_FUNC(mkdir,
+	      [AC_MSG_CHECKING([mkdir variant])
+	      mkdir_variant="unknown"
+	      save_CFLAGS="$CFLAGS"
+	      CFLAGS=$WARN_CFLAGS
+	      AC_TRY_COMPILE([
+#ifdef HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+#ifdef HAVE_IO_H
+#include <io.h>
+#endif
+		      ],
+		      [mkdir ("hello.world", 0777)],
+		      mkdir_variant="mkdir(path, mode)",
+		      [AC_TRY_COMPILE([
+#ifdef HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+#ifdef HAVE_IO_H
+#include <io.h>
+#endif
+			      ],
+			      [mkdir ("hello.world")],
+			      mkdir_variant="mkdir(path)")])
+	      AC_MSG_RESULT([$mkdir_variant])
+	      CFLAGS="$save_CFLAGS"
+	      if test "x$mkdir_variant" = "xmkdir(path, mode)"; then
+		  AC_DEFINE(HAVE_MKDIR, 2,
+			    [Define to non-zero if your system has mkdir, and to 2 if your version of mkdir requires a mode parameter])
+	      else
+		  AC_DEFINE(HAVE_MKDIR, 1,
+			    [Define to non-zero if your system has mkdir, and to 2 if your version of mkdir requires a mode parameter])
+	      fi])
+
+dnl ===========================================================================
+dnl
+dnl Test for the tools required for building one big test binary
+dnl
+
+AC_CHECK_FUNCS(fork waitpid raise)
diff --git a/src/Makefile.am b/src/Makefile.am
index 9bc9e22..b69be51 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -37,6 +37,23 @@ PCB_SRCS = \
 	box.h \
 	buffer.c \
 	buffer.h \
+	cairo/cairo.h \
+	cairo/cairoint-minimal.h \
+	cairo/cairo-bentley-ottmann.c \
+	cairo/cairo-combsort-private.h \
+	cairo/cairo-compiler-private.h \
+	cairo/cairo-fixed-private.h \
+	cairo/cairo-fixed-type-private.h \
+	cairo/cairo-freelist.c \
+	cairo/cairo-freelist-private.h \
+	cairo/cairo-list-private.h \
+	cairo/cairo-malloc-private.h \
+	cairo/cairo-traps.c \
+	cairo/cairo-traps-private.h \
+	cairo/cairo-types-private.h \
+	cairo/cairo-wideint.c \
+	cairo/cairo-wideint-private.h \
+	cairo/cairo-wideint-type-private.h \
 	change.c \
 	change.h \
 	clip.c \
@@ -130,6 +147,7 @@ PCB_SRCS = \
 	set.h \
 	strflags.c \
 	strflags.h \
+	sweep.h \
 	thermal.c \
 	thermal.h \
 	undo.c \
diff --git a/src/cairo/cairo-bentley-ottmann.c b/src/cairo/cairo-bentley-ottmann.c
new file mode 100644
index 0000000..22fa43c
--- /dev/null
+++ b/src/cairo/cairo-bentley-ottmann.c
@@ -0,0 +1,1904 @@
+/*
+ * Copyright © 2004 Carl Worth
+ * Copyright © 2006 Red Hat, Inc.
+ * Copyright © 2008 Chris Wilson
+ * Copyright © 2009 Peter Clifton
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is Carl Worth
+ *
+ * Contributor(s):
+ *        Carl D. Worth <cworth@cworth.org>
+ *        Chris Wilson <chris@chris-wilson.co.uk>
+ *        Peter Clifton <pcjc2@cam.ac.uk> (Adaptation to PCB use)
+ */
+
+/* Provide definitions for standalone compilation */
+#include "cairoint-minimal.h"
+#include "cairo-malloc-private.h"
+#include "cairo-traps-private.h"
+#include "cairo-fixed-private.h"
+#include "cairo-freelist-private.h"
+#include "cairo-combsort-private.h"
+
+#include <glib.h>
+
+#include "polygon.h"
+#include <GL/gl.h>
+#include "hid/common/hidgl.h"
+
+#define _cairo_error(x) (x)
+
+#define DEBUG_PRINT_STATE 0
+#define DEBUG_EVENTS 0
+#define DEBUG_TRAPS 0
+
+typedef cairo_point_t cairo_bo_point32_t;
+
+typedef struct _cairo_bo_intersect_ordinate {
+    int32_t ordinate;
+    enum { EXACT, INEXACT } exactness;
+} cairo_bo_intersect_ordinate_t;
+
+typedef struct _cairo_bo_intersect_point {
+    cairo_bo_intersect_ordinate_t x;
+    cairo_bo_intersect_ordinate_t y;
+} cairo_bo_intersect_point_t;
+
+typedef struct _cairo_bo_edge cairo_bo_edge_t;
+typedef struct _cairo_bo_trap cairo_bo_trap_t;
+
+/* A deferred trapezoid of an edge */
+struct _cairo_bo_trap {
+    cairo_bo_edge_t *right;
+    int32_t top;
+};
+
+struct _cairo_bo_edge {
+    cairo_edge_t edge;
+    cairo_bo_edge_t *prev;
+    cairo_bo_edge_t *next;
+    cairo_bo_trap_t deferred_trap;
+};
+
+/* the parent is always given by index/2 */
+#define PQ_PARENT_INDEX(i) ((i) >> 1)
+#define PQ_FIRST_ENTRY 1
+
+/* left and right children are index * 2 and (index * 2) +1 respectively */
+#define PQ_LEFT_CHILD_INDEX(i) ((i) << 1)
+
+typedef enum {
+    CAIRO_BO_EVENT_TYPE_STOP,
+    CAIRO_BO_EVENT_TYPE_INTERSECTION,
+    CAIRO_BO_EVENT_TYPE_START
+} cairo_bo_event_type_t;
+
+typedef struct _cairo_bo_event {
+    cairo_bo_event_type_t type;
+    cairo_point_t point;
+} cairo_bo_event_t;
+
+typedef struct _cairo_bo_start_event {
+    cairo_bo_event_type_t type;
+    cairo_point_t point;
+    cairo_bo_edge_t edge;
+} cairo_bo_start_event_t;
+
+typedef struct _cairo_bo_queue_event {
+    cairo_bo_event_type_t type;
+    cairo_point_t point;
+    cairo_bo_edge_t *e1;
+    cairo_bo_edge_t *e2;
+} cairo_bo_queue_event_t;
+
+typedef struct _pqueue {
+    int size, max_size;
+
+    cairo_bo_event_t **elements;
+    cairo_bo_event_t *elements_embedded[1024];
+} pqueue_t;
+
+typedef struct _cairo_bo_event_queue {
+    cairo_freepool_t pool;
+    pqueue_t pqueue;
+    cairo_bo_event_t **start_events;
+} cairo_bo_event_queue_t;
+
+typedef struct _cairo_bo_sweep_line {
+    cairo_bo_edge_t *head;
+    cairo_bo_edge_t *stopped;
+    int32_t current_y;
+    cairo_bo_edge_t *current_edge;
+} cairo_bo_sweep_line_t;
+
+#if DEBUG_TRAPS
+static void
+dump_traps (cairo_traps_t *traps, const char *filename)
+{
+    FILE *file;
+    int n;
+
+    if (getenv ("CAIRO_DEBUG_TRAPS") == NULL)
+        return;
+
+    if (traps->has_limits) {
+        printf ("%s: limits=(%d, %d, %d, %d)\n",
+                filename,
+                traps->limits.p1.x, traps->limits.p1.y,
+                traps->limits.p2.x, traps->limits.p2.y);
+    }
+    printf ("%s: extents=(%d, %d, %d, %d)\n",
+            filename,
+            traps->extents.p1.x, traps->extents.p1.y,
+            traps->extents.p2.x, traps->extents.p2.y);
+
+    file = fopen (filename, "a");
+    if (file != NULL) {
+        for (n = 0; n < traps->num_traps; n++) {
+            fprintf (file, "%d %d L:(%d, %d), (%d, %d) R:(%d, %d), (%d, %d)\n",
+                     traps->traps[n].top,
+                     traps->traps[n].bottom,
+                     traps->traps[n].left.p1.x,
+                     traps->traps[n].left.p1.y,
+                     traps->traps[n].left.p2.x,
+                     traps->traps[n].left.p2.y,
+                     traps->traps[n].right.p1.x,
+                     traps->traps[n].right.p1.y,
+                     traps->traps[n].right.p2.x,
+                     traps->traps[n].right.p2.y);
+        }
+        fprintf (file, "\n");
+        fclose (file);
+    }
+}
+
+static void
+dump_edges (cairo_bo_start_event_t *events,
+            int num_edges,
+            const char *filename)
+{
+    FILE *file;
+    int n;
+
+    if (getenv ("CAIRO_DEBUG_TRAPS") == NULL)
+        return;
+
+    file = fopen (filename, "a");
+    if (file != NULL) {
+        for (n = 0; n < num_edges; n++) {
+            fprintf (file, "(%d, %d), (%d, %d) %d %d %d\n",
+                     events[n].edge.edge.line.p1.x,
+                     events[n].edge.edge.line.p1.y,
+                     events[n].edge.edge.line.p2.x,
+                     events[n].edge.edge.line.p2.y,
+                     events[n].edge.edge.top,
+                     events[n].edge.edge.bottom,
+                     events[n].edge.edge.dir);
+        }
+        fprintf (file, "\n");
+        fclose (file);
+    }
+}
+#endif
+
+static cairo_fixed_t
+_line_compute_intersection_x_for_y (const cairo_line_t *line,
+                                    cairo_fixed_t y)
+{
+    cairo_fixed_t x, dy;
+
+    if (y == line->p1.y)
+        return line->p1.x;
+    if (y == line->p2.y)
+        return line->p2.x;
+
+    x = line->p1.x;
+    dy = line->p2.y - line->p1.y;
+    if (dy != 0) {
+        x += _cairo_fixed_mul_div_floor (y - line->p1.y,
+                                         line->p2.x - line->p1.x,
+                                         dy);
+    }
+
+    return x;
+}
+
+static inline int
+_cairo_bo_point32_compare (cairo_bo_point32_t const *a,
+                           cairo_bo_point32_t const *b)
+{
+    int cmp;
+
+    cmp = a->y - b->y;
+    if (cmp)
+        return cmp;
+
+    return a->x - b->x;
+}
+
+/* Compare the slope of a to the slope of b, returning 1, 0, -1 if the
+ * slope a is respectively greater than, equal to, or less than the
+ * slope of b.
+ *
+ * For each edge, consider the direction vector formed from:
+ *
+ *        top -> bottom
+ *
+ * which is:
+ *
+ *        (dx, dy) = (line.p2.x - line.p1.x, line.p2.y - line.p1.y)
+ *
+ * We then define the slope of each edge as dx/dy, (which is the
+ * inverse of the slope typically used in math instruction). We never
+ * compute a slope directly as the value approaches infinity, but we
+ * can derive a slope comparison without division as follows, (where
+ * the ? represents our compare operator).
+ *
+ * 1.           slope(a) ? slope(b)
+ * 2.            adx/ady ? bdx/bdy
+ * 3.        (adx * bdy) ? (bdx * ady)
+ *
+ * Note that from step 2 to step 3 there is no change needed in the
+ * sign of the result since both ady and bdy are guaranteed to be
+ * greater than or equal to 0.
+ *
+ * When using this slope comparison to sort edges, some care is needed
+ * when interpreting the results. Since the slope compare operates on
+ * distance vectors from top to bottom it gives a correct left to
+ * right sort for edges that have a common top point, (such as two
+ * edges with start events at the same location). On the other hand,
+ * the sense of the result will be exactly reversed for two edges that
+ * have a common stop point.
+ */
+static inline int
+_slope_compare (const cairo_bo_edge_t *a,
+                const cairo_bo_edge_t *b)
+{
+    /* XXX: We're assuming here that dx and dy will still fit in 32
+     * bits. That's not true in general as there could be overflow. We
+     * should prevent that before the tessellation algorithm
+     * begins.
+     */
+    int32_t adx = a->edge.line.p2.x - a->edge.line.p1.x;
+    int32_t bdx = b->edge.line.p2.x - b->edge.line.p1.x;
+
+    /* Since the dy's are all positive by construction we can fast
+     * path several common cases.
+     */
+
+    /* First check for vertical lines. */
+    if (adx == 0)
+        return -bdx;
+    if (bdx == 0)
+        return adx;
+
+    /* Then where the two edges point in different directions wrt x. */
+    if ((adx ^ bdx) < 0)
+        return adx;
+
+    /* Finally we actually need to do the general comparison. */
+    {
+        int32_t ady = a->edge.line.p2.y - a->edge.line.p1.y;
+        int32_t bdy = b->edge.line.p2.y - b->edge.line.p1.y;
+        cairo_int64_t adx_bdy = _cairo_int32x32_64_mul (adx, bdy);
+        cairo_int64_t bdx_ady = _cairo_int32x32_64_mul (bdx, ady);
+
+        return _cairo_int64_cmp (adx_bdy, bdx_ady);
+    }
+}
+
+/*
+ * We need to compare the x-coordinates of a pair of lines for a particular y,
+ * without loss of precision.
+ *
+ * The x-coordinate along an edge for a given y is:
+ *   X = A_x + (Y - A_y) * A_dx / A_dy
+ *
+ * So the inequality we wish to test is:
+ *   A_x + (Y - A_y) * A_dx / A_dy ∘ B_x + (Y - B_y) * B_dx / B_dy,
+ * where ∘ is our inequality operator.
+ *
+ * By construction, we know that A_dy and B_dy (and (Y - A_y), (Y - B_y)) are
+ * all positive, so we can rearrange it thus without causing a sign change:
+ *   A_dy * B_dy * (A_x - B_x) ∘ (Y - B_y) * B_dx * A_dy
+ *                                 - (Y - A_y) * A_dx * B_dy
+ *
+ * Given the assumption that all the deltas fit within 32 bits, we can compute
+ * this comparison directly using 128 bit arithmetic. For certain, but common,
+ * input we can reduce this down to a single 32 bit compare by inspecting the
+ * deltas.
+ *
+ * (And put the burden of the work on developing fast 128 bit ops, which are
+ * required throughout the tessellator.)
+ *
+ * See the similar discussion for _slope_compare().
+ */
+static int
+edges_compare_x_for_y_general (const cairo_bo_edge_t *a,
+                               const cairo_bo_edge_t *b,
+                               int32_t y)
+{
+    /* XXX: We're assuming here that dx and dy will still fit in 32
+     * bits. That's not true in general as there could be overflow. We
+     * should prevent that before the tessellation algorithm
+     * begins.
+     */
+    int32_t dx;
+    int32_t adx, ady;
+    int32_t bdx, bdy;
+    enum {
+       HAVE_NONE    = 0x0,
+       HAVE_DX      = 0x1,
+       HAVE_ADX     = 0x2,
+       HAVE_DX_ADX  = HAVE_DX | HAVE_ADX,
+       HAVE_BDX     = 0x4,
+       HAVE_DX_BDX  = HAVE_DX | HAVE_BDX,
+       HAVE_ADX_BDX = HAVE_ADX | HAVE_BDX,
+       HAVE_ALL     = HAVE_DX | HAVE_ADX | HAVE_BDX
+    } have_dx_adx_bdx = HAVE_ALL;
+
+    /* don't bother solving for abscissa if the edges' bounding boxes
+     * can be used to order them. */
+    {
+           int32_t amin, amax;
+           int32_t bmin, bmax;
+           if (a->edge.line.p1.x < a->edge.line.p2.x) {
+                   amin = a->edge.line.p1.x;
+                   amax = a->edge.line.p2.x;
+           } else {
+                   amin = a->edge.line.p2.x;
+                   amax = a->edge.line.p1.x;
+           }
+           if (b->edge.line.p1.x < b->edge.line.p2.x) {
+                   bmin = b->edge.line.p1.x;
+                   bmax = b->edge.line.p2.x;
+           } else {
+                   bmin = b->edge.line.p2.x;
+                   bmax = b->edge.line.p1.x;
+           }
+           if (amax < bmin) return -1;
+           if (amin > bmax) return +1;
+    }
+
+    ady = a->edge.line.p2.y - a->edge.line.p1.y;
+    adx = a->edge.line.p2.x - a->edge.line.p1.x;
+    if (adx == 0)
+        have_dx_adx_bdx &= ~HAVE_ADX;
+
+    bdy = b->edge.line.p2.y - b->edge.line.p1.y;
+    bdx = b->edge.line.p2.x - b->edge.line.p1.x;
+    if (bdx == 0)
+        have_dx_adx_bdx &= ~HAVE_BDX;
+
+    dx = a->edge.line.p1.x - b->edge.line.p1.x;
+    if (dx == 0)
+        have_dx_adx_bdx &= ~HAVE_DX;
+
+#define L _cairo_int64x32_128_mul (_cairo_int32x32_64_mul (ady, bdy), dx)
+#define A _cairo_int64x32_128_mul (_cairo_int32x32_64_mul (adx, bdy), y - a->edge.line.p1.y)
+#define B _cairo_int64x32_128_mul (_cairo_int32x32_64_mul (bdx, ady), y - b->edge.line.p1.y)
+    switch (have_dx_adx_bdx) {
+    default:
+    case HAVE_NONE:
+        return 0;
+    case HAVE_DX:
+        /* A_dy * B_dy * (A_x - B_x) ∘ 0 */
+        return dx; /* ady * bdy is positive definite */
+    case HAVE_ADX:
+        /* 0 ∘  - (Y - A_y) * A_dx * B_dy */
+        return adx; /* bdy * (y - a->top.y) is positive definite */
+    case HAVE_BDX:
+        /* 0 ∘ (Y - B_y) * B_dx * A_dy */
+        return -bdx; /* ady * (y - b->top.y) is positive definite */
+    case HAVE_ADX_BDX:
+        /*  0 ∘ (Y - B_y) * B_dx * A_dy - (Y - A_y) * A_dx * B_dy */
+        if ((adx ^ bdx) < 0) {
+            return adx;
+        } else if (a->edge.line.p1.y == b->edge.line.p1.y) { /* common origin */
+            cairo_int64_t adx_bdy, bdx_ady;
+
+            /* ∴ A_dx * B_dy ∘ B_dx * A_dy */
+
+            adx_bdy = _cairo_int32x32_64_mul (adx, bdy);
+            bdx_ady = _cairo_int32x32_64_mul (bdx, ady);
+
+            return _cairo_int64_cmp (adx_bdy, bdx_ady);
+        } else
+            return _cairo_int128_cmp (A, B);
+    case HAVE_DX_ADX:
+        /* A_dy * (A_x - B_x) ∘ - (Y - A_y) * A_dx */
+        if ((-adx ^ dx) < 0) {
+            return dx;
+        } else {
+            cairo_int64_t ady_dx, dy_adx;
+
+            ady_dx = _cairo_int32x32_64_mul (ady, dx);
+            dy_adx = _cairo_int32x32_64_mul (a->edge.line.p1.y - y, adx);
+
+            return _cairo_int64_cmp (ady_dx, dy_adx);
+        }
+    case HAVE_DX_BDX:
+        /* B_dy * (A_x - B_x) ∘ (Y - B_y) * B_dx */
+        if ((bdx ^ dx) < 0) {
+            return dx;
+        } else {
+            cairo_int64_t bdy_dx, dy_bdx;
+
+            bdy_dx = _cairo_int32x32_64_mul (bdy, dx);
+            dy_bdx = _cairo_int32x32_64_mul (y - b->edge.line.p1.y, bdx);
+
+            return _cairo_int64_cmp (bdy_dx, dy_bdx);
+        }
+    case HAVE_ALL:
+        /* XXX try comparing (a->edge.line.p2.x - b->edge.line.p2.x) et al */
+        return _cairo_int128_cmp (L, _cairo_int128_sub (B, A));
+    }
+#undef B
+#undef A
+#undef L
+}
+
+/*
+ * We need to compare the x-coordinate of a line for a particular y wrt to a
+ * given x, without loss of precision.
+ *
+ * The x-coordinate along an edge for a given y is:
+ *   X = A_x + (Y - A_y) * A_dx / A_dy
+ *
+ * So the inequality we wish to test is:
+ *   A_x + (Y - A_y) * A_dx / A_dy ∘ X
+ * where ∘ is our inequality operator.
+ *
+ * By construction, we know that A_dy (and (Y - A_y)) are
+ * all positive, so we can rearrange it thus without causing a sign change:
+ *   (Y - A_y) * A_dx ∘ (X - A_x) * A_dy
+ *
+ * Given the assumption that all the deltas fit within 32 bits, we can compute
+ * this comparison directly using 64 bit arithmetic.
+ *
+ * See the similar discussion for _slope_compare() and
+ * edges_compare_x_for_y_general().
+ */
+static int
+edge_compare_for_y_against_x (const cairo_bo_edge_t *a,
+                              int32_t y,
+                              int32_t x)
+{
+    int32_t adx, ady;
+    int32_t dx, dy;
+    cairo_int64_t L, R;
+
+    if (x < a->edge.line.p1.x && x < a->edge.line.p2.x)
+        return 1;
+    if (x > a->edge.line.p1.x && x > a->edge.line.p2.x)
+        return -1;
+
+    adx = a->edge.line.p2.x - a->edge.line.p1.x;
+    dx = x - a->edge.line.p1.x;
+
+    if (adx == 0)
+        return -dx;
+    if (dx == 0 || (adx ^ dx) < 0)
+        return adx;
+
+    dy = y - a->edge.line.p1.y;
+    ady = a->edge.line.p2.y - a->edge.line.p1.y;
+
+    L = _cairo_int32x32_64_mul (dy, adx);
+    R = _cairo_int32x32_64_mul (dx, ady);
+
+    return _cairo_int64_cmp (L, R);
+}
+
+static int
+edges_compare_x_for_y (const cairo_bo_edge_t *a,
+                       const cairo_bo_edge_t *b,
+                       int32_t y)
+{
+    /* If the sweep-line is currently on an end-point of a line,
+     * then we know its precise x value (and considering that we often need to
+     * compare events at end-points, this happens frequently enough to warrant
+     * special casing).
+     */
+    enum {
+       HAVE_NEITHER = 0x0,
+       HAVE_AX      = 0x1,
+       HAVE_BX      = 0x2,
+       HAVE_BOTH    = HAVE_AX | HAVE_BX
+    } have_ax_bx = HAVE_BOTH;
+    int32_t ax, bx;
+
+    if (y == a->edge.line.p1.y)
+        ax = a->edge.line.p1.x;
+    else if (y == a->edge.line.p2.y)
+        ax = a->edge.line.p2.x;
+    else
+        have_ax_bx &= ~HAVE_AX;
+
+    if (y == b->edge.line.p1.y)
+        bx = b->edge.line.p1.x;
+    else if (y == b->edge.line.p2.y)
+        bx = b->edge.line.p2.x;
+    else
+        have_ax_bx &= ~HAVE_BX;
+
+    switch (have_ax_bx) {
+    default:
+    case HAVE_NEITHER:
+        return edges_compare_x_for_y_general (a, b, y);
+    case HAVE_AX:
+        return -edge_compare_for_y_against_x (b, y, ax);
+    case HAVE_BX:
+        return edge_compare_for_y_against_x (a, y, bx);
+    case HAVE_BOTH:
+        return ax - bx;
+    }
+}
+
+static inline int
+_line_equal (const cairo_line_t *a, const cairo_line_t *b)
+{
+    return a->p1.x == b->p1.x && a->p1.y == b->p1.y &&
+           a->p2.x == b->p2.x && a->p2.y == b->p2.y;
+}
+
+static int
+_cairo_bo_sweep_line_compare_edges (cairo_bo_sweep_line_t        *sweep_line,
+                                    const cairo_bo_edge_t        *a,
+                                    const cairo_bo_edge_t        *b)
+{
+    int cmp;
+
+    /* compare the edges if not identical */
+    if (! _line_equal (&a->edge.line, &b->edge.line)) {
+        cmp = edges_compare_x_for_y (a, b, sweep_line->current_y);
+        if (cmp)
+            return cmp;
+
+        /* The two edges intersect exactly at y, so fall back on slope
+         * comparison. We know that this compare_edges function will be
+         * called only when starting a new edge, (not when stopping an
+         * edge), so we don't have to worry about conditionally inverting
+         * the sense of _slope_compare. */
+        cmp = _slope_compare (a, b);
+        if (cmp)
+            return cmp;
+    }
+
+    /* We've got two collinear edges now. */
+    return b->edge.bottom - a->edge.bottom;
+}
+
+static inline cairo_int64_t
+det32_64 (int32_t a, int32_t b,
+          int32_t c, int32_t d)
+{
+    /* det = a * d - b * c */
+    return _cairo_int64_sub (_cairo_int32x32_64_mul (a, d),
+                             _cairo_int32x32_64_mul (b, c));
+}
+
+static inline cairo_int128_t
+det64x32_128 (cairo_int64_t a, int32_t       b,
+              cairo_int64_t c, int32_t       d)
+{
+    /* det = a * d - b * c */
+    return _cairo_int128_sub (_cairo_int64x32_128_mul (a, d),
+                              _cairo_int64x32_128_mul (c, b));
+}
+
+/* Compute the intersection of two lines as defined by two edges. The
+ * result is provided as a coordinate pair of 128-bit integers.
+ *
+ * Returns %CAIRO_BO_STATUS_INTERSECTION if there is an intersection or
+ * %CAIRO_BO_STATUS_PARALLEL if the two lines are exactly parallel.
+ */
+static cairo_bool_t
+intersect_lines (cairo_bo_edge_t                *a,
+                 cairo_bo_edge_t                *b,
+                 cairo_bo_intersect_point_t        *intersection)
+{
+    cairo_int64_t a_det, b_det;
+
+    /* XXX: We're assuming here that dx and dy will still fit in 32
+     * bits. That's not true in general as there could be overflow. We
+     * should prevent that before the tessellation algorithm begins.
+     * What we're doing to mitigate this is to perform clamping in
+     * cairo_bo_tessellate_polygon().
+     */
+    int32_t dx1 = a->edge.line.p1.x - a->edge.line.p2.x;
+    int32_t dy1 = a->edge.line.p1.y - a->edge.line.p2.y;
+
+    int32_t dx2 = b->edge.line.p1.x - b->edge.line.p2.x;
+    int32_t dy2 = b->edge.line.p1.y - b->edge.line.p2.y;
+
+    cairo_int64_t den_det;
+    cairo_int64_t R;
+    cairo_quorem64_t qr;
+
+    den_det = det32_64 (dx1, dy1, dx2, dy2);
+
+     /* Q: Can we determine that the lines do not intersect (within range)
+      * much more cheaply than computing the intersection point i.e. by
+      * avoiding the division?
+      *
+      *   X = ax + t * adx = bx + s * bdx;
+      *   Y = ay + t * ady = by + s * bdy;
+      *   ∴ t * (ady*bdx - bdy*adx) = bdx * (by - ay) + bdy * (ax - bx)
+      *   => t * L = R
+      *
+      * Therefore we can reject any intersection (under the criteria for
+      * valid intersection events) if:
+      *   L^R < 0 => t < 0, or
+      *   L<R => t > 1
+      *
+      * (where top/bottom must at least extend to the line endpoints).
+      *
+      * A similar substitution can be performed for s, yielding:
+      *   s * (ady*bdx - bdy*adx) = ady * (ax - bx) - adx * (ay - by)
+      */
+    R = det32_64 (dx2, dy2,
+                  b->edge.line.p1.x - a->edge.line.p1.x,
+                  b->edge.line.p1.y - a->edge.line.p1.y);
+    if (_cairo_int64_negative (den_det)) {
+        if (_cairo_int64_ge (den_det, R))
+            return FALSE;
+    } else {
+        if (_cairo_int64_le (den_det, R))
+            return FALSE;
+    }
+
+    R = det32_64 (dy1, dx1,
+                  a->edge.line.p1.y - b->edge.line.p1.y,
+                  a->edge.line.p1.x - b->edge.line.p1.x);
+    if (_cairo_int64_negative (den_det)) {
+        if (_cairo_int64_ge (den_det, R))
+            return FALSE;
+    } else {
+        if (_cairo_int64_le (den_det, R))
+            return FALSE;
+    }
+
+    /* We now know that the two lines should intersect within range. */
+
+    a_det = det32_64 (a->edge.line.p1.x, a->edge.line.p1.y,
+                      a->edge.line.p2.x, a->edge.line.p2.y);
+    b_det = det32_64 (b->edge.line.p1.x, b->edge.line.p1.y,
+                      b->edge.line.p2.x, b->edge.line.p2.y);
+
+    /* x = det (a_det, dx1, b_det, dx2) / den_det */
+    qr = _cairo_int_96by64_32x64_divrem (det64x32_128 (a_det, dx1,
+                                                       b_det, dx2),
+                                         den_det);
+    if (_cairo_int64_eq (qr.rem, den_det))
+        return FALSE;
+#if 0
+    intersection->x.exactness = _cairo_int64_is_zero (qr.rem) ? EXACT : INEXACT;
+#else
+    intersection->x.exactness = EXACT;
+    if (! _cairo_int64_is_zero (qr.rem)) {
+        if (_cairo_int64_negative (den_det) ^ _cairo_int64_negative (qr.rem))
+            qr.rem = _cairo_int64_negate (qr.rem);
+        qr.rem = _cairo_int64_mul (qr.rem, _cairo_int32_to_int64 (2));
+        if (_cairo_int64_ge (qr.rem, den_det)) {
+            qr.quo = _cairo_int64_add (qr.quo,
+                                       _cairo_int32_to_int64 (_cairo_int64_negative (qr.quo) ? -1 : 1));
+        } else
+            intersection->x.exactness = INEXACT;
+    }
+#endif
+    intersection->x.ordinate = _cairo_int64_to_int32 (qr.quo);
+
+    /* y = det (a_det, dy1, b_det, dy2) / den_det */
+    qr = _cairo_int_96by64_32x64_divrem (det64x32_128 (a_det, dy1,
+                                                       b_det, dy2),
+                                         den_det);
+    if (_cairo_int64_eq (qr.rem, den_det))
+        return FALSE;
+#if 0
+    intersection->y.exactness = _cairo_int64_is_zero (qr.rem) ? EXACT : INEXACT;
+#else
+    intersection->y.exactness = EXACT;
+    if (! _cairo_int64_is_zero (qr.rem)) {
+        if (_cairo_int64_negative (den_det) ^ _cairo_int64_negative (qr.rem))
+            qr.rem = _cairo_int64_negate (qr.rem);
+        qr.rem = _cairo_int64_mul (qr.rem, _cairo_int32_to_int64 (2));
+        if (_cairo_int64_ge (qr.rem, den_det)) {
+            qr.quo = _cairo_int64_add (qr.quo,
+                                       _cairo_int32_to_int64 (_cairo_int64_negative (qr.quo) ? -1 : 1));
+        } else
+            intersection->y.exactness = INEXACT;
+    }
+#endif
+    intersection->y.ordinate = _cairo_int64_to_int32 (qr.quo);
+
+    return TRUE;
+}
+
+static int
+_cairo_bo_intersect_ordinate_32_compare (cairo_bo_intersect_ordinate_t        a,
+                                         int32_t                        b)
+{
+    /* First compare the quotient */
+    if (a.ordinate > b)
+        return +1;
+    if (a.ordinate < b)
+        return -1;
+    /* With quotient identical, if remainder is 0 then compare equal */
+    /* Otherwise, the non-zero remainder makes a > b */
+    return INEXACT == a.exactness;
+}
+
+/* Does the given edge contain the given point. The point must already
+ * be known to be contained within the line determined by the edge,
+ * (most likely the point results from an intersection of this edge
+ * with another).
+ *
+ * If we had exact arithmetic, then this function would simply be a
+ * matter of examining whether the y value of the point lies within
+ * the range of y values of the edge. But since intersection points
+ * are not exact due to being rounded to the nearest integer within
+ * the available precision, we must also examine the x value of the
+ * point.
+ *
+ * The definition of "contains" here is that the given intersection
+ * point will be seen by the sweep line after the start event for the
+ * given edge and before the stop event for the edge. See the comments
+ * in the implementation for more details.
+ */
+static cairo_bool_t
+_cairo_bo_edge_contains_intersect_point (cairo_bo_edge_t                *edge,
+                                         cairo_bo_intersect_point_t        *point)
+{
+    int cmp_top, cmp_bottom;
+
+    /* XXX: When running the actual algorithm, we don't actually need to
+     * compare against edge->top at all here, since any intersection above
+     * top is eliminated early via a slope comparison. We're leaving these
+     * here for now only for the sake of the quadratic-time intersection
+     * finder which needs them.
+     */
+
+    cmp_top = _cairo_bo_intersect_ordinate_32_compare (point->y,
+                                                       edge->edge.top);
+    cmp_bottom = _cairo_bo_intersect_ordinate_32_compare (point->y,
+                                                          edge->edge.bottom);
+
+    if (cmp_top < 0 || cmp_bottom > 0)
+    {
+        return FALSE;
+    }
+
+    if (cmp_top > 0 && cmp_bottom < 0)
+    {
+        return TRUE;
+    }
+
+    /* At this stage, the point lies on the same y value as either
+     * edge->top or edge->bottom, so we have to examine the x value in
+     * order to properly determine containment. */
+
+    /* If the y value of the point is the same as the y value of the
+     * top of the edge, then the x value of the point must be greater
+     * to be considered as inside the edge. Similarly, if the y value
+     * of the point is the same as the y value of the bottom of the
+     * edge, then the x value of the point must be less to be
+     * considered as inside. */
+
+    if (cmp_top == 0) {
+        cairo_fixed_t top_x;
+
+        top_x = _line_compute_intersection_x_for_y (&edge->edge.line,
+                                                    edge->edge.top);
+        return _cairo_bo_intersect_ordinate_32_compare (point->x, top_x) > 0;
+    } else { /* cmp_bottom == 0 */
+        cairo_fixed_t bot_x;
+
+        bot_x = _line_compute_intersection_x_for_y (&edge->edge.line,
+                                                    edge->edge.bottom);
+        return _cairo_bo_intersect_ordinate_32_compare (point->x, bot_x) < 0;
+    }
+}
+
+/* Compute the intersection of two edges. The result is provided as a
+ * coordinate pair of 128-bit integers.
+ *
+ * Returns %CAIRO_BO_STATUS_INTERSECTION if there is an intersection
+ * that is within both edges, %CAIRO_BO_STATUS_NO_INTERSECTION if the
+ * intersection of the lines defined by the edges occurs outside of
+ * one or both edges, and %CAIRO_BO_STATUS_PARALLEL if the two edges
+ * are exactly parallel.
+ *
+ * Note that when determining if a candidate intersection is "inside"
+ * an edge, we consider both the infinitesimal shortening and the
+ * infinitesimal tilt rules described by John Hobby. Specifically, if
+ * the intersection is exactly the same as an edge point, it is
+ * effectively outside (no intersection is returned). Also, if the
+ * intersection point has the same
+ */
+static cairo_bool_t
+_cairo_bo_edge_intersect (cairo_bo_edge_t        *a,
+                          cairo_bo_edge_t        *b,
+                          cairo_bo_point32_t        *intersection)
+{
+    cairo_bo_intersect_point_t quorem;
+
+    if (! intersect_lines (a, b, &quorem))
+        return FALSE;
+
+    if (! _cairo_bo_edge_contains_intersect_point (a, &quorem))
+        return FALSE;
+
+    if (! _cairo_bo_edge_contains_intersect_point (b, &quorem))
+        return FALSE;
+
+    /* Now that we've correctly compared the intersection point and
+     * determined that it lies within the edge, then we know that we
+     * no longer need any more bits of storage for the intersection
+     * than we do for our edge coordinates. We also no longer need the
+     * remainder from the division. */
+    intersection->x = quorem.x.ordinate;
+    intersection->y = quorem.y.ordinate;
+
+    return TRUE;
+}
+
+static inline int
+cairo_bo_event_compare (const cairo_bo_event_t *a,
+                        const cairo_bo_event_t *b)
+{
+    int cmp;
+
+    cmp = _cairo_bo_point32_compare (&a->point, &b->point);
+    if (cmp)
+        return cmp;
+
+    cmp = a->type - b->type;
+    if (cmp)
+        return cmp;
+
+    return a - b;
+}
+
+static inline void
+_pqueue_init (pqueue_t *pq)
+{
+    pq->max_size = ARRAY_LENGTH (pq->elements_embedded);
+    pq->size = 0;
+
+    pq->elements = pq->elements_embedded;
+}
+
+static inline void
+_pqueue_fini (pqueue_t *pq)
+{
+    if (pq->elements != pq->elements_embedded)
+        free (pq->elements);
+}
+
+static cairo_status_t
+_pqueue_grow (pqueue_t *pq)
+{
+    cairo_bo_event_t **new_elements;
+    pq->max_size *= 2;
+
+    if (pq->elements == pq->elements_embedded) {
+        new_elements = _cairo_malloc_ab (pq->max_size,
+                                         sizeof (cairo_bo_event_t *));
+        if (unlikely (new_elements == NULL))
+            return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+
+        memcpy (new_elements, pq->elements_embedded,
+                sizeof (pq->elements_embedded));
+    } else {
+        new_elements = _cairo_realloc_ab (pq->elements,
+                                          pq->max_size,
+                                          sizeof (cairo_bo_event_t *));
+        if (unlikely (new_elements == NULL))
+            return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+    }
+
+    pq->elements = new_elements;
+    return CAIRO_STATUS_SUCCESS;
+}
+
+static inline cairo_status_t
+_pqueue_push (pqueue_t *pq, cairo_bo_event_t *event)
+{
+    cairo_bo_event_t **elements;
+    int i, parent;
+
+    if (unlikely (pq->size + 1 == pq->max_size)) {
+        cairo_status_t status;
+
+        status = _pqueue_grow (pq);
+        if (unlikely (status))
+            return status;
+    }
+
+    elements = pq->elements;
+
+    for (i = ++pq->size;
+         i != PQ_FIRST_ENTRY &&
+         cairo_bo_event_compare (event,
+                                 elements[parent = PQ_PARENT_INDEX (i)]) < 0;
+         i = parent)
+    {
+        elements[i] = elements[parent];
+    }
+
+    elements[i] = event;
+
+    return CAIRO_STATUS_SUCCESS;
+}
+
+static inline void
+_pqueue_pop (pqueue_t *pq)
+{
+    cairo_bo_event_t **elements = pq->elements;
+    cairo_bo_event_t *tail;
+    int child, i;
+
+    tail = elements[pq->size--];
+    if (pq->size == 0) {
+        elements[PQ_FIRST_ENTRY] = NULL;
+        return;
+    }
+
+    for (i = PQ_FIRST_ENTRY;
+         (child = PQ_LEFT_CHILD_INDEX (i)) <= pq->size;
+         i = child)
+    {
+        if (child != pq->size &&
+            cairo_bo_event_compare (elements[child+1],
+                                    elements[child]) < 0)
+        {
+            child++;
+        }
+
+        if (cairo_bo_event_compare (elements[child], tail) >= 0)
+            break;
+
+        elements[i] = elements[child];
+    }
+    elements[i] = tail;
+}
+
+static inline cairo_status_t
+_cairo_bo_event_queue_insert (cairo_bo_event_queue_t        *queue,
+                              cairo_bo_event_type_t         type,
+                              cairo_bo_edge_t                *e1,
+                              cairo_bo_edge_t                *e2,
+                              const cairo_point_t         *point)
+{
+    cairo_bo_queue_event_t *event;
+
+    event = _cairo_freepool_alloc (&queue->pool);
+    if (unlikely (event == NULL))
+        return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+
+    event->type = type;
+    event->e1 = e1;
+    event->e2 = e2;
+    event->point = *point;
+
+    return _pqueue_push (&queue->pqueue, (cairo_bo_event_t *) event);
+}
+
+static void
+_cairo_bo_event_queue_delete (cairo_bo_event_queue_t *queue,
+                              cairo_bo_event_t             *event)
+{
+    _cairo_freepool_free (&queue->pool, event);
+}
+
+static cairo_bo_event_t *
+_cairo_bo_event_dequeue (cairo_bo_event_queue_t *event_queue)
+{
+    cairo_bo_event_t *event, *cmp;
+
+    event = event_queue->pqueue.elements[PQ_FIRST_ENTRY];
+    cmp = *event_queue->start_events;
+    if (event == NULL ||
+        (cmp != NULL && cairo_bo_event_compare (cmp, event) < 0))
+    {
+        event = cmp;
+        event_queue->start_events++;
+    }
+    else
+    {
+        _pqueue_pop (&event_queue->pqueue);
+    }
+
+    return event;
+}
+
+CAIRO_COMBSORT_DECLARE (_cairo_bo_event_queue_sort,
+                        cairo_bo_event_t *,
+                        cairo_bo_event_compare)
+
+static void
+_cairo_bo_event_queue_init (cairo_bo_event_queue_t         *event_queue,
+                            cairo_bo_event_t                **start_events,
+                            int                                  num_events)
+{
+    _cairo_bo_event_queue_sort (start_events, num_events);
+    start_events[num_events] = NULL;
+
+    event_queue->start_events = start_events;
+
+    _cairo_freepool_init (&event_queue->pool,
+                          sizeof (cairo_bo_queue_event_t));
+    _pqueue_init (&event_queue->pqueue);
+    event_queue->pqueue.elements[PQ_FIRST_ENTRY] = NULL;
+}
+
+static cairo_status_t
+_cairo_bo_event_queue_insert_stop (cairo_bo_event_queue_t        *event_queue,
+                                   cairo_bo_edge_t                *edge)
+{
+    cairo_bo_point32_t point;
+
+    point.y = edge->edge.bottom;
+    point.x = _line_compute_intersection_x_for_y (&edge->edge.line,
+                                                  point.y);
+    return _cairo_bo_event_queue_insert (event_queue,
+                                         CAIRO_BO_EVENT_TYPE_STOP,
+                                         edge, NULL,
+                                         &point);
+}
+
+static void
+_cairo_bo_event_queue_fini (cairo_bo_event_queue_t *event_queue)
+{
+    _pqueue_fini (&event_queue->pqueue);
+    _cairo_freepool_fini (&event_queue->pool);
+}
+
+static inline cairo_status_t
+_cairo_bo_event_queue_insert_if_intersect_below_current_y (cairo_bo_event_queue_t        *event_queue,
+                                                           cairo_bo_edge_t        *left,
+                                                           cairo_bo_edge_t *right)
+{
+    cairo_bo_point32_t intersection;
+
+    if (_line_equal (&left->edge.line, &right->edge.line))
+        return CAIRO_STATUS_SUCCESS;
+
+    /* The names "left" and "right" here are correct descriptions of
+     * the order of the two edges within the active edge list. So if a
+     * slope comparison also puts left less than right, then we know
+     * that the intersection of these two segments has already
+     * occurred before the current sweep line position. */
+    if (_slope_compare (left, right) <= 0)
+        return CAIRO_STATUS_SUCCESS;
+
+    if (! _cairo_bo_edge_intersect (left, right, &intersection))
+        return CAIRO_STATUS_SUCCESS;
+
+    return _cairo_bo_event_queue_insert (event_queue,
+                                         CAIRO_BO_EVENT_TYPE_INTERSECTION,
+                                         left, right,
+                                         &intersection);
+}
+
+static void
+_cairo_bo_sweep_line_init (cairo_bo_sweep_line_t *sweep_line)
+{
+    sweep_line->head = NULL;
+    sweep_line->stopped = NULL;
+    sweep_line->current_y = INT32_MIN;
+    sweep_line->current_edge = NULL;
+}
+
+static cairo_status_t
+_cairo_bo_sweep_line_insert (cairo_bo_sweep_line_t        *sweep_line,
+                             cairo_bo_edge_t                *edge)
+{
+    if (sweep_line->current_edge != NULL) {
+        cairo_bo_edge_t *prev, *next;
+        int cmp;
+
+        cmp = _cairo_bo_sweep_line_compare_edges (sweep_line,
+                                                  sweep_line->current_edge,
+                                                  edge);
+        if (cmp < 0) {
+            prev = sweep_line->current_edge;
+            next = prev->next;
+            while (next != NULL &&
+                   _cairo_bo_sweep_line_compare_edges (sweep_line,
+                                                       next, edge) < 0)
+            {
+                prev = next, next = prev->next;
+            }
+
+            prev->next = edge;
+            edge->prev = prev;
+            edge->next = next;
+            if (next != NULL)
+                next->prev = edge;
+        } else if (cmp > 0) {
+            next = sweep_line->current_edge;
+            prev = next->prev;
+            while (prev != NULL &&
+                   _cairo_bo_sweep_line_compare_edges (sweep_line,
+                                                       prev, edge) > 0)
+            {
+                next = prev, prev = next->prev;
+            }
+
+            next->prev = edge;
+            edge->next = next;
+            edge->prev = prev;
+            if (prev != NULL)
+                prev->next = edge;
+            else
+                sweep_line->head = edge;
+        } else {
+            prev = sweep_line->current_edge;
+            edge->prev = prev;
+            edge->next = prev->next;
+            if (prev->next != NULL)
+                prev->next->prev = edge;
+            prev->next = edge;
+        }
+    } else {
+        sweep_line->head = edge;
+    }
+
+    sweep_line->current_edge = edge;
+
+    return CAIRO_STATUS_SUCCESS;
+}
+
+static void
+_cairo_bo_sweep_line_delete (cairo_bo_sweep_line_t        *sweep_line,
+                             cairo_bo_edge_t        *edge)
+{
+    if (edge->prev != NULL)
+        edge->prev->next = edge->next;
+    else
+        sweep_line->head = edge->next;
+
+    if (edge->next != NULL)
+        edge->next->prev = edge->prev;
+
+    if (sweep_line->current_edge == edge)
+        sweep_line->current_edge = edge->prev ? edge->prev : edge->next;
+}
+
+static void
+_cairo_bo_sweep_line_swap (cairo_bo_sweep_line_t        *sweep_line,
+                           cairo_bo_edge_t                *left,
+                           cairo_bo_edge_t                *right)
+{
+    if (left->prev != NULL)
+        left->prev->next = right;
+    else
+        sweep_line->head = right;
+
+    if (right->next != NULL)
+        right->next->prev = left;
+
+    left->next = right->next;
+    right->next = left;
+
+    right->prev = left->prev;
+    left->prev = right;
+}
+
+#if DEBUG_PRINT_STATE
+static void
+_cairo_bo_edge_print (cairo_bo_edge_t *edge)
+{
+    printf ("(%d, %d)-(%d, %d)",
+            edge->edge.line.p1.x, edge->edge.line.p1.y,
+            edge->edge.line.p2.x, edge->edge.line.p2.y);
+}
+
+static void
+_cairo_bo_event_print (cairo_bo_event_t *event)
+{
+    switch (event->type) {
+    case CAIRO_BO_EVENT_TYPE_START:
+        printf ("Start: ");
+        break;
+    case CAIRO_BO_EVENT_TYPE_STOP:
+        printf ("Stop: ");
+        break;
+    case CAIRO_BO_EVENT_TYPE_INTERSECTION:
+        printf ("Intersection: ");
+        break;
+    }
+    printf ("(%d, %d)\t", event->point.x, event->point.y);
+    _cairo_bo_edge_print (((cairo_bo_queue_event_t *)event)->e1);
+    if (event->type == CAIRO_BO_EVENT_TYPE_INTERSECTION) {
+        printf (" X ");
+        _cairo_bo_edge_print (((cairo_bo_queue_event_t *)event)->e2);
+    }
+    printf ("\n");
+}
+
+static void
+_cairo_bo_event_queue_print (cairo_bo_event_queue_t *event_queue)
+{
+    /* XXX: fixme to print the start/stop array too. */
+    printf ("Event queue:\n");
+}
+
+static void
+_cairo_bo_sweep_line_print (cairo_bo_sweep_line_t *sweep_line)
+{
+    cairo_bool_t first = TRUE;
+    cairo_bo_edge_t *edge;
+
+    printf ("Sweep line from edge list: ");
+    first = TRUE;
+    for (edge = sweep_line->head;
+         edge;
+         edge = edge->next)
+    {
+        if (!first)
+            printf (", ");
+        _cairo_bo_edge_print (edge);
+        first = FALSE;
+    }
+    printf ("\n");
+}
+
+static void
+print_state (const char                        *msg,
+             cairo_bo_event_t                *event,
+             cairo_bo_event_queue_t        *event_queue,
+             cairo_bo_sweep_line_t        *sweep_line)
+{
+    printf ("%s ", msg);
+    _cairo_bo_event_print (event);
+    _cairo_bo_event_queue_print (event_queue);
+    _cairo_bo_sweep_line_print (sweep_line);
+    printf ("\n");
+}
+#endif
+
+#if DEBUG_EVENTS
+static void CAIRO_PRINTF_FORMAT (1, 2)
+event_log (const char *fmt, ...)
+{
+    FILE *file;
+
+    if (getenv ("CAIRO_DEBUG_EVENTS") == NULL)
+        return;
+
+    file = fopen ("bo-events.txt", "a");
+    if (file != NULL) {
+        va_list ap;
+
+        va_start (ap, fmt);
+        vfprintf (file, fmt, ap);
+        va_end (ap);
+
+        fclose (file);
+    }
+}
+#endif
+
+static inline cairo_bool_t
+edges_colinear (const cairo_bo_edge_t *a, const cairo_bo_edge_t *b)
+{
+    if (_line_equal (&a->edge.line, &b->edge.line))
+        return TRUE;
+
+    if (_slope_compare (a, b))
+        return FALSE;
+
+    /* The choice of y is not truly arbitrary since we must guarantee that it
+     * is greater than the start of either line.
+     */
+    if (a->edge.line.p1.y == b->edge.line.p1.y) {
+        return a->edge.line.p1.x == b->edge.line.p1.x;
+    } else if (a->edge.line.p1.y < b->edge.line.p1.y) {
+        return edge_compare_for_y_against_x (b,
+                                             a->edge.line.p1.y,
+                                             a->edge.line.p1.x) == 0;
+    } else {
+        return edge_compare_for_y_against_x (a,
+                                             b->edge.line.p1.y,
+                                             b->edge.line.p1.x) == 0;
+    }
+}
+
+/* Adds the trapezoid, if any, of the left edge to the #cairo_traps_t */
+static cairo_status_t
+_cairo_bo_edge_end_trap (cairo_bo_edge_t        *left,
+                         int32_t                 bot,
+                         cairo_traps_t          *traps)
+{
+    cairo_bo_trap_t *trap = &left->deferred_trap;
+
+    /* Only emit (trivial) non-degenerate trapezoids with positive height. */
+    if (likely (trap->top < bot)) {
+        _cairo_traps_add_trap (traps,
+                               trap->top, bot,
+                               &left->edge.line, &trap->right->edge.line);
+
+#if DEBUG_PRINT_STATE
+        printf ("Deferred trap: left=(%d, %d)-(%d,%d) "
+                "right=(%d,%d)-(%d,%d) top=%d, bot=%d\n",
+                left->edge.line.p1.x, left->edge.line.p1.y,
+                left->edge.line.p2.x, left->edge.line.p2.y,
+                trap->right->edge.line.p1.x, trap->right->edge.line.p1.y,
+                trap->right->edge.line.p2.x, trap->right->edge.line.p2.y,
+                trap->top, bot);
+#endif
+#if DEBUG_EVENTS
+        event_log ("end trap: %lu %lu %d %d\n",
+                   (long) left,
+                   (long) trap->right,
+                   trap->top,
+                   bot);
+#endif
+    }
+
+    trap->right = NULL;
+
+//    return _cairo_traps_status (traps);
+    return 0;
+}
+
+
+/* Start a new trapezoid at the given top y coordinate, whose edges
+ * are `edge' and `edge->next'. If `edge' already has a trapezoid,
+ * then either add it to the traps in `traps', if the trapezoid's
+ * right edge differs from `edge->next', or do nothing if the new
+ * trapezoid would be a continuation of the existing one. */
+static inline cairo_status_t
+_cairo_bo_edge_start_or_continue_trap (cairo_bo_edge_t        *left,
+                                       cairo_bo_edge_t  *right,
+                                       int               top,
+                                       cairo_traps_t        *traps)
+{
+    cairo_status_t status;
+    if (left->deferred_trap.right == right) {
+        return CAIRO_STATUS_SUCCESS;
+    }
+
+    if (left->deferred_trap.right != NULL) {
+        if (right != NULL && edges_colinear (left->deferred_trap.right, right))
+        {
+            /* continuation on right, so just swap edges */
+            left->deferred_trap.right = right;
+            return CAIRO_STATUS_SUCCESS;
+        }
+
+        status = _cairo_bo_edge_end_trap (left, top, traps);
+        if (unlikely (status))
+            return status;
+    }
+
+    if (right != NULL && ! edges_colinear (left, right)) {
+        left->deferred_trap.top = top;
+        left->deferred_trap.right = right;
+
+#if DEBUG_EVENTS
+        event_log ("begin trap: %lu %lu %d\n",
+                   (long) left,
+                   (long) right,
+                   top);
+#endif
+    }
+
+    return CAIRO_STATUS_SUCCESS;
+}
+
+static inline cairo_status_t
+_active_edges_to_traps (cairo_bo_edge_t		*left,
+			int32_t			 top,
+			cairo_fill_rule_t	 fill_rule,
+			cairo_traps_t	        *traps)
+{
+    cairo_bo_edge_t *right;
+    cairo_status_t status;
+
+#if DEBUG_PRINT_STATE
+    printf ("Processing active edges for %d\n", top);
+#endif
+
+    if (fill_rule == CAIRO_FILL_RULE_WINDING) {
+	while (left != NULL) {
+	    int in_out;
+
+	    /* Greedily search for the closing edge, so that we generate the
+	     * maximal span width with the minimal number of trapezoids.
+	     */
+	    in_out = left->edge.dir;
+
+	    /* Check if there is a co-linear edge with an existing trap */
+	    right = left->next;
+	    if (left->deferred_trap.right == NULL) {
+		while (right != NULL && right->deferred_trap.right == NULL)
+		    right = right->next;
+
+		if (right != NULL && edges_colinear (left, right)) {
+		    /* continuation on left */
+		    left->deferred_trap = right->deferred_trap;
+		    right->deferred_trap.right = NULL;
+		}
+	    }
+
+	    /* End all subsumed traps */
+	    right = left->next;
+	    while (right != NULL) {
+		if (right->deferred_trap.right != NULL) {
+		    status = _cairo_bo_edge_end_trap (right, top, traps);
+		    if (unlikely (status))
+			return status;
+		}
+
+		in_out += right->edge.dir;
+		if (in_out == 0) {
+		    cairo_bo_edge_t *next;
+		    cairo_bool_t skip = FALSE;
+
+		    /* skip co-linear edges */
+		    next = right->next;
+		    if (next != NULL)
+			skip = edges_colinear (right, next);
+
+		    if (! skip)
+			break;
+		}
+
+		right = right->next;
+	    }
+
+	    status = _cairo_bo_edge_start_or_continue_trap (left, right,
+							    top, traps);
+	    if (unlikely (status))
+		return status;
+
+	    left = right;
+	    if (left != NULL)
+		left = left->next;
+	}
+    } else {
+	while (left != NULL) {
+	    int in_out = 0;
+
+	    right = left->next;
+	    while (right != NULL) {
+		if (right->deferred_trap.right != NULL) {
+		    status = _cairo_bo_edge_end_trap (right, top, traps);
+		    if (unlikely (status))
+			return status;
+		}
+
+		if ((in_out++ & 1) == 0) {
+		    cairo_bo_edge_t *next;
+		    cairo_bool_t skip = FALSE;
+
+		    /* skip co-linear edges */
+		    next = right->next;
+		    if (next != NULL)
+			skip = edges_colinear (right, next);
+
+		    if (! skip)
+			break;
+		}
+
+		right = right->next;
+	    }
+
+	    status = _cairo_bo_edge_start_or_continue_trap (left, right,
+							    top, traps);
+	    if (unlikely (status))
+		return status;
+
+	    left = right;
+	    if (left != NULL)
+		left = left->next;
+	}
+    }
+
+    return CAIRO_STATUS_SUCCESS;
+}
+
+/* Execute a single pass of the Bentley-Ottmann algorithm on edges,
+ * generating trapezoids according to the fill_rule and appending them
+ * to traps. */
+static cairo_status_t
+_cairo_bentley_ottmann_tessellate_bo_edges (cairo_bo_event_t   **start_events,
+                                            int                  num_events,
+                                            cairo_traps_t       *traps,
+                                            int                 *num_intersections)
+{
+    cairo_status_t status = CAIRO_STATUS_SUCCESS; /* silence compiler */
+    int intersection_count = 0;
+    cairo_bo_event_queue_t event_queue;
+    cairo_bo_sweep_line_t sweep_line;
+    cairo_bo_event_t *event;
+    cairo_bo_edge_t *left, *right;
+    cairo_bo_edge_t *e1, *e2;
+
+#if DEBUG_EVENTS
+    {
+        int i;
+
+        for (i = 0; i < num_events; i++) {
+            cairo_bo_start_event_t *event =
+                ((cairo_bo_start_event_t **) start_events)[i];
+            event_log ("edge: %lu (%d, %d) (%d, %d) (%d, %d) %d\n",
+//                       (long) &events[i].edge,
+                       (long) 666,
+                       event->edge.edge.line.p1.x,
+                       event->edge.edge.line.p1.y,
+                       event->edge.edge.line.p2.x,
+                       event->edge.edge.line.p2.y,
+                       event->edge.edge.top,
+                       event->edge.edge.bottom,
+                       event->edge.edge.dir);
+        }
+    }
+#endif
+
+    _cairo_bo_event_queue_init (&event_queue, start_events, num_events);
+    _cairo_bo_sweep_line_init (&sweep_line);
+
+    while ((event = _cairo_bo_event_dequeue (&event_queue))) {
+        if (event->point.y != sweep_line.current_y) {
+            for (e1 = sweep_line.stopped; e1; e1 = e1->next) {
+                if (e1->deferred_trap.right != NULL) {
+                    status = _cairo_bo_edge_end_trap (e1,
+                                                      e1->edge.bottom,
+                                                      traps);
+                    if (unlikely (status))
+                        goto unwind;
+                }
+            }
+            sweep_line.stopped = NULL;
+
+            status = _active_edges_to_traps (sweep_line.head,
+                                             sweep_line.current_y,
+//                                             CAIRO_FILL_RULE_WINDING,
+                                             CAIRO_FILL_RULE_EVEN_ODD,
+                                             traps);
+            if (unlikely (status))
+                goto unwind;
+
+            sweep_line.current_y = event->point.y;
+        }
+
+#if DEBUG_EVENTS
+        event_log ("event: %d (%ld, %ld) %lu, %lu\n",
+                   event->type,
+                   (long) event->point.x,
+                   (long) event->point.y,
+                   (long) ((cairo_bo_queue_event_t *)event)->e1,
+                   (long) ((cairo_bo_queue_event_t *)event)->e2);
+#endif
+
+        switch (event->type) {
+        case CAIRO_BO_EVENT_TYPE_START:
+            e1 = &((cairo_bo_start_event_t *) event)->edge;
+
+            status = _cairo_bo_sweep_line_insert (&sweep_line, e1);
+            if (unlikely (status))
+                goto unwind;
+
+            status = _cairo_bo_event_queue_insert_stop (&event_queue, e1);
+            if (unlikely (status))
+                goto unwind;
+
+            /* check to see if this is a continuation of a stopped edge */
+            /* XXX change to an infinitesimal lengthening rule */
+            for (left = sweep_line.stopped; left; left = left->next) {
+                if (e1->edge.top <= left->edge.bottom &&
+                    edges_colinear (e1, left))
+                {
+                    e1->deferred_trap = left->deferred_trap;
+                    if (left->prev != NULL)
+                        left->prev = left->next;
+                    else
+                        sweep_line.stopped = left->next;
+                    if (left->next != NULL)
+                        left->next->prev = left->prev;
+                    break;
+                }
+            }
+
+            left = e1->prev;
+            right = e1->next;
+
+            if (left != NULL) {
+                status = _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue, left, e1);
+                if (unlikely (status))
+                    goto unwind;
+            }
+
+            if (right != NULL) {
+                status = _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue, e1, right);
+                if (unlikely (status))
+                    goto unwind;
+            }
+
+            break;
+
+        case CAIRO_BO_EVENT_TYPE_STOP:
+            e1 = ((cairo_bo_queue_event_t *) event)->e1;
+            _cairo_bo_event_queue_delete (&event_queue, event);
+
+            left = e1->prev;
+            right = e1->next;
+
+            _cairo_bo_sweep_line_delete (&sweep_line, e1);
+
+            /* first, check to see if we have a continuation via a fresh edge */
+            if (e1->deferred_trap.right != NULL) {
+                e1->next = sweep_line.stopped;
+                if (sweep_line.stopped != NULL)
+                    sweep_line.stopped->prev = e1;
+                sweep_line.stopped = e1;
+                e1->prev = NULL;
+            }
+
+            if (left != NULL && right != NULL) {
+                status = _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue, left, right);
+                if (unlikely (status))
+                    goto unwind;
+            }
+
+            break;
+
+        case CAIRO_BO_EVENT_TYPE_INTERSECTION:
+            break;
+            printf ("Intersection event\n");
+            e1 = ((cairo_bo_queue_event_t *) event)->e1;
+            e2 = ((cairo_bo_queue_event_t *) event)->e2;
+            _cairo_bo_event_queue_delete (&event_queue, event);
+
+            /* skip this intersection if its edges are not adjacent */
+            if (e2 != e1->next)
+                break;
+
+            intersection_count++;
+
+            left = e1->prev;
+            right = e2->next;
+
+            _cairo_bo_sweep_line_swap (&sweep_line, e1, e2);
+
+            /* after the swap e2 is left of e1 */
+
+            if (left != NULL) {
+                status = _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue, left, e2);
+                if (unlikely (status))
+                    goto unwind;
+            }
+
+            if (right != NULL) {
+                status = _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue, e1, right);
+                if (unlikely (status))
+                    goto unwind;
+            }
+
+            break;
+        }
+    }
+
+    *num_intersections = intersection_count;
+    for (e1 = sweep_line.stopped; e1; e1 = e1->next) {
+        if (e1->deferred_trap.right != NULL) {
+            status = _cairo_bo_edge_end_trap (e1, e1->edge.bottom, traps);
+            if (unlikely (status))
+                break;
+        }
+    }
+ unwind:
+    _cairo_bo_event_queue_fini (&event_queue);
+
+#if DEBUG_EVENTS
+    event_log ("\n");
+#endif
+
+    return status;
+}
+
+
+static void
+poly_area_to_start_events (POLYAREA                *poly,
+                           cairo_bo_start_event_t  *events,
+                           cairo_bo_event_t       **event_ptrs,
+                           int                     *counter)
+{
+    int i = *counter;
+    PLINE *contour;
+    POLYAREA *pa;
+    int outer_contour;
+
+    pa = poly;
+    do {
+      /* Loop over contours */
+      outer_contour = 1;
+      for (contour = pa->contours; contour != NULL; contour = contour->next) {
+        /* Loop over nodes, adding edges */
+        VNODE *bv;
+        bv = &contour->head;
+        do {
+          int x1, y1, x2, y2;
+          cairo_edge_t cairo_edge;
+          /* Node is between bv->point[0,1] and bv->next->point[0,1] */
+
+          if (bv->point[1] == bv->next->point[1]) {
+              if (bv->point[0] < bv->next->point[0]) {
+                x1 = bv->point[0];
+                y1 = bv->point[1];
+                x2 = bv->next->point[0];
+                y2 = bv->next->point[1];
+              } else {
+                x1 = bv->next->point[0];
+                y1 = bv->next->point[1];
+                x2 = bv->point[0];
+                y2 = bv->point[1];
+              }
+          } else if (bv->point[1] < bv->next->point[1]) {
+            x1 = bv->point[0];
+            y1 = bv->point[1];
+            x2 = bv->next->point[0];
+            y2 = bv->next->point[1];
+          } else {
+            x1 = bv->next->point[0];
+            y1 = bv->next->point[1];
+            x2 = bv->point[0];
+            y2 = bv->point[1];
+          }
+
+          cairo_edge.line.p1.x = x1;
+          cairo_edge.line.p1.y = y1;
+          cairo_edge.line.p2.x = x2;
+          cairo_edge.line.p2.y = y2;
+          cairo_edge.top = y1;
+          cairo_edge.bottom = y2;
+          cairo_edge.dir = outer_contour ? 1 : -1;
+
+          event_ptrs[i] = (cairo_bo_event_t *) &events[i];
+
+          events[i].type = CAIRO_BO_EVENT_TYPE_START;
+          events[i].point.y = cairo_edge.line.p1.y;
+          events[i].point.x = cairo_edge.line.p1.x;
+
+          events[i].edge.edge = cairo_edge;
+          events[i].edge.deferred_trap.right = NULL;
+          events[i].edge.prev = NULL;
+          events[i].edge.next = NULL;
+          i++;
+
+        } while ((bv = bv->next) != &contour->head);
+        outer_contour = 0;
+      }
+
+    } while ((pa = pa->f) != poly);
+
+    *counter = i;
+}
+
+
+cairo_status_t
+bo_poly_to_traps (POLYAREA *poly, cairo_traps_t *traps)
+{
+  int intersections;
+  cairo_status_t status;
+  cairo_bo_start_event_t stack_events[CAIRO_STACK_ARRAY_LENGTH (cairo_bo_start_event_t)];
+  cairo_bo_start_event_t *events;
+  cairo_bo_event_t *stack_event_ptrs[ARRAY_LENGTH (stack_events) + 1];
+  cairo_bo_event_t **event_ptrs;
+  int num_events = 0;
+  int i;
+  int n;
+  POLYAREA *pa;
+  PLINE *contour;
+
+  pa = poly;
+  do {
+    for (contour = pa->contours; contour != NULL; contour = contour->next)
+      num_events += contour->Count;
+    /* FIXME: Remove horizontal edges? */
+  } while ((pa = pa->f) != poly);
+
+  if (unlikely (0 == num_events))
+      return CAIRO_STATUS_SUCCESS;
+
+  events = stack_events;
+  event_ptrs = stack_event_ptrs;
+  if (num_events > ARRAY_LENGTH (stack_events)) {
+      events = _cairo_malloc_ab_plus_c (num_events,
+                                        sizeof (cairo_bo_start_event_t) +
+                                        sizeof (cairo_bo_event_t *),
+                                        sizeof (cairo_bo_event_t *));
+      if (unlikely (events == NULL))
+          return CAIRO_STATUS_NO_MEMORY;
+
+      event_ptrs = (cairo_bo_event_t **) (events + num_events);
+  }
+
+  i = 0;
+
+  poly_area_to_start_events (poly, events, event_ptrs, &i);
+
+  /* XXX: This would be the convenient place to throw in multiple
+   * passes of the Bentley-Ottmann algorithm. It would merely
+   * require storing the results of each pass into a temporary
+   * cairo_traps_t. */
+  status = _cairo_bentley_ottmann_tessellate_bo_edges (event_ptrs,
+                                                       num_events,
+                                                       traps,
+                                                       &intersections);
+
+  for (n = 0; n < traps->num_traps; n++) {
+    int x1, y1, x2, y2, x3, y3, x4, y4;
+
+    x1 = _line_compute_intersection_x_for_y (&traps->traps[n].left, traps->traps[n].top);
+    y1 = traps->traps[n].top;
+    x2 = _line_compute_intersection_x_for_y (&traps->traps[n].right, traps->traps[n].top);
+    y2 = traps->traps[n].top;
+    x3 = _line_compute_intersection_x_for_y (&traps->traps[n].right, traps->traps[n].bottom);
+    y3 = traps->traps[n].bottom;
+    x4 = _line_compute_intersection_x_for_y (&traps->traps[n].left, traps->traps[n].bottom);
+    y4 = traps->traps[n].bottom;
+
+#if 1
+    if (x1 == x2) {
+      hidgl_ensure_triangle_space (&buffer, 1);
+      hidgl_add_triangle (&buffer, x1, y1, x3, y3, x4, y4);
+    } else if (x3 == x4) {
+      hidgl_ensure_triangle_space (&buffer, 1);
+      hidgl_add_triangle (&buffer, x1, y1, x2, y2, x3, y3);
+    } else {
+      hidgl_ensure_triangle_space (&buffer, 2);
+      hidgl_add_triangle (&buffer, x1, y1, x2, y2, x3, y3);
+      hidgl_add_triangle (&buffer, x3, y3, x4, y4, x1, y1);
+    }
+#else
+    glBegin (GL_LINES);
+    glVertex2i (x1, y1); glVertex2i (x2, y2);
+    glVertex2i (x2, y2); glVertex2i (x3, y3);
+     glVertex2i (x3, y3); glVertex2i (x1, y1);
+    glVertex2i (x3, y3); glVertex2i (x4, y4);
+    glVertex2i (x4, y4); glVertex2i (x1, y1);
+     glVertex2i (x1, y1); glVertex2i (x3, y3);
+    glEnd ();
+#endif
+  }
+
+#if DEBUG_TRAPS
+  dump_traps (traps, "bo-polygon-out.txt");
+#endif
+
+  if (events != stack_events)
+      free (events);
+
+  return CAIRO_STATUS_SUCCESS;
+}
diff --git a/src/cairo/cairo-combsort-private.h b/src/cairo/cairo-combsort-private.h
new file mode 100644
index 0000000..ce31257
--- /dev/null
+++ b/src/cairo/cairo-combsort-private.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright © 2008 Chris Wilson
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is Chris Wilson
+ *
+ * Contributor(s):
+ *	Chris Wilson <chris@chris-wilson.co.uk>
+ */
+
+/* This fragment implements a comb sort (specifically combsort11) */
+#ifndef _HAVE_CAIRO_COMBSORT_NEWGAP
+#define _HAVE_CAIRO_COMBSORT_NEWGAP
+static inline unsigned int
+_cairo_combsort_newgap (unsigned int gap)
+{
+  gap = 10 * gap / 13;
+  if (gap == 9 || gap == 10)
+    gap = 11;
+  if (gap < 1)
+    gap = 1;
+  return gap;
+}
+#endif
+
+#define CAIRO_COMBSORT_DECLARE(NAME, TYPE, CMP) \
+static void \
+NAME (TYPE *base, unsigned int nmemb) \
+{ \
+  unsigned int gap = nmemb; \
+  unsigned int i, j; \
+  int swapped; \
+  do { \
+      gap = _cairo_combsort_newgap (gap); \
+      swapped = gap > 1; \
+      for (i = 0; i < nmemb-gap ; i++) { \
+	  j = i + gap; \
+	  if (CMP (base[i], base[j]) > 0 ) { \
+	      TYPE tmp; \
+	      tmp = base[i]; \
+	      base[i] = base[j]; \
+	      base[j] = tmp; \
+	      swapped = 1; \
+	  } \
+      } \
+  } while (swapped); \
+}
diff --git a/src/cairo/cairo-compiler-private.h b/src/cairo/cairo-compiler-private.h
new file mode 100644
index 0000000..9fe8e9b
--- /dev/null
+++ b/src/cairo/cairo-compiler-private.h
@@ -0,0 +1,203 @@
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2002 University of Southern California
+ * Copyright © 2005 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is University of Southern
+ * California.
+ *
+ * Contributor(s):
+ *	Carl D. Worth <cworth@cworth.org>
+ */
+
+#ifndef CAIRO_COMPILER_PRIVATE_H
+#define CAIRO_COMPILER_PRIVATE_H
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#if __GNUC__ >= 3 && defined(__ELF__) && !defined(__sun)
+# define slim_hidden_proto(name)		slim_hidden_proto1(name, slim_hidden_int_name(name)) cairo_private
+# define slim_hidden_proto_no_warn(name)	slim_hidden_proto1(name, slim_hidden_int_name(name)) cairo_private_no_warn
+# define slim_hidden_def(name)			slim_hidden_def1(name, slim_hidden_int_name(name))
+# define slim_hidden_int_name(name) INT_##name
+# define slim_hidden_proto1(name, internal)				\
+  extern __typeof (name) name						\
+	__asm__ (slim_hidden_asmname (internal))
+# define slim_hidden_def1(name, internal)				\
+  extern __typeof (name) EXT_##name __asm__(slim_hidden_asmname(name))	\
+	__attribute__((__alias__(slim_hidden_asmname(internal))))
+# define slim_hidden_ulp		slim_hidden_ulp1(__USER_LABEL_PREFIX__)
+# define slim_hidden_ulp1(x)		slim_hidden_ulp2(x)
+# define slim_hidden_ulp2(x)		#x
+# define slim_hidden_asmname(name)	slim_hidden_asmname1(name)
+# define slim_hidden_asmname1(name)	slim_hidden_ulp #name
+#else
+# define slim_hidden_proto(name)		int _cairo_dummy_prototype(void)
+# define slim_hidden_proto_no_warn(name)	int _cairo_dummy_prototype(void)
+# define slim_hidden_def(name)			int _cairo_dummy_prototype(void)
+#endif
+
+#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4)
+#define CAIRO_PRINTF_FORMAT(fmt_index, va_index) \
+	__attribute__((__format__(__printf__, fmt_index, va_index)))
+#else
+#define CAIRO_PRINTF_FORMAT(fmt_index, va_index)
+#endif
+
+/* slim_internal.h */
+#define CAIRO_HAS_HIDDEN_SYMBOLS 1
+#if (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3)) && defined(__ELF__) && !defined(__sun)
+#define cairo_private_no_warn	__attribute__((__visibility__("hidden")))
+#elif defined(__SUNPRO_C) && (__SUNPRO_C >= 0x550)
+#define cairo_private_no_warn	__hidden
+#else /* not gcc >= 3.3 and not Sun Studio >= 8 */
+#define cairo_private_no_warn
+#undef CAIRO_HAS_HIDDEN_SYMBOLS
+#endif
+
+#ifndef WARN_UNUSED_RESULT
+#define WARN_UNUSED_RESULT
+#endif
+/* Add attribute(warn_unused_result) if supported */
+#define cairo_warn	    WARN_UNUSED_RESULT
+#define cairo_private	    cairo_private_no_warn cairo_warn
+
+/* This macro allow us to deprecate a function by providing an alias
+   for the old function name to the new function name. With this
+   macro, binary compatibility is preserved. The macro only works on
+   some platforms --- tough.
+
+   Meanwhile, new definitions in the public header file break the
+   source code so that it will no longer link against the old
+   symbols. Instead it will give a descriptive error message
+   indicating that the old function has been deprecated by the new
+   function.
+*/
+#if __GNUC__ >= 2 && defined(__ELF__)
+# define CAIRO_FUNCTION_ALIAS(old, new)		\
+	extern __typeof (new) old		\
+	__asm__ ("" #old)			\
+	__attribute__((__alias__("" #new)))
+#else
+# define CAIRO_FUNCTION_ALIAS(old, new)
+#endif
+
+/*
+ * Cairo uses the following function attributes in order to improve the
+ * generated code (effectively by manual inter-procedural analysis).
+ *
+ *   'cairo_pure': The function is only allowed to read from its arguments
+ *                 and global memory (i.e. following a pointer argument or
+ *                 accessing a shared variable). The return value should
+ *                 only depend on its arguments, and for an identical set of
+ *                 arguments should return the same value.
+ *
+ *   'cairo_const': The function is only allowed to read from its arguments.
+ *                  It is not allowed to access global memory. The return
+ *                  value should only depend its arguments, and for an
+ *                  identical set of arguments should return the same value.
+ *                  This is currently the most strict function attribute.
+ *
+ * Both these function attributes allow gcc to perform CSE and
+ * constant-folding, with 'cairo_const 'also guaranteeing that pointer contents
+ * do not change across the function call.
+ */
+#if __GNUC__ >= 3
+#define cairo_pure __attribute__((pure))
+#define cairo_const __attribute__((const))
+#else
+#define cairo_pure
+#define cairo_const
+#endif
+
+#if defined(__GNUC__) && (__GNUC__ > 2) && defined(__OPTIMIZE__)
+#define _CAIRO_BOOLEAN_EXPR(expr)                   \
+ __extension__ ({                               \
+   int _cairo_boolean_var_;                         \
+   if (expr)                                    \
+      _cairo_boolean_var_ = 1;                      \
+   else                                         \
+      _cairo_boolean_var_ = 0;                      \
+   _cairo_boolean_var_;                             \
+})
+#define likely(expr) (__builtin_expect (_CAIRO_BOOLEAN_EXPR(expr), 1))
+#define unlikely(expr) (__builtin_expect (_CAIRO_BOOLEAN_EXPR(expr), 0))
+#else
+#define likely(expr) (expr)
+#define unlikely(expr) (expr)
+#endif
+
+#ifndef __GNUC__
+#undef __attribute__
+#define __attribute__(x)
+#endif
+
+#if (defined(__WIN32__) && !defined(__WINE__)) || defined(_MSC_VER)
+#define snprintf _snprintf
+#define popen _popen
+#define pclose _pclose
+#define hypot _hypot
+#endif
+
+#ifdef _MSC_VER
+#undef inline
+#define inline __inline
+#endif
+
+#if defined(_MSC_VER) && defined(_M_IX86)
+/* When compiling with /Gy and /OPT:ICF identical functions will be folded in together.
+   The CAIRO_ENSURE_UNIQUE macro ensures that a function is always unique and
+   will never be folded into another one. Something like this might eventually
+   be needed for GCC but it seems fine for now. */
+#define CAIRO_ENSURE_UNIQUE                       \
+    do {                                          \
+	char func[] = __FUNCTION__;               \
+	char file[] = __FILE__;                   \
+	__asm {                                   \
+	    __asm jmp __internal_skip_line_no     \
+	    __asm _emit (__LINE__ & 0xff)         \
+	    __asm _emit ((__LINE__>>8) & 0xff)    \
+	    __asm _emit ((__LINE__>>16) & 0xff)   \
+	    __asm _emit ((__LINE__>>24) & 0xff)   \
+	    __asm lea eax, func                   \
+	    __asm lea eax, file                   \
+	    __asm __internal_skip_line_no:        \
+	};                                        \
+    } while (0)
+#else
+#define CAIRO_ENSURE_UNIQUE    do { } while (0)
+#endif
+
+#ifdef __STRICT_ANSI__
+#undef inline
+#define inline __inline__
+#endif
+
+#endif
diff --git a/src/cairo/cairo-fixed-private.h b/src/cairo/cairo-fixed-private.h
new file mode 100644
index 0000000..e3add4a
--- /dev/null
+++ b/src/cairo/cairo-fixed-private.h
@@ -0,0 +1,290 @@
+/* -*- Mode: c; tab-width: 8; c-basic-offset: 4; indent-tabs-mode: t; -*- */
+/* Cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2007 Mozilla Corporation
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is Mozilla Corporation
+ *
+ * Contributor(s):
+ *	Vladimir Vukicevic <vladimir@pobox.com>
+ */
+
+#ifndef CAIRO_FIXED_PRIVATE_H
+#define CAIRO_FIXED_PRIVATE_H
+
+#include "cairo-fixed-type-private.h"
+
+#include "cairo-wideint-private.h"
+
+/* Implementation */
+
+#if (CAIRO_FIXED_BITS != 32)
+# error CAIRO_FIXED_BITS must be 32, and the type must be a 32-bit type.
+# error To remove this limitation, you will have to fix the tesselator.
+#endif
+
+#define CAIRO_FIXED_ONE        ((cairo_fixed_t)(1 << CAIRO_FIXED_FRAC_BITS))
+#define CAIRO_FIXED_ONE_DOUBLE ((double)(1 << CAIRO_FIXED_FRAC_BITS))
+#define CAIRO_FIXED_EPSILON    ((cairo_fixed_t)(1))
+
+#define CAIRO_FIXED_FRAC_MASK  (((cairo_fixed_unsigned_t)(-1)) >> (CAIRO_FIXED_BITS - CAIRO_FIXED_FRAC_BITS))
+#define CAIRO_FIXED_WHOLE_MASK (~CAIRO_FIXED_FRAC_MASK)
+
+static inline cairo_fixed_t
+_cairo_fixed_from_int (int i)
+{
+    return i << CAIRO_FIXED_FRAC_BITS;
+}
+
+/* This is the "magic number" approach to converting a double into fixed
+ * point as described here:
+ *
+ * http://www.stereopsis.com/sree/fpu2006.html (an overview)
+ * http://www.d6.com/users/checker/pdfs/gdmfp.pdf (in detail)
+ *
+ * The basic idea is to add a large enough number to the double that the
+ * literal floating point is moved up to the extent that it forces the
+ * double's value to be shifted down to the bottom of the mantissa (to make
+ * room for the large number being added in). Since the mantissa is, at a
+ * given moment in time, a fixed point integer itself, one can convert a
+ * float to various fixed point representations by moving around the point
+ * of a floating point number through arithmetic operations. This behavior
+ * is reliable on most modern platforms as it is mandated by the IEEE-754
+ * standard for floating point arithmetic.
+ *
+ * For our purposes, a "magic number" must be carefully selected that is
+ * both large enough to produce the desired point-shifting effect, and also
+ * has no lower bits in its representation that would interfere with our
+ * value at the bottom of the mantissa. The magic number is calculated as
+ * follows:
+ *
+ *          (2 ^ (MANTISSA_SIZE - FRACTIONAL_SIZE)) * 1.5
+ *
+ * where in our case:
+ *  - MANTISSA_SIZE for 64-bit doubles is 52
+ *  - FRACTIONAL_SIZE for 16.16 fixed point is 16
+ *
+ * Although this approach provides a very large speedup of this function
+ * on a wide-array of systems, it does come with two caveats:
+ *
+ * 1) It uses banker's rounding as opposed to arithmetic rounding.
+ * 2) It doesn't function properly if the FPU is in single-precision
+ *    mode.
+ */
+
+/* The 16.16 number must always be available */
+#define CAIRO_MAGIC_NUMBER_FIXED_16_16 (103079215104.0)
+
+#if CAIRO_FIXED_BITS <= 32
+#define CAIRO_MAGIC_NUMBER_FIXED ((1LL << (52 - CAIRO_FIXED_FRAC_BITS)) * 1.5)
+
+/* For 32-bit fixed point numbers */
+static inline cairo_fixed_t
+_cairo_fixed_from_double (double d)
+{
+    union {
+        double d;
+        int32_t i[2];
+    } u;
+
+    u.d = d + CAIRO_MAGIC_NUMBER_FIXED;
+#ifdef FLOAT_WORDS_BIGENDIAN
+    return u.i[1];
+#else
+    return u.i[0];
+#endif
+}
+
+#else
+# error Please define a magic number for your fixed point type!
+# error See cairo-fixed-private.h for details.
+#endif
+
+static inline cairo_fixed_t
+_cairo_fixed_from_26_6 (uint32_t i)
+{
+#if CAIRO_FIXED_FRAC_BITS > 6
+    return i << (CAIRO_FIXED_FRAC_BITS - 6);
+#else
+    return i >> (6 - CAIRO_FIXED_FRAC_BITS);
+#endif
+}
+
+static inline double
+_cairo_fixed_to_double (cairo_fixed_t f)
+{
+    return ((double) f) / CAIRO_FIXED_ONE_DOUBLE;
+}
+
+static inline int
+_cairo_fixed_is_integer (cairo_fixed_t f)
+{
+    return (f & CAIRO_FIXED_FRAC_MASK) == 0;
+}
+
+static inline int
+_cairo_fixed_integer_part (cairo_fixed_t f)
+{
+    return f >> CAIRO_FIXED_FRAC_BITS;
+}
+
+static inline int
+_cairo_fixed_integer_floor (cairo_fixed_t f)
+{
+    if (f >= 0)
+        return f >> CAIRO_FIXED_FRAC_BITS;
+    else
+        return -((-f - 1) >> CAIRO_FIXED_FRAC_BITS) - 1;
+}
+
+static inline int
+_cairo_fixed_integer_ceil (cairo_fixed_t f)
+{
+    if (f > 0)
+	return ((f - 1)>>CAIRO_FIXED_FRAC_BITS) + 1;
+    else
+	return - (-f >> CAIRO_FIXED_FRAC_BITS);
+}
+
+/* A bunch of explicit 16.16 operators; we need these
+ * to interface with pixman and other backends that require
+ * 16.16 fixed point types.
+ */
+static inline cairo_fixed_16_16_t
+_cairo_fixed_to_16_16 (cairo_fixed_t f)
+{
+#if (CAIRO_FIXED_FRAC_BITS == 16) && (CAIRO_FIXED_BITS == 32)
+    return f;
+#elif CAIRO_FIXED_FRAC_BITS > 16
+    /* We're just dropping the low bits, so we won't ever got over/underflow here */
+    return f >> (CAIRO_FIXED_FRAC_BITS - 16);
+#else
+    cairo_fixed_16_16_t x;
+
+    /* Handle overflow/underflow by clamping to the lowest/highest
+     * value representable as 16.16
+     */
+    if ((f >> CAIRO_FIXED_FRAC_BITS) < INT16_MIN) {
+	x = INT32_MIN;
+    } else if ((f >> CAIRO_FIXED_FRAC_BITS) > INT16_MAX) {
+	x = INT32_MAX;
+    } else {
+	x = f << (16 - CAIRO_FIXED_FRAC_BITS);
+    }
+
+    return x;
+#endif
+}
+
+static inline cairo_fixed_16_16_t
+_cairo_fixed_16_16_from_double (double d)
+{
+    union {
+        double d;
+        int32_t i[2];
+    } u;
+
+    u.d = d + CAIRO_MAGIC_NUMBER_FIXED_16_16;
+#ifdef FLOAT_WORDS_BIGENDIAN
+    return u.i[1];
+#else
+    return u.i[0];
+#endif
+}
+
+#if CAIRO_FIXED_BITS == 32
+
+static inline cairo_fixed_t
+_cairo_fixed_mul (cairo_fixed_t a, cairo_fixed_t b)
+{
+    cairo_int64_t temp = _cairo_int32x32_64_mul (a, b);
+    return _cairo_int64_to_int32(_cairo_int64_rsl (temp, CAIRO_FIXED_FRAC_BITS));
+}
+
+/* computes round (a * b / c) */
+static inline cairo_fixed_t
+_cairo_fixed_mul_div (cairo_fixed_t a, cairo_fixed_t b, cairo_fixed_t c)
+{
+    cairo_int64_t ab  = _cairo_int32x32_64_mul (a, b);
+    cairo_int64_t c64 = _cairo_int32_to_int64 (c);
+    return _cairo_int64_to_int32 (_cairo_int64_divrem (ab, c64).quo);
+}
+
+/* computes floor (a * b / c) */
+static inline cairo_fixed_t
+_cairo_fixed_mul_div_floor (cairo_fixed_t a, cairo_fixed_t b, cairo_fixed_t c)
+{
+    return _cairo_int64_32_div (_cairo_int32x32_64_mul (a, b), c);
+}
+
+
+static inline cairo_fixed_t
+_cairo_edge_compute_intersection_y_for_x (const cairo_point_t *p1,
+					  const cairo_point_t *p2,
+					  cairo_fixed_t x)
+{
+    cairo_fixed_t y, dx;
+
+    if (x == p1->x)
+	return p1->y;
+    if (x == p2->x)
+	return p2->y;
+
+    y = p1->y;
+    dx = p2->x - p1->x;
+    if (dx != 0)
+	y += _cairo_fixed_mul_div_floor (x - p1->x, p2->y - p1->y, dx);
+
+    return y;
+}
+
+static inline cairo_fixed_t
+_cairo_edge_compute_intersection_x_for_y (const cairo_point_t *p1,
+					  const cairo_point_t *p2,
+					  cairo_fixed_t y)
+{
+    cairo_fixed_t x, dy;
+
+    if (y == p1->y)
+	return p1->x;
+    if (y == p2->y)
+	return p2->x;
+
+    x = p1->x;
+    dy = p2->y - p1->y;
+    if (dy != 0)
+	x += _cairo_fixed_mul_div_floor (y - p1->y, p2->x - p1->x, dy);
+
+    return x;
+}
+
+#else
+# error Please define multiplication and other operands for your fixed-point type size
+#endif
+
+#endif /* CAIRO_FIXED_PRIVATE_H */
diff --git a/src/cairo/cairo-fixed-type-private.h b/src/cairo/cairo-fixed-type-private.h
new file mode 100644
index 0000000..730ed3e
--- /dev/null
+++ b/src/cairo/cairo-fixed-type-private.h
@@ -0,0 +1,75 @@
+/* -*- Mode: c; tab-width: 8; c-basic-offset: 4; indent-tabs-mode: t; -*- */
+/* Cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2007 Mozilla Corporation
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is Mozilla Corporation
+ *
+ * Contributor(s):
+ *	Vladimir Vukicevic <vladimir@pobox.com>
+ */
+
+#ifndef CAIRO_FIXED_TYPE_PRIVATE_H
+#define CAIRO_FIXED_TYPE_PRIVATE_H
+
+#include "cairo-wideint-type-private.h"
+
+/*
+ * Fixed-point configuration
+ */
+
+typedef int32_t		cairo_fixed_16_16_t;
+typedef cairo_int64_t	cairo_fixed_32_32_t;
+typedef cairo_int64_t	cairo_fixed_48_16_t;
+typedef cairo_int128_t	cairo_fixed_64_64_t;
+typedef cairo_int128_t	cairo_fixed_96_32_t;
+
+/* Eventually, we should allow changing this, but I think
+ * there are some assumptions in the tesselator about the
+ * size of a fixed type.  For now, it must be 32.
+ */
+#define CAIRO_FIXED_BITS	32
+
+/* The number of fractional bits.  Changing this involves
+ * making sure that you compute a double-to-fixed magic number.
+ * (see below).
+ */
+#define CAIRO_FIXED_FRAC_BITS	8
+
+/* A signed type %CAIRO_FIXED_BITS in size; the main fixed point type */
+typedef int32_t cairo_fixed_t;
+
+/* An unsigned type of the same size as #cairo_fixed_t */
+typedef uint32_t cairo_fixed_unsigned_t;
+
+typedef struct _cairo_point {
+    cairo_fixed_t x;
+    cairo_fixed_t y;
+} cairo_point_t;
+
+#endif /* CAIRO_FIXED_TYPE_PRIVATE_H */
diff --git a/src/cairo/cairo-freelist-private.h b/src/cairo/cairo-freelist-private.h
new file mode 100644
index 0000000..5be22b1
--- /dev/null
+++ b/src/cairo/cairo-freelist-private.h
@@ -0,0 +1,150 @@
+/*
+ * Copyright © 2006 Joonas Pihlaja
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+#ifndef CAIRO_FREELIST_H
+#define CAIRO_FREELIST_H
+
+#include "cairo-types-private.h"
+#include "cairo-compiler-private.h"
+
+/* for stand-alone compilation*/
+#ifndef VG
+#define VG(x)
+#endif
+
+#ifndef NULL
+#define NULL (void *) 0
+#endif
+
+typedef struct _cairo_freelist_node cairo_freelist_node_t;
+struct _cairo_freelist_node {
+    cairo_freelist_node_t *next;
+};
+
+typedef struct _cairo_freelist {
+    cairo_freelist_node_t *first_free_node;
+    unsigned nodesize;
+} cairo_freelist_t;
+
+typedef struct _cairo_freelist_pool cairo_freelist_pool_t;
+struct _cairo_freelist_pool {
+    cairo_freelist_pool_t *next;
+    unsigned size, rem;
+    uint8_t *data;
+};
+
+typedef struct _cairo_freepool {
+    cairo_freelist_node_t *first_free_node;
+    cairo_freelist_pool_t *pools;
+    unsigned nodesize;
+    cairo_freelist_pool_t embedded_pool;
+    uint8_t embedded_data[1000];
+} cairo_freepool_t;
+
+
+/* Initialise a freelist that will be responsible for allocating
+ * nodes of size nodesize. */
+cairo_private void
+_cairo_freelist_init (cairo_freelist_t *freelist, unsigned nodesize);
+
+/* Deallocate any nodes in the freelist. */
+cairo_private void
+_cairo_freelist_fini (cairo_freelist_t *freelist);
+
+/* Allocate a new node from the freelist.  If the freelist contains no
+ * nodes, a new one will be allocated using malloc().  The caller is
+ * responsible for calling _cairo_freelist_free() or free() on the
+ * returned node.  Returns %NULL on memory allocation error. */
+cairo_private void *
+_cairo_freelist_alloc (cairo_freelist_t *freelist);
+
+/* Allocate a new node from the freelist.  If the freelist contains no
+ * nodes, a new one will be allocated using calloc().  The caller is
+ * responsible for calling _cairo_freelist_free() or free() on the
+ * returned node.  Returns %NULL on memory allocation error. */
+cairo_private void *
+_cairo_freelist_calloc (cairo_freelist_t *freelist);
+
+/* Return a node to the freelist. This does not deallocate the memory,
+ * but makes it available for later reuse by
+ * _cairo_freelist_alloc(). */
+cairo_private void
+_cairo_freelist_free (cairo_freelist_t *freelist, void *node);
+
+
+cairo_private void
+_cairo_freepool_init (cairo_freepool_t *freepool, unsigned nodesize);
+
+cairo_private void
+_cairo_freepool_fini (cairo_freepool_t *freepool);
+
+cairo_private void *
+_cairo_freepool_alloc_from_new_pool (cairo_freepool_t *freepool);
+
+static inline void *
+_cairo_freepool_alloc_from_pool (cairo_freepool_t *freepool)
+{
+    cairo_freelist_pool_t *pool;
+    uint8_t *ptr;
+
+    pool = freepool->pools;
+    if (unlikely (freepool->nodesize > pool->rem))
+	return _cairo_freepool_alloc_from_new_pool (freepool);
+
+    ptr = pool->data;
+    pool->data += freepool->nodesize;
+    pool->rem -= freepool->nodesize;
+    VG (VALGRIND_MAKE_MEM_UNDEFINED (ptr, freepool->nodesize));
+    return ptr;
+}
+
+static inline void *
+_cairo_freepool_alloc (cairo_freepool_t *freepool)
+{
+    cairo_freelist_node_t *node;
+
+    node = freepool->first_free_node;
+    if (unlikely (node == NULL))
+	return _cairo_freepool_alloc_from_pool (freepool);
+
+    VG (VALGRIND_MAKE_MEM_DEFINED (node, sizeof (node->next)));
+    freepool->first_free_node = node->next;
+    VG (VALGRIND_MAKE_MEM_UNDEFINED (node, freepool->nodesize));
+
+    return node;
+}
+
+cairo_private cairo_status_t
+_cairo_freepool_alloc_array (cairo_freepool_t *freepool,
+			     int count,
+			     void **array);
+
+static inline void
+_cairo_freepool_free (cairo_freepool_t *freepool, void *ptr)
+{
+    cairo_freelist_node_t *node = ptr;
+
+    node->next = freepool->first_free_node;
+    freepool->first_free_node = node;
+    VG (VALGRIND_MAKE_MEM_NOACCESS (node, freepool->nodesize));
+}
+
+#endif /* CAIRO_FREELIST_H */
diff --git a/src/cairo/cairo-freelist.c b/src/cairo/cairo-freelist.c
new file mode 100644
index 0000000..6ea5c17
--- /dev/null
+++ b/src/cairo/cairo-freelist.c
@@ -0,0 +1,176 @@
+/*
+ * Copyright © 2006 Joonas Pihlaja
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "cairo-freelist-private.h"
+
+#define _cairo_error(x) (x)
+
+void
+_cairo_freelist_init (cairo_freelist_t *freelist, unsigned nodesize)
+{
+    memset (freelist, 0, sizeof (cairo_freelist_t));
+    freelist->nodesize = nodesize;
+}
+
+void
+_cairo_freelist_fini (cairo_freelist_t *freelist)
+{
+    cairo_freelist_node_t *node = freelist->first_free_node;
+    while (node) {
+	cairo_freelist_node_t *next;
+
+	VG (VALGRIND_MAKE_MEM_DEFINED (node, sizeof (node->next)));
+	next = node->next;
+
+	free (node);
+	node = next;
+    }
+}
+
+void *
+_cairo_freelist_alloc (cairo_freelist_t *freelist)
+{
+    if (freelist->first_free_node) {
+	cairo_freelist_node_t *node;
+
+	node = freelist->first_free_node;
+	VG (VALGRIND_MAKE_MEM_DEFINED (node, sizeof (node->next)));
+	freelist->first_free_node = node->next;
+	VG (VALGRIND_MAKE_MEM_UNDEFINED (node, freelist->nodesize));
+
+	return node;
+    }
+
+    return malloc (freelist->nodesize);
+}
+
+void *
+_cairo_freelist_calloc (cairo_freelist_t *freelist)
+{
+    void *node = _cairo_freelist_alloc (freelist);
+    if (node)
+	memset (node, 0, freelist->nodesize);
+    return node;
+}
+
+void
+_cairo_freelist_free (cairo_freelist_t *freelist, void *voidnode)
+{
+    cairo_freelist_node_t *node = voidnode;
+    if (node) {
+	node->next = freelist->first_free_node;
+	freelist->first_free_node = node;
+	VG (VALGRIND_MAKE_MEM_NOACCESS (node, freelist->nodesize));
+    }
+}
+
+
+void
+_cairo_freepool_init (cairo_freepool_t *freepool, unsigned nodesize)
+{
+    freepool->first_free_node = NULL;
+    freepool->pools = &freepool->embedded_pool;
+    freepool->nodesize = nodesize;
+
+    freepool->embedded_pool.next = NULL;
+    freepool->embedded_pool.size = sizeof (freepool->embedded_data);
+    freepool->embedded_pool.rem = sizeof (freepool->embedded_data);
+    freepool->embedded_pool.data = freepool->embedded_data;
+
+    VG (VALGRIND_MAKE_MEM_NOACCESS (freepool->embedded_data,
+				    sizeof (freepool->embedded_data)));
+}
+
+void
+_cairo_freepool_fini (cairo_freepool_t *freepool)
+{
+    cairo_freelist_pool_t *pool = freepool->pools;
+    while (pool != &freepool->embedded_pool) {
+	cairo_freelist_pool_t *next = pool->next;
+	free (pool);
+	pool = next;
+    }
+    VG (VALGRIND_MAKE_MEM_NOACCESS (freepool, sizeof (freepool)));
+}
+
+void *
+_cairo_freepool_alloc_from_new_pool (cairo_freepool_t *freepool)
+{
+    cairo_freelist_pool_t *pool;
+    int poolsize;
+
+    if (freepool->pools != &freepool->embedded_pool)
+	poolsize = 2 * freepool->pools->size;
+    else
+	poolsize = (128 * freepool->nodesize + 8191) & -8192;
+    pool = malloc (sizeof (cairo_freelist_pool_t) + poolsize);
+    if (unlikely (pool == NULL))
+	return pool;
+
+    pool->next = freepool->pools;
+    freepool->pools = pool;
+
+    pool->size = poolsize;
+    pool->rem = poolsize - freepool->nodesize;
+    pool->data = (uint8_t *) (pool + 1) + freepool->nodesize;
+
+    VG (VALGRIND_MAKE_MEM_NOACCESS (pool->data, poolsize));
+    VG (VALGRIND_MAKE_MEM_UNDEFINED (pool->data, freepool->nodesize));
+
+    return pool + 1;
+}
+
+cairo_status_t
+_cairo_freepool_alloc_array (cairo_freepool_t *freepool,
+			     int count,
+			     void **array)
+{
+    int i;
+
+    for (i = 0; i < count; i++) {
+	cairo_freelist_node_t *node;
+
+	node = freepool->first_free_node;
+	if (likely (node != NULL)) {
+	    VG (VALGRIND_MAKE_MEM_DEFINED (node, sizeof (node->next)));
+	    freepool->first_free_node = node->next;
+	    VG (VALGRIND_MAKE_MEM_UNDEFINED (node, freepool->nodesize));
+	} else {
+	    node = _cairo_freepool_alloc_from_pool (freepool);
+	    if (unlikely (node == NULL))
+		goto CLEANUP;
+	}
+
+	array[i] = node;
+    }
+
+    return CAIRO_STATUS_SUCCESS;
+
+  CLEANUP:
+    while (i--)
+	_cairo_freepool_free (freepool, array[i]);
+
+    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+}
diff --git a/src/cairo/cairo-list-private.h b/src/cairo/cairo-list-private.h
new file mode 100644
index 0000000..b8254bb
--- /dev/null
+++ b/src/cairo/cairo-list-private.h
@@ -0,0 +1,189 @@
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2009 Chris Wilson
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is Chris Wilson.
+ *
+ * Contributor(s):
+ *      Chris Wilson <chris@chris-wilson.co.uk>
+ *
+ */
+
+#ifndef CAIRO_LIST_PRIVATE_H
+#define CAIRO_LIST_PRIVATE_H
+
+#include "cairo-compiler-private.h"
+
+/* Basic circular, doubly linked list implementation */
+
+typedef struct _cairo_list {
+    struct _cairo_list *next, *prev;
+} cairo_list_t;
+
+#define cairo_list_entry(ptr, type, member) \
+	cairo_container_of(ptr, type, member)
+
+#define cairo_list_first_entry(ptr, type, member) \
+	cairo_list_entry((ptr)->next, type, member)
+
+#define cairo_list_last_entry(ptr, type, member) \
+	cairo_list_entry((ptr)->prev, type, member)
+
+#define cairo_list_foreach(pos, head)			\
+	for (pos = (head)->next; pos != (head);	pos = pos->next)
+
+#define cairo_list_foreach_entry(pos, type, head, member)		\
+	for (pos = cairo_list_entry((head)->next, type, member);\
+	     &pos->member != (head);					\
+	     pos = cairo_list_entry(pos->member.next, type, member))
+
+#define cairo_list_foreach_entry_safe(pos, n, type, head, member)	\
+	for (pos = cairo_list_entry ((head)->next, type, member),\
+	     n = cairo_list_entry (pos->member.next, type, member);\
+	     &pos->member != (head);					\
+	     pos = n, n = cairo_list_entry (n->member.next, type, member))
+
+#define cairo_list_foreach_entry_reverse(pos, type, head, member)	\
+	for (pos = cairo_list_entry((head)->prev, type, member);\
+	     &pos->member != (head);					\
+	     pos = cairo_list_entry(pos->member.prev, type, member))
+
+#ifdef CAIRO_LIST_DEBUG
+static inline void
+cairo_list_validate (const cairo_list_t *head)
+{
+    cairo_list_t *link;
+
+    cairo_list_foreach (link, head) {
+	assert (link->next->prev == link);
+	assert (link->prev->next == link);
+    }
+}
+#else
+#define cairo_list_validate(head)
+#endif
+
+static inline void
+cairo_list_init (cairo_list_t *entry)
+{
+    entry->next = entry;
+    entry->prev = entry;
+}
+
+static inline void
+__cairo_list_add (cairo_list_t *entry,
+	          cairo_list_t *prev,
+		  cairo_list_t *next)
+{
+    next->prev = entry;
+    entry->next = next;
+    entry->prev = prev;
+    prev->next = entry;
+}
+
+static inline void
+cairo_list_add (cairo_list_t *entry, cairo_list_t *head)
+{
+    cairo_list_validate (head);
+    __cairo_list_add (entry, head, head->next);
+    cairo_list_validate (head);
+}
+
+static inline void
+cairo_list_add_tail (cairo_list_t *entry, cairo_list_t *head)
+{
+    cairo_list_validate (head);
+    __cairo_list_add (entry, head->prev, head);
+    cairo_list_validate (head);
+}
+
+static inline void
+__cairo_list_del (cairo_list_t *prev, cairo_list_t *next)
+{
+    next->prev = prev;
+    prev->next = next;
+}
+
+static inline void
+cairo_list_del (cairo_list_t *entry)
+{
+    __cairo_list_del (entry->prev, entry->next);
+    cairo_list_init (entry);
+}
+
+static inline void
+cairo_list_move (cairo_list_t *entry, cairo_list_t *head)
+{
+    cairo_list_validate (head);
+    __cairo_list_del (entry->prev, entry->next);
+    __cairo_list_add (entry, head, head->next);
+    cairo_list_validate (head);
+}
+
+static inline void
+cairo_list_move_tail (cairo_list_t *entry, cairo_list_t *head)
+{
+    cairo_list_validate (head);
+    __cairo_list_del (entry->prev, entry->next);
+    __cairo_list_add (entry, head->prev, head);
+    cairo_list_validate (head);
+}
+
+static inline void
+cairo_list_swap (cairo_list_t *entry, cairo_list_t *other)
+{
+    cairo_list_validate (head);
+    __cairo_list_add (entry, other->prev, other->next);
+    cairo_list_init (other);
+    cairo_list_validate (head);
+}
+
+static inline cairo_bool_t
+cairo_list_is_first (const cairo_list_t *entry,
+	             const cairo_list_t *head)
+{
+    cairo_list_validate (head);
+    return entry->prev == head;
+}
+
+static inline cairo_bool_t
+cairo_list_is_last (const cairo_list_t *entry,
+	            const cairo_list_t *head)
+{
+    cairo_list_validate (head);
+    return entry->next == head;
+}
+
+static inline cairo_bool_t
+cairo_list_is_empty (const cairo_list_t *head)
+{
+    cairo_list_validate (head);
+    return head->next == head;
+}
+
+#endif /* CAIRO_LIST_PRIVATE_H */
diff --git a/src/cairo/cairo-malloc-private.h b/src/cairo/cairo-malloc-private.h
new file mode 100644
index 0000000..d812058
--- /dev/null
+++ b/src/cairo/cairo-malloc-private.h
@@ -0,0 +1,148 @@
+/* -*- Mode: c; tab-width: 8; c-basic-offset: 4; indent-tabs-mode: t; -*- */
+/* Cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2007 Mozilla Corporation
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is Mozilla Corporation
+ *
+ * Contributor(s):
+ *	Vladimir Vukicevic <vladimir@pobox.com>
+ */
+
+#ifndef CAIRO_MALLOC_PRIVATE_H
+#define CAIRO_MALLOC_PRIVATE_H
+
+#include "cairo-wideint-private.h"
+
+#if HAVE_MEMFAULT
+#include <memfault.h>
+#define CAIRO_INJECT_FAULT() MEMFAULT_INJECT_FAULT()
+#else
+#define CAIRO_INJECT_FAULT() 0
+#endif
+
+/**
+ * _cairo_malloc:
+ * @size: size in bytes
+ *
+ * Allocate @size memory using malloc().
+ * The memory should be freed using free().
+ * malloc is skipped, if 0 bytes are requested, and %NULL will be returned.
+ *
+ * Return value: A pointer to the newly allocated memory, or %NULL in
+ * case of malloc() failure or size is 0.
+ */
+
+#define _cairo_malloc(size) \
+   ((size) ? malloc((unsigned) (size)) : NULL)
+
+/**
+ * _cairo_malloc_ab:
+ * @n: number of elements to allocate
+ * @size: size of each element
+ *
+ * Allocates @n*@size memory using _cairo_malloc(), taking care to not
+ * overflow when doing the multiplication.  Behaves much like
+ * calloc(), except that the returned memory is not set to zero.
+ * The memory should be freed using free().
+ *
+ * @size should be a constant so that the compiler can optimize
+ * out a constant division.
+ *
+ * Return value: A pointer to the newly allocated memory, or %NULL in
+ * case of malloc() failure or overflow.
+ */
+
+#define _cairo_malloc_ab(a, size) \
+  ((size) && (unsigned) (a) >= INT32_MAX / (unsigned) (size) ? NULL : \
+   _cairo_malloc((unsigned) (a) * (unsigned) (size)))
+
+/**
+ * _cairo_realloc_ab:
+ * @ptr: original pointer to block of memory to be resized
+ * @n: number of elements to allocate
+ * @size: size of each element
+ *
+ * Reallocates @ptr a block of @n*@size memory using realloc(), taking
+ * care to not overflow when doing the multiplication.  The memory
+ * should be freed using free().
+ *
+ * @size should be a constant so that the compiler can optimize
+ * out a constant division.
+ *
+ * Return value: A pointer to the newly allocated memory, or %NULL in
+ * case of realloc() failure or overflow (whereupon the original block
+ * of memory * is left untouched).
+ */
+
+#define _cairo_realloc_ab(ptr, a, size) \
+  ((size) && (unsigned) (a) >= INT32_MAX / (unsigned) (size) ? NULL : \
+   realloc(ptr, (unsigned) (a) * (unsigned) (size)))
+
+/**
+ * _cairo_malloc_abc:
+ * @n: first factor of number of elements to allocate
+ * @b: second factor of number of elements to allocate
+ * @size: size of each element
+ *
+ * Allocates @n*@b*@size memory using _cairo_malloc(), taking care to not
+ * overflow when doing the multiplication.  Behaves like
+ * _cairo_malloc_ab().  The memory should be freed using free().
+ *
+ * @size should be a constant so that the compiler can optimize
+ * out a constant division.
+ *
+ * Return value: A pointer to the newly allocated memory, or %NULL in
+ * case of malloc() failure or overflow.
+ */
+
+#define _cairo_malloc_abc(a, b, size) \
+  ((b) && (unsigned) (a) >= INT32_MAX / (unsigned) (b) ? NULL : \
+   (size) && (unsigned) ((a)*(b)) >= INT32_MAX / (unsigned) (size) ? NULL : \
+   _cairo_malloc((unsigned) (a) * (unsigned) (b) * (unsigned) (size)))
+
+/**
+ * _cairo_malloc_ab_plus_c:
+ * @n: number of elements to allocate
+ * @size: size of each element
+ * @k: additional size to allocate
+ *
+ * Allocates @n*@ksize+@k memory using _cairo_malloc(), taking care to not
+ * overflow when doing the arithmetic.  Behaves like
+ * _cairo_malloc_ab().  The memory should be freed using free().
+ *
+ * Return value: A pointer to the newly allocated memory, or %NULL in
+ * case of malloc() failure or overflow.
+ */
+
+#define _cairo_malloc_ab_plus_c(n, size, k) \
+  ((size) && (unsigned) (n) >= INT32_MAX / (unsigned) (size) ? NULL : \
+   (unsigned) (k) >= INT32_MAX - (unsigned) (n) * (unsigned) (size) ? NULL : \
+   _cairo_malloc((unsigned) (n) * (unsigned) (size) + (unsigned) (k)))
+
+#endif /* CAIRO_MALLOC_PRIVATE_H */
diff --git a/src/cairo/cairo-traps-private.h b/src/cairo/cairo-traps-private.h
new file mode 100644
index 0000000..ac26aee
--- /dev/null
+++ b/src/cairo/cairo-traps-private.h
@@ -0,0 +1,152 @@
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2002 University of Southern California
+ * Copyright © 2005 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is University of Southern
+ * California.
+ *
+ * Contributor(s):
+ *	Carl D. Worth <cworth@cworth.org>
+ */
+
+/*
+ * These definitions are solely for use by the implementation of cairo
+ * and constitute no kind of standard.  If you need any of these
+ * functions, please drop me a note.  Either the library needs new
+ * functionality, or there's a way to do what you need using the
+ * existing published interfaces. cworth@cworth.org
+ */
+
+#ifndef _CAIRO_TRAPS_PRIVATE_H_
+#define _CAIRO_TRAPS_PRIVATE_H_
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "cairo-types-private.h"
+
+typedef struct _cairo_traps {
+    cairo_status_t status;
+
+    const cairo_box_t *limits;
+    int num_limits;
+
+    unsigned int maybe_region : 1; /* hint: 0 implies that it cannot be */
+    unsigned int has_intersections : 1;
+    unsigned int is_rectilinear : 1;
+    unsigned int is_rectangular : 1;
+
+    int num_traps;
+    int traps_size;
+    cairo_trapezoid_t *traps;
+    cairo_trapezoid_t  traps_embedded[16];
+} cairo_traps_t;
+
+
+/* cairo-traps.c */
+cairo_private void
+_cairo_traps_init (cairo_traps_t *traps);
+
+cairo_private void
+_cairo_traps_limit (cairo_traps_t	*traps,
+		    const cairo_box_t	*boxes,
+		    int			 num_boxes);
+
+cairo_private cairo_status_t
+_cairo_traps_init_boxes (cairo_traps_t	    *traps,
+			 const cairo_box_t    *boxes,
+			 int		     num_boxes);
+
+cairo_private void
+_cairo_traps_clear (cairo_traps_t *traps);
+
+cairo_private void
+_cairo_traps_fini (cairo_traps_t *traps);
+
+#define _cairo_traps_status(T) (T)->status
+
+cairo_private void
+_cairo_traps_translate (cairo_traps_t *traps, int x, int y);
+
+cairo_private cairo_status_t
+_cairo_traps_tessellate_rectangle (cairo_traps_t *traps,
+				   const cairo_point_t *top_left,
+				   const cairo_point_t *bottom_right);
+
+cairo_private void
+_cairo_traps_add_trap (cairo_traps_t *traps,
+		       cairo_fixed_t top, cairo_fixed_t bottom,
+		       cairo_line_t *left, cairo_line_t *right);
+
+cairo_private cairo_status_t
+_cairo_bentley_ottmann_tessellate_rectilinear_polygon (cairo_traps_t	 *traps,
+						       const cairo_polygon_t *polygon,
+						       cairo_fill_rule_t	  fill_rule);
+
+cairo_private cairo_status_t
+_cairo_bentley_ottmann_tessellate_polygon (cairo_traps_t         *traps,
+					   const cairo_polygon_t *polygon);
+
+cairo_private cairo_status_t
+_cairo_bentley_ottmann_tessellate_traps (cairo_traps_t *traps,
+					 cairo_fill_rule_t fill_rule);
+
+cairo_private cairo_status_t
+_cairo_bentley_ottmann_tessellate_rectangular_traps (cairo_traps_t *traps,
+						     cairo_fill_rule_t fill_rule);
+
+cairo_private cairo_status_t
+_cairo_bentley_ottmann_tessellate_rectilinear_traps (cairo_traps_t *traps,
+						     cairo_fill_rule_t fill_rule);
+
+cairo_private int
+_cairo_traps_contain (const cairo_traps_t *traps,
+		      double x, double y);
+
+cairo_private void
+_cairo_traps_extents (const cairo_traps_t *traps,
+		      cairo_box_t         *extents);
+
+cairo_private cairo_int_status_t
+_cairo_traps_extract_region (cairo_traps_t  *traps,
+			     cairo_region_t **region);
+
+cairo_private cairo_status_t
+_cairo_traps_path (const cairo_traps_t *traps,
+		   cairo_path_fixed_t  *path);
+
+cairo_private void
+_cairo_trapezoid_array_translate_and_scale (cairo_trapezoid_t *offset_traps,
+					    cairo_trapezoid_t *src_traps,
+					    int num_traps,
+					    double tx, double ty,
+					    double sx, double sy);
+
+#endif
diff --git a/src/cairo/cairo-traps.c b/src/cairo/cairo-traps.c
new file mode 100644
index 0000000..089f3c6
--- /dev/null
+++ b/src/cairo/cairo-traps.c
@@ -0,0 +1,438 @@
+/* -*- Mode: c; tab-width: 8; c-basic-offset: 4; indent-tabs-mode: t; -*- */
+/*
+ * Copyright © 2002 Keith Packard
+ * Copyright © 2007 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is Keith Packard
+ *
+ * Contributor(s):
+ *	Keith R. Packard <keithp@keithp.com>
+ *	Carl D. Worth <cworth@cworth.org>
+ *
+ * 2002-07-15: Converted from XRenderCompositeDoublePoly to #cairo_trap_t. Carl D. Worth
+ */
+
+#include "cairoint-minimal.h"
+#include "cairo-malloc-private.h"
+#include "cairo-traps-private.h"
+#include "cairo-fixed-private.h"
+
+#define _cairo_error(x) (x)
+
+/* private functions */
+
+void
+_cairo_traps_init (cairo_traps_t *traps)
+{
+    VG (VALGRIND_MAKE_MEM_UNDEFINED (traps, sizeof (cairo_traps_t)));
+
+    traps->status = CAIRO_STATUS_SUCCESS;
+
+    traps->maybe_region = 1;
+    traps->is_rectilinear = 0;
+    traps->is_rectangular = 0;
+
+    traps->num_traps = 0;
+
+    traps->traps_size = ARRAY_LENGTH (traps->traps_embedded);
+    traps->traps = traps->traps_embedded;
+
+    traps->num_limits = 0;
+    traps->has_intersections = FALSE;
+}
+
+void
+_cairo_traps_limit (cairo_traps_t	*traps,
+		    const cairo_box_t	*limits,
+		    int			 num_limits)
+{
+    traps->limits = limits;
+    traps->num_limits = num_limits;
+}
+
+void
+_cairo_traps_clear (cairo_traps_t *traps)
+{
+    traps->status = CAIRO_STATUS_SUCCESS;
+
+    traps->maybe_region = 1;
+    traps->is_rectilinear = 0;
+    traps->is_rectangular = 0;
+
+    traps->num_traps = 0;
+    traps->has_intersections = FALSE;
+}
+
+void
+_cairo_traps_fini (cairo_traps_t *traps)
+{
+    if (traps->traps != traps->traps_embedded)
+	free (traps->traps);
+
+    VG (VALGRIND_MAKE_MEM_NOACCESS (traps, sizeof (cairo_traps_t)));
+}
+
+/* make room for at least one more trap */
+static cairo_bool_t
+_cairo_traps_grow (cairo_traps_t *traps)
+{
+    cairo_trapezoid_t *new_traps;
+    int new_size = 4 * traps->traps_size;
+
+    if (traps->traps == traps->traps_embedded) {
+	new_traps = _cairo_malloc_ab (new_size, sizeof (cairo_trapezoid_t));
+	if (new_traps != NULL)
+	    memcpy (new_traps, traps->traps, sizeof (traps->traps_embedded));
+    } else {
+	new_traps = _cairo_realloc_ab (traps->traps,
+	                               new_size, sizeof (cairo_trapezoid_t));
+    }
+
+    if (unlikely (new_traps == NULL)) {
+	traps->status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
+	return FALSE;
+    }
+
+    traps->traps = new_traps;
+    traps->traps_size = new_size;
+    return TRUE;
+}
+
+void
+_cairo_traps_add_trap (cairo_traps_t *traps,
+		       cairo_fixed_t top, cairo_fixed_t bottom,
+		       cairo_line_t *left, cairo_line_t *right)
+{
+    cairo_trapezoid_t *trap;
+
+    if (unlikely (traps->num_traps == traps->traps_size)) {
+	if (unlikely (! _cairo_traps_grow (traps)))
+	    return;
+    }
+
+    trap = &traps->traps[traps->num_traps++];
+    trap->top = top;
+    trap->bottom = bottom;
+    trap->left = *left;
+    trap->right = *right;
+}
+
+/**
+ * _cairo_traps_init_box:
+ * @traps: a #cairo_traps_t
+ * @box: an array box that will each be converted to a single trapezoid
+ *       to store in @traps.
+ *
+ * Initializes a #cairo_traps_t to contain an array of rectangular
+ * trapezoids.
+ **/
+cairo_status_t
+_cairo_traps_init_boxes (cairo_traps_t	    *traps,
+		         const cairo_box_t  *boxes,
+			 int		     num_boxes)
+{
+    cairo_trapezoid_t *trap;
+
+    _cairo_traps_init (traps);
+
+    while (traps->traps_size < num_boxes) {
+	if (unlikely (! _cairo_traps_grow (traps))) {
+	    _cairo_traps_fini (traps);
+	    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+	}
+    }
+
+    traps->num_traps = num_boxes;
+    traps->is_rectilinear = TRUE;
+    traps->is_rectangular = TRUE;
+
+    trap = &traps->traps[0];
+    while (num_boxes--) {
+	trap->top    = boxes->p1.y;
+	trap->bottom = boxes->p2.y;
+
+	trap->left.p1   = boxes->p1;
+	trap->left.p2.x = boxes->p1.x;
+	trap->left.p2.y = boxes->p2.y;
+
+	trap->right.p1.x = boxes->p2.x;
+	trap->right.p1.y = boxes->p1.y;
+	trap->right.p2   = boxes->p2;
+
+	if (traps->maybe_region) {
+	    traps->maybe_region  = _cairo_fixed_is_integer (boxes->p1.x) &&
+		                   _cairo_fixed_is_integer (boxes->p1.y) &&
+		                   _cairo_fixed_is_integer (boxes->p2.x) &&
+		                   _cairo_fixed_is_integer (boxes->p2.y);
+	}
+
+	trap++, boxes++;
+    }
+
+    return CAIRO_STATUS_SUCCESS;
+}
+
+cairo_status_t
+_cairo_traps_tessellate_rectangle (cairo_traps_t *traps,
+				   const cairo_point_t *top_left,
+				   const cairo_point_t *bottom_right)
+{
+    cairo_line_t left;
+    cairo_line_t right;
+    cairo_fixed_t top, bottom;
+
+    if (top_left->y == bottom_right->y)
+	return CAIRO_STATUS_SUCCESS;
+
+    if (top_left->x == bottom_right->x)
+	return CAIRO_STATUS_SUCCESS;
+
+     left.p1.x =  left.p2.x = top_left->x;
+     left.p1.y = right.p1.y = top_left->y;
+    right.p1.x = right.p2.x = bottom_right->x;
+     left.p2.y = right.p2.y = bottom_right->y;
+
+     top = top_left->y;
+     bottom = bottom_right->y;
+
+    if (traps->num_limits) {
+	cairo_bool_t reversed;
+	int n;
+
+	/* support counter-clockwise winding for rectangular tessellation */
+	reversed = top_left->x > bottom_right->x;
+	if (reversed) {
+	    right.p1.x = right.p2.x = top_left->x;
+	    left.p1.x = left.p2.x = bottom_right->x;
+	}
+
+	for (n = 0; n < traps->num_limits; n++) {
+	    const cairo_box_t *limits = &traps->limits[n];
+	    cairo_line_t _left, _right;
+	    cairo_fixed_t _top, _bottom;
+
+	    if (top >= limits->p2.y)
+		continue;
+	    if (bottom <= limits->p1.y)
+		continue;
+
+	    /* Trivially reject if trapezoid is entirely to the right or
+	     * to the left of the limits. */
+	    if (left.p1.x >= limits->p2.x)
+		continue;
+	    if (right.p1.x <= limits->p1.x)
+		continue;
+
+	    /* Otherwise, clip the trapezoid to the limits. */
+	    _top = top;
+	    if (_top < limits->p1.y)
+		_top = limits->p1.y;
+
+	    _bottom = bottom;
+	    if (_bottom > limits->p2.y)
+		_bottom = limits->p2.y;
+
+	    if (_bottom <= _top)
+		continue;
+
+	    _left = left;
+	    if (_left.p1.x < limits->p1.x) {
+		_left.p1.x = limits->p1.x;
+		_left.p1.y = limits->p1.y;
+		_left.p2.x = limits->p1.x;
+		_left.p2.y = limits->p2.y;
+	    }
+
+	    _right = right;
+	    if (_right.p1.x > limits->p2.x) {
+		_right.p1.x = limits->p2.x;
+		_right.p1.y = limits->p1.y;
+		_right.p2.x = limits->p2.x;
+		_right.p2.y = limits->p2.y;
+	    }
+
+	    if (left.p1.x >= right.p1.x)
+		continue;
+
+	    if (reversed)
+		_cairo_traps_add_trap (traps, _top, _bottom, &_right, &_left);
+	    else
+		_cairo_traps_add_trap (traps, _top, _bottom, &_left, &_right);
+	}
+    } else {
+	_cairo_traps_add_trap (traps, top, bottom, &left, &right);
+    }
+
+    return traps->status;
+}
+
+void
+_cairo_traps_translate (cairo_traps_t *traps, int x, int y)
+{
+    cairo_fixed_t xoff, yoff;
+    cairo_trapezoid_t *t;
+    int i;
+
+    /* Ugh. The cairo_composite/(Render) interface doesn't allow
+       an offset for the trapezoids. Need to manually shift all
+       the coordinates to align with the offset origin of the
+       intermediate surface. */
+
+    xoff = _cairo_fixed_from_int (x);
+    yoff = _cairo_fixed_from_int (y);
+
+    for (i = 0, t = traps->traps; i < traps->num_traps; i++, t++) {
+	t->top += yoff;
+	t->bottom += yoff;
+	t->left.p1.x += xoff;
+	t->left.p1.y += yoff;
+	t->left.p2.x += xoff;
+	t->left.p2.y += yoff;
+	t->right.p1.x += xoff;
+	t->right.p1.y += yoff;
+	t->right.p2.x += xoff;
+	t->right.p2.y += yoff;
+    }
+}
+
+void
+_cairo_trapezoid_array_translate_and_scale (cairo_trapezoid_t *offset_traps,
+                                            cairo_trapezoid_t *src_traps,
+                                            int num_traps,
+                                            double tx, double ty,
+                                            double sx, double sy)
+{
+    int i;
+    cairo_fixed_t xoff = _cairo_fixed_from_double (tx);
+    cairo_fixed_t yoff = _cairo_fixed_from_double (ty);
+
+    if (sx == 1.0 && sy == 1.0) {
+        for (i = 0; i < num_traps; i++) {
+            offset_traps[i].top = src_traps[i].top + yoff;
+            offset_traps[i].bottom = src_traps[i].bottom + yoff;
+            offset_traps[i].left.p1.x = src_traps[i].left.p1.x + xoff;
+            offset_traps[i].left.p1.y = src_traps[i].left.p1.y + yoff;
+            offset_traps[i].left.p2.x = src_traps[i].left.p2.x + xoff;
+            offset_traps[i].left.p2.y = src_traps[i].left.p2.y + yoff;
+            offset_traps[i].right.p1.x = src_traps[i].right.p1.x + xoff;
+            offset_traps[i].right.p1.y = src_traps[i].right.p1.y + yoff;
+            offset_traps[i].right.p2.x = src_traps[i].right.p2.x + xoff;
+            offset_traps[i].right.p2.y = src_traps[i].right.p2.y + yoff;
+        }
+    } else {
+        cairo_fixed_t xsc = _cairo_fixed_from_double (sx);
+        cairo_fixed_t ysc = _cairo_fixed_from_double (sy);
+
+        for (i = 0; i < num_traps; i++) {
+            offset_traps[i].top = _cairo_fixed_mul (src_traps[i].top + yoff, ysc);
+            offset_traps[i].bottom = _cairo_fixed_mul (src_traps[i].bottom + yoff, ysc);
+            offset_traps[i].left.p1.x = _cairo_fixed_mul (src_traps[i].left.p1.x + xoff, xsc);
+            offset_traps[i].left.p1.y = _cairo_fixed_mul (src_traps[i].left.p1.y + yoff, ysc);
+            offset_traps[i].left.p2.x = _cairo_fixed_mul (src_traps[i].left.p2.x + xoff, xsc);
+            offset_traps[i].left.p2.y = _cairo_fixed_mul (src_traps[i].left.p2.y + yoff, ysc);
+            offset_traps[i].right.p1.x = _cairo_fixed_mul (src_traps[i].right.p1.x + xoff, xsc);
+            offset_traps[i].right.p1.y = _cairo_fixed_mul (src_traps[i].right.p1.y + yoff, ysc);
+            offset_traps[i].right.p2.x = _cairo_fixed_mul (src_traps[i].right.p2.x + xoff, xsc);
+            offset_traps[i].right.p2.y = _cairo_fixed_mul (src_traps[i].right.p2.y + yoff, ysc);
+        }
+    }
+}
+
+static cairo_fixed_t
+_line_compute_intersection_x_for_y (const cairo_line_t *line,
+				    cairo_fixed_t y)
+{
+    return _cairo_edge_compute_intersection_x_for_y (&line->p1, &line->p2, y);
+}
+
+void
+_cairo_traps_extents (const cairo_traps_t *traps,
+		      cairo_box_t *extents)
+{
+    int i;
+
+    if (traps->num_traps == 0) {
+	extents->p1.x = extents->p1.y = 0;
+	extents->p2.x = extents->p2.y = 0;
+	return;
+    }
+
+    extents->p1.x = extents->p1.y = INT32_MAX;
+    extents->p2.x = extents->p2.y = INT32_MIN;
+
+    for (i = 0; i < traps->num_traps; i++) {
+	const cairo_trapezoid_t *trap =  &traps->traps[i];
+
+	if (trap->top < extents->p1.y)
+	    extents->p1.y = trap->top;
+	if (trap->bottom > extents->p2.y)
+	    extents->p2.y = trap->bottom;
+
+	if (trap->left.p1.x < extents->p1.x) {
+	    cairo_fixed_t x = trap->left.p1.x;
+	    if (trap->top != trap->left.p1.y) {
+		x = _line_compute_intersection_x_for_y (&trap->left,
+							trap->top);
+		if (x < extents->p1.x)
+		    extents->p1.x = x;
+	    } else
+		extents->p1.x = x;
+	}
+	if (trap->left.p2.x < extents->p1.x) {
+	    cairo_fixed_t x = trap->left.p2.x;
+	    if (trap->bottom != trap->left.p2.y) {
+		x = _line_compute_intersection_x_for_y (&trap->left,
+							trap->bottom);
+		if (x < extents->p1.x)
+		    extents->p1.x = x;
+	    } else
+		extents->p1.x = x;
+	}
+
+	if (trap->right.p1.x > extents->p2.x) {
+	    cairo_fixed_t x = trap->right.p1.x;
+	    if (trap->top != trap->right.p1.y) {
+		x = _line_compute_intersection_x_for_y (&trap->right,
+							trap->top);
+		if (x > extents->p2.x)
+		    extents->p2.x = x;
+	    } else
+		extents->p2.x = x;
+	}
+	if (trap->right.p2.x > extents->p2.x) {
+	    cairo_fixed_t x = trap->right.p2.x;
+	    if (trap->bottom != trap->right.p2.y) {
+		x = _line_compute_intersection_x_for_y (&trap->right,
+							trap->bottom);
+		if (x > extents->p2.x)
+		    extents->p2.x = x;
+	    } else
+		extents->p2.x = x;
+	}
+    }
+}
diff --git a/src/cairo/cairo-types-private.h b/src/cairo/cairo-types-private.h
new file mode 100644
index 0000000..5e024f9
--- /dev/null
+++ b/src/cairo/cairo-types-private.h
@@ -0,0 +1,206 @@
+/* -*- Mode: c; tab-width: 8; c-basic-offset: 4; indent-tabs-mode: t; -*- */
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2002 University of Southern California
+ * Copyright © 2005 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is University of Southern
+ * California.
+ *
+ * Contributor(s):
+ *	Carl D. Worth <cworth@cworth.org>
+ */
+
+#ifndef CAIRO_TYPES_PRIVATE_H
+#define CAIRO_TYPES_PRIVATE_H
+
+#include "cairo.h"
+#include "cairo-fixed-type-private.h"
+#include "cairo-list-private.h"
+
+typedef struct _cairo_array cairo_array_t;
+typedef struct _cairo_backend cairo_backend_t;
+typedef struct _cairo_cache cairo_cache_t;
+typedef struct _cairo_clip cairo_clip_t;
+typedef struct _cairo_clip_path cairo_clip_path_t;
+typedef struct _cairo_gstate cairo_gstate_t;
+typedef struct _cairo_hash_entry cairo_hash_entry_t;
+typedef struct _cairo_hash_table cairo_hash_table_t;
+typedef struct _cairo_path_fixed cairo_path_fixed_t;
+
+typedef cairo_array_t cairo_user_data_array_t;
+
+/**
+ * cairo_hash_entry_t:
+ *
+ * A #cairo_hash_entry_t contains both a key and a value for
+ * #cairo_hash_table_t. User-derived types for #cairo_hash_entry_t must
+ * be type-compatible with this structure (eg. they must have an
+ * unsigned long as the first parameter. The easiest way to get this
+ * is to use:
+ *
+ * 	typedef _my_entry {
+ *	    cairo_hash_entry_t base;
+ *	    ... Remainder of key and value fields here ..
+ *	} my_entry_t;
+ *
+ * which then allows a pointer to my_entry_t to be passed to any of
+ * the #cairo_hash_table_t functions as follows without requiring a cast:
+ *
+ *	_cairo_hash_table_insert (hash_table, &my_entry->base);
+ *
+ * IMPORTANT: The caller is reponsible for initializing
+ * my_entry->base.hash with a hash code derived from the key. The
+ * essential property of the hash code is that keys_equal must never
+ * return %TRUE for two keys that have different hashes. The best hash
+ * code will reduce the frequency of two keys with the same code for
+ * which keys_equal returns %FALSE.
+ *
+ * Which parts of the entry make up the "key" and which part make up
+ * the value are entirely up to the caller, (as determined by the
+ * computation going into base.hash as well as the keys_equal
+ * function). A few of the #cairo_hash_table_t functions accept an entry
+ * which will be used exclusively as a "key", (indicated by a
+ * parameter name of key). In these cases, the value-related fields of
+ * the entry need not be initialized if so desired.
+ **/
+struct _cairo_hash_entry {
+    unsigned long hash;
+};
+
+struct _cairo_array {
+    unsigned int size;
+    unsigned int num_elements;
+    unsigned int element_size;
+    char **elements;
+
+    cairo_bool_t is_snapshot;
+};
+
+/* Sure wish C had a real enum type so that this would be distinct
+ * from #cairo_status_t. Oh well, without that, I'll use this bogus 100
+ * offset.  We want to keep it fit in int8_t as the compiler may choose
+ * that for #cairo_status_t */
+typedef enum _cairo_int_status {
+    CAIRO_INT_STATUS_UNSUPPORTED = 100,
+    CAIRO_INT_STATUS_DEGENERATE,
+    CAIRO_INT_STATUS_NOTHING_TO_DO,
+    CAIRO_INT_STATUS_FLATTEN_TRANSPARENCY,
+    CAIRO_INT_STATUS_IMAGE_FALLBACK,
+    CAIRO_INT_STATUS_ANALYZE_RECORDING_SURFACE_PATTERN,
+
+    CAIRO_INT_STATUS_LAST_STATUS
+} cairo_int_status_t;
+
+typedef struct _cairo_slope {
+    cairo_fixed_t dx;
+    cairo_fixed_t dy;
+} cairo_slope_t, cairo_distance_t;
+
+typedef struct _cairo_point_double {
+    double x;
+    double y;
+} cairo_point_double_t;
+
+typedef struct _cairo_distance_double {
+    double dx;
+    double dy;
+} cairo_distance_double_t;
+
+typedef struct _cairo_line {
+    cairo_point_t p1;
+    cairo_point_t p2;
+} cairo_line_t, cairo_box_t;
+
+typedef struct _cairo_trapezoid {
+    cairo_fixed_t top, bottom;
+    cairo_line_t left, right;
+} cairo_trapezoid_t;
+
+typedef struct _cairo_point_int {
+    int x, y;
+} cairo_point_int_t;
+
+#define CAIRO_RECT_INT_MIN (INT_MIN >> CAIRO_FIXED_FRAC_BITS)
+#define CAIRO_RECT_INT_MAX (INT_MAX >> CAIRO_FIXED_FRAC_BITS)
+
+/* Rectangles that take part in a composite operation.
+ *
+ * This defines four translations that define which pixels of the
+ * source pattern, mask, clip and destination surface take part in a
+ * general composite operation.  The idea is that the pixels at
+ *
+ *	(i,j)+(src.x, src.y) of the source,
+ *      (i,j)+(mask.x, mask.y) of the mask,
+ *      (i,j)+(clip.x, clip.y) of the clip and
+ *      (i,j)+(dst.x, dst.y) of the destination
+ *
+ * all combine together to form the result at (i,j)+(dst.x,dst.y),
+ * for i,j ranging in [0,width) and [0,height) respectively.
+ */
+typedef struct _cairo_composite_rectangles {
+        cairo_point_int_t src;
+        cairo_point_int_t mask;
+        cairo_point_int_t clip;
+        cairo_point_int_t dst;
+        int width;
+        int height;
+} cairo_composite_rectangles_t;
+
+typedef struct _cairo_edge {
+    cairo_line_t line;
+    int top, bottom;
+    int dir;
+} cairo_edge_t;
+
+typedef struct _cairo_polygon {
+    cairo_status_t status;
+
+    cairo_point_t first_point;
+    cairo_point_t last_point;
+    cairo_point_t current_point;
+    cairo_slope_t current_edge;
+    cairo_bool_t has_current_point;
+    cairo_bool_t has_current_edge;
+
+    cairo_box_t extents;
+    cairo_box_t limit;
+    const cairo_box_t *limits;
+    int num_limits;
+
+    int num_edges;
+    int edges_size;
+    cairo_edge_t *edges;
+    cairo_edge_t  edges_embedded[32];
+} cairo_polygon_t;
+
+typedef cairo_warn cairo_status_t
+(*cairo_spline_add_point_func_t) (void *closure,
+				  const cairo_point_t *point);
+
+#endif /* CAIRO_TYPES_PRIVATE_H */
diff --git a/src/cairo/cairo-wideint-private.h b/src/cairo/cairo-wideint-private.h
new file mode 100644
index 0000000..303dab1
--- /dev/null
+++ b/src/cairo/cairo-wideint-private.h
@@ -0,0 +1,329 @@
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2004 Keith Packard
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is Keith Packard
+ *
+ * Contributor(s):
+ *	Keith R. Packard <keithp@keithp.com>
+ *
+ */
+
+#ifndef CAIRO_WIDEINT_H
+#define CAIRO_WIDEINT_H
+
+#include "cairo-wideint-type-private.h"
+
+#include "cairo-compiler-private.h"
+
+/*
+ * 64-bit datatypes.  Two separate implementations, one using
+ * built-in 64-bit signed/unsigned types another implemented
+ * as a pair of 32-bit ints
+ */
+
+#define I cairo_private cairo_const
+
+#if !HAVE_UINT64_T
+
+cairo_uquorem64_t I
+_cairo_uint64_divrem (cairo_uint64_t num, cairo_uint64_t den);
+
+cairo_uint64_t I	_cairo_uint32_to_uint64 (uint32_t i);
+#define			_cairo_uint64_to_uint32(a)  ((a).lo)
+cairo_uint64_t I	_cairo_uint64_add (cairo_uint64_t a, cairo_uint64_t b);
+cairo_uint64_t I	_cairo_uint64_sub (cairo_uint64_t a, cairo_uint64_t b);
+cairo_uint64_t I	_cairo_uint64_mul (cairo_uint64_t a, cairo_uint64_t b);
+cairo_uint64_t I	_cairo_uint32x32_64_mul (uint32_t a, uint32_t b);
+cairo_uint64_t I	_cairo_uint64_lsl (cairo_uint64_t a, int shift);
+cairo_uint64_t I	_cairo_uint64_rsl (cairo_uint64_t a, int shift);
+cairo_uint64_t I	_cairo_uint64_rsa (cairo_uint64_t a, int shift);
+int	       I	_cairo_uint64_lt (cairo_uint64_t a, cairo_uint64_t b);
+int	       I	_cairo_uint64_cmp (cairo_uint64_t a, cairo_uint64_t b);
+int	       I	_cairo_uint64_eq (cairo_uint64_t a, cairo_uint64_t b);
+cairo_uint64_t I	_cairo_uint64_negate (cairo_uint64_t a);
+#define			_cairo_uint64_is_zero(a) ((a).hi == 0 && (a).lo == 0)
+#define			_cairo_uint64_negative(a)   (((int32_t) ((a).hi)) < 0)
+cairo_uint64_t I	_cairo_uint64_not (cairo_uint64_t a);
+
+#define			_cairo_uint64_to_int64(i)   (i)
+#define			_cairo_int64_to_uint64(i)   (i)
+
+cairo_int64_t  I	_cairo_int32_to_int64(int32_t i);
+#define			_cairo_int64_to_int32(a)    ((int32_t) _cairo_uint64_to_uint32(a))
+#define			_cairo_int64_add(a,b)	    _cairo_uint64_add (a,b)
+#define			_cairo_int64_sub(a,b)	    _cairo_uint64_sub (a,b)
+#define			_cairo_int64_mul(a,b)	    _cairo_uint64_mul (a,b)
+cairo_int64_t  I	_cairo_int32x32_64_mul (int32_t a, int32_t b);
+int	       I	_cairo_int64_lt (cairo_int64_t a, cairo_int64_t b);
+int	       I	_cairo_int64_cmp (cairo_int64_t a, cairo_int64_t b);
+#define			_cairo_int64_is_zero(a)	    _cairo_uint64_is_zero (a)
+#define			_cairo_int64_eq(a,b)	    _cairo_uint64_eq (a,b)
+#define			_cairo_int64_lsl(a,b)	    _cairo_uint64_lsl (a,b)
+#define			_cairo_int64_rsl(a,b)	    _cairo_uint64_rsl (a,b)
+#define			_cairo_int64_rsa(a,b)	    _cairo_uint64_rsa (a,b)
+#define			_cairo_int64_negate(a)	    _cairo_uint64_negate(a)
+#define			_cairo_int64_negative(a)    (((int32_t) ((a).hi)) < 0)
+#define			_cairo_int64_not(a)	    _cairo_uint64_not(a)
+
+#else
+
+static inline cairo_uquorem64_t
+_cairo_uint64_divrem (cairo_uint64_t num, cairo_uint64_t den)
+{
+    cairo_uquorem64_t	qr;
+
+    qr.quo = num / den;
+    qr.rem = num % den;
+    return qr;
+}
+
+#define			_cairo_uint32_to_uint64(i)  ((uint64_t) (i))
+#define			_cairo_uint64_to_uint32(i)  ((uint32_t) (i))
+#define			_cairo_uint64_add(a,b)	    ((a) + (b))
+#define			_cairo_uint64_sub(a,b)	    ((a) - (b))
+#define			_cairo_uint64_mul(a,b)	    ((a) * (b))
+#define			_cairo_uint32x32_64_mul(a,b)	((uint64_t) (a) * (b))
+#define			_cairo_uint64_lsl(a,b)	    ((a) << (b))
+#define			_cairo_uint64_rsl(a,b)	    ((uint64_t) (a) >> (b))
+#define			_cairo_uint64_rsa(a,b)	    ((uint64_t) ((int64_t) (a) >> (b)))
+#define			_cairo_uint64_lt(a,b)	    ((a) < (b))
+#define                 _cairo_uint64_cmp(a,b)       ((a) == (b) ? 0 : (a) < (b) ? -1 : 1)
+#define			_cairo_uint64_is_zero(a)    ((a) == 0)
+#define			_cairo_uint64_eq(a,b)	    ((a) == (b))
+#define			_cairo_uint64_negate(a)	    ((uint64_t) -((int64_t) (a)))
+#define			_cairo_uint64_negative(a)   ((int64_t) (a) < 0)
+#define			_cairo_uint64_not(a)	    (~(a))
+
+#define			_cairo_uint64_to_int64(i)   ((int64_t) (i))
+#define			_cairo_int64_to_uint64(i)   ((uint64_t) (i))
+
+#define			_cairo_int32_to_int64(i)    ((int64_t) (i))
+#define			_cairo_int64_to_int32(i)    ((int32_t) (i))
+#define			_cairo_int64_add(a,b)	    ((a) + (b))
+#define			_cairo_int64_sub(a,b)	    ((a) - (b))
+#define			_cairo_int64_mul(a,b)	    ((a) * (b))
+#define			_cairo_int32x32_64_mul(a,b) ((int64_t) (a) * (b))
+#define			_cairo_int64_lt(a,b)	    ((a) < (b))
+#define                 _cairo_int64_cmp(a,b)       ((a) == (b) ? 0 : (a) < (b) ? -1 : 1)
+#define			_cairo_int64_is_zero(a)     ((a) == 0)
+#define			_cairo_int64_eq(a,b)	    ((a) == (b))
+#define			_cairo_int64_lsl(a,b)	    ((a) << (b))
+#define			_cairo_int64_rsl(a,b)	    ((int64_t) ((uint64_t) (a) >> (b)))
+#define			_cairo_int64_rsa(a,b)	    ((int64_t) (a) >> (b))
+#define			_cairo_int64_negate(a)	    (-(a))
+#define			_cairo_int64_negative(a)    ((a) < 0)
+#define			_cairo_int64_not(a)	    (~(a))
+
+#endif
+
+/*
+ * 64-bit comparisions derived from lt or eq
+ */
+#define			_cairo_uint64_le(a,b)	    (!_cairo_uint64_gt(a,b))
+#define			_cairo_uint64_ne(a,b)	    (!_cairo_uint64_eq(a,b))
+#define			_cairo_uint64_ge(a,b)	    (!_cairo_uint64_lt(a,b))
+#define			_cairo_uint64_gt(a,b)	    _cairo_uint64_lt(b,a)
+
+#define			_cairo_int64_le(a,b)	    (!_cairo_int64_gt(a,b))
+#define			_cairo_int64_ne(a,b)	    (!_cairo_int64_eq(a,b))
+#define			_cairo_int64_ge(a,b)	    (!_cairo_int64_lt(a,b))
+#define			_cairo_int64_gt(a,b)	    _cairo_int64_lt(b,a)
+
+/*
+ * As the C implementation always computes both, create
+ * a function which returns both for the 'native' type as well
+ */
+
+static inline cairo_quorem64_t
+_cairo_int64_divrem (cairo_int64_t num, cairo_int64_t den)
+{
+    int			num_neg = _cairo_int64_negative (num);
+    int			den_neg = _cairo_int64_negative (den);
+    cairo_uquorem64_t	uqr;
+    cairo_quorem64_t	qr;
+
+    if (num_neg)
+	num = _cairo_int64_negate (num);
+    if (den_neg)
+	den = _cairo_int64_negate (den);
+    uqr = _cairo_uint64_divrem (num, den);
+    if (num_neg)
+	qr.rem = _cairo_int64_negate (uqr.rem);
+    else
+	qr.rem = uqr.rem;
+    if (num_neg != den_neg)
+	qr.quo = (cairo_int64_t) _cairo_int64_negate (uqr.quo);
+    else
+	qr.quo = (cairo_int64_t) uqr.quo;
+    return qr;
+}
+
+#if 0
+static inline int32_t
+_cairo_int64_32_div (cairo_int64_t num, int32_t den)
+{
+    return num / den;
+}
+#endif
+
+static inline int32_t
+_cairo_int64_32_div (cairo_int64_t num, int32_t den)
+{
+  cairo_quorem64_t quorem;
+  cairo_int64_t den64;
+
+  den64 = _cairo_int32_to_int64 (den);
+  quorem = _cairo_int64_divrem (num, den64);
+
+  return _cairo_int64_to_int32 (quorem.quo);
+}
+
+/*
+ * 128-bit datatypes.  Again, provide two implementations in
+ * case the machine has a native 128-bit datatype.  GCC supports int128_t
+ * on ia64
+ */
+
+#if !HAVE_UINT128_T
+
+cairo_uint128_t I	_cairo_uint32_to_uint128 (uint32_t i);
+cairo_uint128_t I	_cairo_uint64_to_uint128 (cairo_uint64_t i);
+#define			_cairo_uint128_to_uint64(a)	((a).lo)
+#define			_cairo_uint128_to_uint32(a)	_cairo_uint64_to_uint32(_cairo_uint128_to_uint64(a))
+cairo_uint128_t I	_cairo_uint128_add (cairo_uint128_t a, cairo_uint128_t b);
+cairo_uint128_t I	_cairo_uint128_sub (cairo_uint128_t a, cairo_uint128_t b);
+cairo_uint128_t I	_cairo_uint128_mul (cairo_uint128_t a, cairo_uint128_t b);
+cairo_uint128_t I	_cairo_uint64x64_128_mul (cairo_uint64_t a, cairo_uint64_t b);
+cairo_uint128_t I	_cairo_uint128_lsl (cairo_uint128_t a, int shift);
+cairo_uint128_t I	_cairo_uint128_rsl (cairo_uint128_t a, int shift);
+cairo_uint128_t I	_cairo_uint128_rsa (cairo_uint128_t a, int shift);
+int	        I	_cairo_uint128_lt (cairo_uint128_t a, cairo_uint128_t b);
+int	        I	_cairo_uint128_cmp (cairo_uint128_t a, cairo_uint128_t b);
+int	        I	_cairo_uint128_eq (cairo_uint128_t a, cairo_uint128_t b);
+#define			_cairo_uint128_is_zero(a) (_cairo_uint64_is_zero ((a).hi) && _cairo_uint64_is_zero ((a).lo))
+cairo_uint128_t I	_cairo_uint128_negate (cairo_uint128_t a);
+#define			_cairo_uint128_negative(a)  (_cairo_uint64_negative(a.hi))
+cairo_uint128_t I	_cairo_uint128_not (cairo_uint128_t a);
+
+#define			_cairo_uint128_to_int128(i)	(i)
+#define			_cairo_int128_to_uint128(i)	(i)
+
+cairo_int128_t  I	_cairo_int32_to_int128 (int32_t i);
+cairo_int128_t  I	_cairo_int64_to_int128 (cairo_int64_t i);
+#define			_cairo_int128_to_int64(a)   ((cairo_int64_t) (a).lo)
+#define			_cairo_int128_to_int32(a)   _cairo_int64_to_int32(_cairo_int128_to_int64(a))
+#define			_cairo_int128_add(a,b)	    _cairo_uint128_add(a,b)
+#define			_cairo_int128_sub(a,b)	    _cairo_uint128_sub(a,b)
+#define			_cairo_int128_mul(a,b)	    _cairo_uint128_mul(a,b)
+cairo_int128_t I _cairo_int64x64_128_mul (cairo_int64_t a, cairo_int64_t b);
+#define                 _cairo_int64x32_128_mul(a, b) _cairo_int64x64_128_mul(a, _cairo_int32_to_int64(b))
+#define			_cairo_int128_lsl(a,b)	    _cairo_uint128_lsl(a,b)
+#define			_cairo_int128_rsl(a,b)	    _cairo_uint128_rsl(a,b)
+#define			_cairo_int128_rsa(a,b)	    _cairo_uint128_rsa(a,b)
+int 	        I	_cairo_int128_lt (cairo_int128_t a, cairo_int128_t b);
+int	        I	_cairo_int128_cmp (cairo_int128_t a, cairo_int128_t b);
+#define			_cairo_int128_is_zero(a)    _cairo_uint128_is_zero (a)
+#define			_cairo_int128_eq(a,b)	    _cairo_uint128_eq (a,b)
+#define			_cairo_int128_negate(a)	    _cairo_uint128_negate(a)
+#define			_cairo_int128_negative(a)   (_cairo_uint128_negative(a))
+#define			_cairo_int128_not(a)	    _cairo_uint128_not(a)
+
+#else	/* !HAVE_UINT128_T */
+
+#define			_cairo_uint32_to_uint128(i) ((uint128_t) (i))
+#define			_cairo_uint64_to_uint128(i) ((uint128_t) (i))
+#define			_cairo_uint128_to_uint64(i) ((uint64_t) (i))
+#define			_cairo_uint128_to_uint32(i) ((uint32_t) (i))
+#define			_cairo_uint128_add(a,b)	    ((a) + (b))
+#define			_cairo_uint128_sub(a,b)	    ((a) - (b))
+#define			_cairo_uint128_mul(a,b)	    ((a) * (b))
+#define			_cairo_uint64x64_128_mul(a,b)	((uint128_t) (a) * (b))
+#define			_cairo_uint128_lsl(a,b)	    ((a) << (b))
+#define			_cairo_uint128_rsl(a,b)	    ((uint128_t) (a) >> (b))
+#define			_cairo_uint128_rsa(a,b)	    ((uint128_t) ((int128_t) (a) >> (b)))
+#define			_cairo_uint128_lt(a,b)	    ((a) < (b))
+#define			_cairo_uint128_cmp(a,b)	    ((a) == (b) ? 0 : (a) < (b) ? -1 : 1)
+#define			_cairo_uint128_is_zero(a)   ((a) == 0)
+#define			_cairo_uint128_eq(a,b)	    ((a) == (b))
+#define			_cairo_uint128_negate(a)    ((uint128_t) -((int128_t) (a)))
+#define			_cairo_uint128_negative(a)  ((int128_t) (a) < 0)
+#define			_cairo_uint128_not(a)	    (~(a))
+
+#define			_cairo_uint128_to_int128(i) ((int128_t) (i))
+#define			_cairo_int128_to_uint128(i) ((uint128_t) (i))
+
+#define			_cairo_int32_to_int128(i)   ((int128_t) (i))
+#define			_cairo_int64_to_int128(i)   ((int128_t) (i))
+#define			_cairo_int128_to_int64(i)   ((int64_t) (i))
+#define			_cairo_int128_to_int32(i)   ((int32_t) (i))
+#define			_cairo_int128_add(a,b)	    ((a) + (b))
+#define			_cairo_int128_sub(a,b)	    ((a) - (b))
+#define			_cairo_int128_mul(a,b)	    ((a) * (b))
+#define			_cairo_int64x64_128_mul(a,b) ((int128_t) (a) * (b))
+#define                 _cairo_int64x32_128_mul(a, b) _cairo_int64x64_128_mul(a, _cairo_int32_to_int64(b))
+#define			_cairo_int128_lt(a,b)	    ((a) < (b))
+#define			_cairo_int128_cmp(a,b)	    ((a) == (b) ? 0 : (a) < (b) ? -1 : 1)
+#define			_cairo_int128_is_zero(a)    ((a) == 0)
+#define			_cairo_int128_eq(a,b)	    ((a) == (b))
+#define			_cairo_int128_lsl(a,b)	    ((a) << (b))
+#define			_cairo_int128_rsl(a,b)	    ((int128_t) ((uint128_t) (a) >> (b)))
+#define			_cairo_int128_rsa(a,b)	    ((int128_t) (a) >> (b))
+#define			_cairo_int128_negate(a)	    (-(a))
+#define			_cairo_int128_negative(a)   ((a) < 0)
+#define			_cairo_int128_not(a)	    (~(a))
+
+#endif	/* HAVE_UINT128_T */
+
+cairo_uquorem128_t I
+_cairo_uint128_divrem (cairo_uint128_t num, cairo_uint128_t den);
+
+cairo_quorem128_t I
+_cairo_int128_divrem (cairo_int128_t num, cairo_int128_t den);
+
+cairo_uquorem64_t I
+_cairo_uint_96by64_32x64_divrem (cairo_uint128_t num,
+				 cairo_uint64_t  den);
+
+cairo_quorem64_t I
+_cairo_int_96by64_32x64_divrem (cairo_int128_t num,
+				cairo_int64_t  den);
+
+#define			_cairo_uint128_le(a,b)	    (!_cairo_uint128_gt(a,b))
+#define			_cairo_uint128_ne(a,b)	    (!_cairo_uint128_eq(a,b))
+#define			_cairo_uint128_ge(a,b)	    (!_cairo_uint128_lt(a,b))
+#define			_cairo_uint128_gt(a,b)	    _cairo_uint128_lt(b,a)
+
+#define			_cairo_int128_le(a,b)	    (!_cairo_int128_gt(a,b))
+#define			_cairo_int128_ne(a,b)	    (!_cairo_int128_eq(a,b))
+#define			_cairo_int128_ge(a,b)	    (!_cairo_int128_lt(a,b))
+#define			_cairo_int128_gt(a,b)	    _cairo_int128_lt(b,a)
+
+#undef I
+
+#endif /* CAIRO_WIDEINT_H */
diff --git a/src/cairo/cairo-wideint-type-private.h b/src/cairo/cairo-wideint-type-private.h
new file mode 100644
index 0000000..e18f48e
--- /dev/null
+++ b/src/cairo/cairo-wideint-type-private.h
@@ -0,0 +1,153 @@
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2004 Keith Packard
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is Keith Packard
+ *
+ * Contributor(s):
+ *	Keith R. Packard <keithp@keithp.com>
+ *
+ */
+
+#ifndef CAIRO_WIDEINT_TYPE_H
+#define CAIRO_WIDEINT_TYPE_H
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#if   HAVE_STDINT_H
+# include <stdint.h>
+#elif HAVE_INTTYPES_H
+# include <inttypes.h>
+#elif HAVE_SYS_INT_TYPES_H
+# include <sys/int_types.h>
+#elif defined(_MSC_VER)
+  typedef __int8 int8_t;
+  typedef unsigned __int8 uint8_t;
+  typedef __int16 int16_t;
+  typedef unsigned __int16 uint16_t;
+  typedef __int32 int32_t;
+  typedef unsigned __int32 uint32_t;
+  typedef __int64 int64_t;
+  typedef unsigned __int64 uint64_t;
+# ifndef HAVE_UINT64_T
+#  define HAVE_UINT64_T 1
+# endif
+#else
+#error Cannot find definitions for fixed-width integral types (uint8_t, uint32_t, etc.)
+#endif
+
+#ifndef INT16_MIN
+# define INT16_MIN	(-32767-1)
+#endif
+#ifndef INT16_MAX
+# define INT16_MAX	(32767)
+#endif
+#ifndef UINT16_MAX
+# define UINT16_MAX	(65535)
+#endif
+#ifndef INT32_MIN
+# define INT32_MIN	(-2147483647-1)
+#endif
+#ifndef INT32_MAX
+# define INT32_MAX	(2147483647)
+#endif
+
+#if HAVE_BYTESWAP_H
+# include <byteswap.h>
+#endif
+#ifndef bswap_16
+# define bswap_16(p) \
+	(((((uint16_t)(p)) & 0x00ff) << 8) | \
+	  (((uint16_t)(p))           >> 8));
+#endif
+#ifndef bswap_32
+# define bswap_32(p) \
+         (((((uint32_t)(p)) & 0x000000ff) << 24) | \
+	  ((((uint32_t)(p)) & 0x0000ff00) << 8)  | \
+	  ((((uint32_t)(p)) & 0x00ff0000) >> 8)  | \
+	  ((((uint32_t)(p)))              >> 24));
+#endif
+
+
+#if !HAVE_UINT64_T
+
+typedef struct _cairo_uint64 {
+    uint32_t	lo, hi;
+} cairo_uint64_t, cairo_int64_t;
+
+#else
+
+typedef uint64_t    cairo_uint64_t;
+typedef int64_t	    cairo_int64_t;
+
+#endif
+
+typedef struct _cairo_uquorem64 {
+    cairo_uint64_t	quo;
+    cairo_uint64_t	rem;
+} cairo_uquorem64_t;
+
+typedef struct _cairo_quorem64 {
+    cairo_int64_t	quo;
+    cairo_int64_t	rem;
+} cairo_quorem64_t;
+
+/* gcc has a non-standard name. */
+#if HAVE___UINT128_T && !HAVE_UINT128_T
+typedef __uint128_t uint128_t;
+typedef __int128_t int128_t;
+#define HAVE_UINT128_T 1
+#endif
+
+#if !HAVE_UINT128_T
+
+typedef struct cairo_uint128 {
+    cairo_uint64_t	lo, hi;
+} cairo_uint128_t, cairo_int128_t;
+
+#else
+
+typedef uint128_t	cairo_uint128_t;
+typedef int128_t	cairo_int128_t;
+
+#endif
+
+typedef struct _cairo_uquorem128 {
+    cairo_uint128_t	quo;
+    cairo_uint128_t	rem;
+} cairo_uquorem128_t;
+
+typedef struct _cairo_quorem128 {
+    cairo_int128_t	quo;
+    cairo_int128_t	rem;
+} cairo_quorem128_t;
+
+
+#endif /* CAIRO_WIDEINT_H */
diff --git a/src/cairo/cairo-wideint.c b/src/cairo/cairo-wideint.c
new file mode 100644
index 0000000..823ebca
--- /dev/null
+++ b/src/cairo/cairo-wideint.c
@@ -0,0 +1,819 @@
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2004 Keith Packard
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is Keith Packard
+ *
+ * Contributor(s):
+ *	Keith R. Packard <keithp@keithp.com>
+ */
+
+#include "cairo-wideint-private.h"
+
+#if HAVE_UINT64_T
+
+#define uint64_lo32(i)	((i) & 0xffffffff)
+#define uint64_hi32(i)	((i) >> 32)
+#define uint64_lo(i)	((i) & 0xffffffff)
+#define uint64_hi(i)	((i) >> 32)
+#define uint64_shift32(i)   ((i) << 32)
+#define uint64_carry32	(((uint64_t) 1) << 32)
+
+#define _cairo_uint32s_to_uint64(h,l) ((uint64_t) (h) << 32 | (l))
+
+#else
+
+#define uint64_lo32(i)	((i).lo)
+#define uint64_hi32(i)	((i).hi)
+
+static cairo_uint64_t
+uint64_lo (cairo_uint64_t i)
+{
+    cairo_uint64_t  s;
+
+    s.lo = i.lo;
+    s.hi = 0;
+    return s;
+}
+
+static cairo_uint64_t
+uint64_hi (cairo_uint64_t i)
+{
+    cairo_uint64_t  s;
+
+    s.lo = i.hi;
+    s.hi = 0;
+    return s;
+}
+
+static cairo_uint64_t
+uint64_shift32 (cairo_uint64_t i)
+{
+    cairo_uint64_t  s;
+
+    s.lo = 0;
+    s.hi = i.lo;
+    return s;
+}
+
+static const cairo_uint64_t uint64_carry32 = { 0, 1 };
+
+cairo_uint64_t
+_cairo_uint32_to_uint64 (uint32_t i)
+{
+    cairo_uint64_t	q;
+
+    q.lo = i;
+    q.hi = 0;
+    return q;
+}
+
+cairo_int64_t
+_cairo_int32_to_int64 (int32_t i)
+{
+    cairo_uint64_t	q;
+
+    q.lo = i;
+    q.hi = i < 0 ? -1 : 0;
+    return q;
+}
+
+static cairo_uint64_t
+_cairo_uint32s_to_uint64 (uint32_t h, uint32_t l)
+{
+    cairo_uint64_t	q;
+
+    q.lo = l;
+    q.hi = h;
+    return q;
+}
+
+cairo_uint64_t
+_cairo_uint64_add (cairo_uint64_t a, cairo_uint64_t b)
+{
+    cairo_uint64_t	s;
+
+    s.hi = a.hi + b.hi;
+    s.lo = a.lo + b.lo;
+    if (s.lo < a.lo)
+	s.hi++;
+    return s;
+}
+
+cairo_uint64_t
+_cairo_uint64_sub (cairo_uint64_t a, cairo_uint64_t b)
+{
+    cairo_uint64_t	s;
+
+    s.hi = a.hi - b.hi;
+    s.lo = a.lo - b.lo;
+    if (s.lo > a.lo)
+	s.hi--;
+    return s;
+}
+
+#define uint32_lo(i)	((i) & 0xffff)
+#define uint32_hi(i)	((i) >> 16)
+#define uint32_carry16	((1) << 16)
+
+cairo_uint64_t
+_cairo_uint32x32_64_mul (uint32_t a, uint32_t b)
+{
+    cairo_uint64_t  s;
+
+    uint16_t	ah, al, bh, bl;
+    uint32_t	r0, r1, r2, r3;
+
+    al = uint32_lo (a);
+    ah = uint32_hi (a);
+    bl = uint32_lo (b);
+    bh = uint32_hi (b);
+
+    r0 = (uint32_t) al * bl;
+    r1 = (uint32_t) al * bh;
+    r2 = (uint32_t) ah * bl;
+    r3 = (uint32_t) ah * bh;
+
+    r1 += uint32_hi(r0);    /* no carry possible */
+    r1 += r2;		    /* but this can carry */
+    if (r1 < r2)	    /* check */
+	r3 += uint32_carry16;
+
+    s.hi = r3 + uint32_hi(r1);
+    s.lo = (uint32_lo (r1) << 16) + uint32_lo (r0);
+    return s;
+}
+
+cairo_int64_t
+_cairo_int32x32_64_mul (int32_t a, int32_t b)
+{
+    cairo_int64_t s;
+    s = _cairo_uint32x32_64_mul ((uint32_t) a, (uint32_t) b);
+    if (a < 0)
+	s.hi -= b;
+    if (b < 0)
+	s.hi -= a;
+    return s;
+}
+
+cairo_uint64_t
+_cairo_uint64_mul (cairo_uint64_t a, cairo_uint64_t b)
+{
+    cairo_uint64_t	s;
+
+    s = _cairo_uint32x32_64_mul (a.lo, b.lo);
+    s.hi += a.lo * b.hi + a.hi * b.lo;
+    return s;
+}
+
+cairo_uint64_t
+_cairo_uint64_lsl (cairo_uint64_t a, int shift)
+{
+    if (shift >= 32)
+    {
+	a.hi = a.lo;
+	a.lo = 0;
+	shift -= 32;
+    }
+    if (shift)
+    {
+	a.hi = a.hi << shift | a.lo >> (32 - shift);
+	a.lo = a.lo << shift;
+    }
+    return a;
+}
+
+cairo_uint64_t
+_cairo_uint64_rsl (cairo_uint64_t a, int shift)
+{
+    if (shift >= 32)
+    {
+	a.lo = a.hi;
+	a.hi = 0;
+	shift -= 32;
+    }
+    if (shift)
+    {
+	a.lo = a.lo >> shift | a.hi << (32 - shift);
+	a.hi = a.hi >> shift;
+    }
+    return a;
+}
+
+#define _cairo_uint32_rsa(a,n)	((uint32_t) (((int32_t) (a)) >> (n)))
+
+cairo_int64_t
+_cairo_uint64_rsa (cairo_int64_t a, int shift)
+{
+    if (shift >= 32)
+    {
+	a.lo = a.hi;
+	a.hi = _cairo_uint32_rsa (a.hi, 31);
+	shift -= 32;
+    }
+    if (shift)
+    {
+	a.lo = a.lo >> shift | a.hi << (32 - shift);
+	a.hi = _cairo_uint32_rsa (a.hi, shift);
+    }
+    return a;
+}
+
+int
+_cairo_uint64_lt (cairo_uint64_t a, cairo_uint64_t b)
+{
+    return (a.hi < b.hi ||
+	    (a.hi == b.hi && a.lo < b.lo));
+}
+
+int
+_cairo_uint64_eq (cairo_uint64_t a, cairo_uint64_t b)
+{
+    return a.hi == b.hi && a.lo == b.lo;
+}
+
+int
+_cairo_int64_lt (cairo_int64_t a, cairo_int64_t b)
+{
+    if (_cairo_int64_negative (a) && !_cairo_int64_negative (b))
+	return 1;
+    if (!_cairo_int64_negative (a) && _cairo_int64_negative (b))
+	return 0;
+    return _cairo_uint64_lt (a, b);
+}
+
+int
+_cairo_uint64_cmp (cairo_uint64_t a, cairo_uint64_t b)
+{
+    if (a.hi < b.hi)
+	return -1;
+    else if (a.hi > b.hi)
+	return 1;
+    else if (a.lo < b.lo)
+	return -1;
+    else if (a.lo > b.lo)
+	return 1;
+    else
+	return 0;
+}
+
+int
+_cairo_int64_cmp (cairo_int64_t a, cairo_int64_t b)
+{
+    if (_cairo_int64_negative (a) && !_cairo_int64_negative (b))
+	return -1;
+    if (!_cairo_int64_negative (a) && _cairo_int64_negative (b))
+	return 1;
+
+    return _cairo_uint64_cmp (a, b);
+}
+
+cairo_uint64_t
+_cairo_uint64_not (cairo_uint64_t a)
+{
+    a.lo = ~a.lo;
+    a.hi = ~a.hi;
+    return a;
+}
+
+cairo_uint64_t
+_cairo_uint64_negate (cairo_uint64_t a)
+{
+    a.lo = ~a.lo;
+    a.hi = ~a.hi;
+    if (++a.lo == 0)
+	++a.hi;
+    return a;
+}
+
+/*
+ * Simple bit-at-a-time divide.
+ */
+cairo_uquorem64_t
+_cairo_uint64_divrem (cairo_uint64_t num, cairo_uint64_t den)
+{
+    cairo_uquorem64_t	qr;
+    cairo_uint64_t	bit;
+    cairo_uint64_t	quo;
+
+    bit = _cairo_uint32_to_uint64 (1);
+
+    /* normalize to make den >= num, but not overflow */
+    while (_cairo_uint64_lt (den, num) && (den.hi & 0x80000000) == 0)
+    {
+	bit = _cairo_uint64_lsl (bit, 1);
+	den = _cairo_uint64_lsl (den, 1);
+    }
+    quo = _cairo_uint32_to_uint64 (0);
+
+    /* generate quotient, one bit at a time */
+    while (bit.hi | bit.lo)
+    {
+	if (_cairo_uint64_le (den, num))
+	{
+	    num = _cairo_uint64_sub (num, den);
+	    quo = _cairo_uint64_add (quo, bit);
+	}
+	bit = _cairo_uint64_rsl (bit, 1);
+	den = _cairo_uint64_rsl (den, 1);
+    }
+    qr.quo = quo;
+    qr.rem = num;
+    return qr;
+}
+
+#endif /* !HAVE_UINT64_T */
+
+#if HAVE_UINT128_T
+cairo_uquorem128_t
+_cairo_uint128_divrem (cairo_uint128_t num, cairo_uint128_t den)
+{
+    cairo_uquorem128_t	qr;
+
+    qr.quo = num / den;
+    qr.rem = num % den;
+    return qr;
+}
+
+#else
+
+cairo_uint128_t
+_cairo_uint32_to_uint128 (uint32_t i)
+{
+    cairo_uint128_t	q;
+
+    q.lo = _cairo_uint32_to_uint64 (i);
+    q.hi = _cairo_uint32_to_uint64 (0);
+    return q;
+}
+
+cairo_int128_t
+_cairo_int32_to_int128 (int32_t i)
+{
+    cairo_int128_t	q;
+
+    q.lo = _cairo_int32_to_int64 (i);
+    q.hi = _cairo_int32_to_int64 (i < 0 ? -1 : 0);
+    return q;
+}
+
+cairo_uint128_t
+_cairo_uint64_to_uint128 (cairo_uint64_t i)
+{
+    cairo_uint128_t	q;
+
+    q.lo = i;
+    q.hi = _cairo_uint32_to_uint64 (0);
+    return q;
+}
+
+cairo_int128_t
+_cairo_int64_to_int128 (cairo_int64_t i)
+{
+    cairo_int128_t	q;
+
+    q.lo = i;
+    q.hi = _cairo_int32_to_int64 (_cairo_int64_negative(i) ? -1 : 0);
+    return q;
+}
+
+cairo_uint128_t
+_cairo_uint128_add (cairo_uint128_t a, cairo_uint128_t b)
+{
+    cairo_uint128_t	s;
+
+    s.hi = _cairo_uint64_add (a.hi, b.hi);
+    s.lo = _cairo_uint64_add (a.lo, b.lo);
+    if (_cairo_uint64_lt (s.lo, a.lo))
+	s.hi = _cairo_uint64_add (s.hi, _cairo_uint32_to_uint64 (1));
+    return s;
+}
+
+cairo_uint128_t
+_cairo_uint128_sub (cairo_uint128_t a, cairo_uint128_t b)
+{
+    cairo_uint128_t	s;
+
+    s.hi = _cairo_uint64_sub (a.hi, b.hi);
+    s.lo = _cairo_uint64_sub (a.lo, b.lo);
+    if (_cairo_uint64_gt (s.lo, a.lo))
+	s.hi = _cairo_uint64_sub (s.hi, _cairo_uint32_to_uint64(1));
+    return s;
+}
+
+cairo_uint128_t
+_cairo_uint64x64_128_mul (cairo_uint64_t a, cairo_uint64_t b)
+{
+    cairo_uint128_t	s;
+    uint32_t		ah, al, bh, bl;
+    cairo_uint64_t	r0, r1, r2, r3;
+
+    al = uint64_lo32 (a);
+    ah = uint64_hi32 (a);
+    bl = uint64_lo32 (b);
+    bh = uint64_hi32 (b);
+
+    r0 = _cairo_uint32x32_64_mul (al, bl);
+    r1 = _cairo_uint32x32_64_mul (al, bh);
+    r2 = _cairo_uint32x32_64_mul (ah, bl);
+    r3 = _cairo_uint32x32_64_mul (ah, bh);
+
+    r1 = _cairo_uint64_add (r1, uint64_hi (r0));    /* no carry possible */
+    r1 = _cairo_uint64_add (r1, r2);	    	    /* but this can carry */
+    if (_cairo_uint64_lt (r1, r2))		    /* check */
+	r3 = _cairo_uint64_add (r3, uint64_carry32);
+
+    s.hi = _cairo_uint64_add (r3, uint64_hi(r1));
+    s.lo = _cairo_uint64_add (uint64_shift32 (r1),
+				uint64_lo (r0));
+    return s;
+}
+
+cairo_int128_t
+_cairo_int64x64_128_mul (cairo_int64_t a, cairo_int64_t b)
+{
+    cairo_int128_t  s;
+    s = _cairo_uint64x64_128_mul (_cairo_int64_to_uint64(a),
+				  _cairo_int64_to_uint64(b));
+    if (_cairo_int64_negative (a))
+	s.hi = _cairo_uint64_sub (s.hi,
+				  _cairo_int64_to_uint64 (b));
+    if (_cairo_int64_negative (b))
+	s.hi = _cairo_uint64_sub (s.hi,
+				  _cairo_int64_to_uint64 (a));
+    return s;
+}
+
+cairo_uint128_t
+_cairo_uint128_mul (cairo_uint128_t a, cairo_uint128_t b)
+{
+    cairo_uint128_t	s;
+
+    s = _cairo_uint64x64_128_mul (a.lo, b.lo);
+    s.hi = _cairo_uint64_add (s.hi,
+				_cairo_uint64_mul (a.lo, b.hi));
+    s.hi = _cairo_uint64_add (s.hi,
+				_cairo_uint64_mul (a.hi, b.lo));
+    return s;
+}
+
+cairo_uint128_t
+_cairo_uint128_lsl (cairo_uint128_t a, int shift)
+{
+    if (shift >= 64)
+    {
+	a.hi = a.lo;
+	a.lo = _cairo_uint32_to_uint64 (0);
+	shift -= 64;
+    }
+    if (shift)
+    {
+	a.hi = _cairo_uint64_add (_cairo_uint64_lsl (a.hi, shift),
+				    _cairo_uint64_rsl (a.lo, (64 - shift)));
+	a.lo = _cairo_uint64_lsl (a.lo, shift);
+    }
+    return a;
+}
+
+cairo_uint128_t
+_cairo_uint128_rsl (cairo_uint128_t a, int shift)
+{
+    if (shift >= 64)
+    {
+	a.lo = a.hi;
+	a.hi = _cairo_uint32_to_uint64 (0);
+	shift -= 64;
+    }
+    if (shift)
+    {
+	a.lo = _cairo_uint64_add (_cairo_uint64_rsl (a.lo, shift),
+				    _cairo_uint64_lsl (a.hi, (64 - shift)));
+	a.hi = _cairo_uint64_rsl (a.hi, shift);
+    }
+    return a;
+}
+
+cairo_uint128_t
+_cairo_uint128_rsa (cairo_int128_t a, int shift)
+{
+    if (shift >= 64)
+    {
+	a.lo = a.hi;
+	a.hi = _cairo_uint64_rsa (a.hi, 64-1);
+	shift -= 64;
+    }
+    if (shift)
+    {
+	a.lo = _cairo_uint64_add (_cairo_uint64_rsl (a.lo, shift),
+				    _cairo_uint64_lsl (a.hi, (64 - shift)));
+	a.hi = _cairo_uint64_rsa (a.hi, shift);
+    }
+    return a;
+}
+
+int
+_cairo_uint128_lt (cairo_uint128_t a, cairo_uint128_t b)
+{
+    return (_cairo_uint64_lt (a.hi, b.hi) ||
+	    (_cairo_uint64_eq (a.hi, b.hi) &&
+	     _cairo_uint64_lt (a.lo, b.lo)));
+}
+
+int
+_cairo_int128_lt (cairo_int128_t a, cairo_int128_t b)
+{
+    if (_cairo_int128_negative (a) && !_cairo_int128_negative (b))
+	return 1;
+    if (!_cairo_int128_negative (a) && _cairo_int128_negative (b))
+	return 0;
+    return _cairo_uint128_lt (a, b);
+}
+
+int
+_cairo_uint128_cmp (cairo_uint128_t a, cairo_uint128_t b)
+{
+    int cmp;
+
+    cmp = _cairo_uint64_cmp (a.hi, b.hi);
+    if (cmp)
+	return cmp;
+    return _cairo_uint64_cmp (a.lo, b.lo);
+}
+
+int
+_cairo_int128_cmp (cairo_int128_t a, cairo_int128_t b)
+{
+    if (_cairo_int128_negative (a) && !_cairo_int128_negative (b))
+	return -1;
+    if (!_cairo_int128_negative (a) && _cairo_int128_negative (b))
+	return 1;
+
+    return _cairo_uint128_cmp (a, b);
+}
+
+int
+_cairo_uint128_eq (cairo_uint128_t a, cairo_uint128_t b)
+{
+    return (_cairo_uint64_eq (a.hi, b.hi) &&
+	    _cairo_uint64_eq (a.lo, b.lo));
+}
+
+#if HAVE_UINT64_T
+#define _cairo_msbset64(q)  (q & ((uint64_t) 1 << 63))
+#else
+#define _cairo_msbset64(q)  (q.hi & ((uint32_t) 1 << 31))
+#endif
+
+cairo_uquorem128_t
+_cairo_uint128_divrem (cairo_uint128_t num, cairo_uint128_t den)
+{
+    cairo_uquorem128_t	qr;
+    cairo_uint128_t	bit;
+    cairo_uint128_t	quo;
+
+    bit = _cairo_uint32_to_uint128 (1);
+
+    /* normalize to make den >= num, but not overflow */
+    while (_cairo_uint128_lt (den, num) && !_cairo_msbset64(den.hi))
+    {
+	bit = _cairo_uint128_lsl (bit, 1);
+	den = _cairo_uint128_lsl (den, 1);
+    }
+    quo = _cairo_uint32_to_uint128 (0);
+
+    /* generate quotient, one bit at a time */
+    while (_cairo_uint128_ne (bit, _cairo_uint32_to_uint128(0)))
+    {
+	if (_cairo_uint128_le (den, num))
+	{
+	    num = _cairo_uint128_sub (num, den);
+	    quo = _cairo_uint128_add (quo, bit);
+	}
+	bit = _cairo_uint128_rsl (bit, 1);
+	den = _cairo_uint128_rsl (den, 1);
+    }
+    qr.quo = quo;
+    qr.rem = num;
+    return qr;
+}
+
+cairo_int128_t
+_cairo_int128_negate (cairo_int128_t a)
+{
+    a.lo = _cairo_uint64_not (a.lo);
+    a.hi = _cairo_uint64_not (a.hi);
+    return _cairo_uint128_add (a, _cairo_uint32_to_uint128 (1));
+}
+
+cairo_int128_t
+_cairo_int128_not (cairo_int128_t a)
+{
+    a.lo = _cairo_uint64_not (a.lo);
+    a.hi = _cairo_uint64_not (a.hi);
+    return a;
+}
+
+#endif /* !HAVE_UINT128_T */
+
+cairo_quorem128_t
+_cairo_int128_divrem (cairo_int128_t num, cairo_int128_t den)
+{
+    int			num_neg = _cairo_int128_negative (num);
+    int			den_neg = _cairo_int128_negative (den);
+    cairo_uquorem128_t	uqr;
+    cairo_quorem128_t	qr;
+
+    if (num_neg)
+	num = _cairo_int128_negate (num);
+    if (den_neg)
+	den = _cairo_int128_negate (den);
+    uqr = _cairo_uint128_divrem (num, den);
+    if (num_neg)
+	qr.rem = _cairo_int128_negate (uqr.rem);
+    else
+	qr.rem = uqr.rem;
+    if (num_neg != den_neg)
+	qr.quo = _cairo_int128_negate (uqr.quo);
+    else
+	qr.quo = uqr.quo;
+    return qr;
+}
+
+/**
+ * _cairo_uint_96by64_32x64_divrem:
+ *
+ * Compute a 32 bit quotient and 64 bit remainder of a 96 bit unsigned
+ * dividend and 64 bit divisor.  If the quotient doesn't fit into 32
+ * bits then the returned remainder is equal to the divisor, and the
+ * quotient is the largest representable 64 bit integer.  It is an
+ * error to call this function with the high 32 bits of @num being
+ * non-zero. */
+cairo_uquorem64_t
+_cairo_uint_96by64_32x64_divrem (cairo_uint128_t num,
+				 cairo_uint64_t den)
+{
+    cairo_uquorem64_t result;
+    cairo_uint64_t B = _cairo_uint32s_to_uint64 (1, 0);
+
+    /* These are the high 64 bits of the *96* bit numerator.  We're
+     * going to represent the numerator as xB + y, where x is a 64,
+     * and y is a 32 bit number. */
+    cairo_uint64_t x = _cairo_uint128_to_uint64 (_cairo_uint128_rsl(num, 32));
+
+    /* Initialise the result to indicate overflow. */
+    result.quo = _cairo_uint32s_to_uint64 (-1U, -1U);
+    result.rem = den;
+
+    /* Don't bother if the quotient is going to overflow. */
+    if (_cairo_uint64_ge (x, den)) {
+	return /* overflow */ result;
+    }
+
+    if (_cairo_uint64_lt (x, B)) {
+	/* When the final quotient is known to fit in 32 bits, then
+	 * num < 2^64 if and only if den < 2^32. */
+	return _cairo_uint64_divrem (_cairo_uint128_to_uint64 (num), den);
+    }
+    else {
+	/* Denominator is >= 2^32. the numerator is >= 2^64, and the
+	 * division won't overflow: need two divrems.  Write the
+	 * numerator and denominator as
+	 *
+	 *	num = xB + y		x : 64 bits, y : 32 bits
+	 *	den = uB + v		u, v : 32 bits
+	 */
+	uint32_t y = _cairo_uint128_to_uint32 (num);
+	uint32_t u = uint64_hi32 (den);
+	uint32_t v = _cairo_uint64_to_uint32 (den);
+
+	/* Compute a lower bound approximate quotient of num/den
+	 * from x/(u+1).  Then we have
+	 *
+	 * x	= q(u+1) + r	; q : 32 bits, r <= u : 32 bits.
+	 *
+	 * xB + y	= q(u+1)B	+ (rB+y)
+	 *		= q(uB + B + v - v) + (rB+y)
+	 *		= q(uB + v)	+ qB - qv + (rB+y)
+	 *		= q(uB + v)	+ q(B-v) + (rB+y)
+	 *
+	 * The true quotient of num/den then is q plus the
+	 * contribution of q(B-v) + (rB+y).  The main contribution
+	 * comes from the term q(B-v), with the term (rB+y) only
+	 * contributing at most one part.
+	 *
+	 * The term q(B-v) must fit into 64 bits, since q fits into 32
+	 * bits on account of being a lower bound to the true
+	 * quotient, and as B-v <= 2^32, we may safely use a single
+	 * 64/64 bit division to find its contribution. */
+
+	cairo_uquorem64_t quorem;
+	cairo_uint64_t remainder; /* will contain final remainder */
+	uint32_t quotient;	/* will contain final quotient. */
+	uint32_t q;
+	uint32_t r;
+
+	/* Approximate quotient by dividing the high 64 bits of num by
+	 * u+1. Watch out for overflow of u+1. */
+	if (u+1) {
+	    quorem = _cairo_uint64_divrem (x, _cairo_uint32_to_uint64 (u+1));
+	    q = _cairo_uint64_to_uint32 (quorem.quo);
+	    r = _cairo_uint64_to_uint32 (quorem.rem);
+	}
+	else {
+	    q = uint64_hi32 (x);
+	    r = _cairo_uint64_to_uint32 (x);
+	}
+	quotient = q;
+
+	/* Add the main term's contribution to quotient.  Note B-v =
+	 * -v as an uint32 (unless v = 0) */
+	if (v)
+	    quorem = _cairo_uint64_divrem (_cairo_uint32x32_64_mul (q, -v), den);
+	else
+	    quorem = _cairo_uint64_divrem (_cairo_uint32s_to_uint64 (q, 0), den);
+	quotient += _cairo_uint64_to_uint32 (quorem.quo);
+
+	/* Add the contribution of the subterm and start computing the
+	 * true remainder. */
+	remainder = _cairo_uint32s_to_uint64 (r, y);
+	if (_cairo_uint64_ge (remainder, den)) {
+	    remainder = _cairo_uint64_sub (remainder, den);
+	    quotient++;
+	}
+
+	/* Add the contribution of the main term's remainder. The
+	 * funky test here checks that remainder + main_rem >= den,
+	 * taking into account overflow of the addition. */
+	remainder = _cairo_uint64_add (remainder, quorem.rem);
+	if (_cairo_uint64_ge (remainder, den) ||
+	    _cairo_uint64_lt (remainder, quorem.rem))
+	{
+	    remainder = _cairo_uint64_sub (remainder, den);
+	    quotient++;
+	}
+
+	result.quo = _cairo_uint32_to_uint64 (quotient);
+	result.rem = remainder;
+    }
+    return result;
+}
+
+cairo_quorem64_t
+_cairo_int_96by64_32x64_divrem (cairo_int128_t num, cairo_int64_t den)
+{
+    int			num_neg = _cairo_int128_negative (num);
+    int			den_neg = _cairo_int64_negative (den);
+    cairo_uint64_t	nonneg_den;
+    cairo_uquorem64_t	uqr;
+    cairo_quorem64_t	qr;
+
+    if (num_neg)
+	num = _cairo_int128_negate (num);
+    if (den_neg)
+	nonneg_den = _cairo_int64_negate (den);
+    else
+	nonneg_den = den;
+
+    uqr = _cairo_uint_96by64_32x64_divrem (num, nonneg_den);
+    if (_cairo_uint64_eq (uqr.rem, nonneg_den)) {
+	/* bail on overflow. */
+	qr.quo = _cairo_uint32s_to_uint64 (0x7FFFFFFF, -1U);;
+	qr.rem = den;
+	return qr;
+    }
+
+    if (num_neg)
+	qr.rem = _cairo_int64_negate (uqr.rem);
+    else
+	qr.rem = uqr.rem;
+    if (num_neg != den_neg)
+	qr.quo = _cairo_int64_negate (uqr.quo);
+    else
+	qr.quo = uqr.quo;
+    return qr;
+}
diff --git a/src/cairo/cairo.h b/src/cairo/cairo.h
new file mode 100644
index 0000000..6c43402
--- /dev/null
+++ b/src/cairo/cairo.h
@@ -0,0 +1,2549 @@
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2002 University of Southern California
+ * Copyright © 2005 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is University of Southern
+ * California.
+ *
+ * Contributor(s):
+ *	Carl D. Worth <cworth@cworth.org>
+ */
+
+#ifndef CAIRO_H
+#define CAIRO_H
+
+#include "cairo-features.h"
+
+#ifdef  __cplusplus
+# define CAIRO_BEGIN_DECLS  extern "C" {
+# define CAIRO_END_DECLS    }
+#else
+# define CAIRO_BEGIN_DECLS
+# define CAIRO_END_DECLS
+#endif
+
+#ifndef cairo_public
+# define cairo_public
+#endif
+
+CAIRO_BEGIN_DECLS
+
+#define CAIRO_VERSION_ENCODE(major, minor, micro) (	\
+	  ((major) * 10000)				\
+	+ ((minor) *   100)				\
+	+ ((micro) *     1))
+
+#define CAIRO_VERSION CAIRO_VERSION_ENCODE(	\
+	CAIRO_VERSION_MAJOR,			\
+	CAIRO_VERSION_MINOR,			\
+	CAIRO_VERSION_MICRO)
+
+
+#define CAIRO_VERSION_STRINGIZE_(major, minor, micro)	\
+	#major"."#minor"."#micro
+#define CAIRO_VERSION_STRINGIZE(major, minor, micro)	\
+	CAIRO_VERSION_STRINGIZE_(major, minor, micro)
+
+#define CAIRO_VERSION_STRING CAIRO_VERSION_STRINGIZE(	\
+	CAIRO_VERSION_MAJOR,				\
+	CAIRO_VERSION_MINOR,				\
+	CAIRO_VERSION_MICRO)
+
+#if 0
+cairo_public const char*
+cairo_version_string (void);
+#endif
+/**
+ * cairo_bool_t:
+ *
+ * #cairo_bool_t is used for boolean values. Returns of type
+ * #cairo_bool_t will always be either 0 or 1, but testing against
+ * these values explicitly is not encouraged; just use the
+ * value as a boolean condition.
+ *
+ * <informalexample><programlisting>
+ *  if (cairo_in_stroke (cr, x, y)) {
+ *      /<!-- -->* do something *<!-- -->/
+ *  }
+ * </programlisting></informalexample>
+ **/
+typedef int cairo_bool_t;
+
+/**
+ * cairo_t:
+ *
+ * A #cairo_t contains the current state of the rendering device,
+ * including coordinates of yet to be drawn shapes.
+ *
+ * Cairo contexts, as #cairo_t objects are named, are central to
+ * cairo and all drawing with cairo is always done to a #cairo_t
+ * object.
+ *
+ * Memory management of #cairo_t is done with
+ * cairo_reference() and cairo_destroy().
+ **/
+typedef struct _cairo cairo_t;
+
+/**
+ * cairo_surface_t:
+ *
+ * A #cairo_surface_t represents an image, either as the destination
+ * of a drawing operation or as source when drawing onto another
+ * surface.  To draw to a #cairo_surface_t, create a cairo context
+ * with the surface as the target, using cairo_create().
+ *
+ * There are different subtypes of #cairo_surface_t for
+ * different drawing backends; for example, cairo_image_surface_create()
+ * creates a bitmap image in memory.
+ * The type of a surface can be queried with cairo_surface_get_type().
+ *
+ * The initial contents of a surface after creation depend upon the manner
+ * of its creation. If cairo creates the surface and backing storage for
+ * the user, it will be initially cleared; for example,
+ * cairo_image_surface_create() and cairo_surface_create_similar().
+ * Alternatively, if the user passes in a reference to some backing storage
+ * and asks cairo to wrap that in a #cairo_surface_t, then the contents are
+ * not modified; for example, cairo_image_surface_create_for_data() and
+ * cairo_xlib_surface_create().
+ *
+ * Memory management of #cairo_surface_t is done with
+ * cairo_surface_reference() and cairo_surface_destroy().
+ **/
+typedef struct _cairo_surface cairo_surface_t;
+
+/**
+ * cairo_matrix_t:
+ * @xx: xx component of the affine transformation
+ * @yx: yx component of the affine transformation
+ * @xy: xy component of the affine transformation
+ * @yy: yy component of the affine transformation
+ * @x0: X translation component of the affine transformation
+ * @y0: Y translation component of the affine transformation
+ *
+ * A #cairo_matrix_t holds an affine transformation, such as a scale,
+ * rotation, shear, or a combination of those. The transformation of
+ * a point (x, y) is given by:
+ * <programlisting>
+ *     x_new = xx * x + xy * y + x0;
+ *     y_new = yx * x + yy * y + y0;
+ * </programlisting>
+ **/
+typedef struct _cairo_matrix {
+    double xx; double yx;
+    double xy; double yy;
+    double x0; double y0;
+} cairo_matrix_t;
+
+/**
+ * cairo_pattern_t:
+ *
+ * A #cairo_pattern_t represents a source when drawing onto a
+ * surface. There are different subtypes of #cairo_pattern_t,
+ * for different types of sources; for example,
+ * cairo_pattern_create_rgb() creates a pattern for a solid
+ * opaque color.
+ *
+ * Other than various cairo_pattern_create_<emphasis>type</emphasis>()
+ * functions, some of the pattern types can be implicitly created
+ * using various cairo_set_source_<emphasis>type</emphasis>() functions;
+ * for example cairo_set_source_rgb().
+ *
+ * The type of a pattern can be queried with cairo_pattern_get_type().
+ *
+ * Memory management of #cairo_pattern_t is done with
+ * cairo_pattern_reference() and cairo_pattern_destroy().
+ **/
+typedef struct _cairo_pattern cairo_pattern_t;
+
+/**
+ * cairo_destroy_func_t:
+ * @data: The data element being destroyed.
+ *
+ * #cairo_destroy_func_t the type of function which is called when a
+ * data element is destroyed. It is passed the pointer to the data
+ * element and should free any memory and resources allocated for it.
+ **/
+typedef void (*cairo_destroy_func_t) (void *data);
+
+/**
+ * cairo_user_data_key_t:
+ * @unused: not used; ignore.
+ *
+ * #cairo_user_data_key_t is used for attaching user data to cairo
+ * data structures.  The actual contents of the struct is never used,
+ * and there is no need to initialize the object; only the unique
+ * address of a #cairo_data_key_t object is used.  Typically, you
+ * would just use the address of a static #cairo_data_key_t object.
+ **/
+typedef struct _cairo_user_data_key {
+    int unused;
+} cairo_user_data_key_t;
+
+/**
+ * cairo_status_t:
+ * @CAIRO_STATUS_SUCCESS: no error has occurred
+ * @CAIRO_STATUS_NO_MEMORY: out of memory
+ * @CAIRO_STATUS_INVALID_RESTORE: cairo_restore() called without matching cairo_save()
+ * @CAIRO_STATUS_INVALID_POP_GROUP: no saved group to pop, i.e. cairo_pop_group() without matching cairo_push_group()
+ * @CAIRO_STATUS_NO_CURRENT_POINT: no current point defined
+ * @CAIRO_STATUS_INVALID_MATRIX: invalid matrix (not invertible)
+ * @CAIRO_STATUS_INVALID_STATUS: invalid value for an input #cairo_status_t
+ * @CAIRO_STATUS_NULL_POINTER: %NULL pointer
+ * @CAIRO_STATUS_INVALID_STRING: input string not valid UTF-8
+ * @CAIRO_STATUS_INVALID_PATH_DATA: input path data not valid
+ * @CAIRO_STATUS_READ_ERROR: error while reading from input stream
+ * @CAIRO_STATUS_WRITE_ERROR: error while writing to output stream
+ * @CAIRO_STATUS_SURFACE_FINISHED: target surface has been finished
+ * @CAIRO_STATUS_SURFACE_TYPE_MISMATCH: the surface type is not appropriate for the operation
+ * @CAIRO_STATUS_PATTERN_TYPE_MISMATCH: the pattern type is not appropriate for the operation
+ * @CAIRO_STATUS_INVALID_CONTENT: invalid value for an input #cairo_content_t
+ * @CAIRO_STATUS_INVALID_FORMAT: invalid value for an input #cairo_format_t
+ * @CAIRO_STATUS_INVALID_VISUAL: invalid value for an input Visual*
+ * @CAIRO_STATUS_FILE_NOT_FOUND: file not found
+ * @CAIRO_STATUS_INVALID_DASH: invalid value for a dash setting
+ * @CAIRO_STATUS_INVALID_DSC_COMMENT: invalid value for a DSC comment (Since 1.2)
+ * @CAIRO_STATUS_INVALID_INDEX: invalid index passed to getter (Since 1.4)
+ * @CAIRO_STATUS_CLIP_NOT_REPRESENTABLE: clip region not representable in desired format (Since 1.4)
+ * @CAIRO_STATUS_TEMP_FILE_ERROR: error creating or writing to a temporary file (Since 1.6)
+ * @CAIRO_STATUS_INVALID_STRIDE: invalid value for stride (Since 1.6)
+ * @CAIRO_STATUS_FONT_TYPE_MISMATCH: the font type is not appropriate for the operation (Since 1.8)
+ * @CAIRO_STATUS_USER_FONT_IMMUTABLE: the user-font is immutable (Since 1.8)
+ * @CAIRO_STATUS_USER_FONT_ERROR: error occurred in a user-font callback function (Since 1.8)
+ * @CAIRO_STATUS_NEGATIVE_COUNT: negative number used where it is not allowed (Since 1.8)
+ * @CAIRO_STATUS_INVALID_CLUSTERS: input clusters do not represent the accompanying text and glyph array (Since 1.8)
+ * @CAIRO_STATUS_INVALID_SLANT: invalid value for an input #cairo_font_slant_t (Since 1.8)
+ * @CAIRO_STATUS_INVALID_WEIGHT: invalid value for an input #cairo_font_weight_t (Since 1.8)
+ * @CAIRO_STATUS_INVALID_SIZE: invalid value (typically too big) for the size of the input (surface, pattern, etc.) (Since 1.10)
+ * @CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED: user-font method not implemented (Since 1.10)
+ * @CAIRO_STATUS_LAST_STATUS: this is a special value indicating the number of
+ *   status values defined in this enumeration.  When using this value, note
+ *   that the version of cairo at run-time may have additional status values
+ *   defined than the value of this symbol at compile-time. (Since 1.10)
+ *
+ * #cairo_status_t is used to indicate errors that can occur when
+ * using Cairo. In some cases it is returned directly by functions.
+ * but when using #cairo_t, the last error, if any, is stored in
+ * the context and can be retrieved with cairo_status().
+ *
+ * New entries may be added in future versions.  Use cairo_status_to_string()
+ * to get a human-readable representation of an error message.
+ **/
+typedef enum _cairo_status {
+    CAIRO_STATUS_SUCCESS = 0,
+
+    CAIRO_STATUS_NO_MEMORY,
+    CAIRO_STATUS_INVALID_RESTORE,
+    CAIRO_STATUS_INVALID_POP_GROUP,
+    CAIRO_STATUS_NO_CURRENT_POINT,
+    CAIRO_STATUS_INVALID_MATRIX,
+    CAIRO_STATUS_INVALID_STATUS,
+    CAIRO_STATUS_NULL_POINTER,
+    CAIRO_STATUS_INVALID_STRING,
+    CAIRO_STATUS_INVALID_PATH_DATA,
+    CAIRO_STATUS_READ_ERROR,
+    CAIRO_STATUS_WRITE_ERROR,
+    CAIRO_STATUS_SURFACE_FINISHED,
+    CAIRO_STATUS_SURFACE_TYPE_MISMATCH,
+    CAIRO_STATUS_PATTERN_TYPE_MISMATCH,
+    CAIRO_STATUS_INVALID_CONTENT,
+    CAIRO_STATUS_INVALID_FORMAT,
+    CAIRO_STATUS_INVALID_VISUAL,
+    CAIRO_STATUS_FILE_NOT_FOUND,
+    CAIRO_STATUS_INVALID_DASH,
+    CAIRO_STATUS_INVALID_DSC_COMMENT,
+    CAIRO_STATUS_INVALID_INDEX,
+    CAIRO_STATUS_CLIP_NOT_REPRESENTABLE,
+    CAIRO_STATUS_TEMP_FILE_ERROR,
+    CAIRO_STATUS_INVALID_STRIDE,
+    CAIRO_STATUS_FONT_TYPE_MISMATCH,
+    CAIRO_STATUS_USER_FONT_IMMUTABLE,
+    CAIRO_STATUS_USER_FONT_ERROR,
+    CAIRO_STATUS_NEGATIVE_COUNT,
+    CAIRO_STATUS_INVALID_CLUSTERS,
+    CAIRO_STATUS_INVALID_SLANT,
+    CAIRO_STATUS_INVALID_WEIGHT,
+    CAIRO_STATUS_INVALID_SIZE,
+    CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED,
+
+    CAIRO_STATUS_LAST_STATUS
+} cairo_status_t;
+
+/**
+ * cairo_content_t:
+ * @CAIRO_CONTENT_COLOR: The surface will hold color content only.
+ * @CAIRO_CONTENT_ALPHA: The surface will hold alpha content only.
+ * @CAIRO_CONTENT_COLOR_ALPHA: The surface will hold color and alpha content.
+ *
+ * #cairo_content_t is used to describe the content that a surface will
+ * contain, whether color information, alpha information (translucence
+ * vs. opacity), or both.
+ *
+ * Note: The large values here are designed to keep #cairo_content_t
+ * values distinct from #cairo_format_t values so that the
+ * implementation can detect the error if users confuse the two types.
+ **/
+typedef enum _cairo_content {
+    CAIRO_CONTENT_COLOR		= 0x1000,
+    CAIRO_CONTENT_ALPHA		= 0x2000,
+    CAIRO_CONTENT_COLOR_ALPHA	= 0x3000
+} cairo_content_t;
+
+/**
+ * cairo_write_func_t:
+ * @closure: the output closure
+ * @data: the buffer containing the data to write
+ * @length: the amount of data to write
+ *
+ * #cairo_write_func_t is the type of function which is called when a
+ * backend needs to write data to an output stream.  It is passed the
+ * closure which was specified by the user at the time the write
+ * function was registered, the data to write and the length of the
+ * data in bytes.  The write function should return
+ * %CAIRO_STATUS_SUCCESS if all the data was successfully written,
+ * %CAIRO_STATUS_WRITE_ERROR otherwise.
+ *
+ * Returns: the status code of the write operation
+ **/
+typedef cairo_status_t (*cairo_write_func_t) (void		  *closure,
+					      const unsigned char *data,
+					      unsigned int	   length);
+
+/**
+ * cairo_read_func_t:
+ * @closure: the input closure
+ * @data: the buffer into which to read the data
+ * @length: the amount of data to read
+ *
+ * #cairo_read_func_t is the type of function which is called when a
+ * backend needs to read data from an input stream.  It is passed the
+ * closure which was specified by the user at the time the read
+ * function was registered, the buffer to read the data into and the
+ * length of the data in bytes.  The read function should return
+ * %CAIRO_STATUS_SUCCESS if all the data was successfully read,
+ * %CAIRO_STATUS_READ_ERROR otherwise.
+ *
+ * Returns: the status code of the read operation
+ **/
+typedef cairo_status_t (*cairo_read_func_t) (void		*closure,
+					     unsigned char	*data,
+					     unsigned int	length);
+
+/* Functions for manipulating state objects */
+cairo_public cairo_t *
+cairo_create (cairo_surface_t *target);
+
+cairo_public cairo_t *
+cairo_reference (cairo_t *cr);
+
+cairo_public void
+cairo_destroy (cairo_t *cr);
+
+cairo_public unsigned int
+cairo_get_reference_count (cairo_t *cr);
+
+cairo_public void *
+cairo_get_user_data (cairo_t			 *cr,
+		     const cairo_user_data_key_t *key);
+
+cairo_public cairo_status_t
+cairo_set_user_data (cairo_t			 *cr,
+		     const cairo_user_data_key_t *key,
+		     void			 *user_data,
+		     cairo_destroy_func_t	  destroy);
+
+cairo_public void
+cairo_save (cairo_t *cr);
+
+cairo_public void
+cairo_restore (cairo_t *cr);
+
+cairo_public void
+cairo_push_group (cairo_t *cr);
+
+cairo_public void
+cairo_push_group_with_content (cairo_t *cr, cairo_content_t content);
+
+cairo_public cairo_pattern_t *
+cairo_pop_group (cairo_t *cr);
+
+cairo_public void
+cairo_pop_group_to_source (cairo_t *cr);
+
+/* Modify state */
+
+/**
+ * cairo_operator_t:
+ * @CAIRO_OPERATOR_CLEAR: clear destination layer (bounded)
+ * @CAIRO_OPERATOR_SOURCE: replace destination layer (bounded)
+ * @CAIRO_OPERATOR_OVER: draw source layer on top of destination layer
+ * (bounded)
+ * @CAIRO_OPERATOR_IN: draw source where there was destination content
+ * (unbounded)
+ * @CAIRO_OPERATOR_OUT: draw source where there was no destination
+ * content (unbounded)
+ * @CAIRO_OPERATOR_ATOP: draw source on top of destination content and
+ * only there
+ * @CAIRO_OPERATOR_DEST: ignore the source
+ * @CAIRO_OPERATOR_DEST_OVER: draw destination on top of source
+ * @CAIRO_OPERATOR_DEST_IN: leave destination only where there was
+ * source content (unbounded)
+ * @CAIRO_OPERATOR_DEST_OUT: leave destination only where there was no
+ * source content
+ * @CAIRO_OPERATOR_DEST_ATOP: leave destination on top of source content
+ * and only there (unbounded)
+ * @CAIRO_OPERATOR_XOR: source and destination are shown where there is only
+ * one of them
+ * @CAIRO_OPERATOR_ADD: source and destination layers are accumulated
+ * @CAIRO_OPERATOR_SATURATE: like over, but assuming source and dest are
+ * disjoint geometries
+ * @CAIRO_OPERATOR_MULTIPLY: source and destination layers are multiplied.
+ * This causes the result to be at least as dark as the darker inputs.
+ * @CAIRO_OPERATOR_SCREEN: source and destination are complemented and
+ * multiplied. This causes the result to be at least as light as the lighter
+ * inputs.
+ * @CAIRO_OPERATOR_OVERLAY: multiplies or screens, depending on the
+ * lightness of the destination color.
+ * @CAIRO_OPERATOR_DARKEN: replaces the destination with the source if it
+ * is darker, otherwise keeps the source.
+ * @CAIRO_OPERATOR_LIGHTEN: replaces the destination with the source if it
+ * is lighter, otherwise keeps the source.
+ * @CAIRO_OPERATOR_COLOR_DODGE: brightens the destination color to reflect
+ * the source color.
+ * @CAIRO_OPERATOR_COLOR_BURN: darkens the destination color to reflect
+ * the source color.
+ * @CAIRO_OPERATOR_HARD_LIGHT: Multiplies or screens, dependant on source
+ * color.
+ * @CAIRO_OPERATOR_SOFT_LIGHT: Darkens or lightens, dependant on source
+ * color.
+ * @CAIRO_OPERATOR_DIFFERENCE: Takes the difference of the source and
+ * destination color.
+ * @CAIRO_OPERATOR_EXCLUSION: Produces an effect similar to difference, but
+ * with lower contrast.
+ * @CAIRO_OPERATOR_HSL_HUE: Creates a color with the hue of the source
+ * and the saturation and luminosity of the target.
+ * @CAIRO_OPERATOR_HSL_SATURATION: Creates a color with the saturation
+ * of the source and the hue and luminosity of the target. Painting with
+ * this mode onto a gray area prduces no change.
+ * @CAIRO_OPERATOR_HSL_COLOR: Creates a color with the hue and saturation
+ * of the source and the luminosity of the target. This preserves the gray
+ * levels of the target and is useful for coloring monochrome images or
+ * tinting color images.
+ * @CAIRO_OPERATOR_HSL_LUMINOSITY: Creates a color with the luminosity of
+ * the source and the hue and saturation of the target. This produces an
+ * inverse effect to @CAIRO_OPERATOR_HSL_COLOR.
+ *
+ * #cairo_operator_t is used to set the compositing operator for all cairo
+ * drawing operations.
+ *
+ * The default operator is %CAIRO_OPERATOR_OVER.
+ *
+ * The operators marked as <firstterm>unbounded</firstterm> modify their
+ * destination even outside of the mask layer (that is, their effect is not
+ * bound by the mask layer).  However, their effect can still be limited by
+ * way of clipping.
+ *
+ * To keep things simple, the operator descriptions here
+ * document the behavior for when both source and destination are either fully
+ * transparent or fully opaque.  The actual implementation works for
+ * translucent layers too.
+ * For a more detailed explanation of the effects of each operator, including
+ * the mathematical definitions, see
+ * <ulink url="http://cairographics.org/operators/">http://cairographics.org/operators/</ulink>.
+ **/
+typedef enum _cairo_operator {
+    CAIRO_OPERATOR_CLEAR,
+
+    CAIRO_OPERATOR_SOURCE,
+    CAIRO_OPERATOR_OVER,
+    CAIRO_OPERATOR_IN,
+    CAIRO_OPERATOR_OUT,
+    CAIRO_OPERATOR_ATOP,
+
+    CAIRO_OPERATOR_DEST,
+    CAIRO_OPERATOR_DEST_OVER,
+    CAIRO_OPERATOR_DEST_IN,
+    CAIRO_OPERATOR_DEST_OUT,
+    CAIRO_OPERATOR_DEST_ATOP,
+
+    CAIRO_OPERATOR_XOR,
+    CAIRO_OPERATOR_ADD,
+    CAIRO_OPERATOR_SATURATE,
+
+    CAIRO_OPERATOR_MULTIPLY,
+    CAIRO_OPERATOR_SCREEN,
+    CAIRO_OPERATOR_OVERLAY,
+    CAIRO_OPERATOR_DARKEN,
+    CAIRO_OPERATOR_LIGHTEN,
+    CAIRO_OPERATOR_COLOR_DODGE,
+    CAIRO_OPERATOR_COLOR_BURN,
+    CAIRO_OPERATOR_HARD_LIGHT,
+    CAIRO_OPERATOR_SOFT_LIGHT,
+    CAIRO_OPERATOR_DIFFERENCE,
+    CAIRO_OPERATOR_EXCLUSION,
+    CAIRO_OPERATOR_HSL_HUE,
+    CAIRO_OPERATOR_HSL_SATURATION,
+    CAIRO_OPERATOR_HSL_COLOR,
+    CAIRO_OPERATOR_HSL_LUMINOSITY
+} cairo_operator_t;
+
+cairo_public void
+cairo_set_operator (cairo_t *cr, cairo_operator_t op);
+
+cairo_public void
+cairo_set_source (cairo_t *cr, cairo_pattern_t *source);
+
+cairo_public void
+cairo_set_source_rgb (cairo_t *cr, double red, double green, double blue);
+
+cairo_public void
+cairo_set_source_rgba (cairo_t *cr,
+		       double red, double green, double blue,
+		       double alpha);
+
+cairo_public void
+cairo_set_source_surface (cairo_t	  *cr,
+			  cairo_surface_t *surface,
+			  double	   x,
+			  double	   y);
+
+cairo_public void
+cairo_set_tolerance (cairo_t *cr, double tolerance);
+
+/**
+ * cairo_antialias_t:
+ * @CAIRO_ANTIALIAS_DEFAULT: Use the default antialiasing for
+ *   the subsystem and target device
+ * @CAIRO_ANTIALIAS_NONE: Use a bilevel alpha mask
+ * @CAIRO_ANTIALIAS_GRAY: Perform single-color antialiasing (using
+ *  shades of gray for black text on a white background, for example).
+ * @CAIRO_ANTIALIAS_SUBPIXEL: Perform antialiasing by taking
+ *  advantage of the order of subpixel elements on devices
+ *  such as LCD panels
+ *
+ * Specifies the type of antialiasing to do when rendering text or shapes.
+ **/
+typedef enum _cairo_antialias {
+    CAIRO_ANTIALIAS_DEFAULT,
+    CAIRO_ANTIALIAS_NONE,
+    CAIRO_ANTIALIAS_GRAY,
+    CAIRO_ANTIALIAS_SUBPIXEL
+} cairo_antialias_t;
+
+cairo_public void
+cairo_set_antialias (cairo_t *cr, cairo_antialias_t antialias);
+
+/**
+ * cairo_fill_rule_t:
+ * @CAIRO_FILL_RULE_WINDING: If the path crosses the ray from
+ * left-to-right, counts +1. If the path crosses the ray
+ * from right to left, counts -1. (Left and right are determined
+ * from the perspective of looking along the ray from the starting
+ * point.) If the total count is non-zero, the point will be filled.
+ * @CAIRO_FILL_RULE_EVEN_ODD: Counts the total number of
+ * intersections, without regard to the orientation of the contour. If
+ * the total number of intersections is odd, the point will be
+ * filled.
+ *
+ * #cairo_fill_rule_t is used to select how paths are filled. For both
+ * fill rules, whether or not a point is included in the fill is
+ * determined by taking a ray from that point to infinity and looking
+ * at intersections with the path. The ray can be in any direction,
+ * as long as it doesn't pass through the end point of a segment
+ * or have a tricky intersection such as intersecting tangent to the path.
+ * (Note that filling is not actually implemented in this way. This
+ * is just a description of the rule that is applied.)
+ *
+ * The default fill rule is %CAIRO_FILL_RULE_WINDING.
+ *
+ * New entries may be added in future versions.
+ **/
+typedef enum _cairo_fill_rule {
+    CAIRO_FILL_RULE_WINDING,
+    CAIRO_FILL_RULE_EVEN_ODD
+} cairo_fill_rule_t;
+
+cairo_public void
+cairo_set_fill_rule (cairo_t *cr, cairo_fill_rule_t fill_rule);
+
+cairo_public void
+cairo_set_line_width (cairo_t *cr, double width);
+
+/**
+ * cairo_line_cap_t:
+ * @CAIRO_LINE_CAP_BUTT: start(stop) the line exactly at the start(end) point
+ * @CAIRO_LINE_CAP_ROUND: use a round ending, the center of the circle is the end point
+ * @CAIRO_LINE_CAP_SQUARE: use squared ending, the center of the square is the end point
+ *
+ * Specifies how to render the endpoints of the path when stroking.
+ *
+ * The default line cap style is %CAIRO_LINE_CAP_BUTT.
+ **/
+typedef enum _cairo_line_cap {
+    CAIRO_LINE_CAP_BUTT,
+    CAIRO_LINE_CAP_ROUND,
+    CAIRO_LINE_CAP_SQUARE
+} cairo_line_cap_t;
+
+cairo_public void
+cairo_set_line_cap (cairo_t *cr, cairo_line_cap_t line_cap);
+
+/**
+ * cairo_line_join_t:
+ * @CAIRO_LINE_JOIN_MITER: use a sharp (angled) corner, see
+ * cairo_set_miter_limit()
+ * @CAIRO_LINE_JOIN_ROUND: use a rounded join, the center of the circle is the
+ * joint point
+ * @CAIRO_LINE_JOIN_BEVEL: use a cut-off join, the join is cut off at half
+ * the line width from the joint point
+ *
+ * Specifies how to render the junction of two lines when stroking.
+ *
+ * The default line join style is %CAIRO_LINE_JOIN_MITER.
+ **/
+typedef enum _cairo_line_join {
+    CAIRO_LINE_JOIN_MITER,
+    CAIRO_LINE_JOIN_ROUND,
+    CAIRO_LINE_JOIN_BEVEL
+} cairo_line_join_t;
+
+cairo_public void
+cairo_set_line_join (cairo_t *cr, cairo_line_join_t line_join);
+
+cairo_public void
+cairo_set_dash (cairo_t      *cr,
+		const double *dashes,
+		int	      num_dashes,
+		double	      offset);
+
+cairo_public void
+cairo_set_miter_limit (cairo_t *cr, double limit);
+
+cairo_public void
+cairo_translate (cairo_t *cr, double tx, double ty);
+
+cairo_public void
+cairo_scale (cairo_t *cr, double sx, double sy);
+
+cairo_public void
+cairo_rotate (cairo_t *cr, double angle);
+
+cairo_public void
+cairo_transform (cairo_t	      *cr,
+		 const cairo_matrix_t *matrix);
+
+cairo_public void
+cairo_set_matrix (cairo_t	       *cr,
+		  const cairo_matrix_t *matrix);
+
+cairo_public void
+cairo_identity_matrix (cairo_t *cr);
+
+cairo_public void
+cairo_user_to_device (cairo_t *cr, double *x, double *y);
+
+cairo_public void
+cairo_user_to_device_distance (cairo_t *cr, double *dx, double *dy);
+
+cairo_public void
+cairo_device_to_user (cairo_t *cr, double *x, double *y);
+
+cairo_public void
+cairo_device_to_user_distance (cairo_t *cr, double *dx, double *dy);
+
+/* Path creation functions */
+cairo_public void
+cairo_new_path (cairo_t *cr);
+
+cairo_public void
+cairo_move_to (cairo_t *cr, double x, double y);
+
+cairo_public void
+cairo_new_sub_path (cairo_t *cr);
+
+cairo_public void
+cairo_line_to (cairo_t *cr, double x, double y);
+
+cairo_public void
+cairo_curve_to (cairo_t *cr,
+		double x1, double y1,
+		double x2, double y2,
+		double x3, double y3);
+
+cairo_public void
+cairo_arc (cairo_t *cr,
+	   double xc, double yc,
+	   double radius,
+	   double angle1, double angle2);
+
+cairo_public void
+cairo_arc_negative (cairo_t *cr,
+		    double xc, double yc,
+		    double radius,
+		    double angle1, double angle2);
+
+/* XXX: NYI
+cairo_public void
+cairo_arc_to (cairo_t *cr,
+	      double x1, double y1,
+	      double x2, double y2,
+	      double radius);
+*/
+
+cairo_public void
+cairo_rel_move_to (cairo_t *cr, double dx, double dy);
+
+cairo_public void
+cairo_rel_line_to (cairo_t *cr, double dx, double dy);
+
+cairo_public void
+cairo_rel_curve_to (cairo_t *cr,
+		    double dx1, double dy1,
+		    double dx2, double dy2,
+		    double dx3, double dy3);
+
+cairo_public void
+cairo_rectangle (cairo_t *cr,
+		 double x, double y,
+		 double width, double height);
+
+/* XXX: NYI
+cairo_public void
+cairo_stroke_to_path (cairo_t *cr);
+*/
+
+cairo_public void
+cairo_close_path (cairo_t *cr);
+
+cairo_public void
+cairo_path_extents (cairo_t *cr,
+		    double *x1, double *y1,
+		    double *x2, double *y2);
+
+/* Painting functions */
+cairo_public void
+cairo_paint (cairo_t *cr);
+
+cairo_public void
+cairo_paint_with_alpha (cairo_t *cr,
+			double   alpha);
+
+cairo_public void
+cairo_mask (cairo_t         *cr,
+	    cairo_pattern_t *pattern);
+
+cairo_public void
+cairo_mask_surface (cairo_t         *cr,
+		    cairo_surface_t *surface,
+		    double           surface_x,
+		    double           surface_y);
+
+cairo_public void
+cairo_stroke (cairo_t *cr);
+
+cairo_public void
+cairo_stroke_preserve (cairo_t *cr);
+
+cairo_public void
+cairo_fill (cairo_t *cr);
+
+cairo_public void
+cairo_fill_preserve (cairo_t *cr);
+
+cairo_public void
+cairo_copy_page (cairo_t *cr);
+
+cairo_public void
+cairo_show_page (cairo_t *cr);
+
+/* Insideness testing */
+cairo_public cairo_bool_t
+cairo_in_stroke (cairo_t *cr, double x, double y);
+
+cairo_public cairo_bool_t
+cairo_in_fill (cairo_t *cr, double x, double y);
+
+cairo_public cairo_bool_t
+cairo_in_clip (cairo_t *cr, double x, double y);
+
+/* Rectangular extents */
+cairo_public void
+cairo_stroke_extents (cairo_t *cr,
+		      double *x1, double *y1,
+		      double *x2, double *y2);
+
+cairo_public void
+cairo_fill_extents (cairo_t *cr,
+		    double *x1, double *y1,
+		    double *x2, double *y2);
+
+/* Clipping */
+cairo_public void
+cairo_reset_clip (cairo_t *cr);
+
+cairo_public void
+cairo_clip (cairo_t *cr);
+
+cairo_public void
+cairo_clip_preserve (cairo_t *cr);
+
+cairo_public void
+cairo_clip_extents (cairo_t *cr,
+		    double *x1, double *y1,
+		    double *x2, double *y2);
+
+/**
+ * cairo_rectangle_t:
+ * @x: X coordinate of the left side of the rectangle
+ * @y: Y coordinate of the the top side of the rectangle
+ * @width: width of the rectangle
+ * @height: height of the rectangle
+ *
+ * A data structure for holding a rectangle.
+ *
+ * Since: 1.4
+ **/
+typedef struct _cairo_rectangle {
+    double x, y, width, height;
+} cairo_rectangle_t;
+
+/**
+ * cairo_rectangle_list_t:
+ * @status: Error status of the rectangle list
+ * @rectangles: Array containing the rectangles
+ * @num_rectangles: Number of rectangles in this list
+ * 
+ * A data structure for holding a dynamically allocated
+ * array of rectangles.
+ *
+ * Since: 1.4
+ **/
+typedef struct _cairo_rectangle_list {
+    cairo_status_t     status;
+    cairo_rectangle_t *rectangles;
+    int                num_rectangles;
+} cairo_rectangle_list_t;
+
+cairo_public cairo_rectangle_list_t *
+cairo_copy_clip_rectangle_list (cairo_t *cr);
+
+cairo_public void
+cairo_rectangle_list_destroy (cairo_rectangle_list_t *rectangle_list);
+
+/* Font/Text functions */
+
+/**
+ * cairo_scaled_font_t:
+ *
+ * A #cairo_scaled_font_t is a font scaled to a particular size and device
+ * resolution. A #cairo_scaled_font_t is most useful for low-level font
+ * usage where a library or application wants to cache a reference
+ * to a scaled font to speed up the computation of metrics.
+ *
+ * There are various types of scaled fonts, depending on the
+ * <firstterm>font backend</firstterm> they use. The type of a
+ * scaled font can be queried using cairo_scaled_font_get_type().
+ *
+ * Memory management of #cairo_scaled_font_t is done with
+ * cairo_scaled_font_reference() and cairo_scaled_font_destroy().
+ **/
+typedef struct _cairo_scaled_font cairo_scaled_font_t;
+
+/**
+ * cairo_font_face_t:
+ *
+ * A #cairo_font_face_t specifies all aspects of a font other
+ * than the size or font matrix (a font matrix is used to distort
+ * a font by sheering it or scaling it unequally in the two
+ * directions) . A font face can be set on a #cairo_t by using
+ * cairo_set_font_face(); the size and font matrix are set with
+ * cairo_set_font_size() and cairo_set_font_matrix().
+ *
+ * There are various types of font faces, depending on the
+ * <firstterm>font backend</firstterm> they use. The type of a
+ * font face can be queried using cairo_font_face_get_type().
+ *
+ * Memory management of #cairo_font_face_t is done with
+ * cairo_font_face_reference() and cairo_font_face_destroy().
+ **/
+typedef struct _cairo_font_face cairo_font_face_t;
+
+/**
+ * cairo_glyph_t:
+ * @index: glyph index in the font. The exact interpretation of the
+ *      glyph index depends on the font technology being used.
+ * @x: the offset in the X direction between the origin used for
+ *     drawing or measuring the string and the origin of this glyph.
+ * @y: the offset in the Y direction between the origin used for
+ *     drawing or measuring the string and the origin of this glyph.
+ *
+ * The #cairo_glyph_t structure holds information about a single glyph
+ * when drawing or measuring text. A font is (in simple terms) a
+ * collection of shapes used to draw text. A glyph is one of these
+ * shapes. There can be multiple glyphs for a single character
+ * (alternates to be used in different contexts, for example), or a
+ * glyph can be a <firstterm>ligature</firstterm> of multiple
+ * characters. Cairo doesn't expose any way of converting input text
+ * into glyphs, so in order to use the Cairo interfaces that take
+ * arrays of glyphs, you must directly access the appropriate
+ * underlying font system.
+ *
+ * Note that the offsets given by @x and @y are not cumulative. When
+ * drawing or measuring text, each glyph is individually positioned
+ * with respect to the overall origin
+ **/
+typedef struct {
+    unsigned long        index;
+    double               x;
+    double               y;
+} cairo_glyph_t;
+
+cairo_public cairo_glyph_t *
+cairo_glyph_allocate (int num_glyphs);
+
+cairo_public void
+cairo_glyph_free (cairo_glyph_t *glyphs);
+
+/**
+ * cairo_text_cluster_t:
+ * @num_bytes: the number of bytes of UTF-8 text covered by cluster
+ * @num_glyphs: the number of glyphs covered by cluster
+ *
+ * The #cairo_text_cluster_t structure holds information about a single
+ * <firstterm>text cluster</firstterm>.  A text cluster is a minimal
+ * mapping of some glyphs corresponding to some UTF-8 text.
+ *
+ * For a cluster to be valid, both @num_bytes and @num_glyphs should
+ * be non-negative, and at least one should be non-zero.
+ * Note that clusters with zero glyphs are not as well supported as
+ * normal clusters.  For example, PDF rendering applications typically
+ * ignore those clusters when PDF text is being selected.
+ *
+ * See cairo_show_text_glyphs() for how clusters are used in advanced
+ * text operations.
+ *
+ * Since: 1.8
+ **/
+typedef struct {
+    int        num_bytes;
+    int        num_glyphs;
+} cairo_text_cluster_t;
+
+cairo_public cairo_text_cluster_t *
+cairo_text_cluster_allocate (int num_clusters);
+
+cairo_public void
+cairo_text_cluster_free (cairo_text_cluster_t *clusters);
+
+/**
+ * cairo_text_cluster_flags_t:
+ * @CAIRO_TEXT_CLUSTER_FLAG_BACKWARD: The clusters in the cluster array
+ * map to glyphs in the glyph array from end to start.
+ *
+ * Specifies properties of a text cluster mapping.
+ *
+ * Since: 1.8
+ **/
+typedef enum _cairo_text_cluster_flags {
+    CAIRO_TEXT_CLUSTER_FLAG_BACKWARD = 0x00000001
+} cairo_text_cluster_flags_t;
+
+/**
+ * cairo_text_extents_t:
+ * @x_bearing: the horizontal distance from the origin to the
+ *   leftmost part of the glyphs as drawn. Positive if the
+ *   glyphs lie entirely to the right of the origin.
+ * @y_bearing: the vertical distance from the origin to the
+ *   topmost part of the glyphs as drawn. Positive only if the
+ *   glyphs lie completely below the origin; will usually be
+ *   negative.
+ * @width: width of the glyphs as drawn
+ * @height: height of the glyphs as drawn
+ * @x_advance:distance to advance in the X direction
+ *    after drawing these glyphs
+ * @y_advance: distance to advance in the Y direction
+ *   after drawing these glyphs. Will typically be zero except
+ *   for vertical text layout as found in East-Asian languages.
+ *
+ * The #cairo_text_extents_t structure stores the extents of a single
+ * glyph or a string of glyphs in user-space coordinates. Because text
+ * extents are in user-space coordinates, they are mostly, but not
+ * entirely, independent of the current transformation matrix. If you call
+ * <literal>cairo_scale(cr, 2.0, 2.0)</literal>, text will
+ * be drawn twice as big, but the reported text extents will not be
+ * doubled. They will change slightly due to hinting (so you can't
+ * assume that metrics are independent of the transformation matrix),
+ * but otherwise will remain unchanged.
+ **/
+typedef struct {
+    double x_bearing;
+    double y_bearing;
+    double width;
+    double height;
+    double x_advance;
+    double y_advance;
+} cairo_text_extents_t;
+
+/**
+ * cairo_font_extents_t:
+ * @ascent: the distance that the font extends above the baseline.
+ *          Note that this is not always exactly equal to the maximum
+ *          of the extents of all the glyphs in the font, but rather
+ *          is picked to express the font designer's intent as to
+ *          how the font should align with elements above it.
+ * @descent: the distance that the font extends below the baseline.
+ *           This value is positive for typical fonts that include
+ *           portions below the baseline. Note that this is not always
+ *           exactly equal to the maximum of the extents of all the
+ *           glyphs in the font, but rather is picked to express the
+ *           font designer's intent as to how the the font should
+ *           align with elements below it.
+ * @height: the recommended vertical distance between baselines when
+ *          setting consecutive lines of text with the font. This
+ *          is greater than @ascent+@descent by a
+ *          quantity known as the <firstterm>line spacing</firstterm>
+ *          or <firstterm>external leading</firstterm>. When space
+ *          is at a premium, most fonts can be set with only
+ *          a distance of @ascent+@descent between lines.
+ * @max_x_advance: the maximum distance in the X direction that
+ *         the the origin is advanced for any glyph in the font.
+ * @max_y_advance: the maximum distance in the Y direction that
+ *         the the origin is advanced for any glyph in the font.
+ *         this will be zero for normal fonts used for horizontal
+ *         writing. (The scripts of East Asia are sometimes written
+ *         vertically.)
+ *
+ * The #cairo_font_extents_t structure stores metric information for
+ * a font. Values are given in the current user-space coordinate
+ * system.
+ *
+ * Because font metrics are in user-space coordinates, they are
+ * mostly, but not entirely, independent of the current transformation
+ * matrix. If you call <literal>cairo_scale(cr, 2.0, 2.0)</literal>,
+ * text will be drawn twice as big, but the reported text extents will
+ * not be doubled. They will change slightly due to hinting (so you
+ * can't assume that metrics are independent of the transformation
+ * matrix), but otherwise will remain unchanged.
+ **/
+typedef struct {
+    double ascent;
+    double descent;
+    double height;
+    double max_x_advance;
+    double max_y_advance;
+} cairo_font_extents_t;
+
+/**
+ * cairo_font_slant_t:
+ * @CAIRO_FONT_SLANT_NORMAL: Upright font style
+ * @CAIRO_FONT_SLANT_ITALIC: Italic font style
+ * @CAIRO_FONT_SLANT_OBLIQUE: Oblique font style
+ *
+ * Specifies variants of a font face based on their slant.
+ **/
+typedef enum _cairo_font_slant {
+    CAIRO_FONT_SLANT_NORMAL,
+    CAIRO_FONT_SLANT_ITALIC,
+    CAIRO_FONT_SLANT_OBLIQUE
+} cairo_font_slant_t;
+
+/**
+ * cairo_font_weight_t:
+ * @CAIRO_FONT_WEIGHT_NORMAL: Normal font weight
+ * @CAIRO_FONT_WEIGHT_BOLD: Bold font weight
+ *
+ * Specifies variants of a font face based on their weight.
+ **/
+typedef enum _cairo_font_weight {
+    CAIRO_FONT_WEIGHT_NORMAL,
+    CAIRO_FONT_WEIGHT_BOLD
+} cairo_font_weight_t;
+
+/**
+ * cairo_subpixel_order_t:
+ * @CAIRO_SUBPIXEL_ORDER_DEFAULT: Use the default subpixel order for
+ *   for the target device
+ * @CAIRO_SUBPIXEL_ORDER_RGB: Subpixel elements are arranged horizontally
+ *   with red at the left
+ * @CAIRO_SUBPIXEL_ORDER_BGR:  Subpixel elements are arranged horizontally
+ *   with blue at the left
+ * @CAIRO_SUBPIXEL_ORDER_VRGB: Subpixel elements are arranged vertically
+ *   with red at the top
+ * @CAIRO_SUBPIXEL_ORDER_VBGR: Subpixel elements are arranged vertically
+ *   with blue at the top
+ *
+ * The subpixel order specifies the order of color elements within
+ * each pixel on the display device when rendering with an
+ * antialiasing mode of %CAIRO_ANTIALIAS_SUBPIXEL.
+ **/
+typedef enum _cairo_subpixel_order {
+    CAIRO_SUBPIXEL_ORDER_DEFAULT,
+    CAIRO_SUBPIXEL_ORDER_RGB,
+    CAIRO_SUBPIXEL_ORDER_BGR,
+    CAIRO_SUBPIXEL_ORDER_VRGB,
+    CAIRO_SUBPIXEL_ORDER_VBGR
+} cairo_subpixel_order_t;
+
+/**
+ * cairo_hint_style_t:
+ * @CAIRO_HINT_STYLE_DEFAULT: Use the default hint style for
+ *   font backend and target device
+ * @CAIRO_HINT_STYLE_NONE: Do not hint outlines
+ * @CAIRO_HINT_STYLE_SLIGHT: Hint outlines slightly to improve
+ *   contrast while retaining good fidelity to the original
+ *   shapes.
+ * @CAIRO_HINT_STYLE_MEDIUM: Hint outlines with medium strength
+ *   giving a compromise between fidelity to the original shapes
+ *   and contrast
+ * @CAIRO_HINT_STYLE_FULL: Hint outlines to maximize contrast
+ *
+ * Specifies the type of hinting to do on font outlines. Hinting
+ * is the process of fitting outlines to the pixel grid in order
+ * to improve the appearance of the result. Since hinting outlines
+ * involves distorting them, it also reduces the faithfulness
+ * to the original outline shapes. Not all of the outline hinting
+ * styles are supported by all font backends.
+ *
+ * New entries may be added in future versions.
+ **/
+typedef enum _cairo_hint_style {
+    CAIRO_HINT_STYLE_DEFAULT,
+    CAIRO_HINT_STYLE_NONE,
+    CAIRO_HINT_STYLE_SLIGHT,
+    CAIRO_HINT_STYLE_MEDIUM,
+    CAIRO_HINT_STYLE_FULL
+} cairo_hint_style_t;
+
+/**
+ * cairo_hint_metrics_t:
+ * @CAIRO_HINT_METRICS_DEFAULT: Hint metrics in the default
+ *  manner for the font backend and target device
+ * @CAIRO_HINT_METRICS_OFF: Do not hint font metrics
+ * @CAIRO_HINT_METRICS_ON: Hint font metrics
+ *
+ * Specifies whether to hint font metrics; hinting font metrics
+ * means quantizing them so that they are integer values in
+ * device space. Doing this improves the consistency of
+ * letter and line spacing, however it also means that text
+ * will be laid out differently at different zoom factors.
+ **/
+typedef enum _cairo_hint_metrics {
+    CAIRO_HINT_METRICS_DEFAULT,
+    CAIRO_HINT_METRICS_OFF,
+    CAIRO_HINT_METRICS_ON
+} cairo_hint_metrics_t;
+
+/**
+ * cairo_font_options_t:
+ *
+ * An opaque structure holding all options that are used when
+ * rendering fonts.
+ *
+ * Individual features of a #cairo_font_options_t can be set or
+ * accessed using functions named
+ * cairo_font_options_set_<emphasis>feature_name</emphasis> and
+ * cairo_font_options_get_<emphasis>feature_name</emphasis>, like
+ * cairo_font_options_set_antialias() and
+ * cairo_font_options_get_antialias().
+ *
+ * New features may be added to a #cairo_font_options_t in the
+ * future.  For this reason, cairo_font_options_copy(),
+ * cairo_font_options_equal(), cairo_font_options_merge(), and
+ * cairo_font_options_hash() should be used to copy, check
+ * for equality, merge, or compute a hash value of
+ * #cairo_font_options_t objects.
+ **/
+typedef struct _cairo_font_options cairo_font_options_t;
+
+cairo_public cairo_font_options_t *
+cairo_font_options_create (void);
+
+cairo_public cairo_font_options_t *
+cairo_font_options_copy (const cairo_font_options_t *original);
+
+cairo_public void
+cairo_font_options_destroy (cairo_font_options_t *options);
+
+cairo_public cairo_status_t
+cairo_font_options_status (cairo_font_options_t *options);
+
+cairo_public void
+cairo_font_options_merge (cairo_font_options_t       *options,
+			  const cairo_font_options_t *other);
+cairo_public cairo_bool_t
+cairo_font_options_equal (const cairo_font_options_t *options,
+			  const cairo_font_options_t *other);
+
+cairo_public unsigned long
+cairo_font_options_hash (const cairo_font_options_t *options);
+
+cairo_public void
+cairo_font_options_set_antialias (cairo_font_options_t *options,
+				  cairo_antialias_t     antialias);
+cairo_public cairo_antialias_t
+cairo_font_options_get_antialias (const cairo_font_options_t *options);
+
+cairo_public void
+cairo_font_options_set_subpixel_order (cairo_font_options_t   *options,
+				       cairo_subpixel_order_t  subpixel_order);
+cairo_public cairo_subpixel_order_t
+cairo_font_options_get_subpixel_order (const cairo_font_options_t *options);
+
+cairo_public void
+cairo_font_options_set_hint_style (cairo_font_options_t *options,
+				   cairo_hint_style_t     hint_style);
+cairo_public cairo_hint_style_t
+cairo_font_options_get_hint_style (const cairo_font_options_t *options);
+
+cairo_public void
+cairo_font_options_set_hint_metrics (cairo_font_options_t *options,
+				     cairo_hint_metrics_t  hint_metrics);
+cairo_public cairo_hint_metrics_t
+cairo_font_options_get_hint_metrics (const cairo_font_options_t *options);
+
+/* This interface is for dealing with text as text, not caring about the
+   font object inside the the cairo_t. */
+
+cairo_public void
+cairo_select_font_face (cairo_t              *cr,
+			const char           *family,
+			cairo_font_slant_t   slant,
+			cairo_font_weight_t  weight);
+
+cairo_public void
+cairo_set_font_size (cairo_t *cr, double size);
+
+cairo_public void
+cairo_set_font_matrix (cairo_t		    *cr,
+		       const cairo_matrix_t *matrix);
+
+cairo_public void
+cairo_get_font_matrix (cairo_t *cr,
+		       cairo_matrix_t *matrix);
+
+cairo_public void
+cairo_set_font_options (cairo_t                    *cr,
+			const cairo_font_options_t *options);
+
+cairo_public void
+cairo_get_font_options (cairo_t              *cr,
+			cairo_font_options_t *options);
+
+cairo_public void
+cairo_set_font_face (cairo_t *cr, cairo_font_face_t *font_face);
+
+cairo_public cairo_font_face_t *
+cairo_get_font_face (cairo_t *cr);
+
+cairo_public void
+cairo_set_scaled_font (cairo_t                   *cr,
+		       const cairo_scaled_font_t *scaled_font);
+
+cairo_public cairo_scaled_font_t *
+cairo_get_scaled_font (cairo_t *cr);
+
+cairo_public void
+cairo_show_text (cairo_t *cr, const char *utf8);
+
+cairo_public void
+cairo_show_glyphs (cairo_t *cr, const cairo_glyph_t *glyphs, int num_glyphs);
+
+cairo_public void
+cairo_show_text_glyphs (cairo_t			   *cr,
+			const char		   *utf8,
+			int			    utf8_len,
+			const cairo_glyph_t	   *glyphs,
+			int			    num_glyphs,
+			const cairo_text_cluster_t *clusters,
+			int			    num_clusters,
+			cairo_text_cluster_flags_t  cluster_flags);
+
+cairo_public void
+cairo_text_path  (cairo_t *cr, const char *utf8);
+
+cairo_public void
+cairo_glyph_path (cairo_t *cr, const cairo_glyph_t *glyphs, int num_glyphs);
+
+cairo_public void
+cairo_text_extents (cairo_t              *cr,
+		    const char    	 *utf8,
+		    cairo_text_extents_t *extents);
+
+cairo_public void
+cairo_glyph_extents (cairo_t               *cr,
+		     const cairo_glyph_t   *glyphs,
+		     int                   num_glyphs,
+		     cairo_text_extents_t  *extents);
+
+cairo_public void
+cairo_font_extents (cairo_t              *cr,
+		    cairo_font_extents_t *extents);
+
+/* Generic identifier for a font style */
+
+cairo_public cairo_font_face_t *
+cairo_font_face_reference (cairo_font_face_t *font_face);
+
+cairo_public void
+cairo_font_face_destroy (cairo_font_face_t *font_face);
+
+cairo_public unsigned int
+cairo_font_face_get_reference_count (cairo_font_face_t *font_face);
+
+cairo_public cairo_status_t
+cairo_font_face_status (cairo_font_face_t *font_face);
+
+
+/**
+ * cairo_font_type_t:
+ * @CAIRO_FONT_TYPE_TOY: The font was created using cairo's toy font api
+ * @CAIRO_FONT_TYPE_FT: The font is of type FreeType
+ * @CAIRO_FONT_TYPE_WIN32: The font is of type Win32
+ * @CAIRO_FONT_TYPE_QUARTZ: The font is of type Quartz (Since: 1.6)
+ * @CAIRO_FONT_TYPE_USER: The font was create using cairo's user font api (Since: 1.8)
+ *
+ * #cairo_font_type_t is used to describe the type of a given font
+ * face or scaled font. The font types are also known as "font
+ * backends" within cairo.
+ *
+ * The type of a font face is determined by the function used to
+ * create it, which will generally be of the form
+ * cairo_<emphasis>type</emphasis>_font_face_create(). The font face type can be queried
+ * with cairo_font_face_get_type()
+ *
+ * The various #cairo_font_face_t functions can be used with a font face
+ * of any type.
+ *
+ * The type of a scaled font is determined by the type of the font
+ * face passed to cairo_scaled_font_create(). The scaled font type can
+ * be queried with cairo_scaled_font_get_type()
+ *
+ * The various #cairo_scaled_font_t functions can be used with scaled
+ * fonts of any type, but some font backends also provide
+ * type-specific functions that must only be called with a scaled font
+ * of the appropriate type. These functions have names that begin with
+ * cairo_<emphasis>type</emphasis>_scaled_font() such as cairo_ft_scaled_font_lock_face().
+ *
+ * The behavior of calling a type-specific function with a scaled font
+ * of the wrong type is undefined.
+ *
+ * New entries may be added in future versions.
+ *
+ * Since: 1.2
+ **/
+typedef enum _cairo_font_type {
+    CAIRO_FONT_TYPE_TOY,
+    CAIRO_FONT_TYPE_FT,
+    CAIRO_FONT_TYPE_WIN32,
+    CAIRO_FONT_TYPE_QUARTZ,
+    CAIRO_FONT_TYPE_USER
+} cairo_font_type_t;
+
+cairo_public cairo_font_type_t
+cairo_font_face_get_type (cairo_font_face_t *font_face);
+
+cairo_public void *
+cairo_font_face_get_user_data (cairo_font_face_t	   *font_face,
+			       const cairo_user_data_key_t *key);
+
+cairo_public cairo_status_t
+cairo_font_face_set_user_data (cairo_font_face_t	   *font_face,
+			       const cairo_user_data_key_t *key,
+			       void			   *user_data,
+			       cairo_destroy_func_t	    destroy);
+
+/* Portable interface to general font features. */
+
+cairo_public cairo_scaled_font_t *
+cairo_scaled_font_create (cairo_font_face_t          *font_face,
+			  const cairo_matrix_t       *font_matrix,
+			  const cairo_matrix_t       *ctm,
+			  const cairo_font_options_t *options);
+
+cairo_public cairo_scaled_font_t *
+cairo_scaled_font_reference (cairo_scaled_font_t *scaled_font);
+
+cairo_public void
+cairo_scaled_font_destroy (cairo_scaled_font_t *scaled_font);
+
+cairo_public unsigned int
+cairo_scaled_font_get_reference_count (cairo_scaled_font_t *scaled_font);
+
+cairo_public cairo_status_t
+cairo_scaled_font_status (cairo_scaled_font_t *scaled_font);
+
+cairo_public cairo_font_type_t
+cairo_scaled_font_get_type (cairo_scaled_font_t *scaled_font);
+
+cairo_public void *
+cairo_scaled_font_get_user_data (cairo_scaled_font_t         *scaled_font,
+				 const cairo_user_data_key_t *key);
+
+cairo_public cairo_status_t
+cairo_scaled_font_set_user_data (cairo_scaled_font_t         *scaled_font,
+				 const cairo_user_data_key_t *key,
+				 void                        *user_data,
+				 cairo_destroy_func_t	      destroy);
+
+cairo_public void
+cairo_scaled_font_extents (cairo_scaled_font_t  *scaled_font,
+			   cairo_font_extents_t *extents);
+
+cairo_public void
+cairo_scaled_font_text_extents (cairo_scaled_font_t  *scaled_font,
+				const char  	     *utf8,
+				cairo_text_extents_t *extents);
+
+cairo_public void
+cairo_scaled_font_glyph_extents (cairo_scaled_font_t   *scaled_font,
+				 const cairo_glyph_t   *glyphs,
+				 int                   num_glyphs,
+				 cairo_text_extents_t  *extents);
+
+cairo_public cairo_status_t
+cairo_scaled_font_text_to_glyphs (cairo_scaled_font_t        *scaled_font,
+				  double		      x,
+				  double		      y,
+				  const char	             *utf8,
+				  int		              utf8_len,
+				  cairo_glyph_t	            **glyphs,
+				  int		             *num_glyphs,
+				  cairo_text_cluster_t      **clusters,
+				  int		             *num_clusters,
+				  cairo_text_cluster_flags_t *cluster_flags);
+
+cairo_public cairo_font_face_t *
+cairo_scaled_font_get_font_face (cairo_scaled_font_t *scaled_font);
+
+cairo_public void
+cairo_scaled_font_get_font_matrix (cairo_scaled_font_t	*scaled_font,
+				   cairo_matrix_t	*font_matrix);
+
+cairo_public void
+cairo_scaled_font_get_ctm (cairo_scaled_font_t	*scaled_font,
+			   cairo_matrix_t	*ctm);
+
+cairo_public void
+cairo_scaled_font_get_scale_matrix (cairo_scaled_font_t	*scaled_font,
+				    cairo_matrix_t	*scale_matrix);
+
+cairo_public void
+cairo_scaled_font_get_font_options (cairo_scaled_font_t		*scaled_font,
+				    cairo_font_options_t	*options);
+
+
+/* Toy fonts */
+
+cairo_public cairo_font_face_t *
+cairo_toy_font_face_create (const char           *family,
+			    cairo_font_slant_t    slant,
+			    cairo_font_weight_t   weight);
+
+cairo_public const char *
+cairo_toy_font_face_get_family (cairo_font_face_t *font_face);
+
+cairo_public cairo_font_slant_t
+cairo_toy_font_face_get_slant (cairo_font_face_t *font_face);
+
+cairo_public cairo_font_weight_t
+cairo_toy_font_face_get_weight (cairo_font_face_t *font_face);
+
+
+/* User fonts */
+
+cairo_public cairo_font_face_t *
+cairo_user_font_face_create (void);
+
+/* User-font method signatures */
+
+/**
+ * cairo_user_scaled_font_init_func_t:
+ * @scaled_font: the scaled-font being created
+ * @cr: a cairo context, in font space
+ * @extents: font extents to fill in, in font space
+ *
+ * #cairo_user_scaled_font_init_func_t is the type of function which is
+ * called when a scaled-font needs to be created for a user font-face.
+ *
+ * The cairo context @cr is not used by the caller, but is prepared in font
+ * space, similar to what the cairo contexts passed to the render_glyph
+ * method will look like.  The callback can use this context for extents
+ * computation for example.  After the callback is called, @cr is checked
+ * for any error status.
+ *
+ * The @extents argument is where the user font sets the font extents for
+ * @scaled_font.  It is in font space, which means that for most cases its
+ * ascent and descent members should add to 1.0.  @extents is preset to
+ * hold a value of 1.0 for ascent, height, and max_x_advance, and 0.0 for
+ * descent and max_y_advance members.
+ *
+ * The callback is optional.  If not set, default font extents as described
+ * in the previous paragraph will be used.
+ *
+ * Note that @scaled_font is not fully initialized at this
+ * point and trying to use it for text operations in the callback will result
+ * in deadlock.
+ *
+ * Returns: %CAIRO_STATUS_SUCCESS upon success, or an error status on error.
+ *
+ * Since: 1.8
+ **/
+typedef cairo_status_t (*cairo_user_scaled_font_init_func_t) (cairo_scaled_font_t  *scaled_font,
+							      cairo_t              *cr,
+							      cairo_font_extents_t *extents);
+
+/**
+ * cairo_user_scaled_font_render_glyph_func_t:
+ * @scaled_font: user scaled-font
+ * @glyph: glyph code to render
+ * @cr: cairo context to draw to, in font space
+ * @extents: glyph extents to fill in, in font space
+ *
+ * #cairo_user_scaled_font_render_glyph_func_t is the type of function which
+ * is called when a user scaled-font needs to render a glyph.
+ *
+ * The callback is mandatory, and expected to draw the glyph with code @glyph to
+ * the cairo context @cr.  @cr is prepared such that the glyph drawing is done in
+ * font space.  That is, the matrix set on @cr is the scale matrix of @scaled_font,
+ * The @extents argument is where the user font sets the font extents for
+ * @scaled_font.  However, if user prefers to draw in user space, they can
+ * achieve that by changing the matrix on @cr.  All cairo rendering operations
+ * to @cr are permitted, however, the result is undefined if any source other
+ * than the default source on @cr is used.  That means, glyph bitmaps should
+ * be rendered using cairo_mask() instead of cairo_paint().
+ *
+ * Other non-default settings on @cr include a font size of 1.0 (given that
+ * it is set up to be in font space), and font options corresponding to
+ * @scaled_font.
+ *
+ * The @extents argument is preset to have <literal>x_bearing</literal>,
+ * <literal>width</literal>, and <literal>y_advance</literal> of zero,
+ * <literal>y_bearing</literal> set to <literal>-font_extents.ascent</literal>,
+ * <literal>height</literal> to <literal>font_extents.ascent+font_extents.descent</literal>,
+ * and <literal>x_advance</literal> to <literal>font_extents.max_x_advance</literal>.
+ * The only field user needs to set in majority of cases is
+ * <literal>x_advance</literal>.
+ * If the <literal>width</literal> field is zero upon the callback returning
+ * (which is its preset value), the glyph extents are automatically computed
+ * based on the drawings done to @cr.  This is in most cases exactly what the
+ * desired behavior is.  However, if for any reason the callback sets the
+ * extents, it must be ink extents, and include the extents of all drawing
+ * done to @cr in the callback.
+ *
+ * Returns: %CAIRO_STATUS_SUCCESS upon success, or
+ * %CAIRO_STATUS_USER_FONT_ERROR or any other error status on error.
+ *
+ * Since: 1.8
+ **/
+typedef cairo_status_t (*cairo_user_scaled_font_render_glyph_func_t) (cairo_scaled_font_t  *scaled_font,
+								      unsigned long         glyph,
+								      cairo_t              *cr,
+								      cairo_text_extents_t *extents);
+
+/**
+ * cairo_user_scaled_font_text_to_glyphs_func_t:
+ * @scaled_font: the scaled-font being created
+ * @utf8: a string of text encoded in UTF-8
+ * @utf8_len: length of @utf8 in bytes
+ * @glyphs: pointer to array of glyphs to fill, in font space
+ * @num_glyphs: pointer to number of glyphs
+ * @clusters: pointer to array of cluster mapping information to fill, or %NULL
+ * @num_clusters: pointer to number of clusters
+ * @cluster_flags: pointer to location to store cluster flags corresponding to the
+ *                 output @clusters
+ *
+ * #cairo_user_scaled_font_text_to_glyphs_func_t is the type of function which
+ * is called to convert input text to an array of glyphs.  This is used by the
+ * cairo_show_text() operation.
+ *
+ * Using this callback the user-font has full control on glyphs and their
+ * positions.  That means, it allows for features like ligatures and kerning,
+ * as well as complex <firstterm>shaping</firstterm> required for scripts like
+ * Arabic and Indic.
+ *
+ * The @num_glyphs argument is preset to the number of glyph entries available
+ * in the @glyphs buffer. If the @glyphs buffer is %NULL, the value of
+ * @num_glyphs will be zero.  If the provided glyph array is too short for
+ * the conversion (or for convenience), a new glyph array may be allocated
+ * using cairo_glyph_allocate() and placed in @glyphs.  Upon return,
+ * @num_glyphs should contain the number of generated glyphs.  If the value
+ * @glyphs points at has changed after the call, the caller will free the
+ * allocated glyph array using cairo_glyph_free().
+ * The callback should populate the glyph indices and positions (in font space)
+ * assuming that the text is to be shown at the origin.
+ *
+ * If @clusters is not %NULL, @num_clusters and @cluster_flags are also
+ * non-%NULL, and cluster mapping should be computed. The semantics of how
+ * cluster array allocation works is similar to the glyph array.  That is,
+ * if @clusters initially points to a non-%NULL value, that array may be used
+ * as a cluster buffer, and @num_clusters points to the number of cluster
+ * entries available there.  If the provided cluster array is too short for
+ * the conversion (or for convenience), a new cluster array may be allocated
+ * using cairo_text_cluster_allocate() and placed in @clusters.  Upon return,
+ * @num_clusters should contain the number of generated clusters.
+ * If the value @clusters points at has changed after the call, the caller
+ * will free the allocated cluster array using cairo_text_cluster_free().
+ *
+ * The callback is optional.  If @num_glyphs is negative upon
+ * the callback returning or if the return value
+ * is %CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED, the unicode_to_glyph callback
+ * is tried.  See #cairo_user_scaled_font_unicode_to_glyph_func_t.
+ *
+ * Note: While cairo does not impose any limitation on glyph indices,
+ * some applications may assume that a glyph index fits in a 16-bit
+ * unsigned integer.  As such, it is advised that user-fonts keep their
+ * glyphs in the 0 to 65535 range.  Furthermore, some applications may
+ * assume that glyph 0 is a special glyph-not-found glyph.  User-fonts
+ * are advised to use glyph 0 for such purposes and do not use that
+ * glyph value for other purposes.
+ *
+ * Returns: %CAIRO_STATUS_SUCCESS upon success,
+ * %CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED if fallback options should be tried,
+ * or %CAIRO_STATUS_USER_FONT_ERROR or any other error status on error.
+ *
+ * Since: 1.8
+ **/
+typedef cairo_status_t (*cairo_user_scaled_font_text_to_glyphs_func_t) (cairo_scaled_font_t        *scaled_font,
+									const char	           *utf8,
+									int		            utf8_len,
+									cairo_glyph_t	          **glyphs,
+									int		           *num_glyphs,
+									cairo_text_cluster_t      **clusters,
+									int		           *num_clusters,
+									cairo_text_cluster_flags_t *cluster_flags);
+
+/**
+ * cairo_user_scaled_font_unicode_to_glyph_func_t:
+ * @scaled_font: the scaled-font being created
+ * @unicode: input unicode character code-point
+ * @glyph_index: output glyph index
+ *
+ * #cairo_user_scaled_font_unicode_to_glyph_func_t is the type of function which
+ * is called to convert an input Unicode character to a single glyph.
+ * This is used by the cairo_show_text() operation.
+ *
+ * This callback is used to provide the same functionality as the
+ * text_to_glyphs callback does (see #cairo_user_scaled_font_text_to_glyphs_func_t)
+ * but has much less control on the output,
+ * in exchange for increased ease of use.  The inherent assumption to using
+ * this callback is that each character maps to one glyph, and that the
+ * mapping is context independent.  It also assumes that glyphs are positioned
+ * according to their advance width.  These mean no ligatures, kerning, or
+ * complex scripts can be implemented using this callback.
+ *
+ * The callback is optional, and only used if text_to_glyphs callback is not
+ * set or fails to return glyphs.  If this callback is not set or if it returns
+ * %CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED, an identity mapping from Unicode
+ * code-points to glyph indices is assumed.
+ *
+ * Note: While cairo does not impose any limitation on glyph indices,
+ * some applications may assume that a glyph index fits in a 16-bit
+ * unsigned integer.  As such, it is advised that user-fonts keep their
+ * glyphs in the 0 to 65535 range.  Furthermore, some applications may
+ * assume that glyph 0 is a special glyph-not-found glyph.  User-fonts
+ * are advised to use glyph 0 for such purposes and do not use that
+ * glyph value for other purposes.
+ *
+ * Returns: %CAIRO_STATUS_SUCCESS upon success,
+ * %CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED if fallback options should be tried,
+ * or %CAIRO_STATUS_USER_FONT_ERROR or any other error status on error.
+ *
+ * Since: 1.8
+ **/
+typedef cairo_status_t (*cairo_user_scaled_font_unicode_to_glyph_func_t) (cairo_scaled_font_t *scaled_font,
+									  unsigned long        unicode,
+									  unsigned long       *glyph_index);
+
+/* User-font method setters */
+
+cairo_public void
+cairo_user_font_face_set_init_func (cairo_font_face_t                  *font_face,
+				    cairo_user_scaled_font_init_func_t  init_func);
+
+cairo_public void
+cairo_user_font_face_set_render_glyph_func (cairo_font_face_t                          *font_face,
+					    cairo_user_scaled_font_render_glyph_func_t  render_glyph_func);
+
+cairo_public void
+cairo_user_font_face_set_text_to_glyphs_func (cairo_font_face_t                            *font_face,
+					      cairo_user_scaled_font_text_to_glyphs_func_t  text_to_glyphs_func);
+
+cairo_public void
+cairo_user_font_face_set_unicode_to_glyph_func (cairo_font_face_t                              *font_face,
+					        cairo_user_scaled_font_unicode_to_glyph_func_t  unicode_to_glyph_func);
+
+/* User-font method getters */
+
+cairo_public cairo_user_scaled_font_init_func_t
+cairo_user_font_face_get_init_func (cairo_font_face_t *font_face);
+
+cairo_public cairo_user_scaled_font_render_glyph_func_t
+cairo_user_font_face_get_render_glyph_func (cairo_font_face_t *font_face);
+
+cairo_public cairo_user_scaled_font_text_to_glyphs_func_t
+cairo_user_font_face_get_text_to_glyphs_func (cairo_font_face_t *font_face);
+
+cairo_public cairo_user_scaled_font_unicode_to_glyph_func_t
+cairo_user_font_face_get_unicode_to_glyph_func (cairo_font_face_t *font_face);
+
+
+/* Query functions */
+
+cairo_public cairo_operator_t
+cairo_get_operator (cairo_t *cr);
+
+cairo_public cairo_pattern_t *
+cairo_get_source (cairo_t *cr);
+
+cairo_public double
+cairo_get_tolerance (cairo_t *cr);
+
+cairo_public cairo_antialias_t
+cairo_get_antialias (cairo_t *cr);
+
+cairo_public cairo_bool_t
+cairo_has_current_point (cairo_t *cr);
+
+cairo_public void
+cairo_get_current_point (cairo_t *cr, double *x, double *y);
+
+cairo_public cairo_fill_rule_t
+cairo_get_fill_rule (cairo_t *cr);
+
+cairo_public double
+cairo_get_line_width (cairo_t *cr);
+
+cairo_public cairo_line_cap_t
+cairo_get_line_cap (cairo_t *cr);
+
+cairo_public cairo_line_join_t
+cairo_get_line_join (cairo_t *cr);
+
+cairo_public double
+cairo_get_miter_limit (cairo_t *cr);
+
+cairo_public int
+cairo_get_dash_count (cairo_t *cr);
+
+cairo_public void
+cairo_get_dash (cairo_t *cr, double *dashes, double *offset);
+
+cairo_public void
+cairo_get_matrix (cairo_t *cr, cairo_matrix_t *matrix);
+
+cairo_public cairo_surface_t *
+cairo_get_target (cairo_t *cr);
+
+cairo_public cairo_surface_t *
+cairo_get_group_target (cairo_t *cr);
+
+/**
+ * cairo_path_data_type_t:
+ * @CAIRO_PATH_MOVE_TO: A move-to operation
+ * @CAIRO_PATH_LINE_TO: A line-to operation
+ * @CAIRO_PATH_CURVE_TO: A curve-to operation
+ * @CAIRO_PATH_CLOSE_PATH: A close-path operation
+ *
+ * #cairo_path_data_t is used to describe the type of one portion
+ * of a path when represented as a #cairo_path_t.
+ * See #cairo_path_data_t for details.
+ **/
+typedef enum _cairo_path_data_type {
+    CAIRO_PATH_MOVE_TO,
+    CAIRO_PATH_LINE_TO,
+    CAIRO_PATH_CURVE_TO,
+    CAIRO_PATH_CLOSE_PATH
+} cairo_path_data_type_t;
+
+/**
+ * cairo_path_data_t:
+ *
+ * #cairo_path_data_t is used to represent the path data inside a
+ * #cairo_path_t.
+ *
+ * The data structure is designed to try to balance the demands of
+ * efficiency and ease-of-use. A path is represented as an array of
+ * #cairo_path_data_t, which is a union of headers and points.
+ *
+ * Each portion of the path is represented by one or more elements in
+ * the array, (one header followed by 0 or more points). The length
+ * value of the header is the number of array elements for the current
+ * portion including the header, (ie. length == 1 + # of points), and
+ * where the number of points for each element type is as follows:
+ *
+ * <programlisting>
+ *     %CAIRO_PATH_MOVE_TO:     1 point
+ *     %CAIRO_PATH_LINE_TO:     1 point
+ *     %CAIRO_PATH_CURVE_TO:    3 points
+ *     %CAIRO_PATH_CLOSE_PATH:  0 points
+ * </programlisting>
+ *
+ * The semantics and ordering of the coordinate values are consistent
+ * with cairo_move_to(), cairo_line_to(), cairo_curve_to(), and
+ * cairo_close_path().
+ *
+ * Here is sample code for iterating through a #cairo_path_t:
+ *
+ * <informalexample><programlisting>
+ *      int i;
+ *      cairo_path_t *path;
+ *      cairo_path_data_t *data;
+ * &nbsp;
+ *      path = cairo_copy_path (cr);
+ * &nbsp;
+ *      for (i=0; i < path->num_data; i += path->data[i].header.length) {
+ *          data = &amp;path->data[i];
+ *          switch (data->header.type) {
+ *          case CAIRO_PATH_MOVE_TO:
+ *              do_move_to_things (data[1].point.x, data[1].point.y);
+ *              break;
+ *          case CAIRO_PATH_LINE_TO:
+ *              do_line_to_things (data[1].point.x, data[1].point.y);
+ *              break;
+ *          case CAIRO_PATH_CURVE_TO:
+ *              do_curve_to_things (data[1].point.x, data[1].point.y,
+ *                                  data[2].point.x, data[2].point.y,
+ *                                  data[3].point.x, data[3].point.y);
+ *              break;
+ *          case CAIRO_PATH_CLOSE_PATH:
+ *              do_close_path_things ();
+ *              break;
+ *          }
+ *      }
+ *      cairo_path_destroy (path);
+ * </programlisting></informalexample>
+ *
+ * As of cairo 1.4, cairo does not mind if there are more elements in
+ * a portion of the path than needed.  Such elements can be used by
+ * users of the cairo API to hold extra values in the path data
+ * structure.  For this reason, it is recommended that applications
+ * always use <literal>data->header.length</literal> to
+ * iterate over the path data, instead of hardcoding the number of
+ * elements for each element type.
+ **/
+typedef union _cairo_path_data_t cairo_path_data_t;
+union _cairo_path_data_t {
+    struct {
+	cairo_path_data_type_t type;
+	int length;
+    } header;
+    struct {
+	double x, y;
+    } point;
+};
+
+/**
+ * cairo_path_t:
+ * @status: the current error status
+ * @data: the elements in the path
+ * @num_data: the number of elements in the data array
+ *
+ * A data structure for holding a path. This data structure serves as
+ * the return value for cairo_copy_path() and
+ * cairo_copy_path_flat() as well the input value for
+ * cairo_append_path().
+ *
+ * See #cairo_path_data_t for hints on how to iterate over the
+ * actual data within the path.
+ *
+ * The num_data member gives the number of elements in the data
+ * array. This number is larger than the number of independent path
+ * portions (defined in #cairo_path_data_type_t), since the data
+ * includes both headers and coordinates for each portion.
+ **/
+typedef struct cairo_path {
+    cairo_status_t status;
+    cairo_path_data_t *data;
+    int num_data;
+} cairo_path_t;
+
+cairo_public cairo_path_t *
+cairo_copy_path (cairo_t *cr);
+
+cairo_public cairo_path_t *
+cairo_copy_path_flat (cairo_t *cr);
+
+cairo_public void
+cairo_append_path (cairo_t		*cr,
+		   const cairo_path_t	*path);
+
+cairo_public void
+cairo_path_destroy (cairo_path_t *path);
+
+/* Error status queries */
+
+cairo_public cairo_status_t
+cairo_status (cairo_t *cr);
+
+cairo_public const char *
+cairo_status_to_string (cairo_status_t status);
+
+/* Surface manipulation */
+
+cairo_public cairo_surface_t *
+cairo_surface_create_similar (cairo_surface_t  *other,
+			      cairo_content_t	content,
+			      int		width,
+			      int		height);
+
+cairo_public cairo_surface_t *
+cairo_surface_reference (cairo_surface_t *surface);
+
+cairo_public void
+cairo_surface_finish (cairo_surface_t *surface);
+
+cairo_public void
+cairo_surface_destroy (cairo_surface_t *surface);
+
+cairo_public unsigned int
+cairo_surface_get_reference_count (cairo_surface_t *surface);
+
+cairo_public cairo_status_t
+cairo_surface_status (cairo_surface_t *surface);
+
+/**
+ * cairo_surface_type_t:
+ * @CAIRO_SURFACE_TYPE_IMAGE: The surface is of type image
+ * @CAIRO_SURFACE_TYPE_PDF: The surface is of type pdf
+ * @CAIRO_SURFACE_TYPE_PS: The surface is of type ps
+ * @CAIRO_SURFACE_TYPE_XLIB: The surface is of type xlib
+ * @CAIRO_SURFACE_TYPE_XCB: The surface is of type xcb
+ * @CAIRO_SURFACE_TYPE_GLITZ: The surface is of type glitz
+ * @CAIRO_SURFACE_TYPE_QUARTZ: The surface is of type quartz
+ * @CAIRO_SURFACE_TYPE_WIN32: The surface is of type win32
+ * @CAIRO_SURFACE_TYPE_BEOS: The surface is of type beos
+ * @CAIRO_SURFACE_TYPE_DIRECTFB: The surface is of type directfb
+ * @CAIRO_SURFACE_TYPE_SVG: The surface is of type svg
+ * @CAIRO_SURFACE_TYPE_OS2: The surface is of type os2
+ * @CAIRO_SURFACE_TYPE_WIN32_PRINTING: The surface is a win32 printing surface
+ * @CAIRO_SURFACE_TYPE_QUARTZ_IMAGE: The surface is of type quartz_image
+ * @CAIRO_SURFACE_TYPE_SCRIPT: The surface is of type script, since 1.10
+ * @CAIRO_SURFACE_TYPE_QT: The surface is of type Qt, since 1.10
+ * @CAIRO_SURFACE_TYPE_RECORDING: The surface is of type recording, since 1.10
+ * @CAIRO_SURFACE_TYPE_VG: The surface is a OpenVG surface, since 1.10
+ * @CAIRO_SURFACE_TYPE_GL: The surface is of type OpenGL, since 1.10
+ * @CAIRO_SURFACE_TYPE_DRM: The surface is of type Direct Render Manager, since 1.10
+ * @CAIRO_SURFACE_TYPE_TEE: The surface is of type 'tee' (a multiplexing surface), since 1.10
+ * @CAIRO_SURFACE_TYPE_XML: The surface is of type XML (for debugging), since 1.10
+ * @CAIRO_SURFACE_TYPE_SKIA: The surface is of type Skia, since 1.10
+ *
+ * #cairo_surface_type_t is used to describe the type of a given
+ * surface. The surface types are also known as "backends" or "surface
+ * backends" within cairo.
+ *
+ * The type of a surface is determined by the function used to create
+ * it, which will generally be of the form cairo_<emphasis>type</emphasis>_surface_create(),
+ * (though see cairo_surface_create_similar() as well).
+ *
+ * The surface type can be queried with cairo_surface_get_type()
+ *
+ * The various #cairo_surface_t functions can be used with surfaces of
+ * any type, but some backends also provide type-specific functions
+ * that must only be called with a surface of the appropriate
+ * type. These functions have names that begin with
+ * cairo_<emphasis>type</emphasis>_surface<!-- --> such as cairo_image_surface_get_width().
+ *
+ * The behavior of calling a type-specific function with a surface of
+ * the wrong type is undefined.
+ *
+ * New entries may be added in future versions.
+ *
+ * Since: 1.2
+ **/
+typedef enum _cairo_surface_type {
+    CAIRO_SURFACE_TYPE_IMAGE,
+    CAIRO_SURFACE_TYPE_PDF,
+    CAIRO_SURFACE_TYPE_PS,
+    CAIRO_SURFACE_TYPE_XLIB,
+    CAIRO_SURFACE_TYPE_XCB,
+    CAIRO_SURFACE_TYPE_GLITZ,
+    CAIRO_SURFACE_TYPE_QUARTZ,
+    CAIRO_SURFACE_TYPE_WIN32,
+    CAIRO_SURFACE_TYPE_BEOS,
+    CAIRO_SURFACE_TYPE_DIRECTFB,
+    CAIRO_SURFACE_TYPE_SVG,
+    CAIRO_SURFACE_TYPE_OS2,
+    CAIRO_SURFACE_TYPE_WIN32_PRINTING,
+    CAIRO_SURFACE_TYPE_QUARTZ_IMAGE,
+    CAIRO_SURFACE_TYPE_SCRIPT,
+    CAIRO_SURFACE_TYPE_QT,
+    CAIRO_SURFACE_TYPE_RECORDING,
+    CAIRO_SURFACE_TYPE_VG,
+    CAIRO_SURFACE_TYPE_GL,
+    CAIRO_SURFACE_TYPE_DRM,
+    CAIRO_SURFACE_TYPE_TEE,
+    CAIRO_SURFACE_TYPE_XML,
+    CAIRO_SURFACE_TYPE_SKIA
+} cairo_surface_type_t;
+
+cairo_public cairo_surface_type_t
+cairo_surface_get_type (cairo_surface_t *surface);
+
+cairo_public cairo_content_t
+cairo_surface_get_content (cairo_surface_t *surface);
+
+#if CAIRO_HAS_PNG_FUNCTIONS
+
+cairo_public cairo_status_t
+cairo_surface_write_to_png (cairo_surface_t	*surface,
+			    const char		*filename);
+
+cairo_public cairo_status_t
+cairo_surface_write_to_png_stream (cairo_surface_t	*surface,
+				   cairo_write_func_t	write_func,
+				   void			*closure);
+
+#endif
+
+cairo_public void *
+cairo_surface_get_user_data (cairo_surface_t		 *surface,
+			     const cairo_user_data_key_t *key);
+
+cairo_public cairo_status_t
+cairo_surface_set_user_data (cairo_surface_t		 *surface,
+			     const cairo_user_data_key_t *key,
+			     void			 *user_data,
+			     cairo_destroy_func_t	 destroy);
+
+#define CAIRO_MIME_TYPE_JPEG "image/jpeg"
+#define CAIRO_MIME_TYPE_PNG "image/png"
+#define CAIRO_MIME_TYPE_JP2 "image/jp2"
+
+cairo_public void
+cairo_surface_get_mime_data (cairo_surface_t		*surface,
+                             const char			*mime_type,
+                             const unsigned char       **data,
+                             unsigned int		*length);
+
+cairo_public cairo_status_t
+cairo_surface_set_mime_data (cairo_surface_t		*surface,
+                             const char			*mime_type,
+                             const unsigned char	*data,
+                             unsigned int		 length,
+			     cairo_destroy_func_t	 destroy,
+			     void			*closure);
+
+cairo_public void
+cairo_surface_get_font_options (cairo_surface_t      *surface,
+				cairo_font_options_t *options);
+
+cairo_public void
+cairo_surface_flush (cairo_surface_t *surface);
+
+cairo_public void
+cairo_surface_mark_dirty (cairo_surface_t *surface);
+
+cairo_public void
+cairo_surface_mark_dirty_rectangle (cairo_surface_t *surface,
+				    int              x,
+				    int              y,
+				    int              width,
+				    int              height);
+
+cairo_public void
+cairo_surface_set_device_offset (cairo_surface_t *surface,
+				 double           x_offset,
+				 double           y_offset);
+
+cairo_public void
+cairo_surface_get_device_offset (cairo_surface_t *surface,
+				 double          *x_offset,
+				 double          *y_offset);
+
+cairo_public void
+cairo_surface_set_fallback_resolution (cairo_surface_t	*surface,
+				       double		 x_pixels_per_inch,
+				       double		 y_pixels_per_inch);
+
+cairo_public void
+cairo_surface_get_fallback_resolution (cairo_surface_t	*surface,
+				       double		*x_pixels_per_inch,
+				       double		*y_pixels_per_inch);
+
+cairo_public void
+cairo_surface_copy_page (cairo_surface_t *surface);
+
+cairo_public void
+cairo_surface_show_page (cairo_surface_t *surface);
+
+cairo_public cairo_bool_t
+cairo_surface_has_show_text_glyphs (cairo_surface_t *surface);
+
+/* Image-surface functions */
+
+/**
+ * cairo_format_t:
+ * @CAIRO_FORMAT_ARGB32: each pixel is a 32-bit quantity, with
+ *   alpha in the upper 8 bits, then red, then green, then blue.
+ *   The 32-bit quantities are stored native-endian. Pre-multiplied
+ *   alpha is used. (That is, 50% transparent red is 0x80800000,
+ *   not 0x80ff0000.)
+ * @CAIRO_FORMAT_RGB24: each pixel is a 32-bit quantity, with
+ *   the upper 8 bits unused. Red, Green, and Blue are stored
+ *   in the remaining 24 bits in that order.
+ * @CAIRO_FORMAT_A8: each pixel is a 8-bit quantity holding
+ *   an alpha value.
+ * @CAIRO_FORMAT_A1: each pixel is a 1-bit quantity holding
+ *   an alpha value. Pixels are packed together into 32-bit
+ *   quantities. The ordering of the bits matches the
+ *   endianess of the platform. On a big-endian machine, the
+ *   first pixel is in the uppermost bit, on a little-endian
+ *   machine the first pixel is in the least-significant bit.
+ * @CAIRO_FORMAT_RGB16_565: This format value is deprecated. It has
+ *   never been properly implemented in cairo and should not be used
+ *   by applications. (since 1.2)
+ *
+ * #cairo_format_t is used to identify the memory format of
+ * image data.
+ *
+ * New entries may be added in future versions.
+ **/
+typedef enum _cairo_format {
+    CAIRO_FORMAT_ARGB32,
+    CAIRO_FORMAT_RGB24,
+    CAIRO_FORMAT_A8,
+    CAIRO_FORMAT_A1
+    /* The value of 4 is reserved by a deprecated enum value.
+     * The next format added must have an explicit value of 5.
+    CAIRO_FORMAT_RGB16_565 = 4,
+    */
+} cairo_format_t;
+
+cairo_public cairo_surface_t *
+cairo_image_surface_create (cairo_format_t	format,
+			    int			width,
+			    int			height);
+
+cairo_public int
+cairo_format_stride_for_width (cairo_format_t	format,
+			       int		width);
+
+cairo_public cairo_surface_t *
+cairo_image_surface_create_for_data (unsigned char	       *data,
+				     cairo_format_t		format,
+				     int			width,
+				     int			height,
+				     int			stride);
+
+cairo_public unsigned char *
+cairo_image_surface_get_data (cairo_surface_t *surface);
+
+cairo_public cairo_format_t
+cairo_image_surface_get_format (cairo_surface_t *surface);
+
+cairo_public int
+cairo_image_surface_get_width (cairo_surface_t *surface);
+
+cairo_public int
+cairo_image_surface_get_height (cairo_surface_t *surface);
+
+cairo_public int
+cairo_image_surface_get_stride (cairo_surface_t *surface);
+
+#if CAIRO_HAS_PNG_FUNCTIONS
+
+cairo_public cairo_surface_t *
+cairo_image_surface_create_from_png (const char	*filename);
+
+cairo_public cairo_surface_t *
+cairo_image_surface_create_from_png_stream (cairo_read_func_t	read_func,
+					    void		*closure);
+
+#endif
+
+/* Recording-surface functions */
+
+cairo_public cairo_surface_t *
+cairo_recording_surface_create (cairo_content_t		 content,
+                                const cairo_rectangle_t *extents);
+
+cairo_public void
+cairo_recording_surface_ink_extents (cairo_surface_t *surface,
+                                     double *x0,
+                                     double *y0,
+                                     double *width,
+                                     double *height);
+
+/* Tee-surface functions */
+
+cairo_public cairo_surface_t *
+cairo_tee_surface_create (cairo_surface_t *master);
+
+cairo_public void
+cairo_tee_surface_add (cairo_surface_t *surface,
+		       cairo_surface_t *target);
+
+cairo_public void
+cairo_tee_surface_remove (cairo_surface_t *surface,
+			  cairo_surface_t *target);
+
+cairo_public cairo_surface_t *
+cairo_tee_surface_index (cairo_surface_t *surface,
+			 int index);
+
+/* Pattern creation functions */
+
+cairo_public cairo_pattern_t *
+cairo_pattern_create_rgb (double red, double green, double blue);
+
+cairo_public cairo_pattern_t *
+cairo_pattern_create_rgba (double red, double green, double blue,
+			   double alpha);
+
+cairo_public cairo_pattern_t *
+cairo_pattern_create_for_surface (cairo_surface_t *surface);
+
+cairo_public cairo_pattern_t *
+cairo_pattern_create_linear (double x0, double y0,
+			     double x1, double y1);
+
+cairo_public cairo_pattern_t *
+cairo_pattern_create_radial (double cx0, double cy0, double radius0,
+			     double cx1, double cy1, double radius1);
+
+cairo_public cairo_pattern_t *
+cairo_pattern_reference (cairo_pattern_t *pattern);
+
+cairo_public void
+cairo_pattern_destroy (cairo_pattern_t *pattern);
+
+cairo_public unsigned int
+cairo_pattern_get_reference_count (cairo_pattern_t *pattern);
+
+cairo_public cairo_status_t
+cairo_pattern_status (cairo_pattern_t *pattern);
+
+cairo_public void *
+cairo_pattern_get_user_data (cairo_pattern_t		 *pattern,
+			     const cairo_user_data_key_t *key);
+
+cairo_public cairo_status_t
+cairo_pattern_set_user_data (cairo_pattern_t		 *pattern,
+			     const cairo_user_data_key_t *key,
+			     void			 *user_data,
+			     cairo_destroy_func_t	  destroy);
+
+/**
+ * cairo_pattern_type_t:
+ * @CAIRO_PATTERN_TYPE_SOLID: The pattern is a solid (uniform)
+ * color. It may be opaque or translucent.
+ * @CAIRO_PATTERN_TYPE_SURFACE: The pattern is a based on a surface (an image).
+ * @CAIRO_PATTERN_TYPE_LINEAR: The pattern is a linear gradient.
+ * @CAIRO_PATTERN_TYPE_RADIAL: The pattern is a radial gradient.
+ *
+ * #cairo_pattern_type_t is used to describe the type of a given pattern.
+ *
+ * The type of a pattern is determined by the function used to create
+ * it. The cairo_pattern_create_rgb() and cairo_pattern_create_rgba()
+ * functions create SOLID patterns. The remaining
+ * cairo_pattern_create<!-- --> functions map to pattern types in obvious
+ * ways.
+ *
+ * The pattern type can be queried with cairo_pattern_get_type()
+ *
+ * Most #cairo_pattern_t functions can be called with a pattern of any
+ * type, (though trying to change the extend or filter for a solid
+ * pattern will have no effect). A notable exception is
+ * cairo_pattern_add_color_stop_rgb() and
+ * cairo_pattern_add_color_stop_rgba() which must only be called with
+ * gradient patterns (either LINEAR or RADIAL). Otherwise the pattern
+ * will be shutdown and put into an error state.
+ *
+ * New entries may be added in future versions.
+ *
+ * Since: 1.2
+ **/
+typedef enum _cairo_pattern_type {
+    CAIRO_PATTERN_TYPE_SOLID,
+    CAIRO_PATTERN_TYPE_SURFACE,
+    CAIRO_PATTERN_TYPE_LINEAR,
+    CAIRO_PATTERN_TYPE_RADIAL
+} cairo_pattern_type_t;
+
+cairo_public cairo_pattern_type_t
+cairo_pattern_get_type (cairo_pattern_t *pattern);
+
+cairo_public void
+cairo_pattern_add_color_stop_rgb (cairo_pattern_t *pattern,
+				  double offset,
+				  double red, double green, double blue);
+
+cairo_public void
+cairo_pattern_add_color_stop_rgba (cairo_pattern_t *pattern,
+				   double offset,
+				   double red, double green, double blue,
+				   double alpha);
+
+cairo_public void
+cairo_pattern_set_matrix (cairo_pattern_t      *pattern,
+			  const cairo_matrix_t *matrix);
+
+cairo_public void
+cairo_pattern_get_matrix (cairo_pattern_t *pattern,
+			  cairo_matrix_t  *matrix);
+
+/**
+ * cairo_extend_t:
+ * @CAIRO_EXTEND_NONE: pixels outside of the source pattern
+ *   are fully transparent
+ * @CAIRO_EXTEND_REPEAT: the pattern is tiled by repeating
+ * @CAIRO_EXTEND_REFLECT: the pattern is tiled by reflecting
+ *   at the edges (Implemented for surface patterns since 1.6)
+ * @CAIRO_EXTEND_PAD: pixels outside of the pattern copy
+ *   the closest pixel from the source (Since 1.2; but only
+ *   implemented for surface patterns since 1.6)
+ *
+ * #cairo_extend_t is used to describe how pattern color/alpha will be
+ * determined for areas "outside" the pattern's natural area, (for
+ * example, outside the surface bounds or outside the gradient
+ * geometry).
+ *
+ * The default extend mode is %CAIRO_EXTEND_NONE for surface patterns
+ * and %CAIRO_EXTEND_PAD for gradient patterns.
+ *
+ * New entries may be added in future versions.
+ **/
+typedef enum _cairo_extend {
+    CAIRO_EXTEND_NONE,
+    CAIRO_EXTEND_REPEAT,
+    CAIRO_EXTEND_REFLECT,
+    CAIRO_EXTEND_PAD
+} cairo_extend_t;
+
+cairo_public void
+cairo_pattern_set_extend (cairo_pattern_t *pattern, cairo_extend_t extend);
+
+cairo_public cairo_extend_t
+cairo_pattern_get_extend (cairo_pattern_t *pattern);
+
+/**
+ * cairo_filter_t:
+ * @CAIRO_FILTER_FAST: A high-performance filter, with quality similar
+ *     to %CAIRO_FILTER_NEAREST
+ * @CAIRO_FILTER_GOOD: A reasonable-performance filter, with quality
+ *     similar to %CAIRO_FILTER_BILINEAR
+ * @CAIRO_FILTER_BEST: The highest-quality available, performance may
+ *     not be suitable for interactive use.
+ * @CAIRO_FILTER_NEAREST: Nearest-neighbor filtering
+ * @CAIRO_FILTER_BILINEAR: Linear interpolation in two dimensions
+ * @CAIRO_FILTER_GAUSSIAN: This filter value is currently
+ *     unimplemented, and should not be used in current code.
+ *
+ * #cairo_filter_t is used to indicate what filtering should be
+ * applied when reading pixel values from patterns. See
+ * cairo_pattern_set_source() for indicating the desired filter to be
+ * used with a particular pattern.
+ */
+typedef enum _cairo_filter {
+    CAIRO_FILTER_FAST,
+    CAIRO_FILTER_GOOD,
+    CAIRO_FILTER_BEST,
+    CAIRO_FILTER_NEAREST,
+    CAIRO_FILTER_BILINEAR,
+    CAIRO_FILTER_GAUSSIAN
+} cairo_filter_t;
+
+cairo_public void
+cairo_pattern_set_filter (cairo_pattern_t *pattern, cairo_filter_t filter);
+
+cairo_public cairo_filter_t
+cairo_pattern_get_filter (cairo_pattern_t *pattern);
+
+cairo_public cairo_status_t
+cairo_pattern_get_rgba (cairo_pattern_t *pattern,
+			double *red, double *green,
+			double *blue, double *alpha);
+
+cairo_public cairo_status_t
+cairo_pattern_get_surface (cairo_pattern_t *pattern,
+			   cairo_surface_t **surface);
+
+
+cairo_public cairo_status_t
+cairo_pattern_get_color_stop_rgba (cairo_pattern_t *pattern,
+				   int index, double *offset,
+				   double *red, double *green,
+				   double *blue, double *alpha);
+
+cairo_public cairo_status_t
+cairo_pattern_get_color_stop_count (cairo_pattern_t *pattern,
+				    int *count);
+
+cairo_public cairo_status_t
+cairo_pattern_get_linear_points (cairo_pattern_t *pattern,
+				 double *x0, double *y0,
+				 double *x1, double *y1);
+
+cairo_public cairo_status_t
+cairo_pattern_get_radial_circles (cairo_pattern_t *pattern,
+				  double *x0, double *y0, double *r0,
+				  double *x1, double *y1, double *r1);
+
+/* Matrix functions */
+
+cairo_public void
+cairo_matrix_init (cairo_matrix_t *matrix,
+		   double  xx, double  yx,
+		   double  xy, double  yy,
+		   double  x0, double  y0);
+
+cairo_public void
+cairo_matrix_init_identity (cairo_matrix_t *matrix);
+
+cairo_public void
+cairo_matrix_init_translate (cairo_matrix_t *matrix,
+			     double tx, double ty);
+
+cairo_public void
+cairo_matrix_init_scale (cairo_matrix_t *matrix,
+			 double sx, double sy);
+
+cairo_public void
+cairo_matrix_init_rotate (cairo_matrix_t *matrix,
+			  double radians);
+
+cairo_public void
+cairo_matrix_translate (cairo_matrix_t *matrix, double tx, double ty);
+
+cairo_public void
+cairo_matrix_scale (cairo_matrix_t *matrix, double sx, double sy);
+
+cairo_public void
+cairo_matrix_rotate (cairo_matrix_t *matrix, double radians);
+
+cairo_public cairo_status_t
+cairo_matrix_invert (cairo_matrix_t *matrix);
+
+cairo_public void
+cairo_matrix_multiply (cairo_matrix_t	    *result,
+		       const cairo_matrix_t *a,
+		       const cairo_matrix_t *b);
+
+cairo_public void
+cairo_matrix_transform_distance (const cairo_matrix_t *matrix,
+				 double *dx, double *dy);
+
+cairo_public void
+cairo_matrix_transform_point (const cairo_matrix_t *matrix,
+			      double *x, double *y);
+
+/* Region functions */
+
+typedef struct _cairo_region cairo_region_t;
+
+typedef struct _cairo_rectangle_int {
+    int x, y;
+    int width, height;
+} cairo_rectangle_int_t;
+
+typedef enum _cairo_region_overlap {
+    CAIRO_REGION_OVERLAP_IN,		/* completely inside region */
+    CAIRO_REGION_OVERLAP_OUT,		/* completely outside region */
+    CAIRO_REGION_OVERLAP_PART		/* partly inside region */
+} cairo_region_overlap_t;
+
+cairo_public cairo_region_t *
+cairo_region_create (void);
+
+cairo_public cairo_region_t *
+cairo_region_create_rectangle (const cairo_rectangle_int_t *rectangle);
+
+cairo_public cairo_region_t *
+cairo_region_create_rectangles (const cairo_rectangle_int_t *rects,
+				int count);
+
+cairo_public cairo_region_t *
+cairo_region_copy (const cairo_region_t *original);
+
+cairo_public cairo_region_t *
+cairo_region_reference (cairo_region_t *);
+
+cairo_public void
+cairo_region_destroy (cairo_region_t *region);
+
+cairo_public cairo_bool_t
+cairo_region_equal (const cairo_region_t *a, const cairo_region_t *b);
+
+cairo_public cairo_status_t
+cairo_region_status (const cairo_region_t *region);
+
+cairo_public void
+cairo_region_get_extents (const cairo_region_t        *region,
+			  cairo_rectangle_int_t *extents);
+
+cairo_public int
+cairo_region_num_rectangles (const cairo_region_t *region);
+
+cairo_public void
+cairo_region_get_rectangle (const cairo_region_t        *region,
+			    int                    nth_rectangle,
+			    cairo_rectangle_int_t *rectangle);
+
+cairo_public cairo_bool_t
+cairo_region_is_empty (const cairo_region_t *region);
+
+cairo_public cairo_region_overlap_t
+cairo_region_contains_rectangle (const cairo_region_t *region,
+				 const cairo_rectangle_int_t *rectangle);
+
+cairo_public cairo_bool_t
+cairo_region_contains_point (const cairo_region_t *region, int x, int y);
+
+cairo_public void
+cairo_region_translate (cairo_region_t *region, int dx, int dy);
+
+cairo_public cairo_status_t
+cairo_region_subtract (cairo_region_t *dst, const cairo_region_t *other);
+
+cairo_public cairo_status_t
+cairo_region_subtract_rectangle (cairo_region_t *dst,
+				 const cairo_rectangle_int_t *rectangle);
+
+cairo_public cairo_status_t
+cairo_region_intersect (cairo_region_t *dst, cairo_region_t *other);
+
+cairo_public cairo_status_t
+cairo_region_intersect_rectangle (cairo_region_t *dst,
+				  const cairo_rectangle_int_t *rectangle);
+
+cairo_public cairo_status_t
+cairo_region_union (cairo_region_t *dst, cairo_region_t *other);
+
+cairo_public cairo_status_t
+cairo_region_union_rectangle (cairo_region_t *dst,
+			      const cairo_rectangle_int_t *rectangle);
+
+
+/* Functions to be used while debugging (not intended for use in production code) */
+cairo_public void
+cairo_debug_reset_static_data (void);
+
+
+CAIRO_END_DECLS
+
+#endif /* CAIRO_H */
diff --git a/src/cairo/cairoint-minimal.h b/src/cairo/cairoint-minimal.h
new file mode 100644
index 0000000..4bde38d
--- /dev/null
+++ b/src/cairo/cairoint-minimal.h
@@ -0,0 +1,147 @@
+/* cairo - a vector graphics library with display and print output
+ *
+ * Copyright © 2002 University of Southern California
+ * Copyright © 2005 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it either under the terms of the GNU Lesser General Public
+ * License version 2.1 as published by the Free Software Foundation
+ * (the "LGPL") or, at your option, under the terms of the Mozilla
+ * Public License Version 1.1 (the "MPL"). If you do not alter this
+ * notice, a recipient may use your version of this file under either
+ * the MPL or the LGPL.
+ *
+ * You should have received a copy of the LGPL along with this library
+ * in the file COPYING-LGPL-2.1; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * You should have received a copy of the MPL along with this library
+ * in the file COPYING-MPL-1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
+ * OF ANY KIND, either express or implied. See the LGPL or the MPL for
+ * the specific language governing rights and limitations.
+ *
+ * The Original Code is the cairo graphics library.
+ *
+ * The Initial Developer of the Original Code is University of Southern
+ * California.
+ *
+ * Contributor(s):
+ *	Carl D. Worth <cworth@cworth.org>
+ */
+
+/*
+ * These definitions are solely for use by the implementation of cairo
+ * and constitute no kind of standard.  If you need any of these
+ * functions, please drop me a note.  Either the library needs new
+ * functionality, or there's a way to do what you need using the
+ * existing published interfaces. cworth@cworth.org
+ */
+
+#ifndef _CAIROINT_H_
+#define _CAIROINT_H_
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#ifdef _MSC_VER
+#define cairo_public __declspec(dllexport)
+#endif
+
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdarg.h>
+#include <stddef.h>
+
+#ifdef _MSC_VER
+#define _USE_MATH_DEFINES
+#endif
+#include <math.h>
+#include <limits.h>
+#include <stdio.h>
+
+#include "cairo.h"
+#include <pixman.h>
+
+#include "cairo-compiler-private.h"
+
+CAIRO_BEGIN_DECLS
+
+#if _WIN32 && !_WIN32_WCE /* Permissions on WinCE? No worries! */
+cairo_private FILE *
+_cairo_win32_tmpfile (void);
+#define tmpfile() _cairo_win32_tmpfile()
+#endif
+
+#undef MIN
+#define MIN(a, b) ((a) < (b) ? (a) : (b))
+
+#undef MAX
+#define MAX(a, b) ((a) > (b) ? (a) : (b))
+
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+
+#ifndef M_PI
+#define M_PI 3.14159265358979323846
+#endif
+
+#ifndef M_SQRT2
+#define M_SQRT2 1.41421356237309504880
+#endif
+
+#ifndef M_SQRT1_2
+#define M_SQRT1_2 0.707106781186547524400844362104849039
+#endif
+
+#undef  ARRAY_LENGTH
+#define ARRAY_LENGTH(__array) ((int) (sizeof (__array) / sizeof (__array[0])))
+
+#undef STRINGIFY
+#undef STRINGIFY_ARG
+#define STRINGIFY(macro_or_string)    STRINGIFY_ARG (macro_or_string)
+#define STRINGIFY_ARG(contents)       #contents
+
+#if defined (__GNUC__)
+#define cairo_container_of(ptr, type, member) ({ \
+    const __typeof__ (((type *) 0)->member) *mptr__ = (ptr); \
+    (type *) ((char *) mptr__ - offsetof (type, member)); \
+})
+#else
+#define cairo_container_of(ptr, type, member) \
+    (type *)((char *) (ptr) - (char *) &((type *)0)->member)
+#endif
+
+
+/* Size in bytes of buffer to use off the stack per functions.
+ * Mostly used by text functions.  For larger allocations, they'll
+ * malloc(). */
+#ifndef CAIRO_STACK_BUFFER_SIZE
+#define CAIRO_STACK_BUFFER_SIZE (512 * sizeof (int))
+#endif
+
+#define CAIRO_STACK_ARRAY_LENGTH(T) (CAIRO_STACK_BUFFER_SIZE / sizeof(T))
+
+
+#include "cairo-types-private.h"
+
+#if HAVE_VALGRIND
+# include <memcheck.h>
+# define VG(x) x
+#else
+# define VG(x)
+#endif
+
+#endif
diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index 677cc22..ac247ec 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -37,7 +37,7 @@
 #include "hid.h"
 #include "hidgl.h"
 #include "rtree.h"
-
+#include "sweep.h"
 
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
@@ -638,6 +638,13 @@ hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale
   PLINE *contour;
   struct do_hole_info info;
   int stencil_bit;
+  cairo_traps_t traps;
+
+  _cairo_traps_init (&traps);
+  bo_poly_to_traps (poly->Clipped, &traps);
+  _cairo_traps_fini (&traps);
+
+  return;
 
   info.scale = scale;
   global_scale = scale;
diff --git a/src/sweep.h b/src/sweep.h
new file mode 100644
index 0000000..2d084ed
--- /dev/null
+++ b/src/sweep.h
@@ -0,0 +1,3 @@
+#include "cairo/cairo-traps-private.h"
+
+cairo_status_t bo_poly_to_traps (POLYAREA *poly, cairo_traps_t *traps);

Bottom: 83ee1e3c2805837772fde845d713ed9d08901dec
Top:    e9c76e6ea92c24c45c9aea42b5fbafcafe2cdc41
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-11-06 16:38:24 +0000

Board outline polygon generation

ALSO:  ** SHOULD MERGE SOME OF THIS COMMIT DOWN INTO OTHER PATCHES **

Fix mask display in 3D (Allow both side masks to display at once)
Fix rendering depths for silk and mask layers


---

diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 3f101be..be37956 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -523,36 +523,47 @@ int compute_depth (int group)
 {
   static int last_depth_computed = 0;
 
+  int solder_group;
+  int component_group;
+  int min_phys_group;
+  int max_phys_group;
+  int max_depth;
   int depth = last_depth_computed;
   int newgroup;
   int idx = (group >= 0
              && group <
              max_layer) ? PCB->LayerGroups.Entries[group][0] : group;
 
+  solder_group = GetLayerGroupNumberByNumber (max_layer + SOLDER_LAYER);
+  component_group = GetLayerGroupNumberByNumber (max_layer + COMPONENT_LAYER);
+
+  min_phys_group = MIN (solder_group, component_group);
+  max_phys_group = MAX (solder_group, component_group);
+
+  max_depth = (1 + max_phys_group - min_phys_group) * 10;
+
   if (group >= 0 && group < max_layer) {
     newgroup = group;
-#if 0
-    /* Re-ordering doesn't work, since we also need to adjust the rendering order */
-    if (group == 1)
-      newgroup = max_layer - 1;
-    else if (group > 1)
-      newgroup = group - 1;
-#endif
-    depth = ((max_layer - newgroup) * 10) * 200 / gport->zoom;
+
+    depth = (max_depth - newgroup * 10) * 200 / gport->zoom;
   } else if (SL_TYPE (idx) == SL_MASK) {
-    if (SL_SIDE (idx) == SL_TOP_SIDE && !Settings.ShowSolderSide) {
-      depth = (max_layer * 10 + 3) * 200 / gport->zoom;
+    if (SL_SIDE (idx) == SL_TOP_SIDE) {
+      depth = (max_depth + 3) * 200 / gport->zoom;
     } else {
       depth = (10 - 3) * 200 / gport->zoom;
     }
   } else if (SL_TYPE (idx) == SL_SILK) {
-    if (SL_SIDE (idx) == SL_TOP_SIDE && !Settings.ShowSolderSide) {
-      depth = (max_layer * 10 + 5) * 200 / gport->zoom;
+    if (SL_SIDE (idx) == SL_TOP_SIDE) {
+      depth = (max_depth + 5) * 200 / gport->zoom;
     } else {
       depth = (10 - 5) * 200 / gport->zoom;
     }
   } else if (SL_TYPE (idx) == SL_INVISIBLE) {
-    depth = (10 - 3) * 200 / gport->zoom;
+    if (Settings.ShowSolderSide) {
+      depth = (max_depth + 5) * 200 / gport->zoom;
+    } else {
+      depth = (10 - 5) * 200 / gport->zoom;
+    }
   }
 
   last_depth_computed = depth;
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index cc5c259..14f125c 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -45,6 +45,7 @@
 #include "draw.h"
 #include "error.h"
 #include "misc.h"
+#include "polygon.h"
 #include "set.h"
 #include "rtree.h"
 #include "snavi.h"
@@ -1309,6 +1310,7 @@ DrawMask (BoxType * screen)
 {
   struct pin_info info;
   int thin = TEST_FLAG(THINDRAWFLAG, PCB) || TEST_FLAG(THINDRAWPOLYFLAG, PCB);
+  PolygonType polygon;
 
   OutputType *out = &Output;
 
@@ -1337,7 +1339,13 @@ DrawMask (BoxType * screen)
   gui->use_mask (HID_MASK_AFTER);
   gui->set_color (out->fgGC, PCB->MaskColor);
   ghid_global_alpha_mult (out->fgGC, thin ? 0.35 : 1.0);
-  gui->fill_rect (out->fgGC, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
+
+  polygon.Clipped = board_outline_poly ();
+  SET_FLAG (FULLPOLYFLAG, &polygon);
+  common_fill_pcb_polygon (out->fgGC, &polygon, screen);
+  /* THE GL fill_pcb_polygon doesn't work whilst masking */
+//  gui->fill_pcb_polygon (out->fgGC, &polygon, screen);
+//  gui->fill_rect (out->fgGC, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
   ghid_global_alpha_mult (out->fgGC, 1.0);
 
   gui->use_mask (HID_MASK_OFF);
@@ -1353,8 +1361,8 @@ DrawLayerGroup (int group, const BoxType * screen)
   int n_entries = PCB->LayerGroups.Number[group];
   Cardinal *layers = PCB->LayerGroups.Entries[group];
   int first_run = 1;
-  int component = GetLayerGroupNumberByNumber (max_layer + COMPONENT_LAYER);
-  int solder    = GetLayerGroupNumberByNumber (max_layer + SOLDER_LAYER);
+  int component_group = GetLayerGroupNumberByNumber (max_layer + COMPONENT_LAYER);
+  int solder_group    = GetLayerGroupNumberByNumber (max_layer + SOLDER_LAYER);
 
   if (!gui->set_layer (0, group, 0)) {
     gui->set_layer (NULL, SL (FINISHED, 0), 0);
@@ -1416,12 +1424,12 @@ DrawLayerGroup (int group, const BoxType * screen)
       if (!global_view_2d && rv) {
         if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, pin_inlayer_callback, Layer);
         if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, via_inlayer_callback, Layer);
-        if ((layernum == component && !SWAP_IDENT) ||
-            (layernum == solder    &&  SWAP_IDENT))
+        if ((group == component_group && !SWAP_IDENT) ||
+            (group == solder_group    &&  SWAP_IDENT))
           if (PCB->PinOn)
             r_search (PCB->Data->pad_tree, screen, NULL, pad_callback, Layer);
-        if ((layernum == solder    && !SWAP_IDENT) ||
-            (layernum == component &&  SWAP_IDENT))
+        if ((group == solder_group    && !SWAP_IDENT) ||
+            (group == component_group &&  SWAP_IDENT))
           if (PCB->PinOn)
             r_search (PCB->Data->pad_tree, screen, NULL, backPad_callback, Layer);
       }
@@ -1534,6 +1542,9 @@ ghid_draw_everything (BoxTypePtr drawn_area)
   if (!global_view_2d && save_show_solder)
     reverse_layers = !reverse_layers;
 
+  PCB->Data->SILKLAYER.Color = PCB->ElementColor;
+  PCB->Data->BACKSILKLAYER.Color = PCB->InvisibleObjectsColor;
+
   solder_group = GetLayerGroupNumberByNumber (max_layer + SOLDER_LAYER);
   component_group = GetLayerGroupNumberByNumber (max_layer + COMPONENT_LAYER);
 
@@ -1556,18 +1567,46 @@ ghid_draw_everything (BoxTypePtr drawn_area)
     }
   }
 
+
   /*
    * first draw all 'invisible' stuff
    */
   if (!TEST_FLAG (CHECKPLANESFLAG, PCB) &&
       gui->set_layer ("invisible", SL (INVISIBLE, 0), 0)) {
-    if (global_view_2d)
-      r_search (PCB->Data->pad_tree, drawn_area, NULL, backPad_callback, NULL);
     if (PCB->ElementOn) {
-      r_search (PCB->Data->element_tree, drawn_area, NULL, backE_callback, NULL);
       r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], drawn_area, NULL, backN_callback, NULL);
       DrawLayer (&(PCB->Data->BACKSILKLAYER), drawn_area);
     }
+#if 1
+    if (!global_view_2d) {
+      /* Draw the solder mask if turned on */
+      if (gui->set_layer ("soldermask", SL (MASK, BOTTOM), 0)) {
+        int save_swap = SWAP_IDENT;
+        gui->set_layer (NULL, SL (FINISHED, 0), 0);
+        gui->set_layer ("componentmask", SL (MASK, TOP), 0);
+        //^__ HACK, THE GUI DOESNT WANT US TO DRAW THIS!
+        SWAP_IDENT = 0;
+        DrawMask (drawn_area);
+        SWAP_IDENT = save_swap;
+        gui->set_layer (NULL, SL (FINISHED, 0), 0);
+      }
+      if (gui->set_layer ("componentmask", SL (MASK, TOP), 0)) {
+        int save_swap = SWAP_IDENT;
+        gui->set_layer (NULL, SL (FINISHED, 0), 0);
+        gui->set_layer ("soldermask", SL (MASK, BOTTOM), 0);
+        //^__ HACK, THE GUI DOESNT WANT US TO DRAW THIS!
+        SWAP_IDENT = 1;
+        DrawMask (drawn_area);
+        SWAP_IDENT = save_swap;
+        gui->set_layer (NULL, SL (FINISHED, 0), 0);
+      }
+      gui->set_layer ("invisible", SL (INVISIBLE, 0), 0);
+    }
+#endif
+    if (global_view_2d)
+      r_search (PCB->Data->pad_tree, drawn_area, NULL, backPad_callback, NULL);
+    if (PCB->ElementOn)
+      r_search (PCB->Data->element_tree, drawn_area, NULL, backE_callback, NULL);
     gui->set_layer (NULL, SL (FINISHED, 0), 0);
   }
 
@@ -1576,9 +1615,11 @@ ghid_draw_everything (BoxTypePtr drawn_area)
     DrawLayerGroup (drawn_groups [i], drawn_area);
 
 #if 1
-    if (!global_view_2d &&
-        drawn_groups[i] > min_phys_group &&
-        drawn_groups[i] <= max_phys_group) {
+    if (!global_view_2d && i > 0 &&
+        drawn_groups[i] >= min_phys_group &&
+        drawn_groups[i] <= max_phys_group &&
+        drawn_groups[i - 1] >= min_phys_group &&
+        drawn_groups[i - 1] <= max_phys_group) {
       cyl_info.from_layer = drawn_groups[i];
       cyl_info.to_layer = drawn_groups[i - 1];
       cyl_info.scale = gport->zoom;
diff --git a/src/polygon.c b/src/polygon.c
index 0a86fa4..95704bb 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -81,6 +81,7 @@ dicer output is used for HIDs which cannot render things with holes
 #include <math.h>
 #include <memory.h>
 #include <setjmp.h>
+#include <glib.h>
 
 #include "global.h"
 #include "box.h"
@@ -1811,3 +1812,171 @@ debug_polygon (PolygonType *p)
 	break;
     }
 }
+
+struct clip_outline_info {
+  POLYAREA *poly;
+};
+
+#define ROUTER_THICKNESS 1000
+//#define ROUTER_THICKNESS 10
+
+static int
+arc_outline_callback (const BoxType * b, void *cl)
+{
+  ArcTypePtr arc = (ArcTypePtr)b;
+  struct clip_outline_info *info = cl;
+  POLYAREA *np, *res;
+
+  if (!(np = ArcPoly (arc, ROUTER_THICKNESS)))
+    return 0;
+
+  poly_Boolean_free (info->poly, np, &res, PBO_SUB);
+  info->poly = res;
+
+  return 1;
+}
+
+static int
+line_outline_callback (const BoxType * b, void *cl)
+{
+  LineTypePtr line = (LineTypePtr)b;
+  struct clip_outline_info *info = cl;
+  POLYAREA *np, *res;
+
+  if (!(np = LinePoly (line, ROUTER_THICKNESS)))
+    return 0;
+
+  poly_Boolean_free (info->poly, np, &res, PBO_SUB);
+  info->poly = res;
+
+  return 1;
+}
+
+static void
+delete_piece_cb (gpointer data, gpointer userdata)
+{
+  POLYAREA *piece = data;
+  POLYAREA **res = userdata;
+
+  /* If this item was the start of the list, advance that pointer */
+  if (*res == piece)
+    *res = (*res)->f;
+
+  /* But reset it to NULL if it wraps around and hits us again */
+  if (*res == piece)
+    *res = NULL;
+
+  piece->b->f = piece->f;
+  piece->f->b = piece->b;
+  piece->f = piece->b = piece;
+
+  poly_Free (&piece);
+}
+
+POLYAREA *board_outline_poly ()
+{
+  int i;
+  int count;
+  int found_outline = 0;
+  LayerTypePtr Layer = NULL;
+  BoxType region;
+  struct clip_outline_info info;
+  POLYAREA *whole_world;
+  POLYAREA *clipped;
+  POLYAREA *piece;
+  POLYAREA *check;
+  GList *pieces_to_delete = NULL;
+
+#define BLOAT_WORLD 1000
+
+  whole_world = RectPoly (-BLOAT_WORLD, BLOAT_WORLD + PCB->MaxWidth,
+                          -BLOAT_WORLD, BLOAT_WORLD + PCB->MaxHeight);
+
+  for (i = 0; i < max_layer; i++)
+    {
+      Layer = PCB->Data->Layer + i;
+
+      if (strcasecmp (Layer->Name, "outline") == 0 ||
+          strcasecmp (Layer->Name, "route") == 0)
+        {
+          found_outline = 1;
+          break;
+        }
+    }
+
+  if (!found_outline) {
+    printf ("Didn't find outline\n");
+    return whole_world;
+  }
+
+  /* Do stuff to turn the outline layer into a polygon */
+
+  /* Ideally, we just want to look at centre-lines, but that is hard!
+   *
+   * Lets add all lines, arcs etc.. together to form a polygon comprising
+   * the bits we presume a router would remove.
+   *
+   * Then we need to subtract that from some notional "infinite" plane
+   * polygon, leaving the remaining pieces.
+   *
+   * OR.. we could just look at the holes in the resulting polygon?
+   *
+   * Given these holes, we need to know which are inside and outside.
+   *   _____________
+   *  / ___________ \
+   *  ||           ||
+   *  ||   //=\\   ||
+   *  ||   || ||   ||
+   *  ||   \\=//   ||
+   *  ||___________||
+   *  \_____________/
+   */
+
+  info.poly = whole_world;
+
+  region.X1 = 0;
+  region.Y1 = 0;
+  region.X2 = PCB->MaxWidth;
+  region.Y2 = PCB->MaxHeight;
+
+  r_search (Layer->line_tree, &region, NULL, line_outline_callback, &info);
+  r_search (Layer->arc_tree,  &region, NULL, arc_outline_callback, &info);
+
+  clipped = info.poly;
+
+  /* Now we just need to work out which pieces of polygon are inside
+     and outside the board! */
+
+  /* If there is only one piece, return that */
+  if (clipped->f == clipped)
+    return clipped;
+
+  /* WARNING: This next check is O(n^2), where n is the number of clipped
+   *          pieces, hopefully the outline layer isn't too complex!
+   */
+
+  piece = clipped;
+  do { /* LOOP OVER POLYGON PIECES */
+
+    if (piece->contours == NULL)
+      printf ("WTF?\n");
+
+    count = 0;
+    check = clipped;
+    do { /* LOOP OVER POLYGON PIECES */
+      if (check == piece)
+        continue;
+      if (poly_ContourInContour (check->contours, piece->contours))
+        count ++;
+    } while ((check = check->f) != clipped);
+
+    /* If the piece is inside an odd number of others, delete it */
+    if ((count & 1) == 0)
+      pieces_to_delete = g_list_prepend (pieces_to_delete, piece);
+
+  } while ((piece = piece->f) != clipped);
+
+  g_list_foreach (pieces_to_delete, delete_piece_cb, &clipped);
+
+  return clipped;
+}
diff --git a/src/polygon.h b/src/polygon.h
index 2faaa20..ccf3164 100644
--- a/src/polygon.h
+++ b/src/polygon.h
@@ -66,4 +66,5 @@ Boolean isects (POLYAREA *, PolygonTypePtr, Boolean);
 Boolean MorphPolygon (LayerTypePtr, PolygonTypePtr);
 void NoHolesPolygonDicer (PolygonType *p, const BoxType *clip,
                           void (*emit) (PLINE *, void *), void *user_data);
+POLYAREA *board_outline_poly ();
 #endif

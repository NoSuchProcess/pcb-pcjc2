Bottom: 525b93b0344c2d8e23e3fbfc94f1cbe708bea4ff
Top:    aad7e962472bd029da0e10d809188190b92ffef5
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-11-15 23:20:39 +0000

Speed up^M^M^M^M^M^M^M^M Slow down NoHolesPolygonDicer

Avoid using poly_AndSubtract_free(), since it uses PBO_ISECT which
is relatively slow. Instead, make two copies of the input polygon,
then subtract from them with a PBO_SUB operation.

GAH.. The overheads of all the extra copying seem to be swamping
the supposed benefits!


---

diff --git a/src/polygon.c b/src/polygon.c
index adf6995..f67e7a0 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -1633,12 +1633,20 @@ r_NoHolesPolygonDicer (POLYAREA * pa,
     }
   else
     {
-      POLYAREA *poly2, *left, *right;
+      POLYAREA *pa_copy, *left_rect, *right_rect, *left, *right;
+
+      /* copy the main poly only */
+      poly_Copy0 (&pa_copy, pa);
 
       /* make a rectangle of the left region slicing through the middle of the first hole */
-      poly2 = RectPoly (p->xmin, (p->next->xmin + p->next->xmax) / 2,
-                        p->ymin, p->ymax);
-      poly_AndSubtract_free (pa, poly2, &left, &right);
+      left_rect = RectPoly (p->xmin - 1, (p->next->xmin + p->next->xmax) / 2, p->ymin - 1, p->ymax + 1);
+      /* make a rectangle of the right region slicing through the middle of the first hole */
+      right_rect = RectPoly ((p->next->xmin + p->next->xmax) / 2 - 1, p->xmax, p->ymin - 1, p->ymax + 1);
+
+      /* NB: Subtraction is faster than intersection */
+      poly_Boolean_free (pa, right_rect, &left, PBO_SUB);
+      poly_Boolean_free (pa_copy, left_rect, &right, PBO_SUB);
+
       if (left)
         {
           POLYAREA *cur, *next;

Bottom: e6a6c4c2230977849f7d872947b773d96760e665
Top:    f09bb91f8bb37f4482290409046ae3004446006d
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-05-10 18:14:08 +0100

Add support for a "poured" object.

This takes half of the existing polygon functionality, and splits it
such that the user defines a poured region (similar to drawing a polygon
previously), and after clipping, this produces zero or more polygon
objects which are drawn and connectivity checked with the existing
polygon code.

Selecting a "polygon" will cause the parent "pour" to be looked up, and
all child polygons selected. Manipulations will always occur on the
"pour", with "polygons" being updated after clipping.

It remains to be seen whether "pour" will have its own file-format entry,
or if it will take over the meaning of the existing "polygon" entry.


---

diff --git a/globalconst.h b/globalconst.h
index cd6f4f9..4ab3813 100755
--- a/globalconst.h
+++ b/globalconst.h
@@ -118,6 +118,8 @@
 						/* line points */
 #define	MAX_POLYGON_POINT_DISTANCE	0	/* maximum distance when searching */
 						/* polygon points */
+#define	MAX_POUR_POINT_DISTANCE	0	/* maximum distance when searching */
+						/* pour points */
 #define	MAX_ELEMENTNAMES		3	/* number of supported names of */
 						/* an element */
 #define	MAX_LIBRARY_LINE_LENGTH		255	/* maximum line length in the */
diff --git a/po/POTFILES.in b/po/POTFILES.in
index b0e6f31..24b21f2 100644
--- a/po/POTFILES.in
+++ b/po/POTFILES.in
@@ -36,6 +36,7 @@ src/move.c
 src/netlist.c
 src/parse_y.c
 src/polygon.c
+src/pour.c
 src/rats.c
 src/report.c
 src/res_parse.c
diff --git a/src/Makefile.am b/src/Makefile.am
index b709c27..452e325 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -121,6 +121,8 @@ PCB_SRCS = \
 	polygon.h \
 	polygon1.c \
 	polyarea.h \
+	pour.c \
+	pour.h \
 	puller.c \
 	print.c \
 	print.h \
diff --git a/src/action.c b/src/action.c
index 6bbee09..87d5665 100644
--- a/src/action.c
+++ b/src/action.c
@@ -57,6 +57,7 @@
 #include "misc.h"
 #include "move.h"
 #include "polygon.h"
+#include "pour.h"
 /*#include "print.h"*/
 #include "rats.h"
 #include "remove.h"
@@ -144,7 +145,7 @@ typedef enum
   F_PinByName,
   F_PinOrPadName,
   F_Pinout,
-  F_Polygon,
+  F_Pour,
   F_PreviousPoint,
   F_RatsNest,
   F_Rectangle,
@@ -296,7 +297,7 @@ static PointType InsertedPoint;
 static LayerTypePtr lastLayer;
 static struct
 {
-  PolygonTypePtr poly;
+  PourTypePtr pour;
   LineType line;
 }
 fake;
@@ -379,7 +380,7 @@ static FunctionType Functions[] = {
   {"PinByName", F_PinByName},
   {"PinOrPadName", F_PinOrPadName},
   {"Pinout", F_Pinout},
-  {"Polygon", F_Polygon},
+  {"Pour", F_Pour},
   {"PreviousPoint", F_PreviousPoint},
   {"RatsNest", F_RatsNest},
   {"Rectangle", F_Rectangle},
@@ -841,8 +842,8 @@ AdjustAttachedObjects (void)
       AdjustAttachedBox ();
       break;
 
-      /* polygon creation mode */
-    case POLYGON_MODE:
+      /* pour creation mode */
+    case POUR_MODE:
       AdjustAttachedLine ();
       break;
       /* line creation mode */
@@ -1351,12 +1352,12 @@ NotifyMode (void)
 	  Crosshair.AttachedBox.Point1.X != Crosshair.AttachedBox.Point2.X &&
 	  Crosshair.AttachedBox.Point1.Y != Crosshair.AttachedBox.Point2.Y)
 	{
-	  PolygonTypePtr polygon;
+	  PourTypePtr pour;
 
 	  int flags = CLEARPOLYFLAG;
 	  if (TEST_FLAG (NEWFULLPOLYFLAG, PCB))
 	    flags |= FULLPOLYFLAG;
-	  if ((polygon = CreateNewPolygonFromRectangle (CURRENT,
+	  if ((pour = CreateNewPourFromRectangle (CURRENT,
 							Crosshair.
 							AttachedBox.Point1.X,
 							Crosshair.
@@ -1369,10 +1370,10 @@ NotifyMode (void)
 							(flags))) !=
 	      NULL)
 	    {
-	      AddObjectToCreateUndoList (POLYGON_TYPE, CURRENT,
-					 polygon, polygon);
+	      AddObjectToCreateUndoList (POUR_TYPE, CURRENT,
+					 pour, pour);
 	      IncrementUndoSerialNumber ();
-	      DrawPolygon (CURRENT, polygon, 0);
+	      DrawPour (CURRENT, pour, 0);
 	      Draw ();
 	    }
 
@@ -1412,10 +1413,10 @@ NotifyMode (void)
 	break;
       }
 
-    case POLYGON_MODE:
+    case POUR_MODE:
       {
-	PointTypePtr points = Crosshair.AttachedPolygon.Points;
-	Cardinal n = Crosshair.AttachedPolygon.PointN;
+	PointTypePtr points = Crosshair.AttachedPour.Points;
+	Cardinal n = Crosshair.AttachedPour.PointN;
 
 	/* do update of position; use the 'LINE_MODE' mechanism */
 	NotifyLine ();
@@ -1425,7 +1426,7 @@ NotifyMode (void)
 	    points->X == Crosshair.AttachedLine.Point2.X &&
 	    points->Y == Crosshair.AttachedLine.Point2.Y)
 	  {
-	    CopyAttachedPolygonToLayer ();
+	    CopyAttachedPourToLayer ();
 	    Draw ();
 	    break;
 	  }
@@ -1437,9 +1438,9 @@ NotifyMode (void)
 	    points[n - 1].X != Crosshair.AttachedLine.Point2.X ||
 	    points[n - 1].Y != Crosshair.AttachedLine.Point2.Y)
 	  {
-	    CreateNewPointInPolygon (&Crosshair.AttachedPolygon,
-				     Crosshair.AttachedLine.Point2.X,
-				     Crosshair.AttachedLine.Point2.Y);
+	    CreateNewPointInPour (&Crosshair.AttachedPour,
+				  Crosshair.AttachedLine.Point2.X,
+				  Crosshair.AttachedLine.Point2.Y);
 
 	    /* copy the coordinates */
 	    Crosshair.AttachedLine.Point1.X = Crosshair.AttachedLine.Point2.X;
@@ -1633,17 +1634,15 @@ NotifyMode (void)
 	      else
 		{
 		  /* get starting point of nearest segment */
-		  if (Crosshair.AttachedObject.Type == POLYGON_TYPE)
+		  if (Crosshair.AttachedObject.Type == POUR_TYPE)
 		    {
-		      fake.poly =
-			(PolygonTypePtr) Crosshair.AttachedObject.Ptr2;
+		      fake.pour = (PourTypePtr) Crosshair.AttachedObject.Ptr2;
 		      polyIndex =
-			GetLowestDistancePolygonPoint (fake.poly, Note.X,
-						       Note.Y);
-		      fake.line.Point1 = fake.poly->Points[polyIndex];
+			GetLowestDistancePourPoint (fake.pour, Note.X, Note.Y);
+		      fake.line.Point1 = fake.pour->Points[polyIndex];
 		      fake.line.Point2 = (polyIndex) ?
-			fake.poly->Points[polyIndex - 1]
-			: fake.poly->Points[fake.poly->PointN - 1];
+			fake.pour->Points[polyIndex - 1]
+			: fake.pour->Points[fake.pour->PointN - 1];
 		      Crosshair.AttachedObject.Ptr2 = &fake.line;
 
 		    }
@@ -1655,9 +1654,9 @@ NotifyMode (void)
 
 	  /* second notify, insert new point into object */
 	case STATE_SECOND:
-	  if (Crosshair.AttachedObject.Type == POLYGON_TYPE)
-	    InsertPointIntoObject (POLYGON_TYPE,
-				   Crosshair.AttachedObject.Ptr1, fake.poly,
+	  if (Crosshair.AttachedObject.Type == POUR_TYPE)
+	    InsertPointIntoObject (POUR_TYPE,
+				   Crosshair.AttachedObject.Ptr1, fake.pour,
 				   &polyIndex,
 				   InsertedPoint.X, InsertedPoint.Y, False);
 	  else
@@ -3013,13 +3012,13 @@ ActionMode (int argc, char **argv, int x, int y)
 		  }
 		break;
 	  
-	      case POLYGON_MODE:
+	      case POUR_MODE:
 		if (Crosshair.AttachedLine.State == STATE_FIRST)
 		  SetMode (ARROW_MODE);
 		else
 		  {
 		    SetMode (NO_MODE);
-		    SetMode (POLYGON_MODE);
+		    SetMode (POUR_MODE);
 		  }
 		break;
 
@@ -3048,8 +3047,8 @@ ActionMode (int argc, char **argv, int x, int y)
 	case F_PasteBuffer:
 	  SetMode (PASTEBUFFER_MODE);
 	  break;
-	case F_Polygon:
-	  SetMode (POLYGON_MODE);
+	case F_Pour:
+	  SetMode (POUR_MODE);
 	  break;
 #ifndef HAVE_LIBSTROKE
 	case F_Release:
@@ -3093,9 +3092,9 @@ ActionMode (int argc, char **argv, int x, int y)
 	  else if (Settings.Mode == RECTANGLE_MODE
 		   && Crosshair.AttachedBox.State != STATE_FIRST)
 	    SetMode (RECTANGLE_MODE);
-	  else if (Settings.Mode == POLYGON_MODE
+	  else if (Settings.Mode == POUR_MODE
 		   && Crosshair.AttachedLine.State != STATE_FIRST)
-	    SetMode (POLYGON_MODE);
+	    SetMode (POUR_MODE);
 	  else
 	    {
 	      SaveMode ();
@@ -4578,6 +4577,9 @@ off are automatically deleted.
 static int
 ActionMorphPolygon (int argc, char **argv, int x, int y)
 {
+#warning FIXME Later
+  Message ("Morph polygon not implemented. Pours are nice though!\n");
+#if 0
   char *function = ARG (0);
   if (function)
     {
@@ -4613,6 +4615,7 @@ ActionMorphPolygon (int argc, char **argv, int x, int y)
 	}
     }
   return 0;
+#endif
 }
 
 /* --------------------------------------------------------------------------- */
@@ -6107,9 +6110,9 @@ ActionUndo (int argc, char **argv, int x, int y)
       /* undo the last operation */
 
       HideCrosshair (True);
-      if (Settings.Mode == POLYGON_MODE && Crosshair.AttachedPolygon.PointN)
+      if (Settings.Mode == POUR_MODE && Crosshair.AttachedPour.PointN)
 	{
-	  GoToPreviousPoint ();
+	  GoToPreviousPourPoint ();
 	  RestoreCrosshair (True);
 	  return 0;
 	}
@@ -6269,8 +6272,8 @@ three "undone" lines.
 static int
 ActionRedo (int argc, char **argv, int x, int y)
 {
-  if ((Settings.Mode == POLYGON_MODE &&
-       Crosshair.AttachedPolygon.PointN) ||
+  if ((Settings.Mode == POUR_MODE &&
+       Crosshair.AttachedPour.PointN) ||
       Crosshair.AttachedLine.State == STATE_SECOND)
     return 1;
   HideCrosshair (True);
@@ -6320,19 +6323,19 @@ static int
 ActionPolygon (int argc, char **argv, int x, int y)
 {
   char *function = ARG (0);
-  if (function && Settings.Mode == POLYGON_MODE)
+  if (function && Settings.Mode == POUR_MODE)
     {
       HideCrosshair (True);
       switch (GetFunctionID (function))
 	{
-	  /* close open polygon if possible */
+	  /* close open pour if possible */
 	case F_Close:
-	  ClosePolygon ();
+	  ClosePour ();
 	  break;
 
 	  /* go back to the previous point */
 	case F_PreviousPoint:
-	  GoToPreviousPoint ();
+	  GoToPreviousPourPoint ();
 	  break;
 	}
       RestoreCrosshair (True);
diff --git a/src/action.h b/src/action.h
index 8ce4a15..bd09d18 100644
--- a/src/action.h
+++ b/src/action.h
@@ -33,7 +33,7 @@
 
 #include "global.h"
 
-#define CLONE_TYPES LINE_TYPE | ARC_TYPE | VIA_TYPE | POLYGON_TYPE
+#define CLONE_TYPES LINE_TYPE | ARC_TYPE | VIA_TYPE | POUR_TYPE
 
 void ActionMovePointer (char *, char *);
 void ActionAdjustStyle (char *);
diff --git a/src/autoroute.c b/src/autoroute.c
index b9f1fdd..6d1ec8d 100644
--- a/src/autoroute.c
+++ b/src/autoroute.c
@@ -74,6 +74,7 @@
 #include "misc.h"
 #include "mtspace.h"
 #include "mymem.h"
+#include "pour.h"
 #include "polygon.h"
 #include "rats.h"
 #include "remove.h"
@@ -767,6 +768,8 @@ AddPolygon (PointerListType layergroupboxes[], Cardinal layer,
 			     polygon->BoundingBox.X2,
 			     polygon->BoundingBox.Y2,
 			     layergroup, polygon, style);
+#warning FIXME LATER
+#if 0
   if (polygon->PointN == 4 &&
       (polygon->Points[0].X == polygon->Points[1].X ||
        polygon->Points[0].Y == polygon->Points[1].Y) &&
@@ -777,6 +780,7 @@ AddPolygon (PointerListType layergroupboxes[], Cardinal layer,
       (polygon->Points[3].X == polygon->Points[0].X ||
        polygon->Points[3].Y == polygon->Points[0].Y))
     is_not_rectangle = 0;
+#endif
   rb->flags.nonstraight = is_not_rectangle;
   rb->layer = layer;
   rb->came_from = ALL;
@@ -1182,12 +1186,16 @@ CreateRouteData ()
       }
       END_LOOP;
       /* add all polygons */
-      POLYGON_LOOP (LAYER_PTR (i));
+      POUR_LOOP (LAYER_PTR (i));
       {
-	if (TEST_FLAG (DRCFLAG, polygon))
-	  CLEAR_FLAG (DRCFLAG, polygon);
-	else
-	  AddPolygon (layergroupboxes, i, polygon, rd->styles[NUM_STYLES]);
+        POURPOLYGON_LOOP (pour);
+        {
+          if (TEST_FLAG (DRCFLAG, polygon))
+            CLEAR_FLAG (DRCFLAG, polygon);
+          else
+            AddPolygon (layergroupboxes, i, polygon, rd->styles[NUM_STYLES]);
+        }
+        END_LOOP;
       }
       END_LOOP;
       /* add all copper text */
@@ -5055,20 +5063,18 @@ IronDownAllUnfixedPaths (routedata_t * rd)
 	  int type = FindPin (&p->box, &pin);
 	  if (pin)
 	    {
-	      AddObjectToClearPolyUndoList (type,
+	      AddObjectToClearPourUndoList (type,
 					    pin->Element ? pin->Element : pin,
 					    pin, pin, False);
-	      RestoreToPolygon (PCB->Data, VIA_TYPE, LAYER_PTR (p->layer),
-				pin);
+	      RestoreToPours (PCB->Data, VIA_TYPE, LAYER_PTR (p->layer), pin);
 	      AddObjectToFlagUndoList (type,
 				       pin->Element ? pin->Element : pin, pin,
 				       pin);
 	      ASSIGN_THERM (p->layer, PCB->ThermStyle, pin);
-	      AddObjectToClearPolyUndoList (type,
+	      AddObjectToClearPourUndoList (type,
 					    pin->Element ? pin->Element : pin,
 					    pin, pin, True);
-	      ClearFromPolygon (PCB->Data, VIA_TYPE, LAYER_PTR (p->layer),
-				pin);
+	      ClearFromPours (PCB->Data, VIA_TYPE, LAYER_PTR (p->layer), pin);
 	      changed = True;
 	    }
 	}
diff --git a/src/buffer.c b/src/buffer.c
index fbd1735..dd269bc 100644
--- a/src/buffer.c
+++ b/src/buffer.c
@@ -50,6 +50,7 @@
 #include "misc.h"
 #include "parse_l.h"
 #include "polygon.h"
+#include "pour.h"
 #include "rats.h"
 #include "rotate.h"
 #include "remove.h"
@@ -72,14 +73,14 @@ static void *AddLineToBuffer (LayerTypePtr, LineTypePtr);
 static void *AddArcToBuffer (LayerTypePtr, ArcTypePtr);
 static void *AddRatToBuffer (RatTypePtr);
 static void *AddTextToBuffer (LayerTypePtr, TextTypePtr);
-static void *AddPolygonToBuffer (LayerTypePtr, PolygonTypePtr);
+static void *AddPourToBuffer (LayerTypePtr, PourTypePtr);
 static void *AddElementToBuffer (ElementTypePtr);
 static void *MoveViaToBuffer (PinTypePtr);
 static void *MoveLineToBuffer (LayerTypePtr, LineTypePtr);
 static void *MoveArcToBuffer (LayerTypePtr, ArcTypePtr);
 static void *MoveRatToBuffer (RatTypePtr);
 static void *MoveTextToBuffer (LayerTypePtr, TextTypePtr);
-static void *MovePolygonToBuffer (LayerTypePtr, PolygonTypePtr);
+static void *MovePourToBuffer (LayerTypePtr, PourTypePtr);
 static void *MoveElementToBuffer (ElementTypePtr);
 static void SwapBuffer (BufferTypePtr);
 
@@ -93,7 +94,8 @@ static DataTypePtr Dest, Source;
 static ObjectFunctionType AddBufferFunctions = {
   AddLineToBuffer,
   AddTextToBuffer,
-  AddPolygonToBuffer,
+  NULL,
+  AddPourToBuffer,
   AddViaToBuffer,
   AddElementToBuffer,
   NULL,
@@ -108,10 +110,17 @@ static ObjectFunctionType AddBufferFunctions = {
 {
 MoveLineToBuffer,
     MoveTextToBuffer,
-    MovePolygonToBuffer,
+    NULL,
+    MovePourToBuffer,
     MoveViaToBuffer,
     MoveElementToBuffer,
-    NULL, NULL, NULL, NULL, NULL, MoveArcToBuffer, MoveRatToBuffer};
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    MoveArcToBuffer,
+    MoveRatToBuffer};
 
 static int ExtraFlag = 0;
 
@@ -186,18 +195,18 @@ AddTextToBuffer (LayerTypePtr Layer, TextTypePtr Text)
 }
 
 /* ---------------------------------------------------------------------------
- * copies a polygon to buffer
+ * copies a pour to buffer
  */
 static void *
-AddPolygonToBuffer (LayerTypePtr Layer, PolygonTypePtr Polygon)
+AddPourToBuffer (LayerTypePtr Layer, PourTypePtr Pour)
 {
   LayerTypePtr layer = &Dest->Layer[GetLayerNumber (Source, Layer)];
-  PolygonTypePtr polygon;
+  PourTypePtr pour;
 
-  polygon = GetPolygonMemory (layer);
-  CopyPolygonLowLevel (polygon, Polygon);
-  CLEAR_FLAG (FOUNDFLAG | ExtraFlag, polygon);
-  return (polygon);
+  pour = GetPourMemory (layer);
+  CopyPourLowLevel (pour, Pour);
+  CLEAR_FLAG (FOUNDFLAG | ExtraFlag, pour);
+  return (pour);
 }
 
 /* ---------------------------------------------------------------------------
@@ -240,7 +249,7 @@ MoveViaToBuffer (PinTypePtr Via)
 {
   PinTypePtr via;
 
-  RestoreToPolygon (Source, VIA_TYPE, Via, Via);
+  RestoreToPours (Source, VIA_TYPE, Via, Via);
   r_delete_entry (Source->via_tree, (BoxType *) Via);
   via = GetViaMemory (Dest);
   *via = *Via;
@@ -255,7 +264,7 @@ MoveViaToBuffer (PinTypePtr Via)
   if (!Dest->via_tree)
     Dest->via_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (Dest->via_tree, (BoxType *) via, 0);
-  ClearFromPolygon (Dest, VIA_TYPE, via, via);
+  ClearFromPours (Dest, VIA_TYPE, via, via);
   return (via);
 }
 
@@ -293,7 +302,7 @@ MoveLineToBuffer (LayerTypePtr Layer, LineTypePtr Line)
   LayerTypePtr lay;
   LineTypePtr line;
 
-  RestoreToPolygon (Source, LINE_TYPE, Layer, Line);
+  RestoreToPours (Source, LINE_TYPE, Layer, Line);
   r_delete_entry (Layer->line_tree, (BoxTypePtr) Line);
   lay = &Dest->Layer[GetLayerNumber (Source, Layer)];
   line = GetLineMemory (lay);
@@ -310,7 +319,7 @@ MoveLineToBuffer (LayerTypePtr Layer, LineTypePtr Line)
   if (!lay->line_tree)
     lay->line_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (lay->line_tree, (BoxTypePtr) line, 0);
-  ClearFromPolygon (Dest, LINE_TYPE, lay, line);
+  ClearFromPours (Dest, LINE_TYPE, lay, line);
   return (line);
 }
 
@@ -323,7 +332,7 @@ MoveArcToBuffer (LayerTypePtr Layer, ArcTypePtr Arc)
   LayerTypePtr lay;
   ArcTypePtr arc;
 
-  RestoreToPolygon (Source, ARC_TYPE, Layer, Arc);
+  RestoreToPours (Source, ARC_TYPE, Layer, Arc);
   r_delete_entry (Layer->arc_tree, (BoxTypePtr) Arc);
   lay = &Dest->Layer[GetLayerNumber (Source, Layer)];
   arc = GetArcMemory (lay);
@@ -340,7 +349,7 @@ MoveArcToBuffer (LayerTypePtr Layer, ArcTypePtr Arc)
   if (!lay->arc_tree)
     lay->arc_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (lay->arc_tree, (BoxTypePtr) arc, 0);
-  ClearFromPolygon (Dest, ARC_TYPE, lay, arc);
+  ClearFromPours (Dest, ARC_TYPE, lay, arc);
   return (arc);
 }
 
@@ -354,7 +363,7 @@ MoveTextToBuffer (LayerTypePtr Layer, TextTypePtr Text)
   LayerTypePtr lay;
 
   r_delete_entry (Layer->text_tree, (BoxTypePtr) Text);
-  RestoreToPolygon (Source, TEXT_TYPE, Layer, Text);
+  RestoreToPours (Source, TEXT_TYPE, Layer, Text);
   lay = &Dest->Layer[GetLayerNumber (Source, Layer)];
   text = GetTextMemory (lay);
   *text = *Text;
@@ -368,36 +377,36 @@ MoveTextToBuffer (LayerTypePtr Layer, TextTypePtr Text)
   if (!lay->text_tree)
     lay->text_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (lay->text_tree, (BoxTypePtr) text, 0);
-  ClearFromPolygon (Dest, TEXT_TYPE, lay, text);
+  ClearFromPours (Dest, TEXT_TYPE, lay, text);
   return (text);
 }
 
 /* ---------------------------------------------------------------------------
- * moves a polygon to buffer. Doesn't allocate memory for the points
+ * moves a pour to buffer. Doesn't allocate memory for the points
  */
 static void *
-MovePolygonToBuffer (LayerTypePtr Layer, PolygonTypePtr Polygon)
+MovePourToBuffer (LayerTypePtr Layer, PourTypePtr Pour)
 {
   LayerTypePtr lay;
-  PolygonTypePtr polygon;
+  PourTypePtr pour;
 
-  r_delete_entry (Layer->polygon_tree, (BoxTypePtr) Polygon);
+  r_delete_entry (Layer->pour_tree, (BoxTypePtr) Pour);
   lay = &Dest->Layer[GetLayerNumber (Source, Layer)];
-  polygon = GetPolygonMemory (lay);
-  *polygon = *Polygon;
-  CLEAR_FLAG (FOUNDFLAG, polygon);
-  if (Polygon != &Layer->Polygon[--Layer->PolygonN])
+  pour = GetPourMemory (lay);
+  *pour = *Pour;
+  CLEAR_FLAG (FOUNDFLAG, pour);
+  if (Pour != &Layer->Pour[--Layer->PourN])
   {
-  *Polygon = Layer->Polygon[Layer->PolygonN];
-  r_substitute (Layer->polygon_tree,
-		(BoxTypePtr) & Layer->Polygon[Layer->PolygonN],
-		(BoxTypePtr) Polygon);
+  *Pour = Layer->Pour[Layer->PourN];
+  r_substitute (Layer->pour_tree,
+		(BoxTypePtr) & Layer->Pour[Layer->PourN],
+		(BoxTypePtr) Pour);
   }
-  memset (&Layer->Polygon[Layer->PolygonN], 0, sizeof (PolygonType));
-  if (!lay->polygon_tree)
-    lay->polygon_tree = r_create_tree (NULL, 0, 0);
-  r_insert_entry (lay->polygon_tree, (BoxTypePtr) polygon, 0);
-  return (polygon);
+  memset (&Layer->Pour[Layer->PourN], 0, sizeof (PourType));
+  if (!lay->pour_tree)
+    lay->pour_tree = r_create_tree (NULL, 0, 0);
+  r_insert_entry (lay->pour_tree, (BoxTypePtr) pour, 0);
+  return (pour);
 }
 
 /* ---------------------------------------------------------------------------
@@ -419,14 +428,14 @@ MoveElementToBuffer (ElementTypePtr Element)
   *element = *Element;
   PIN_LOOP (element);
   {
-    RestoreToPolygon(Source, PIN_TYPE, Element, pin);
+    RestoreToPours(Source, PIN_TYPE, Element, pin);
     CLEAR_FLAG (WARNFLAG | FOUNDFLAG, pin);
     pin->Element = element;
   }
   END_LOOP;
   PAD_LOOP (element);
   {
-    RestoreToPolygon(Source, PAD_TYPE, Element, pad);
+    RestoreToPours(Source, PAD_TYPE, Element, pad);
     CLEAR_FLAG (WARNFLAG | FOUNDFLAG, pad);
     pad->Element = element;
   }
@@ -442,12 +451,12 @@ MoveElementToBuffer (ElementTypePtr Element)
    */
   PIN_LOOP (element);
   {
-    ClearFromPolygon (Dest, PIN_TYPE, element, pin);
+    ClearFromPours (Dest, PIN_TYPE, element, pin);
   }
   END_LOOP;
   PAD_LOOP (element);
   {
-    ClearFromPolygon (Dest, PAD_TYPE, element, pad);
+    ClearFromPours (Dest, PAD_TYPE, element, pad);
   }
   END_LOOP;
 
@@ -991,6 +1000,8 @@ SmashBufferElement (BufferTypePtr Buffer)
   return (True);
 }
 
+#warning FIXME Later
+#if 0
 /*---------------------------------------------------------------------------
  *
  * see if a polygon is a rectangle.  If so, canonicalize it.
@@ -1027,6 +1038,7 @@ polygon_is_rectangle (PolygonTypePtr poly)
     return 1;
   return 0;
 }
+#endif
 
 /*---------------------------------------------------------------------------
  *
@@ -1093,34 +1105,40 @@ ConvertBufferToElement (BufferTypePtr Buffer)
       hasParts = True;
     }
     END_LOOP;
-    POLYGON_LOOP (layer);
+#warning FIXME Later
+#if 0
+    POUR_LOOP (layer);
     {
-      int x1, y1, x2, y2, w, h, t;
-
-      if (! polygon_is_rectangle (polygon))
-        {
-          crooked = True;
-	  continue;
-        }
-
-      w = polygon->Points[2].X - polygon->Points[0].X;
-      h = polygon->Points[1].Y - polygon->Points[0].Y;
-      t = (w < h) ? w : h;
-      x1 = polygon->Points[0].X + t/2;
-      y1 = polygon->Points[0].Y + t/2;
-      x2 = x1 + (w-t);
-      y2 = y1 + (h-t);
-
-      sprintf (num, "%d", pin_n++);
-      CreateNewPad (Element,
-		    x1, y1, x2, y2, t,
-		    2 * Settings.Keepaway,
-		    t + Settings.Keepaway,
-		    NULL, num,
-		    MakeFlags (SQUAREFLAG | (SWAP_IDENT ? ONSOLDERFLAG : NOFLAG)));
-      hasParts = True;
+      POURPOLYGON_LOOP (pour);
+      {
+        int x1, y1, x2, y2, w, h, t;
+
+        if (! polygon_is_rectangle (polygon))
+          {
+            crooked = True;
+            continue;
+          }
+
+        w = polygon->Points[2].X - polygon->Points[0].X;
+        h = polygon->Points[1].Y - polygon->Points[0].Y;
+        t = (w < h) ? w : h;
+        x1 = polygon->Points[0].X + t/2;
+        y1 = polygon->Points[0].Y + t/2;
+        x2 = x1 + (w-t);
+        y2 = y1 + (h-t);
+
+        sprintf (num, "%d", pin_n++);
+        CreateNewPad (Element, x1, y1, x2, y2, t,
+                      2 * Settings.Keepaway,
+                      t + Settings.Keepaway,
+                      NULL, num,
+                      MakeFlags (SQUAREFLAG | (SWAP_IDENT ? ONSOLDERFLAG : NOFLAG)));
+        hasParts = True;
+      }
+      END_LOOP;
     }
     END_LOOP;
+#endif
   }
   END_LOOP;
   /* now get the opposite side pads */
@@ -1273,6 +1291,8 @@ RotateBuffer (BufferTypePtr Buffer, BYTE Number)
     r_insert_entry (layer->text_tree, (BoxTypePtr) text, 0);
   }
   ENDALL_LOOP;
+#warning FIXME Later
+#if 0
   ALLPOLYGON_LOOP (Buffer->Data);
   {
     r_delete_entry (layer->polygon_tree, (BoxTypePtr) polygon);
@@ -1280,6 +1300,14 @@ RotateBuffer (BufferTypePtr Buffer, BYTE Number)
     r_insert_entry (layer->polygon_tree, (BoxTypePtr) polygon, 0);
   }
   ENDALL_LOOP;
+#endif
+  ALLPOUR_LOOP (Buffer->Data);
+  {
+    r_delete_entry (layer->pour_tree, (BoxTypePtr) pour);
+    RotatePourLowLevel (pour, Buffer->X, Buffer->Y, Number);
+    r_insert_entry (layer->pour_tree, (BoxTypePtr) pour, 0);
+  }
+  ENDALL_LOOP;
 
   /* finally the origin and the bounding box */
   ROTATE (Buffer->X, Buffer->Y, Buffer->X, Buffer->Y, Number);
@@ -1331,7 +1359,7 @@ FreeRotateElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
     /* pre-delete the pins from the pin-tree before their coordinates change */
     if (Data)
       r_delete_entry (Data->pin_tree, (BoxType *) pin);
-    RestoreToPolygon (Data, PIN_TYPE, Element, pin);
+    RestoreToPours (Data, PIN_TYPE, Element, pin);
     free_rotate (&pin->X, &pin->Y, X, Y, cosa, sina);
     SetPinBoundingBox (pin);
   }
@@ -1341,7 +1369,7 @@ FreeRotateElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
     /* pre-delete the pads before their coordinates change */
     if (Data)
       r_delete_entry (Data->pad_tree, (BoxType *) pad);
-    RestoreToPolygon (Data, PAD_TYPE, Element, pad);
+    RestoreToPours (Data, PAD_TYPE, Element, pad);
     free_rotate (&pad->Point1.X, &pad->Point1.Y, X, Y, cosa, sina);
     free_rotate (&pad->Point2.X, &pad->Point2.Y, X, Y, cosa, sina);
     SetLineBoundingBox ((LineType *) pad);
@@ -1357,7 +1385,7 @@ FreeRotateElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
 
   free_rotate (&Element->MarkX, &Element->MarkY, X, Y, cosa, sina);
   SetElementBoundingBox (Data, Element, &PCB->Font);
-  ClearFromPolygon (Data, ELEMENT_TYPE, Element, Element);
+  ClearFromPours (Data, ELEMENT_TYPE, Element, Element);
 }
 
 void
@@ -1406,6 +1434,8 @@ FreeRotateBuffer (BufferTypePtr Buffer, double Angle)
   }
   ENDALL_LOOP;
   /* FIXME: rotate text */
+#warning FIXME Later
+#if 0
   ALLPOLYGON_LOOP (Buffer->Data);
   {
     r_delete_entry (layer->polygon_tree, (BoxTypePtr) polygon);
@@ -1418,6 +1448,19 @@ FreeRotateBuffer (BufferTypePtr Buffer, double Angle)
     r_insert_entry (layer->polygon_tree, (BoxTypePtr) polygon, 0);
   }
   ENDALL_LOOP;
+#endif
+  ALLPOUR_LOOP (Buffer->Data);
+  {
+    r_delete_entry (layer->pour_tree, (BoxTypePtr) pour);
+    POURPOINT_LOOP (pour);
+    {
+      free_rotate (&point->X, &point->Y, Buffer->X, Buffer->Y, cosa, sina);
+    }
+    END_LOOP;
+    SetPourBoundingBox (pour);
+    r_insert_entry (layer->pour_tree, (BoxTypePtr) pour, 0);
+  }
+  ENDALL_LOOP;
 
   SetBufferBoundingBox (Buffer);
 }
@@ -1513,6 +1556,8 @@ MirrorBuffer (BufferTypePtr Buffer)
     SetArcBoundingBox (arc);
   }
   ENDALL_LOOP;
+#warning FIXME Later
+#if 0
   ALLPOLYGON_LOOP (Buffer->Data);
   {
     POLYGONPOINT_LOOP (polygon);
@@ -1524,6 +1569,7 @@ MirrorBuffer (BufferTypePtr Buffer)
     SetPolygonBoundingBox (polygon);
   }
   ENDALL_LOOP;
+#endif
   SetBufferBoundingBox (Buffer);
 }
 
@@ -1578,6 +1624,8 @@ SwapBuffer (BufferTypePtr Buffer)
     r_insert_entry (layer->arc_tree, (BoxTypePtr) arc, 0);
   }
   ENDALL_LOOP;
+#warning FIXME Later
+#if 0
   ALLPOLYGON_LOOP (Buffer->Data);
   {
     r_delete_entry (layer->polygon_tree, (BoxTypePtr) polygon);
@@ -1592,6 +1640,7 @@ SwapBuffer (BufferTypePtr Buffer)
     /* hmmm, how to handle clip */
   }
   ENDALL_LOOP;
+#endif
   ALLTEXT_LOOP (Buffer->Data);
   {
     r_delete_entry (layer->text_tree, (BoxTypePtr) text);
diff --git a/src/change.c b/src/change.c
index fe159f4..1149dec 100644
--- a/src/change.c
+++ b/src/change.c
@@ -50,6 +50,7 @@
 #include "misc.h"
 #include "mirror.h"
 #include "polygon.h"
+#include "pour.h"
 #include "rats.h"
 #include "remove.h"
 #include "rtree.h"
@@ -83,6 +84,7 @@ static void *ChangeViaMaskSize (PinTypePtr);
 static void *ChangeLineSize (LayerTypePtr, LineTypePtr);
 static void *ChangeLineClearSize (LayerTypePtr, LineTypePtr);
 static void *ChangePolygonClearSize (LayerTypePtr, PolygonTypePtr);
+static void *ChangePourClearSize (LayerTypePtr, PourTypePtr);
 static void *ChangeArcSize (LayerTypePtr, ArcTypePtr);
 static void *ChangeArcClearSize (LayerTypePtr, ArcTypePtr);
 static void *ChangeTextSize (LayerTypePtr, TextTypePtr);
@@ -123,7 +125,7 @@ static void *ClrArcJoin (LayerTypePtr, ArcTypePtr);
 static void *ChangeTextJoin (LayerTypePtr, TextTypePtr);
 static void *SetTextJoin (LayerTypePtr, TextTypePtr);
 static void *ClrTextJoin (LayerTypePtr, TextTypePtr);
-static void *ChangePolyClear (LayerTypePtr, PolygonTypePtr);
+static void *ChangePourClear (LayerTypePtr, PourTypePtr);
 
 /* ---------------------------------------------------------------------------
  * some local identifiers
@@ -134,7 +136,8 @@ static char *NewName;		/* new name */
 static ObjectFunctionType ChangeSizeFunctions = {
   ChangeLineSize,
   ChangeTextSize,
-  ChangePolyClear,
+  NULL,
+  ChangePourClear,
   ChangeViaSize,
   ChangeElementSize,		/* changes silk screen line width */
   ChangeElementNameSize,
@@ -149,6 +152,7 @@ static ObjectFunctionType Change2ndSizeFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   ChangeVia2ndSize,
   ChangeElement2ndSize,
   NULL,
@@ -163,6 +167,7 @@ static ObjectFunctionType ChangeThermalFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   ChangeViaThermal,
   NULL,
   NULL,
@@ -177,6 +182,7 @@ static ObjectFunctionType ChangeClearSizeFunctions = {
   ChangeLineClearSize,
   NULL,
   ChangePolygonClearSize, /* just to tell the user not to :-) */
+  ChangePourClearSize, /* just to tell the user not to :-) */
   ChangeViaClearSize,
   NULL,
   NULL,
@@ -191,6 +197,7 @@ static ObjectFunctionType ChangeNameFunctions = {
   ChangeLineName,
   ChangeTextName,
   NULL,
+  NULL,
   ChangeViaName,
   ChangeElementName,
   NULL,
@@ -206,6 +213,7 @@ static ObjectFunctionType ChangeSquareFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   ChangeElementSquare,
   NULL,
   ChangePinSquare,
@@ -226,6 +234,7 @@ static ObjectFunctionType ChangeJoinFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   ChangeArcJoin,
   NULL
 };
@@ -233,6 +242,7 @@ static ObjectFunctionType ChangeOctagonFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   ChangeViaOctagon,
   ChangeElementOctagon,
   NULL,
@@ -247,6 +257,7 @@ static ObjectFunctionType ChangeMaskSizeFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   ChangeViaMaskSize,
 #if 0
   ChangeElementMaskSize,
@@ -266,6 +277,7 @@ static ObjectFunctionType SetSquareFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   SetElementSquare,
   NULL,
   SetPinSquare,
@@ -286,6 +298,7 @@ static ObjectFunctionType SetJoinFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   SetArcJoin,
   NULL
 };
@@ -293,6 +306,7 @@ static ObjectFunctionType SetOctagonFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   SetViaOctagon,
   SetElementOctagon,
   NULL,
@@ -308,6 +322,7 @@ static ObjectFunctionType ClrSquareFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   ClrElementSquare,
   NULL,
   ClrPinSquare,
@@ -328,6 +343,7 @@ static ObjectFunctionType ClrJoinFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   ClrArcJoin,
   NULL
 };
@@ -335,6 +351,7 @@ static ObjectFunctionType ClrOctagonFunctions = {
   NULL,
   NULL,
   NULL,
+  NULL,
   ClrViaOctagon,
   ClrElementOctagon,
   NULL,
@@ -353,15 +370,15 @@ static ObjectFunctionType ClrOctagonFunctions = {
 static void *
 ChangeViaThermal (PinTypePtr Via)
 {
-  AddObjectToClearPolyUndoList (VIA_TYPE, Via, Via, Via, False);
-  RestoreToPolygon (PCB->Data, VIA_TYPE, CURRENT, Via);
+  AddObjectToClearPourUndoList (VIA_TYPE, Via, Via, Via, False);
+  RestoreToPours (PCB->Data, VIA_TYPE, CURRENT, Via);
   AddObjectToFlagUndoList (VIA_TYPE, Via, Via, Via);
   if (!Delta)			/* remove the thermals */
     CLEAR_THERM (INDEXOFCURRENT, Via);
   else
     ASSIGN_THERM (INDEXOFCURRENT, Delta, Via);
-  AddObjectToClearPolyUndoList (VIA_TYPE, Via, Via, Via, True);
-  ClearFromPolygon (PCB->Data, VIA_TYPE, CURRENT, Via);
+  AddObjectToClearPourUndoList (VIA_TYPE, Via, Via, Via, True);
+  ClearFromPours (PCB->Data, VIA_TYPE, CURRENT, Via);
   DrawVia (Via, 0);
   return Via;
 }
@@ -373,15 +390,15 @@ ChangeViaThermal (PinTypePtr Via)
 static void *
 ChangePinThermal (ElementTypePtr element, PinTypePtr Pin)
 {
-  AddObjectToClearPolyUndoList (PIN_TYPE, element, Pin, Pin, False);
-  RestoreToPolygon (PCB->Data, VIA_TYPE, CURRENT, Pin);
+  AddObjectToClearPourUndoList (PIN_TYPE, element, Pin, Pin, False);
+  RestoreToPours (PCB->Data, VIA_TYPE, CURRENT, Pin);
   AddObjectToFlagUndoList (PIN_TYPE, element, Pin, Pin);
   if (!Delta)			/* remove the thermals */
     CLEAR_THERM (INDEXOFCURRENT, Pin);
   else
     ASSIGN_THERM (INDEXOFCURRENT, Delta, Pin);
-  AddObjectToClearPolyUndoList (PIN_TYPE, element, Pin, Pin, True);
-  ClearFromPolygon (PCB->Data, VIA_TYPE, CURRENT, Pin);
+  AddObjectToClearPourUndoList (PIN_TYPE, element, Pin, Pin, True);
+  ClearFromPours (PCB->Data, VIA_TYPE, CURRENT, Pin);
   DrawPin (Pin, 0);
   return Pin;
 }
@@ -405,7 +422,7 @@ ChangeViaSize (PinTypePtr Via)
       AddObjectToSizeUndoList (VIA_TYPE, Via, Via, Via);
       EraseVia (Via);
       r_delete_entry (PCB->Data->via_tree, (BoxType *) Via);
-      RestoreToPolygon (PCB->Data, PIN_TYPE, Via, Via);
+      RestoreToPours (PCB->Data, PIN_TYPE, Via, Via);
       if (Via->Mask)
 	{
 	  AddObjectToMaskSizeUndoList (VIA_TYPE, Via, Via, Via);
@@ -414,7 +431,7 @@ ChangeViaSize (PinTypePtr Via)
       Via->Thickness = value;
       SetPinBoundingBox (Via);
       r_insert_entry (PCB->Data->via_tree, (BoxType *) Via, 0);
-      ClearFromPolygon (PCB->Data, VIA_TYPE, Via, Via);
+      ClearFromPours (PCB->Data, VIA_TYPE, Via, Via);
       DrawVia (Via, 0);
       return (Via);
     }
@@ -443,10 +460,10 @@ ChangeVia2ndSize (PinTypePtr Via)
       Via->DrillingHole = value;
       if (TEST_FLAG (HOLEFLAG, Via))
 	{
-	  RestoreToPolygon (PCB->Data, VIA_TYPE, Via, Via);
+	  RestoreToPours (PCB->Data, VIA_TYPE, Via, Via);
 	  AddObjectToSizeUndoList (VIA_TYPE, Via, Via, Via);
 	  Via->Thickness = value;
-	  ClearFromPolygon (PCB->Data, VIA_TYPE, Via, Via);
+	  ClearFromPours (PCB->Data, VIA_TYPE, Via, Via);
 	}
       DrawVia (Via, 0);
       return (Via);
@@ -475,14 +492,14 @@ ChangeViaClearSize (PinTypePtr Via)
     value = PCB->Bloat * 2 + 2;
   if (Via->Clearance == value)
     return NULL;
-  RestoreToPolygon (PCB->Data, VIA_TYPE, Via, Via);
+  RestoreToPours (PCB->Data, VIA_TYPE, Via, Via);
   AddObjectToClearSizeUndoList (VIA_TYPE, Via, Via, Via);
   EraseVia (Via);
   r_delete_entry (PCB->Data->via_tree, (BoxType *) Via);
   Via->Clearance = value;
   SetPinBoundingBox (Via);
   r_insert_entry (PCB->Data->via_tree, (BoxType *) Via, 0);
-  ClearFromPolygon (PCB->Data, VIA_TYPE, Via, Via);
+  ClearFromPours (PCB->Data, VIA_TYPE, Via, Via);
   DrawVia (Via, 0);
   Via->Element = NULL;
   return (Via);
@@ -509,12 +526,12 @@ ChangePinSize (ElementTypePtr Element, PinTypePtr Pin)
       AddObjectToMaskSizeUndoList (PIN_TYPE, Element, Pin, Pin);
       ErasePin (Pin);
       r_delete_entry (PCB->Data->pin_tree, &Pin->BoundingBox);
-      RestoreToPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+      RestoreToPours (PCB->Data, PIN_TYPE, Element, Pin);
       Pin->Mask += value - Pin->Thickness;
       Pin->Thickness = value;
       /* SetElementBB updates all associated rtrees */
       SetElementBoundingBox (PCB->Data, Element, &PCB->Font);
-      ClearFromPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+      ClearFromPours (PCB->Data, PIN_TYPE, Element, Pin);
       DrawPin (Pin, 0);
       return (Pin);
     }
@@ -541,14 +558,14 @@ ChangePinClearSize (ElementTypePtr Element, PinTypePtr Pin)
     value = PCB->Bloat * 2 + 2;
   if (Pin->Clearance == value)
     return NULL;
-  RestoreToPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+  RestoreToPours (PCB->Data, PIN_TYPE, Element, Pin);
   AddObjectToClearSizeUndoList (PIN_TYPE, Element, Pin, Pin);
   ErasePin (Pin);
   r_delete_entry (PCB->Data->pin_tree, &Pin->BoundingBox);
   Pin->Clearance = value;
   /* SetElementBB updates all associated rtrees */
   SetElementBoundingBox (PCB->Data, Element, &PCB->Font);
-  ClearFromPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+  ClearFromPours (PCB->Data, PIN_TYPE, Element, Pin);
   DrawPin (Pin, 0);
   return (Pin);
 }
@@ -568,14 +585,14 @@ ChangePadSize (ElementTypePtr Element, PadTypePtr Pad)
     {
       AddObjectToSizeUndoList (PAD_TYPE, Element, Pad, Pad);
       AddObjectToMaskSizeUndoList (PAD_TYPE, Element, Pad, Pad);
-      RestoreToPolygon (PCB->Data, PAD_TYPE, Element, Pad);
+      RestoreToPours (PCB->Data, PAD_TYPE, Element, Pad);
       ErasePad (Pad);
       r_delete_entry (PCB->Data->pad_tree, &Pad->BoundingBox);
       Pad->Mask += value - Pad->Thickness;
       Pad->Thickness = value;
       /* SetElementBB updates all associated rtrees */
       SetElementBoundingBox (PCB->Data, Element, &PCB->Font);
-      ClearFromPolygon (PCB->Data, PAD_TYPE, Element, Pad);
+      ClearFromPours (PCB->Data, PAD_TYPE, Element, Pad);
       DrawPad (Pad, 0);
       return (Pad);
     }
@@ -603,13 +620,13 @@ ChangePadClearSize (ElementTypePtr Element, PadTypePtr Pad)
   if (value == Pad->Clearance)
     return NULL;
   AddObjectToClearSizeUndoList (PAD_TYPE, Element, Pad, Pad);
-  RestoreToPolygon (PCB->Data, PAD_TYPE, Element, Pad);
+  RestoreToPours (PCB->Data, PAD_TYPE, Element, Pad);
   ErasePad (Pad);
   r_delete_entry (PCB->Data->pad_tree, &Pad->BoundingBox);
   Pad->Clearance = value;
   /* SetElementBB updates all associated rtrees */
   SetElementBoundingBox (PCB->Data, Element, &PCB->Font);
-  ClearFromPolygon (PCB->Data, PAD_TYPE, Element, Pad);
+  ClearFromPours (PCB->Data, PAD_TYPE, Element, Pad);
   DrawPad (Pad, 0);
   return Pad;
 }
@@ -643,10 +660,10 @@ ChangeElement2ndSize (ElementTypePtr Element)
 	DrawPin (pin, 0);
 	if (TEST_FLAG (HOLEFLAG, pin))
 	  {
-	    RestoreToPolygon (PCB->Data, PIN_TYPE, Element, pin);
+	    RestoreToPours (PCB->Data, PIN_TYPE, Element, pin);
 	    AddObjectToSizeUndoList (PIN_TYPE, Element, pin, pin);
 	    pin->Thickness = value;
-	    ClearFromPolygon (PCB->Data, PIN_TYPE, Element, pin);
+	    ClearFromPours (PCB->Data, PIN_TYPE, Element, pin);
 	  }
       }
   }
@@ -680,10 +697,10 @@ ChangePin2ndSize (ElementTypePtr Element, PinTypePtr Pin)
       DrawPin (Pin, 0);
       if (TEST_FLAG (HOLEFLAG, Pin))
 	{
-	  RestoreToPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+	  RestoreToPours (PCB->Data, PIN_TYPE, Element, Pin);
 	  AddObjectToSizeUndoList (PIN_TYPE, Element, Pin, Pin);
 	  Pin->Thickness = value;
-	  ClearFromPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+	  ClearFromPours (PCB->Data, PIN_TYPE, Element, Pin);
 	}
       return (Pin);
     }
@@ -707,11 +724,11 @@ ChangeLineSize (LayerTypePtr Layer, LineTypePtr Line)
       AddObjectToSizeUndoList (LINE_TYPE, Layer, Line, Line);
       EraseLine (Line);
       r_delete_entry (Layer->line_tree, (BoxTypePtr) Line);
-      RestoreToPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+      RestoreToPours (PCB->Data, LINE_TYPE, Layer, Line);
       Line->Thickness = value;
       SetLineBoundingBox (Line);
       r_insert_entry (Layer->line_tree, (BoxTypePtr) Line, 0);
-      ClearFromPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+      ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
       DrawLine (Layer, Line, 0);
       return (Line);
     }
@@ -733,7 +750,7 @@ ChangeLineClearSize (LayerTypePtr Layer, LineTypePtr Line)
   if (value != Line->Clearance)
     {
       AddObjectToClearSizeUndoList (LINE_TYPE, Layer, Line, Line);
-      RestoreToPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+      RestoreToPours (PCB->Data, LINE_TYPE, Layer, Line);
       EraseLine (Line);
       r_delete_entry (Layer->line_tree, (BoxTypePtr) Line);
       Line->Clearance = value;
@@ -744,7 +761,7 @@ ChangeLineClearSize (LayerTypePtr Layer, LineTypePtr Line)
 	}
       SetLineBoundingBox (Line);
       r_insert_entry (Layer->line_tree, (BoxTypePtr) Line, 0);
-      ClearFromPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+      ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
       DrawLine (Layer, Line, 0);
       return (Line);
     }
@@ -772,6 +789,26 @@ ChangePolygonClearSize (LayerTypePtr Layer, PolygonTypePtr poly)
 }
 
 /* ---------------------------------------------------------------------------
+ * Handle attepts to change the clearance of a polygon.
+ */
+static void *
+ChangePourClearSize (LayerTypePtr Layer, PourTypePtr pour)
+{
+  static int shown_this_message = 0;
+  if (!shown_this_message)
+    {
+      gui->confirm_dialog ("To change the clearance of objects in a pour, "
+			   "change the objects, not the pour.\n"
+			   "Hint: To set a minimum clearance for a group of objects, "
+			   "select them all then :MinClearGap(Selected,=10,mil)",
+			   "Ok", NULL);
+      shown_this_message = 1;
+    }
+
+  return (NULL);
+}
+
+/* ---------------------------------------------------------------------------
  * changes the size of an arc
  * returns TRUE if changed
  */
@@ -788,11 +825,11 @@ ChangeArcSize (LayerTypePtr Layer, ArcTypePtr Arc)
       AddObjectToSizeUndoList (ARC_TYPE, Layer, Arc, Arc);
       EraseArc (Arc);
       r_delete_entry (Layer->arc_tree, (BoxTypePtr) Arc);
-      RestoreToPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
+      RestoreToPours (PCB->Data, ARC_TYPE, Layer, Arc);
       Arc->Thickness = value;
       SetArcBoundingBox (Arc);
       r_insert_entry (Layer->arc_tree, (BoxTypePtr) Arc, 0);
-      ClearFromPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
+      ClearFromPours (PCB->Data, ARC_TYPE, Layer, Arc);
       DrawArc (Layer, Arc, 0);
       return (Arc);
     }
@@ -816,7 +853,7 @@ ChangeArcClearSize (LayerTypePtr Layer, ArcTypePtr Arc)
       AddObjectToClearSizeUndoList (ARC_TYPE, Layer, Arc, Arc);
       EraseArc (Arc);
       r_delete_entry (Layer->arc_tree, (BoxTypePtr) Arc);
-      RestoreToPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
+      RestoreToPours (PCB->Data, ARC_TYPE, Layer, Arc);
       Arc->Clearance = value;
       if (Arc->Clearance == 0)
 	{
@@ -825,7 +862,7 @@ ChangeArcClearSize (LayerTypePtr Layer, ArcTypePtr Arc)
 	}
       SetArcBoundingBox (Arc);
       r_insert_entry (Layer->arc_tree, (BoxTypePtr) Arc, 0);
-      ClearFromPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
+      ClearFromPours (PCB->Data, ARC_TYPE, Layer, Arc);
       DrawArc (Layer, Arc, 0);
       return (Arc);
     }
@@ -849,11 +886,11 @@ ChangeTextSize (LayerTypePtr Layer, TextTypePtr Text)
       AddObjectToSizeUndoList (TEXT_TYPE, Layer, Text, Text);
       EraseText (Layer, Text);
       r_delete_entry (Layer->text_tree, (BoxTypePtr) Text);
-      RestoreToPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+      RestoreToPours (PCB->Data, TEXT_TYPE, Layer, Text);
       Text->Scale = value;
       SetTextBoundingBox (&PCB->Font, Text);
       r_insert_entry (Layer->text_tree, (BoxTypePtr) Text, 0);
-      ClearFromPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+      ClearFromPours (PCB->Data, TEXT_TYPE, Layer, Text);
       DrawText (Layer, Text, 0);
       return (Text);
     }
@@ -1075,12 +1112,12 @@ ChangeTextName (LayerTypePtr Layer, TextTypePtr Text)
   if (TEST_FLAG (LOCKFLAG, Text))
     return (NULL);
   EraseText (Layer, Text);
-  RestoreToPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+  RestoreToPours (PCB->Data, TEXT_TYPE, Layer, Text);
   Text->TextString = NewName;
 
   /* calculate size of the bounding box */
   SetTextBoundingBox (&PCB->Font, Text);
-  ClearFromPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+  ClearFromPours (PCB->Data, TEXT_TYPE, Layer, Text);
   DrawText (Layer, Text, 0);
   return (old);
 }
@@ -1134,15 +1171,15 @@ ChangeLineJoin (LayerTypePtr Layer, LineTypePtr Line)
   EraseLine (Line);
   if (TEST_FLAG(CLEARLINEFLAG, Line))
   {
-  AddObjectToClearPolyUndoList (LINE_TYPE, Layer, Line, Line, False);
-  RestoreToPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+  AddObjectToClearPourUndoList (LINE_TYPE, Layer, Line, Line, False);
+  RestoreToPours (PCB->Data, LINE_TYPE, Layer, Line);
   }
   AddObjectToFlagUndoList (LINE_TYPE, Layer, Line, Line);
   TOGGLE_FLAG (CLEARLINEFLAG, Line);
   if (TEST_FLAG(CLEARLINEFLAG, Line))
   {
-  AddObjectToClearPolyUndoList (LINE_TYPE, Layer, Line, Line, True);
-  ClearFromPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+  AddObjectToClearPourUndoList (LINE_TYPE, Layer, Line, Line, True);
+  ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
   }
   DrawLine (Layer, Line, 0);
   return (Line);
@@ -1180,17 +1217,17 @@ ChangeArcJoin (LayerTypePtr Layer, ArcTypePtr Arc)
     return (NULL);
   EraseArc (Arc);
   if (TEST_FLAG (CLEARLINEFLAG, Arc))
-  {
-    RestoreToPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
-    AddObjectToClearPolyUndoList (ARC_TYPE, Layer, Arc, Arc, False);
+    {
+      RestoreToPours (PCB->Data, ARC_TYPE, Layer, Arc);
+      AddObjectToClearPourUndoList (ARC_TYPE, Layer, Arc, Arc, False);
     }
   AddObjectToFlagUndoList (ARC_TYPE, Layer, Arc, Arc);
   TOGGLE_FLAG (CLEARLINEFLAG, Arc);
   if (TEST_FLAG (CLEARLINEFLAG, Arc))
-  {
-    ClearFromPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
-  AddObjectToClearPolyUndoList (ARC_TYPE, Layer, Arc, Arc, True);
-  }
+    {
+      ClearFromPours (PCB->Data, ARC_TYPE, Layer, Arc);
+      AddObjectToClearPourUndoList (ARC_TYPE, Layer, Arc, Arc, True);
+    }
   DrawArc (Layer, Arc, 0);
   return (Arc);
 }
@@ -1228,15 +1265,15 @@ ChangeTextJoin (LayerTypePtr Layer, TextTypePtr Text)
   EraseText (Layer, Text);
   if (TEST_FLAG(CLEARLINEFLAG, Text))
   {
-  AddObjectToClearPolyUndoList (TEXT_TYPE, Layer, Text, Text, False);
-  RestoreToPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+  AddObjectToClearPourUndoList (TEXT_TYPE, Layer, Text, Text, False);
+  RestoreToPours (PCB->Data, TEXT_TYPE, Layer, Text);
   }
   AddObjectToFlagUndoList (LINE_TYPE, Layer, Text, Text);
   TOGGLE_FLAG (CLEARLINEFLAG, Text);
   if (TEST_FLAG(CLEARLINEFLAG, Text))
   {
-  AddObjectToClearPolyUndoList (TEXT_TYPE, Layer, Text, Text, True);
-  ClearFromPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+  AddObjectToClearPourUndoList (TEXT_TYPE, Layer, Text, Text, True);
+  ClearFromPours (PCB->Data, TEXT_TYPE, Layer, Text);
   }
   DrawText (Layer, Text, 0);
   return (Text);
@@ -1399,12 +1436,12 @@ ChangePadSquare (ElementTypePtr Element, PadTypePtr Pad)
   if (TEST_FLAG (LOCKFLAG, Pad))
     return (NULL);
   ErasePad (Pad);
-  AddObjectToClearPolyUndoList (PAD_TYPE, Element, Pad, Pad, False);
-  RestoreToPolygon (PCB->Data, PAD_TYPE, Element, Pad);
+  AddObjectToClearPourUndoList (PAD_TYPE, Element, Pad, Pad, False);
+  RestoreToPours (PCB->Data, PAD_TYPE, Element, Pad);
   AddObjectToFlagUndoList (PAD_TYPE, Element, Pad, Pad);
   TOGGLE_FLAG (SQUAREFLAG, Pad);
-  AddObjectToClearPolyUndoList (PAD_TYPE, Element, Pad, Pad, True);
-  ClearFromPolygon (PCB->Data, PAD_TYPE, Element, Pad);
+  AddObjectToClearPourUndoList (PAD_TYPE, Element, Pad, Pad, True);
+  ClearFromPours (PCB->Data, PAD_TYPE, Element, Pad);
   DrawPad (Pad, 0);
   return (Pad);
 }
@@ -1446,12 +1483,12 @@ ChangePinSquare (ElementTypePtr Element, PinTypePtr Pin)
   if (TEST_FLAG (LOCKFLAG, Pin))
     return (NULL);
   ErasePin (Pin);
-  AddObjectToClearPolyUndoList (PIN_TYPE, Element, Pin, Pin, False);
-  RestoreToPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+  AddObjectToClearPourUndoList (PIN_TYPE, Element, Pin, Pin, False);
+  RestoreToPours (PCB->Data, PIN_TYPE, Element, Pin);
   AddObjectToFlagUndoList (PIN_TYPE, Element, Pin, Pin);
   TOGGLE_FLAG (SQUAREFLAG, Pin);
-  AddObjectToClearPolyUndoList (PIN_TYPE, Element, Pin, Pin, True);
-  ClearFromPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+  AddObjectToClearPourUndoList (PIN_TYPE, Element, Pin, Pin, True);
+  ClearFromPours (PCB->Data, PIN_TYPE, Element, Pin);
   DrawPin (Pin, 0);
   return (Pin);
 }
@@ -1489,12 +1526,12 @@ ChangeViaOctagon (PinTypePtr Via)
   if (TEST_FLAG (LOCKFLAG, Via))
     return (NULL);
   EraseVia (Via);
-  AddObjectToClearPolyUndoList (VIA_TYPE, Via, Via, Via, False);
-  RestoreToPolygon (PCB->Data, VIA_TYPE, Via, Via);
+  AddObjectToClearPourUndoList (VIA_TYPE, Via, Via, Via, False);
+  RestoreToPours (PCB->Data, VIA_TYPE, Via, Via);
   AddObjectToFlagUndoList (VIA_TYPE, Via, Via, Via);
   TOGGLE_FLAG (OCTAGONFLAG, Via);
-  AddObjectToClearPolyUndoList (VIA_TYPE, Via, Via, Via, True);
-  ClearFromPolygon (PCB->Data, VIA_TYPE, Via, Via);
+  AddObjectToClearPourUndoList (VIA_TYPE, Via, Via, Via, True);
+  ClearFromPours (PCB->Data, VIA_TYPE, Via, Via);
   DrawVia (Via, 0);
   return (Via);
 }
@@ -1532,12 +1569,12 @@ ChangePinOctagon (ElementTypePtr Element, PinTypePtr Pin)
   if (TEST_FLAG (LOCKFLAG, Pin))
     return (NULL);
   ErasePin (Pin);
-  AddObjectToClearPolyUndoList (PIN_TYPE, Element, Pin, Pin, False);
-  RestoreToPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+  AddObjectToClearPourUndoList (PIN_TYPE, Element, Pin, Pin, False);
+  RestoreToPours (PCB->Data, PIN_TYPE, Element, Pin);
   AddObjectToFlagUndoList (PIN_TYPE, Element, Pin, Pin);
   TOGGLE_FLAG (OCTAGONFLAG, Pin);
-  AddObjectToClearPolyUndoList (PIN_TYPE, Element, Pin, Pin, True);
-  ClearFromPolygon (PCB->Data, PIN_TYPE, Element, Pin);
+  AddObjectToClearPourUndoList (PIN_TYPE, Element, Pin, Pin, True);
+  ClearFromPours (PCB->Data, PIN_TYPE, Element, Pin);
   DrawPin (Pin, 0);
   return (Pin);
 }
@@ -1579,10 +1616,10 @@ ChangeHole (PinTypePtr Via)
   TOGGLE_FLAG (HOLEFLAG, Via);
   if (TEST_FLAG (HOLEFLAG, Via))
     {
-      RestoreToPolygon (PCB->Data, VIA_TYPE, Via, Via);
+      RestoreToPours (PCB->Data, VIA_TYPE, Via, Via);
       AddObjectToSizeUndoList (VIA_TYPE, Via, Via, Via);
       Via->Thickness = Via->Mask = Via->DrillingHole;
-      ClearFromPolygon (PCB->Data, VIA_TYPE, Via, Via);
+      ClearFromPours (PCB->Data, VIA_TYPE, Via, Via);
     }
   else
     {
@@ -1611,19 +1648,19 @@ ChangePaste (PadTypePtr Pad)
 }
 
 /* ---------------------------------------------------------------------------
- * changes the CLEARPOLY flag of a polygon
+ * changes the CLEARPOLY flag of a pour
  */
 static void *
-ChangePolyClear (LayerTypePtr Layer, PolygonTypePtr Polygon)
+ChangePourClear (LayerTypePtr Layer, PourTypePtr Pour)
 {
-  if (TEST_FLAG (LOCKFLAG, Polygon))
+  if (TEST_FLAG (LOCKFLAG, Pour))
     return (NULL);
-  AddObjectToClearPolyUndoList (POLYGON_TYPE, Layer, Polygon, Polygon, True);
-  AddObjectToFlagUndoList (POLYGON_TYPE, Layer, Polygon, Polygon);
-  TOGGLE_FLAG (CLEARPOLYFLAG, Polygon);
-  InitClip (PCB->Data, Layer, Polygon);
-  DrawPolygon (Layer, Polygon, 0);
-  return (Polygon);
+  AddObjectToClearPourUndoList (POUR_TYPE, Layer, Pour, Pour, True);
+  AddObjectToFlagUndoList (POUR_TYPE, Layer, Pour, Pour);
+  TOGGLE_FLAG (CLEARPOLYFLAG, Pour);
+  InitPourClip (PCB->Data, Layer, Pour);
+  DrawPour (Layer, Pour, 0);
+  return (Pour);
 }
 
 /* ----------------------------------------------------------------------
diff --git a/src/change.h b/src/change.h
index fc577a0..834d3de 100644
--- a/src/change.h
+++ b/src/change.h
@@ -40,7 +40,7 @@
 	(VIA_TYPE | PIN_TYPE | PAD_TYPE | TEXT_TYPE | ELEMENT_TYPE | ELEMENTNAME_TYPE | LINE_TYPE)
 
 #define	CHANGESIZE_TYPES        \
-	(POLYGON_TYPE | VIA_TYPE | PIN_TYPE | PAD_TYPE | LINE_TYPE | \
+	(POUR_TYPE | VIA_TYPE | PIN_TYPE | PAD_TYPE | LINE_TYPE | \
 	 ARC_TYPE | TEXT_TYPE | ELEMENTNAME_TYPE | ELEMENT_TYPE)
 
 #define	CHANGE2NDSIZE_TYPES     \
diff --git a/src/const.h b/src/const.h
index 2f97d4e..cc94f8c 100644
--- a/src/const.h
+++ b/src/const.h
@@ -78,7 +78,8 @@
 #define	VIA_MODE		1	/* draw vias */
 #define	LINE_MODE		2	/* draw lines */
 #define	RECTANGLE_MODE		3	/* create rectangles */
-#define	POLYGON_MODE		4	/* draw filled polygons */
+//#define	POLYGON_MODE		4	/* draw filled polygons */
+#define	POUR_MODE		4	/* draw poured areas */
 #define	PASTEBUFFER_MODE	5	/* paste objects from buffer */
 #define	TEXT_MODE		6	/* create text objects */
 #define	ROTATE_MODE		102	/* rotate objects */
@@ -302,17 +303,20 @@ When set, element names are not drawn.
 #define	PIN_TYPE		0x00100	/* objects that are part */
 #define	PAD_TYPE		0x00200	/* 'pin' of SMD element */
 #define	ELEMENTNAME_TYPE	0x00400	/* of others */
-#define	POLYGONPOINT_TYPE	0x00800
+//#define	POLYGONPOINT_TYPE	0x00800
+#define POURPOINT_TYPE 		0x00800
 #define	LINEPOINT_TYPE		0x01000
 #define ELEMENTLINE_TYPE        0x02000
 #define ARC_TYPE                0x04000
 #define ELEMENTARC_TYPE		0x08000
 
 #define LOCKED_TYPE 		0x10000	/* used to tell search to include locked items. */
+#define POUR_TYPE 		0x20000
 
 #define PIN_TYPES     (VIA_TYPE | PIN_TYPE)
-#define LOCK_TYPES    (VIA_TYPE | LINE_TYPE | ARC_TYPE | POLYGON_TYPE | ELEMENT_TYPE \
-                      | TEXT_TYPE | ELEMENTNAME_TYPE | LOCKED_TYPE)
+#define LOCK_TYPES    (VIA_TYPE | LINE_TYPE | ARC_TYPE | POUR_TYPE | \
+                       ELEMENT_TYPE | TEXT_TYPE | ELEMENTNAME_TYPE | \
+                       LOCKED_TYPE)
 
 #define	ALL_TYPES		(~0)	/* all bits set */
 
diff --git a/src/copy.c b/src/copy.c
index 583feb8..f15e2f2 100644
--- a/src/copy.c
+++ b/src/copy.c
@@ -47,7 +47,7 @@
 #include "mirror.h"
 #include "misc.h"
 #include "move.h"
-#include "polygon.h"
+#include "pour.h"
 #include "rats.h"
 #include "rtree.h"
 #include "select.h"
@@ -66,7 +66,7 @@ static void *CopyVia (PinTypePtr);
 static void *CopyLine (LayerTypePtr, LineTypePtr);
 static void *CopyArc (LayerTypePtr, ArcTypePtr);
 static void *CopyText (LayerTypePtr, TextTypePtr);
-static void *CopyPolygon (LayerTypePtr, PolygonTypePtr);
+static void *CopyPour (LayerTypePtr, PourTypePtr);
 static void *CopyElement (ElementTypePtr);
 
 /* ---------------------------------------------------------------------------
@@ -76,7 +76,8 @@ static LocationType DeltaX, DeltaY;	/* movement vector */
 static ObjectFunctionType CopyFunctions = {
   CopyLine,
   CopyText,
-  CopyPolygon,
+  NULL,
+  CopyPour,
   CopyVia,
   CopyElement,
   NULL,
@@ -89,19 +90,19 @@ static ObjectFunctionType CopyFunctions = {
 };
 
 /* ---------------------------------------------------------------------------
- * copies data from one polygon to another
+ * copies data from one pour to another
  * 'Dest' has to exist
  */
-PolygonTypePtr
-CopyPolygonLowLevel (PolygonTypePtr Dest, PolygonTypePtr Src)
+PourTypePtr
+CopyPourLowLevel (PourTypePtr Dest, PourTypePtr Src)
 {
   /* copy all data */
-  POLYGONPOINT_LOOP (Src);
+  POURPOINT_LOOP (Src);
   {
-    CreateNewPointInPolygon (Dest, point->X, point->Y);
+    CreateNewPointInPour (Dest, point->X, point->Y);
   }
   END_LOOP;
-  SetPolygonBoundingBox (Dest);
+  SetPourBoundingBox (Dest);
   Dest->Flags = Src->Flags;
   CLEAR_FLAG (FOUNDFLAG, Dest);
   return (Dest);
@@ -257,23 +258,23 @@ CopyText (LayerTypePtr Layer, TextTypePtr Text)
 }
 
 /* ---------------------------------------------------------------------------
- * copies a polygon 
+ * copies a pour
  */
 static void *
-CopyPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
+CopyPour (LayerTypePtr Layer, PourTypePtr Pour)
 {
-  PolygonTypePtr polygon;
-
-  polygon = CreateNewPolygon (Layer, NoFlags ());
-  CopyPolygonLowLevel (polygon, Polygon);
-  MovePolygonLowLevel (polygon, DeltaX, DeltaY);
-  if (!Layer->polygon_tree)
-    Layer->polygon_tree = r_create_tree (NULL, 0, 0);
-  r_insert_entry (Layer->polygon_tree, (BoxTypePtr) polygon, 0);
-  InitClip (PCB->Data, Layer, polygon);
-  DrawPolygon (Layer, polygon, 0);
-  AddObjectToCreateUndoList (POLYGON_TYPE, Layer, polygon, polygon);
-  return (polygon);
+  PourTypePtr pour;
+
+  pour = CreateNewPour (Layer, NoFlags ());
+  CopyPourLowLevel (pour, Pour);
+  MovePourLowLevel (pour, DeltaX, DeltaY);
+  if (!Layer->pour_tree)
+    Layer->pour_tree = r_create_tree (NULL, 0, 0);
+  r_insert_entry (Layer->pour_tree, (BoxTypePtr) pour, 0);
+  InitPourClip (PCB->Data, Layer, pour);
+  DrawPour (Layer, pour, 0);
+  AddObjectToCreateUndoList (POUR_TYPE, Layer, pour, pour);
+  return (pour);
 }
 
 /* ---------------------------------------------------------------------------
@@ -342,7 +343,7 @@ CopyPastebufferToLayout (LocationType X, LocationType Y)
 	  changed = changed ||
 	    (sourcelayer->LineN != 0) ||
 	    (sourcelayer->ArcN != 0) ||
-	    (sourcelayer->PolygonN != 0) || (sourcelayer->TextN != 0);
+	    (sourcelayer->PourN != 0) || (sourcelayer->TextN != 0);
 	  LINE_LOOP (sourcelayer);
 	  {
 	    CopyLine (destlayer, line);
@@ -358,9 +359,9 @@ CopyPastebufferToLayout (LocationType X, LocationType Y)
 	    CopyText (destlayer, text);
 	  }
 	  END_LOOP;
-	  POLYGON_LOOP (sourcelayer);
+	  POUR_LOOP (sourcelayer);
 	  {
-	    CopyPolygon (destlayer, polygon);
+	    CopyPour (destlayer, pour);
 	  }
 	  END_LOOP;
 	}
diff --git a/src/copy.h b/src/copy.h
index 472fc75..8d027d0 100644
--- a/src/copy.h
+++ b/src/copy.h
@@ -38,10 +38,10 @@
  */
 #define	COPY_TYPES              \
 	(VIA_TYPE | LINE_TYPE | TEXT_TYPE | \
-	ELEMENT_TYPE | ELEMENTNAME_TYPE | POLYGON_TYPE | ARC_TYPE)
+	ELEMENT_TYPE | ELEMENTNAME_TYPE | POUR_TYPE | ARC_TYPE)
 
 
-PolygonTypePtr CopyPolygonLowLevel (PolygonTypePtr, PolygonTypePtr);
+PourTypePtr CopyPourLowLevel (PourTypePtr, PourTypePtr);
 ElementTypePtr CopyElementLowLevel (DataTypePtr, ElementTypePtr,
 				    ElementTypePtr, Boolean, LocationType, LocationType);
 Boolean CopyPastebufferToLayout (LocationType, LocationType);
diff --git a/src/create.c b/src/create.c
index eced68d..e911290 100644
--- a/src/create.c
+++ b/src/create.c
@@ -545,29 +545,28 @@ CreateNewArcOnLayer (LayerTypePtr Layer,
   return (Arc);
 }
 
-
 /* ---------------------------------------------------------------------------
- * creates a new polygon from the old formats rectangle data
+ * creates a new pour from the old formats rectangle data
  */
-PolygonTypePtr
-CreateNewPolygonFromRectangle (LayerTypePtr Layer,
+PourTypePtr
+CreateNewPourFromRectangle (LayerTypePtr Layer,
 			       LocationType X1, LocationType Y1,
 			       LocationType X2, LocationType Y2,
 			       FlagType Flags)
 {
-  PolygonTypePtr polygon = CreateNewPolygon (Layer, Flags);
-  if (!polygon)
-    return (polygon);
-
-  CreateNewPointInPolygon (polygon, X1, Y1);
-  CreateNewPointInPolygon (polygon, X2, Y1);
-  CreateNewPointInPolygon (polygon, X2, Y2);
-  CreateNewPointInPolygon (polygon, X1, Y2);
-  SetPolygonBoundingBox (polygon);
-  if (!Layer->polygon_tree)
-    Layer->polygon_tree = r_create_tree (NULL, 0, 0);
-  r_insert_entry (Layer->polygon_tree, (BoxTypePtr) polygon, 0);
-  return (polygon);
+  PourTypePtr pour = CreateNewPour (Layer, Flags);
+  if (!pour)
+    return (pour);
+
+  CreateNewPointInPour (pour, X1, Y1);
+  CreateNewPointInPour (pour, X2, Y1);
+  CreateNewPointInPour (pour, X2, Y2);
+  CreateNewPointInPour (pour, X1, Y2);
+  SetPourBoundingBox (pour);
+  if (!Layer->pour_tree)
+    Layer->pour_tree = r_create_tree (NULL, 0, 0);
+  r_insert_entry (Layer->pour_tree, (BoxTypePtr) pour, 0);
+  return (pour);
 }
 
 /* ---------------------------------------------------------------------------
@@ -605,9 +604,9 @@ CreateNewText (LayerTypePtr Layer, FontTypePtr PCBFont,
  * creates a new polygon on a layer
  */
 PolygonTypePtr
-CreateNewPolygon (LayerTypePtr Layer, FlagType Flags)
+CreateNewPolygonInPour (PourType *pour, FlagType Flags)
 {
-  PolygonTypePtr polygon = GetPolygonMemory (Layer);
+  PolygonTypePtr polygon = GetPolygonMemoryInPour (pour);
 
   /* copy values */
   polygon->Flags = Flags;
@@ -615,17 +614,40 @@ CreateNewPolygon (LayerTypePtr Layer, FlagType Flags)
   polygon->Clipped = NULL;
   polygon->NoHoles = NULL;
   polygon->NoHolesValid = 0;
+  polygon->ParentPour = pour;
   return (polygon);
 }
 
 /* ---------------------------------------------------------------------------
- * creates a new point in a polygon
+ * creates a new pour on a layer
+ */
+PourTypePtr
+CreateNewPour (LayerTypePtr Layer, FlagType Flags)
+{
+  PourTypePtr pour = GetPourMemory (Layer);
+
+  /* copy values */
+  pour->Flags = Flags;
+  pour->ID = ID++;
+
+  pour->PointN = 0;
+  pour->PointMax = 0;
+  pour->Points = NULL;
+  pour->PolygonN = 0;
+  pour->PolygonMax = 0;
+  pour->Polygons = NULL;
+
+  return (pour);
+}
+
+/* ---------------------------------------------------------------------------
+ * creates a new point in a pour
  */
 PointTypePtr
-CreateNewPointInPolygon (PolygonTypePtr Polygon, LocationType X,
+CreateNewPointInPour (PourTypePtr Pour, LocationType X,
 			 LocationType Y)
 {
-  PointTypePtr point = GetPointMemoryInPolygon (Polygon);
+  PointTypePtr point = GetPointMemoryInPour (Pour);
 
   /* copy values */
   point->X = X;
diff --git a/src/create.h b/src/create.h
index a994c84..4c9fae6 100644
--- a/src/create.h
+++ b/src/create.h
@@ -54,13 +54,14 @@ RatTypePtr CreateNewRat (DataTypePtr, LocationType, LocationType,
 ArcTypePtr CreateNewArcOnLayer (LayerTypePtr, LocationType, LocationType,
 				BDimension, BDimension, int, int, BDimension, BDimension,
 				FlagType);
-PolygonTypePtr CreateNewPolygonFromRectangle (LayerTypePtr, LocationType,
+PourTypePtr CreateNewPourFromRectangle (LayerTypePtr, LocationType,
 					      LocationType, LocationType,
 					      LocationType, FlagType);
 TextTypePtr CreateNewText (LayerTypePtr, FontTypePtr, LocationType,
 			   LocationType, BYTE, int, char *, FlagType);
-PolygonTypePtr CreateNewPolygon (LayerTypePtr, FlagType);
-PointTypePtr CreateNewPointInPolygon (PolygonTypePtr,
+PolygonTypePtr CreateNewPolygonInPour (PourType *pour, FlagType);
+PourTypePtr CreateNewPour (LayerTypePtr, FlagType);
+PointTypePtr CreateNewPointInPour (PourTypePtr,
 				      LocationType, LocationType);
 ElementTypePtr CreateNewElement (DataTypePtr, ElementTypePtr,
 				 FontTypePtr, FlagType, char *, char *,
diff --git a/src/crosshair.c b/src/crosshair.c
index cea493a..d75cfbe 100644
--- a/src/crosshair.c
+++ b/src/crosshair.c
@@ -77,6 +77,7 @@ static int CrosshairStackLocation = 0;
  * some local prototypes
  */
 static void XORPolygon (PolygonTypePtr, LocationType, LocationType);
+static void XORPour (PourTypePtr, LocationType, LocationType);
 static void XORDrawElement (ElementTypePtr, LocationType, LocationType);
 static void XORDrawBuffer (BufferTypePtr);
 static void XORDrawInsertPointObject (void);
@@ -92,6 +93,8 @@ static void XORDrawAttachedArc (BDimension);
 static void
 XORPolygon (PolygonTypePtr polygon, LocationType dx, LocationType dy)
 {
+#warning FIXME Later
+#if 0
   int i;
   for (i = 0; i < polygon->PointN - 1; i++)
     gui->draw_line (Crosshair.GC,
@@ -102,6 +105,25 @@ XORPolygon (PolygonTypePtr polygon, LocationType dx, LocationType dy)
     gui->draw_line (Crosshair.GC,
 		    polygon->Points[i].X + dx, polygon->Points[i].Y + dy,
 		    polygon->Points[0].X + dx, polygon->Points[0].Y + dy);
+#endif
+}
+
+/* ---------------------------------------------------------------------------
+ * creates a tmp pour with coordinates converted to screen system
+ */
+static void
+XORPour (PourTypePtr pour, LocationType dx, LocationType dy)
+{
+  int i;
+  for (i = 0; i < pour->PointN - 1; i++)
+    gui->draw_line (Crosshair.GC,
+		    pour->Points[i].X + dx, pour->Points[i].Y + dy,
+		    pour->Points[i + 1].X + dx,
+		    pour->Points[i + 1].Y + dy);
+  if (i > 1)
+    gui->draw_line (Crosshair.GC,
+		    pour->Points[i].X + dx, pour->Points[i].Y + dy,
+		    pour->Points[0].X + dx, pour->Points[0].Y + dy);
 }
 
 /*-----------------------------------------------------------
@@ -350,9 +372,11 @@ XORDrawBuffer (BufferTypePtr Buffer)
 	/* the tmp polygon has n+1 points because the first
 	 * and the last one are set to the same coordinates
 	 */
-	POLYGON_LOOP (layer);
+	POUR_LOOP (layer);
 	{
-	  XORPolygon (polygon, x, y);
+	  XORPour (pour, x, y);
+#warning FIXME Later
+//	  XORPolygon (polygon, x, y);
 	}
 	END_LOOP;
       }
@@ -452,6 +476,18 @@ XORDrawMoveOrCopyObject (void)
 	break;
       }
 
+    case POUR_TYPE:
+      {
+	PourTypePtr pour =
+	  (PourTypePtr) Crosshair.AttachedObject.Ptr2;
+
+	/* the tmp pour has n+1 points because the first
+	 * and the last one are set to the same coordinates
+	 */
+	XORPour (pour, dx, dy);
+	break;
+      }
+
     case LINEPOINT_TYPE:
       {
 	LineTypePtr line;
@@ -470,24 +506,24 @@ XORDrawMoveOrCopyObject (void)
 	break;
       }
 
-    case POLYGONPOINT_TYPE:
+    case POURPOINT_TYPE:
       {
-	PolygonTypePtr polygon;
+	PourTypePtr pour;
 	PointTypePtr point, previous, following;
 
-	polygon = (PolygonTypePtr) Crosshair.AttachedObject.Ptr2;
+	pour = (PourTypePtr) Crosshair.AttachedObject.Ptr2;
 	point = (PointTypePtr) Crosshair.AttachedObject.Ptr3;
 
 	/* get previous and following point */
-	if (point == polygon->Points)
+	if (point == pour->Points)
 	  {
-	    previous = &polygon->Points[polygon->PointN - 1];
+	    previous = &pour->Points[pour->PointN - 1];
 	    following = point + 1;
 	  }
-	else if (point == &polygon->Points[polygon->PointN - 1])
+	else if (point == &pour->Points[pour->PointN - 1])
 	  {
 	    previous = point - 1;
-	    following = &polygon->Points[0];
+	    following = &pour->Points[0];
 	  }
 	else
 	  {
@@ -598,8 +634,8 @@ DrawAttached (Boolean BlockToo)
 	}
       break;
 
-      /* the attached line is used by both LINEMODE and POLYGON_MODE */
-    case POLYGON_MODE:
+      /* the attached line is used by both LINEMODE and POUR_MODE */
+    case POUR_MODE:
       /* draw only if starting point is set */
       if (Crosshair.AttachedLine.State != STATE_FIRST)
 	gui->draw_line (Crosshair.GC,
@@ -608,10 +644,10 @@ DrawAttached (Boolean BlockToo)
 			Crosshair.AttachedLine.Point2.X,
 			Crosshair.AttachedLine.Point2.Y);
 
-      /* draw attached polygon only if in POLYGON_MODE */
-      if (Crosshair.AttachedPolygon.PointN > 1)
+      /* draw attached pour only if in POUR_MODE */
+      if (Crosshair.AttachedPour.PointN > 1)
 	{
-	  XORPolygon (&Crosshair.AttachedPolygon, 0, 0);
+	  XORPour (&Crosshair.AttachedPour, 0, 0);
 	}
       break;
 
@@ -988,7 +1024,7 @@ FitCrosshairIntoGrid (LocationType X, LocationType Y)
 
   if (TEST_FLAG (SNAPPINFLAG, PCB))
     ans = SearchScreenGridSlop (Crosshair.X, Crosshair.Y,
-                                POLYGONPOINT_TYPE, &ptr1, &ptr2, &ptr3);
+                                POURPOINT_TYPE, &ptr1, &ptr2, &ptr3);
   else
     ans = NO_TYPE;
 
@@ -1163,6 +1199,6 @@ void
 DestroyCrosshair (void)
 {
   CrosshairOff (True);
-  FreePolygonMemory (&Crosshair.AttachedPolygon);
+  FreePourMemory (&Crosshair.AttachedPour);
   gui->destroy_gc (Crosshair.GC);
 }
diff --git a/src/draw.c b/src/draw.c
index 37055e1..dfe0d46 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -100,6 +100,7 @@ static void DrawPadNameLowLevel (PadTypePtr);
 static void DrawLineLowLevel (LineTypePtr, Boolean);
 /* static */ void DrawRegularText (LayerTypePtr, TextTypePtr, int);
 static void DrawPolygonLowLevel (PolygonTypePtr);
+static void DrawPourLowLevel (PourTypePtr);
 static void DrawArcLowLevel (ArcTypePtr);
 static void DrawElementPackageLowLevel (ElementTypePtr Element, int);
 static void DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon);
@@ -677,6 +678,7 @@ struct pin_info
 {
   Boolean arg;
   LayerTypePtr Layer;
+  const BoxType * clip;
 };
 
 /* static */ int
@@ -688,12 +690,32 @@ clearPin_callback (const BoxType * b, void *cl)
     ClearOnlyPin (pin, True);
   return 1;
 }
+
 static int
 poly_callback (const BoxType * b, void *cl)
 {
   struct pin_info *i = (struct pin_info *) cl;
 
+//  printf ("Got one poly callback, %p\n", b);
   DrawPlainPolygon (i->Layer, (PolygonTypePtr) b);
+
+  return 1;
+}
+
+static int
+pour_callback (const BoxType * b, void *cl)
+{
+  struct pin_info *i = (struct pin_info *) cl;
+  PourType *pour = (PourType *)b;
+
+  if (gui->gui)
+    DrawPour (i->Layer, pour, 0);
+
+  if (pour->PolygonN)
+    {
+      r_search (pour->polygon_tree, i->clip, NULL, poly_callback, i);
+    }
+
   return 1;
 }
 
@@ -769,6 +791,7 @@ DrawMask (BoxType * screen)
   OutputType *out = &Output;
 
   info.arg = True;
+  info.clip = screen;
 
   if (thin)
     gui->set_color (Output.pmGC, PCB->MaskColor);
@@ -867,8 +890,9 @@ DrawLayer (LayerTypePtr Layer, const BoxType * screen)
   /* print the non-clearing polys */
   info.Layer = Layer;
   info.arg = False;
+  info.clip = screen;
   clip_box = screen;
-  r_search (Layer->polygon_tree, screen, NULL, poly_callback, &info);
+  r_search (Layer->pour_tree, screen, NULL, pour_callback, &info);
 
   /* draw all visible lines this layer */
   r_search (Layer->line_tree, screen, NULL, line_callback, Layer);
@@ -906,13 +930,13 @@ DrawLayerGroup (int group, const BoxType * screen)
 	rv = 0;
       if (layernum < max_layer && Layer->On)
 	{
-	  /* draw all polygons on this layer */
-	  if (Layer->PolygonN)
+	  /* draw all pours on this layer */
+	  if (Layer->PourN)
 	    {
 	      info.Layer = Layer;
 	      info.arg = True;
-	      r_search (Layer->polygon_tree, screen, NULL, poly_callback,
-			&info);
+	      info.clip = screen;
+	      r_search (Layer->pour_tree, screen, NULL, pour_callback, &info);
 	      info.arg = False;
 
 	      /* HACK: Subcomposite polygons separately from other layer primitives */
@@ -1657,6 +1681,48 @@ DrawPolygonLowLevel (PolygonTypePtr Polygon)
 }
 
 /* ---------------------------------------------------------------------------
+ * lowlevel drawing routine for pours
+ */
+static void
+DrawPourLowLevel (PourTypePtr Pour)
+{
+  int *x, *y, n, i;
+
+  if (Gathering)
+    {
+      AddPart (Pour);
+      return;
+    }
+
+  n = Pour->PointN;
+  x = (int *) malloc (n * sizeof (int));
+  y = (int *) malloc (n * sizeof (int));
+  for (i = 0; i < n; i++)
+    {
+      x[i] = Pour->Points[i].X;
+      y[i] = Pour->Points[i].Y;
+    }
+
+//  if (TEST_FLAG (THINDRAWFLAG, PCB) ||
+//      TEST_FLAG (THINDRAWPOLYFLAG, PCB) ||
+//      TEST_FLAG (CLEARLINEFLAG, Pour))
+  if (1)
+    {
+      gui->set_line_width (Output.fgGC, 2);
+//      gui->set_line_width (Output.fgGC, 1);
+      for (i = 0; i < n - 1; i++)
+        {
+          gui->draw_line (Output.fgGC, x[i], y[i], x[i + 1], y[i + 1]);
+        }
+      gui->draw_line (Output.fgGC, x[n - 1], y[n - 1], x[0], y[0]);
+    }
+  else
+    gui->fill_polygon (Output.fgGC, n, x, y);
+  free (x);
+  free (y);
+}
+
+/* ---------------------------------------------------------------------------
  * lowlevel routine to element arcs
  */
 static void
@@ -1975,6 +2041,37 @@ DrawPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon, int unused)
   DrawPolygonLowLevel (Polygon);
 }
 
+/* ---------------------------------------------------------------------------
+ * draws a pour on a layer
+ */
+void
+DrawPour (LayerTypePtr Layer, PourTypePtr Pour, int unused)
+{
+  int layernum;
+
+  if (TEST_FLAG (SELECTEDFLAG | FOUNDFLAG, Pour))
+    {
+      if (TEST_FLAG (SELECTEDFLAG, Pour))
+	gui->set_color (Output.fgGC, Layer->SelectedColor);
+      else
+	gui->set_color (Output.fgGC, PCB->ConnectedColor);
+    }
+  else
+    gui->set_color (Output.fgGC, Layer->Color);
+  layernum = GetLayerNumber (PCB->Data, Layer);
+  DrawPourLowLevel (Pour);
+#warning FIXME Later
+#if 0
+  if (TEST_FLAG (CLEARPOLYFLAG, Pour))
+    {
+      r_search (PCB->Data->pin_tree, &Pour->BoundingBox, NULL,
+		cp_callback, (void *) PIN_TYPE);
+      r_search (PCB->Data->via_tree, &Pour->BoundingBox, NULL,
+		cp_callback, (void *) VIA_TYPE);
+    }
+#endif
+}
+
 int
 thin_callback (PLINE * pl, LayerTypePtr lay, PolygonTypePtr poly)
 {
@@ -2279,6 +2376,18 @@ ErasePolygon (PolygonTypePtr Polygon)
 }
 
 /* ---------------------------------------------------------------------------
+ * erases a pour on a layer
+ */
+void
+ErasePour (PourTypePtr Pour)
+{
+  Erasing++;
+  gui->set_color (Output.fgGC, Settings.BackgroundColor);
+  DrawPourLowLevel (Pour);
+  Erasing--;
+}
+
+/* ---------------------------------------------------------------------------
  * erases an element
  */
 void
@@ -2359,6 +2468,9 @@ EraseObject (int type, void *lptr, void *ptr)
     case POLYGON_TYPE:
       ErasePolygon ((PolygonTypePtr) ptr);
       break;
+    case POUR_TYPE:
+      ErasePour ((PourTypePtr) ptr);
+      break;
     case ELEMENT_TYPE:
       EraseElement ((ElementTypePtr) ptr);
       break;
@@ -2406,6 +2518,10 @@ DrawObject (int type, void *ptr1, void *ptr2, int unused)
       if (((LayerTypePtr) ptr1)->On)
 	DrawPolygon ((LayerTypePtr) ptr1, (PolygonTypePtr) ptr2, 0);
       break;
+    case POUR_TYPE:
+      if (((LayerTypePtr) ptr1)->On)
+	DrawPour ((LayerTypePtr) ptr1, (PourTypePtr) ptr2, 0);
+      break;
     case ELEMENT_TYPE:
       if (PCB->ElementOn &&
 	  (FRONT ((ElementTypePtr) ptr2) || PCB->InvisibleObjectsOn))
diff --git a/src/draw.h b/src/draw.h
index e87f88c..05c3856 100644
--- a/src/draw.h
+++ b/src/draw.h
@@ -50,6 +50,7 @@ void DrawArc (LayerTypePtr, ArcTypePtr, int);
 void DrawText (LayerTypePtr, TextTypePtr, int);
 void DrawTextLowLevel (TextTypePtr, int);
 void DrawPolygon (LayerTypePtr, PolygonTypePtr, int);
+void DrawPour (LayerTypePtr, PourTypePtr, int);
 void DrawElement (ElementTypePtr, int);
 void DrawElementName (ElementTypePtr, int);
 void DrawElementPackage (ElementTypePtr, int);
@@ -67,6 +68,7 @@ void EraseLine (LineTypePtr);
 void EraseArc (ArcTypePtr);
 void EraseText (LayerTypePtr, TextTypePtr);
 void ErasePolygon (PolygonTypePtr);
+void ErasePour (PourTypePtr);
 void EraseElement (ElementTypePtr);
 void EraseElementPinsAndPads (ElementTypePtr);
 void EraseElementName (ElementTypePtr);
diff --git a/src/file.c b/src/file.c
index 639c971..cc6a964 100644
--- a/src/file.c
+++ b/src/file.c
@@ -786,7 +786,7 @@ WriteLayerData (FILE * FP, Cardinal Number, LayerTypePtr layer)
 {
   int n;
   /* write information about non empty layers */
-  if (layer->LineN || layer->ArcN || layer->TextN || layer->PolygonN ||
+  if (layer->LineN || layer->ArcN || layer->TextN || layer->PourN ||
       (layer->Name && *layer->Name))
     {
       fprintf (FP, "Layer(%i ", (int) Number + 1);
@@ -821,14 +821,14 @@ WriteLayerData (FILE * FP, Cardinal Number, LayerTypePtr layer)
 	  PrintQuotedString (FP, EMPTY (text->TextString));
 	  fprintf (FP, " %s]\n", F2S (text, TEXT_TYPE));
 	}
-      for (n = 0; n < layer->PolygonN; n++)
+      for (n = 0; n < layer->PourN; n++)
 	{
-	  PolygonTypePtr polygon = &layer->Polygon[n];
+	  PourTypePtr pour = &layer->Pour[n];
 	  int p, i = 0;
-	  fprintf (FP, "\tPolygon(%s)\n\t(", F2S (polygon, POLYGON_TYPE));
-	  for (p = 0; p < polygon->PointN; p++)
+	  fprintf (FP, "\tPolygon(%s)\n\t(", F2S (pour, POUR_TYPE));
+	  for (p = 0; p < pour->PointN; p++)
 	    {
-	      PointTypePtr point = &polygon->Points[p];
+	      PointTypePtr point = &pour->Points[p];
 	      if (i++ % 5 == 0)
 		fputs ("\n\t\t", FP);
 	      fprintf (FP, "[%i %i] ", (int) point->X, (int) point->Y);
diff --git a/src/find.c b/src/find.c
index b1b0211..0bef8fe 100644
--- a/src/find.c
+++ b/src/find.c
@@ -628,6 +628,7 @@ void
 InitLayoutLookup (void)
 {
   Cardinal i;
+  int polycount;
 
   /* initialize line arc and polygon data */
   for (i = 0; i < max_layer; i++)
@@ -652,12 +653,18 @@ InitLayoutLookup (void)
 
 
       /* allocate memory for polygon list */
-      if (layer->PolygonN)
+      polycount = 0;
+      POUR_LOOP (layer);
+      {
+        polycount += pour->PolygonN;
+      }
+      END_LOOP;
+      if (polycount)
         {
-          PolygonList[i].Data = (void **) MyCalloc (layer->PolygonN,
+          PolygonList[i].Data = (void **) MyCalloc (polycount,
                                                     sizeof (PolygonTypePtr),
                                                     "InitLayoutLookup()");
-          PolygonList[i].Size = layer->PolygonN;
+          PolygonList[i].Size = polycount;
         }
 
       /* clear some struct members */
@@ -799,6 +806,16 @@ LOCtoPVpoly_callback (const BoxType * b, void *cl)
   return 0;
 }
 
+static int
+LOCtoPVpourPoly_callback (const BoxType * b, void *cl)
+{
+  PourTypePtr pour = (PourTypePtr) b;
+  struct pv_info *i = (struct pv_info *) cl;
+
+  return r_search (pour->polygon_tree, (BoxType *) &i->pv,
+                   NULL, LOCtoPVpoly_callback, i);
+}
+
 /* ---------------------------------------------------------------------------
  * checks if a PV is connected to LOs, if it is, the LO is added to
  * the appropriate list and the 'used' flag is set
@@ -841,8 +858,8 @@ LookupLOConnectionsToPVList (Boolean AndRats)
             return True;
           /* check all polygons */
           if (setjmp (info.env) == 0)
-            r_search (LAYER_PTR (layer)->polygon_tree, (BoxType *) & info.pv,
-                      NULL, LOCtoPVpoly_callback, &info);
+            r_search (LAYER_PTR (layer)->pour_tree, (BoxType *) & info.pv,
+                      NULL, LOCtoPVpourPoly_callback, &info);
           else
             return True;
         }
@@ -1939,15 +1956,13 @@ LookupLOConnectionsToArc (ArcTypePtr Arc, Cardinal LayerGroup)
   /* loop over all layers of the group */
   for (entry = 0; entry < PCB->LayerGroups.Number[LayerGroup]; entry++)
     {
-      Cardinal layer, i;
+      Cardinal layer;
 
       layer = PCB->LayerGroups.Entries[LayerGroup][entry];
 
       /* handle normal layers */
       if (layer < max_layer)
         {
-          PolygonTypePtr polygon;
-
           info.layer = layer;
           /* add arcs */
           if (setjmp (info.env) == 0)
@@ -1963,12 +1978,18 @@ LookupLOConnectionsToArc (ArcTypePtr Arc, Cardinal LayerGroup)
             return True;
 
           /* now check all polygons */
-          i = 0;
-          polygon = PCB->Data->Layer[layer].Polygon;
-          for (; i < PCB->Data->Layer[layer].PolygonN; i++, polygon++)
-            if (!TEST_FLAG (TheFlag, polygon) && IsArcInPolygon (Arc, polygon)
-                && ADD_POLYGON_TO_LIST (layer, polygon))
-              return True;
+          POUR_LOOP (LAYER_PTR (layer));
+          {
+            POURPOLYGON_LOOP (pour);
+            {
+              if (!TEST_FLAG (TheFlag, polygon) &&
+                  IsArcInPolygon (Arc, polygon) &&
+                  ADD_POLYGON_TO_LIST (layer, polygon))
+                return True;
+            }
+            END_LOOP;
+          }
+          END_LOOP;
         }
       else
         {
@@ -2084,8 +2105,6 @@ LookupLOConnectionsToLine (LineTypePtr Line, Cardinal LayerGroup,
       /* handle normal layers */
       if (layer < max_layer)
         {
-          PolygonTypePtr polygon;
-
           info.layer = layer;
           /* add lines */
           if (setjmp (info.env) == 0)
@@ -2102,13 +2121,18 @@ LookupLOConnectionsToLine (LineTypePtr Line, Cardinal LayerGroup,
           /* now check all polygons */
           if (PolysTo)
             {
-              Cardinal i = 0;
-              polygon = PCB->Data->Layer[layer].Polygon;
-              for (; i < PCB->Data->Layer[layer].PolygonN; i++, polygon++)
-                if (!TEST_FLAG
-                    (TheFlag, polygon) && IsLineInPolygon (Line, polygon)
-                    && ADD_POLYGON_TO_LIST (layer, polygon))
-                  return True;
+              POUR_LOOP (LAYER_PTR (layer));
+              {
+                POURPOLYGON_LOOP (pour);
+                {
+                  if (!TEST_FLAG (TheFlag, polygon) &&
+                      IsLineInPolygon (Line, polygon) &&
+                      ADD_POLYGON_TO_LIST (layer, polygon))
+                    return True;
+                }
+                END_LOOP;
+              }
+              END_LOOP;
             }
         }
       else
@@ -2166,7 +2190,6 @@ static Boolean
 LOTouchesLine (LineTypePtr Line, Cardinal LayerGroup)
 {
   Cardinal entry;
-  Cardinal i;
   struct lo_info info;
 
 
@@ -2183,8 +2206,6 @@ LOTouchesLine (LineTypePtr Line, Cardinal LayerGroup)
       /* handle normal layers */
       if (layer < max_layer)
         {
-          PolygonTypePtr polygon;
-
           /* find the first line that touches coordinates */
 
           if (setjmp (info.env) == 0)
@@ -2199,12 +2220,17 @@ LOTouchesLine (LineTypePtr Line, Cardinal LayerGroup)
             return (True);
 
           /* now check all polygons */
-          i = 0;
-          polygon = PCB->Data->Layer[layer].Polygon;
-          for (; i < PCB->Data->Layer[layer].PolygonN; i++, polygon++)
-            if (!TEST_FLAG (TheFlag, polygon)
-                && IsLineInPolygon (Line, polygon))
-              return (True);
+          POUR_LOOP (LAYER_PTR (layer));
+          {
+            POURPOLYGON_LOOP (pour);
+            {
+              if (!TEST_FLAG (TheFlag, polygon) &&
+                  IsLineInPolygon (Line, polygon))
+                return (True);
+            }
+            END_LOOP;
+          }
+          END_LOOP;
         }
       else
         {
@@ -2260,6 +2286,16 @@ PolygonToRat_callback (const BoxType * b, void *cl)
 }
 
 static int
+PourPolygonToRat_callback (const BoxType * b, void *cl)
+{
+  PourTypePtr pour = (PourTypePtr) b;
+  struct rat_info *i = (struct rat_info *) cl;
+
+  return r_search_pt (pour->polygon_tree, i->Point, 1,
+                      NULL, PolygonToRat_callback, i);
+}
+
+static int
 LOCtoPad_callback (const BoxType * b, void *cl)
 {
   PadTypePtr pad = (PadTypePtr) b;
@@ -2310,8 +2346,8 @@ LookupLOConnectionsToRatEnd (PointTypePtr Point, Cardinal LayerGroup)
           else
             return True;
           if (setjmp (info.env) == 0)
-            r_search_pt (LAYER_PTR (layer)->polygon_tree, Point, 1,
-                      NULL, PolygonToRat_callback, &info);
+            r_search_pt (LAYER_PTR (layer)->pour_tree, Point, 1,
+                      NULL, PourPolygonToRat_callback, &info);
         }
       else
         {
@@ -2375,6 +2411,16 @@ LOCtoPadPoly_callback (const BoxType * b, void *cl)
 }
 
 static int
+LOCtoPadPourPoly_callback (const BoxType * b, void *cl)
+{
+  PourTypePtr pour = (PourTypePtr) b;
+  struct lo_info *i = (struct lo_info *) cl;
+
+  return r_search (pour->polygon_tree, &i->pad.BoundingBox,
+                   NULL, LOCtoPadPoly_callback, i);
+}
+
+static int
 LOCtoPadRat_callback (const BoxType * b, void *cl)
 {
   RatTypePtr rat = (RatTypePtr) b;
@@ -2464,8 +2510,8 @@ LookupLOConnectionsToPad (PadTypePtr Pad, Cardinal LayerGroup)
             return True;
           /* add polygons */
           if (setjmp (info.env) == 0)
-            r_search (LAYER_PTR (layer)->polygon_tree, &info.pad.BoundingBox,
-                      NULL, LOCtoPadPoly_callback, &info);
+            r_search (LAYER_PTR (layer)->pour_tree, &info.pad.BoundingBox,
+                      NULL, LOCtoPadPourPoly_callback, &info);
           else
             return True;
         }
@@ -2575,25 +2621,30 @@ LookupLOConnectionsToPolygon (PolygonTypePtr Polygon, Cardinal LayerGroup)
 /* loop over all layers of the group */
   for (entry = 0; entry < PCB->LayerGroups.Number[LayerGroup]; entry++)
     {
-      Cardinal layer, i;
+      Cardinal layer;
 
       layer = PCB->LayerGroups.Entries[LayerGroup][entry];
 
       /* handle normal layers */
       if (layer < max_layer)
         {
-          PolygonTypePtr polygon;
+          info.layer = layer;
 
           /* check all polygons */
 
-          polygon = PCB->Data->Layer[layer].Polygon;
-          for (i = 0; i < PCB->Data->Layer[layer].PolygonN; i++, polygon++)
-            if (!TEST_FLAG (TheFlag, polygon)
-                && IsPolygonInPolygon (polygon, Polygon)
-                && ADD_POLYGON_TO_LIST (layer, polygon))
-              return True;
+          POUR_LOOP (LAYER_PTR (layer));
+          {
+            POURPOLYGON_LOOP (pour);
+            {
+              if (!TEST_FLAG (TheFlag, polygon) &&
+                  IsPolygonInPolygon (polygon, Polygon) &&
+                  ADD_POLYGON_TO_LIST (layer, polygon))
+                return True;
+            }
+            END_LOOP;
+          }
+          END_LOOP;
 
-          info.layer = layer;
           /* check all lines */
           if (setjmp (info.env) == 0)
             r_search (LAYER_PTR (layer)->line_tree,
@@ -3555,17 +3606,21 @@ ResetFoundLinesAndPolygons (Boolean AndDraw)
       }
   }
   ENDALL_LOOP;
-  COPPERPOLYGON_LOOP (PCB->Data);
+  COPPERPOUR_LOOP (PCB->Data);
   {
-    if (TEST_FLAG (TheFlag, polygon))
-      {
-        if (AndDraw)
-          AddObjectToFlagUndoList (POLYGON_TYPE, layer, polygon, polygon);
-        CLEAR_FLAG (TheFlag, polygon);
-        if (AndDraw)
-          DrawPolygon (layer, polygon, 0);
-        change = True;
-      }
+    POURPOLYGON_LOOP (pour);
+    {
+      if (TEST_FLAG (TheFlag, polygon))
+        {
+          if (AndDraw)
+            AddObjectToFlagUndoList (POLYGON_TYPE, layer, polygon, polygon);
+          CLEAR_FLAG (TheFlag, polygon);
+          if (AndDraw)
+            DrawPolygon (layer, polygon, 0);
+          change = True;
+        }
+    }
+    END_LOOP;
   }
   ENDALL_LOOP;
   if (change)
diff --git a/src/find.h b/src/find.h
index c6e6eef..aae9d89 100644
--- a/src/find.h
+++ b/src/find.h
@@ -42,7 +42,7 @@
 #define LOOKUP_MORE	\
 	(VIA_TYPE | LINE_TYPE | RATLINE_TYPE | POLYGON_TYPE | ARC_TYPE)
 #define SILK_TYPE	\
-	(LINE_TYPE | ARC_TYPE | POLYGON_TYPE)
+	(LINE_TYPE | ARC_TYPE | POUR_TYPE)
 
 Boolean LineLineIntersect (LineTypePtr, LineTypePtr);
 Boolean LineArcIntersect (LineTypePtr, ArcTypePtr);
diff --git a/src/flags.c b/src/flags.c
index c6c7458..5ae97c3 100644
--- a/src/flags.c
+++ b/src/flags.c
@@ -191,7 +191,8 @@ HID_Flag flags_flag_list[] = {
   {"lockmode", FlagMode, LOCK_MODE},
   {"movemode", FlagMode, MOVE_MODE},
   {"pastebuffermode", FlagMode, PASTEBUFFER_MODE},
-  {"polygonmode", FlagMode, POLYGON_MODE},
+//  {"polygonmode", FlagMode, POLYGON_MODE},
+  {"pourmode", FlagMode, POUR_MODE},
   {"rectanglemode", FlagMode, RECTANGLE_MODE},
   {"removemode", FlagMode, REMOVE_MODE},
   {"rotatemode", FlagMode, ROTATE_MODE},
diff --git a/src/global.h b/src/global.h
index 1082dd1..d9a4e62 100644
--- a/src/global.h
+++ b/src/global.h
@@ -237,15 +237,41 @@ typedef struct
   void *Element;
 } TextType, *TextTypePtr;
 
-struct polygon_st			/* holds information about a polygon */
+struct rtree
+{
+  struct rtree_node *root;
+  int size;			/* number of entries in tree */
+};
+
+typedef struct			/* holds information about a polygon */
+{
+  ANYOBJECTFIELDS;
+
+  Cardinal PointN;		/* number of points in pour outline */
+  Cardinal PointMax;		/* max number from malloc() */
+  PointTypePtr Points;		/* pour outline data */
+
+  Cardinal PolygonN;		/* number of polygons this pour has */
+  Cardinal PolygonMax;		/* max number from malloc() */
+  PolygonTypePtr Polygons;	/* pour polygons */
+
+  rtree_t *polygon_tree;	/* r-tree of child polygons */
+
+} PourType, *PourTypePtr;
+
+struct polygon_st		/* holds information about a polygon */
 {
   ANYOBJECTFIELDS;
-  Cardinal PointN,		/* number of points in polygon */
-    PointMax;			/* max number from malloc() */
+
+//  Cardinal PointN,		/* number of points in polygon */
+//  Cardinal PointMax;		/* max number from malloc() */
+//  PointTypePtr Points;		/* data */
+
   POLYAREA *Clipped;		/* the clipped region of this polygon */
-  PLINE *NoHoles;		/* the polygon broken into hole-less regions */
+  PLINE *NoHoles;		/* the clipped polygon broken into hole-less regions */
   int NoHolesValid;		/* Is the NoHoles polygon up to date? */
-  PointTypePtr Points;		/* data */
+
+  PourTypePtr ParentPour;	/* The pour which resulted in this polygon */
 };
 
 typedef struct			/* holds information about arcs */
@@ -259,26 +285,25 @@ typedef struct			/* holds information about arcs */
     Delta;
 } ArcType, *ArcTypePtr;
 
-struct rtree
-{
-  struct rtree_node *root;
-  int size;			/* number of entries in tree */
-};
-
 typedef struct			/* holds information about one layer */
 {
   char *Name;			/* layer name */
   Cardinal LineN,		/* number of lines */
     TextN,			/* labels */
-    PolygonN,			/* polygons */
+//    PolygonN,			/* polygons */
+    PourN,			/* poured areas */
     ArcN,			/* and arcs */
     LineMax,			/* max number from malloc() */
-    TextMax, PolygonMax, ArcMax;
+    TextMax,
+//    PolygonMax,
+    PourMax,
+    ArcMax;
   LineTypePtr Line;		/* pointer to additional structures */
   TextTypePtr Text;
-  PolygonTypePtr Polygon;
+//  PolygonTypePtr Polygon;
+  PourTypePtr Pour;
   ArcTypePtr Arc;
-  rtree_t *line_tree, *text_tree, *polygon_tree, *arc_tree;
+  rtree_t *line_tree, *text_tree, *pour_tree, *arc_tree;
   Boolean On;			/* visible flag */
   char *Color,			/* color */
    *SelectedColor;
@@ -563,7 +588,8 @@ typedef struct			/* holds cursor information */
   Boolean On;			/* flag for 'is visible' */
   AttachedLineType AttachedLine;	/* data of new lines... */
   AttachedBoxType AttachedBox;
-  PolygonType AttachedPolygon;
+//  PolygonType AttachedPolygon;
+  PourType AttachedPour;
   AttachedObjectType AttachedObject;	/* data of attached objects */
   enum crosshair_shape shape; /* shape of crosshair */
 } CrosshairType, *CrosshairTypePtr;
@@ -678,13 +704,15 @@ typedef struct
   void *(*Line) (LayerTypePtr, LineTypePtr);
   void *(*Text) (LayerTypePtr, TextTypePtr);
   void *(*Polygon) (LayerTypePtr, PolygonTypePtr);
+  void *(*Pour) (LayerTypePtr, PourTypePtr);
   void *(*Via) (PinTypePtr);
   void *(*Element) (ElementTypePtr);
   void *(*ElementName) (ElementTypePtr);
   void *(*Pin) (ElementTypePtr, PinTypePtr);
   void *(*Pad) (ElementTypePtr, PadTypePtr);
   void *(*LinePoint) (LayerTypePtr, LineTypePtr, PointTypePtr);
-  void *(*Point) (LayerTypePtr, PolygonTypePtr, PointTypePtr);
+//  void *(*PolygonPoint) (LayerTypePtr, PolygonTypePtr, PointTypePtr);
+  void *(*PourPoint) (LayerTypePtr, PourTypePtr, PointTypePtr);
   void *(*Arc) (LayerTypePtr, ArcTypePtr);
   void *(*Rat) (RatTypePtr);
 } ObjectFunctionType, *ObjectFunctionTypePtr;
diff --git a/src/gpcb-menu.res b/src/gpcb-menu.res
index 1511e09..14ec444 100644
--- a/src/gpcb-menu.res
+++ b/src/gpcb-menu.res
@@ -509,7 +509,7 @@ PopupMenus =
        {"Arc" checked=arcmode,1 Mode(Arc) a={"F3" "<Key>F3"}}
        {"Text" checked=textmode,1 Mode(Text) a={"F4" "<Key>F4"}}
        {"Rectangle" checked=rectanglemode,1 Mode(Rectangle) a={"F5" "<Key>F5"}}
-       {"Polygon" checked=polygonmode,1 Mode(Polygon) a={"F6" "<Key>F6"}}
+       {"Polygon" checked=pourmode,1 Mode(Pour) a={"F6" "<Key>F6"}}
        {"Buffer" checked=pastebuffermode,1 Mode(PasteBuffer) a={"F7" "<Key>F7"}}
        {"Remove" checked=removemode,1 Mode(Remove) a={"F8" "<Key>F8"}}
        {"Rotate" checked=rotatemode,1 Mode(Rotate) a={"F9" "<Key>F9"}}
diff --git a/src/hid/gerber/gerber.c b/src/hid/gerber/gerber.c
index 55d1218..ab6fdb0 100644
--- a/src/hid/gerber/gerber.c
+++ b/src/hid/gerber/gerber.c
@@ -383,7 +383,7 @@ gerber_do_export (HID_Attr_Val * options)
   for (i = 0; i < max_layer; i++)
     {
       LayerType *layer = PCB->Data->Layer + i;
-      if (layer->LineN || layer->TextN || layer->ArcN || layer->PolygonN)
+      if (layer->LineN || layer->TextN || layer->ArcN || layer->PourN)
 	print_group[GetLayerGroupNumberByNumber (i)] = 1;
     }
   print_group[GetLayerGroupNumberByNumber (max_layer)] = 1;
diff --git a/src/hid/gtk/gui-drc-window.c b/src/hid/gtk/gui-drc-window.c
index fa2ec86..d4e8065 100644
--- a/src/hid/gtk/gui-drc-window.c
+++ b/src/hid/gtk/gui-drc-window.c
@@ -166,15 +166,19 @@ unset_found_flags (int AndDraw)
       }
   }
   ENDALL_LOOP;
-  COPPERPOLYGON_LOOP (PCB->Data);
+  COPPERPOUR_LOOP (PCB->Data);
   {
-    if (TEST_FLAG (flag, polygon))
-      {
-	AddObjectToFlagUndoList (POLYGON_TYPE, layer, polygon, polygon);
-	CLEAR_FLAG (flag, polygon);
-	DrawPolygon (layer, polygon, 0);
-	change = True;
-      }
+    POURPOLYGON_LOOP (pour);
+    {
+      if (TEST_FLAG (flag, polygon))
+        {
+          AddObjectToFlagUndoList (POLYGON_TYPE, layer, polygon, polygon);
+          CLEAR_FLAG (flag, polygon);
+          DrawPolygon (layer, polygon, 0);
+          change = True;
+        }
+    }
+    END_LOOP;
   }
   ENDALL_LOOP;
   if (change)
diff --git a/src/hid/gtk/gui-icons-mode-buttons.data b/src/hid/gtk/gui-icons-mode-buttons.data
index 1938ee2..e210157 100644
--- a/src/hid/gtk/gui-icons-mode-buttons.data
+++ b/src/hid/gtk/gui-icons-mode-buttons.data
@@ -252,7 +252,7 @@ static char *pan[] = {
 
 #endif
 /* XPM */
-static char *poly[] = {
+static char *pour[] = {
 /* columns rows colors chars-per-pixel */
 "21 21 4 1",
 "  c black",
diff --git a/src/hid/gtk/gui-misc.c b/src/hid/gtk/gui-misc.c
index e8ad916..e1b6290 100644
--- a/src/hid/gtk/gui-misc.c
+++ b/src/hid/gtk/gui-misc.c
@@ -219,7 +219,7 @@ ghid_mode_cursor (int Mode)
       gport_set_cursor (GDK_LEFT_PTR);
       break;
 
-    case POLYGON_MODE:
+    case POUR_MODE:
       gport_set_cursor (GDK_SB_UP_ARROW);
       break;
 
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index 4e69c74..b95aa6f 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -460,7 +460,7 @@ have_crosshair_attachments (void)
     case VIA_MODE:
       result = TRUE;
       break;
-    case POLYGON_MODE:
+    case POUR_MODE:
       if (Crosshair.AttachedLine.State != STATE_FIRST)
 	result = TRUE;
       break;
diff --git a/src/hid/gtk/gui-top-window.c b/src/hid/gtk/gui-top-window.c
index 0cda4d5..9d02688 100644
--- a/src/hid/gtk/gui-top-window.c
+++ b/src/hid/gtk/gui-top-window.c
@@ -1984,7 +1984,8 @@ static ModeButton mode_buttons[] = {
   {NULL, NULL, NULL, "arc", ARC_MODE, arc},
   {NULL, NULL, NULL, "text", TEXT_MODE, text},
   {NULL, NULL, NULL, "rectangle", RECTANGLE_MODE, rect},
-  {NULL, NULL, NULL, "polygon", POLYGON_MODE, poly},
+  {NULL, NULL, NULL, "pour", POUR_MODE, pour},
+//  {NULL, NULL, NULL, "polygon", POLYGON_MODE, poly},
   {NULL, NULL, NULL, "buffer", PASTEBUFFER_MODE, buf},
   {NULL, NULL, NULL, "remove", REMOVE_MODE, del},
   {NULL, NULL, NULL, "rotate", ROTATE_MODE, rot},
diff --git a/src/hid/nelma/nelma.c b/src/hid/nelma/nelma.c
index c2f6ddf..7303953 100644
--- a/src/hid/nelma/nelma.c
+++ b/src/hid/nelma/nelma.c
@@ -526,7 +526,7 @@ nelma_choose_groups()
 		layer = &PCB->Data->Layer[n];
 
 		if (layer->LineN || layer->TextN || layer->ArcN ||
-		    layer->PolygonN) {
+		    layer->PourN) {
 			/* layer isn't empty */
 
 			/*
diff --git a/src/hid/png/png.c b/src/hid/png/png.c
index 0c292cd..46bd92b 100644
--- a/src/hid/png/png.c
+++ b/src/hid/png/png.c
@@ -333,7 +333,7 @@ png_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
   for (i = 0; i < max_layer; i++)
     {
       LayerType *layer = PCB->Data->Layer + i;
-      if (layer->LineN || layer->TextN || layer->ArcN || layer->PolygonN)
+      if (layer->LineN || layer->TextN || layer->ArcN || layer->PourN)
 	print_group[GetLayerGroupNumberByNumber (i)] = 1;
     }
   print_group[GetLayerGroupNumberByNumber (max_layer)] = 1;
diff --git a/src/hid/ps/eps.c b/src/hid/ps/eps.c
index d67947d..16e0718 100644
--- a/src/hid/ps/eps.c
+++ b/src/hid/ps/eps.c
@@ -150,7 +150,7 @@ eps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
     {
       LayerType *layer = PCB->Data->Layer + i;
       if (layer->On)
-	if (layer->LineN || layer->TextN || layer->ArcN || layer->PolygonN)
+	if (layer->LineN || layer->TextN || layer->ArcN || layer->PourN)
 	  print_group[GetLayerGroupNumberByNumber (i)] = 1;
     }
 
diff --git a/src/hid/ps/ps.c b/src/hid/ps/ps.c
index 6a915f0..0860ca3 100644
--- a/src/hid/ps/ps.c
+++ b/src/hid/ps/ps.c
@@ -481,7 +481,7 @@ ps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
   for (i = 0; i < max_layer; i++)
     {
       LayerType *layer = PCB->Data->Layer + i;
-      if (layer->LineN || layer->TextN || layer->ArcN || layer->PolygonN)
+      if (layer->LineN || layer->TextN || layer->ArcN || layer->PourN)
 	print_group[GetLayerGroupNumberByNumber (i)] = 1;
 
       if (strcmp (layer->Name, "outline") == 0 ||
diff --git a/src/insert.c b/src/insert.c
index 3d4a2f5..6399fac 100644
--- a/src/insert.c
+++ b/src/insert.c
@@ -46,6 +46,7 @@
 #include "misc.h"
 #include "move.h"
 #include "polygon.h"
+#include "pour.h"
 #include "rtree.h"
 #include "search.h"
 #include "select.h"
@@ -65,7 +66,7 @@ RCSID ("$Id$");
  * some local prototypes
  */
 static void *InsertPointIntoLine (LayerTypePtr, LineTypePtr);
-static void *InsertPointIntoPolygon (LayerTypePtr, PolygonTypePtr);
+static void *InsertPointIntoPour (LayerTypePtr, PourTypePtr);
 static void *InsertPointIntoRat (RatTypePtr);
 
 /* ---------------------------------------------------------------------------
@@ -78,7 +79,8 @@ static Boolean Forcible;
 static ObjectFunctionType InsertFunctions = {
   InsertPointIntoLine,
   NULL,
-  InsertPointIntoPolygon,
+  NULL,
+  InsertPointIntoPour,
   NULL,
   NULL,
   NULL,
@@ -159,10 +161,10 @@ InsertPointIntoLine (LayerTypePtr Layer, LineTypePtr Line)
 }
 
 /* ---------------------------------------------------------------------------
- * inserts a point into a polygon
+ * inserts a point into a pour
  */
 static void *
-InsertPointIntoPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
+InsertPointIntoPour (LayerTypePtr Layer, PourTypePtr Pour)
 {
   PointType save;
   Cardinal n;
@@ -175,34 +177,34 @@ InsertPointIntoPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
        */
       line.Thickness = 0;
       if (InsertAt == 0)
-	line.Point1 = Polygon->Points[Polygon->PointN - 1];
+	line.Point1 = Pour->Points[Pour->PointN - 1];
       else
-	line.Point1 = Polygon->Points[InsertAt - 1];
-      line.Point2 = Polygon->Points[InsertAt];
+	line.Point1 = Pour->Points[InsertAt - 1];
+      line.Point2 = Pour->Points[InsertAt];
       if (IsPointOnLine ((float) InsertX, (float) InsertY, 0.0, &line))
 	return (NULL);
     }
   /*
    * second, shift the points up to make room for the new point
    */
-  ErasePolygon (Polygon);
-  r_delete_entry (Layer->polygon_tree, (BoxTypePtr) Polygon);
-  save = *CreateNewPointInPolygon (Polygon, InsertX, InsertY);
-  for (n = Polygon->PointN - 1; n > InsertAt; n--)
-    Polygon->Points[n] = Polygon->Points[n - 1];
-  Polygon->Points[InsertAt] = save;
+  ErasePour (Pour);
+  r_delete_entry (Layer->pour_tree, (BoxTypePtr) Pour);
+  save = *CreateNewPointInPour (Pour, InsertX, InsertY);
+  for (n = Pour->PointN - 1; n > InsertAt; n--)
+    Pour->Points[n] = Pour->Points[n - 1];
+  Pour->Points[InsertAt] = save;
   SetChangedFlag (True);
-  AddObjectToInsertPointUndoList (POLYGONPOINT_TYPE, Layer, Polygon,
-				  &Polygon->Points[InsertAt]);
-  SetPolygonBoundingBox (Polygon);
-  r_insert_entry (Layer->polygon_tree, (BoxType *) Polygon, 0);
-  InitClip (PCB->Data, Layer, Polygon);
-  if (Forcible || !RemoveExcessPolygonPoints (Layer, Polygon))
+  AddObjectToInsertPointUndoList (POURPOINT_TYPE, Layer, Pour,
+				  &Pour->Points[InsertAt]);
+  SetPourBoundingBox (Pour);
+  r_insert_entry (Layer->pour_tree, (BoxType *) Pour, 0);
+  InitPourClip (PCB->Data, Layer, Pour);
+  if (Forcible || !RemoveExcessPourPoints (Layer, Pour))
     {
-      DrawPolygon (Layer, Polygon, 0);
+      DrawPour (Layer, Pour, 0);
       Draw ();
     }
-  return (&Polygon->Points[InsertAt]);
+  return (&Pour->Points[InsertAt]);
 }
 
 /* ---------------------------------------------------------------------------
diff --git a/src/insert.h b/src/insert.h
index bbe99d5..451d37e 100644
--- a/src/insert.h
+++ b/src/insert.h
@@ -33,7 +33,7 @@
 
 #include "global.h"
 
-#define	INSERT_TYPES	(POLYGON_TYPE | LINE_TYPE | RATLINE_TYPE)
+#define	INSERT_TYPES	(POUR_TYPE | LINE_TYPE | RATLINE_TYPE)
 
 /* ---------------------------------------------------------------------------
  * prototypes
diff --git a/src/macro.h b/src/macro.h
index 819d202..f9200b0 100644
--- a/src/macro.h
+++ b/src/macro.h
@@ -391,19 +391,26 @@ extern int mem_any_set (unsigned char *, int);
 	{						\
 		text = &(layer)->Text[n]
 
-#define	POLYGON_LOOP(layer) do {			\
+#define	POUR_LOOP(layer) do {			\
 	Cardinal		n;			\
-	PolygonTypePtr	polygon;			\
-	for (n = (layer)->PolygonN-1; n != -1; n--)	\
+	PourTypePtr	pour;			\
+	for (n = (layer)->PourN-1; n != -1; n--)	\
 	{						\
-		polygon = &(layer)->Polygon[n]
+		pour = &(layer)->Pour[n]
 
-#define	POLYGONPOINT_LOOP(polygon) do	{	\
+#define	POURPOINT_LOOP(pour) do	{	\
 	Cardinal			n;		\
 	PointTypePtr	point;				\
-	for (n = (polygon)->PointN-1; n != -1; n--)	\
+	for (n = (pour)->PointN-1; n != -1; n--)	\
 	{						\
-		point = &(polygon)->Points[n]
+		point = &(pour)->Points[n]
+
+#define	POURPOLYGON_LOOP(pour) do	{	\
+	Cardinal			n;		\
+	PolygonTypePtr	polygon;				\
+	for (n = (pour)->PolygonN-1; n != -1; n--)	\
+	{						\
+		polygon = &(pour)->Polygons[n]
 
 #define ENDALL_LOOP }} while (0);  }} while (0)
 
@@ -429,12 +436,12 @@ extern int mem_any_set (unsigned char *, int);
 	{ \
 		ARC_LOOP(layer)
 
-#define	ALLPOLYGON_LOOP(top)	do {		\
+#define	ALLPOUR_LOOP(top)	do {		\
 	Cardinal		l;			\
 	LayerTypePtr	layer = (top)->Layer;		\
 	for (l = 0; l < max_layer + 2; l++, layer++)	\
 	{ \
-		POLYGON_LOOP(layer)
+		POUR_LOOP(layer)
 
 #define	COPPERLINE_LOOP(top) do	{		\
 	Cardinal		l;			\
@@ -450,12 +457,12 @@ extern int mem_any_set (unsigned char *, int);
 	{ \
 		ARC_LOOP(layer)
 
-#define	COPPERPOLYGON_LOOP(top) do	{		\
+#define	COPPERPOUR_LOOP(top) do	{		\
 	Cardinal		l;			\
 	LayerTypePtr	layer = (top)->Layer;		\
 	for (l = 0; l < max_layer; l++, layer++)	\
 	{ \
-		POLYGON_LOOP(layer)
+		POUR_LOOP(layer)
 
 #define	SILKLINE_LOOP(top) do	{		\
 	Cardinal		l;			\
@@ -473,13 +480,13 @@ extern int mem_any_set (unsigned char *, int);
 	{ \
 		ARC_LOOP(layer)
 
-#define	SILKPOLYGON_LOOP(top) do	{		\
+#define	SILKPOUR_LOOP(top) do	{		\
 	Cardinal		l;			\
 	LayerTypePtr	layer = (top)->Layer;		\
 	layer += max_layer;				\
 	for (l = 0; l < 2; l++, layer++)		\
 	{ \
-		POLYGON_LOOP(layer)
+		POUR_LOOP(layer)
 
 #define	ALLTEXT_LOOP(top)	do {		\
 	Cardinal		l;			\
@@ -512,13 +519,13 @@ extern int mem_any_set (unsigned char *, int);
                 TEXT_LOOP(layer);                                      \
                   if (TEXT_IS_VISIBLE((board), layer, text))
 
-#define	VISIBLEPOLYGON_LOOP(top) do	{	\
+#define	VISIBLEPOUR_LOOP(top) do	{	\
 	Cardinal		l;			\
 	LayerTypePtr	layer = (top)->Layer;		\
 	for (l = 0; l < max_layer + 2; l++, layer++)	\
 	{ \
 		if (layer->On)				\
-			POLYGON_LOOP(layer)
+			POUR_LOOP(layer)
 
 #define POINTER_LOOP(top) do	{	\
 	Cardinal	n;			\
diff --git a/src/mirror.c b/src/mirror.c
index 7ef7d41..1b76e88 100644
--- a/src/mirror.c
+++ b/src/mirror.c
@@ -46,6 +46,7 @@
 #include "mirror.h"
 #include "misc.h"
 #include "polygon.h"
+#include "pour.h"
 #include "search.h"
 #include "select.h"
 #include "set.h"
@@ -78,14 +79,14 @@ MirrorElementCoordinates (DataTypePtr Data, ElementTypePtr Element,
   END_LOOP;
   PIN_LOOP (Element);
   {
-    RestoreToPolygon (Data, PIN_TYPE, Element, pin);
+    RestoreToPours (Data, PIN_TYPE, Element, pin);
     pin->X = SWAP_X (pin->X);
     pin->Y = SWAP_Y (pin->Y) + yoff;
   }
   END_LOOP;
   PAD_LOOP (Element);
   {
-    RestoreToPolygon (Data, PAD_TYPE, Element, pad);
+    RestoreToPours (Data, PAD_TYPE, Element, pad);
     pad->Point1.X = SWAP_X (pad->Point1.X);
     pad->Point1.Y = SWAP_Y (pad->Point1.Y) + yoff;
     pad->Point2.X = SWAP_X (pad->Point2.X);
@@ -115,5 +116,5 @@ MirrorElementCoordinates (DataTypePtr Data, ElementTypePtr Element,
   TOGGLE_FLAG (ONSOLDERFLAG, Element);
   /* this inserts all of the rtree data too */
   SetElementBoundingBox (Data, Element, &PCB->Font);
-  ClearFromPolygon (Data, ELEMENT_TYPE, Element, Element);
+  ClearFromPours (Data, ELEMENT_TYPE, Element, Element);
 }
diff --git a/src/misc.c b/src/misc.c
index 20048db..574c45b 100644
--- a/src/misc.c
+++ b/src/misc.c
@@ -66,6 +66,7 @@
 #include "misc.h"
 #include "move.h"
 #include "polygon.h"
+#include "pour.h"
 #include "remove.h"
 #include "rtree.h"
 #include "rotate.h"
@@ -242,22 +243,35 @@ SetLineBoundingBox (LineTypePtr Line)
 }
 
 /* ---------------------------------------------------------------------------
- * sets the bounding box of a polygons
+ * sets the bounding box of a polygon
  */
 void
 SetPolygonBoundingBox (PolygonTypePtr Polygon)
 {
-  Polygon->BoundingBox.X1 = Polygon->BoundingBox.Y1 = MAX_COORD;
-  Polygon->BoundingBox.X2 = Polygon->BoundingBox.Y2 = 0;
-  POLYGONPOINT_LOOP (Polygon);
+  PLINE *outer = Polygon->Clipped->contours;
+  Polygon->BoundingBox.X1 = outer->xmin;
+  Polygon->BoundingBox.Y1 = outer->ymin;
+  Polygon->BoundingBox.X2 = outer->xmax;
+  Polygon->BoundingBox.Y2 = outer->ymax;
+}
+
+/* ---------------------------------------------------------------------------
+ * sets the bounding box of a pour
+ */
+void
+SetPourBoundingBox (PourTypePtr Pour)
+{
+  Pour->BoundingBox.X1 = Pour->BoundingBox.Y1 = MAX_COORD;
+  Pour->BoundingBox.X2 = Pour->BoundingBox.Y2 = 0;
+  POURPOINT_LOOP (Pour);
   {
-    MAKEMIN (Polygon->BoundingBox.X1, point->X);
-    MAKEMIN (Polygon->BoundingBox.Y1, point->Y);
-    MAKEMAX (Polygon->BoundingBox.X2, point->X);
-    MAKEMAX (Polygon->BoundingBox.Y2, point->Y);
+    MAKEMIN (Pour->BoundingBox.X1, point->X);
+    MAKEMIN (Pour->BoundingBox.Y1, point->Y);
+    MAKEMAX (Pour->BoundingBox.X2, point->X);
+    MAKEMAX (Pour->BoundingBox.Y2, point->Y);
   }
   /* boxes don't include the lower right corner */
-  close_box(&Polygon->BoundingBox);
+  close_box(&Pour->BoundingBox);
   END_LOOP;
 }
 
@@ -499,7 +513,9 @@ IsDataEmpty (DataTypePtr Data)
     hasNoObjects = hasNoObjects &&
       Data->Layer[i].LineN == 0 &&
       Data->Layer[i].ArcN == 0 &&
-      Data->Layer[i].TextN == 0 && Data->Layer[i].PolygonN == 0;
+      Data->Layer[i].TextN == 0 &&
+      Data->Layer[i].PourN == 0;
+
   return (hasNoObjects);
 }
 
@@ -579,13 +595,17 @@ GetDataBoundingBox (DataTypePtr Data)
     box.Y2 = MAX (box.Y2, text->BoundingBox.Y2);
   }
   ENDALL_LOOP;
-  ALLPOLYGON_LOOP (Data);
-  {
-    box.X1 = MIN (box.X1, polygon->BoundingBox.X1);
-    box.Y1 = MIN (box.Y1, polygon->BoundingBox.Y1);
-    box.X2 = MAX (box.X2, polygon->BoundingBox.X2);
-    box.Y2 = MAX (box.Y2, polygon->BoundingBox.Y2);
-  }
+  ALLPOUR_LOOP (Data);
+    {
+      POURPOLYGON_LOOP (pour);
+      {
+        box.X1 = MIN (box.X1, polygon->BoundingBox.X1);
+        box.Y1 = MIN (box.Y1, polygon->BoundingBox.Y1);
+        box.X2 = MAX (box.X2, polygon->BoundingBox.X2);
+        box.Y2 = MAX (box.Y2, polygon->BoundingBox.Y2);
+      }
+      END_LOOP;
+    }
   ENDALL_LOOP;
   return (IsDataEmpty (Data) ? NULL : &box);
 }
@@ -1223,6 +1243,7 @@ GetObjectBoundingBox (int Type, void *Ptr1, void *Ptr2, void *Ptr3)
     case ARC_TYPE:
     case TEXT_TYPE:
     case POLYGON_TYPE:
+    case POUR_TYPE:
     case PAD_TYPE:
     case PIN_TYPE:
     case ELEMENTNAME_TYPE:
@@ -1230,7 +1251,7 @@ GetObjectBoundingBox (int Type, void *Ptr1, void *Ptr2, void *Ptr3)
     case VIA_TYPE:
     case ELEMENT_TYPE:
       return (BoxType *)Ptr1;
-    case POLYGONPOINT_TYPE:
+    case POURPOINT_TYPE:
     case LINEPOINT_TYPE:
       return (BoxType *)Ptr3;
     default:
@@ -1500,14 +1521,14 @@ ChangeArcAngles (LayerTypePtr Layer, ArcTypePtr a,
       new_da = 360;
       new_sa = 0;
     }
-  RestoreToPolygon (PCB->Data, ARC_TYPE, Layer, a);
+  RestoreToPours (PCB->Data, ARC_TYPE, Layer, a);
   r_delete_entry (Layer->arc_tree, (BoxTypePtr) a);
   AddObjectToChangeAnglesUndoList (ARC_TYPE, a, a, a);
   a->StartAngle = new_sa;
   a->Delta = new_da;
   SetArcBoundingBox (a);
   r_insert_entry (Layer->arc_tree, (BoxTypePtr) a, 0);
-  ClearFromPolygon (PCB->Data, ARC_TYPE, Layer, a);
+  ClearFromPours (PCB->Data, ARC_TYPE, Layer, a);
 }
 
 static char *
@@ -1592,13 +1613,8 @@ GetGridLockCoordinates (int type, void *ptr1,
       *x = ((ElementTypePtr) ptr2)->MarkX;
       *y = ((ElementTypePtr) ptr2)->MarkY;
       break;
-    case POLYGON_TYPE:
-      *x = ((PolygonTypePtr) ptr2)->Points[0].X;
-      *y = ((PolygonTypePtr) ptr2)->Points[0].Y;
-      break;
-
     case LINEPOINT_TYPE:
-    case POLYGONPOINT_TYPE:
+    case POURPOINT_TYPE:
       *x = ((PointTypePtr) ptr3)->X;
       *y = ((PointTypePtr) ptr3)->Y;
       break;
diff --git a/src/misc.h b/src/misc.h
index 3634f9b..1cb3b2c 100644
--- a/src/misc.h
+++ b/src/misc.h
@@ -42,6 +42,7 @@ void SetPointBoundingBox (PointTypePtr);
 void SetPinBoundingBox (PinTypePtr);
 void SetPadBoundingBox (PadTypePtr);
 void SetPolygonBoundingBox (PolygonTypePtr);
+void SetPourBoundingBox (PourTypePtr);
 void SetElementBoundingBox (DataTypePtr, ElementTypePtr, FontTypePtr);
 Boolean IsDataEmpty (DataTypePtr);
 BoxTypePtr GetDataBoundingBox (DataTypePtr);
diff --git a/src/move.c b/src/move.c
index 6f0c82f..7875020 100644
--- a/src/move.c
+++ b/src/move.c
@@ -48,6 +48,7 @@
 #include "move.h"
 #include "mymem.h"
 #include "polygon.h"
+#include "pour.h"
 #include "rtree.h"
 #include "search.h"
 #include "select.h"
@@ -72,14 +73,14 @@ static void *MoveVia (PinTypePtr);
 static void *MoveLine (LayerTypePtr, LineTypePtr);
 static void *MoveArc (LayerTypePtr, ArcTypePtr);
 static void *MoveText (LayerTypePtr, TextTypePtr);
-static void *MovePolygon (LayerTypePtr, PolygonTypePtr);
+static void *MovePour (LayerTypePtr, PourTypePtr);
 static void *MoveLinePoint (LayerTypePtr, LineTypePtr, PointTypePtr);
-static void *MovePolygonPoint (LayerTypePtr, PolygonTypePtr, PointTypePtr);
+static void *MovePourPoint (LayerTypePtr, PourTypePtr, PointTypePtr);
 static void *MoveLineToLayer (LayerTypePtr, LineTypePtr);
 static void *MoveArcToLayer (LayerTypePtr, ArcTypePtr);
 static void *MoveRatToLayer (RatTypePtr);
 static void *MoveTextToLayer (LayerTypePtr, TextTypePtr);
-static void *MovePolygonToLayer (LayerTypePtr, PolygonTypePtr);
+static void *MovePourToLayer (LayerTypePtr, PourTypePtr);
 
 /* ---------------------------------------------------------------------------
  * some local identifiers
@@ -91,14 +92,15 @@ static Boolean MoreToCome;
 static ObjectFunctionType MoveFunctions = {
   MoveLine,
   MoveText,
-  MovePolygon,
+  NULL,
+  MovePour,
   MoveVia,
   MoveElement,
   MoveElementName,
   NULL,
   NULL,
   MoveLinePoint,
-  MovePolygonPoint,
+  MovePourPoint,
   MoveArc,
   NULL
 }, MoveToLayerFunctions =
@@ -106,8 +108,17 @@ static ObjectFunctionType MoveFunctions = {
 {
 MoveLineToLayer,
     MoveTextToLayer,
-    MovePolygonToLayer,
-    NULL, NULL, NULL, NULL, NULL, NULL, NULL, MoveArcToLayer, MoveRatToLayer};
+    NULL,
+    MovePourToLayer,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    MoveArcToLayer,
+    MoveRatToLayer};
 
 /* ---------------------------------------------------------------------------
  * moves a element by +-X and +-Y
@@ -128,13 +139,13 @@ MoveElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
     if (Data)
       {
 	r_delete_entry (Data->pin_tree, (BoxType *) pin);
-	RestoreToPolygon (Data, PIN_TYPE, Element, pin);
+	RestoreToPours (Data, PIN_TYPE, Element, pin);
       }
     MOVE_PIN_LOWLEVEL (pin, DX, DY);
     if (Data)
       {
 	r_insert_entry (Data->pin_tree, (BoxType *) pin, 0);
-	ClearFromPolygon (Data, PIN_TYPE, Element, pin);
+	ClearFromPours (Data, PIN_TYPE, Element, pin);
       }
   }
   END_LOOP;
@@ -143,13 +154,13 @@ MoveElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
     if (Data)
       {
 	r_delete_entry (Data->pad_tree, (BoxType *) pad);
-	RestoreToPolygon (Data, PAD_TYPE, Element, pad);
+	RestoreToPours (Data, PAD_TYPE, Element, pad);
       }
     MOVE_PAD_LOWLEVEL (pad, DX, DY);
     if (Data)
       {
 	r_insert_entry (Data->pad_tree, (BoxType *) pad, 0);
-	ClearFromPolygon (Data, PAD_TYPE, Element, pad);
+	ClearFromPours (Data, PAD_TYPE, Element, pad);
       }
   }
   END_LOOP;
@@ -249,12 +260,12 @@ static void *
 MoveVia (PinTypePtr Via)
 {
   r_delete_entry (PCB->Data->via_tree, (BoxTypePtr) Via);
-  RestoreToPolygon (PCB->Data, VIA_TYPE, Via, Via);
+  RestoreToPours (PCB->Data, VIA_TYPE, Via, Via);
   MOVE_VIA_LOWLEVEL (Via, DeltaX, DeltaY);
   if (PCB->ViaOn)
     EraseVia (Via);
   r_insert_entry (PCB->Data->via_tree, (BoxTypePtr) Via, 0);
-  ClearFromPolygon (PCB->Data, VIA_TYPE, Via, Via);
+  ClearFromPours (PCB->Data, VIA_TYPE, Via, Via);
   if (PCB->ViaOn)
     {
       DrawVia (Via, 0);
@@ -271,11 +282,11 @@ MoveLine (LayerTypePtr Layer, LineTypePtr Line)
 {
   if (Layer->On)
     EraseLine (Line);
-  RestoreToPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+  RestoreToPours (PCB->Data, LINE_TYPE, Layer, Line);
   r_delete_entry (Layer->line_tree, (BoxTypePtr) Line);
   MOVE_LINE_LOWLEVEL (Line, DeltaX, DeltaY);
   r_insert_entry (Layer->line_tree, (BoxTypePtr) Line, 0);
-  ClearFromPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+  ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
   if (Layer->On)
     {
       DrawLine (Layer, Line, 0);
@@ -290,7 +301,7 @@ MoveLine (LayerTypePtr Layer, LineTypePtr Line)
 static void *
 MoveArc (LayerTypePtr Layer, ArcTypePtr Arc)
 {
-  RestoreToPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
+  RestoreToPours (PCB->Data, ARC_TYPE, Layer, Arc);
   r_delete_entry (Layer->arc_tree, (BoxTypePtr) Arc);
   if (Layer->On)
     {
@@ -304,7 +315,7 @@ MoveArc (LayerTypePtr Layer, ArcTypePtr Arc)
       MOVE_ARC_LOWLEVEL (Arc, DeltaX, DeltaY);
     }
   r_insert_entry (Layer->arc_tree, (BoxTypePtr) Arc, 0);
-  ClearFromPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
+  ClearFromPours (PCB->Data, ARC_TYPE, Layer, Arc);
   return (Arc);
 }
 
@@ -314,7 +325,7 @@ MoveArc (LayerTypePtr Layer, ArcTypePtr Arc)
 static void *
 MoveText (LayerTypePtr Layer, TextTypePtr Text)
 {
-  RestoreToPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+  RestoreToPours (PCB->Data, TEXT_TYPE, Layer, Text);
   r_delete_entry (Layer->text_tree, (BoxTypePtr) Text);
   if (Layer->On)
     {
@@ -326,45 +337,45 @@ MoveText (LayerTypePtr Layer, TextTypePtr Text)
   else
     MOVE_TEXT_LOWLEVEL (Text, DeltaX, DeltaY);
   r_insert_entry (Layer->text_tree, (BoxTypePtr) Text, 0);
-  ClearFromPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+  ClearFromPours (PCB->Data, TEXT_TYPE, Layer, Text);
   return (Text);
 }
 
 /* ---------------------------------------------------------------------------
- * low level routine to move a polygon
+ * low level routine to move a pour
  */
 void
-MovePolygonLowLevel (PolygonTypePtr Polygon, LocationType DeltaX,
+MovePourLowLevel (PourTypePtr Pour, LocationType DeltaX,
 		     LocationType DeltaY)
 {
-  POLYGONPOINT_LOOP (Polygon);
+  POURPOINT_LOOP (Pour);
   {
     MOVE (point->X, point->Y, DeltaX, DeltaY);
   }
   END_LOOP;
-  MOVE_BOX_LOWLEVEL (&Polygon->BoundingBox, DeltaX, DeltaY);
+  MOVE_BOX_LOWLEVEL (&Pour->BoundingBox, DeltaX, DeltaY);
 }
 
 /* ---------------------------------------------------------------------------
- * moves a polygon
+ * moves a pour
  */
 static void *
-MovePolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
+MovePour (LayerTypePtr Layer, PourTypePtr Pour)
 {
   if (Layer->On)
     {
-      ErasePolygon (Polygon);
+      ErasePour (Pour);
     }
-  r_delete_entry (Layer->polygon_tree, (BoxType *) Polygon);
-  MovePolygonLowLevel (Polygon, DeltaX, DeltaY);
-  r_insert_entry (Layer->polygon_tree, (BoxType *) Polygon, 0);
-  InitClip (PCB->Data, Layer, Polygon);
+  r_delete_entry (Layer->pour_tree, (BoxType *) Pour);
+  MovePourLowLevel (Pour, DeltaX, DeltaY);
+  r_insert_entry (Layer->pour_tree, (BoxType *) Pour, 0);
+  InitPourClip (PCB->Data, Layer, Pour);
   if (Layer->On)
     {
-      DrawPolygon (Layer, Polygon, 0);
+      DrawPour (Layer, Pour, 0);
       Draw ();
     }
-  return (Polygon);
+  return (Pour);
 }
 
 /* ---------------------------------------------------------------------------
@@ -377,12 +388,12 @@ MoveLinePoint (LayerTypePtr Layer, LineTypePtr Line, PointTypePtr Point)
     {
       if (Layer->On)
 	EraseLine (Line);
-      RestoreToPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+      RestoreToPours (PCB->Data, LINE_TYPE, Layer, Line);
       r_delete_entry (Layer->line_tree, &Line->BoundingBox);
       MOVE (Point->X, Point->Y, DeltaX, DeltaY);
       SetLineBoundingBox (Line);
       r_insert_entry (Layer->line_tree, &Line->BoundingBox, 0);
-      ClearFromPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+      ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
       if (Layer->On)
 	{
 	  DrawLine (Layer, Line, 0);
@@ -408,25 +419,24 @@ MoveLinePoint (LayerTypePtr Layer, LineTypePtr Line, PointTypePtr Point)
 }
 
 /* ---------------------------------------------------------------------------
- * moves a polygon-point
+ * moves a pour-point
  */
 static void *
-MovePolygonPoint (LayerTypePtr Layer, PolygonTypePtr Polygon,
-		  PointTypePtr Point)
+MovePourPoint (LayerTypePtr Layer, PourTypePtr Pour, PointTypePtr Point)
 {
   if (Layer->On)
     {
-      ErasePolygon (Polygon);
+      ErasePour (Pour);
     }
-  r_delete_entry (Layer->polygon_tree, (BoxType *) Polygon);
+  r_delete_entry (Layer->pour_tree, (BoxType *) Pour);
   MOVE (Point->X, Point->Y, DeltaX, DeltaY);
-  SetPolygonBoundingBox (Polygon);
-  r_insert_entry (Layer->polygon_tree, (BoxType *) Polygon, 0);
-  RemoveExcessPolygonPoints (Layer, Polygon);
-  InitClip (PCB->Data, Layer, Polygon);
+  SetPourBoundingBox (Pour);
+  r_insert_entry (Layer->pour_tree, (BoxType *) Pour, 0);
+  RemoveExcessPourPoints (Layer, Pour);
+  InitPourClip (PCB->Data, Layer, Pour);
   if (Layer->On)
     {
-      DrawPolygon (Layer, Polygon, 0);
+      DrawPour (Layer, Pour, 0);
       Draw ();
     }
   return (Point);
@@ -498,11 +508,11 @@ MoveArcToLayer (LayerTypePtr Layer, ArcTypePtr Arc)
   if (((long int) Dest == -1) || Dest == Layer)
     return (Arc);
   AddObjectToMoveToLayerUndoList (ARC_TYPE, Layer, Arc, Arc);
-  RestoreToPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
+  RestoreToPours (PCB->Data, ARC_TYPE, Layer, Arc);
   if (Layer->On)
     EraseArc (Arc);
   new = MoveArcToLayerLowLevel (Layer, Arc, Dest);
-  ClearFromPolygon (PCB->Data, ARC_TYPE, Dest, Arc);
+  ClearFromPours (PCB->Data, ARC_TYPE, Dest, Arc);
   if (Dest->On)
     DrawArc (Dest, new, 0);
   Draw ();
@@ -592,10 +602,10 @@ MoveLineToLayer (LayerTypePtr Layer, LineTypePtr Line)
   AddObjectToMoveToLayerUndoList (LINE_TYPE, Layer, Line, Line);
   if (Layer->On)
     EraseLine (Line);
-  RestoreToPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+  RestoreToPours (PCB->Data, LINE_TYPE, Layer, Line);
   new = MoveLineToLayerLowLevel (Layer, Line, Dest);
   Line = NULL;
-  ClearFromPolygon (PCB->Data, LINE_TYPE, Dest, new);
+  ClearFromPours (PCB->Data, LINE_TYPE, Dest, new);
   if (Dest->On)
     DrawLine (Dest, new, 0);
   Draw ();
@@ -646,7 +656,7 @@ MoveTextToLayerLowLevel (LayerTypePtr Source, TextTypePtr Text,
 {
   TextTypePtr new = GetTextMemory (Destination);
 
-  RestoreToPolygon (PCB->Data, TEXT_TYPE, Source, Text);
+  RestoreToPours (PCB->Data, TEXT_TYPE, Source, Text);
   r_delete_entry (Source->text_tree, (BoxTypePtr) Text);
   /* copy the data and remove it from the former layer */
   *new = *Text;
@@ -664,7 +674,7 @@ MoveTextToLayerLowLevel (LayerTypePtr Source, TextTypePtr Text,
   if (!Destination->text_tree)
     Destination->text_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (Destination->text_tree, (BoxTypePtr) new, 0);
-  ClearFromPolygon (PCB->Data, TEXT_TYPE, Destination, new);
+  ClearFromPours (PCB->Data, TEXT_TYPE, Destination, new);
   return (new);
 }
 
@@ -697,25 +707,25 @@ MoveTextToLayer (LayerTypePtr Layer, TextTypePtr Text)
 }
 
 /* ---------------------------------------------------------------------------
- * moves a polygon between layers; lowlevel routines
+ * moves a pour between layers; lowlevel routines
  */
 void *
-MovePolygonToLayerLowLevel (LayerTypePtr Source, PolygonTypePtr Polygon,
+MovePourToLayerLowLevel (LayerTypePtr Source, PourTypePtr Pour,
 			    LayerTypePtr Destination)
 {
-  PolygonTypePtr new = GetPolygonMemory (Destination);
+  PourTypePtr new = GetPourMemory (Destination);
 
-  r_delete_entry (Source->polygon_tree, (BoxType *) Polygon);
+  r_delete_entry (Source->pour_tree, (BoxType *) Pour);
   /* copy the data and remove it from the former layer */
-  *new = *Polygon;
-  *Polygon = Source->Polygon[--Source->PolygonN];
-  r_substitute (Source->polygon_tree,
-		(BoxType *) & Source->Polygon[Source->PolygonN],
-		(BoxType *) Polygon);
-  memset (&Source->Polygon[Source->PolygonN], 0, sizeof (PolygonType));
-  if (!Destination->polygon_tree)
-    Destination->polygon_tree = r_create_tree (NULL, 0, 0);
-  r_insert_entry (Destination->polygon_tree, (BoxType *) new, 0);
+  *new = *Pour;
+  *Pour = Source->Pour[--Source->PourN];
+  r_substitute (Source->pour_tree,
+		(BoxType *) & Source->Pour[Source->PourN],
+		(BoxType *) Pour);
+  memset (&Source->Pour[Source->PourN], 0, sizeof (PourType));
+  if (!Destination->pour_tree)
+    Destination->pour_tree = r_create_tree (NULL, 0, 0);
+  r_insert_entry (Destination->pour_tree, (BoxType *) new, 0);
   return (new);
 }
 
@@ -745,37 +755,40 @@ mptl_pin_callback (const BoxType *b, void *cl)
 }
 
 /* ---------------------------------------------------------------------------
- * moves a polygon between layers
+ * moves a pour between layers
  */
 static void *
-MovePolygonToLayer (LayerTypePtr Layer, PolygonTypePtr Polygon)
+MovePourToLayer (LayerTypePtr Layer, PourTypePtr Pour)
 {
-  PolygonTypePtr new;
-  struct mptlc d;
+  PourTypePtr new;
+//  struct mptlc d;
 
-  if (TEST_FLAG (LOCKFLAG, Polygon))
+  if (TEST_FLAG (LOCKFLAG, Pour))
     {
       Message (_("Sorry, the object is locked\n"));
       return NULL;
     }
   if (((long int) Dest == -1) || (Layer == Dest))
-    return (Polygon);
-  AddObjectToMoveToLayerUndoList (POLYGON_TYPE, Layer, Polygon, Polygon);
+    return (Pour);
+  AddObjectToMoveToLayerUndoList (POUR_TYPE, Layer, Pour, Pour);
   if (Layer->On)
-    ErasePolygon (Polygon);
-  /* Move all of the thermals with the polygon */
+    ErasePour (Pour);
+#define FIXME Later
+#if 0
+  /* Move all of the thermals with the pour */
   d.snum = GetLayerNumber (PCB->Data, Layer);
   d.dnum = GetLayerNumber (PCB->Data, Dest);
-  d.polygon = Polygon;
+  d.pour = Pour;
   d.type = PIN_TYPE;
-  r_search (PCB->Data->pin_tree, &Polygon->BoundingBox, NULL, mptl_pin_callback, &d);
+  r_search (PCB->Data->pin_tree, &Pour->BoundingBox, NULL, mptl_pin_callback, &d);
   d.type = VIA_TYPE;
-  r_search (PCB->Data->via_tree, &Polygon->BoundingBox, NULL, mptl_pin_callback, &d);
-  new = MovePolygonToLayerLowLevel (Layer, Polygon, Dest);
-  InitClip (PCB->Data, Dest, new);
+  r_search (PCB->Data->via_tree, &Pour->BoundingBox, NULL, mptl_pin_callback, &d);
+#endif
+  new = MovePourToLayerLowLevel (Layer, Pour, Dest);
+  InitPourClip (PCB->Data, Dest, new);
   if (Dest->On)
     {
-      DrawPolygon (Dest, new, 0);
+      DrawPour (Dest, new, 0);
       Draw ();
     }
   return (new);
diff --git a/src/move.h b/src/move.h
index f060ff5..886bf64 100644
--- a/src/move.h
+++ b/src/move.h
@@ -85,15 +85,15 @@
 
 #define	MOVE_TYPES	\
 	(VIA_TYPE | LINE_TYPE | TEXT_TYPE | ELEMENT_TYPE | ELEMENTNAME_TYPE |	\
-	POLYGON_TYPE | POLYGONPOINT_TYPE | LINEPOINT_TYPE | ARC_TYPE)
+	POUR_TYPE | POURPOINT_TYPE | LINEPOINT_TYPE | ARC_TYPE)
 #define	MOVETOLAYER_TYPES	\
-	(LINE_TYPE | TEXT_TYPE | POLYGON_TYPE | RATLINE_TYPE | ARC_TYPE)
+	(LINE_TYPE | TEXT_TYPE | POUR_TYPE | RATLINE_TYPE | ARC_TYPE)
 
 
 /* ---------------------------------------------------------------------------
  * prototypes
  */
-void MovePolygonLowLevel (PolygonTypePtr, LocationType, LocationType);
+void MovePourLowLevel (PourTypePtr, LocationType, LocationType);
 void MoveElementLowLevel (DataTypePtr, ElementTypePtr, LocationType,
 			  LocationType);
 void *MoveObject (int, void *, void *, void *, LocationType, LocationType);
@@ -102,7 +102,6 @@ void *MoveObjectAndRubberband (int, void *, void *, void *,
 			       LocationType, LocationType);
 void *MoveLineToLayerLowLevel (LayerTypePtr, LineTypePtr, LayerTypePtr);
 void *MoveTextToLayerLowLevel (LayerTypePtr, TextTypePtr, LayerTypePtr);
-void *MovePolygonToLayerLowLevel (LayerTypePtr, PolygonTypePtr, LayerTypePtr);
 Boolean MoveSelectedObjectsToLayer (LayerTypePtr);
 
 /* index is 0..MAX_LAYER-1.  If old_index is -1, a new layer is
diff --git a/src/mymem.c b/src/mymem.c
index 4118cf0..8b064d7 100644
--- a/src/mymem.c
+++ b/src/mymem.c
@@ -408,32 +408,61 @@ GetTextMemory (LayerTypePtr Layer)
 }
 
 /* ---------------------------------------------------------------------------
+ * get next slot for a pour polygon object, allocates memory if necessary
+ */
+PourTypePtr
+GetPourMemory (LayerTypePtr Layer)
+{
+  PourTypePtr pour = Layer->Pour;
+
+  /* realloc new memory if necessary and clear it */
+  if (Layer->PourN >= Layer->PourMax)
+    {
+      Layer->PourMax += STEP_POUR;
+      if (Layer->pour_tree)
+	r_destroy_tree (&Layer->pour_tree);
+      pour = MyRealloc (pour, Layer->PourMax * sizeof (PourType),
+			   "GetPourMemory()");
+      Layer->Pour = pour;
+      memset (pour + Layer->PourN, 0,
+	      STEP_POUR * sizeof (PourType));
+      Layer->pour_tree = r_create_tree (NULL, 0, 0);
+      POUR_LOOP (Layer);
+      {
+	r_insert_entry (Layer->pour_tree, (BoxType *) pour, 0);
+      }
+      END_LOOP;
+    }
+  return (pour + Layer->PourN++);
+}
+
+/* ---------------------------------------------------------------------------
  * get next slot for a polygon object, allocates memory if necessary
  */
 PolygonTypePtr
-GetPolygonMemory (LayerTypePtr Layer)
+GetPolygonMemoryInPour (PourTypePtr Pour)
 {
-  PolygonTypePtr polygon = Layer->Polygon;
+  PolygonTypePtr polygon = Pour->Polygons;
 
   /* realloc new memory if necessary and clear it */
-  if (Layer->PolygonN >= Layer->PolygonMax)
+  if (Pour->PolygonN >= Pour->PolygonMax)
     {
-      Layer->PolygonMax += STEP_POLYGON;
-      if (Layer->polygon_tree)
-	r_destroy_tree (&Layer->polygon_tree);
-      polygon = MyRealloc (polygon, Layer->PolygonMax * sizeof (PolygonType),
-			   "GetPolygonMemory()");
-      Layer->Polygon = polygon;
-      memset (polygon + Layer->PolygonN, 0,
-	      STEP_POLYGON * sizeof (PolygonType));
-      Layer->polygon_tree = r_create_tree (NULL, 0, 0);
-      POLYGON_LOOP (Layer);
+      Pour->PolygonMax += STEP_POLYGON;
+      if (Pour->polygon_tree)
+        r_destroy_tree (&Pour->polygon_tree);
+      polygon = MyRealloc (polygon, Pour->PolygonMax * sizeof (PolygonType),
+                           "GetPolygonMemoryInPour()");
+      Pour->Polygons = polygon;
+      memset (polygon + Pour->PolygonN, 0,
+              STEP_POLYGON * sizeof (PolygonType));
+      Pour->polygon_tree = r_create_tree (NULL, 0, 0);
+      POURPOLYGON_LOOP (Pour);
       {
-	r_insert_entry (Layer->polygon_tree, (BoxType *) polygon, 0);
+        r_insert_entry (Pour->polygon_tree, (BoxType *) polygon, 0);
       }
       END_LOOP;
     }
-  return (polygon + Layer->PolygonN++);
+  return (polygon + Pour->PolygonN++);
 }
 
 /* ---------------------------------------------------------------------------
@@ -443,6 +472,9 @@ GetPolygonMemory (LayerTypePtr Layer)
 PointTypePtr
 GetPointMemoryInPolygon (PolygonTypePtr Polygon)
 {
+  return NULL;
+#warning FIXME Later
+#if 0
   PointTypePtr points = Polygon->Points;
 
   /* realloc new memory if necessary and clear it */
@@ -456,6 +488,29 @@ GetPointMemoryInPolygon (PolygonTypePtr Polygon)
 	      STEP_POLYGONPOINT * sizeof (PointType));
     }
   return (points + Polygon->PointN++);
+#endif
+}
+
+/* ---------------------------------------------------------------------------
+ * gets the next slot for a point in a pour struct, allocates memory
+ * if necessary
+ */
+PointTypePtr
+GetPointMemoryInPour (PourTypePtr Pour)
+{
+  PointTypePtr points = Pour->Points;
+
+  /* realloc new memory if necessary and clear it */
+  if (Pour->PointN >= Pour->PointMax)
+    {
+      Pour->PointMax += STEP_POLYGONPOINT;
+      points = MyRealloc (points, Pour->PointMax * sizeof (PointType),
+			  "GetPointMemoryInPour()");
+      Pour->Points = points;
+      memset (points + Pour->PointN, 0,
+	      STEP_POLYGONPOINT * sizeof (PointType));
+    }
+  return (points + Pour->PointN++);
 }
 
 /* ---------------------------------------------------------------------------
@@ -733,7 +788,7 @@ FreePolygonMemory (PolygonTypePtr Polygon)
 {
   if (Polygon)
     {
-      MYFREE (Polygon->Points);
+//      MYFREE (Polygon->Points);
       if (Polygon->Clipped)
 	poly_Free (&Polygon->Clipped);
       poly_FreeContours (&Polygon->NoHoles);
@@ -742,6 +797,26 @@ FreePolygonMemory (PolygonTypePtr Polygon)
 }
 
 /* ---------------------------------------------------------------------------
+ * frees memory used by a pour
+ */
+void
+FreePourMemory (PourTypePtr Pour)
+{
+  if (Pour)
+    {
+      MYFREE (Pour->Points);
+#define FIXME Later
+#if 0
+      if (Pour->Clipped)
+	poly_Free (&Pour->Clipped);
+      if (Pour->NoHoles)
+	poly_Free (&Pour->NoHoles);
+#endif
+      memset (Pour, 0, sizeof (PourType));
+    }
+}
+
+/* ---------------------------------------------------------------------------
  * frees memory used by a box list
  */
 void
@@ -925,20 +1000,31 @@ FreeDataMemory (DataTypePtr Data)
 	  MYFREE (layer->Line);
 	  MYFREE (layer->Arc);
 	  MYFREE (layer->Text);
+#warning FIXME Later
+#if 0
 	  POLYGON_LOOP (layer);
 	  {
 	    FreePolygonMemory (polygon);
 	  }
 	  END_LOOP;
-	  MYFREE (layer->Polygon);
+#endif
+//	  MYFREE (layer->Polygon);
+	  POUR_LOOP (layer);
+	  {
+	    FreePourMemory (pour);
+	  }
+	  END_LOOP;
+	  MYFREE (layer->Pour);
 	  if (layer->line_tree)
 	    r_destroy_tree (&layer->line_tree);
 	  if (layer->arc_tree)
 	    r_destroy_tree (&layer->arc_tree);
 	  if (layer->text_tree)
 	    r_destroy_tree (&layer->text_tree);
-	  if (layer->polygon_tree)
-	    r_destroy_tree (&layer->polygon_tree);
+//	  if (layer->polygon_tree)
+//	    r_destroy_tree (&layer->polygon_tree);
+	  if (layer->pour_tree)
+	    r_destroy_tree (&layer->pour_tree);
 	}
 
       if (Data->element_tree)
diff --git a/src/mymem.h b/src/mymem.h
index b9d4de1..d902609 100644
--- a/src/mymem.h
+++ b/src/mymem.h
@@ -56,7 +56,8 @@
 #define	STEP_SELECTORENTRY	128
 #define	STEP_REMOVELIST		500
 #define	STEP_UNDOLIST		500
-#define	STEP_POLYGON		10
+#define	STEP_POUR		10
+#define	STEP_POLYGON		100
 #define	STEP_POLYGONPOINT	10
 #define	STEP_LIBRARYMENU	10
 #define	STEP_LIBRARYENTRY	20
@@ -80,8 +81,10 @@ LineTypePtr GetLineMemory (LayerTypePtr);
 ArcTypePtr GetArcMemory (LayerTypePtr);
 RatTypePtr GetRatMemory (DataTypePtr);
 TextTypePtr GetTextMemory (LayerTypePtr);
-PolygonTypePtr GetPolygonMemory (LayerTypePtr);
+PolygonTypePtr GetPolygonMemoryInPour (PourTypePtr);
+PourTypePtr GetPourMemory (LayerTypePtr);
 PointTypePtr GetPointMemoryInPolygon (PolygonTypePtr);
+PointTypePtr GetPointMemoryInPour (PourTypePtr);
 ElementTypePtr GetElementMemory (DataTypePtr);
 BoxTypePtr GetBoxMemory (BoxListTypePtr);
 ConnectionTypePtr GetConnectionMemory (NetTypePtr);
@@ -100,6 +103,7 @@ char *MyStrdup (char *s, const char *);
 /* void MyFree (void **); */
 #define MYFREE(x) do { SaveFree(x); (x)=NULL; } while (0)
 void FreePolygonMemory (PolygonTypePtr);
+void FreePourMemory (PourTypePtr);
 void FreeElementMemory (ElementTypePtr);
 void FreePCBMemory (PCBTypePtr);
 void FreeBoxListMemory (BoxListTypePtr);
diff --git a/src/parse_y.y b/src/parse_y.y
index bbb7255..8e35612 100644
--- a/src/parse_y.y
+++ b/src/parse_y.y
@@ -52,6 +52,7 @@
 #include "misc.h"
 #include "parse_l.h"
 #include "polygon.h"
+#include "pour.h"
 #include "remove.h"
 #include "rtree.h"
 #include "strflags.h"
@@ -64,7 +65,7 @@
 RCSID("$Id$");
 
 static	LayerTypePtr	Layer;
-static	PolygonTypePtr	Polygon;
+static	PourTypePtr	Pour;
 static	SymbolTypePtr	Symbol;
 static	int		pin_num;
 static	LibraryMenuTypePtr	Menu;
@@ -188,8 +189,8 @@ parsepcb
 			 */
 			PCB = yyPCB;
 			for (i = 0; i < yyData->LayerN+2; i++)
-			  for (j = 0; j < yyData->Layer[i].PolygonN; j++)
-			      InitClip (yyData, &yyData->Layer[i], &yyData->Layer[i].Polygon[j]);
+			  for (j = 0; j < yyData->Layer[i].PourN; j++)
+			      InitPourClip (yyData, &yyData->Layer[i], &yyData->Layer[i].Pour[j]);
 			PCB = pcb_save;
 			}
 			   
@@ -888,7 +889,7 @@ layerdefinition
 			/* x1, y1, x2, y2, flags */
 		| T_RECTANGLE '(' NUMBER NUMBER NUMBER NUMBER NUMBER ')'
 			{
-				CreateNewPolygonFromRectangle(Layer,
+				CreateNewPourFromRectangle(Layer,
 					$3*100, $4*100, ($3+$5)*100, ($4+$6)*100, OldFlags($7));
 			}
 		| text_hi_format
@@ -898,25 +899,25 @@ layerdefinition
 			/* flags are passed in */
 		| T_POLYGON '(' flags ')' '('
 			{
-				Polygon = CreateNewPolygon(Layer, $3);
+				Pour = CreateNewPour(Layer, $3);
 			}
 		  polygonpoints ')'
 		  	{
 					/* ignore junk */
-				if (Polygon->PointN >= 3)
+				if (Pour->PointN >= 3)
 				  {
-				    SetPolygonBoundingBox (Polygon);
-				    if (!Layer->polygon_tree)
-				      Layer->polygon_tree = r_create_tree (NULL, 0, 0);
-				    r_insert_entry (Layer->polygon_tree, (BoxType *) Polygon, 0);
+				    SetPourBoundingBox (Pour);
+				    if (!Layer->pour_tree)
+				      Layer->pour_tree = r_create_tree (NULL, 0, 0);
+				    r_insert_entry (Layer->pour_tree, (BoxType *) Pour, 0);
 				  }
 				else
 				{
 					Message("WARNING parsing file '%s'\n"
 						"    line:        %i\n"
-						"    description: 'ignored polygon (< 3 points)'\n",
+						"    description: 'ignored polygon pour (< 3 points)'\n",
 						yyfilename, yylineno);
-					DestroyObject(yyData, POLYGON_TYPE, Layer, Polygon, Polygon);
+					DestroyObject(yyData, POLYGON_TYPE, Layer, Pour, Pour);
 				}
 			}
 		;
@@ -1145,11 +1146,11 @@ polygonpoint
 			/* xcoord ycoord */
 		: '(' NUMBER NUMBER ')'
 			{
-				CreateNewPointInPolygon(Polygon, $2*100, $3*100);
+				CreateNewPointInPour(Pour, $2*100, $3*100);
 			}
 		| '[' NUMBER NUMBER ']'
 			{
-				CreateNewPointInPolygon(Polygon, $2, $3);
+				CreateNewPointInPour(Pour, $2, $3);
 			}
 		|
 		;
diff --git a/src/pcb-menu.res b/src/pcb-menu.res
index c18eb86..447a1d2 100644
--- a/src/pcb-menu.res
+++ b/src/pcb-menu.res
@@ -173,7 +173,7 @@ MainMenu =
    {"Arc" checked=arcmode,1 Mode(Arc) a={"F3" "<Key>F3"}}
    {"Text" checked=textmode,1 Mode(Text) a={"F4" "<Key>F4"}}
    {"Rectangle" checked=rectanglemode,1 Mode(Rectangle) a={"F5" "<Key>F5"}}
-   {"Polygon" checked=polygonmode,1 Mode(Polygon) a={"F6" "<Key>F6"}}
+   {"Polygon" checked=pourmode,1 Mode(Pour) a={"F6" "<Key>F6"}}
    {"Buffer" checked=pastebuffermode,1 Mode(PasteBuffer) a={"F7" "<Key>F7"}}
    {"Remove" checked=removemode,1 Mode(Remove) a={"F8" "<Key>F8"}}
    {"Rotate" checked=rotatemode,1 Mode(Rotate) a={"F9" "<Key>F9"}}
diff --git a/src/polygon.c b/src/polygon.c
index 901d058..2792144 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -32,6 +32,8 @@
 Here's a brief tour of the data and life of a polygon, courtesy of Ben
 Jackson:
 
+*** FIXME: SOME OF THIS WILL BE OUT DATED BY THE ADDITION OF POURS ****
+
 A PCB PolygonType contains an array of points outlining the polygon.
 This is what is manipulated by the UI and stored in the saved PCB.
 
@@ -109,10 +111,6 @@ RCSID ("$Id$");
 
 #define ROUND(x) ((long)(((x) >= 0 ? (x) + 0.5  : (x) - 0.5)))
 
-#define UNSUBTRACT_BLOAT 10
-#define SUBTRACT_PIN_VIA_BATCH_SIZE 100
-#define SUBTRACT_LINE_BATCH_SIZE 1
-
 /* ---------------------------------------------------------------------------
  * local prototypes
  */
@@ -144,6 +142,7 @@ ComputeNoHoles (PolygonType *poly)
   poly->NoHolesValid = 1;
 }
 
+#if 0
 static POLYAREA *
 biggest (POLYAREA * p)
 {
@@ -193,12 +192,14 @@ biggest (POLYAREA * p)
   assert (p->b);
   return p;
 }
+#endif
 
 POLYAREA *
 ContourToPoly (PLINE * contour)
 {
   POLYAREA *p;
   poly_PreContour (contour, TRUE);
+  poly_ChkContour (contour);
   assert (contour->Flags.orient == PLF_DIR);
   if (!(p = poly_Create ()))
     return NULL;
@@ -207,14 +208,17 @@ ContourToPoly (PLINE * contour)
   return p;
 }
 
+#warning FIXME Later
+#if 0
 static POLYAREA *
-original_poly (PolygonType * p)
+original_poly (PourType * p)
 {
+  return NULL;
   PLINE *contour = NULL;
   POLYAREA *np = NULL;
   Vector v;
 
-  /* first make initial polygon contour */
+  /* first make initial pour contour */
   POLYGONPOINT_LOOP (p);
   {
     v[0] = point->X;
@@ -251,6 +255,7 @@ original_poly (PolygonType * p)
   assert (poly_Valid (np));
   return biggest (np);
 }
+#endif
 
 POLYAREA *
 RectPoly (LocationType x1, LocationType x2, LocationType y1, LocationType y2)
@@ -624,6 +629,8 @@ SquarePadPoly (PadType * pad, BDimension clear)
   return np;
 }
 
+#warning FIXME Later
+#if 0
 /* clear np1 from the polygon */
 static int
 Subtract (POLYAREA * np1, PolygonType * p, Boolean fnp)
@@ -657,7 +664,9 @@ Subtract (POLYAREA * np1, PolygonType * p, Boolean fnp)
       p->NoHoles = NULL;
       return -1;
     }
-  p->Clipped = biggest (merged);
+#warning FIXME Later
+//  p->Clipped = biggest (merged);
+  p->Clipped = merged;
   assert (!p->Clipped || poly_Valid (p->Clipped));
   if (!p->Clipped)
     Message ("Polygon cleared out of existence near (%d, %d)\n",
@@ -665,6 +674,7 @@ Subtract (POLYAREA * np1, PolygonType * p, Boolean fnp)
              (p->BoundingBox.Y1 + p->BoundingBox.Y2) / 2);
   return 1;
 }
+#endif
 
 /* create a polygon of the pin clearance */
 POLYAREA *
@@ -696,435 +706,14 @@ BoxPolyBloated (BoxType *box, BDimension bloat)
                    box->Y1 - bloat, box->Y2 + bloat);
 }
 
-/* remove the pin clearance from the polygon */
-static int
-SubtractPin (DataType * d, PinType * pin, LayerType * l, PolygonType * p)
-{
-  POLYAREA *np;
-  Cardinal i;
-
-  if (pin->Clearance == 0)
-    return 0;
-  i = GetLayerNumber (d, l);
-  if (TEST_THERM (i, pin))
-    {
-      np = ThermPoly ((PCBTypePtr) (d->pcb), pin, i);
-      if (!np)
-        return 0;
-    }
-  else
-    {
-      np = PinPoly (pin, pin->Thickness, pin->Clearance);
-      if (!np)
-        return -1;
-    }
-  return Subtract (np, p, TRUE);
-}
-
-static int
-SubtractLine (LineType * line, PolygonType * p)
-{
-  POLYAREA *np;
-
-  if (!TEST_FLAG (CLEARLINEFLAG, line))
-    return 0;
-  if (!(np = LinePoly (line, line->Thickness + line->Clearance)))
-    return -1;
-  return Subtract (np, p, True);
-}
-
-static int
-SubtractArc (ArcType * arc, PolygonType * p)
-{
-  POLYAREA *np;
-
-  if (!TEST_FLAG (CLEARLINEFLAG, arc))
-    return 0;
-  if (!(np = ArcPoly (arc, arc->Thickness + arc->Clearance)))
-    return -1;
-  return Subtract (np, p, True);
-}
-
-static int
-SubtractText (TextType * text, PolygonType * p)
-{
-  POLYAREA *np;
-  const BoxType *b = &text->BoundingBox;
-
-  if (!TEST_FLAG (CLEARLINEFLAG, text))
-    return 0;
-  if (!(np = RoundRect (b->X1 + PCB->Bloat, b->X2 - PCB->Bloat,
-                        b->Y1 + PCB->Bloat, b->Y2 - PCB->Bloat, PCB->Bloat)))
-    return -1;
-  return Subtract (np, p, True);
-}
-
-static int
-SubtractPad (PadType * pad, PolygonType * p)
-{
-  POLYAREA *np = NULL;
-
-  if (pad->Clearance == 0)
-    return 0;
-  if (TEST_FLAG (SQUAREFLAG, pad))
-    {
-      if (!
-          (np = SquarePadPoly (pad, pad->Thickness + pad->Clearance)))
-        return -1;
-    }
-  else
-    {
-      if (!
-          (np = LinePoly ((LineType *) pad, pad->Thickness + pad->Clearance)))
-        return -1;
-    }
-  return Subtract (np, p, True);
-}
-
-struct cpInfo
-{
-  const BoxType *other;
-  DataType *data;
-  LayerType *layer;
-  PolygonType *polygon;
-  Boolean solder;
-  POLYAREA *accumulate;
-  int batch_size;
-  jmp_buf env;
-};
-
-static void
-subtract_accumulated (struct cpInfo *info, PolygonTypePtr polygon)
-{
-  if (info->accumulate == NULL)
-    return;
-  Subtract (info->accumulate, polygon, True);
-  info->accumulate = NULL;
-  info->batch_size = 0;
-}
-
-static int
-pin_sub_callback (const BoxType * b, void *cl)
-{
-  PinTypePtr pin = (PinTypePtr) b;
-  struct cpInfo *info = (struct cpInfo *) cl;
-  PolygonTypePtr polygon;
-  POLYAREA *np;
-  POLYAREA *merged;
-  Cardinal i;
-
-  /* don't subtract the object that was put back! */
-  if (b == info->other)
-    return 0;
-  polygon = info->polygon;
-
-  if (pin->Clearance == 0)
-    return 0;
-  i = GetLayerNumber (info->data, info->layer);
-  if (TEST_THERM (i, pin))
-    {
-      np = ThermPoly ((PCBTypePtr) (info->data->pcb), pin, i);
-      if (!np)
-        return 1;
-    }
-  else
-    {
-      np = PinPoly (pin, pin->Thickness, pin->Clearance);
-      if (!np)
-        longjmp (info->env, 1);
-    }
-
-  poly_Boolean_free (info->accumulate, np, &merged, PBO_UNITE);
-  info->accumulate = merged;
-
-  info->batch_size ++;
-
-  if (info->batch_size == SUBTRACT_PIN_VIA_BATCH_SIZE)
-    subtract_accumulated (info, polygon);
-
-  return 1;
-}
-
-static int
-arc_sub_callback (const BoxType * b, void *cl)
-{
-  ArcTypePtr arc = (ArcTypePtr) b;
-  struct cpInfo *info = (struct cpInfo *) cl;
-  PolygonTypePtr polygon;
-
-  /* don't subtract the object that was put back! */
-  if (b == info->other)
-    return 0;
-  if (!TEST_FLAG (CLEARLINEFLAG, arc))
-    return 0;
-  polygon = info->polygon;
-  if (SubtractArc (arc, polygon) < 0)
-    longjmp (info->env, 1);
-  return 1;
-}
-
-static int
-pad_sub_callback (const BoxType * b, void *cl)
-{
-  PadTypePtr pad = (PadTypePtr) b;
-  struct cpInfo *info = (struct cpInfo *) cl;
-  PolygonTypePtr polygon;
-
-  /* don't subtract the object that was put back! */
-  if (b == info->other)
-    return 0;
-  if (pad->Clearance == 0)
-    return 0;
-  polygon = info->polygon;
-  if (XOR (TEST_FLAG (ONSOLDERFLAG, pad), !info->solder))
-    {
-      if (SubtractPad (pad, polygon) < 0)
-        longjmp (info->env, 1);
-      return 1;
-    }
-  return 0;
-}
-
-static int
-line_sub_callback (const BoxType * b, void *cl)
-{
-  LineTypePtr line = (LineTypePtr) b;
-  struct cpInfo *info = (struct cpInfo *) cl;
-  PolygonTypePtr polygon;
-  POLYAREA *np;
-  POLYAREA *merged;
-
-  /* don't subtract the object that was put back! */
-  if (b == info->other)
-    return 0;
-  if (!TEST_FLAG (CLEARLINEFLAG, line))
-    return 0;
-  polygon = info->polygon;
-
-  if (!(np = LinePoly (line, line->Thickness + line->Clearance)))
-    longjmp (info->env, 1);
-
-  poly_Boolean_free (info->accumulate, np, &merged, PBO_UNITE);
-  info->accumulate = merged;
-  info->batch_size ++;
-
-  if (info->batch_size == SUBTRACT_LINE_BATCH_SIZE)
-    subtract_accumulated (info, polygon);
-
-  return 1;
-}
-
-static int
-text_sub_callback (const BoxType * b, void *cl)
-{
-  TextTypePtr text = (TextTypePtr) b;
-  struct cpInfo *info = (struct cpInfo *) cl;
-  PolygonTypePtr polygon;
-
-  /* don't subtract the object that was put back! */
-  if (b == info->other)
-    return 0;
-  if (!TEST_FLAG (CLEARLINEFLAG, text))
-    return 0;
-  polygon = info->polygon;
-  if (SubtractText (text, polygon) < 0)
-    longjmp (info->env, 1);
-  return 1;
-}
-
-static int
-Group (DataTypePtr Data, Cardinal layer)
-{
-  Cardinal i, j;
-  for (i = 0; i < max_layer; i++)
-    for (j = 0; j < ((PCBType *) (Data->pcb))->LayerGroups.Number[i]; j++)
-      if (layer == ((PCBType *) (Data->pcb))->LayerGroups.Entries[i][j])
-        return i;
-  return i;
-}
-
-static int
-clearPoly (DataTypePtr Data, LayerTypePtr Layer, PolygonType * polygon,
-           const BoxType * here, BDimension expand)
-{
-  int r = 0;
-  BoxType region;
-  struct cpInfo info;
-  Cardinal group;
-
-  if (!TEST_FLAG (CLEARPOLYFLAG, polygon)
-      || GetLayerNumber (Data, Layer) >= max_layer)
-    return 0;
-  group = Group (Data, GetLayerNumber (Data, Layer));
-  info.solder = (group == Group (Data, max_layer + SOLDER_LAYER));
-  info.data = Data;
-  info.other = here;
-  info.layer = Layer;
-  info.polygon = polygon;
-  if (here)
-    region = clip_box (here, &polygon->BoundingBox);
-  else
-    region = polygon->BoundingBox;
-  region = bloat_box (&region, expand);
-
-  if (setjmp (info.env) == 0)
-    {
-      r = 0;
-      info.accumulate = NULL;
-      info.batch_size = 0;
-      if (info.solder || group == Group (Data, max_layer + COMPONENT_LAYER))
-	r += r_search (Data->pad_tree, &region, NULL, pad_sub_callback, &info);
-      GROUP_LOOP (Data, group);
-      {
-        r +=
-          r_search (layer->line_tree, &region, NULL, line_sub_callback,
-                    &info);
-        subtract_accumulated (&info, polygon);
-        r +=
-          r_search (layer->arc_tree, &region, NULL, arc_sub_callback, &info);
-	r +=
-          r_search (layer->text_tree, &region, NULL, text_sub_callback, &info);
-      }
-      END_LOOP;
-      r += r_search (Data->via_tree, &region, NULL, pin_sub_callback, &info);
-      r += r_search (Data->pin_tree, &region, NULL, pin_sub_callback, &info);
-      subtract_accumulated (&info, polygon);
-    }
-  polygon->NoHolesValid = 0;
-  return r;
-}
-
-static int
-Unsubtract (POLYAREA * np1, PolygonType * p)
-{
-  POLYAREA *merged = NULL, *np = np1;
-  POLYAREA *orig_poly, *clipped_np;
-  int x;
-  assert (np);
-  assert (p && p->Clipped);
-
-  orig_poly = original_poly (p);
-
-  x = poly_Boolean_free (np, orig_poly, &clipped_np, PBO_ISECT);
-  if (x != err_ok)
-    {
-      fprintf (stderr, "Error while clipping PBO_ISECT: %d\n", x);
-      poly_Free (&clipped_np);
-      goto fail;
-    }
-
-  x = poly_Boolean_free (p->Clipped, clipped_np, &merged, PBO_UNITE);
-  if (x != err_ok)
-    {
-      fprintf (stderr, "Error while clipping PBO_UNITE: %d\n", x);
-      poly_Free (&merged);
-      goto fail;
-    }
-  p->Clipped = biggest (merged);
-  assert (!p->Clipped || poly_Valid (p->Clipped));
-  return 1;
-
-fail:
-  p->Clipped = NULL;
-  if (p->NoHoles) printf ("Just leaked in Unsubtract\n");
-  p->NoHoles = NULL;
-  return 0;
-}
-
-static int
-UnsubtractPin (PinType * pin, LayerType * l, PolygonType * p)
-{
-  POLYAREA *np;
-
-  /* overlap a bit to prevent gaps from rounding errors */
-  np = BoxPolyBloated (&pin->BoundingBox, UNSUBTRACT_BLOAT);
-
-  if (!np)
-    return 0;
-  if (!Unsubtract (np, p))
-    return 0;
-  clearPoly (PCB->Data, l, p, (const BoxType *) pin, 2 * UNSUBTRACT_BLOAT);
-  return 1;
-}
-
-static int
-UnsubtractArc (ArcType * arc, LayerType * l, PolygonType * p)
-{
-  POLYAREA *np;
-
-  if (!TEST_FLAG (CLEARLINEFLAG, arc))
-    return 0;
-
-  /* overlap a bit to prevent gaps from rounding errors */
-  np = BoxPolyBloated (&arc->BoundingBox, UNSUBTRACT_BLOAT);
-
-  if (!np)
-    return 0;
-  if (!Unsubtract (np, p))
-    return 0;
-  clearPoly (PCB->Data, l, p, (const BoxType *) arc, 2 * UNSUBTRACT_BLOAT);
-  return 1;
-}
-
-static int
-UnsubtractLine (LineType * line, LayerType * l, PolygonType * p)
-{
-  POLYAREA *np;
-
-  if (!TEST_FLAG (CLEARLINEFLAG, line))
-    return 0;
-
-  /* overlap a bit to prevent notches from rounding errors */
-  np = BoxPolyBloated (&line->BoundingBox, UNSUBTRACT_BLOAT);
-
-  if (!np)
-    return 0;
-  if (!Unsubtract (np, p))
-    return 0;
-  clearPoly (PCB->Data, l, p, (const BoxType *) line, 2 * UNSUBTRACT_BLOAT);
-  return 1;
-}
-
-static int
-UnsubtractText (TextType * text, LayerType * l, PolygonType * p)
-{
-  POLYAREA *np;
-
-  if (!TEST_FLAG (CLEARLINEFLAG, text))
-    return 0;
-
-  /* overlap a bit to prevent notches from rounding errors */
-  np = BoxPolyBloated (&text->BoundingBox, UNSUBTRACT_BLOAT);
-
-  if (!np)
-    return -1;
-  if (!Unsubtract (np, p))
-    return 0;
-  clearPoly (PCB->Data, l, p, (const BoxType *) text, 2 * UNSUBTRACT_BLOAT);
-  return 1;
-}
-
-static int
-UnsubtractPad (PadType * pad, LayerType * l, PolygonType * p)
-{
-  POLYAREA *np;
-
-  /* overlap a bit to prevent notches from rounding errors */
-  np = BoxPolyBloated (&pad->BoundingBox, UNSUBTRACT_BLOAT);
-
-  if (!np)
-    return 0;
-  if (!Unsubtract (np, p))
-    return 0;
-  clearPoly (PCB->Data, l, p, (const BoxType *) pad, 2 * UNSUBTRACT_BLOAT);
-  return 1;
-}
-
-static Boolean inhibit = False;
-
 int
 InitClip (DataTypePtr Data, LayerTypePtr layer, PolygonType * p)
 {
+  /* NOP */
+  printf ("Someone called InitClip, bad someone.\n");
+  return 0;
+#warning FIXME Later
+#if 0
   if (inhibit)
     return 0;
   if (p->Clipped)
@@ -1139,205 +728,7 @@ InitClip (DataTypePtr Data, LayerTypePtr layer, PolygonType * p)
   else
     p->NoHolesValid = 0;
   return 1;
-}
-
-/* --------------------------------------------------------------------------
- * remove redundant polygon points. Any point that lies on the straight
- * line between the points on either side of it is redundant.
- * returns true if any points are removed
- */
-Boolean
-RemoveExcessPolygonPoints (LayerTypePtr Layer, PolygonTypePtr Polygon)
-{
-  PointTypePtr pt1, pt2, pt3;
-  Cardinal n;
-  LineType line;
-  Boolean changed = False;
-
-  if (Undoing ())
-    return (False);
-  /* there are always at least three points in a polygon */
-  pt1 = &Polygon->Points[Polygon->PointN - 1];
-  pt2 = &Polygon->Points[0];
-  pt3 = &Polygon->Points[1];
-  for (n = 0; n < Polygon->PointN; n++, pt1++, pt2++, pt3++)
-    {
-      /* wrap around polygon */
-      if (n == 1)
-        pt1 = &Polygon->Points[0];
-      if (n == Polygon->PointN - 1)
-        pt3 = &Polygon->Points[0];
-      line.Point1 = *pt1;
-      line.Point2 = *pt3;
-      line.Thickness = 0;
-      if (IsPointOnLine ((float) pt2->X, (float) pt2->Y, 0.0, &line))
-        {
-          RemoveObject (POLYGONPOINT_TYPE, (void *) Layer, (void *) Polygon,
-                        (void *) pt2);
-          changed = True;
-        }
-    }
-  return (changed);
-}
-
-/* ---------------------------------------------------------------------------
- * returns the index of the polygon point which is the end
- * point of the segment with the lowest distance to the passed
- * coordinates
- */
-Cardinal
-GetLowestDistancePolygonPoint (PolygonTypePtr Polygon, LocationType X,
-                               LocationType Y)
-{
-  double mindistance = (double) MAX_COORD * MAX_COORD;
-  PointTypePtr ptr1 = &Polygon->Points[Polygon->PointN - 1],
-    ptr2 = &Polygon->Points[0];
-  Cardinal n, result = 0;
-
-  /* we calculate the distance to each segment and choose the
-   * shortest distance. If the closest approach between the
-   * given point and the projected line (i.e. the segment extended)
-   * is not on the segment, then the distance is the distance
-   * to the segment end point.
-   */
-
-  for (n = 0; n < Polygon->PointN; n++, ptr2++)
-    {
-      register double u, dx, dy;
-      dx = ptr2->X - ptr1->X;
-      dy = ptr2->Y - ptr1->Y;
-      if (dx != 0.0 || dy != 0.0)
-        {
-          /* projected intersection is at P1 + u(P2 - P1) */
-          u = ((X - ptr1->X) * dx + (Y - ptr1->Y) * dy) / (dx * dx + dy * dy);
-
-          if (u < 0.0)
-            {                   /* ptr1 is closest point */
-              u = SQUARE (X - ptr1->X) + SQUARE (Y - ptr1->Y);
-            }
-          else if (u > 1.0)
-            {                   /* ptr2 is closest point */
-              u = SQUARE (X - ptr2->X) + SQUARE (Y - ptr2->Y);
-            }
-          else
-            {                   /* projected intersection is closest point */
-              u = SQUARE (X - ptr1->X * (1.0 - u) - u * ptr2->X) +
-                SQUARE (Y - ptr1->Y * (1.0 - u) - u * ptr2->Y);
-            }
-          if (u < mindistance)
-            {
-              mindistance = u;
-              result = n;
-            }
-        }
-      ptr1 = ptr2;
-    }
-  return (result);
-}
-
-/* ---------------------------------------------------------------------------
- * go back to the  previous point of the polygon
- */
-void
-GoToPreviousPoint (void)
-{
-  switch (Crosshair.AttachedPolygon.PointN)
-    {
-      /* do nothing if mode has just been entered */
-    case 0:
-      break;
-
-      /* reset number of points and 'LINE_MODE' state */
-    case 1:
-      Crosshair.AttachedPolygon.PointN = 0;
-      Crosshair.AttachedLine.State = STATE_FIRST;
-      addedLines = 0;
-      break;
-
-      /* back-up one point */
-    default:
-      {
-        PointTypePtr points = Crosshair.AttachedPolygon.Points;
-        Cardinal n = Crosshair.AttachedPolygon.PointN - 2;
-
-        Crosshair.AttachedPolygon.PointN--;
-        Crosshair.AttachedLine.Point1.X = points[n].X;
-        Crosshair.AttachedLine.Point1.Y = points[n].Y;
-        break;
-      }
-    }
-}
-
-/* ---------------------------------------------------------------------------
- * close polygon if possible
- */
-void
-ClosePolygon (void)
-{
-  Cardinal n = Crosshair.AttachedPolygon.PointN;
-
-  /* check number of points */
-  if (n >= 3)
-    {
-      /* if 45 degree lines are what we want do a quick check
-       * if closing the polygon makes sense
-       */
-      if (!TEST_FLAG (ALLDIRECTIONFLAG, PCB))
-        {
-          BDimension dx, dy;
-
-          dx = abs (Crosshair.AttachedPolygon.Points[n - 1].X -
-                    Crosshair.AttachedPolygon.Points[0].X);
-          dy = abs (Crosshair.AttachedPolygon.Points[n - 1].Y -
-                    Crosshair.AttachedPolygon.Points[0].Y);
-          if (!(dx == 0 || dy == 0 || dx == dy))
-            {
-              Message
-                (_
-                 ("Cannot close polygon because 45 degree lines are requested.\n"));
-              return;
-            }
-        }
-      CopyAttachedPolygonToLayer ();
-      Draw ();
-    }
-  else
-    Message (_("A polygon has to have at least 3 points\n"));
-}
-
-/* ---------------------------------------------------------------------------
- * moves the data of the attached (new) polygon to the current layer
- */
-void
-CopyAttachedPolygonToLayer (void)
-{
-  PolygonTypePtr polygon;
-  int saveID;
-
-  /* move data to layer and clear attached struct */
-  polygon = CreateNewPolygon (CURRENT, NoFlags ());
-  saveID = polygon->ID;
-  *polygon = Crosshair.AttachedPolygon;
-  polygon->ID = saveID;
-  SET_FLAG (CLEARPOLYFLAG, polygon);
-  if (TEST_FLAG (NEWFULLPOLYFLAG, PCB))
-    SET_FLAG (FULLPOLYFLAG, polygon);
-  memset (&Crosshair.AttachedPolygon, 0, sizeof (PolygonType));
-  SetPolygonBoundingBox (polygon);
-  if (!CURRENT->polygon_tree)
-    CURRENT->polygon_tree = r_create_tree (NULL, 0, 0);
-  r_insert_entry (CURRENT->polygon_tree, (BoxType *) polygon, 0);
-  InitClip (PCB->Data, CURRENT, polygon);
-  DrawPolygon (CURRENT, polygon, 0);
-  SetChangedFlag (True);
-
-  /* reset state of attached line */
-  Crosshair.AttachedLine.State = STATE_FIRST;
-  addedLines = 0;
-
-  /* add to undo list */
-  AddObjectToCreateUndoList (POLYGON_TYPE, CURRENT, polygon, polygon);
-  IncrementUndoSerialNumber ();
+#endif
 }
 
 /* find polygon holes in range, then call the callback function for
@@ -1381,61 +772,14 @@ struct plow_info
 };
 
 static int
-subtract_plow (DataTypePtr Data, LayerTypePtr Layer, PolygonTypePtr Polygon,
-               int type, void *ptr1, void *ptr2)
+plow_callback_2 (const BoxType * b, void *cl)
 {
-  if (!Polygon->Clipped)
-    return 0;
-  switch (type)
-    {
-    case PIN_TYPE:
-    case VIA_TYPE:
-      SubtractPin (Data, (PinTypePtr) ptr2, Layer, Polygon);
-      Polygon->NoHolesValid = 0;
-      return 1;
-    case LINE_TYPE:
-      SubtractLine ((LineTypePtr) ptr2, Polygon);
-      Polygon->NoHolesValid = 0;
-      return 1;
-    case ARC_TYPE:
-      SubtractArc ((ArcTypePtr) ptr2, Polygon);
-      Polygon->NoHolesValid = 0;
-      return 1;
-    case PAD_TYPE:
-      SubtractPad ((PadTypePtr) ptr2, Polygon);
-      Polygon->NoHolesValid = 0;
-      return 1;
-    case TEXT_TYPE:
-      SubtractText ((TextTypePtr) ptr2, Polygon);
-      Polygon->NoHolesValid = 0;
-      return 1;
-    }
-  return 0;
-}
+  struct plow_info *plow = (struct plow_info *) cl;
+  PolygonTypePtr polygon = (PolygonTypePtr) b;
 
-static int
-add_plow (DataTypePtr Data, LayerTypePtr Layer, PolygonTypePtr Polygon,
-          int type, void *ptr1, void *ptr2)
-{
-  switch (type)
-    {
-    case PIN_TYPE:
-    case VIA_TYPE:
-      UnsubtractPin ((PinTypePtr) ptr2, Layer, Polygon);
-      return 1;
-    case LINE_TYPE:
-      UnsubtractLine ((LineTypePtr) ptr2, Layer, Polygon);
-      return 1;
-    case ARC_TYPE:
-      UnsubtractArc ((ArcTypePtr) ptr2, Layer, Polygon);
-      return 1;
-    case PAD_TYPE:
-      UnsubtractPad ((PadTypePtr) ptr2, Layer, Polygon);
-      return 1;
-    case TEXT_TYPE:
-      UnsubtractText ((TextTypePtr) ptr2, Layer, Polygon);
-      return 1;
-    }
+  if (TEST_FLAG (CLEARPOLYFLAG, polygon))
+    return plow->callback (plow->data, plow->layer, polygon, plow->type,
+                           plow->ptr1, plow->ptr2);
   return 0;
 }
 
@@ -1443,12 +787,10 @@ static int
 plow_callback (const BoxType * b, void *cl)
 {
   struct plow_info *plow = (struct plow_info *) cl;
-  PolygonTypePtr polygon = (PolygonTypePtr) b;
+  PourTypePtr pour = (PourTypePtr) b;
+  BoxType *sb = &((PinTypePtr) plow->ptr2)->BoundingBox;
 
-  if (TEST_FLAG (CLEARPOLYFLAG, polygon))
-    return plow->callback (plow->data, plow->layer, polygon, plow->type,
-                           plow->ptr1, plow->ptr2);
-  return 0;
+  return r_search (pour->polygon_tree, sb, NULL, plow_callback_2, plow);
 }
 
 int
@@ -1475,8 +817,7 @@ PlowsPolygon (DataType * Data, int type, void *ptr1, void *ptr2,
           LAYER_LOOP (Data, max_layer);
           {
             info.layer = layer;
-            r +=
-              r_search (layer->polygon_tree, &sb, NULL, plow_callback, &info);
+            r += r_search (layer->pour_tree, &sb, NULL, plow_callback, &info);
           }
           END_LOOP;
         }
@@ -1486,8 +827,7 @@ PlowsPolygon (DataType * Data, int type, void *ptr1, void *ptr2,
                                                                          ((LayerTypePtr) ptr1))));
           {
             info.layer = layer;
-            r +=
-              r_search (layer->polygon_tree, &sb, NULL, plow_callback, &info);
+            r += r_search (layer->pour_tree, &sb, NULL, plow_callback, &info);
           }
           END_LOOP;
         }
@@ -1505,7 +845,7 @@ PlowsPolygon (DataType * Data, int type, void *ptr1, void *ptr2,
                                                                      ((LayerTypePtr) ptr1))));
       {
         info.layer = layer;
-        r += r_search (layer->polygon_tree, &sb, NULL, plow_callback, &info);
+        r += r_search (layer->pour_tree, &sb, NULL, plow_callback, &info);
       }
       END_LOOP;
       break;
@@ -1519,7 +859,7 @@ PlowsPolygon (DataType * Data, int type, void *ptr1, void *ptr2,
         {
           info.layer = layer;
           r +=
-            r_search (layer->polygon_tree, &sb, NULL, plow_callback, &info);
+            r_search (layer->pour_tree, &sb, NULL, plow_callback, &info);
         }
         END_LOOP;
       }
@@ -1543,23 +883,6 @@ PlowsPolygon (DataType * Data, int type, void *ptr1, void *ptr2,
   return r;
 }
 
-void
-RestoreToPolygon (DataType * Data, int type, void *ptr1, void *ptr2)
-{
-  if (type == POLYGON_TYPE)
-    InitClip (PCB->Data, (LayerTypePtr) ptr1, (PolygonTypePtr) ptr2);
-  else
-    PlowsPolygon (Data, type, ptr1, ptr2, add_plow);
-}
-
-void
-ClearFromPolygon (DataType * Data, int type, void *ptr1, void *ptr2)
-{
-  if (type == POLYGON_TYPE)
-    InitClip (PCB->Data, (LayerTypePtr) ptr1, (PolygonTypePtr) ptr2);
-  else
-    PlowsPolygon (Data, type, ptr1, ptr2, subtract_plow);
-}
 
 Boolean
 isects (POLYAREA * a, PolygonTypePtr p, Boolean fr)
@@ -1709,6 +1032,9 @@ NoHolesPolygonDicer (PolygonTypePtr p, const BoxType * clip,
 Boolean
 MorphPolygon (LayerTypePtr layer, PolygonTypePtr poly)
 {
+  return 0;
+#warning FIXME Later
+#if 0
   POLYAREA *p, *start;
   Boolean many = False;
   FlagType flags;
@@ -1772,6 +1098,7 @@ MorphPolygon (LayerTypePtr layer, PolygonTypePtr poly)
   inhibit = False;
   IncrementUndoSerialNumber ();
   return many;
+#endif
 }
 
 void debug_pline (PLINE *pl)
@@ -1804,9 +1131,9 @@ debug_polygon (PolygonType *p)
 {
   int i;
   POLYAREA *pa;
-  fprintf (stderr, "POLYGON %p  %d pts\n", p, p->PointN);
-  for (i=0; i<p->PointN; i++)
-    fprintf(stderr, "\t%d: %d, %d\n", i, p->Points[i].X, p->Points[i].Y);
+//  fprintf (stderr, "POLYGON %p  %d pts\n", p, p->PointN);
+//  for (i=0; i<p->PointN; i++)
+//    fprintf(stderr, "\t%d: %d, %d\n", i, p->Points[i].X, p->Points[i].Y);
   pa = p->Clipped;
   while (pa)
     {
diff --git a/src/polygon.h b/src/polygon.h
index ccf3164..15223c0 100644
--- a/src/polygon.h
+++ b/src/polygon.h
@@ -33,27 +33,26 @@
 
 #include "global.h"
 
-Cardinal GetLowestDistancePolygonPoint (PolygonTypePtr,
-					LocationType, LocationType);
-Boolean RemoveExcessPolygonPoints (LayerTypePtr, PolygonTypePtr);
-void GoToPreviousPoint (void);
-void ClosePolygon (void);
-void CopyAttachedPolygonToLayer (void);
 int PolygonHoles (PolygonType *ptr, const BoxType *range,
 		  int (*callback) (PLINE *, void *user_data),
                   void *user_data);
 int PlowsPolygon (DataType *, int, void *, void *,
 		  int (*callback) (DataTypePtr, LayerTypePtr, PolygonTypePtr, int, void *, void *));
 void ComputeNoHoles (PolygonType *poly);
+
 POLYAREA * ContourToPoly (PLINE *);
 POLYAREA * RectPoly (LocationType x1, LocationType x2, LocationType y1, LocationType y2);
-POLYAREA * CirclePoly(LocationType x, LocationType y, BDimension radius);
 POLYAREA * OctagonPoly(LocationType x, LocationType y, BDimension radius);
-POLYAREA * LinePoly(LineType *l, BDimension thick);
+void frac_circle (PLINE *, LocationType, LocationType, Vector, int);
+POLYAREA * CirclePoly(LocationType x, LocationType y, BDimension radius);
+POLYAREA * RoundRect (LocationType x1, LocationType x2, LocationType y1, LocationType y2, BDimension t);
 POLYAREA * ArcPoly(ArcType *l, BDimension thick);
+POLYAREA * LinePoly(LineType *l, BDimension thick);
+POLYAREA * SquarePadPoly (PadType * pad, BDimension clear);
+
 POLYAREA * PinPoly(PinType *l, BDimension thick, BDimension clear);
 POLYAREA * BoxPolyBloated (BoxType *box, BDimension radius);
-void frac_circle (PLINE *, LocationType, LocationType, Vector, int);
+
 int InitClip(DataType *d, LayerType *l, PolygonType *p);
 void RestoreToPolygon(DataType *, int, void *, void *);
 void ClearFromPolygon(DataType *, int, void *, void *);
diff --git a/src/polygon1.c b/src/polygon1.c
index c624d8b..f74febf 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -935,6 +935,45 @@ intersect (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
 }
 
 static void
+M_POLYAREA_intersect2 (jmp_buf * e, POLYAREA * afst, POLYAREA * bfst, int add)
+{
+  POLYAREA *a = afst, *b = bfst;
+  PLINE *curcA, *curcB;
+  CVCList *the_list = NULL;
+
+  if (a == NULL || b == NULL)
+    error (err_bad_parm);
+  do
+    {
+      do
+	{
+	  if (a->contours->xmax >= b->contours->xmin &&
+	      a->contours->ymax >= b->contours->ymin &&
+	      a->contours->xmin <= b->contours->xmax &&
+	      a->contours->ymin <= b->contours->ymax)
+	    {
+	      if (intersect (e, a, b, add))
+		error (err_no_memory);
+	    }
+	}
+      while ((a = a->f) != afst);
+      for (curcB = b->contours; curcB != NULL; curcB = curcB->next)
+	if (curcB->Flags.status == ISECTED)
+	  if (!(the_list = add_descriptors (curcB, 'B', the_list)))
+	    error (err_no_memory);
+    }
+  while ((b = b->f) != bfst);
+  do
+    {
+      for (curcA = a->contours; curcA != NULL; curcA = curcA->next)
+	if (curcA->Flags.status == ISECTED)
+	  if (!(the_list = add_descriptors (curcA, 'A', the_list)))
+	    error (err_no_memory);
+    }
+  while ((a = a->f) != afst);
+}				/* M_POLYAREA_intersect */
+
+static void
 M_POLYAREA_intersect (jmp_buf * e, POLYAREA * afst, POLYAREA * bfst, int add)
 {
   POLYAREA *a = afst, *b = bfst;
@@ -1185,7 +1224,7 @@ M_POLYAREA_label (POLYAREA * afst, POLYAREA * b, BOOLp touch)
 	      return TRUE;
 	  }
     }
-  while (!touch && (a = a->f) != afst);
+  while ((a = a->f) != afst);
   return FALSE;
 }
 
@@ -2297,7 +2336,8 @@ Touching (POLYAREA * a, POLYAREA * b)
       if (!poly_Valid (b))
 	return -1;
 #endif
-      M_POLYAREA_intersect (&e, a, b, False);
+//      M_POLYAREA_intersect (&e, a, b, False);
+      M_POLYAREA_intersect2 (&e, a, b, False);
 
       if (M_POLYAREA_label (a, b, TRUE))
 	return TRUE;
@@ -3061,15 +3101,19 @@ inside_sector (VNODE * pn, Vector p2)
 BOOLp
 poly_ChkContour (PLINE * a)
 {
-  VNODE *a1, *a2, *hit1, *hit2;
+  VNODE *a1, *a2, *a2_start, *hit1, *hit2;
   Vector i1, i2;
   int icnt;
+  double d1, d2;
+
+#warning FIXME Later: Deliberately disabled this test - seems something strange is going on
+  return FALSE;
 
   assert (a != NULL);
   a1 = &a->head;
   do
     {
-      a2 = a1;
+      a2_start = a2 = a1;
       do
 	{
 	  if (!node_neighbours (a1, a2) &&
@@ -3079,9 +3123,11 @@ poly_ChkContour (PLINE * a)
 	      if (icnt > 1)
 		return TRUE;
 
-	      if (vect_dist2 (i1, a1->point) < EPSILON)
+	      d1 = -1;
+	      d2 = -1;
+	      if ((d1 = vect_dist2 (i1, a1->point)) < EPSILON)
 		hit1 = a1;
-	      else if (vect_dist2 (i1, a1->next->point) < EPSILON)
+	      else if ((d2 = vect_dist2 (i1, a1->next->point)) < EPSILON)
 		hit1 = a1->next;
 	      else
 		return TRUE;
@@ -3103,7 +3149,7 @@ poly_ChkContour (PLINE * a)
 #endif
 	    }
 	}
-      while ((a2 = a2->next) != &a->head);
+      while ((a2 = a2->next) != a2_start);
     }
   while ((a1 = a1->next) != &a->head);
   return FALSE;
diff --git a/src/pour.c b/src/pour.c
new file mode 100644
index 0000000..84fb231
--- /dev/null
+++ b/src/pour.c
@@ -0,0 +1,1279 @@
+/* $Id$ */
+
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 1994,1995,1996 Thomas Nau
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Contact addresses for paper mail and Email:
+ *  Thomas Nau, Schlehenweg 15, 88471 Baustetten, Germany
+ *  Thomas.Nau@rz.uni-ulm.de
+ *
+ */
+
+
+/* special pour editing routines
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <assert.h>
+#include <math.h>
+#include <memory.h>
+#include <setjmp.h>
+
+#include "global.h"
+#include "box.h"
+#include "create.h"
+#include "crosshair.h"
+#include "data.h"
+#include "draw.h"
+#include "error.h"
+#include "find.h"
+#include "misc.h"
+#include "move.h"
+#include "polygon.h"
+#include "pour.h"
+#include "remove.h"
+#include "rtree.h"
+#include "search.h"
+#include "set.h"
+#include "thermal.h"
+#include "undo.h"
+
+#ifdef HAVE_LIBDMALLOC
+#include <dmalloc.h>
+#endif
+
+RCSID ("$Id$");
+
+#define ROUND(x) ((long)(((x) >= 0 ? (x) + 0.5  : (x) - 0.5)))
+
+#define UNSUBTRACT_BLOAT 100
+
+/* ---------------------------------------------------------------------------
+ * local prototypes
+ */
+
+
+/* --------------------------------------------------------------------------
+ * remove redundant polygon points. Any point that lies on the straight
+ * line between the points on either side of it is redundant.
+ * returns true if any points are removed
+ */
+Boolean
+RemoveExcessPourPoints (LayerTypePtr Layer, PourTypePtr Pour)
+{
+  PointTypePtr pt1, pt2, pt3;
+  Cardinal n;
+  LineType line;
+  Boolean changed = False;
+
+  if (Undoing ())
+    return (False);
+  /* there are always at least three points in a pour */
+  pt1 = &Pour->Points[Pour->PointN - 1];
+  pt2 = &Pour->Points[0];
+  pt3 = &Pour->Points[1];
+  for (n = 0; n < Pour->PointN; n++, pt1++, pt2++, pt3++)
+    {
+      /* wrap around pour */
+      if (n == 1)
+        pt1 = &Pour->Points[0];
+      if (n == Pour->PointN - 1)
+        pt3 = &Pour->Points[0];
+      line.Point1 = *pt1;
+      line.Point2 = *pt3;
+      line.Thickness = 0;
+      if (IsPointOnLine ((float) pt2->X, (float) pt2->Y, 0.0, &line))
+        {
+          RemoveObject (POURPOINT_TYPE, (void *) Layer, (void *) Pour,
+                        (void *) pt2);
+          changed = True;
+        }
+    }
+  return (changed);
+}
+
+/* ---------------------------------------------------------------------------
+ * returns the index of the polygon point which is the end
+ * point of the segment with the lowest distance to the passed
+ * coordinates
+ */
+Cardinal
+GetLowestDistancePourPoint (PourTypePtr Pour, LocationType X,
+                            LocationType Y)
+{
+  double mindistance = (double) MAX_COORD * MAX_COORD;
+  PointTypePtr ptr1 = &Pour->Points[Pour->PointN - 1],
+               ptr2 = &Pour->Points[0];
+  Cardinal n, result = 0;
+
+  /* we calculate the distance to each segment and choose the
+   * shortest distance. If the closest approach between the
+   * given point and the projected line (i.e. the segment extended)
+   * is not on the segment, then the distance is the distance
+   * to the segment end point.
+   */
+
+  for (n = 0; n < Pour->PointN; n++, ptr2++)
+    {
+      register double u, dx, dy;
+      dx = ptr2->X - ptr1->X;
+      dy = ptr2->Y - ptr1->Y;
+      if (dx != 0.0 || dy != 0.0)
+        {
+          /* projected intersection is at P1 + u(P2 - P1) */
+          u = ((X - ptr1->X) * dx + (Y - ptr1->Y) * dy) / (dx * dx + dy * dy);
+
+          if (u < 0.0)
+            {                   /* ptr1 is closest point */
+              u = SQUARE (X - ptr1->X) + SQUARE (Y - ptr1->Y);
+            }
+          else if (u > 1.0)
+            {                   /* ptr2 is closest point */
+              u = SQUARE (X - ptr2->X) + SQUARE (Y - ptr2->Y);
+            }
+          else
+            {                   /* projected intersection is closest point */
+              u = SQUARE (X - ptr1->X * (1.0 - u) - u * ptr2->X) +
+                SQUARE (Y - ptr1->Y * (1.0 - u) - u * ptr2->Y);
+            }
+          if (u < mindistance)
+            {
+              mindistance = u;
+              result = n;
+            }
+        }
+      ptr1 = ptr2;
+    }
+  return (result);
+}
+
+/* ---------------------------------------------------------------------------
+ * go back to the  previous point of the polygon
+ */
+void
+GoToPreviousPourPoint (void)
+{
+  switch (Crosshair.AttachedPour.PointN)
+    {
+      /* do nothing if mode has just been entered */
+    case 0:
+      break;
+
+      /* reset number of points and 'LINE_MODE' state */
+    case 1:
+      Crosshair.AttachedPour.PointN = 0;
+      Crosshair.AttachedLine.State = STATE_FIRST;
+      addedLines = 0;
+      break;
+
+      /* back-up one point */
+    default:
+      {
+        PointTypePtr points = Crosshair.AttachedPour.Points;
+        Cardinal n = Crosshair.AttachedPour.PointN - 2;
+
+        Crosshair.AttachedPour.PointN--;
+        Crosshair.AttachedLine.Point1.X = points[n].X;
+        Crosshair.AttachedLine.Point1.Y = points[n].Y;
+        break;
+      }
+    }
+}
+
+/* ---------------------------------------------------------------------------
+ * close pour if possible
+ */
+void
+ClosePour (void)
+{
+  Cardinal n = Crosshair.AttachedPour.PointN;
+
+  /* check number of points */
+  if (n >= 3)
+    {
+      /* if 45 degree lines are what we want do a quick check
+       * if closing the polygon makes sense
+       */
+      if (!TEST_FLAG (ALLDIRECTIONFLAG, PCB))
+        {
+          BDimension dx, dy;
+
+          dx = abs (Crosshair.AttachedPour.Points[n - 1].X -
+                    Crosshair.AttachedPour.Points[0].X);
+          dy = abs (Crosshair.AttachedPour.Points[n - 1].Y -
+                    Crosshair.AttachedPour.Points[0].Y);
+          if (!(dx == 0 || dy == 0 || dx == dy))
+            {
+              Message
+                (_
+                 ("Cannot close polygon because 45 degree lines are requested.\n"));
+              return;
+            }
+        }
+      CopyAttachedPourToLayer ();
+      Draw ();
+    }
+  else
+    Message (_("A polygon has to have at least 3 points\n"));
+}
+
+/* ---------------------------------------------------------------------------
+ * moves the data of the attached (new) polygon to the current layer
+ */
+void
+CopyAttachedPourToLayer (void)
+{
+  PourTypePtr pour;
+  int saveID;
+
+  /* move data to layer and clear attached struct */
+  pour = CreateNewPour (CURRENT, NoFlags ());
+  saveID = pour->ID;
+  *pour = Crosshair.AttachedPour;
+  pour->ID = saveID;
+  SET_FLAG (CLEARPOLYFLAG, pour);
+  if (TEST_FLAG (NEWFULLPOLYFLAG, PCB))
+    SET_FLAG (FULLPOLYFLAG, pour);
+  memset (&Crosshair.AttachedPour, 0, sizeof (PourType));
+  SetPourBoundingBox (pour);
+  if (!CURRENT->pour_tree)
+    CURRENT->pour_tree = r_create_tree (NULL, 0, 0);
+  r_insert_entry (CURRENT->pour_tree, (BoxType *) pour, 0);
+  InitPourClip (PCB->Data, CURRENT, pour);
+//  DrawPolygon (CURRENT, polygon, 0);
+  DrawPour (CURRENT, pour, 0);
+  SetChangedFlag (True);
+
+  /* reset state of attached line */
+  Crosshair.AttachedLine.State = STATE_FIRST;
+  addedLines = 0;
+
+  /* add to undo list */
+  AddObjectToCreateUndoList (POUR_TYPE, CURRENT, pour, pour);
+  IncrementUndoSerialNumber ();
+}
+
+/*---------------------------------------- END OF NICE GENTLE UI DRIVEN PIECES OF THE POUR CODE --------------*/
+
+/*---------------------------------------- THIS CODE BELOW WILL MURDER SMALL ANIMALS THEN LAUGH --------------*/
+
+/* ---------------------------------------------------------------------------
+ * destroys a polygon from a pour
+ */
+static void *
+DestroyPolygonInPour (PourTypePtr pour, PolygonTypePtr polygon)
+{
+  r_delete_entry (pour->polygon_tree, (BoxTypePtr) polygon);
+
+  FreePolygonMemory (polygon);
+  *polygon = pour->Polygons[ --pour->PolygonN ];
+  r_substitute (pour->polygon_tree,
+                (BoxType *) & pour->Polygons[ pour->PolygonN ],
+                (BoxType *) polygon);
+  memset (&pour->Polygons[ pour->PolygonN ], 0, sizeof (PolygonType));
+  return (NULL);
+}
+
+static int
+subtract_poly (POLYAREA * np1, POLYAREA **pg)
+{
+  POLYAREA *merged = NULL, *np = np1;
+  int x;
+
+  assert (np);
+  assert (pg);
+  assert (*pg);
+
+  if (pg == NULL)
+    {
+      printf ("Hmm, got pg == NULL in subtract_poly\n");
+      poly_Free (&np);
+      return -1;
+    }
+
+  assert (poly_Valid (*pg));
+  assert (poly_Valid (np));
+  x = poly_Boolean_free (*pg, np, &merged, PBO_SUB);
+  if (x != err_ok)
+    {
+      fprintf (stderr, "Error while clipping PBO_SUB: %d\n", x);
+      poly_Free (&merged);
+      *pg = NULL;
+      return -1;
+    }
+
+  assert (!merged || poly_Valid (merged));
+
+  *pg = merged;
+  return 1;
+}
+
+  static int
+unite_poly (POLYAREA * np, POLYAREA ** pg)
+{
+  POLYAREA *merged = NULL;
+  int x;
+  assert (np);
+  assert (pg);
+//  assert (*pg);
+  x = poly_Boolean_free (*pg, np, &merged, PBO_UNITE);
+  if (x != err_ok)
+    {
+      fprintf (stderr, "Error while clipping PBO_UNITE: %d\n", x);
+      poly_Free (&merged);
+      *pg = NULL;
+      return 0;
+    }
+  assert (!merged || poly_Valid (merged));
+  *pg = merged;
+  return 1;
+}
+
+static int
+intersect_poly (POLYAREA * np, POLYAREA ** pg)
+{
+  POLYAREA *merged;
+  int x;
+  assert (np);
+  assert (pg);
+  assert (*pg);
+  x = poly_Boolean_free (*pg, np, &merged, PBO_ISECT);
+  if (x != err_ok)
+    {
+      fprintf (stderr, "Error while clipping PBO_ISECT: %d\n", x);
+      poly_Free (&merged);
+      *pg = NULL;
+      return 0;
+    }
+  assert (!merged || poly_Valid (merged));
+  *pg = merged;
+  return 1;
+}
+
+
+static POLYAREA *
+get_subtract_pin_poly (DataType * d, PinType * pin, LayerType * l, PourType *pour)
+{
+  POLYAREA *np;
+  Cardinal i;
+
+  if (pin->Clearance == 0)
+    return NULL;
+
+  i = GetLayerNumber (d, l);
+  if (TEST_THERM (i, pin))
+    np = ThermPoly ((PCBTypePtr) (d->pcb), pin, i);
+  else
+    np = PinPoly (pin, pin->Thickness, pin->Clearance);
+
+  return np;
+}
+
+static POLYAREA *
+get_subtract_line_poly (LineType *line, PourType *pour)
+{
+  if (!TEST_FLAG (CLEARLINEFLAG, line))
+    return NULL;
+
+  return LinePoly (line, line->Thickness + line->Clearance);
+}
+
+static POLYAREA *
+get_subtract_arc_poly (ArcType * arc, PourType * pour)
+{
+  if (!TEST_FLAG (CLEARLINEFLAG, arc))
+    return NULL;
+
+  return ArcPoly (arc, arc->Thickness + arc->Clearance);
+}
+
+static POLYAREA *
+get_subtract_text_poly (TextType * text, PourType * pour)
+{
+  const BoxType *b = &text->BoundingBox;
+
+  if (!TEST_FLAG (CLEARLINEFLAG, text))
+    return NULL;
+
+  return RoundRect (b->X1 + PCB->Bloat, b->X2 - PCB->Bloat,
+                    b->Y1 + PCB->Bloat, b->Y2 - PCB->Bloat, PCB->Bloat);
+}
+
+static POLYAREA *
+get_subtract_pad_poly (PadType * pad, PourType * pour)
+{
+  POLYAREA *np;
+
+  if (pad->Clearance == 0)
+    return NULL;
+
+  if (TEST_FLAG (SQUAREFLAG, pad))
+    np = SquarePadPoly (pad, pad->Thickness + pad->Clearance);
+  else
+    np = LinePoly ((LineType *) pad, pad->Thickness + pad->Clearance);
+
+  return np;
+}
+
+static POLYAREA *
+get_subtract_polygon_poly (PolygonType * polygon, PourType * pour)
+{
+  POLYAREA *np;
+
+  /* Don't subtract from ourselves! */
+  if (polygon->ParentPour == pour || !TEST_FLAG (CLEARLINEFLAG, polygon))
+    return NULL;
+
+  poly_Copy0 (&np, polygon->Clipped);
+
+  return np;
+}
+
+struct cpInfo
+{
+  const BoxType *other;
+  DataType *data;
+  LayerType *layer;
+  PourType *pour;
+  Boolean solder;
+  POLYAREA *pg;
+  BoxType *region;
+  jmp_buf env;
+};
+
+static int
+pin_sub_callback (const BoxType * b, void *cl)
+{
+  PinTypePtr pin = (PinTypePtr) b;
+  struct cpInfo *info = (struct cpInfo *) cl;
+  POLYAREA *np;
+
+  /* don't subtract the object that was put back! */
+  if (b == info->other)
+    return 0;
+
+  np = get_subtract_pin_poly (info->data, pin, info->layer, info->pour);
+  if (np == NULL)
+    return 0;
+
+  if (subtract_poly (np, &info->pg) < 0)
+    longjmp (info->env, 1);
+  return 1;
+}
+
+static int
+arc_sub_callback (const BoxType * b, void *cl)
+{
+  ArcTypePtr arc = (ArcTypePtr) b;
+  struct cpInfo *info = (struct cpInfo *) cl;
+  POLYAREA *np;
+
+  /* don't subtract the object that was put back! */
+  if (b == info->other)
+    return 0;
+  if (!TEST_FLAG (CLEARLINEFLAG, arc))
+    return 0;
+
+  np = get_subtract_arc_poly (arc, info->pour);
+  if (np == NULL)
+    return 0;
+
+  if (subtract_poly (np, &info->pg) < 0)
+    longjmp (info->env, 1);
+  return 1;
+}
+
+static int
+pad_sub_callback (const BoxType * b, void *cl)
+{
+  PadTypePtr pad = (PadTypePtr) b;
+  struct cpInfo *info = (struct cpInfo *) cl;
+  POLYAREA *np;
+
+  /* don't subtract the object that was put back! */
+  if (b == info->other)
+    return 0;
+  if (XOR (TEST_FLAG (ONSOLDERFLAG, pad), info->solder))
+    return 0;
+
+  np = get_subtract_pad_poly (pad, info->pour);
+  if (np == NULL)
+    return 0;
+
+  if (subtract_poly (np, &info->pg) < 0)
+    longjmp (info->env, 1);
+  return 1;
+}
+
+static int
+line_sub_callback (const BoxType * b, void *cl)
+{
+  LineTypePtr line = (LineTypePtr) b;
+  struct cpInfo *info = (struct cpInfo *) cl;
+  POLYAREA *np;
+
+  /* don't subtract the object that was put back! */
+  if (b == info->other)
+    return 0;
+  if (!TEST_FLAG (CLEARLINEFLAG, line))
+    return 0;
+
+  np = get_subtract_line_poly (line, info->pour);
+  if (np == NULL)
+    return 0;
+
+  if (subtract_poly (np, &info->pg) < 0)
+    longjmp (info->env, 1);
+  return 1;
+}
+
+
+static int
+text_sub_callback (const BoxType * b, void *cl)
+{
+  TextTypePtr text = (TextTypePtr) b;
+  struct cpInfo *info = (struct cpInfo *) cl;
+  POLYAREA *np;
+
+  /* don't subtract the object that was put back! */
+  if (b == info->other)
+    return 0;
+  if (!TEST_FLAG (CLEARLINEFLAG, text))
+    return 0;
+
+  np = get_subtract_text_poly (text, info->pour);
+  if (np == NULL)
+    return 0;
+
+  if (subtract_poly (np, &info->pg) < 0)
+    longjmp (info->env, 1);
+  return 1;
+}
+
+static int
+poly_sub_callback (const BoxType * b, void *cl)
+{
+  PolygonTypePtr poly = (PolygonTypePtr) b;
+  struct cpInfo *info = (struct cpInfo *) cl;
+  POLYAREA *np;
+
+  /* don't subtract the object that was put back! */
+  if (b == info->other)
+    return 0;
+  if (!TEST_FLAG (CLEARLINEFLAG, poly))
+    return 0;
+
+  np = get_subtract_polygon_poly (poly, info->pour);
+  if (np == NULL)
+    return 0;
+
+  if (subtract_poly (np, &info->pg) < 0)
+    longjmp (info->env, 1);
+  return 1;
+}
+
+static int
+pour_sub_callback (const BoxType * b, void *cl)
+{
+  PourTypePtr pour = (PourTypePtr) b;
+  struct cpInfo *info = (struct cpInfo *) cl;
+  BoxType *region = info->region;
+
+  return r_search (pour->polygon_tree, region, NULL, poly_sub_callback, info);
+
+}
+
+static int
+Group (DataTypePtr Data, Cardinal layer)
+{
+  Cardinal i, j;
+  for (i = 0; i < max_layer; i++)
+    for (j = 0; j < ((PCBType *) (Data->pcb))->LayerGroups.Number[i]; j++)
+      if (layer == ((PCBType *) (Data->pcb))->LayerGroups.Entries[i][j])
+        return i;
+  return i;
+}
+
+/* NB: For convenience, we're passing the defined POLYAREA in here */
+static int
+ClearPour (DataTypePtr Data, LayerTypePtr Layer, PourType * pour,
+           POLYAREA **pg, const BoxType * here, BDimension expand)
+{
+  int r = 0;
+  BoxType region;
+  struct cpInfo info;
+  Cardinal group;
+
+  if (!TEST_FLAG (CLEARPOLYFLAG, pour)
+      || GetLayerNumber (Data, Layer) >= max_layer)
+    return 0;
+  group = Group (Data, GetLayerNumber (Data, Layer));
+  info.solder = (group == Group (Data, max_layer + SOLDER_LAYER));
+  info.data = Data;
+  info.other = here;
+  info.layer = Layer;
+  info.pour = pour;
+  info.pg = *pg;
+  if (here)
+    region = clip_box (here, &pour->BoundingBox);
+  else
+    region = pour->BoundingBox;
+  region = bloat_box (&region, expand);
+  info.region = &region;
+
+  if (setjmp (info.env) == 0)
+    {
+      r  = r_search (Data->via_tree, &region, NULL, pin_sub_callback, &info);
+      r += r_search (Data->pin_tree, &region, NULL, pin_sub_callback, &info);
+      GROUP_LOOP (Data, group);
+      {
+        r += r_search (layer->line_tree, &region, NULL, line_sub_callback, &info);
+        r += r_search (layer->arc_tree,  &region, NULL, arc_sub_callback,  &info);
+        r += r_search (layer->text_tree, &region, NULL, text_sub_callback, &info);
+        r += r_search (layer->pour_tree, &region, NULL, pour_sub_callback, &info);
+      }
+      END_LOOP;
+      if (info.solder || group == Group (Data, max_layer + COMPONENT_LAYER))
+        r += r_search (Data->pad_tree, &region, NULL, pad_sub_callback, &info);
+    }
+
+  *pg = info.pg;
+
+  return r;
+}
+
+static int
+subtract_plow (DataTypePtr Data, LayerTypePtr Layer, PourTypePtr pour,
+              int type, void *ptr1, void *ptr2)
+{
+  POLYAREA *np = NULL, *pg = NULL, *start_pg, *tmp;
+  int count, count_all, count_added;
+
+  switch (type)
+    {
+    case PIN_TYPE:
+    case VIA_TYPE:
+      np = get_subtract_pin_poly (Data, (PinTypePtr) ptr2, Layer, pour);
+      break;
+    case LINE_TYPE:
+      np = get_subtract_line_poly ((LineTypePtr) ptr2, pour);
+      break;
+    case ARC_TYPE:
+      np = get_subtract_arc_poly ((ArcTypePtr) ptr2, pour);
+      break;
+    case PAD_TYPE:
+      np = get_subtract_pad_poly ((PadTypePtr) ptr2, pour);
+      break;
+    case POLYGON_TYPE:
+      np = get_subtract_polygon_poly ((PolygonTypePtr) ptr2, pour);
+      break;
+    case TEXT_TYPE:
+      np = get_subtract_text_poly ((TextTypePtr) ptr2, pour);
+      break;
+    }
+
+  if (np == NULL)
+    {
+      printf ("Didn't get a POLYAREA to subtract, so bailing\n");
+      return 0;
+    }
+
+  assert (poly_Valid (np));
+
+  /* Make pg contain the polygons we're going to fiddle with */
+
+  count = 0;
+  POURPOLYGON_LOOP (pour);
+  {
+    /* Gather up children which are touched by np */
+    if (isects (np, polygon, False))
+      {
+        count++;
+        /* Steal their clipped contours, then delete them */
+        /* Add contour to local list to fiddle about with */
+
+        assert (poly_Valid (polygon->Clipped));
+        if (polygon->Clipped == NULL)
+          {
+            printf ("Got polygon->clipped == NULL!\n");
+            continue;
+          }
+        if (pg == NULL)
+          {
+            pg = polygon->Clipped;
+            polygon->Clipped = NULL;
+          }
+        else
+          {
+            /* Link the _single_ polygon->Clipped into our circular pg list. */
+            polygon->Clipped->f = pg;
+            polygon->Clipped->b = pg->b;
+            pg->b->f = polygon->Clipped;
+            pg->b = polygon->Clipped;
+            polygon->Clipped = NULL;
+          }
+        /* POURPOLYGON_LOOP iterates backwards, so it's OK
+         * to delete the current element we're sitting on */
+        DestroyPolygonInPour (pour, polygon);
+      }
+  }
+  END_LOOP;
+//  printf ("Subtract counted %i touching children, now removed\n", count);
+
+  if (pg == NULL)
+    {
+      printf ("Hmm, got pg == NULL in subtract_plow\n");
+      poly_Free (&np);
+      return -1;
+    }
+
+  assert (poly_Valid (pg));
+
+  /* Perform the subtract operation */
+
+  /* NB: Old *pg is freed inside subtract_poly */
+  subtract_poly (np, &pg);
+
+  if (pg == NULL)
+    {
+      printf ("Poly killed to death by subtracting\n");
+      return -1;
+    }
+
+#if 0
+  count = 0;
+  { POLYAREA *pg_start;
+  pg_start = pg;
+  do {
+    count++;
+  } while ((pg = pg->f) != pg_start);
+  }
+  printf ("After subtract, counted %i polygon pieces\n", count);
+#endif
+
+  count_all = count_added = 0;
+  /* For each piece of the clipped up polygon, create a new child */
+  start_pg = pg;
+  do
+    {
+      PolygonType *poly;
+
+      tmp = pg->f;
+      pg->f = pg;
+      pg->b = pg;
+
+      count_all++;
+//      if (pg->contours->area > PCB->IsleArea)
+      if (1) // Breaks incremental updates otherwise
+        {
+          count_added++;
+          poly = CreateNewPolygonInPour (pour, pour->Flags);
+          poly->Clipped = pg;
+          CLEAR_FLAG (SELECTEDFLAG, poly);
+
+          SetPolygonBoundingBox (poly);
+
+          if (pour->polygon_tree == NULL)
+            pour->polygon_tree = r_create_tree (NULL, 0, 0);
+          r_insert_entry (pour->polygon_tree, (BoxType *) poly, 0);
+        }
+      else
+        {
+          poly_Free (&pg);
+        }
+    }
+  while ((pg = tmp) != start_pg);
+
+  return 0;
+}
+
+static POLYAREA *
+get_unsubtract_pin_poly (PinType * pin, LayerType * l, PourType * pour)
+{
+  /* overlap a bit to prevent gaps from rounding errors */
+  return BoxPolyBloated (&pin->BoundingBox, UNSUBTRACT_BLOAT);
+}
+
+static POLYAREA *
+get_unsubtract_arc_poly (ArcType * arc, LayerType * l, PourType * pour)
+{
+  if (!TEST_FLAG (CLEARLINEFLAG, arc))
+    return NULL;
+
+  /* overlap a bit to prevent gaps from rounding errors */
+  return BoxPolyBloated (&arc->BoundingBox, UNSUBTRACT_BLOAT);
+}
+
+static POLYAREA *
+get_unsubtract_line_poly (LineType * line, LayerType * l, PourType * pour)
+{
+  if (!TEST_FLAG (CLEARLINEFLAG, line))
+    return NULL;
+
+  /* overlap a bit to prevent notches from rounding errors */
+  return BoxPolyBloated (&line->BoundingBox, UNSUBTRACT_BLOAT);
+}
+
+static POLYAREA *
+get_unsubtract_text_poly (TextType * text, LayerType * l, PourType * pour)
+{
+  if (!TEST_FLAG (CLEARLINEFLAG, text))
+    return NULL;
+
+  /* overlap a bit to prevent notches from rounding errors */
+  return BoxPolyBloated (&text->BoundingBox, UNSUBTRACT_BLOAT);
+}
+
+static POLYAREA *
+get_unsubtract_pad_poly (PadType * pad, LayerType * l, PourType * pour)
+{
+  /* overlap a bit to prevent notches from rounding errors */
+  return BoxPolyBloated (&pad->BoundingBox, UNSUBTRACT_BLOAT);
+}
+
+static POLYAREA *
+get_unsubtract_polygon_poly (PolygonType * poly, LayerType * l, PourType * pour)
+{
+  /* Don't subtract from ourselves, or if CLEARLINEFLAG isn't set */
+  if (poly->ParentPour == pour || !TEST_FLAG (CLEARLINEFLAG, poly))
+    return NULL;
+
+  /* overlap a bit to prevent notches from rounding errors */
+  return BoxPolyBloated (&poly->BoundingBox, UNSUBTRACT_BLOAT);
+}
+
+static POLYAREA *
+original_pour_poly (PourType * p)
+{
+  PLINE *contour = NULL;
+  POLYAREA *np = NULL;
+  Vector v;
+
+  /* first make initial polygon contour */
+  POURPOINT_LOOP (p);
+  {
+    v[0] = point->X;
+    v[1] = point->Y;
+    if (contour == NULL)
+      {
+        if ((contour = poly_NewContour (v)) == NULL)
+          return NULL;
+      }
+    else
+      poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+  }
+  END_LOOP;
+  if (contour == NULL)
+    {
+      printf ("How did that escape - did the loop iterate zero times??\n");
+      POURPOINT_LOOP (p);
+        {
+          printf ("Hello\n");
+        }
+      END_LOOP;
+      return NULL;
+    }
+  poly_PreContour (contour, TRUE);
+  /* make sure it is a positive contour */
+  if ((contour->Flags.orient) != PLF_DIR)
+    poly_InvContour (contour);
+  assert ((contour->Flags.orient) == PLF_DIR);
+  if ((np = poly_Create ()) == NULL)
+    return NULL;
+  poly_InclContour (np, contour);
+  assert (poly_Valid (np));
+  return np;
+}
+
+static int
+add_plow (DataTypePtr Data, LayerTypePtr Layer, PourTypePtr pour,
+          int type, void *ptr1, void *ptr2)
+{
+  POLYAREA *np = NULL, *pg = NULL, *tmp, *start_pg;
+  POLYAREA *orig_poly;
+  int count, count_all, count_added;
+
+  switch (type)
+    {
+    case PIN_TYPE:
+    case VIA_TYPE:
+      np = get_unsubtract_pin_poly ((PinTypePtr) ptr2, Layer, pour);
+      break;
+    case LINE_TYPE:
+      np = get_unsubtract_line_poly ((LineTypePtr) ptr2, Layer, pour);
+      break;
+    case ARC_TYPE:
+      np = get_unsubtract_arc_poly ((ArcTypePtr) ptr2, Layer, pour);
+      break;
+    case PAD_TYPE:
+      np = get_unsubtract_pad_poly ((PadTypePtr) ptr2, Layer, pour);
+      break;
+    case POLYGON_TYPE:
+      np = get_unsubtract_polygon_poly ((PolygonTypePtr) ptr2, Layer, pour);
+      break;
+    case TEXT_TYPE:
+      np = get_unsubtract_text_poly ((TextTypePtr) ptr2, Layer, pour);
+      break;
+    }
+
+  if (np == NULL)
+    {
+      printf ("Didn't get a POLYAREA to add, so bailing\n");
+      return 0;
+    }
+
+  orig_poly = original_pour_poly (pour);
+  /* NB: orig_poly and old *pg are freed inside intersect_poly() */
+  intersect_poly (orig_poly, &np);
+
+  if (np == NULL)
+    {
+      printf ("POLYAREA to add got clipped away, so bailing\n");
+      return 0;
+    }
+
+  assert (poly_Valid (np));
+
+  /* Make pg contain the polygons we're going to fiddle with */
+
+  count = 0;
+  POURPOLYGON_LOOP (pour);
+  {
+    /* Gather up children which are touched by np */
+    if (isects (np, polygon, False))
+      {
+        count++;
+        /* Steal their clipped contours, then delete them */
+        /* Add contour to local list to fiddle about with */
+
+        assert (poly_Valid (polygon->Clipped));
+        if (polygon->Clipped == NULL)
+          {
+            printf ("Got polygon->clipped == NULL!\n");
+            continue;
+          }
+        if (pg == NULL)
+          {
+            pg = polygon->Clipped;
+            polygon->Clipped = NULL;
+          }
+        else
+          {
+            /* Link the _single_ polygon->Clipped into our circular pg list. */
+            polygon->Clipped->f = pg;
+            polygon->Clipped->b = pg->b;
+            pg->b->f = polygon->Clipped;
+            pg->b = polygon->Clipped;
+            polygon->Clipped = NULL;
+          }
+        /* POURPOLYGON_LOOP iterates backwards, so it's OK
+         * to delete the current element we're sitting on */
+        DestroyPolygonInPour (pour, polygon);
+      }
+  }
+  END_LOOP;
+//  printf ("Unsubtract counted %i touching children, now removed\n", count);
+
+  if (pg == NULL)
+    {
+      printf ("Hmm, got pg == NULL in add_plow\n");
+//      poly_Free (&np);
+//      return -1;
+    }
+
+//  assert (poly_Valid (pg));
+
+  /* Perform the union operation */
+  /* NB: np and old *pg are freed inside union_poly() */
+  unite_poly (np, &pg);
+
+
+#if 0
+  count = 0;
+  { POLYAREA *pg_start;
+  pg_start = pg;
+  do {
+    count++;
+  } while ((pg = pg->f) != pg_start);
+  }
+  printf ("After unsubtract, counted %i polygon pieces\n", count);
+#endif
+
+  ClearPour (PCB->Data, Layer, pour, &pg, (const BoxType *) ptr2, 2 * UNSUBTRACT_BLOAT);
+
+  if (pg == NULL)
+    {
+      printf ("Poly killed to death somehow\n");
+      return -1;
+    }
+
+  /* For each piece of the clipped up polygon, create a new child */
+  count_all = count_added = 0;
+  start_pg = pg;
+  do
+    {
+      PolygonType *poly;
+
+      tmp = pg->f;
+      pg->f = pg;
+      pg->b = pg;
+      count_all++;
+//      if (pg->contours->area > PCB->IsleArea)
+      if (1) // Breaks incremental updates otherwise
+        {
+          count_added++;
+          poly = CreateNewPolygonInPour (pour, pour->Flags);
+          poly->Clipped = pg;
+          CLEAR_FLAG (SELECTEDFLAG, poly);
+
+          SetPolygonBoundingBox (poly);
+
+          if (pour->polygon_tree == NULL)
+            pour->polygon_tree = r_create_tree (NULL, 0, 0);
+          r_insert_entry (pour->polygon_tree, (BoxType *) poly, 0);
+        }
+      else
+        {
+          printf ("Too small\n");
+          poly_Free (&pg);
+        }
+    }
+  while ((pg = tmp) != start_pg);
+
+//  printf ("ClearPour counted %i polygon pieces, and added the biggest %i\n", count_all, count_added);
+
+  return 0;
+}
+
+/* ---------------------------------------------------------------------------------------------------------- */
+
+int
+InitPourClip (DataTypePtr Data, LayerTypePtr layer, PourType * pour)
+{
+  POLYAREA *pg, *tmp, *start_pg;
+  int count_all, count_added;
+
+  /* Free any children we might have */
+  if (pour->PolygonN)
+    {
+      POURPOLYGON_LOOP (pour);
+      {
+        /* POURPOLYGON_LOOP iterates backwards, so it's OK
+         * to delete the current element we're sitting on */
+        DestroyPolygonInPour (pour, polygon);
+      }
+      END_LOOP;
+    }
+
+  pg = original_pour_poly (pour);
+  if (!pg)
+    {
+      printf ("Clipping returned NULL - can that be good?\n");
+      return 0;
+    }
+//  assert (poly_Valid (clipped));
+  if (TEST_FLAG (CLEARPOLYFLAG, pour))
+    {
+      /* Clip the pour against anything we can find in this layer */
+      ClearPour (Data, layer, pour, &pg, NULL, UNSUBTRACT_BLOAT);
+    }
+
+  if (pg == NULL)
+    {
+      printf ("Got pg == NULL for some reason\n");
+      return 0;
+    }
+
+  count_all = count_added = 0;
+  /* For each piece of the clipped up polygon, create a new child */
+  start_pg = pg;
+  do
+    {
+      PolygonType *poly;
+
+      tmp = pg->f;
+      pg->f = pg;
+      pg->b = pg;
+
+      count_all++;
+//      if (pg->contours->area > PCB->IsleArea)
+      if (1) // Breaks incremental updates otherwise
+        {
+          count_added++;
+          poly = CreateNewPolygonInPour (pour, pour->Flags);
+          poly->Clipped = pg;
+          CLEAR_FLAG (SELECTEDFLAG, poly);
+
+          SetPolygonBoundingBox (poly);
+
+          if (pour->polygon_tree == NULL)
+            pour->polygon_tree = r_create_tree (NULL, 0, 0);
+          r_insert_entry (pour->polygon_tree, (BoxType *) poly, 0);
+        }
+      else
+        {
+          poly_Free (&pg);
+        }
+    }
+  while ((pg = tmp) != start_pg);
+
+  return 1;
+}
+
+struct plow_info
+{
+  int type;
+  void *ptr1, *ptr2;
+  LayerTypePtr layer;
+  DataTypePtr data;
+  int (*callback) (DataTypePtr, LayerTypePtr,
+                   PourTypePtr, int, void *, void *);
+};
+
+static int
+plow_callback (const BoxType * b, void *cl)
+{
+  struct plow_info *plow = (struct plow_info *) cl;
+  PourTypePtr pour = (PourTypePtr) b;
+
+  if (TEST_FLAG (CLEARPOLYFLAG, pour))
+    return plow->callback (plow->data, plow->layer, pour,
+                           plow->type, plow->ptr1, plow->ptr2);
+  return 0;
+}
+
+int
+PlowPours (DataType * Data, int type, void *ptr1, void *ptr2,
+           int (*call_back) (DataTypePtr data, LayerTypePtr lay,
+                             PourTypePtr poly, int type,
+                             void *ptr1, void *ptr2))
+{
+  BoxType sb = ((PinTypePtr) ptr2)->BoundingBox;
+  int r = 0;
+  struct plow_info info;
+
+  info.type = type;
+  info.ptr1 = ptr1;
+  info.ptr2 = ptr2;
+  info.data = Data;
+  info.callback = call_back;
+  switch (type)
+    {
+    case PIN_TYPE:
+    case VIA_TYPE:
+      if (type == PIN_TYPE || ptr1 == ptr2 || ptr1 == NULL)
+        {
+          LAYER_LOOP (Data, max_layer);
+          {
+            info.layer = layer;
+            r += r_search (layer->pour_tree, &sb, NULL, plow_callback, &info);
+          }
+          END_LOOP;
+        }
+      else
+        {
+          int layer_no = GetLayerNumber (Data, ((LayerTypePtr) ptr1));
+          int group_no = GetLayerGroupNumberByNumber (layer_no);
+          GROUP_LOOP (Data, group_no);
+          {
+            info.layer = layer;
+            r += r_search (layer->pour_tree, &sb, NULL, plow_callback, &info);
+          }
+          END_LOOP;
+        }
+      break;
+    case LINE_TYPE:
+    case ARC_TYPE:
+    case TEXT_TYPE:
+    case POLYGON_TYPE:
+      /* the cast works equally well for lines and arcs */
+      if (!TEST_FLAG (CLEARLINEFLAG, (LineTypePtr) ptr2))
+        return 0;
+      /* silk doesn't plow */
+      if (GetLayerNumber (Data, ptr1) >= max_layer)
+        return 0;
+      GROUP_LOOP (Data, GetLayerGroupNumberByNumber (GetLayerNumber (Data,
+                                                                     ((LayerTypePtr) ptr1))));
+      {
+        info.layer = layer;
+        r += r_search (layer->pour_tree, &sb, NULL, plow_callback, &info);
+      }
+      END_LOOP;
+      break;
+    case PAD_TYPE:
+      {
+        Cardinal group = TEST_FLAG (ONSOLDERFLAG,
+                                    (PadType *) ptr2) ? SOLDER_LAYER :
+          COMPONENT_LAYER;
+        group = GetLayerGroupNumberByNumber (max_layer + group);
+        GROUP_LOOP (Data, group);
+        {
+          info.layer = layer;
+          r += r_search (layer->pour_tree, &sb, NULL, plow_callback, &info);
+        }
+        END_LOOP;
+      }
+      break;
+
+    case ELEMENT_TYPE:
+      {
+        PIN_LOOP ((ElementType *) ptr1);
+        {
+          PlowPours (Data, PIN_TYPE, ptr1, pin, call_back);
+        }
+        END_LOOP;
+        PAD_LOOP ((ElementType *) ptr1);
+        {
+          PlowPours (Data, PAD_TYPE, ptr1, pad, call_back);
+        }
+        END_LOOP;
+      }
+      break;
+    }
+  return r;
+}
+
+void
+RestoreToPours (DataType * Data, int type, void *ptr1, void *ptr2)
+{
+  if (type == POUR_TYPE)
+    {
+#warning FIXME Later: Why do we need to do this?
+//      printf ("Calling InitPourClip from RestoreToPour\n");
+      InitPourClip (PCB->Data, (LayerTypePtr) ptr1, (PourTypePtr) ptr2);
+    }
+  PlowPours (Data, type, ptr1, ptr2, add_plow);
+}
+
+void
+ClearFromPours (DataType * Data, int type, void *ptr1, void *ptr2)
+{
+  if (type == POUR_TYPE)
+    {
+#warning FIXME Later: Why do we need to do this?
+//      printf ("Calling InitPourClip from ClearFromPour\n");
+      InitPourClip (PCB->Data, (LayerTypePtr) ptr1, (PourTypePtr) ptr2);
+    }
+  PlowPours (Data, type, ptr1, ptr2, subtract_plow);
+}
+
diff --git a/src/pour.h b/src/pour.h
new file mode 100644
index 0000000..f04e342
--- /dev/null
+++ b/src/pour.h
@@ -0,0 +1,47 @@
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 1994,1995,1996 Thomas Nau
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Contact addresses for paper mail and Email:
+ *  Thomas Nau, Schlehenweg 15, 88471 Baustetten, Germany
+ *  Thomas.Nau@rz.uni-ulm.de
+ *
+ *  RCS: $Id$
+ */
+
+/* prototypes for pour editing routines
+ */
+
+#ifndef	__POUR_INCLUDED__
+#define	__POUR_INCLUDED__
+
+#include "global.h"
+
+Cardinal GetLowestDistancePourPoint (PourTypePtr,
+					LocationType, LocationType);
+Boolean RemoveExcessPourPoints (LayerTypePtr, PourTypePtr);
+void GoToPreviousPourPoint (void);
+void ClosePour (void);
+void CopyAttachedPourToLayer (void);
+
+int InitPourClip(DataType *d, LayerType *l, PourType *p);
+void RestoreToPours(DataType *, int, void *, void *);
+void ClearFromPours(DataType *, int, void *, void *);
+
+#endif /* __POUR_INCLUDED__ */
diff --git a/src/puller.c b/src/puller.c
index 848d394..db123b1 100644
--- a/src/puller.c
+++ b/src/puller.c
@@ -1704,6 +1704,8 @@ gp_text_cb (const BoxType *b, void *cb)
   return 0;
 }
 
+#warning FIXME Later: Really want to geometry of the clipped polygons
+#if 0
 static int
 gp_poly_cb (const BoxType *b, void *cb)
 {
@@ -1713,6 +1715,18 @@ gp_poly_cb (const BoxType *b, void *cb)
     gp_point (p->Points[i].X, p->Points[i].Y, 0, 0);
   return 0;
 }
+#endif
+
+#warning FIXME Later: Really want to geometry of the clipped polygons
+static int
+gp_pour_cb (const BoxType *b, void *cb)
+{
+  int i;
+  const PourTypePtr p = (PourTypePtr) b;
+  for (i=0; i<p->PointN; i++)
+    gp_point (p->Points[i].X, p->Points[i].Y, 0, 0);
+  return 0;
+}
 
 static int
 gp_pin_cb (const BoxType *b, void *cb)
@@ -2238,7 +2252,7 @@ maybe_pull_1 (LineTypePtr line)
   r_search(CURRENT->line_tree, &box, NULL, gp_line_cb, 0);
   r_search(CURRENT->arc_tree, &box, NULL, gp_arc_cb, 0);
   r_search(CURRENT->text_tree, &box, NULL, gp_text_cb, 0);
-  r_search(CURRENT->polygon_tree, &box, NULL, gp_poly_cb, 0);
+  r_search(CURRENT->pour_tree, &box, NULL, gp_pour_cb, 0);
   r_search(PCB->Data->pin_tree, &box, NULL, gp_pin_cb, 0);
   r_search(PCB->Data->via_tree, &box, NULL, gp_pin_cb, 0);
   r_search(PCB->Data->pad_tree, &box, NULL, gp_pad_cb, 0);
diff --git a/src/rats.c b/src/rats.c
index c174cc9..e0e6a32 100644
--- a/src/rats.c
+++ b/src/rats.c
@@ -513,20 +513,24 @@ GatherSubnets (NetListTypePtr Netl, Boolean NoWarn, Boolean AndRats)
       }
       ENDALL_LOOP;
       /* add polygons so the auto-router can see them as targets */
-      ALLPOLYGON_LOOP (PCB->Data);
+      ALLPOUR_LOOP (PCB->Data);
       {
-	if (TEST_FLAG (DRCFLAG, polygon))
-	  {
-	    conn = GetConnectionMemory (a);
-	    /* make point on a vertex */
-	    conn->X = polygon->Clipped->contours->head.point[0];
-	    conn->Y = polygon->Clipped->contours->head.point[1];
-	    conn->type = POLYGON_TYPE;
-	    conn->ptr1 = layer;
-	    conn->ptr2 = polygon;
-	    conn->group = GetLayerGroupNumberByPointer (layer);
-	    conn->menu = NULL;	/* agnostic view of where it belongs */
-	  }
+        POURPOLYGON_LOOP (pour);
+        {
+          if (TEST_FLAG (DRCFLAG, polygon))
+            {
+              conn = GetConnectionMemory (a);
+              /* make point on a vertex */
+              conn->X = polygon->Clipped->contours->head.point[0];
+              conn->Y = polygon->Clipped->contours->head.point[1];
+              conn->type = POLYGON_TYPE;
+              conn->ptr1 = layer;
+              conn->ptr2 = polygon;
+              conn->group = GetLayerGroupNumberByPointer (layer);
+              conn->menu = NULL;	/* agnostic view of where it belongs */
+            }
+        }
+        END_LOOP;
       }
       ENDALL_LOOP;
       VIA_LOOP (PCB->Data);
diff --git a/src/remove.c b/src/remove.c
index a82b478..31d2bb4 100644
--- a/src/remove.c
+++ b/src/remove.c
@@ -46,6 +46,7 @@
 #include "move.h"
 #include "mymem.h"
 #include "polygon.h"
+#include "pour.h"
 #include "rats.h"
 #include "remove.h"
 #include "rtree.h"
@@ -69,12 +70,12 @@ static void *DestroyRat (RatTypePtr);
 static void *DestroyLine (LayerTypePtr, LineTypePtr);
 static void *DestroyArc (LayerTypePtr, ArcTypePtr);
 static void *DestroyText (LayerTypePtr, TextTypePtr);
-static void *DestroyPolygon (LayerTypePtr, PolygonTypePtr);
+static void *DestroyPour (LayerTypePtr, PourTypePtr);
 static void *DestroyElement (ElementTypePtr);
 static void *RemoveVia (PinTypePtr);
 static void *RemoveRat (RatTypePtr);
-static void *DestroyPolygonPoint (LayerTypePtr, PolygonTypePtr, PointTypePtr);
-static void *RemovePolygonPoint (LayerTypePtr, PolygonTypePtr, PointTypePtr);
+static void *DestroyPourPoint (LayerTypePtr, PourTypePtr, PointTypePtr);
+static void *RemovePourPoint (LayerTypePtr, PourTypePtr, PointTypePtr);
 static void *RemoveLinePoint (LayerTypePtr, LineTypePtr, PointTypePtr);
 
 /* ---------------------------------------------------------------------------
@@ -83,28 +84,30 @@ static void *RemoveLinePoint (LayerTypePtr, LineTypePtr, PointTypePtr);
 static ObjectFunctionType RemoveFunctions = {
   RemoveLine,
   RemoveText,
-  RemovePolygon,
+  NULL,
+  RemovePour,
   RemoveVia,
   RemoveElement,
   NULL,
   NULL,
   NULL,
   RemoveLinePoint,
-  RemovePolygonPoint,
+  RemovePourPoint,
   RemoveArc,
   RemoveRat
 };
 static ObjectFunctionType DestroyFunctions = {
   DestroyLine,
   DestroyText,
-  DestroyPolygon,
+  NULL, //DestroyPolygon,
+  DestroyPour,
   DestroyVia,
   DestroyElement,
   NULL,
   NULL,
   NULL,
   NULL,
-  DestroyPolygonPoint,
+  DestroyPourPoint,
   DestroyArc,
   DestroyRat
 };
@@ -178,21 +181,21 @@ DestroyArc (LayerTypePtr Layer, ArcTypePtr Arc)
 }
 
 /* ---------------------------------------------------------------------------
- * destroys a polygon from a layer
+ * destroys a pour from a layer
  */
 static void *
-DestroyPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
+DestroyPour (LayerTypePtr Layer, PourTypePtr Pour)
 {
-  r_delete_entry (Layer->polygon_tree, (BoxTypePtr) Polygon);
-  FreePolygonMemory (Polygon);
-  if (Polygon != &Layer->Polygon[--Layer->PolygonN])
+  r_delete_entry (Layer->pour_tree, (BoxTypePtr) Pour);
+  FreePourMemory (Pour);
+  if (Pour != &Layer->Pour[--Layer->PourN])
     {
-      *Polygon = Layer->Polygon[Layer->PolygonN];
-      r_substitute (Layer->polygon_tree,
-		    (BoxType *) & Layer->Polygon[Layer->PolygonN],
-		    (BoxType *) Polygon);
+      *Pour = Layer->Pour[Layer->PourN];
+      r_substitute (Layer->pour_tree,
+                    (BoxType *) & Layer->Pour[Layer->PourN],
+                    (BoxType *) Pour);
     }
-  memset (&Layer->Polygon[Layer->PolygonN], 0, sizeof (PolygonType));
+  memset (&Layer->Pour[Layer->PourN], 0, sizeof (PourType));
   return (NULL);
 }
 
@@ -200,24 +203,24 @@ DestroyPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
  * removes a polygon-point from a polygon and destroys the data
  */
 static void *
-DestroyPolygonPoint (LayerTypePtr Layer,
-		     PolygonTypePtr Polygon, PointTypePtr Point)
+DestroyPourPoint (LayerTypePtr Layer,
+                  PourTypePtr Pour, PointTypePtr Point)
 {
   PointTypePtr ptr;
 
-  if (Polygon->PointN <= 3)
-    return RemovePolygon (Layer, Polygon);
-  r_delete_entry (Layer->polygon_tree, (BoxType *) Polygon);
-  for (ptr = Point + 1; ptr != &Polygon->Points[Polygon->PointN]; ptr++)
+  if (Pour->PointN <= 3)
+    return RemovePour (Layer, Pour);
+  r_delete_entry (Layer->pour_tree, (BoxType *) Pour);
+  for (ptr = Point + 1; ptr != &Pour->Points[Pour->PointN]; ptr++)
     {
       *Point = *ptr;
       Point = ptr;
     }
-  Polygon->PointN--;
-  SetPolygonBoundingBox (Polygon);
-  r_insert_entry (Layer->polygon_tree, (BoxType *) Polygon, 0);
-  InitClip (PCB->Data, Layer, Polygon);
-  return (Polygon);
+  Pour->PointN--;
+  SetPourBoundingBox (Pour);
+  r_insert_entry (Layer->pour_tree, (BoxType *) Pour, 0);
+  InitPourClip (PCB->Data, Layer, Pour);
+  return (Pour);
 }
 
 /* ---------------------------------------------------------------------------
@@ -464,62 +467,62 @@ RemoveText (LayerTypePtr Layer, TextTypePtr Text)
 }
 
 /* ---------------------------------------------------------------------------
- * removes a polygon from a layer
+ * removes a pour from a layer
  */
 void *
-RemovePolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
+RemovePour (LayerTypePtr Layer, PourTypePtr Pour)
 {
   /* erase from screen */
   if (Layer->On)
     {
-      ErasePolygon (Polygon);
+      ErasePour (Pour);
       if (!Bulk)
 	Draw ();
     }
-  MoveObjectToRemoveUndoList (POLYGON_TYPE, Layer, Polygon, Polygon);
+  MoveObjectToRemoveUndoList (POUR_TYPE, Layer, Pour, Pour);
   return (NULL);
 }
 
 /* ---------------------------------------------------------------------------
- * removes a polygon-point from a polygon
+ * removes a pour-point from a pour
  */
 static void *
-RemovePolygonPoint (LayerTypePtr Layer,
-		    PolygonTypePtr Polygon, PointTypePtr Point)
+RemovePourPoint (LayerTypePtr Layer,
+                 PourTypePtr Pour, PointTypePtr Point)
 {
   PointTypePtr ptr;
   Cardinal index = 0;
-  if (Polygon->PointN <= 3)
-    return RemovePolygon (Layer, Polygon);
+  if (Pour->PointN <= 3)
+    return RemovePour (Layer, Pour);
   if (Layer->On)
-    ErasePolygon (Polygon);
-  /* insert the polygon-point into the undo list */
-  POLYGONPOINT_LOOP (Polygon);
+    ErasePour (Pour);
+  /* insert the pour-point into the undo list */
+  POURPOINT_LOOP (Pour);
   {
     if (point == Point)
       {
-	index = n;
-	break;
+        index = n;
+        break;
       }
   }
   END_LOOP;
-  AddObjectToRemovePointUndoList (POLYGONPOINT_TYPE, Layer, Polygon, index);
-  r_delete_entry (Layer->polygon_tree, (BoxType *) Polygon);
+  AddObjectToRemovePointUndoList (POURPOINT_TYPE, Layer, Pour, index);
+  r_delete_entry (Layer->pour_tree, (BoxType *) Pour);
   /* remove point from list, keep point order */
-  for (ptr = Point + 1; ptr != &Polygon->Points[Polygon->PointN]; ptr++)
+  for (ptr = Point + 1; ptr != &Pour->Points[Pour->PointN]; ptr++)
     {
       *Point = *ptr;
       Point = ptr;
     }
-  Polygon->PointN--;
-  SetPolygonBoundingBox (Polygon);
-  r_insert_entry (Layer->polygon_tree, (BoxType *) Polygon, 0);
-  RemoveExcessPolygonPoints (Layer, Polygon);
-  InitClip (PCB->Data, Layer, Polygon);
-  /* redraw polygon if necessary */
+  Pour->PointN--;
+  SetPourBoundingBox (Pour);
+  r_insert_entry (Layer->pour_tree, (BoxType *) Pour, 0);
+  RemoveExcessPourPoints (Layer, Pour);
+  InitPourClip (PCB->Data, Layer, Pour);
+  /* redraw pour if necessary */
   if (Layer->On)
     {
-      DrawPolygon (Layer, Polygon, 0);
+      DrawPour (Layer, Pour, 0);
       if (!Bulk)
 	Draw ();
     }
diff --git a/src/remove.h b/src/remove.h
index 8b7c166..7650a65 100644
--- a/src/remove.h
+++ b/src/remove.h
@@ -38,11 +38,11 @@
  */
 #define REMOVE_TYPES            \
 	(VIA_TYPE | LINEPOINT_TYPE | LINE_TYPE | TEXT_TYPE | ELEMENT_TYPE |	\
-	POLYGONPOINT_TYPE | POLYGON_TYPE | RATLINE_TYPE | ARC_TYPE)
+	POURPOINT_TYPE | POUR_TYPE | RATLINE_TYPE | ARC_TYPE)
 
 void *RemoveLine (LayerTypePtr, LineTypePtr);
 void *RemoveArc (LayerTypePtr, ArcTypePtr);
-void *RemovePolygon (LayerTypePtr, PolygonTypePtr);
+void *RemovePour (LayerTypePtr, PourTypePtr);
 void *RemoveText (LayerTypePtr, TextTypePtr);
 void *RemoveElement (ElementTypePtr);
 void ClearRemoveList (void);
diff --git a/src/report.c b/src/report.c
index 2e80e66..23b13c2 100644
--- a/src/report.c
+++ b/src/report.c
@@ -330,11 +330,42 @@ ReportDialog (int argc, char **argv, int x, int y)
 		 flags_to_string (Polygon->Flags, POLYGON_TYPE),
 		 Polygon->BoundingBox.X1, Polygon->BoundingBox.Y1,
 		 Polygon->BoundingBox.X2, Polygon->BoundingBox.Y2,
+     0, 0,
+#warning FIXME Later
+#if 0
 		 Polygon->PointN, Polygon->PointMax - Polygon->PointN,
+#endif
 		 GetLayerNumber (PCB->Data, (LayerTypePtr) ptr1),
 		 TEST_FLAG (LOCKFLAG, Polygon) ? "It is LOCKED\n" : "");
 	break;
       }
+    case POUR_TYPE:
+      {
+	PourTypePtr Pour;
+#ifndef NDEBUG
+	if (gui->shift_is_pressed ())
+	  {
+	    LayerTypePtr layer = (LayerTypePtr) ptr1;
+	    __r_dump_tree (layer->pour_tree->root, 0);
+	    return;
+	  }
+#endif
+	Pour = (PourTypePtr) ptr2;
+
+	sprintf (&report[0], "POUR ID# %ld   Flags:%s\n"
+		 "Its bounding box is (%d,%d) (%d,%d)\n"
+		 "It has %d points and could store %d more\n"
+		 "without using more memory.\n"
+		 "It resides on layer %d\n"
+		 "%s", Pour->ID,
+		 flags_to_string (Pour->Flags, POUR_TYPE),
+		 Pour->BoundingBox.X1, Pour->BoundingBox.Y1,
+		 Pour->BoundingBox.X2, Pour->BoundingBox.Y2,
+		 Pour->PointN, Pour->PointMax - Pour->PointN,
+		 GetLayerNumber (PCB->Data, (LayerTypePtr) ptr1),
+		 TEST_FLAG (LOCKFLAG, Pour) ? "It is LOCKED\n" : "");
+	break;
+      }
     case PAD_TYPE:
       {
 	int len, dx, dy, mgap;
@@ -465,14 +496,14 @@ ReportDialog (int argc, char **argv, int x, int y)
 	break;
       }
     case LINEPOINT_TYPE:
-    case POLYGONPOINT_TYPE:
+    case POURPOINT_TYPE:
       {
 	PointTypePtr point = (PointTypePtr) ptr2;
 	sprintf (&report[0], "POINT ID# %ld. Points don't have flags.\n"
 		 "Located at (X,Y) = (%d,%d)\n"
 		 "It belongs to a %s on layer %d\n", point->ID,
 		 point->X, point->Y,
-		 (type == LINEPOINT_TYPE) ? "line" : "polygon",
+		 (type == LINEPOINT_TYPE) ? "line" : "pour",
 		 GetLayerNumber (PCB->Data, (LayerTypePtr) ptr1));
 	break;
       }
diff --git a/src/report.h b/src/report.h
index 7abbb79..39ce0ca 100644
--- a/src/report.h
+++ b/src/report.h
@@ -31,8 +31,8 @@
 #include "global.h"
 
 #define REPORT_TYPES \
-	(VIA_TYPE | LINE_TYPE | TEXT_TYPE | POLYGON_TYPE | ELEMENT_TYPE | \
+	(VIA_TYPE | LINE_TYPE | TEXT_TYPE | POUR_TYPE | ELEMENT_TYPE | \
 	 RATLINE_TYPE | PIN_TYPE | PAD_TYPE | ELEMENTNAME_TYPE | ARC_TYPE \
-	 | POLYGONPOINT_TYPE | LINEPOINT_TYPE)
+	 | POURPOINT_TYPE | LINEPOINT_TYPE)
 
 #endif
diff --git a/src/rotate.c b/src/rotate.c
index 247a1a9..43efbe5 100644
--- a/src/rotate.c
+++ b/src/rotate.c
@@ -44,6 +44,7 @@
 #include "error.h"
 #include "misc.h"
 #include "polygon.h"
+#include "pour.h"
 #include "rotate.h"
 #include "rtree.h"
 #include "rubberband.h"
@@ -81,6 +82,7 @@ static ObjectFunctionType RotateFunctions = {
   RotateText,
   NULL,
   NULL,
+  NULL,
   RotateElement,
   RotateElementName,
   NULL,
@@ -158,18 +160,18 @@ RotateTextLowLevel (TextTypePtr Text, LocationType X, LocationType Y,
 }
 
 /* ---------------------------------------------------------------------------
- * rotates a polygon in 90 degree steps
+ * rotates a pour in 90 degree steps
  */
 void
-RotatePolygonLowLevel (PolygonTypePtr Polygon,
+RotatePourLowLevel (PourTypePtr Pour,
 		       LocationType X, LocationType Y, BYTE Number)
 {
-  POLYGONPOINT_LOOP (Polygon);
+  POURPOINT_LOOP (Pour);
   {
     ROTATE (point->X, point->Y, X, Y, Number);
   }
   END_LOOP;
-  RotateBoxLowLevel (&Polygon->BoundingBox, X, Y, Number);
+  RotateBoxLowLevel (&Pour->BoundingBox, X, Y, Number);
 }
 
 /* ---------------------------------------------------------------------------
@@ -179,11 +181,11 @@ static void *
 RotateText (LayerTypePtr Layer, TextTypePtr Text)
 {
   EraseText (Layer, Text);
-  RestoreToPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+  RestoreToPours (PCB->Data, TEXT_TYPE, Layer, Text);
   r_delete_entry (Layer->text_tree, (BoxTypePtr) Text);
   RotateTextLowLevel (Text, CenterX, CenterY, Number);
   r_insert_entry (Layer->text_tree, (BoxTypePtr) Text, 0);
-  ClearFromPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
+  ClearFromPours (PCB->Data, TEXT_TYPE, Layer, Text);
   DrawText (Layer, Text, 0);
   Draw ();
   return (Text);
@@ -241,7 +243,7 @@ RotateElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
     /* pre-delete the pins from the pin-tree before their coordinates change */
     if (Data)
       r_delete_entry (Data->pin_tree, (BoxType *) pin);
-    RestoreToPolygon (Data, PIN_TYPE, Element, pin);
+    RestoreToPours (Data, PIN_TYPE, Element, pin);
     ROTATE_PIN_LOWLEVEL (pin, X, Y, Number);
   }
   END_LOOP;
@@ -250,7 +252,7 @@ RotateElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
     /* pre-delete the pads before their coordinates change */
     if (Data)
       r_delete_entry (Data->pad_tree, (BoxType *) pad);
-    RestoreToPolygon (Data, PAD_TYPE, Element, pad);
+    RestoreToPours (Data, PAD_TYPE, Element, pad);
     ROTATE_PAD_LOWLEVEL (pad, X, Y, Number);
   }
   END_LOOP;
@@ -262,7 +264,7 @@ RotateElementLowLevel (DataTypePtr Data, ElementTypePtr Element,
   ROTATE (Element->MarkX, Element->MarkY, X, Y, Number);
   /* SetElementBoundingBox reenters the rtree data */
   SetElementBoundingBox (Data, Element, &PCB->Font);
-  ClearFromPolygon (Data, ELEMENT_TYPE, Element, Element);
+  ClearFromPours (Data, ELEMENT_TYPE, Element, Element);
 }
 
 /* ---------------------------------------------------------------------------
@@ -274,7 +276,7 @@ RotateLinePoint (LayerTypePtr Layer, LineTypePtr Line, PointTypePtr Point)
   EraseLine (Line);
   if (Layer)
     {
-      RestoreToPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+      RestoreToPours (PCB->Data, LINE_TYPE, Layer, Line);
       r_delete_entry (Layer->line_tree, (BoxTypePtr) Line);
     }
   else
@@ -284,7 +286,7 @@ RotateLinePoint (LayerTypePtr Layer, LineTypePtr Line, PointTypePtr Point)
   if (Layer)
     {
       r_insert_entry (Layer->line_tree, (BoxTypePtr) Line, 0);
-      ClearFromPolygon (PCB->Data, LINE_TYPE, Layer, Line);
+      ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
       DrawLine (Layer, Line, 0);
     }
   else
@@ -388,7 +390,7 @@ RotateObject (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
       EraseLine (ptr->Line);
       if (ptr->Layer)
 	{
-	  RestoreToPolygon (PCB->Data, LINE_TYPE, ptr->Layer, ptr->Line);
+	  RestoreToPours (PCB->Data, LINE_TYPE, ptr->Layer, ptr->Line);
 	  r_delete_entry (ptr->Layer->line_tree, (BoxType *) ptr->Line);
 	}
       else
@@ -398,7 +400,7 @@ RotateObject (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
       if (ptr->Layer)
 	{
 	  r_insert_entry (ptr->Layer->line_tree, (BoxType *) ptr->Line, 0);
-	  ClearFromPolygon (PCB->Data, LINE_TYPE, ptr->Layer, ptr->Line);
+	  ClearFromPours (PCB->Data, LINE_TYPE, ptr->Layer, ptr->Line);
 	  DrawLine (ptr->Layer, ptr->Line, 0);
 	}
       else
diff --git a/src/rotate.h b/src/rotate.h
index f032fcb..8ad4f60 100644
--- a/src/rotate.h
+++ b/src/rotate.h
@@ -64,7 +64,7 @@ void RotateLineLowLevel (LineTypePtr, LocationType, LocationType, BYTE);
 void RotateArcLowLevel (ArcTypePtr, LocationType, LocationType, BYTE);
 void RotateBoxLowLevel (BoxTypePtr, LocationType, LocationType, BYTE);
 void RotateTextLowLevel (TextTypePtr, LocationType, LocationType, BYTE);
-void RotatePolygonLowLevel (PolygonTypePtr, LocationType, LocationType, BYTE);
+void RotatePourLowLevel (PourTypePtr, LocationType, LocationType, BYTE);
 void RotateElementLowLevel (DataTypePtr, ElementTypePtr, LocationType,
 			    LocationType, BYTE);
 void *RotateObject (int, void *, void *, void *, LocationType, LocationType,
diff --git a/src/search.c b/src/search.c
index d6a3c38..aa65fd2 100644
--- a/src/search.c
+++ b/src/search.c
@@ -80,6 +80,8 @@ static Boolean SearchTextByLocation (int, LayerTypePtr *, TextTypePtr *,
 				     TextTypePtr *);
 static Boolean SearchPolygonByLocation (int, LayerTypePtr *, PolygonTypePtr *,
 					PolygonTypePtr *);
+static Boolean SearchPourByLocation (int, LayerTypePtr *, PourTypePtr *,
+					PourTypePtr *);
 static Boolean SearchPinByLocation (int, ElementTypePtr *, PinTypePtr *,
 				    PinTypePtr *);
 static Boolean SearchPadByLocation (int, ElementTypePtr *, PadTypePtr *,
@@ -91,7 +93,7 @@ static Boolean SearchElementNameByLocation (int, ElementTypePtr *,
 					    Boolean);
 static Boolean SearchLinePointByLocation (int, LayerTypePtr *, LineTypePtr *,
 					  PointTypePtr *);
-static Boolean SearchPointByLocation (int, LayerTypePtr *, PolygonTypePtr *,
+static Boolean SearchPourPointByLocation (int, LayerTypePtr *, PourTypePtr *,
 				      PointTypePtr *);
 static Boolean SearchElementByLocation (int, ElementTypePtr *,
 					ElementTypePtr *, ElementTypePtr *,
@@ -105,6 +107,7 @@ struct ans_info
   void **ptr1, **ptr2, **ptr3;
   Boolean BackToo;
   float area;
+  BoxType *search_box;
   jmp_buf env;
   int locked;			/* This will be zero or LOCKFLAG */
 };
@@ -419,6 +422,14 @@ polygon_callback (const BoxType * box, void *cl)
   return 0;
 }
 
+static int
+pour_polygon_callback (const BoxType * box, void *cl)
+{
+  PourTypePtr pour = (PourTypePtr) box;
+  struct ans_info *i = (struct ans_info *) cl;
+
+  return r_search (pour->polygon_tree, &SearchBox, NULL, polygon_callback, i);
+}
 
 /* ---------------------------------------------------------------------------
  * searches a polygon on the SearchLayer 
@@ -436,13 +447,59 @@ SearchPolygonByLocation (int locked, LayerTypePtr * Layer,
 
   if (setjmp (info.env) == 0)
     {
-      r_search (SearchLayer->polygon_tree, &SearchBox, NULL, polygon_callback,
+      r_search (SearchLayer->pour_tree, &SearchBox, NULL, pour_polygon_callback,
 		&info);
       return False;
     }
   return (True);
 }
 
+#warning FIXME Later: For now, can only select a pour if you're hitting its child polygons
+#if 0
+static int
+pour_callback (const BoxType * box, void *cl)
+{
+  PourTypePtr pour = (PourTypePtr) box;
+  struct ans_info *i = (struct ans_info *) cl;
+
+  if (TEST_FLAG (i->locked, pour))
+    return 0;
+
+  if (IsPointInPour (PosX, PosY, SearchRadius, pour))
+    {
+      *i->ptr2 = *i->ptr3 = pour;
+      longjmp (i->env, 1);
+    }
+  return 0;
+}
+#endif
+
+/* ---------------------------------------------------------------------------
+ * searches a pour on the SearchLayer 
+ */
+static Boolean
+SearchPourByLocation (int locked, LayerTypePtr * Layer,
+                      PourTypePtr * Pour, PourTypePtr * Dummy)
+{
+  struct ans_info info;
+
+  *Layer = SearchLayer;
+  info.ptr2 = (void **) Pour;
+  info.ptr3 = (void **) Dummy;
+  info.locked = (locked & LOCKED_TYPE) ? 0 : LOCKFLAG;
+
+#warning FIXME Later: For now, can only select a pour if you're hitting its child polygons
+  if (setjmp (info.env) == 0)
+    {
+      r_search (SearchLayer->pour_tree, &SearchBox, NULL, pour_polygon_callback, &info);
+      return False;
+    }
+
+  /* Make sure we return the pour, not the polygon */
+  *info.ptr2 = *info.ptr3 = ((PolygonTypePtr)*info.ptr2)->ParentPour;
+  return (True);
+}
+
 static int
 linepoint_callback (const BoxType * b, void *cl)
 {
@@ -498,27 +555,27 @@ SearchLinePointByLocation (int locked, LayerTypePtr * Layer,
 }
 
 /* ---------------------------------------------------------------------------
- * searches a polygon-point on all layers that are switched on
+ * searches a pour-point on all layers that are switched on
  * in layerstack order
  */
 static Boolean
-SearchPointByLocation (int locked, LayerTypePtr * Layer,
-		       PolygonTypePtr * Polygon, PointTypePtr * Point)
+SearchPourPointByLocation (int locked, LayerTypePtr * Layer,
+		       PourTypePtr * Pour, PointTypePtr * Point)
 {
   float d, least;
   Boolean found = False;
 
-  least = SQUARE (SearchRadius + MAX_POLYGON_POINT_DISTANCE);
+  least = SQUARE (SearchRadius + MAX_POUR_POINT_DISTANCE);
   *Layer = SearchLayer;
-  POLYGON_LOOP (*Layer);
+  POUR_LOOP (*Layer);
   {
-    POLYGONPOINT_LOOP (polygon);
+    POURPOINT_LOOP (pour);
     {
       d = SQUARE (point->X - PosX) + SQUARE (point->Y - PosY);
       if (d < least)
 	{
 	  least = d;
-	  *Polygon = polygon;
+	  *Pour = pour;
 	  *Point = point;
 	  found = True;
 	}
@@ -1176,7 +1233,7 @@ SearchObjectByLocation (int Type,
     }
   if (TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG (THINDRAWPOLYFLAG, PCB))
     {
-      Type &= ~POLYGON_TYPE;
+      Type &= ~(POLYGON_TYPE | POUR_TYPE);
     }
 
   if (Type & RATLINE_TYPE && PCB->RatOn &&
@@ -1241,12 +1298,12 @@ SearchObjectByLocation (int Type,
       if (SearchLayer->On)
 	{
 	  if ((HigherAvail & (PIN_TYPE | PAD_TYPE)) == 0 &&
-	      Type & POLYGONPOINT_TYPE &&
-	      SearchPointByLocation (locked,
-				     (LayerTypePtr *) Result1,
-				     (PolygonTypePtr *) Result2,
-				     (PointTypePtr *) Result3))
-	    return (POLYGONPOINT_TYPE);
+	      Type & POURPOINT_TYPE &&
+	      SearchPourPointByLocation (locked,
+					 (LayerTypePtr *) Result1,
+					 (PourTypePtr *) Result2,
+					 (PointTypePtr *) Result3))
+	    return (POURPOINT_TYPE);
 
 	  if ((HigherAvail & (PIN_TYPE | PAD_TYPE)) == 0 &&
 	      Type & LINEPOINT_TYPE &&
@@ -1297,6 +1354,27 @@ SearchObjectByLocation (int Type,
 	      else
 		return (POLYGON_TYPE);
 	    }
+
+	  if (Type & POUR_TYPE &&
+	      SearchPourByLocation (locked,
+				    (LayerTypePtr *) Result1,
+				    (PourTypePtr *) Result2,
+				    (PourTypePtr *) Result3))
+	    {
+	      if (HigherAvail)
+		{
+		  BoxTypePtr box =
+		    &(*(PourTypePtr *) Result2)->BoundingBox;
+		  float area =
+		    (float) (box->X2 - box->X1) * (float) (box->X2 - box->X1);
+		  if (HigherBound < area)
+		    break;
+		  else
+		    return (POUR_TYPE);
+		}
+	      else
+		return (POUR_TYPE);
+	    }
 	}
     }
   /* return any previously found objects */
@@ -1428,31 +1506,47 @@ SearchObjectByID (DataTypePtr Base,
       ENDALL_LOOP;
     }
 
-  if (type == POLYGON_TYPE || type == POLYGONPOINT_TYPE)
+  if (type == POUR_TYPE || type == POURPOINT_TYPE || type == POLYGON_TYPE)
     {
-      ALLPOLYGON_LOOP (Base);
+      ALLPOUR_LOOP (Base);
       {
-	if (polygon->ID == ID)
+	if (pour->ID == ID)
 	  {
 	    *Result1 = (void *) layer;
-	    *Result2 = *Result3 = (void *) polygon;
-	    return (POLYGON_TYPE);
+	    *Result2 = *Result3 = (void *) pour;
+	    return (POUR_TYPE);
 	  }
-	if (type == POLYGONPOINT_TYPE)
-	  POLYGONPOINT_LOOP (polygon);
-	{
-	  if (point->ID == ID)
-	    {
-	      *Result1 = (void *) layer;
-	      *Result2 = (void *) polygon;
-	      *Result3 = (void *) point;
-	      return (POLYGONPOINT_TYPE);
-	    }
-	}
-	END_LOOP;
+	if (type == POURPOINT_TYPE)
+          {
+            POURPOINT_LOOP (pour);
+            {
+              if (point->ID == ID)
+                {
+                  *Result1 = (void *) layer;
+                  *Result2 = (void *) pour;
+                  *Result3 = (void *) point;
+                  return (POURPOINT_TYPE);
+                }
+            }
+            END_LOOP;
+          }
+        else if (type == POLYGON_TYPE)
+          {
+            POURPOLYGON_LOOP (pour);
+            {
+              if (polygon->ID == ID)
+                {
+                  *Result1 = (void *) layer;
+                  *Result2 = *Result3 = (void *) polygon;
+                  return (POLYGON_TYPE);
+                }
+            }
+            END_LOOP;
+          }
       }
       ENDALL_LOOP;
     }
+
   if (type == VIA_TYPE)
     {
       VIA_LOOP (Base);
diff --git a/src/search.h b/src/search.h
index 43f48d7..f5c6d42 100644
--- a/src/search.h
+++ b/src/search.h
@@ -59,8 +59,13 @@
 #define	TEXT_IN_BOX(t,b)	\
 	(BOX_IN_BOX(&((t)->BoundingBox), (b)))
 
+#if 0 // NOT USED
 #define	POLYGON_IN_BOX(p,b)	\
 	(BOX_IN_BOX(&((p)->BoundingBox), (b)))
+#endif
+
+#define	POUR_IN_BOX(p,b)	\
+	(BOX_IN_BOX(&((p)->BoundingBox), (b)))
 
 #define	ELEMENT_IN_BOX(e,b)	\
 	(BOX_IN_BOX(&((e)->BoundingBox), (b)))
diff --git a/src/select.c b/src/select.c
index 7b96fec..9d17e27 100644
--- a/src/select.c
+++ b/src/select.c
@@ -182,6 +182,7 @@ SelectObject (void)
 	break;
       }
 
+#if 0
     case POLYGON_TYPE:
       {
 	PolygonType *poly = (PolygonTypePtr) ptr2;
@@ -193,6 +194,19 @@ SelectObject (void)
 	/* changing memory order no longer effects draw order */
 	break;
       }
+#endif
+
+    case POUR_TYPE:
+      {
+	PourType *pour = (PolygonTypePtr) ptr2;
+
+	layer = (LayerTypePtr) ptr1;
+	AddObjectToFlagUndoList (POUR_TYPE, ptr1, ptr2, ptr2);
+	TOGGLE_FLAG (SELECTEDFLAG, pour);
+	DrawPour (layer, pour, 0);
+	/* changing memory order no longer effects draw order */
+	break;
+      }
 
     case PIN_TYPE:
       AddObjectToFlagUndoList (PIN_TYPE, ptr1, ptr2, ptr2);
@@ -340,8 +354,20 @@ SelectBlock (BoxTypePtr Box, Boolean Flag)
 	}
     }
     END_LOOP;
-    POLYGON_LOOP (layer);
+    POUR_LOOP (layer);
     {
+#warning FIXME Later: Do we want to be able to select the polygon pieces?
+      if (POUR_IN_BOX (pour, Box)
+	  && !TEST_FLAG (LOCKFLAG, pour)
+	  && TEST_FLAG (SELECTEDFLAG, pour) != Flag)
+	{
+	  AddObjectToFlagUndoList (POUR_TYPE, layer, pour, pour);
+	  ASSIGN_FLAG (SELECTEDFLAG, Flag, pour);
+	  if (layer->On)
+	    DrawPour (layer, pour, 0);
+	  changed = True;
+	}
+#if 0
       if (POLYGON_IN_BOX (polygon, Box)
 	  && !TEST_FLAG (LOCKFLAG, polygon)
 	  && TEST_FLAG (SELECTEDFLAG, polygon) != Flag)
@@ -352,6 +378,7 @@ SelectBlock (BoxTypePtr Box, Boolean Flag)
 	    DrawPolygon (layer, polygon, 0);
 	  changed = True;
 	}
+#endif
     }
     END_LOOP;
   }
@@ -512,9 +539,14 @@ ObjectOperation (ObjectFunctionTypePtr F,
 	return (F->Polygon ((LayerTypePtr) Ptr1, (PolygonTypePtr) Ptr2));
       break;
 
-    case POLYGONPOINT_TYPE:
-      if (F->Point)
-	return (F->Point ((LayerTypePtr) Ptr1, (PolygonTypePtr) Ptr2,
+    case POUR_TYPE:
+      if (F->Pour)
+	return (F->Pour ((LayerTypePtr) Ptr1, (PourTypePtr) Ptr2));
+      break;
+
+    case POURPOINT_TYPE:
+      if (F->PourPoint)
+	return (F->PourPoint ((LayerTypePtr) Ptr1, (PourTypePtr) Ptr2,
 			  (PointTypePtr) Ptr3));
       break;
 
@@ -613,21 +645,44 @@ SelectedOperation (ObjectFunctionTypePtr F, Boolean Reset, int type)
   }
   ENDALL_LOOP;
 
+#if 0
   /* check polygons */
   if (type & POLYGON_TYPE && F->Polygon)
-    VISIBLEPOLYGON_LOOP (PCB->Data);
-  {
-    if (TEST_FLAG (SELECTEDFLAG, polygon))
+    VISIBLEPOUR_LOOP (PCB->Data);
+    {
+      POURPOLYGON_LOOP (pour);
       {
-	if (Reset)
-	  {
-	    AddObjectToFlagUndoList (POLYGON_TYPE, layer, polygon, polygon);
-	    CLEAR_FLAG (SELECTEDFLAG, polygon);
-	  }
-	F->Polygon (layer, polygon);
-	changed = True;
+        if (TEST_FLAG (SELECTEDFLAG, polygon))
+          {
+            if (Reset)
+              {
+                AddObjectToFlagUndoList (POLYGON_TYPE, layer, polygon, polygon);
+                CLEAR_FLAG (SELECTEDFLAG, polygon);
+              }
+            F->Polygon (layer, polygon);
+            changed = True;
+          }
       }
-  }
+      END_LOOP;
+    }
+  ENDALL_LOOP;
+#endif
+
+  /* check pours */
+  if (type & POUR_TYPE && F->Pour)
+    VISIBLEPOUR_LOOP (PCB->Data);
+    {
+      if (TEST_FLAG (SELECTEDFLAG, pour))
+        {
+          if (Reset)
+            {
+              AddObjectToFlagUndoList (POUR_TYPE, layer, pour, pour);
+              CLEAR_FLAG (SELECTEDFLAG, pour);
+            }
+          F->Pour (layer, pour);
+          changed = True;
+        }
+    }
   ENDALL_LOOP;
 
   /* elements silkscreen */
@@ -789,17 +844,23 @@ SelectConnection (Boolean Flag)
       }
   }
   ENDALL_LOOP;
-  VISIBLEPOLYGON_LOOP (PCB->Data);
+#if 0
+  VISIBLEPOUR_LOOP (PCB->Data);
   {
-    if (TEST_FLAG (FOUNDFLAG, polygon) && !TEST_FLAG (LOCKFLAG, polygon))
-      {
-	AddObjectToFlagUndoList (POLYGON_TYPE, layer, polygon, polygon);
-	ASSIGN_FLAG (SELECTEDFLAG, Flag, polygon);
-	DrawPolygon (layer, polygon, 0);
-	changed = True;
-      }
+    POURPOLYGON_LOOP (pour);
+    {
+      if (TEST_FLAG (FOUNDFLAG, polygon) && !TEST_FLAG (LOCKFLAG, polygon))
+        {
+          AddObjectToFlagUndoList (POLYGON_TYPE, layer, polygon, polygon);
+          ASSIGN_FLAG (SELECTEDFLAG, Flag, polygon);
+          DrawPolygon (layer, polygon, 0);
+          changed = True;
+        }
+    }
+    END_LOOP;
   }
   ENDALL_LOOP;
+#endif
 
   if (PCB->PinOn && PCB->ElementOn)
     {
diff --git a/src/select.h b/src/select.h
index 7a48dae..479cc0c 100644
--- a/src/select.h
+++ b/src/select.h
@@ -34,7 +34,7 @@
 #include "global.h"
 
 #define SELECT_TYPES	\
-	(VIA_TYPE | LINE_TYPE | TEXT_TYPE | POLYGON_TYPE | ELEMENT_TYPE |	\
+	(VIA_TYPE | LINE_TYPE | TEXT_TYPE | POUR_TYPE | ELEMENT_TYPE |	\
 	 PIN_TYPE | PAD_TYPE | ELEMENTNAME_TYPE | RATLINE_TYPE | ARC_TYPE)
 
 void SelectPin (LibraryEntryTypePtr entry, Boolean toggle);
diff --git a/src/set.c b/src/set.c
index 912db04..e9ced1d 100644
--- a/src/set.c
+++ b/src/set.c
@@ -248,11 +248,11 @@ SetMode (int Mode)
   addedLines = 0;
   Crosshair.AttachedObject.Type = NO_TYPE;
   Crosshair.AttachedObject.State = STATE_FIRST;
-  Crosshair.AttachedPolygon.PointN = 0;
+  Crosshair.AttachedPour.PointN = 0;
   if (PCB->RatDraw)
     {
       if (Mode == ARC_MODE || Mode == RECTANGLE_MODE ||
-	  Mode == VIA_MODE || Mode == POLYGON_MODE ||
+	  Mode == VIA_MODE || Mode == POUR_MODE ||
 	  Mode == TEXT_MODE || Mode == INSERTPOINT_MODE ||
 	  Mode == THERMAL_MODE)
 	{
diff --git a/src/strflags.c b/src/strflags.c
index ac1fdcc..26a2405 100644
--- a/src/strflags.c
+++ b/src/strflags.c
@@ -95,7 +95,7 @@ static FlagBitsType object_flagbits[] = {
   { HOLEFLAG, N ("hole"), PIN_TYPES },
   { RATFLAG, N ("rat"), RATLINE_TYPE },
   { PININPOLYFLAG, N ("pininpoly"), PIN_TYPES | PAD_TYPE },
-  { CLEARPOLYFLAG, N ("clearpoly"), POLYGON_TYPE },
+  { CLEARPOLYFLAG, N ("clearpoly"), POUR_TYPE },
   { HIDENAMEFLAG, N ("hidename"), ELEMENT_TYPE },
   { DISPLAYNAMEFLAG, N ("showname"), ELEMENT_TYPE },
   { CLEARLINEFLAG, N ("clearline"), LINE_TYPE | ARC_TYPE | TEXT_TYPE },
@@ -110,7 +110,7 @@ static FlagBitsType object_flagbits[] = {
   { DRCFLAG, N ("drc"), ALL_TYPES },
   { LOCKFLAG, N ("lock"), ALL_TYPES },
   { EDGE2FLAG, N ("edge2"), ALL_TYPES },
-  { FULLPOLYFLAG, N ("fullpoly"), POLYGON_TYPE},
+  { FULLPOLYFLAG, N ("fullpoly"), POUR_TYPE},
   { NOPASTEFLAG, N ("nopaste"), PAD_TYPE }
 };
 
diff --git a/src/undo.c b/src/undo.c
index cb8d180..5ddadd9 100644
--- a/src/undo.c
+++ b/src/undo.c
@@ -62,6 +62,7 @@
 #include "move.h"
 #include "mymem.h"
 #include "polygon.h"
+#include "pour.h"
 #include "remove.h"
 #include "rotate.h"
 #include "rtree.h"
@@ -126,7 +127,7 @@ typedef struct			/* information about poly clear/restore */
   Boolean Clear;		/* true was clear, false was restore */
   LayerTypePtr Layer;
 }
-ClearPolyType, *ClearPolyTypePtr;
+ClearPourType, *ClearPourTypePtr;
 
 typedef struct			/* information about netlist lib changes */
 {
@@ -151,7 +152,7 @@ typedef struct			/* holds information about an operation */
     FlagType Flags;
     BDimension Size;
     LayerChangeType LayerChange;
-    ClearPolyType ClearPoly;
+    ClearPourType ClearPour;
     NetlistChangeType NetlistChange;
   }
   Data;
@@ -192,7 +193,7 @@ static Boolean UndoChange2ndSize (UndoListTypePtr);
 static Boolean UndoChangeAngles (UndoListTypePtr);
 static Boolean UndoChangeClearSize (UndoListTypePtr);
 static Boolean UndoChangeMaskSize (UndoListTypePtr);
-static Boolean UndoClearPoly (UndoListTypePtr);
+static Boolean UndoClearPour (UndoListTypePtr);
 static int PerformUndo (UndoListTypePtr);
 
 /* ---------------------------------------------------------------------------
@@ -310,7 +311,7 @@ UndoRotate (UndoListTypePtr Entry)
  * returns True if anything has been recovered
  */
 static Boolean
-UndoClearPoly (UndoListTypePtr Entry)
+UndoClearPour (UndoListTypePtr Entry)
 {
   void *ptr1, *ptr2, *ptr3;
   int type;
@@ -319,11 +320,11 @@ UndoClearPoly (UndoListTypePtr Entry)
     SearchObjectByID (PCB->Data, &ptr1, &ptr2, &ptr3, Entry->ID, Entry->Kind);
   if (type != NO_TYPE)
     {
-      if (Entry->Data.ClearPoly.Clear)
-	RestoreToPolygon (PCB->Data, type, Entry->Data.ClearPoly.Layer, ptr3);
+      if (Entry->Data.ClearPour.Clear)
+	RestoreToPours (PCB->Data, type, Entry->Data.ClearPour.Layer, ptr3);
       else
-	ClearFromPolygon (PCB->Data, type, Entry->Data.ClearPoly.Layer, ptr3);
-      Entry->Data.ClearPoly.Clear = !Entry->Data.ClearPoly.Clear;
+	ClearFromPours (PCB->Data, type, Entry->Data.ClearPour.Layer, ptr3);
+      Entry->Data.ClearPour.Clear = !Entry->Data.ClearPour.Clear;
       return True;
     }
   return False;
@@ -436,11 +437,11 @@ UndoChangeClearSize (UndoListTypePtr Entry)
       if (TEST_FLAG (LOCKFLAG, (LineTypePtr) ptr2))
 	return (False);
       swap = ((PinTypePtr) ptr2)->Clearance;
-      RestoreToPolygon (PCB->Data, type, ptr1, ptr2);
+      RestoreToPours (PCB->Data, type, ptr1, ptr2);
       if (andDraw)
 	EraseObject (type, ptr1, ptr2);
       ((PinTypePtr) ptr2)->Clearance = Entry->Data.Size;
-      ClearFromPolygon (PCB->Data, type, ptr1, ptr2);
+      ClearFromPours (PCB->Data, type, ptr1, ptr2);
       Entry->Data.Size = swap;
       if (andDraw)
 	DrawObject (type, ptr1, ptr2, 0);
@@ -504,12 +505,12 @@ UndoChangeSize (UndoListTypePtr Entry)
       /* Wow! can any object be treated as a pin type for size change?? */
       /* pins, vias, lines, and arcs can. Text can't but it has it's own mechanism */
       swap = ((PinTypePtr) ptr2)->Thickness;
-      RestoreToPolygon (PCB->Data, type, ptr1, ptr2);
+      RestoreToPours (PCB->Data, type, ptr1, ptr2);
       if (andDraw)
 	EraseObject (type, ptr1, ptr2);
       ((PinTypePtr) ptr2)->Thickness = Entry->Data.Size;
       Entry->Data.Size = swap;
-      ClearFromPolygon (PCB->Data, type, ptr1, ptr2);
+      ClearFromPours (PCB->Data, type, ptr1, ptr2);
       if (andDraw)
 	DrawObject (type, ptr1, ptr2, 0);
       return (True);
@@ -710,35 +711,35 @@ static Boolean
 UndoRemovePoint (UndoListTypePtr Entry)
 {
   LayerTypePtr layer;
-  PolygonTypePtr polygon;
+  PourTypePtr pour;
   void *ptr3;
   int type;
 
   /* lookup entry (polygon not point was saved) by it's ID */
-  assert (Entry->Kind == POLYGON_TYPE);
+  assert (Entry->Kind == POUR_TYPE);
   type =
-    SearchObjectByID (PCB->Data, (void *) &layer, (void *) &polygon, &ptr3,
+    SearchObjectByID (PCB->Data, (void *) &layer, (void *) &pour, &ptr3,
 		      Entry->ID, Entry->Kind);
   switch (type)
     {
-    case POLYGON_TYPE:		/* restore the removed point */
+    case POUR_TYPE:		/* restore the removed point */
       {
-	if (TEST_FLAG (LOCKFLAG, polygon))
+	if (TEST_FLAG (LOCKFLAG, pour))
 	  return (False);
 	/* recover the point */
 	if (andDraw && layer->On)
-	  ErasePolygon (polygon);
-	InsertPointIntoObject (POLYGON_TYPE, layer, polygon,
+	  ErasePour (pour);
+	InsertPointIntoObject (POUR_TYPE, layer, pour,
 			       &Entry->Data.RemovedPoint.Index,
 			       Entry->Data.RemovedPoint.X,
 			       Entry->Data.RemovedPoint.Y, True);
-	polygon->Points[Entry->Data.RemovedPoint.Index].ID =
+	pour->Points[Entry->Data.RemovedPoint.Index].ID =
 	  Entry->Data.RemovedPoint.ID;
 	if (andDraw && layer->On)
-	  DrawPolygon (layer, polygon, 0);
+	  DrawPour (layer, pour, 0);
 	Entry->Type = UNDO_INSERT_POINT;
 	Entry->ID = Entry->Data.RemovedPoint.ID;
-	Entry->Kind = POLYGONPOINT_TYPE;
+	Entry->Kind = POURPOINT_TYPE;
 	return (True);
       }
 
@@ -748,37 +749,37 @@ UndoRemovePoint (UndoListTypePtr Entry)
 }
 
 /* ---------------------------------------------------------------------------
- * recovers an inserted polygon point
+ * recovers an inserted pour point
  * returns true on success
  */
 static Boolean
 UndoInsertPoint (UndoListTypePtr Entry)
 {
   LayerTypePtr layer;
-  PolygonTypePtr polygon;
+  PourTypePtr pour;
   PointTypePtr pnt;
   int type;
 
-  assert (Entry->Kind == POLYGONPOINT_TYPE);
+  assert (Entry->Kind == POURPOINT_TYPE);
   /* lookup entry by it's ID */
   type =
-    SearchObjectByID (PCB->Data, (void *) &layer, (void *) &polygon,
+    SearchObjectByID (PCB->Data, (void *) &layer, (void *) &pour,
 		      (void *) &pnt, Entry->ID, Entry->Kind);
   switch (type)
     {
-    case POLYGONPOINT_TYPE:	/* removes an inserted polygon point */
+    case POURPOINT_TYPE:	/* removes an inserted pour point */
       {
-	if (TEST_FLAG (LOCKFLAG, polygon))
+	if (TEST_FLAG (LOCKFLAG, pour))
 	  return (False);
 	if (andDraw && layer->On)
-	  ErasePolygon (polygon);
+	  ErasePour (pour);
 	Entry->Data.RemovedPoint.X = pnt->X;
 	Entry->Data.RemovedPoint.Y = pnt->Y;
 	Entry->Data.RemovedPoint.ID = pnt->ID;
-	Entry->ID = polygon->ID;
-	Entry->Kind = POLYGON_TYPE;
+	Entry->ID = pour->ID;
+	Entry->Kind = POUR_TYPE;
 	Entry->Type = UNDO_REMOVE_POINT;
-	POLYGONPOINT_LOOP (polygon);
+	POURPOINT_LOOP (pour);
 	{
 	  if (pnt == point)
 	    {
@@ -787,9 +788,9 @@ UndoInsertPoint (UndoListTypePtr Entry)
 	    }
 	}
 	END_LOOP;
-	DestroyObject (PCB->Data, POLYGONPOINT_TYPE, layer, polygon, pnt);
+	DestroyObject (PCB->Data, POURPOINT_TYPE, layer, pour, pnt);
 	if (andDraw && layer->On)
-	  DrawPolygon (layer, polygon, 0);
+	  DrawPour (layer, pour, 0);
 	return (True);
       }
 
@@ -975,7 +976,7 @@ PerformUndo (UndoListTypePtr ptr)
       break;
 
     case UNDO_CLEAR:
-      if (UndoClearPoly (ptr))
+      if (UndoClearPour (ptr))
 	return (UNDO_CLEAR);
       break;
 
@@ -1147,7 +1148,7 @@ ClearUndoList (Boolean Force)
  * adds an object to the list of clearpoly objects
  */
 void
-AddObjectToClearPolyUndoList (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
+AddObjectToClearPourUndoList (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
 			      Boolean clear)
 {
   UndoListTypePtr undo;
@@ -1155,8 +1156,8 @@ AddObjectToClearPolyUndoList (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
   if (!Locked)
     {
       undo = GetUndoSlot (UNDO_CLEAR, OBJECT_ID (Ptr3), Type);
-      undo->Data.ClearPoly.Clear = clear;
-      undo->Data.ClearPoly.Layer = (LayerTypePtr) Ptr1;
+      undo->Data.ClearPour.Clear = clear;
+      undo->Data.ClearPour.Layer = (LayerTypePtr) Ptr1;
     }
 }
 
@@ -1222,23 +1223,23 @@ AddObjectToRemovePointUndoList (int Type,
 				void *Ptr1, void *Ptr2, Cardinal index)
 {
   UndoListTypePtr undo;
-  PolygonTypePtr polygon = (PolygonTypePtr) Ptr2;
+  PourTypePtr pour = (PourTypePtr) Ptr2;
 
   if (!Locked)
     {
       switch (Type)
 	{
-	case POLYGONPOINT_TYPE:
+	case POURPOINT_TYPE:
 	  {
 	    /* save the ID of the parent object; else it will be
 	     * impossible to recover the point
 	     */
 	    undo =
-	      GetUndoSlot (UNDO_REMOVE_POINT, OBJECT_ID (polygon),
-			   POLYGON_TYPE);
-	    undo->Data.RemovedPoint.X = polygon->Points[index].X;
-	    undo->Data.RemovedPoint.Y = polygon->Points[index].Y;
-	    undo->Data.RemovedPoint.ID = polygon->Points[index].ID;
+	      GetUndoSlot (UNDO_REMOVE_POINT, OBJECT_ID (pour),
+			   POUR_TYPE);
+	    undo->Data.RemovedPoint.X = pour->Points[index].X;
+	    undo->Data.RemovedPoint.Y = pour->Points[index].Y;
+	    undo->Data.RemovedPoint.ID = pour->Points[index].ID;
 	    undo->Data.RemovedPoint.Index = index;
 	  }
 	  break;
@@ -1317,7 +1318,7 @@ AddObjectToCreateUndoList (int Type, void *Ptr1, void *Ptr2, void *Ptr3)
 
   if (!Locked)
     undo = GetUndoSlot (UNDO_CREATE, OBJECT_ID (Ptr3), Type);
-  ClearFromPolygon (PCB->Data, Type, Ptr1, Ptr2);
+  ClearFromPours (PCB->Data, Type, Ptr1, Ptr2);
 }
 
 /* ---------------------------------------------------------------------------
diff --git a/src/undo.h b/src/undo.h
index a138927..e5da981 100644
--- a/src/undo.h
+++ b/src/undo.h
@@ -61,7 +61,7 @@ void AddObjectTo2ndSizeUndoList (int, void *, void *, void *);
 void AddObjectToClearSizeUndoList (int, void *, void *, void *);
 void AddObjectToMaskSizeUndoList (int, void *, void *, void *);
 void AddObjectToChangeAnglesUndoList (int, void *, void *, void *);
-void AddObjectToClearPolyUndoList (int, void *, void *, void *, Boolean);
+void AddObjectToClearPourUndoList (int, void *, void *, void *, Boolean);
 void AddLayerChangeToUndoList (int, int);
 void AddNetlistLibToUndoList (LibraryTypePtr);
 void LockUndo (void);

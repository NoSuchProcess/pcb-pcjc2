Bottom: 44ee51bcdda5b204d2160db3c298086b0738b0d2
Top:    642a0086ec29df8ce45f9f8d981bf303d97f1472
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2012-11-14 21:59:50 +0000

Other drawing API changes


---

diff --git a/src/crosshair.c b/src/crosshair.c
index b809d6b..7f31266 100644
--- a/src/crosshair.c
+++ b/src/crosshair.c
@@ -296,10 +296,6 @@ draw_move_or_copy_object (DrawAPI *dapi)
 void
 DrawAttached (DrawAPI *dapi)
 {
-  /* DEBUG ONLY */
-  if (dapi == NULL)
-    return;
-
   dapi->gc = dapi->graphics->make_gc ();
 
   dapi->graphics->set_color (dapi->gc, Settings.CrosshairColor);
@@ -459,10 +455,6 @@ DrawAttached (DrawAPI *dapi)
 void
 DrawMark (DrawAPI *dapi)
 {
-  /* DEBUG ONLY */
-  if (dapi == NULL)
-    return;
-
   /* Mark is not drawn when it is not set */
   if (!Marked.status)
     return;
diff --git a/src/data.c b/src/data.c
index 9d6588c..6f88522 100644
--- a/src/data.c
+++ b/src/data.c
@@ -42,7 +42,6 @@
 
 CrosshairType Crosshair;	/* information about cursor settings */
 MarkType Marked;		/* a cross-hair mark */
-OutputType Output;		/* some widgets ... used for drawing */
 PCBType *PCB;			/* pointer to layout struct */
 
 char *Progname;
diff --git a/src/data.h b/src/data.h
index 28cbfda..94c035f 100644
--- a/src/data.h
+++ b/src/data.h
@@ -41,8 +41,6 @@ extern CrosshairType Crosshair;
 
 extern MarkType Marked;
 
-extern OutputType Output;
-
 extern PCBType *PCB;
 
 #define max_group (PCB->Data->LayerN)
diff --git a/src/draw.c b/src/draw.c
index e4d59f5..3c9ab30 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -71,59 +71,76 @@
  */
 static BoxType Block = {MAXINT, MAXINT, -MAXINT, -MAXINT};
 
-static int doing_pinout = 0;
-static bool doing_assy = false;
-
 /* ---------------------------------------------------------------------------
  * some local prototypes
  */
-static void DrawEverything (const BoxType *);
-static void DrawPPV (int group, const BoxType *);
+static void DrawPPV (DrawAPI *dapi, int group);
 static void AddPart (void *);
-static void SetPVColor (PinType *, int);
-static void DrawEMark (ElementType *, Coord, Coord, bool);
-static void DrawRats (const BoxType *);
+static void DrawEMark (DrawAPI *dapi, ElementType *, Coord, Coord, bool);
+static void DrawRats (DrawAPI *dapi);
+
+struct side_info {
+  DrawAPI *dapi;
+  int side;
+};
 
 /*--------------------------------------------------------------------------------------
- * setup color for pin or via
+ * setup color for various objects
  */
 static void
-SetPVColor (PinType *Pin, int Type)
+set_color_for_pin (DrawAPI *dapi, PinType *pin)
 {
-  char *color;
+  char *color = PCB->PinColor;
 
-  if (Type == VIA_TYPE)
+  if (!dapi->doing_pinout)
     {
-      if (!doing_pinout
-	  && TEST_FLAG (WARNFLAG | SELECTEDFLAG | FOUNDFLAG, Pin))
-	{
-	  if (TEST_FLAG (WARNFLAG, Pin))
-	    color = PCB->WarnColor;
-	  else if (TEST_FLAG (SELECTEDFLAG, Pin))
-	    color = PCB->ViaSelectedColor;
-	  else
-	    color = PCB->ConnectedColor;
-	}
-      else
-	color = PCB->ViaColor;
+      if (TEST_FLAG (WARNFLAG, pin))
+        color = PCB->WarnColor;
+      else if (TEST_FLAG (SELECTEDFLAG, pin))
+        color = PCB->PinSelectedColor;
+      else if (TEST_FLAG (FOUNDFLAG, pin))
+        color = PCB->ConnectedColor;
     }
-  else
+
+  dapi->graphics->set_color (dapi->fg_gc, color);
+}
+
+static void
+set_color_for_via (DrawAPI *dapi, PinType *via)
+{
+  char *color = PCB->ViaColor;
+
+  if (!dapi->doing_pinout)
     {
-      if (!doing_pinout
-	  && TEST_FLAG (WARNFLAG | SELECTEDFLAG | FOUNDFLAG, Pin))
-	{
-	  if (TEST_FLAG (WARNFLAG, Pin))
-	    color = PCB->WarnColor;
-	  else if (TEST_FLAG (SELECTEDFLAG, Pin))
-	    color = PCB->PinSelectedColor;
-	  else
-	    color = PCB->ConnectedColor;
-	}
-      else
-	color = PCB->PinColor;
+      if (TEST_FLAG (WARNFLAG, via))
+        color = PCB->WarnColor;
+      else if (TEST_FLAG (SELECTEDFLAG, via))
+        color = PCB->ViaSelectedColor;
+      else if (TEST_FLAG (FOUNDFLAG, via))
+        color = PCB->ConnectedColor;
     }
 
-  gui->graphics->set_color (Output.fgGC, color);
+  dapi->graphics->set_color (dapi->fg_gc, color);
+}
+
+static void
+set_color_for_pad (DrawAPI *dapi, LayerType *layer, PadType *pad)
+{
+  char *color = PCB->PinColor;
+
+  if (!dapi->doing_pinout)
+    {
+      if (TEST_FLAG (WARNFLAG, pad))
+        color = PCB->WarnColor;
+      else if (TEST_FLAG (SELECTEDFLAG, pad))
+        color = PCB->PinSelectedColor;
+      else if (TEST_FLAG (FOUNDFLAG, pad))
+        color = PCB->ConnectedColor;
+      else if (!FRONT (pad))
+        color = PCB->InvisibleObjectsColor;
+    }
+
+  dapi->graphics->set_color (dapi->fg_gc, color);
 }
 
 /*---------------------------------------------------------------------------
@@ -164,7 +181,7 @@ Redraw (void)
 }
 
 static void
-_draw_pv_name (PinType *pv)
+_draw_pv_name (DrawAPI *dapi, PinType *pv)
 {
   BoxType box;
   bool vert;
@@ -188,7 +205,7 @@ _draw_pv_name (PinType *pv)
       box.Y1 = pv->Y - pv->Thickness    / 2 + Settings.PinoutTextOffsetY;
     }
 
-  gui->graphics->set_color (Output.fgGC, PCB->PinNameColor);
+  dapi->graphics->set_color (dapi->fg_gc, PCB->PinNameColor);
 
   text.Flags = NoFlags ();
   /* Set font height to approx 56% of pin thickness */
@@ -197,55 +214,42 @@ _draw_pv_name (PinType *pv)
   text.Y = box.Y1;
   text.Direction = vert ? 1 : 0;
 
-  if (gui->gui)
-    doing_pinout++;
-  DrawTextLowLevel (Output.fgGC, &text, 0);
-  if (gui->gui)
-    doing_pinout--;
-}
-
-static void
-_draw_pv (PinType *pv, bool draw_hole)
-{
-  if (TEST_FLAG (THINDRAWFLAG, PCB))
-    gui->graphics->thindraw_pcb_pv (Output.fgGC, Output.fgGC, pv, draw_hole, false);
-  else
-    gui->graphics->fill_pcb_pv (Output.fgGC, Output.bgGC, pv, draw_hole, false);
-
-  if (!TEST_FLAG (HOLEFLAG, pv) && TEST_FLAG (DISPLAYNAMEFLAG, pv))
-    _draw_pv_name (pv);
-}
-
-static void
-draw_pin (PinType *pin, bool draw_hole)
-{
-  SetPVColor (pin, PIN_TYPE);
-  _draw_pv (pin, draw_hole);
+  g_warn_if_fail (dapi->doing_overlay_text == false);
+  dapi->doing_overlay_text = gui->gui;
+  dapi->draw_pcb_text (dapi, NULL, &text, 0);
+  dapi->doing_overlay_text = false;
 }
 
 static int
 pin_callback (const BoxType * b, void *cl)
 {
-  draw_pin ((PinType *)b, false);
-  return 1;
-}
+  DrawAPI *dapi = cl;
+  PinType *pin = (PinType *)b;
 
-static void
-draw_via (PinType *via, bool draw_hole)
-{
-  SetPVColor (via, VIA_TYPE);
-  _draw_pv (via, draw_hole);
+  dapi->set_color_for_pin (dapi, pin);
+  dapi->draw_pcb_pin (dapi, pin);
+
+  if (!TEST_FLAG (HOLEFLAG, pin) && TEST_FLAG (DISPLAYNAMEFLAG, pin))
+    _draw_pv_name (dapi, pin);
+  return 1;
 }
 
 static int
 via_callback (const BoxType * b, void *cl)
 {
-  draw_via ((PinType *)b, false);
+  DrawAPI *dapi = cl;
+  PinType *via = (PinType *)b;
+
+  dapi->set_color_for_via (dapi, via);
+  dapi->draw_pcb_via (dapi, via);
+
+  if (!TEST_FLAG (HOLEFLAG, via) && TEST_FLAG (DISPLAYNAMEFLAG, via))
+    _draw_pv_name (dapi, via);
   return 1;
 }
 
 static void
-draw_pad_name (PadType *pad)
+draw_pad_name (DrawAPI *dapi, PadType *pad)
 {
   BoxType box;
   bool vert;
@@ -274,7 +278,7 @@ draw_pad_name (PadType *pad)
       box.Y1 += Settings.PinoutTextOffsetY;
     }
 
-  gui->graphics->set_color (Output.fgGC, PCB->PinNameColor);
+  dapi->graphics->set_color (dapi->fg_gc, PCB->PinNameColor);
 
   text.Flags = NoFlags ();
   /* Set font height to approx 90% of pin thickness */
@@ -283,73 +287,47 @@ draw_pad_name (PadType *pad)
   text.Y = box.Y1;
   text.Direction = vert ? 1 : 0;
 
-  DrawTextLowLevel (Output.fgGC, &text, 0);
+  dapi->draw_pcb_text (dapi, NULL, &text, 0);
 }
 
 static void
-_draw_pad (hidGC gc, PadType *pad, bool clear, bool mask)
+draw_pad (DrawAPI *dapi, PadType *pad)
 {
-  if (clear && !mask && pad->Clearance <= 0)
-    return;
-
-  if (TEST_FLAG (THINDRAWFLAG, PCB) ||
-      (clear && TEST_FLAG (THINDRAWPOLYFLAG, PCB)))
-    gui->graphics->thindraw_pcb_pad (gc, pad, clear, mask);
-  else
-    gui->graphics->fill_pcb_pad (gc, pad, clear, mask);
-}
-
-static void
-draw_pad (PadType *pad)
-{
-  if (doing_pinout)
-   gui->graphics->set_color (Output.fgGC, PCB->PinColor);
-  else if (TEST_FLAG (WARNFLAG | SELECTEDFLAG | FOUNDFLAG, pad))
-   {
-     if (TEST_FLAG (WARNFLAG, pad))
-       gui->graphics->set_color (Output.fgGC, PCB->WarnColor);
-     else if (TEST_FLAG (SELECTEDFLAG, pad))
-       gui->graphics->set_color (Output.fgGC, PCB->PinSelectedColor);
-     else
-       gui->graphics->set_color (Output.fgGC, PCB->ConnectedColor);
-   }
-  else if (FRONT (pad))
-   gui->graphics->set_color (Output.fgGC, PCB->PinColor);
-  else
-   gui->graphics->set_color (Output.fgGC, PCB->InvisibleObjectsColor);
-
-  _draw_pad (Output.fgGC, pad, false, false);
+  dapi->set_color_for_pad (dapi, NULL, pad);
+  dapi->draw_pcb_pad (dapi, NULL, pad);
 
-  if (doing_pinout || TEST_FLAG (DISPLAYNAMEFLAG, pad))
-    draw_pad_name (pad);
+  if (dapi->doing_pinout || TEST_FLAG (DISPLAYNAMEFLAG, pad))
+    draw_pad_name (dapi, pad);
 }
 
 static int
 pad_callback (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *) b;
-  int *side = cl;
+  struct side_info *info = cl;
+  DrawAPI *dapi = info->dapi;
 
-  if (ON_SIDE (pad, *side))
-    draw_pad (pad);
+  if (ON_SIDE (pad, info->side))
+    draw_pad (dapi, pad);
   return 1;
 }
 
 static void
-draw_element_name (ElementType *element)
+draw_element_name (DrawAPI *dapi, ElementType *element)
 {
   if ((TEST_FLAG (HIDENAMESFLAG, PCB) && gui->gui) ||
       TEST_FLAG (HIDENAMEFLAG, element))
     return;
-  if (doing_pinout || doing_assy)
-    gui->graphics->set_color (Output.fgGC, PCB->ElementColor);
+  if (dapi->doing_overlay_text || dapi->doing_pinout || dapi->doing_assy)
+    dapi->graphics->set_color (dapi->fg_gc, PCB->ElementColor);
   else if (TEST_FLAG (SELECTEDFLAG, &ELEMENT_TEXT (PCB, element)))
-    gui->graphics->set_color (Output.fgGC, PCB->ElementSelectedColor);
+    dapi->graphics->set_color (dapi->fg_gc, PCB->ElementSelectedColor);
   else if (FRONT (element))
-    gui->graphics->set_color (Output.fgGC, PCB->ElementColor);
+    dapi->graphics->set_color (dapi->fg_gc, PCB->ElementColor);
   else
-    gui->graphics->set_color (Output.fgGC, PCB->InvisibleObjectsColor);
-  DrawTextLowLevel (Output.fgGC, &ELEMENT_TEXT (PCB, element), PCB->minSlk);
+    dapi->graphics->set_color (dapi->fg_gc, PCB->InvisibleObjectsColor);
+
+  dapi->draw_pcb_text (dapi, NULL, &ELEMENT_TEXT (PCB, element), PCB->minSlk);
 }
 
 static int
@@ -357,127 +335,128 @@ name_callback (const BoxType * b, void *cl)
 {
   TextType *text = (TextType *) b;
   ElementType *element = (ElementType *) text->Element;
-  int *side = cl;
+  struct side_info *info = cl;
+  DrawAPI *dapi = info->dapi;
 
   if (TEST_FLAG (HIDENAMEFLAG, element))
     return 0;
 
-  if (ON_SIDE (element, *side))
-    draw_element_name (element);
+  if (ON_SIDE (element, info->side))
+    draw_element_name (dapi, element);
   return 0;
 }
 
-static void
-draw_element_pins_and_pads (ElementType *element)
-{
-  PAD_LOOP (element);
-  {
-    if (doing_pinout || doing_assy || FRONT (pad) || PCB->InvisibleObjectsOn)
-      draw_pad (pad);
-  }
-  END_LOOP;
-  PIN_LOOP (element);
-  {
-    draw_pin (pin, true);
-  }
-  END_LOOP;
-}
-
 static int
 EMark_callback (const BoxType * b, void *cl)
 {
+  DrawAPI *dapi = cl;
   ElementType *element = (ElementType *) b;
 
-  DrawEMark (element, element->MarkX, element->MarkY, !FRONT (element));
+  DrawEMark (dapi, element, element->MarkX, element->MarkY, !FRONT (element));
   return 1;
 }
 
+struct hole_info {
+  DrawAPI *dapi;
+  int plated;
+};
+
 static int
 hole_callback (const BoxType * b, void *cl)
 {
   PinType *pv = (PinType *) b;
-  int plated = cl ? *(int *) cl : -1;
+  struct hole_info *info = cl;
+  DrawAPI *dapi = info->dapi;
 
-  if ((plated == 0 && !TEST_FLAG (HOLEFLAG, pv)) ||
-      (plated == 1 &&  TEST_FLAG (HOLEFLAG, pv)))
+  if ((info->plated == 0 && !TEST_FLAG (HOLEFLAG, pv)) ||
+      (info->plated == 1 &&  TEST_FLAG (HOLEFLAG, pv)))
     return 1;
 
   if (TEST_FLAG (THINDRAWFLAG, PCB))
     {
       if (!TEST_FLAG (HOLEFLAG, pv))
         {
-          gui->graphics->set_line_cap (Output.fgGC, Round_Cap);
-          gui->graphics->set_line_width (Output.fgGC, 0);
-          gui->graphics->draw_arc (Output.fgGC,
-                                   pv->X, pv->Y, pv->DrillingHole / 2,
-                                   pv->DrillingHole / 2, 0, 360);
+          dapi->graphics->set_line_cap (dapi->fg_gc, Round_Cap);
+          dapi->graphics->set_line_width (dapi->fg_gc, 0);
+          dapi->graphics->draw_arc (dapi->fg_gc, pv->X, pv->Y, pv->DrillingHole / 2,
+                                    pv->DrillingHole / 2, 0, 360);
         }
     }
   else
-    gui->graphics->fill_circle (Output.bgGC, pv->X, pv->Y, pv->DrillingHole / 2);
+    dapi->graphics->fill_circle (dapi->bg_gc, pv->X, pv->Y, pv->DrillingHole / 2);
 
   if (TEST_FLAG (HOLEFLAG, pv))
     {
       if (TEST_FLAG (WARNFLAG, pv))
-        gui->graphics->set_color (Output.fgGC, PCB->WarnColor);
+        dapi->graphics->set_color (dapi->fg_gc, PCB->WarnColor);
       else if (TEST_FLAG (SELECTEDFLAG, pv))
-        gui->graphics->set_color (Output.fgGC, PCB->ViaSelectedColor);
+        dapi->graphics->set_color (dapi->fg_gc, PCB->ViaSelectedColor);
       else
-        gui->graphics->set_color (Output.fgGC, Settings.BlackColor);
+        dapi->graphics->set_color (dapi->fg_gc, Settings.BlackColor);
 
-      gui->graphics->set_line_cap (Output.fgGC, Round_Cap);
-      gui->graphics->set_line_width (Output.fgGC, 0);
-      gui->graphics->draw_arc (Output.fgGC,
-                               pv->X, pv->Y, pv->DrillingHole / 2,
-                               pv->DrillingHole / 2, 0, 360);
+      dapi->graphics->set_line_cap (dapi->fg_gc, Round_Cap);
+      dapi->graphics->set_line_width (dapi->fg_gc, 0);
+      dapi->graphics->draw_arc (dapi->fg_gc, pv->X, pv->Y, pv->DrillingHole / 2,
+                                pv->DrillingHole / 2, 0, 360);
     }
   return 1;
 }
 
 void
-DrawHoles (bool draw_plated, bool draw_unplated, const BoxType *drawn_area)
+DrawHoles (DrawAPI *dapi, bool draw_plated, bool draw_unplated)
 {
-  int plated = -1;
+  struct hole_info info;
+
+  info.dapi = dapi;
+  info.plated = -1;
 
-  if ( draw_plated && !draw_unplated) plated = 1;
-  if (!draw_plated &&  draw_unplated) plated = 0;
+  if ( draw_plated && !draw_unplated) info.plated = 1;
+  if (!draw_plated &&  draw_unplated) info.plated = 0;
 
-  r_search (PCB->Data->pin_tree, drawn_area, NULL, hole_callback, &plated);
-  r_search (PCB->Data->via_tree, drawn_area, NULL, hole_callback, &plated);
+  r_search (PCB->Data->pin_tree, dapi->clip_box, NULL, hole_callback, &info);
+  r_search (PCB->Data->via_tree, dapi->clip_box, NULL, hole_callback, &info);
 }
 
 static void
-_draw_line (hidGC gc, LineType *line)
+_draw_line (DrawAPI *dapi, LineType *line)
 {
-  gui->graphics->set_line_cap (gc, Trace_Cap);
+  dapi->graphics->set_line_cap (dapi->fg_gc, Trace_Cap);
   if (TEST_FLAG (THINDRAWFLAG, PCB))
-    gui->graphics->set_line_width (gc, 0);
+    dapi->graphics->set_line_width (dapi->fg_gc, 0);
   else
-    gui->graphics->set_line_width (gc, line->Thickness);
+    dapi->graphics->set_line_width (dapi->fg_gc, line->Thickness);
 
-  gui->graphics->draw_line (gc, line->Point1.X, line->Point1.Y,
-                                line->Point2.X, line->Point2.Y);
+  dapi->graphics->draw_line (dapi->fg_gc, line->Point1.X, line->Point1.Y,
+                                          line->Point2.X, line->Point2.Y);
 }
 
 static void
-draw_line (LayerType *layer, LineType *line)
+draw_line (DrawAPI *dapi, LayerType *layer, LineType *line)
 {
   if (TEST_FLAG (SELECTEDFLAG | FOUNDFLAG, line))
     {
       if (TEST_FLAG (SELECTEDFLAG, line))
-        gui->graphics->set_color (Output.fgGC, layer->SelectedColor);
+        dapi->graphics->set_color (dapi->fg_gc, layer->SelectedColor);
       else
-        gui->graphics->set_color (Output.fgGC, PCB->ConnectedColor);
+        dapi->graphics->set_color (dapi->fg_gc, PCB->ConnectedColor);
     }
   else
-    gui->graphics->set_color (Output.fgGC, layer->Color);
-  _draw_line (Output.fgGC, line);
+    dapi->graphics->set_color (dapi->fg_gc, layer->Color);
+  _draw_line (dapi, line);
 }
 
+struct layer_info {
+  DrawAPI *dapi;
+  LayerType *layer;
+};
+
 static int
 line_callback (const BoxType * b, void *cl)
 {
-  draw_line ((LayerType *) cl, (LineType *) b);
+  struct layer_info *info = cl;
+
+  DrawAPI *dapi = info->dapi;
+  draw_line (dapi, info->layer, (LineType *) b);
   return 1;
 }
 
@@ -485,16 +464,17 @@ static int
 rat_callback (const BoxType * b, void *cl)
 {
   RatType *rat = (RatType *)b;
+  DrawAPI *dapi = cl;
 
   if (TEST_FLAG (SELECTEDFLAG | FOUNDFLAG, rat))
     {
       if (TEST_FLAG (SELECTEDFLAG, rat))
-        gui->graphics->set_color (Output.fgGC, PCB->RatSelectedColor);
+        dapi->graphics->set_color (dapi->fg_gc, PCB->RatSelectedColor);
       else
-        gui->graphics->set_color (Output.fgGC, PCB->ConnectedColor);
+        dapi->graphics->set_color (dapi->fg_gc, PCB->ConnectedColor);
     }
   else
-    gui->graphics->set_color (Output.fgGC, PCB->RatColor);
+    dapi->graphics->set_color (dapi->fg_gc, PCB->RatColor);
 
   if (Settings.RatThickness < 100)
     rat->Thickness = pixel_slop * Settings.RatThickness;
@@ -504,78 +484,80 @@ rat_callback (const BoxType * b, void *cl)
       int w = rat->Thickness;
 
       if (TEST_FLAG (THINDRAWFLAG, PCB))
-        gui->graphics->set_line_width (Output.fgGC, 0);
+        dapi->graphics->set_line_width (dapi->fg_gc, 0);
       else
-        gui->graphics->set_line_width (Output.fgGC, w);
-      gui->graphics->draw_arc (Output.fgGC, rat->Point1.X, rat->Point1.Y,
-                               w * 2, w * 2, 0, 360);
+        dapi->graphics->set_line_width (dapi->fg_gc, w);
+      dapi->graphics->draw_arc (dapi->fg_gc, rat->Point1.X, rat->Point1.Y, w * 2, w * 2, 0, 360);
     }
   else
-    _draw_line (Output.fgGC, (LineType *) rat);
+    _draw_line (dapi, (LineType *) rat);
   return 1;
 }
 
 static void
-_draw_arc (ArcType *arc)
+_draw_arc (DrawAPI *dapi, ArcType *arc)
 {
   if (!arc->Thickness)
     return;
 
   if (TEST_FLAG (THINDRAWFLAG, PCB))
-    gui->graphics->set_line_width (Output.fgGC, 0);
+    dapi->graphics->set_line_width (dapi->fg_gc, 0);
   else
-    gui->graphics->set_line_width (Output.fgGC, arc->Thickness);
-  gui->graphics->set_line_cap (Output.fgGC, Trace_Cap);
+    dapi->graphics->set_line_width (dapi->fg_gc, arc->Thickness);
+  dapi->graphics->set_line_cap (dapi->fg_gc, Trace_Cap);
 
-  gui->graphics->draw_arc (Output.fgGC, arc->X, arc->Y, arc->Width,
-                           arc->Height, arc->StartAngle, arc->Delta);
+  dapi->graphics->draw_arc (dapi->fg_gc, arc->X, arc->Y, arc->Width,
+                            arc->Height, arc->StartAngle, arc->Delta);
 }
 
 static void
-draw_arc (LayerType *layer, ArcType *arc)
+draw_arc (DrawAPI *dapi, LayerType *layer, ArcType *arc)
 {
   if (TEST_FLAG (SELECTEDFLAG | FOUNDFLAG, arc))
     {
       if (TEST_FLAG (SELECTEDFLAG, arc))
-        gui->graphics->set_color (Output.fgGC, layer->SelectedColor);
+        dapi->graphics->set_color (dapi->fg_gc, layer->SelectedColor);
       else
-        gui->graphics->set_color (Output.fgGC, PCB->ConnectedColor);
+        dapi->graphics->set_color (dapi->fg_gc, PCB->ConnectedColor);
     }
   else
-    gui->graphics->set_color (Output.fgGC, layer->Color);
+    dapi->graphics->set_color (dapi->fg_gc, layer->Color);
 
-  _draw_arc (arc);
+  _draw_arc (dapi, arc);
 }
 
 static int
 arc_callback (const BoxType * b, void *cl)
 {
-  draw_arc ((LayerType *) cl, (ArcType *) b);
+  struct layer_info *info = cl;
+  DrawAPI *dapi = info->dapi;
+
+  draw_arc (dapi, info->layer, (ArcType *) b);
   return 1;
 }
 
 static void
-draw_element_package (ElementType *element)
+draw_element_package (DrawAPI *dapi, ElementType *element)
 {
   /* set color and draw lines, arcs, text and pins */
-  if (doing_pinout || doing_assy)
-    gui->graphics->set_color (Output.fgGC, PCB->ElementColor);
+  if (dapi->doing_pinout || dapi->doing_assy)
+    dapi->graphics->set_color (dapi->fg_gc, PCB->ElementColor);
   else if (TEST_FLAG (SELECTEDFLAG, element))
-    gui->graphics->set_color (Output.fgGC, PCB->ElementSelectedColor);
+    dapi->graphics->set_color (dapi->fg_gc, PCB->ElementSelectedColor);
   else if (FRONT (element))
-    gui->graphics->set_color (Output.fgGC, PCB->ElementColor);
+    dapi->graphics->set_color (dapi->fg_gc, PCB->ElementColor);
   else
-    gui->graphics->set_color (Output.fgGC, PCB->InvisibleObjectsColor);
+    dapi->graphics->set_color (dapi->fg_gc, PCB->InvisibleObjectsColor);
 
   /* draw lines, arcs, text and pins */
   ELEMENTLINE_LOOP (element);
   {
-    _draw_line (Output.fgGC, line);
+    _draw_line (dapi, line);
   }
   END_LOOP;
   ARC_LOOP (element);
   {
-    _draw_arc (arc);
+    _draw_arc (dapi, arc);
   }
   END_LOOP;
 }
@@ -584,10 +566,11 @@ static int
 element_callback (const BoxType * b, void *cl)
 {
   ElementType *element = (ElementType *) b;
-  int *side = cl;
+  struct side_info *info = cl;
+  DrawAPI *dapi = info->dapi;
 
-  if (ON_SIDE (element, *side))
-    draw_element_package (element);
+  if (ON_SIDE (element, info->side))
+    draw_element_package (dapi, element);
   return 1;
 }
 
@@ -595,28 +578,29 @@ element_callback (const BoxType * b, void *cl)
  * prints assembly drawing.
  */
 
-void
-PrintAssembly (int side, const BoxType * drawn_area)
+static void
+PrintAssembly (DrawAPI *dapi, int side)
 {
   int side_group = GetLayerGroupNumberByNumber (max_copper_layer + side);
 
-  doing_assy = true;
-  gui->graphics->set_draw_faded (Output.fgGC, 1);
-  DrawLayerGroup (side_group, drawn_area);
-  gui->graphics->set_draw_faded (Output.fgGC, 0);
+  g_warn_if_fail (dapi->doing_assy == false);
+  dapi->doing_assy = true;
+  dapi->graphics->set_draw_faded (dapi->fg_gc, 1);
+  dapi->draw_pcb_layer_group (dapi, side_group);
+  dapi->graphics->set_draw_faded (dapi->fg_gc, 0);
 
   /* draw package */
-  DrawSilk (side, drawn_area);
-  doing_assy = false;
+  dapi->draw_silk_layer (dapi, side);
+  dapi->doing_assy = false;
 }
 
 /* ---------------------------------------------------------------------------
  * initializes some identifiers for a new zoom factor and redraws whole screen
  */
 static void
-DrawEverything (const BoxType *drawn_area)
+DrawEverything (DrawAPI *dapi)
 {
-  int i, ngroups, side;
+  int i, ngroups;
   int component, solder;
   /* This is the list of layer groups we will draw.  */
   int do_group[MAX_LAYER];
@@ -649,14 +633,18 @@ DrawEverything (const BoxType *drawn_area)
   if (!TEST_FLAG (CHECKPLANESFLAG, PCB)
       && gui->set_layer ("invisible", SL (INVISIBLE, 0), 0))
     {
-      side = SWAP_IDENT ? COMPONENT_LAYER : SOLDER_LAYER;
+      struct side_info side_info;
+
+      side_info.dapi = dapi;
+      side_info.side = SWAP_IDENT ? COMPONENT_LAYER : SOLDER_LAYER;
+
       if (PCB->ElementOn)
 	{
-	  r_search (PCB->Data->element_tree, drawn_area, NULL, element_callback, &side);
-	  r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], drawn_area, NULL, name_callback, &side);
-	  DrawLayer (&(PCB->Data->Layer[max_copper_layer + side]), drawn_area);
+	  r_search (PCB->Data->element_tree, dapi->clip_box, NULL, element_callback, &side_info);
+	  r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], dapi->clip_box, NULL, name_callback, &side_info);
+	  dapi->draw_pcb_layer (dapi, &(PCB->Data->Layer[max_copper_layer + side_info.side]));
 	}
-      r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, &side);
+      r_search (PCB->Data->pad_tree, dapi->clip_box, NULL, pad_callback, &side_info);
       gui->end_layer ();
     }
 
@@ -667,7 +655,7 @@ DrawEverything (const BoxType *drawn_area)
 
       if (gui->set_layer (0, group, 0))
         {
-          DrawLayerGroup (group, drawn_area);
+          dapi->draw_pcb_layer_group (dapi, group);
           gui->end_layer ();
         }
     }
@@ -677,20 +665,20 @@ DrawEverything (const BoxType *drawn_area)
 
   /* Draw pins, pads, vias below silk */
   if (gui->gui)
-    DrawPPV (SWAP_IDENT ? solder : component, drawn_area);
+    DrawPPV (dapi, SWAP_IDENT ? solder : component);
   else
     {
-      CountHoles (&plated, &unplated, drawn_area);
+      CountHoles (&plated, &unplated, dapi->clip_box);
 
       if (plated && gui->set_layer ("plated-drill", SL (PDRILL, 0), 0))
         {
-          DrawHoles (true, false, drawn_area);
+          DrawHoles (dapi, true, false);
           gui->end_layer ();
         }
 
       if (unplated && gui->set_layer ("unplated-drill", SL (UDRILL, 0), 0))
         {
-          DrawHoles (false, true, drawn_area);
+          DrawHoles (dapi, false, true);
           gui->end_layer ();
         }
     }
@@ -698,25 +686,25 @@ DrawEverything (const BoxType *drawn_area)
   /* Draw the solder mask if turned on */
   if (gui->set_layer ("componentmask", SL (MASK, TOP), 0))
     {
-      DrawMask (COMPONENT_LAYER, drawn_area);
+      dapi->draw_mask_layer (dapi, COMPONENT_LAYER);
       gui->end_layer ();
     }
 
   if (gui->set_layer ("soldermask", SL (MASK, BOTTOM), 0))
     {
-      DrawMask (SOLDER_LAYER, drawn_area);
+      dapi->draw_mask_layer (dapi, SOLDER_LAYER);
       gui->end_layer ();
     }
 
   if (gui->set_layer ("topsilk", SL (SILK, TOP), 0))
     {
-      DrawSilk (COMPONENT_LAYER, drawn_area);
+      dapi->draw_silk_layer (dapi, COMPONENT_LAYER);
       gui->end_layer ();
     }
 
   if (gui->set_layer ("bottomsilk", SL (SILK, BOTTOM), 0))
     {
-      DrawSilk (SOLDER_LAYER, drawn_area);
+      dapi->draw_silk_layer (dapi, SOLDER_LAYER);
       gui->end_layer ();
     }
 
@@ -724,12 +712,11 @@ DrawEverything (const BoxType *drawn_area)
     {
       /* Draw element Marks */
       if (PCB->PinOn)
-	r_search (PCB->Data->element_tree, drawn_area, NULL, EMark_callback,
-		  NULL);
+	r_search (PCB->Data->element_tree, dapi->clip_box, NULL, EMark_callback, dapi);
       /* Draw rat lines on top */
       if (gui->set_layer ("rats", SL (RATS, 0), 0))
         {
-          DrawRats(drawn_area);
+          DrawRats (dapi);
           gui->end_layer ();
         }
     }
@@ -737,38 +724,38 @@ DrawEverything (const BoxType *drawn_area)
   paste_empty = IsPasteEmpty (COMPONENT_LAYER);
   if (gui->set_layer ("toppaste", SL (PASTE, TOP), paste_empty))
     {
-      DrawPaste (COMPONENT_LAYER, drawn_area);
+      dapi->draw_paste_layer (dapi, COMPONENT_LAYER);
       gui->end_layer ();
     }
 
   paste_empty = IsPasteEmpty (SOLDER_LAYER);
   if (gui->set_layer ("bottompaste", SL (PASTE, BOTTOM), paste_empty))
     {
-      DrawPaste (SOLDER_LAYER, drawn_area);
+      dapi->draw_paste_layer (dapi, SOLDER_LAYER);
       gui->end_layer ();
     }
 
   if (gui->set_layer ("topassembly", SL (ASSY, TOP), 0))
     {
-      PrintAssembly (COMPONENT_LAYER, drawn_area);
+      PrintAssembly (dapi, COMPONENT_LAYER);
       gui->end_layer ();
     }
 
   if (gui->set_layer ("bottomassembly", SL (ASSY, BOTTOM), 0))
     {
-      PrintAssembly (SOLDER_LAYER, drawn_area);
+      PrintAssembly (dapi, SOLDER_LAYER);
       gui->end_layer ();
     }
 
   if (gui->set_layer ("fab", SL (FAB, 0), 0))
     {
-      PrintFab (Output.fgGC);
+      PrintFab (dapi);
       gui->end_layer ();
     }
 }
 
 static void
-DrawEMark (ElementType *e, Coord X, Coord Y, bool invisible)
+DrawEMark (DrawAPI *dapi, ElementType *e, Coord X, Coord Y, bool invisible)
 {
   Coord mark_size = EMARK_SIZE;
   if (!PCB->InvisibleObjectsOn && invisible)
@@ -789,14 +776,13 @@ DrawEMark (ElementType *e, Coord X, Coord Y, bool invisible)
       mark_size = MIN (mark_size, pad0->Thickness / 2);
     }
 
-  gui->graphics->set_color (Output.fgGC,
-		  invisible ? PCB->InvisibleMarkColor : PCB->ElementColor);
-  gui->graphics->set_line_cap (Output.fgGC, Trace_Cap);
-  gui->graphics->set_line_width (Output.fgGC, 0);
-  gui->graphics->draw_line (Output.fgGC, X - mark_size, Y, X, Y - mark_size);
-  gui->graphics->draw_line (Output.fgGC, X + mark_size, Y, X, Y - mark_size);
-  gui->graphics->draw_line (Output.fgGC, X - mark_size, Y, X, Y + mark_size);
-  gui->graphics->draw_line (Output.fgGC, X + mark_size, Y, X, Y + mark_size);
+  dapi->graphics->set_color (dapi->fg_gc, invisible ? PCB->InvisibleMarkColor : PCB->ElementColor);
+  dapi->graphics->set_line_cap (dapi->fg_gc, Trace_Cap);
+  dapi->graphics->set_line_width (dapi->fg_gc, 0);
+  dapi->graphics->draw_line (dapi->fg_gc, X - mark_size, Y, X, Y - mark_size);
+  dapi->graphics->draw_line (dapi->fg_gc, X + mark_size, Y, X, Y - mark_size);
+  dapi->graphics->draw_line (dapi->fg_gc, X - mark_size, Y, X, Y + mark_size);
+  dapi->graphics->draw_line (dapi->fg_gc, X + mark_size, Y, X, Y + mark_size);
 
   /*
    * If an element is locked, place a "L" on top of the "diamond".
@@ -805,8 +791,8 @@ DrawEMark (ElementType *e, Coord X, Coord Y, bool invisible)
    */
   if (TEST_FLAG (LOCKFLAG, e) )
     {
-      gui->graphics->draw_line (Output.fgGC, X, Y, X + 2 * mark_size, Y);
-      gui->graphics->draw_line (Output.fgGC, X, Y, X, Y - 4* mark_size);
+      dapi->graphics->draw_line (dapi->fg_gc, X, Y, X + 2 * mark_size, Y);
+      dapi->graphics->draw_line (dapi->fg_gc, X, Y, X, Y - 4* mark_size);
     }
 }
 
@@ -815,61 +801,52 @@ DrawEMark (ElementType *e, Coord X, Coord Y, bool invisible)
  * otherwise drawing depends on PCB->PinOn and PCB->ViaOn
  */
 static void
-DrawPPV (int group, const BoxType *drawn_area)
+DrawPPV (DrawAPI *dapi, int group)
 {
   int component_group = GetLayerGroupNumberByNumber (component_silk_layer);
   int solder_group = GetLayerGroupNumberByNumber (solder_silk_layer);
-  int side;
+  struct hole_info hole_info;
+
+  hole_info.dapi = dapi;
+  hole_info.plated = -1;
 
   if (PCB->PinOn || !gui->gui)
     {
+      struct side_info side_info;
+      side_info.dapi = dapi;
+
       /* draw element pins */
-      r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_callback, NULL);
+      r_search (PCB->Data->pin_tree, dapi->clip_box, NULL, pin_callback, dapi);
 
       /* draw element pads */
       if (group == component_group)
         {
-          side = COMPONENT_LAYER;
-          r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, &side);
+          side_info.side = COMPONENT_LAYER;
+          r_search (PCB->Data->pad_tree, dapi->clip_box, NULL, pad_callback, &side_info);
         }
 
       if (group == solder_group)
         {
-          side = SOLDER_LAYER;
-          r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, &side);
+          side_info.side = SOLDER_LAYER;
+          r_search (PCB->Data->pad_tree, dapi->clip_box, NULL, pad_callback, &side_info);
         }
     }
 
   /* draw vias */
   if (PCB->ViaOn || !gui->gui)
     {
-      r_search (PCB->Data->via_tree, drawn_area, NULL, via_callback, NULL);
-      r_search (PCB->Data->via_tree, drawn_area, NULL, hole_callback, NULL);
+      r_search (PCB->Data->via_tree, dapi->clip_box, NULL, via_callback, dapi);
+      r_search (PCB->Data->via_tree, dapi->clip_box, NULL, hole_callback, &hole_info);
     }
-  if (PCB->PinOn || doing_assy)
-    r_search (PCB->Data->pin_tree, drawn_area, NULL, hole_callback, NULL);
+  if (PCB->PinOn || dapi->doing_assy)
+    r_search (PCB->Data->pin_tree, dapi->clip_box, NULL, hole_callback, &hole_info);
 }
 
 static int
-clearPin_callback (const BoxType * b, void *cl)
-{
-  PinType *pin = (PinType *) b;
-  if (TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG (THINDRAWPOLYFLAG, PCB))
-    gui->graphics->thindraw_pcb_pv (Output.pmGC, Output.pmGC, pin, false, true);
-  else
-    gui->graphics->fill_pcb_pv (Output.pmGC, Output.pmGC, pin, false, true);
-  return 1;
-}
-
-struct poly_info {
-  const BoxType *drawn_area;
-  LayerType *layer;
-};
-
-static int
 poly_callback (const BoxType * b, void *cl)
 {
-  struct poly_info *i = cl;
+  struct layer_info *info = cl;
+  DrawAPI *dapi = info->dapi;
   PolygonType *polygon = (PolygonType *)b;
   static char *color;
 
@@ -877,43 +854,52 @@ poly_callback (const BoxType * b, void *cl)
     return 0;
 
   if (TEST_FLAG (SELECTEDFLAG, polygon))
-    color = i->layer->SelectedColor;
+    color = info->layer->SelectedColor;
   else if (TEST_FLAG (FOUNDFLAG, polygon))
     color = PCB->ConnectedColor;
   else
-    color = i->layer->Color;
-  gui->graphics->set_color (Output.fgGC, color);
+    color = info->layer->Color;
+  dapi->graphics->set_color (dapi->fg_gc, color);
 
-  if (gui->graphics->thindraw_pcb_polygon != NULL &&
-      (TEST_FLAG (THINDRAWFLAG, PCB) ||
-       TEST_FLAG (THINDRAWPOLYFLAG, PCB)))
-    gui->graphics->thindraw_pcb_polygon (Output.fgGC, polygon, i->drawn_area);
-  else
-    gui->graphics->fill_pcb_polygon (Output.fgGC, polygon, i->drawn_area);
+  dapi->draw_pcb_polygon (dapi, info->layer, polygon);
 
   /* If checking planes, thin-draw any pieces which have been clipped away */
-  if (gui->graphics->thindraw_pcb_polygon != NULL &&
-      TEST_FLAG (CHECKPLANESFLAG, PCB) &&
+  if ( TEST_FLAG (CHECKPLANESFLAG, PCB) &&
       !TEST_FLAG (FULLPOLYFLAG, polygon))
     {
       PolygonType poly = *polygon;
 
+      /* XXX: SET FLAG TO MAKE THE GUI THINDRAW */
+
       for (poly.Clipped = polygon->Clipped->f;
            poly.Clipped != polygon->Clipped;
            poly.Clipped = poly.Clipped->f)
-        gui->graphics->thindraw_pcb_polygon (Output.fgGC, &poly, i->drawn_area);
+        dapi->draw_pcb_polygon (dapi, info->layer, &poly);
     }
 
   return 1;
 }
 
 static int
-clearPad_callback (const BoxType * b, void *cl)
+pin_mask_callback (const BoxType * b, void *cl)
+{
+  PinType *pin = (PinType *) b;
+  struct side_info *info = cl;
+
+  info->dapi->draw_pcb_pin_mask (info->dapi, pin);
+  return 1;
+}
+
+static int
+pad_mask_callback (const BoxType * b, void *cl)
 {
   PadType *pad = (PadType *) b;
-  int *side = cl;
-  if (ON_SIDE (pad, *side) && pad->Mask)
-    _draw_pad (Output.pmGC, pad, true, true);
+  struct side_info *info = cl;
+
+  if (!ON_SIDE (pad, info->side))
+    return 0;
+
+  info->dapi->draw_pcb_pad_mask (info->dapi, NULL, pad);
   return 1;
 }
 
@@ -922,112 +908,117 @@ clearPad_callback (const BoxType * b, void *cl)
  */
 
 void
-DrawSilk (int side, const BoxType * drawn_area)
+draw_silk_layer (DrawAPI *dapi, int side)
 {
+  struct side_info side_info;
+
+  side_info.dapi = dapi;
+  side_info.side = side;
+
 #if 0
   /* This code is used when you want to mask silk to avoid exposed
-     pins and pads.  We decided it was a bad idea to do this
-     unconditionally, but the code remains.  */
-#endif
+   * pins and pads.  We decided it was a bad idea to do this
+   * unconditionally, but the code remains.
+   *
+   * Note that many exporters (notably gerber, ps, eps), do not support the
+   * masking API, so this code won't actually work.
+   */
 
-#if 0
   if (gui->poly_before)
     {
-      gui->graphics->use_mask (HID_MASK_BEFORE);
+      dapi->graphics->use_mask (HID_MASK_BEFORE);
 #endif
-      DrawLayer (LAYER_PTR (max_copper_layer + side), drawn_area);
+      dapi->draw_pcb_layer (dapi, LAYER_PTR (max_copper_layer + side));
       /* draw package */
-      r_search (PCB->Data->element_tree, drawn_area, NULL, element_callback, &side);
-      r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], drawn_area, NULL, name_callback, &side);
+      r_search (PCB->Data->element_tree, dapi->clip_box, NULL, element_callback, &side_info);
+      r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], dapi->clip_box, NULL, name_callback, &side_info);
 #if 0
     }
 
-  gui->graphics->use_mask (HID_MASK_CLEAR);
-  r_search (PCB->Data->pin_tree, drawn_area, NULL, clearPin_callback, NULL);
-  r_search (PCB->Data->via_tree, drawn_area, NULL, clearPin_callback, NULL);
-  r_search (PCB->Data->pad_tree, drawn_area, NULL, clearPad_callback, &side);
+  dapi->graphics->use_mask (HID_MASK_CLEAR);
+  r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_mask_callback, NULL);
+  r_search (PCB->Data->via_tree, drawn_area, NULL, pin_mask_callback, NULL);
+  r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_mask_callback, &side);
 
   if (gui->poly_after)
     {
-      gui->graphics->use_mask (HID_MASK_AFTER);
-      DrawLayer (LAYER_PTR (max_copper_layer + layer), drawn_area);
+      dapi->graphics->use_mask (HID_MASK_AFTER);
+      DrawLayer (dapi, LAYER_PTR (max_copper_layer + layer), drawn_area);
       /* draw package */
       r_search (PCB->Data->element_tree, drawn_area, NULL, element_callback, &side);
-      r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], drawn_area, NULL, name_callback, &side);
+      r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], drawn_area, NULL, name_callback, &side_info);
     }
-  gui->graphics->use_mask (HID_MASK_OFF);
+  dapi->graphics->use_mask (HID_MASK_OFF);
 #endif
 }
 
 
 static void
-DrawMaskBoardArea (int mask_type, const BoxType *drawn_area)
+DrawMaskBoardArea (DrawAPI *dapi, int mask_type)
 {
   /* Skip the mask drawing if the GUI doesn't want this type */
   if ((mask_type == HID_MASK_BEFORE && !gui->poly_before) ||
       (mask_type == HID_MASK_AFTER  && !gui->poly_after))
     return;
 
-  gui->graphics->use_mask (mask_type);
-  gui->graphics->set_color (Output.fgGC, PCB->MaskColor);
-  if (drawn_area == NULL)
-    gui->graphics->fill_rect (Output.fgGC, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
+  dapi->graphics->use_mask (mask_type);
+  dapi->graphics->set_color (dapi->fg_gc, PCB->MaskColor);
+  if (dapi->clip_box == NULL)
+    dapi->graphics->fill_rect (dapi->fg_gc, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
   else
-    gui->graphics->fill_rect (Output.fgGC, drawn_area->X1, drawn_area->Y1,
-                                           drawn_area->X2, drawn_area->Y2);
+    dapi->graphics->fill_rect (dapi->fg_gc, dapi->clip_box->X1, dapi->clip_box->Y1,
+                                            dapi->clip_box->X2, dapi->clip_box->Y2);
 }
 
 /* ---------------------------------------------------------------------------
  * draws solder mask layer - this will cover nearly everything
  */
-void
-DrawMask (int side, const BoxType *screen)
+static void
+draw_mask_layer (DrawAPI *dapi, int side)
 {
   int thin = TEST_FLAG(THINDRAWFLAG, PCB) || TEST_FLAG(THINDRAWPOLYFLAG, PCB);
+  struct side_info info;
+
+  info.dapi = dapi;
+  info.side = side;
 
   if (thin)
-    gui->graphics->set_color (Output.pmGC, PCB->MaskColor);
+    dapi->graphics->set_color (dapi->fg_gc, PCB->MaskColor);
   else
     {
-      DrawMaskBoardArea (HID_MASK_BEFORE, screen);
-      gui->graphics->use_mask (HID_MASK_CLEAR);
+      DrawMaskBoardArea (dapi, HID_MASK_BEFORE);
+      dapi->graphics->use_mask (HID_MASK_CLEAR);
+      dapi->graphics->set_color (dapi->fg_gc, "erase"); /* <-- XXX: This might not be needed */
     }
 
-  r_search (PCB->Data->pin_tree, screen, NULL, clearPin_callback, NULL);
-  r_search (PCB->Data->via_tree, screen, NULL, clearPin_callback, NULL);
-  r_search (PCB->Data->pad_tree, screen, NULL, clearPad_callback, &side);
+  r_search (PCB->Data->pin_tree, dapi->clip_box, NULL, pin_mask_callback, &info);
+  r_search (PCB->Data->via_tree, dapi->clip_box, NULL, pin_mask_callback, &info);
+  r_search (PCB->Data->pad_tree, dapi->clip_box, NULL, pad_mask_callback, &info);
 
-  if (thin)
-    gui->graphics->set_color (Output.pmGC, "erase");
-  else
+  if (!thin)
     {
-      DrawMaskBoardArea (HID_MASK_AFTER, screen);
-      gui->graphics->use_mask (HID_MASK_OFF);
+      DrawMaskBoardArea (dapi, HID_MASK_AFTER);
+      dapi->graphics->use_mask (HID_MASK_OFF);
     }
 }
 
 /* ---------------------------------------------------------------------------
  * draws solder paste layer for a given side of the board
  */
-void
-DrawPaste (int side, const BoxType *drawn_area)
+static void
+draw_paste_layer (DrawAPI *dapi, int side)
 {
-  gui->graphics->set_color (Output.fgGC, PCB->ElementColor);
+  dapi->graphics->set_color (dapi->fg_gc, PCB->ElementColor); /* XXX: DO WE NEED THIS? */
   ALLPAD_LOOP (PCB->Data);
   {
-    if (ON_SIDE (pad, side) && !TEST_FLAG (NOPASTEFLAG, pad) && pad->Mask > 0)
-      {
-        if (pad->Mask < pad->Thickness)
-          _draw_pad (Output.fgGC, pad, true, true);
-        else
-          _draw_pad (Output.fgGC, pad, false, false);
-      }
+    if (ON_SIDE (pad, side))
+      dapi->draw_pcb_pad_paste (dapi, NULL, pad);
   }
   ENDALL_LOOP;
 }
 
 static void
-DrawRats (const BoxType *drawn_area)
+DrawRats (DrawAPI *dapi)
 {
   /*
    * XXX lesstif allows positive AND negative drawing in HID_MASK_CLEAR.
@@ -1037,64 +1028,61 @@ DrawRats (const BoxType *drawn_area)
   int can_mask = strcmp(gui->name, "lesstif") == 0;
 
   if (can_mask)
-    gui->graphics->use_mask (HID_MASK_CLEAR);
-  r_search (PCB->Data->rat_tree, drawn_area, NULL, rat_callback, NULL);
+    dapi->graphics->use_mask (HID_MASK_CLEAR);
+  r_search (PCB->Data->rat_tree, dapi->clip_box, NULL, rat_callback, dapi);
   if (can_mask)
-    gui->graphics->use_mask (HID_MASK_OFF);
+    dapi->graphics->use_mask (HID_MASK_OFF);
 }
 
 static int
 text_callback (const BoxType * b, void *cl)
 {
-  LayerType *layer = cl;
+  struct layer_info *info = cl;
+  DrawAPI *dapi = info->dapi;
   TextType *text = (TextType *)b;
   int min_silk_line;
 
   if (TEST_FLAG (SELECTEDFLAG, text))
-    gui->graphics->set_color (Output.fgGC, layer->SelectedColor);
+    dapi->graphics->set_color (dapi->fg_gc, info->layer->SelectedColor);
   else
-    gui->graphics->set_color (Output.fgGC, layer->Color);
-  if (layer == &PCB->Data->SILKLAYER ||
-      layer == &PCB->Data->BACKSILKLAYER)
+    dapi->graphics->set_color (dapi->fg_gc, info->layer->Color);
+
+  if (info->layer == &PCB->Data->SILKLAYER ||
+      info->layer == &PCB->Data->BACKSILKLAYER)
     min_silk_line = PCB->minSlk;
   else
     min_silk_line = PCB->minWid;
-  DrawTextLowLevel (Output.fgGC, text, min_silk_line);
+
+  dapi->draw_pcb_text (dapi, info->layer, text, min_silk_line);
   return 1;
 }
 
-void
-DrawLayer (LayerType *Layer, const BoxType *screen)
+static void
+draw_pcb_layer (DrawAPI *dapi, LayerType *layer)
 {
-  struct poly_info info = {screen, Layer};
+  struct layer_info info;
+
+  info.dapi = dapi;
+  info.layer = layer;
 
-  /* print the non-clearing polys */
-  r_search (Layer->polygon_tree, screen, NULL, poly_callback, &info);
+  r_search (layer->polygon_tree, dapi->clip_box, NULL, poly_callback, &info);
 
   if (TEST_FLAG (CHECKPLANESFLAG, PCB))
     return;
 
-  /* draw all visible lines this layer */
-  r_search (Layer->line_tree, screen, NULL, line_callback, Layer);
-
-  /* draw the layer arcs on screen */
-  r_search (Layer->arc_tree, screen, NULL, arc_callback, Layer);
-
-  /* draw the layer text on screen */
-  r_search (Layer->text_tree, screen, NULL, text_callback, Layer);
+  r_search (layer->line_tree,    dapi->clip_box, NULL, line_callback, &info);
+  r_search (layer->arc_tree,     dapi->clip_box, NULL, arc_callback,  &info);
+  r_search (layer->text_tree,    dapi->clip_box, NULL, text_callback, &info);
 
   /* We should check for gui->gui here, but it's kinda cool seeing the
      auto-outline magically disappear when you first add something to
      the "outline" layer.  */
-  if (IsLayerEmpty (Layer)
-      && (strcmp (Layer->Name, "outline") == 0
-	  || strcmp (Layer->Name, "route") == 0))
+  if (IsLayerEmpty (layer) && (strcmp (layer->Name, "outline") == 0 ||
+                               strcmp (layer->Name, "route")   == 0))
     {
-      gui->graphics->set_color (Output.fgGC, Layer->Color);
-      gui->graphics->set_line_width (Output.fgGC, PCB->minWid);
-      gui->graphics->draw_rect (Output.fgGC,
-                                0, 0,
-                                PCB->MaxWidth, PCB->MaxHeight);
+      dapi->graphics->set_color (dapi->fg_gc, layer->Color);
+      dapi->graphics->set_line_width (dapi->fg_gc, PCB->minWid);
+      dapi->graphics->draw_rect (dapi->fg_gc, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
     }
 }
 
@@ -1102,30 +1090,29 @@ DrawLayer (LayerType *Layer, const BoxType *screen)
  * draws one layer group.  If the exporter is not a GUI,
  * also draws the pins / pads / vias in this layer group.
  */
-void
-DrawLayerGroup (int group, const BoxType *drawn_area)
+static void
+draw_pcb_layer_group (DrawAPI *dapi, int group)
 {
-  int i, rv = 1;
+  int i;
   int layernum;
-  LayerType *Layer;
+  bool draw_ppv = false;
+  LayerType *layer;
   int n_entries = PCB->LayerGroups.Number[group];
   Cardinal *layers = PCB->LayerGroups.Entries[group];
 
   for (i = n_entries - 1; i >= 0; i--)
     {
       layernum = layers[i];
-      Layer = PCB->Data->Layer + layers[i];
-      if (strcmp (Layer->Name, "outline") == 0 ||
-          strcmp (Layer->Name, "route") == 0)
-        rv = 0;
-      if (layernum < max_copper_layer && Layer->On)
-        DrawLayer (Layer, drawn_area);
+      layer = PCB->Data->Layer + layers[i];
+      if (strcmp (layer->Name, "outline") != 0 &&
+          strcmp (layer->Name, "route")   != 0)
+        draw_ppv = !gui->gui;
+      if (layernum < max_copper_layer && layer->On)
+        dapi->draw_pcb_layer (dapi, layer);
     }
-  if (n_entries > 1)
-    rv = 1;
 
-  if (rv && !gui->gui)
-    DrawPPV (group, drawn_area);
+  if (draw_ppv)
+    DrawPPV (dapi, group);
 }
 
 static void
@@ -1194,7 +1181,7 @@ GatherPadName (PadType *Pad)
  * lowlevel drawing routine for text objects
  */
 void
-DrawTextLowLevel (hidGC gc, TextType *Text, Coord min_line_width)
+draw_pcb_text (DrawAPI *dapi, LayerType *layer, TextType *Text, Coord min_line_width)
 {
   Coord x = 0;
   unsigned char *string = (unsigned char *) Text->TextString;
@@ -1238,7 +1225,7 @@ DrawTextLowLevel (hidGC gc, TextType *Text, Coord min_line_width)
 	      newline.Point1.Y += Text->Y;
 	      newline.Point2.X += Text->X;
 	      newline.Point2.Y += Text->Y;
-	      _draw_line (gc, &newline);
+	      _draw_line (dapi, &newline);
 	    }
 
 	  /* move on to next cursor position */
@@ -1262,9 +1249,8 @@ DrawTextLowLevel (hidGC gc, TextType *Text, Coord min_line_width)
 	  defaultsymbol.Y1 += Text->Y;
 	  defaultsymbol.X2 += Text->X;
 	  defaultsymbol.Y2 += Text->Y;
-	  gui->graphics->fill_rect (gc,
-	                            defaultsymbol.X1, defaultsymbol.Y1,
-	                            defaultsymbol.X2, defaultsymbol.Y2);
+	  dapi->graphics->fill_rect (dapi->fg_gc, defaultsymbol.X1, defaultsymbol.Y1,
+	                                          defaultsymbol.X2, defaultsymbol.Y2);
 
 	  /* move on to next cursor position */
 	  x += size;
@@ -1300,8 +1286,7 @@ void
 DrawPin (PinType *Pin)
 {
   AddPart (Pin);
-  if ((!TEST_FLAG (HOLEFLAG, Pin) && TEST_FLAG (DISPLAYNAMEFLAG, Pin))
-      || doing_pinout)
+  if ((!TEST_FLAG (HOLEFLAG, Pin) && TEST_FLAG (DISPLAYNAMEFLAG, Pin)))
     DrawPinName (Pin);
 }
 
@@ -1321,7 +1306,7 @@ void
 DrawPad (PadType *Pad)
 {
   AddPart (Pad);
-  if (doing_pinout || TEST_FLAG (DISPLAYNAMEFLAG, Pad))
+  if (TEST_FLAG (DISPLAYNAMEFLAG, Pad))
     DrawPadName (Pad);
 }
 
@@ -1444,7 +1429,7 @@ DrawElementPinsAndPads (ElementType *Element)
 {
   PAD_LOOP (Element);
   {
-    if (doing_pinout || doing_assy || FRONT (pad) || PCB->InvisibleObjectsOn)
+    if (FRONT (pad) || PCB->InvisibleObjectsOn)
       DrawPad (pad);
   }
   END_LOOP;
@@ -1715,41 +1700,122 @@ DrawObject (int type, void *ptr1, void *ptr2)
 }
 
 static void
-draw_element (ElementType *element)
+draw_pcb_element (DrawAPI *dapi, ElementType *element)
 {
-  draw_element_package (element);
-  draw_element_name (element);
-  draw_element_pins_and_pads (element);
+  draw_element_package (dapi, element);
+  draw_element_name (dapi, element);
+
+  PAD_LOOP (element);
+  {
+    draw_pad (dapi, pad);
+  }
+  END_LOOP;
+  PIN_LOOP (element);
+  {
+    dapi->set_color_for_pin (dapi, pin);
+    dapi->draw_pcb_pin (dapi, pin);
+
+    if (!TEST_FLAG (HOLEFLAG, pin) && TEST_FLAG (DISPLAYNAMEFLAG, pin))
+      _draw_pv_name (dapi, pin);
+    dapi->draw_pcb_pin_hole (dapi, pin);
+  }
+  END_LOOP;
 }
 
 /* ---------------------------------------------------------------------------
  * HID drawing callback.
  */
 
-void
-hid_expose_callback (HID * hid, BoxType * region, void *item)
+static void
+draw_everything (DrawAPI *dapi)
 {
-  HID *old_gui = gui;
+  dapi->fg_gc = dapi->graphics->make_gc ();
+  dapi->bg_gc = dapi->graphics->make_gc ();
 
-  gui = hid;
-  Output.fgGC = gui->graphics->make_gc ();
-  Output.bgGC = gui->graphics->make_gc ();
-  Output.pmGC = gui->graphics->make_gc ();
+  dapi->graphics->set_color (dapi->bg_gc, "drill");
 
-  hid->graphics->set_color (Output.pmGC, "erase");
-  hid->graphics->set_color (Output.bgGC, "drill");
+  DrawEverything (dapi);
 
-  if (item)
-    {
-      doing_pinout = true;
-      draw_element ((ElementType *)item);
-      doing_pinout = false;
-    }
-  else
-    DrawEverything (region);
+  dapi->graphics->destroy_gc (dapi->fg_gc);
+  dapi->graphics->destroy_gc (dapi->bg_gc);
+}
+
+static void
+draw_pinout_preview (DrawAPI *dapi, ElementType *element)
+{
+  dapi->fg_gc = dapi->graphics->make_gc ();
+  dapi->bg_gc = dapi->graphics->make_gc ();
+
+  dapi->graphics->set_color (dapi->bg_gc, "drill");
+
+  g_warn_if_fail (dapi->doing_pinout == false);
+  dapi->doing_pinout = true;
+  dapi->draw_pcb_element (dapi, element);
+  dapi->doing_pinout = false;
+
+  dapi->graphics->destroy_gc (dapi->fg_gc);
+  dapi->graphics->destroy_gc (dapi->bg_gc);
+}
+
+static void
+set_clip_box (DrawAPI *dapi, const BoxType *clip_box)
+{
+  dapi->clip_box = clip_box;
+}
+
+DrawAPI *
+draw_api_new (void)
+{
+  DrawAPI *dapi;
+
+  dapi = g_new0 (DrawAPI, 1);
+
+#if 0
+  dapi->draw_pcb_pin          =
+  dapi->draw_pcb_pin_mask     =
+  dapi->draw_pcb_pin_hole     =
+  dapi->draw_pcb_via          =
+  dapi->draw_pcb_via_mask     =
+  dapi->draw_pcb_via_hole     =
+  dapi->draw_pcb_pad          =
+  dapi->draw_pcb_pad_mask     =
+  dapi->draw_pcb_pad_paste    =
+  dapi->draw_pcb_line         =
+  dapi->draw_pcb_arc          =
+#endif
+  dapi->draw_pcb_text         = draw_pcb_text;
+#if 0
+  dapi->draw_pcb_polygon      =
+#endif
+  dapi->set_color_for_pin     = set_color_for_pin;
+  dapi->set_color_for_via     = set_color_for_via;
+  dapi->set_color_for_pad     = set_color_for_pad;
+
+  /* The following types can be on copper layer, silk layers, selected, found,
+   * warned, they can be drawn as overlay text. We sould consisder whether
+   * any of these need to be split up into multiple hooks.
+   */
+  dapi->set_color_for_line    = NULL; // set_color_for_line;
+  dapi->set_color_for_arc     = NULL; // set_color_for_arc;
+  dapi->set_color_for_text    = NULL; // set_color_for_text;
+  dapi->set_color_for_polygon = NULL; // set_color_for_polygon;
+#if 0
+  dapi->draw_rat              =
+#endif
+  dapi->draw_pcb_element      = draw_pcb_element;
+  dapi->draw_pcb_layer        = draw_pcb_layer;
+  dapi->draw_pcb_layer_group  = draw_pcb_layer_group;
+  dapi->draw_mask_layer       = draw_mask_layer;
+  dapi->draw_paste_layer      = draw_paste_layer;
+  dapi->draw_silk_layer       = draw_silk_layer; /* Hmm - should be able to do this by layer number, even if not layer group */
+  /* But it would mean special casing diving into element silk from teh draw_pcb_layer function */
+  dapi->draw_everything       = draw_everything;
+  dapi->draw_pinout_preview   = draw_pinout_preview;
+#if 0
+  dapi->draw_pcb_buffer       =
+  dapi->set_draw_offset       =
+#endif
+  dapi->set_clip_box          = set_clip_box;
 
-  gui->graphics->destroy_gc (Output.fgGC);
-  gui->graphics->destroy_gc (Output.bgGC);
-  gui->graphics->destroy_gc (Output.pmGC);
-  gui = old_gui;
+  return dapi;
 }
diff --git a/src/draw.h b/src/draw.h
index 88e2349..dc0246f 100644
--- a/src/draw.h
+++ b/src/draw.h
@@ -31,6 +31,7 @@
 #define	PCB_DRAW_H
 
 #include "global.h"
+#include "draw_api.h"
 
 void Draw (void);
 void Redraw (void);
@@ -44,14 +45,12 @@ void DrawPadName (PadType *);
 void DrawLine (LayerType *, LineType *);
 void DrawArc (LayerType *, ArcType *);
 void DrawText (LayerType *, TextType *);
-void DrawTextLowLevel (hidGC gc, TextType *, Coord);
 void DrawPolygon (LayerType *, PolygonType *);
 void DrawElement (ElementType *);
 void DrawElementName (ElementType *);
 void DrawElementPackage (ElementType *);
 void DrawElementPinsAndPads (ElementType *);
 void DrawObject (int, void *, void *);
-void DrawLayer (LayerType *, const BoxType *);
 void EraseVia (PinType *);
 void EraseRat (RatType *);
 void EraseViaName (PinType *);
@@ -68,11 +67,6 @@ void EraseElementPinsAndPads (ElementType *);
 void EraseElementName (ElementType *);
 void EraseObject (int, void *, void *);
 
-void DrawLayerGroup (int side, const BoxType *drawn_area);
-void DrawPaste (int side, const BoxType *drawn_area);
-void DrawSilk (int side, const BoxType *drawn_area);
-void DrawMask (int side, const BoxType *drawn_area);
-void DrawHoles (bool draw_plated, bool draw_unplated, const BoxType *drawn_area);
-void PrintAssembly (int side, const BoxType *drawn_area);
+DrawAPI *draw_api_new (void);
 
 #endif
diff --git a/src/draw_api.h b/src/draw_api.h
index 69091c8..7b180b2 100644
--- a/src/draw_api.h
+++ b/src/draw_api.h
@@ -28,38 +28,64 @@ typedef struct GraphicsAPI GraphicsAPI;
 
 struct DrawAPI {
   /* Virtual functions */
-  void (*draw_pcb_pin)         (DrawAPI *, PinType *);
-  void (*draw_pcb_pin_mask)    (DrawAPI *, PinType *);
-  void (*draw_pcb_pin_hole)    (DrawAPI *, PinType *);
-  void (*draw_pcb_via)         (DrawAPI *, PinType *);
-  void (*draw_pcb_via_mask)    (DrawAPI *, PinType *);
-  void (*draw_pcb_via_hole)    (DrawAPI *, PinType *);
-  void (*draw_pcb_pad)         (DrawAPI *, LayerType *, PadType *);
-  void (*draw_pcb_pad_mask)    (DrawAPI *, LayerType *, PadType *);
-  void (*draw_pcb_pad_paste)   (DrawAPI *, LayerType *, PadType *);
-  void (*draw_pcb_line)        (DrawAPI *, LayerType *, LineType *);
-//  void (*draw_rat)         (DrawAPI *,              RatType *);
-  void (*draw_pcb_arc)         (DrawAPI *, LayerType *, ArcType *);
-  void (*draw_pcb_text)        (DrawAPI *, LayerType *, TextType *);
-  void (*draw_pcb_polygon)     (DrawAPI *, LayerType *, PolygonType *);
-
-//  void (*draw_ppv)         (DrawAPI *, LayerType *, int);
-//  void (*draw_holes)       (DrawAPI *,              int);
-  void (*draw_pcb_element)     (DrawAPI *, ElementType *);
-  void (*draw_pcb_layer)       (DrawAPI *, LayerType *,                const BoxType *, void *);
-  void (*draw_pcb_layer_group) (DrawAPI *, LayerType *,                const BoxType *, void *);
-  void (*draw_pcb_buffer)      (DrawAPI *, BufferType *);
+
+  /* Isolated calls, corresponding to actual copper / mask / paste features. These don't call other dapi's */
+
+  void (*draw_pcb_pin)          (DrawAPI *,              PinType *);
+  void (*draw_pcb_pin_mask)     (DrawAPI *,              PinType *);
+  void (*draw_pcb_pin_hole)     (DrawAPI *,              PinType *);
+  void (*draw_pcb_via)          (DrawAPI *,              PinType *);
+  void (*draw_pcb_via_mask)     (DrawAPI *,              PinType *);
+  void (*draw_pcb_via_hole)     (DrawAPI *,              PinType *);
+  void (*draw_pcb_pad)          (DrawAPI *, LayerType *, PadType *);
+  void (*draw_pcb_pad_mask)     (DrawAPI *, LayerType *, PadType *);
+  void (*draw_pcb_pad_paste)    (DrawAPI *, LayerType *, PadType *);
+  void (*draw_pcb_line)         (DrawAPI *, LayerType *, LineType *);
+  void (*draw_pcb_arc)          (DrawAPI *, LayerType *, ArcType *);
+  void (*draw_pcb_text)         (DrawAPI *, LayerType *, TextType *, Coord /* <-(HACK) */ );
+  void (*draw_pcb_polygon)      (DrawAPI *, LayerType *, PolygonType *);
+
+  /* Nasty, but pragmatic - a lot of our renderers will want to pick a colour */
+  void (*set_color_for_pin)     (DrawAPI *,              PinType *);
+  void (*set_color_for_via)     (DrawAPI *,              PinType *);
+  void (*set_color_for_pad)     (DrawAPI *, LayerType *, PadType *);
+  void (*set_color_for_line)    (DrawAPI *, LayerType *, LineType *);
+  void (*set_color_for_arc)     (DrawAPI *, LayerType *, ArcType *);
+  void (*set_color_for_text)    (DrawAPI *, LayerType *, TextType *);
+  void (*set_color_for_polygon) (DrawAPI *, LayerType *, PolygonType *);
+
+//  void (*draw_rat)              (DrawAPI *,              RatType *);
+
+  /* May call other dapi functions */
+  void (*draw_pcb_element)      (DrawAPI *, ElementType *);
+
+  /* Operates by calling other functions */
+//  void (*draw_holes)            (DrawAPI *,              int);
+//  void (*draw_ppv)              (DrawAPI *, LayerType *, int);
+  void (*draw_pcb_layer)        (DrawAPI *, LayerType *);
+  void (*draw_pcb_layer_group)  (DrawAPI *, int);
+  void (*draw_mask_layer)       (DrawAPI *, int);
+  void (*draw_paste_layer)      (DrawAPI *, int);
+  void (*draw_silk_layer)       (DrawAPI *, int);
+  void (*draw_pcb_buffer)       (DrawAPI *, BufferType *);
+  void (*draw_everything)       (DrawAPI *);
+  void (*draw_pinout_preview)   (DrawAPI *, ElementType *);
+
+  /* Setup dapi API rendering parameters */
   void (*set_draw_offset)      (DrawAPI *, Coord, Coord);
   void (*set_clip_box)         (DrawAPI *, const BoxType *);
 
   /* Member variables */
-//  GraphicsAPI *graphics;
-  HID_DRAW_API *graphics;
-  hidGC gc;
-  hidGC fg_gc;
-  hidGC bg_gc;
-  hidGC pm_gc;
-  BoxType *clip_box;
+  const BoxType *clip_box; /* Clipping box for the current drawing operation                  */
+  bool doing_overlay_text; /* Override for colour / style of overlay text such as pin names   */
+  bool doing_pinout;       /* Override for visibility / style when drawing a pinout preview   */
+  bool doing_assy;         /* Override for visibility / style when making an assembly drawing */
+
+//  GraphicsAPI *gapi;       /* <--- This should be in a subclass of the base dapi, but nevermind */
+  HID_DRAW_API *graphics;  /* <--- This should be in a subclass of the base dapi, but nevermind */
+  hidGC gc;                /* <--- This should be in a subclass of the base dapi, but nevermind */
+  hidGC fg_gc;             /* <--- This should be in a subclass of the base dapi, but nevermind */
+  hidGC bg_gc;             /* <--- This should be in a subclass of the base dapi, but nevermind */
 };
 
 #if 0
diff --git a/src/global.h b/src/global.h
index 7b966dc..6c0c68b 100644
--- a/src/global.h
+++ b/src/global.h
@@ -181,17 +181,6 @@ typedef struct
 	PointType	Point1,		\
 			Point2
 
-/* ---------------------------------------------------------------------------
- * some useful values of our widgets
- */
-typedef struct			/* holds information about output window */
-{
-  hidGC bgGC,			/* background and foreground; */
-    fgGC,			/* changed from some routines */
-    pmGC;			/* depth 1 pixmap GC to store clip */
-}
-OutputType;
-
 /* ----------------------------------------------------------------------
  * layer group. A layer group identifies layers which are always switched
  * on/off together.
diff --git a/src/hid.h b/src/hid.h
index 9230cd4..c32a68b 100644
--- a/src/hid.h
+++ b/src/hid.h
@@ -378,7 +378,7 @@ typedef enum
     void (*end_layer) (void);
 
 
-    HID_DRAW_API *graphics;
+//    HID_DRAW_API *graphics;
 
     /* This is for the printer.  If you call this for the GUI, xval and
        yval are ignored, and a dialog pops up to lead you through the
@@ -615,7 +615,7 @@ typedef enum
    Do *not* assume that the hid that is passed is the GUI hid.  This
    callback is also used for printing and exporting. */
   struct BoxType;
-  void hid_expose_callback (HID * hid_, struct BoxType *region_, void *item_);
+//  void hid_expose_callback (DrawAPI *dapi, struct BoxType *region_, void *item_);
 
 /* This is initially set to a "no-gui" gui, and later reset by
    main. hid_expose_callback also temporarily set it for drawing. */
diff --git a/src/hid/common/draw_helpers.c b/src/hid/common/draw_helpers.c
index 5344500..f8c0ccf 100644
--- a/src/hid/common/draw_helpers.c
+++ b/src/hid/common/draw_helpers.c
@@ -1,9 +1,11 @@
 #include "global.h"
 #include "hid.h"
 #include "polygon.h"
+#include "draw_api.h"
+#include "data.h"    /* <-- For nasty global "PCB" */
 
 static void
-fill_contour (hidGC gc, PLINE *pl)
+fill_contour (DrawAPI *dapi, PLINE *pl)
 {
   Coord *x, *y, n, i = 0;
   VNODE *v;
@@ -18,26 +20,26 @@ fill_contour (hidGC gc, PLINE *pl)
       y[i++] = v->point[1];
     }
 
-  gui->graphics->fill_polygon (gc, n, x, y);
+  dapi->graphics->fill_polygon (dapi->fg_gc, n, x, y);
 
   free (x);
   free (y);
 }
 
 static void
-thindraw_contour (hidGC gc, PLINE *pl)
+thindraw_contour (DrawAPI *dapi, PLINE *pl)
 {
   VNODE *v;
   Coord last_x, last_y;
   Coord this_x, this_y;
 
-  gui->graphics->set_line_width (gc, 0);
-  gui->graphics->set_line_cap (gc, Round_Cap);
+  dapi->graphics->set_line_width (dapi->fg_gc, 0);
+  dapi->graphics->set_line_cap (dapi->fg_gc, Round_Cap);
 
   /* If the contour is round, use an arc drawing routine. */
   if (pl->is_round)
     {
-      gui->graphics->draw_arc (gc, pl->cx, pl->cy, pl->radius, pl->radius, 0, 360);
+      dapi->graphics->draw_arc (dapi->fg_gc, pl->cx, pl->cy, pl->radius, pl->radius, 0, 360);
       return;
     }
 
@@ -54,8 +56,8 @@ thindraw_contour (hidGC gc, PLINE *pl)
       this_x = v->point[0];
       this_y = v->point[1];
 
-      gui->graphics->draw_line (gc, last_x, last_y, this_x, this_y);
-      // gui->graphics->fill_circle (gc, this_x, this_y, 30);
+      dapi->graphics->draw_line (dapi->fg_gc, last_x, last_y, this_x, this_y);
+      // dapi->graphics->fill_circle (dapi->fg_gc, this_x, this_y, 30);
 
       last_x = this_x;
       last_y = this_y;
@@ -66,15 +68,15 @@ thindraw_contour (hidGC gc, PLINE *pl)
 static void
 fill_contour_cb (PLINE *pl, void *user_data)
 {
-  hidGC gc = (hidGC)user_data;
+  DrawAPI *dapi = user_data;
   PLINE *local_pl = pl;
 
-  fill_contour (gc, pl);
+  fill_contour (dapi, pl);
   poly_FreeContours (&local_pl);
 }
 
 static void
-fill_clipped_contour (hidGC gc, PLINE *pl, const BoxType *clip_box)
+fill_clipped_contour (DrawAPI *dapi, PLINE *pl)
 {
   PLINE *pl_copy;
   POLYAREA *clip_poly;
@@ -83,8 +85,8 @@ fill_clipped_contour (hidGC gc, PLINE *pl, const BoxType *clip_box)
   POLYAREA *draw_piece;
   int x;
 
-  clip_poly = RectPoly (clip_box->X1, clip_box->X2,
-                        clip_box->Y1, clip_box->Y2);
+  clip_poly = RectPoly (dapi->clip_box->X1, dapi->clip_box->X2,
+                        dapi->clip_box->Y1, dapi->clip_box->Y2);
   poly_CopyContour (&pl_copy, pl);
   piece_poly = poly_Create ();
   poly_InclContour (piece_poly, pl_copy);
@@ -97,7 +99,7 @@ fill_clipped_contour (hidGC gc, PLINE *pl, const BoxType *clip_box)
   do
     {
       /* NB: The polygon won't have any holes in it */
-      fill_contour (gc, draw_piece->contours);
+      fill_contour (dapi, draw_piece->contours);
     }
   while ((draw_piece = draw_piece->f) != clipped_pieces);
   poly_Free (&clipped_pieces);
@@ -139,8 +141,8 @@ should_compute_no_holes (PolygonType *poly, const BoxType *clip_box)
 }
 #undef BOUNDS_INSIDE_CLIP_THRESHOLD
 
-void
-common_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+static void
+common_fill_pcb_polygon (DrawAPI *dapi, LayerType *layer, PolygonType *poly)
 {
   if (!poly->NoHolesValid)
     {
@@ -148,10 +150,10 @@ common_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
        * NoHoles version and cache it for later rendering, otherwise
        * just compute what we need to render now.
        */
-      if (should_compute_no_holes (poly, clip_box))
+      if (should_compute_no_holes (poly, dapi->clip_box))
         ComputeNoHoles (poly);
       else
-        NoHolesPolygonDicer (poly, clip_box, fill_contour_cb, gc);
+        NoHolesPolygonDicer (poly, dapi->clip_box, fill_contour_cb, dapi);
     }
   if (poly->NoHolesValid && poly->NoHoles)
     {
@@ -159,10 +161,10 @@ common_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
 
       for (pl = poly->NoHoles; pl != NULL; pl = pl->next)
         {
-          if (clip_box == NULL)
-            fill_contour (gc, pl);
+          if (dapi->clip_box == NULL)
+            fill_contour (dapi, pl);
           else
-            fill_clipped_contour (gc, pl, clip_box);
+            fill_clipped_contour (dapi, pl);
         }
     }
 
@@ -175,32 +177,29 @@ common_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
       for (p.Clipped = poly->Clipped->f;
            p.Clipped != poly->Clipped;
            p.Clipped = p.Clipped->f)
-        NoHolesPolygonDicer (&p, clip_box, fill_contour_cb, gc);
+        NoHolesPolygonDicer (&p, dapi->clip_box, fill_contour_cb, dapi);
     }
 }
 
 static int
 thindraw_hole_cb (PLINE *pl, void *user_data)
 {
-  hidGC gc = (hidGC)user_data;
-  thindraw_contour (gc, pl);
+  DrawAPI *dapi = user_data;
+  thindraw_contour (dapi, pl);
   return 0;
 }
 
-void
-common_thindraw_pcb_polygon (hidGC gc, PolygonType *poly,
-                             const BoxType *clip_box)
+static void
+common_thindraw_pcb_polygon (DrawAPI *dapi, LayerType *layer,
+                             PolygonType *poly)
 {
-  thindraw_contour (gc, poly->Clipped->contours);
-  PolygonHoles (poly, clip_box, thindraw_hole_cb, gc);
+  thindraw_contour (dapi, poly->Clipped->contours);
+  PolygonHoles (poly, dapi->clip_box, thindraw_hole_cb, dapi);
 }
 
-void
-common_thindraw_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask)
+static void
+thindraw_pcb_pad (DrawAPI *dapi, PadType *pad, Coord w)
 {
-  Coord w = clear ? (mask ? pad->Mask
-                          : pad->Thickness + pad->Clearance)
-                  : pad->Thickness;
   Coord x1, y1, x2, y2;
   Coord t = w / 2;
   x1 = pad->Point1.X;
@@ -214,8 +213,8 @@ common_thindraw_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask)
       x1 = x2; x2 = temp_x;
       y1 = y2; y2 = temp_y;
     }
-  gui->graphics->set_line_cap (gc, Round_Cap);
-  gui->graphics->set_line_width (gc, 0);
+  dapi->graphics->set_line_cap (dapi->fg_gc, Round_Cap);
+  dapi->graphics->set_line_width (dapi->fg_gc, 0);
   if (TEST_FLAG (SQUAREFLAG, pad))
     {
       /* slanted square pad */
@@ -231,14 +230,14 @@ common_thindraw_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask)
       tx = t * cos (theta + M_PI / 4) * sqrt (2.0);
       ty = t * sin (theta + M_PI / 4) * sqrt (2.0);
 
-      gui->graphics->draw_line (gc, x1 - tx, y1 - ty, x2 + ty, y2 - tx);
-      gui->graphics->draw_line (gc, x2 + ty, y2 - tx, x2 + tx, y2 + ty);
-      gui->graphics->draw_line (gc, x2 + tx, y2 + ty, x1 - ty, y1 + tx);
-      gui->graphics->draw_line (gc, x1 - ty, y1 + tx, x1 - tx, y1 - ty);
+      dapi->graphics->draw_line (dapi->fg_gc, x1 - tx, y1 - ty, x2 + ty, y2 - tx);
+      dapi->graphics->draw_line (dapi->fg_gc, x2 + ty, y2 - tx, x2 + tx, y2 + ty);
+      dapi->graphics->draw_line (dapi->fg_gc, x2 + tx, y2 + ty, x1 - ty, y1 + tx);
+      dapi->graphics->draw_line (dapi->fg_gc, x1 - ty, y1 + tx, x1 - tx, y1 - ty);
     }
   else if (x1 == x2 && y1 == y2)
     {
-      gui->graphics->draw_arc (gc, x1, y1, t, t, 0, 360);
+      dapi->graphics->draw_arc (dapi->fg_gc, x1, y1, t, t, 0, 360);
     }
   else
     {
@@ -252,25 +251,41 @@ common_thindraw_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask)
       ox = dy * h + 0.5 * SGN (dy);
       oy = -(dx * h + 0.5 * SGN (dx));
 
-      gui->graphics->draw_line (gc, x1 + ox, y1 + oy, x2 + ox, y2 + oy);
+      dapi->graphics->draw_line (dapi->fg_gc, x1 + ox, y1 + oy, x2 + ox, y2 + oy);
 
       if (abs (ox) >= pixel_slop || abs (oy) >= pixel_slop)
         {
           Angle angle = atan2 (dx, dy) * 57.295779;
-          gui->graphics->draw_line (gc, x1 - ox, y1 - oy, x2 - ox, y2 - oy);
-          gui->graphics->draw_arc (gc, x1, y1, t, t, angle - 180, 180);
-          gui->graphics->draw_arc (gc, x2, y2, t, t, angle, 180);
+          dapi->graphics->draw_line (dapi->fg_gc, x1 - ox, y1 - oy, x2 - ox, y2 - oy);
+          dapi->graphics->draw_arc (dapi->fg_gc, x1, y1, t, t, angle - 180, 180);
+          dapi->graphics->draw_arc (dapi->fg_gc, x2, y2, t, t, angle, 180);
         }
     }
 }
 
-void
-common_fill_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask)
+static void
+common_thindraw_pcb_pad (DrawAPI *dapi, LayerType *layer, PadType *pad)
+{
+  thindraw_pcb_pad (dapi, pad, pad->Thickness);
+}
+
+static void
+common_thindraw_pcb_pad_mask (DrawAPI *dapi, LayerType *layer, PadType *pad)
+{
+  if (pad->Mask > 0)
+    thindraw_pcb_pad (dapi, pad, pad->Mask);
+}
+
+static void
+common_thindraw_pcb_pad_paste (DrawAPI *dapi, LayerType *layer, PadType *pad)
 {
-  Coord w = clear ? (mask ? pad->Mask
-                          : pad->Thickness + pad->Clearance)
-                  : pad->Thickness;
+  if (!TEST_FLAG (NOPASTEFLAG, pad) && pad->Mask > 0)
+    thindraw_pcb_pad (dapi, pad, MIN (pad->Thickness, pad->Mask));
+}
 
+static void
+fill_pcb_pad (DrawAPI *dapi, PadType *pad, Coord w)
+{
   if (pad->Point1.X == pad->Point2.X &&
       pad->Point1.Y == pad->Point2.Y)
     {
@@ -281,24 +296,45 @@ common_fill_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask)
           b = pad->Point1.Y - w / 2;
           r = l + w;
           t = b + w;
-          gui->graphics->fill_rect (gc, l, b, r, t);
+          dapi->graphics->fill_rect (dapi->fg_gc, l, b, r, t);
         }
       else
         {
-          gui->graphics->fill_circle (gc, pad->Point1.X, pad->Point1.Y, w / 2);
+          dapi->graphics->fill_circle (dapi->fg_gc, pad->Point1.X, pad->Point1.Y, w / 2);
         }
     }
   else
     {
-      gui->graphics->set_line_cap (gc, TEST_FLAG (SQUAREFLAG, pad) ?
-                               Square_Cap : Round_Cap);
-      gui->graphics->set_line_width (gc, w);
+      dapi->graphics->set_line_cap (dapi->fg_gc, TEST_FLAG (SQUAREFLAG, pad) ?
+                                                                  Square_Cap : Round_Cap);
+      dapi->graphics->set_line_width (dapi->fg_gc, w);
 
-      gui->graphics->draw_line (gc, pad->Point1.X, pad->Point1.Y,
-                          pad->Point2.X, pad->Point2.Y);
+      dapi->graphics->draw_line (dapi->fg_gc, pad->Point1.X, pad->Point1.Y,
+                                              pad->Point2.X, pad->Point2.Y);
     }
 }
 
+static void
+common_fill_pcb_pad (DrawAPI *dapi, LayerType *layer, PadType *pad)
+{
+  fill_pcb_pad (dapi, pad, pad->Thickness);
+}
+
+static void
+common_fill_pcb_pad_mask (DrawAPI *dapi, LayerType *layer, PadType *pad)
+{
+  if (pad->Mask > 0)
+    fill_pcb_pad (dapi, pad, pad->Mask);
+}
+
+static void
+common_fill_pcb_pad_paste (DrawAPI *dapi, LayerType *layer, PadType *pad)
+{
+  if (!TEST_FLAG (NOPASTEFLAG, pad) && pad->Mask > 0)
+    fill_pcb_pad (dapi, pad, MIN (pad->Thickness, pad->Mask));
+}
+
+
 /* ---------------------------------------------------------------------------
  * draws one polygon
  * x and y are already in display coordinates
@@ -320,7 +356,7 @@ typedef struct
 FloatPolyType;
 
 static void
-draw_octagon_poly (hidGC gc, Coord X, Coord Y,
+draw_octagon_poly (DrawAPI *dapi, Coord X, Coord Y,
                    Coord Thickness, bool thin_draw)
 {
   static FloatPolyType p[8] = {
@@ -359,38 +395,23 @@ draw_octagon_poly (hidGC gc, Coord X, Coord Y,
   if (thin_draw)
     {
       int i;
-      gui->graphics->set_line_cap (gc, Round_Cap);
-      gui->graphics->set_line_width (gc, 0);
+      dapi->graphics->set_line_cap (dapi->fg_gc, Round_Cap);
+      dapi->graphics->set_line_width (dapi->fg_gc, 0);
       polygon_x[8] = X + scaled_x[0];
       polygon_y[8] = Y + scaled_y[0];
       for (i = 0; i < 8; i++)
-        gui->graphics->draw_line (gc, polygon_x[i    ], polygon_y[i    ],
-                            polygon_x[i + 1], polygon_y[i + 1]);
+        dapi->graphics->draw_line (dapi->fg_gc, polygon_x[i    ], polygon_y[i    ],
+                                                polygon_x[i + 1], polygon_y[i + 1]);
     }
   else
-    gui->graphics->fill_polygon (gc, 8, polygon_x, polygon_y);
+    dapi->graphics->fill_polygon (dapi->fg_gc, 8, polygon_x, polygon_y);
 }
 
-void
-common_fill_pcb_pv (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool mask)
+static void
+fill_pcb_pv (DrawAPI *dapi, PinType *pv, Coord w)
 {
-  Coord w = mask ? pv->Mask : pv->Thickness;
   Coord r = w / 2;
 
-  if (TEST_FLAG (HOLEFLAG, pv))
-    {
-      if (mask)
-	gui->graphics->fill_circle (bg_gc, pv->X, pv->Y, r);
-      if (drawHole)
-        {
-          gui->graphics->fill_circle (bg_gc, pv->X, pv->Y, r);
-          gui->graphics->set_line_cap (fg_gc, Round_Cap);
-          gui->graphics->set_line_width (fg_gc, 0);
-          gui->graphics->draw_arc (fg_gc, pv->X, pv->Y, r, r, 0, 360);
-        }
-      return;
-    }
-
   if (TEST_FLAG (SQUAREFLAG, pv))
     {
       Coord l = pv->X - r;
@@ -398,38 +419,56 @@ common_fill_pcb_pv (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool m
       Coord r = l + w;
       Coord t = b + w;
 
-      gui->graphics->fill_rect (fg_gc, l, b, r, t);
+      dapi->graphics->fill_rect (dapi->fg_gc, l, b, r, t);
     }
   else if (TEST_FLAG (OCTAGONFLAG, pv))
-    draw_octagon_poly (fg_gc, pv->X, pv->Y, w, false);
+    draw_octagon_poly (dapi, pv->X, pv->Y, w, false);
   else /* draw a round pin or via */
-    gui->graphics->fill_circle (fg_gc, pv->X, pv->Y, r);
+    dapi->graphics->fill_circle (dapi->fg_gc, pv->X, pv->Y, r);
+}
 
-  /* and the drilling hole  (which is always round) */
-  if (drawHole)
-    gui->graphics->fill_circle (bg_gc, pv->X, pv->Y, pv->DrillingHole / 2);
+static void
+common_fill_pcb_pv (DrawAPI *dapi, PinType *pv)
+{
+  if (!TEST_FLAG (HOLEFLAG, pv))
+    fill_pcb_pv (dapi, pv, pv->Thickness);
 }
 
-void
-common_thindraw_pcb_pv (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool mask)
+static void
+common_fill_pcb_pv_mask (DrawAPI *dapi, PinType *pv)
 {
-  Coord w = mask ? pv->Mask : pv->Thickness;
-  Coord r = w / 2;
+  if (pv->Mask > 0)
+    fill_pcb_pv (dapi, pv, pv->Mask);
+}
+
+static void
+common_fill_pcb_pv_hole (DrawAPI *dapi, PinType *pv)
+{
+  Coord r = pv->DrillingHole / 2;
 
+  dapi->graphics->fill_circle (dapi->bg_gc, pv->X, pv->Y, r);
+
+  /* Outline the hole if we are just drawing a hole */
   if (TEST_FLAG (HOLEFLAG, pv))
     {
-      if (mask)
-	gui->graphics->draw_arc (fg_gc, pv->X, pv->Y, r, r, 0, 360);
-      if (drawHole)
-        {
-	  r = pv->DrillingHole / 2;
-          gui->graphics->set_line_cap (bg_gc, Round_Cap);
-          gui->graphics->set_line_width (bg_gc, 0);
-          gui->graphics->draw_arc (bg_gc, pv->X, pv->Y, r, r, 0, 360);
-        }
-      return;
+      dapi->graphics->set_line_cap (dapi->fg_gc, Round_Cap);
+      dapi->graphics->set_line_width (dapi->fg_gc, 0);
+      dapi->graphics->draw_arc (dapi->fg_gc, pv->X, pv->Y, r, r, 0, 360);
     }
+}
+
+static void
+thindraw_pcb_pv (DrawAPI *dapi, PinType *pv, Coord w)
+{
+  Coord r = w / 2;
 
+  /* NB: This code-path allows a square or octagonal mask for a hole,
+   *     whereas our pervious drawing routines would always force a
+   *     round mask aperture for a hole.
+   *     This new code should be ok, as the SQUARE or OCTAGONAL flags
+   *     are highly unlikely to be set on a hole. (But can be now if
+   *     the user desires).
+   */
   if (TEST_FLAG (SQUAREFLAG, pv))
     {
       Coord l = pv->X - r;
@@ -437,42 +476,155 @@ common_thindraw_pcb_pv (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bo
       Coord r = l + w;
       Coord t = b + w;
 
-      gui->graphics->set_line_cap (fg_gc, Round_Cap);
-      gui->graphics->set_line_width (fg_gc, 0);
-      gui->graphics->draw_line (fg_gc, r, t, r, b);
-      gui->graphics->draw_line (fg_gc, l, t, l, b);
-      gui->graphics->draw_line (fg_gc, r, t, l, t);
-      gui->graphics->draw_line (fg_gc, r, b, l, b);
+      dapi->graphics->set_line_cap (dapi->fg_gc, Round_Cap);
+      dapi->graphics->set_line_width (dapi->fg_gc, 0);
+      dapi->graphics->draw_line (dapi->fg_gc, r, t, r, b);
+      dapi->graphics->draw_line (dapi->fg_gc, l, t, l, b);
+      dapi->graphics->draw_line (dapi->fg_gc, r, t, l, t);
+      dapi->graphics->draw_line (dapi->fg_gc, r, b, l, b);
 
     }
   else if (TEST_FLAG (OCTAGONFLAG, pv))
     {
-      draw_octagon_poly (fg_gc, pv->X, pv->Y, w, true);
+      draw_octagon_poly (dapi, pv->X, pv->Y, w, true);
     }
   else /* draw a round pin or via */
     {
-      gui->graphics->set_line_cap (fg_gc, Round_Cap);
-      gui->graphics->set_line_width (fg_gc, 0);
-      gui->graphics->draw_arc (fg_gc, pv->X, pv->Y, r, r, 0, 360);
+      dapi->graphics->set_line_cap (dapi->fg_gc, Round_Cap);
+      dapi->graphics->set_line_width (dapi->fg_gc, 0);
+      dapi->graphics->draw_arc (dapi->fg_gc, pv->X, pv->Y, r, r, 0, 360);
     }
+}
 
-  /* and the drilling hole  (which is always round */
-  if (drawHole)
-    {
-      gui->graphics->set_line_cap (bg_gc, Round_Cap);
-      gui->graphics->set_line_width (bg_gc, 0);
-      gui->graphics->draw_arc (bg_gc, pv->X, pv->Y, pv->DrillingHole / 2,
-                     pv->DrillingHole / 2, 0, 360);
-    }
+static void
+common_thindraw_pcb_pv (DrawAPI *dapi, PinType *pv)
+{
+  if (!TEST_FLAG (HOLEFLAG, pv))
+    thindraw_pcb_pv (dapi, pv, pv->Thickness);
+}
+
+static void
+common_thindraw_pcb_pv_mask (DrawAPI *dapi, PinType *pv)
+{
+  if (pv->Mask > 0)
+    thindraw_pcb_pv (dapi, pv, pv->Mask);
+}
+
+static void
+common_thindraw_pcb_pv_hole (DrawAPI *dapi, PinType *pv)
+{
+  Coord r = pv->DrillingHole / 2;
+
+  dapi->graphics->set_line_cap (dapi->bg_gc, Round_Cap);
+  dapi->graphics->set_line_width (dapi->bg_gc, 0);
+  dapi->graphics->draw_arc (dapi->bg_gc, pv->X, pv->Y, r, r, 0, 360);
+}
+
+static void
+common_draw_pcb_polygon (DrawAPI *dapi, LayerType *layer, PolygonType *poly)
+{
+  if (TEST_FLAG (THINDRAWFLAG,     PCB) ||
+      TEST_FLAG (THINDRAWPOLYFLAG, PCB))
+    common_thindraw_pcb_polygon (dapi, layer, poly);
+  else
+    common_fill_pcb_polygon (dapi, layer, poly);
+
+}
+
+static void
+common_draw_pcb_pad (DrawAPI *dapi, LayerType *layer, PadType *pad)
+{
+  if (TEST_FLAG (THINDRAWFLAG, PCB))
+    common_thindraw_pcb_pad (dapi, layer, pad);
+  else
+    common_fill_pcb_pad (dapi, layer, pad);
+}
+
+static void
+common_draw_pcb_pad_mask (DrawAPI *dapi, LayerType *layer, PadType *pad)
+{
+  if (TEST_FLAG (THINDRAWFLAG,     PCB) ||
+      TEST_FLAG (THINDRAWPOLYFLAG, PCB))
+    common_thindraw_pcb_pad_mask (dapi, layer, pad);
+  else
+    common_fill_pcb_pad_mask (dapi, layer, pad);
+}
+
+static void
+common_draw_pcb_pad_paste (DrawAPI *dapi, LayerType *layer, PadType *pad)
+{
+  if (TEST_FLAG (THINDRAWFLAG, PCB))
+    common_thindraw_pcb_pad_paste (dapi, layer, pad);
+  else
+    common_fill_pcb_pad_paste (dapi, layer, pad);
+}
+
+static void
+common_draw_pcb_pv (DrawAPI *dapi, PinType *pv)
+{
+  if (TEST_FLAG (THINDRAWFLAG, PCB))
+    common_thindraw_pcb_pv (dapi, pv);
+  else
+    common_fill_pcb_pv (dapi, pv);
+}
+
+static void
+common_draw_pcb_pv_mask (DrawAPI *dapi, PinType *pv)
+{
+  if (TEST_FLAG (THINDRAWFLAG,     PCB) ||
+      TEST_FLAG (THINDRAWPOLYFLAG, PCB))
+    common_thindraw_pcb_pv_mask (dapi, pv);
+  else
+    common_fill_pcb_pv_mask (dapi, pv);
+}
+
+static void
+common_draw_pcb_pv_hole (DrawAPI *dapi, PinType *pv)
+{
+  if (TEST_FLAG (THINDRAWFLAG, PCB))
+    common_thindraw_pcb_pv_hole (dapi, pv);
+  else
+    common_fill_pcb_pv_hole (dapi, pv);
+}
+
+void
+common_draw_helpers_init (DrawAPI *dapi)
+{
+  dapi->draw_pcb_polygon   = common_draw_pcb_polygon;
+  dapi->draw_pcb_pad       = common_draw_pcb_pad;
+  dapi->draw_pcb_pad_mask  = common_draw_pcb_pad_mask;
+  dapi->draw_pcb_pad_paste = common_draw_pcb_pad_paste;
+  dapi->draw_pcb_pin       = common_draw_pcb_pv;
+  dapi->draw_pcb_pin_mask  = common_draw_pcb_pv_mask;
+  dapi->draw_pcb_pin_hole  = common_draw_pcb_pv_hole;
+  dapi->draw_pcb_via       = common_draw_pcb_pv;
+  dapi->draw_pcb_via_mask  = common_draw_pcb_pv_mask;
 }
 
 void
-common_draw_helpers_init (HID_DRAW_API *dapi)
-{
-  dapi->fill_pcb_polygon     = common_fill_pcb_polygon;
-  dapi->thindraw_pcb_polygon = common_thindraw_pcb_polygon;
-  dapi->fill_pcb_pad         = common_fill_pcb_pad;
-  dapi->thindraw_pcb_pad     = common_thindraw_pcb_pad;
-  dapi->fill_pcb_pv          = common_fill_pcb_pv;
-  dapi->thindraw_pcb_pv      = common_thindraw_pcb_pv;
+common_fill_helpers_init (DrawAPI *dapi)
+{
+  dapi->draw_pcb_polygon   = common_fill_pcb_polygon;
+  dapi->draw_pcb_pad       = common_fill_pcb_pad;
+  dapi->draw_pcb_pad_mask  = common_fill_pcb_pad_mask;
+  dapi->draw_pcb_pad_paste = common_fill_pcb_pad_paste;
+  dapi->draw_pcb_pin       = common_fill_pcb_pv;
+  dapi->draw_pcb_pin_mask  = common_fill_pcb_pv_mask;
+  dapi->draw_pcb_pin_hole  = common_fill_pcb_pv_hole;
+  dapi->draw_pcb_via       = common_fill_pcb_pv;
+  dapi->draw_pcb_via_mask  = common_fill_pcb_pv_mask;
+}
+
+void
+common_thindraw_helpers_init (DrawAPI *dapi)
+{
+  dapi->draw_pcb_polygon   = common_thindraw_pcb_polygon;
+  dapi->draw_pcb_pad       = common_thindraw_pcb_pad;
+  dapi->draw_pcb_pad_mask  = common_thindraw_pcb_pad_mask;
+  dapi->draw_pcb_pad_paste = common_thindraw_pcb_pad_paste;
+  dapi->draw_pcb_pin       = common_thindraw_pcb_pv;
+  dapi->draw_pcb_pin_mask  = common_thindraw_pcb_pv_mask;
+  dapi->draw_pcb_pin_hole  = common_thindraw_pcb_pv_hole;
+  dapi->draw_pcb_via       = common_thindraw_pcb_pv;
+  dapi->draw_pcb_via_mask  = common_thindraw_pcb_pv_mask;
 }
diff --git a/src/hid/common/draw_helpers.h b/src/hid/common/draw_helpers.h
index f9bf0cb..24294a4 100644
--- a/src/hid/common/draw_helpers.h
+++ b/src/hid/common/draw_helpers.h
@@ -6,4 +6,4 @@ void common_fill_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask);
 void common_thindraw_pcb_pad (hidGC gc, PadType *pad, bool clear, bool mask);
 void common_fill_pcb_pv (hidGC gc, PinType *pv, bool drawHole, bool mask);
 void common_thindraw_pcb_pv (hidGC fg_gc, hidGC bg_gc, PinType *pv, bool drawHole, bool mask);
-void common_draw_helpers_init (HID_DRAW_API *dapi);
+void common_draw_helpers_init (DrawAPI *dapi);
diff --git a/src/hid/common/extents.c b/src/hid/common/extents.c
index dc30848..4df36cf 100644
--- a/src/hid/common/extents.c
+++ b/src/hid/common/extents.c
@@ -12,6 +12,7 @@
 
 #include "hid.h"
 #include "../hidint.h"
+#include "draw_api.h"
 #include "hid/common/draw_helpers.h"
 
 #ifdef HAVE_LIBDMALLOC
@@ -164,7 +165,7 @@ hid_extents_init (void)
   memset (&extents_hid, 0, sizeof (HID));
   memset (&extents_graphics, 0, sizeof (HID_DRAW_API));
 
-  common_draw_helpers_init (&extents_graphics);
+//  common_draw_helpers_init (&extents_graphics);
 
   extents_hid.struct_size         = sizeof (HID);
   extents_hid.name                = "extents-extents";
@@ -173,7 +174,7 @@ hid_extents_init (void)
 
   extents_hid.set_layer           = extents_set_layer;
 
-  extents_hid.graphics            = &extents_graphics;
+//  extents_hid.graphics            = &extents_graphics;
 
   extents_graphics.make_gc        = extents_make_gc;
   extents_graphics.destroy_gc     = extents_destroy_gc;
@@ -194,7 +195,7 @@ hid_extents_init (void)
 BoxType *
 hid_get_extents (void *item)
 {
-  BoxType region;
+//  BoxType region;
 
   /* As this isn't a real "HID", we need to ensure we are initialised. */
   hid_extents_init ();
@@ -204,11 +205,13 @@ hid_get_extents (void *item)
   box.X2 = -MAXINT;
   box.Y2 = -MAXINT;
 
+#if 0
   region.X1 = -MAXINT;
   region.Y1 = -MAXINT;
   region.X2 = MAXINT;
   region.Y2 = MAXINT;
   hid_expose_callback (&extents_hid, &region, item);
+#endif
 
   return &box;
 }
diff --git a/src/hid/common/hidnogui.c b/src/hid/common/hidnogui.c
index b6c8222..ff78c92 100644
--- a/src/hid/common/hidnogui.c
+++ b/src/hid/common/hidnogui.c
@@ -493,11 +493,13 @@ common_nogui_graphics_init (HID_DRAW_API *graphics)
   graphics->fill_polygon =    nogui_fill_polygon;
   graphics->fill_rect =       nogui_fill_rect;
 
+#if 0
   graphics->fill_pcb_polygon = nogui_fill_pcb_polygon;
   graphics->fill_pcb_pad =     nogui_fill_pcb_pad;
   graphics->thindraw_pcb_pad = nogui_thindraw_pcb_pad;
   graphics->fill_pcb_pv =      nogui_fill_pcb_pv;
   graphics->thindraw_pcb_pv =  nogui_thindraw_pcb_pv;
+#endif
 }
 
 static HID nogui_hid;
@@ -513,7 +515,7 @@ hid_nogui_get_hid (void)
   nogui_hid.name        = "nogui";
   nogui_hid.description = "Default GUI when no other GUI is present.  "
                           "Does nothing.";
-  nogui_hid.graphics    = &nogui_graphics;
+//  nogui_hid.graphics    = &nogui_graphics;
 
   common_nogui_init (&nogui_hid);
   common_nogui_graphics_init (&nogui_graphics);
diff --git a/src/hid/gcode/gcode.c b/src/hid/gcode/gcode.c
index 9dbd378..f66f557 100644
--- a/src/hid/gcode/gcode.c
+++ b/src/hid/gcode/gcode.c
@@ -56,6 +56,7 @@
 #include "../hidint.h"
 #include <gd.h>
 #include "hid/common/hidnogui.h"
+#include "draw_api.h"
 #include "hid/common/draw_helpers.h"
 #include "bitmap.h"
 #include "curve.h"
@@ -454,6 +455,7 @@ gcode_finish_png (const char *layername)
 static void
 gcode_start_png_export ()
 {
+#if 0
   BoxType region;
 
   region.X1 = PCB->ExtentMinX;
@@ -465,6 +467,7 @@ gcode_start_png_export ()
   lastbrush = (gdImagePtr)((void *) -1);
 
   hid_expose_callback (&gcode_hid, &region, 0);
+#endif
 }
 
 static FILE *
@@ -1572,7 +1575,7 @@ hid_gcode_init ()
   memset (&gcode_graphics, 0, sizeof (HID_DRAW_API));
 
   common_nogui_init (&gcode_hid);
-  common_draw_helpers_init (&gcode_graphics);
+//  common_draw_helpers_init (&gcode_graphics);
 
   gcode_hid.struct_size         = sizeof (HID);
   gcode_hid.name                = "gcode";
@@ -1587,7 +1590,7 @@ hid_gcode_init ()
   gcode_hid.calibrate           = gcode_calibrate;
   gcode_hid.set_crosshair       = gcode_set_crosshair;
 
-  gcode_hid.graphics            = &gcode_graphics;
+//  gcode_hid.graphics            = &gcode_graphics;
 
   gcode_graphics.make_gc        = gcode_make_gc;
   gcode_graphics.destroy_gc     = gcode_destroy_gc;
diff --git a/src/hid/gerber/gerber.c b/src/hid/gerber/gerber.c
index 502fb7a..dfd2b35 100644
--- a/src/hid/gerber/gerber.c
+++ b/src/hid/gerber/gerber.c
@@ -622,11 +622,11 @@ gerber_do_export (HID_Attr_Val * options)
   lastgroup = -1;
   layer_list_idx = 0;
   finding_apertures = 1;
-  hid_expose_callback (&gerber_hid, &region, 0);
+//  hid_expose_callback (&gerber_hid, &region, 0);
 
   layer_list_idx = 0;
   finding_apertures = 0;
-  hid_expose_callback (&gerber_hid, &region, 0);
+//  hid_expose_callback (&gerber_hid, &region, 0);
 
   memcpy (LayerStack, saved_layer_stack, sizeof (LayerStack));
 
@@ -854,23 +854,28 @@ gerber_set_layer (const char *name, int group, int empty)
     {
       if (outline_layer
 	  && outline_layer != PCB->Data->Layer+idx)
-	DrawLayer (outline_layer, &region);
+        {
+          DrawAPI *dapi = NULL;
+          dapi->set_clip_box (dapi, &region);
+          dapi->draw_pcb_layer (dapi, outline_layer);
+        }
       else if (!outline_layer)
-	{
-	  hidGC gc = gui->graphics->make_gc ();
-	  printf("name %s idx %d\n", name, idx);
-	  if (SL_TYPE (idx) == SL_SILK)
-	    gui->graphics->set_line_width (gc, PCB->minSlk);
-	  else if (group >= 0)
-	    gui->graphics->set_line_width (gc, PCB->minWid);
-	  else
-	    gui->graphics->set_line_width (gc, AUTO_OUTLINE_WIDTH);
-	  gui->graphics->draw_line (gc, 0, 0, PCB->MaxWidth, 0);
-	  gui->graphics->draw_line (gc, 0, 0, 0, PCB->MaxHeight);
-	  gui->graphics->draw_line (gc, PCB->MaxWidth, 0, PCB->MaxWidth, PCB->MaxHeight);
-	  gui->graphics->draw_line (gc, 0, PCB->MaxHeight, PCB->MaxWidth, PCB->MaxHeight);
-	  gui->graphics->destroy_gc (gc);
-	}
+        {
+          DrawAPI *dapi = NULL;
+          hidGC gc = dapi->graphics->make_gc ();
+          printf("name %s idx %d\n", name, idx);
+          if (SL_TYPE (idx) == SL_SILK)
+            dapi->graphics->set_line_width (gc, PCB->minSlk);
+          else if (group >= 0)
+            dapi->graphics->set_line_width (gc, PCB->minWid);
+          else
+            dapi->graphics->set_line_width (gc, AUTO_OUTLINE_WIDTH);
+          dapi->graphics->draw_line (gc, 0, 0, PCB->MaxWidth, 0);
+          dapi->graphics->draw_line (gc, 0, 0, 0, PCB->MaxHeight);
+          dapi->graphics->draw_line (gc, PCB->MaxWidth, 0, PCB->MaxWidth, PCB->MaxHeight);
+          dapi->graphics->draw_line (gc, 0, PCB->MaxHeight, PCB->MaxWidth, PCB->MaxHeight);
+          dapi->graphics->destroy_gc (gc);
+      }
     }
 
   return 1;
@@ -1178,8 +1183,8 @@ gerber_fill_polygon (hidGC gc, int n_coords, Coord *x, Coord *y)
   int firstTime = 1;
   Coord startX = 0, startY = 0;
 
-  if (is_mask && current_mask == HID_MASK_BEFORE)
-    return;
+//  if (is_mask && current_mask == HID_MASK_BEFORE)
+//    return;
 
   use_gc (gc, 10 * 100);
   if (!f)
@@ -1262,7 +1267,7 @@ hid_gerber_init ()
   memset (&gerber_graphics, 0, sizeof (gerber_graphics));
 
   common_nogui_init (&gerber_hid);
-  common_draw_helpers_init (&gerber_graphics);
+//  common_draw_helpers_init (&gerber_graphics);
 
   gerber_hid.struct_size         = sizeof (gerber_hid);
   gerber_hid.name                = "gerber";
@@ -1276,7 +1281,7 @@ hid_gerber_init ()
   gerber_hid.calibrate           = gerber_calibrate;
   gerber_hid.set_crosshair       = gerber_set_crosshair;
 
-  gerber_hid.graphics            = &gerber_graphics;
+//  gerber_hid.graphics            = &gerber_graphics;
 
   gerber_graphics.make_gc        = gerber_make_gc;
   gerber_graphics.destroy_gc     = gerber_destroy_gc;
diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index 6c159b4..f1ee9aa 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -785,7 +785,7 @@ redraw_region (GdkRectangle *rect)
 
   ghid_draw_bg_image();
 
-  hid_expose_callback (&ghid_hid, &region, 0);
+//  hid_expose_callback (&ghid_hid, &region, 0);
   ghid_draw_grid ();
 
   /* In some cases we are called with the crosshair still off */
@@ -1159,7 +1159,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
                       0, 0, allocation.width, allocation.height);
 
   /* call the drawing routine */
-  hid_expose_callback (&ghid_hid, NULL, &pinout->element);
+//  hid_expose_callback (&ghid_hid, NULL, &pinout->element);
 
   gport->drawable = save_drawable;
   gport->view = save_view;
@@ -1216,7 +1216,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   region.Y1 = MAX (0, MIN (PCB->MaxHeight, region.Y1));
   region.Y2 = MAX (0, MIN (PCB->MaxHeight, region.Y2));
 
-  hid_expose_callback (&ghid_hid, &region, NULL);
+//  hid_expose_callback (&ghid_hid, &region, NULL);
 
   gport->drawable = save_drawable;
   gport->view = save_view;
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 95aa233..2548c25 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -9,6 +9,7 @@
 #include "../hidint.h"
 #include "gui.h"
 #include "gui-pinout-preview.h"
+#include "draw.h"
 #include "outline_draw.h"
 
 /* The Linux OpenGL ABI 1.0 spec requires that we define
@@ -577,7 +578,7 @@ ghid_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
 void
 ghid_thindraw_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
 {
-  common_thindraw_pcb_polygon (gc, poly, clip_box);
+  //common_thindraw_pcb_polygon (gc, poly, clip_box);
   ghid_set_alpha_mult (gc, 0.25);
   ghid_fill_pcb_polygon (gc, poly, clip_box);
   ghid_set_alpha_mult (gc, 1.0);
@@ -781,8 +782,8 @@ ghid_init_renderer (int *argc, char ***argv, GHidPort *port)
 
   /* Setup HID function pointers specific to the GL renderer*/
   ghid_hid.end_layer = ghid_end_layer;
-  ghid_graphics.fill_pcb_polygon = ghid_fill_pcb_polygon;
-  ghid_graphics.thindraw_pcb_polygon = ghid_thindraw_pcb_polygon;
+//  ghid_graphics.fill_pcb_polygon = ghid_fill_pcb_polygon;
+//  ghid_graphics.thindraw_pcb_polygon = ghid_thindraw_pcb_polygon;
 }
 
 void
@@ -869,6 +870,13 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   Coord min_depth;
   Coord max_depth;
 
+  DrawAPI *dapi;
+
+  dapi = draw_api_new ();
+  dapi->graphics = &ghid_graphics;
+  dapi->gc = dapi->graphics->make_gc ();
+  common_draw_helpers_init (dapi);
+
   gtk_widget_get_allocation (widget, &allocation);
 
   ghid_start_drawing (port);
@@ -877,8 +885,8 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   /* If we don't have any stencil bits available,
      we can't use the hidgl polygon drawing routine */
   /* TODO: We could use the GLU tessellator though */
-  if (hidgl_stencil_bits() == 0)
-    ghid_graphics.fill_pcb_polygon = common_fill_pcb_polygon;
+//  if (hidgl_stencil_bits() == 0)
+//    ghid_graphics.fill_pcb_polygon = common_fill_pcb_polygon;
 
   glEnable (GL_BLEND);
   glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
@@ -1000,7 +1008,9 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   ghid_draw_bg_image ();
 
   ghid_invalidate_current_gc ();
-  hid_expose_callback (&ghid_hid, &region, 0);
+  dapi->set_clip_box (dapi, &region);
+  dapi->draw_everything (dapi);
+//  hid_expose_callback (&ghid_hid, &region, 0);
   hidgl_flush_triangles (&buffer);
 
   ghid_draw_grid (&region);
@@ -1009,11 +1019,11 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   {
     DrawAPI *dapi;
-    dapi = outline_draw_new (gui->graphics);
+    dapi = outline_draw_new (&ghid_graphics);
     dapi->set_draw_offset = hidgl_set_draw_offset;
 
-    DrawAttached (dapi);
-    DrawMark (dapi);
+//    DrawAttached (dapi);
+//    DrawMark (dapi);
   }
   hidgl_flush_triangles (&buffer);
 
@@ -1131,7 +1141,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
                 gport->view.flip_y ? gport->view.y0 - PCB->MaxHeight :
                                     -gport->view.y0, 0);
 
-  hid_expose_callback (&ghid_hid, NULL, &pinout->element);
+//  hid_expose_callback (&ghid_hid, NULL, &pinout->element);
   hidgl_flush_triangles (&buffer);
   glPopMatrix ();
 
@@ -1248,7 +1258,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   region.Y1 = MAX (0, MIN (PCB->MaxHeight, region.Y1));
   region.Y2 = MAX (0, MIN (PCB->MaxHeight, region.Y2));
 
-  hid_expose_callback (&ghid_hid, &region, NULL);
+//  hid_expose_callback (&ghid_hid, &region, NULL);
   hidgl_flush_triangles (&buffer);
   glPopMatrix ();
 
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 6fff548..44b7916 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -2180,6 +2180,7 @@ hid_gtk_init ()
   ghid_hid.notify_save_pcb          = ghid_notify_save_pcb;
   ghid_hid.notify_filename_changed  = ghid_notify_filename_changed;
 
+#if 0
   ghid_hid.graphics                 = &ghid_graphics;
 
   common_draw_helpers_init (&ghid_graphics);
@@ -2196,6 +2197,7 @@ hid_gtk_init ()
   ghid_graphics.fill_circle         = ghid_fill_circle;
   ghid_graphics.fill_polygon        = ghid_fill_polygon;
   ghid_graphics.fill_rect           = ghid_fill_rect;
+#endif
 
   hid_register_hid (&ghid_hid);
 #include "gtk_lists.h"
diff --git a/src/hid/lesstif/main.c b/src/hid/lesstif/main.c
index 043d83e..e1db86a 100644
--- a/src/hid/lesstif/main.c
+++ b/src/hid/lesstif/main.c
@@ -822,7 +822,7 @@ Benchmark (int argc, char **argv, Coord x, Coord y)
   do
     {
       XFillRectangle (display, pixmap, bg_gc, 0, 0, view_width, view_height);
-      hid_expose_callback (&lesstif_hid, &region, 0);
+//      hid_expose_callback (&lesstif_hid, &region, 0);
       XSync (display, 0);
       time (&end);
       i++;
@@ -2573,7 +2573,7 @@ idle_proc (XtPointer dummy)
 	    }
 	}
       DrawBackgroundImage();
-      hid_expose_callback (&lesstif_hid, &region, 0);
+//      hid_expose_callback (&lesstif_hid, &region, 0);
       draw_grid ();
       lesstif_use_mask (0);
       show_crosshair (0); /* To keep the drawn / not drawn info correct */
@@ -2583,6 +2583,7 @@ idle_proc (XtPointer dummy)
       pixmap = window;
       if (crosshair_on)
         {
+          lesstif_set_draw_xor (gc, true);
           DrawAttached ();
           DrawMark ();
         }
@@ -2952,6 +2953,7 @@ lesstif_notify_crosshair_change (bool changes_complete)
     {
       save_pixmap = pixmap;
       pixmap = window;
+      lesstif_set_draw_xor (gc, true);
       DrawAttached ();
       pixmap = save_pixmap;
     }
@@ -3778,7 +3780,7 @@ pinout_callback (Widget da, PinoutData * pd,
   region.Y2 = PCB->MaxHeight;
 
   XFillRectangle (display, pixmap, bg_gc, 0, 0, pd->v_width, pd->v_height);
-  hid_expose_callback (&lesstif_hid, &region, pd->item);
+//  hid_expose_callback (&lesstif_hid, &region, pd->item);
 
   pinout = 0;
   view_left_x = save_vx;
@@ -4020,6 +4022,7 @@ lesstif_flush_debug_draw (void)
   pixmap = window;
   if (crosshair_on)
     {
+      lesstif_set_draw_xor (gc, true);
       DrawAttached ();
       DrawMark ();
     }
diff --git a/src/hid/nelma/nelma.c b/src/hid/nelma/nelma.c
index cad06fd..b0245f5 100644
--- a/src/hid/nelma/nelma.c
+++ b/src/hid/nelma/nelma.c
@@ -72,6 +72,7 @@
 #include "hid.h"
 #include "../hidint.h"
 #include "hid/common/hidnogui.h"
+#include "draw_api.h"
 #include "hid/common/draw_helpers.h"
 
 #include <gd.h>
@@ -636,6 +637,7 @@ nelma_finish_png()
 void 
 nelma_start_png_export()
 {
+#if 0
 	BoxType         region;
 
 	region.X1 = 0;
@@ -647,6 +649,7 @@ nelma_start_png_export()
 	lastbrush = (gdImagePtr)((void *) -1);
 
 	hid_expose_callback(&nelma_hid, &region, 0);
+#endif
 }
 
 static void 
@@ -1034,7 +1037,7 @@ hid_nelma_init()
   memset (&nelma_graphics, 0, sizeof (HID_DRAW_API));
 
   common_nogui_init (&nelma_hid);
-  common_draw_helpers_init (&nelma_graphics);
+//  common_draw_helpers_init (&nelma_graphics);
 
   nelma_hid.struct_size         = sizeof (HID);
   nelma_hid.name                = "nelma";
@@ -1049,7 +1052,7 @@ hid_nelma_init()
   nelma_hid.calibrate           = nelma_calibrate;
   nelma_hid.set_crosshair       = nelma_set_crosshair;
 
-  nelma_hid.graphics            = &nelma_graphics;
+//  nelma_hid.graphics            = &nelma_graphics;
 
   nelma_graphics.make_gc        = nelma_make_gc;
   nelma_graphics.destroy_gc     = nelma_destroy_gc;
diff --git a/src/hid/png/png.c b/src/hid/png/png.c
index 39094fc..29e6798 100644
--- a/src/hid/png/png.c
+++ b/src/hid/png/png.c
@@ -43,6 +43,7 @@
 #include "hid.h"
 #include "../hidint.h"
 #include "hid/common/hidnogui.h"
+#include "draw_api.h"
 #include "hid/common/draw_helpers.h"
 #include "png.h"
 
@@ -650,7 +651,7 @@ png_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
 	}
     }
 
-  hid_expose_callback (&png_hid, bounds, 0);
+//  hid_expose_callback (&png_hid, bounds, 0);
 
   memcpy (LayerStack, saved_layer_stack, sizeof (LayerStack));
   PCB->Flags = save_flags;
@@ -1363,10 +1364,10 @@ png_use_mask (enum mask_mode mode)
   if (photo_mode)
     return;
 
-  if (mode == HID_MASK_CLEAR)
-    {
-      return;
-    }
+//  if (mode == HID_MASK_CLEAR)
+//    {
+//      return;
+//    }
   if (mode != HID_MASK_OFF)
     {
       if (mask_im == NULL)
@@ -1800,7 +1801,7 @@ hid_png_init ()
   memset (&png_graphics, 0, sizeof (HID_DRAW_API));
 
   common_nogui_init (&png_hid);
-  common_draw_helpers_init (&png_graphics);
+//  common_draw_helpers_init (&png_graphics);
 
   png_hid.struct_size = sizeof (HID);
   png_hid.name        = "png";
@@ -1815,7 +1816,7 @@ hid_png_init ()
   png_hid.calibrate           = png_calibrate;
   png_hid.set_crosshair       = png_set_crosshair;
 
-  png_hid.graphics            = &png_graphics;
+//  png_hid.graphics            = &png_graphics;
 
   png_graphics.make_gc        = png_make_gc;
   png_graphics.destroy_gc     = png_destroy_gc;
diff --git a/src/hid/ps/eps.c b/src/hid/ps/eps.c
index 1466051..13b6f04 100644
--- a/src/hid/ps/eps.c
+++ b/src/hid/ps/eps.c
@@ -16,6 +16,7 @@
 #include "hid.h"
 #include "../hidint.h"
 #include "hid/common/hidnogui.h"
+#include "draw_api.h"
 #include "hid/common/draw_helpers.h"
 #include "../ps/ps.h"
 #include "hid/common/hidinit.h"
@@ -309,7 +310,7 @@ eps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
   fprintf (f,
 	   "/a { gsave setlinewidth translate scale 0 0 1 5 3 roll arc stroke grestore} bind def\n");
 
-  hid_expose_callback (&eps_hid, bounds, 0);
+//  hid_expose_callback (&eps_hid, bounds, 0);
 
   fprintf (f, "showpage\n");
 
@@ -444,6 +445,7 @@ eps_destroy_gc (hidGC gc)
 static void
 eps_use_mask (enum mask_mode mode)
 {
+#if 0
   static int mask_pending = 0;
   switch (mode)
     {
@@ -466,6 +468,7 @@ eps_use_mask (enum mask_mode mode)
 	}
       break;
     }
+#endif
 }
 
 static void
@@ -663,7 +666,7 @@ hid_eps_init ()
   memset (&eps_graphics, 0, sizeof (HID_DRAW_API));
 
   common_nogui_init (&eps_hid);
-  common_draw_helpers_init (&eps_graphics);
+//  common_draw_helpers_init (&eps_graphics);
 
   eps_hid.struct_size         = sizeof (HID);
   eps_hid.name                = "eps";
@@ -678,7 +681,7 @@ hid_eps_init ()
   eps_hid.calibrate           = eps_calibrate;
   eps_hid.set_crosshair       = eps_set_crosshair;
 
-  eps_hid.graphics            = &eps_graphics;
+//  eps_hid.graphics            = &eps_graphics;
 
   eps_graphics.make_gc        = eps_make_gc;
   eps_graphics.destroy_gc     = eps_destroy_gc;
diff --git a/src/hid/ps/ps.c b/src/hid/ps/ps.c
index c1776de..ce0f08a 100644
--- a/src/hid/ps/ps.c
+++ b/src/hid/ps/ps.c
@@ -689,13 +689,13 @@ ps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
 
       global.doing_toc = 1;
       global.pagecount = 1;  /* 'pagecount' is modified by hid_expose_callback() call */
-      hid_expose_callback (&ps_hid, &global.region, 0);
+//      hid_expose_callback (&ps_hid, &global.region, 0);
     }
 
   global.pagecount = 1; /* Reset 'pagecount' if single file */
   global.doing_toc = 0;
   ps_set_layer (NULL, 0, -1);  /* reset static vars */
-  hid_expose_callback (&ps_hid, &global.region, 0);
+//  hid_expose_callback (&ps_hid, &global.region, 0);
 
   if (the_file)
     fprintf (the_file, "showpage\n");
@@ -1000,10 +1000,11 @@ ps_set_layer (const char *name, int group, int empty)
       global.outline_layer != NULL &&
       global.outline_layer != PCB->Data->Layer+idx &&
       strcmp (name, "outline") != 0 &&
-      strcmp (name, "route") != 0
-      )
+      strcmp (name, "route")   != 0)
     {
-      DrawLayer (global.outline_layer, &global.region);
+      DrawAPI *dapi = NULL;
+      dapi->set_clip_box (dapi, &global.region);
+      dapi->draw_pcb_layer (dapi, global.outline_layer);
     }
 
   return 1;
@@ -1510,7 +1511,7 @@ void ps_ps_graphics_init (HID_DRAW_API *graphics)
   graphics->fill_polygon       = ps_fill_polygon;
   graphics->fill_rect          = ps_fill_rect;
 
-  graphics->fill_pcb_polygon   = ps_fill_pcb_polygon;
+//  graphics->fill_pcb_polygon   = ps_fill_pcb_polygon;
 }
 
 void
@@ -1520,7 +1521,7 @@ hid_ps_init ()
   memset (&ps_graphics, 0, sizeof (HID_DRAW_API));
 
   common_nogui_init (&ps_hid);
-  common_draw_helpers_init (&ps_graphics);
+//  common_draw_helpers_init (&ps_graphics);
   ps_ps_init (&ps_hid);
   ps_ps_graphics_init (&ps_graphics);
 
@@ -1530,7 +1531,7 @@ hid_ps_init ()
   ps_hid.exporter           = 1;
   ps_hid.poly_before        = 1;
 
-  ps_hid.graphics           = &ps_graphics;
+//  ps_hid.graphics           = &ps_graphics;
 
   hid_register_hid (&ps_hid);
 
diff --git a/src/outline_draw.c b/src/outline_draw.c
index e8731a0..ed46508 100644
--- a/src/outline_draw.c
+++ b/src/outline_draw.c
@@ -121,6 +121,13 @@ outline_draw_pcb_arc (DrawAPI *dapi, LayerType *layer, ArcType *arc)
                               arc->Width, arc->Height, arc->StartAngle, arc->Delta);
 }
 
+static void
+outline_draw_pcb_text (DrawAPI *dapi, LayerType *layer, TextType *text, Coord min_width)
+{
+  BoxType *box = &text->BoundingBox;
+  dapi->graphics->draw_rect (dapi->gc, box->X1, box->Y1, box->X2, box->Y2);
+}
+
 /* ---------------------------------------------------------------------------
  * draws the elements of a loaded circuit which is to be merged in
  */
@@ -207,7 +214,7 @@ outline_draw_pcb_buffer (DrawAPI *dapi, BufferType *Buffer)
         END_LOOP;
         TEXT_LOOP (layer);
         {
-          dapi->draw_pcb_text (dapi, layer, text);
+          dapi->draw_pcb_text (dapi, layer, text, 0);
         }
         END_LOOP;
         POLYGON_LOOP (layer);
@@ -239,6 +246,7 @@ outline_draw_pcb_buffer (DrawAPI *dapi, BufferType *Buffer)
     }
 }
 
+#if 0
 static void
 outline_draw_pcb_pv (DrawAPI *dapi, PinType *pin)
 {
@@ -256,6 +264,7 @@ outline_draw_pcb_pad (DrawAPI *dapi, LayerType *layer, PadType *pad)
 {
   dapi->graphics->thindraw_pcb_pad (dapi->gc, pad, false, false);
 }
+#endif
 
 DrawAPI *outline_draw_new (HID_DRAW_API *graphics)
 {
@@ -264,17 +273,18 @@ DrawAPI *outline_draw_new (HID_DRAW_API *graphics)
   dapi = g_new0 (DrawAPI, 1);
   dapi->graphics = graphics;
 
-  dapi->draw_pcb_pin          = outline_draw_pcb_pv;
-  dapi->draw_pcb_pin_mask     = outline_draw_pcb_pv_mask;
+  dapi->draw_pcb_pin          = NULL; //outline_draw_pcb_pv;
+  dapi->draw_pcb_pin_mask     = NULL; //outline_draw_pcb_pv_mask;
   dapi->draw_pcb_pin_hole     = NULL;
-  dapi->draw_pcb_via          = outline_draw_pcb_pv;
-  dapi->draw_pcb_via_mask     = outline_draw_pcb_pv_mask;
+  dapi->draw_pcb_via          = NULL; //outline_draw_pcb_pv;
+  dapi->draw_pcb_via_mask     = NULL; //outline_draw_pcb_pv_mask;
   dapi->draw_pcb_via_hole     = NULL;
-  dapi->draw_pcb_pad          = outline_draw_pcb_pad;
+  dapi->draw_pcb_pad          = NULL; //outline_draw_pcb_pad;
   dapi->draw_pcb_pad_mask     = NULL;
   dapi->draw_pcb_pad_paste    = NULL;
   dapi->draw_pcb_line         = outline_draw_pcb_line;
   dapi->draw_pcb_arc          = outline_draw_pcb_arc;
+  dapi->draw_pcb_text         = outline_draw_pcb_text;
   dapi->draw_pcb_polygon      = outline_draw_pcb_polygon;
 
   dapi->draw_pcb_element      = outline_draw_pcb_element;
diff --git a/src/print.c b/src/print.c
index 27e1c98..5871849 100644
--- a/src/print.c
+++ b/src/print.c
@@ -73,22 +73,9 @@
 #define DRILL_MARK_SIZE	MIL_TO_COORD(16)
 #define FAB_LINE_W      MIL_TO_COORD(8)
 
-static void
-fab_line (hidGC gc, int x1, int y1, int x2, int y2)
-{
-  gui->graphics->draw_line (gc, x1, y1, x2, y2);
-}
-
-static void
-fab_circle (hidGC gc, int x, int y, int r)
-{
-  gui->graphics->draw_arc (gc, x, y, r, r, 0, 180);
-  gui->graphics->draw_arc (gc, x, y, r, r, 180, 180);
-}
-
 /* align is 0=left, 1=center, 2=right, add 8 for underline */
 static void
-text_at (hidGC gc, int x, int y, int align, char *fmt, ...)
+text_at (DrawAPI *dapi, int x, int y, int align, char *fmt, ...)
 {
   char tmp[512];
   int w = 0, i;
@@ -111,17 +98,15 @@ text_at (hidGC gc, int x, int y, int align, char *fmt, ...)
   t.X -= w * (align & 3) / 2;
   if (t.X < 0)
     t.X = 0;
-  DrawTextLowLevel (gc, &t, 0);
+  dapi->draw_pcb_text (dapi, NULL, &t, 0);
   if (align & 8)
-    fab_line (gc, t.X,
-              t.Y + SCALE_TEXT (font->MaxHeight, t.Scale) + MIL_TO_COORD(10),
-              t.X + w,
-              t.Y + SCALE_TEXT (font->MaxHeight, t.Scale) + MIL_TO_COORD(10));
+    dapi->graphics->draw_line (dapi->gc, t.X,     t.Y + SCALE_TEXT (font->MaxHeight, t.Scale) + MIL_TO_COORD(10),
+                                     t.X + w, t.Y + SCALE_TEXT (font->MaxHeight, t.Scale) + MIL_TO_COORD(10));
 }
 
 /* Y, +, X, circle, square */
 static void
-drill_sym (hidGC gc, int idx, int x, int y)
+drill_sym (DrawAPI *dapi, int idx, int x, int y)
 {
   int type = idx % 5;
   int size = idx / 5;
@@ -130,60 +115,61 @@ drill_sym (hidGC gc, int idx, int x, int y)
   switch (type)
     {
     case 0:			/* Y */ ;
-      fab_line (gc, x, y, x, y + s2);
-      fab_line (gc, x, y, x + s2 * 13 / 15, y - s2 / 2);
-      fab_line (gc, x, y, x - s2 * 13 / 15, y - s2 / 2);
+      dapi->graphics->draw_line (dapi->gc, x, y, x, y + s2);
+      dapi->graphics->draw_line (dapi->gc, x, y, x + s2 * 13 / 15, y - s2 / 2);
+      dapi->graphics->draw_line (dapi->gc, x, y, x - s2 * 13 / 15, y - s2 / 2);
       for (i = 1; i <= size; i++)
-        fab_circle (gc, x, y, i * DRILL_MARK_SIZE);
+        dapi->graphics->draw_arc (dapi->gc, x, y, i * DRILL_MARK_SIZE, i * DRILL_MARK_SIZE, 0, 360);
       break;
     case 1:			/* + */
       ;
-      fab_line (gc, x, y - s2, x, y + s2);
-      fab_line (gc, x - s2, y, x + s2, y);
+      dapi->graphics->draw_line (dapi->gc, x, y - s2, x, y + s2);
+      dapi->graphics->draw_line (dapi->gc, x - s2, y, x + s2, y);
       for (i = 1; i <= size; i++)
         {
-          fab_line (gc, x - i * DRILL_MARK_SIZE, y - i * DRILL_MARK_SIZE,
-                        x + i * DRILL_MARK_SIZE, y - i * DRILL_MARK_SIZE);
-          fab_line (gc, x - i * DRILL_MARK_SIZE, y - i * DRILL_MARK_SIZE,
-                        x - i * DRILL_MARK_SIZE, y + i * DRILL_MARK_SIZE);
-          fab_line (gc, x - i * DRILL_MARK_SIZE, y + i * DRILL_MARK_SIZE,
-                        x + i * DRILL_MARK_SIZE, y + i * DRILL_MARK_SIZE);
-          fab_line (gc, x + i * DRILL_MARK_SIZE, y - i * DRILL_MARK_SIZE,
-                        x + i * DRILL_MARK_SIZE, y + i * DRILL_MARK_SIZE);
+          dapi->graphics->draw_line (dapi->gc, x - i * DRILL_MARK_SIZE, y - i * DRILL_MARK_SIZE,
+                                           x + i * DRILL_MARK_SIZE, y - i * DRILL_MARK_SIZE);
+          dapi->graphics->draw_line (dapi->gc, x - i * DRILL_MARK_SIZE, y - i * DRILL_MARK_SIZE,
+                                           x - i * DRILL_MARK_SIZE, y + i * DRILL_MARK_SIZE);
+          dapi->graphics->draw_line (dapi->gc, x - i * DRILL_MARK_SIZE, y + i * DRILL_MARK_SIZE,
+                                           x + i * DRILL_MARK_SIZE, y + i * DRILL_MARK_SIZE);
+          dapi->graphics->draw_line (dapi->gc, x + i * DRILL_MARK_SIZE, y - i * DRILL_MARK_SIZE,
+                                           x + i * DRILL_MARK_SIZE, y + i * DRILL_MARK_SIZE);
         }
       break;
     case 2:			/* X */ ;
-      fab_line (gc, x - s2 * 3 / 4, y - s2 * 3 / 4, x + s2 * 3 / 4,
-		y + s2 * 3 / 4);
-      fab_line (gc, x - s2 * 3 / 4, y + s2 * 3 / 4, x + s2 * 3 / 4,
-		y - s2 * 3 / 4);
+      dapi->graphics->draw_line (dapi->gc, x - s2 * 3 / 4, y - s2 * 3 / 4,
+                                       x + s2 * 3 / 4, y + s2 * 3 / 4);
+      dapi->graphics->draw_line (dapi->gc, x - s2 * 3 / 4, y + s2 * 3 / 4,
+                                       x + s2 * 3 / 4, y - s2 * 3 / 4);
       for (i = 1; i <= size; i++)
         {
-          fab_line (gc, x - i * DRILL_MARK_SIZE, y - i * DRILL_MARK_SIZE,
-                        x + i * DRILL_MARK_SIZE, y - i * DRILL_MARK_SIZE);
-          fab_line (gc, x - i * DRILL_MARK_SIZE, y - i * DRILL_MARK_SIZE,
-                        x - i * DRILL_MARK_SIZE, y + i * DRILL_MARK_SIZE);
-          fab_line (gc, x - i * DRILL_MARK_SIZE, y + i * DRILL_MARK_SIZE,
-                        x + i * DRILL_MARK_SIZE, y + i * DRILL_MARK_SIZE);
-          fab_line (gc, x + i * DRILL_MARK_SIZE, y - i * DRILL_MARK_SIZE,
-                        x + i * DRILL_MARK_SIZE, y + i * DRILL_MARK_SIZE);
+          dapi->graphics->draw_line (dapi->gc, x - i * DRILL_MARK_SIZE, y - i * DRILL_MARK_SIZE,
+                                           x + i * DRILL_MARK_SIZE, y - i * DRILL_MARK_SIZE);
+          dapi->graphics->draw_line (dapi->gc, x - i * DRILL_MARK_SIZE, y - i * DRILL_MARK_SIZE,
+                                           x - i * DRILL_MARK_SIZE, y + i * DRILL_MARK_SIZE);
+          dapi->graphics->draw_line (dapi->gc, x - i * DRILL_MARK_SIZE, y + i * DRILL_MARK_SIZE,
+                                           x + i * DRILL_MARK_SIZE, y + i * DRILL_MARK_SIZE);
+          dapi->graphics->draw_line (dapi->gc, x + i * DRILL_MARK_SIZE, y - i * DRILL_MARK_SIZE,
+                                           x + i * DRILL_MARK_SIZE, y + i * DRILL_MARK_SIZE);
         }
       break;
     case 3:			/* circle */ ;
       for (i = 0; i <= size; i++)
-        fab_circle (gc, x, y, (i + 1) * DRILL_MARK_SIZE - DRILL_MARK_SIZE / 2);
+        dapi->graphics->draw_arc (dapi->gc, x, y, (i + 1) * DRILL_MARK_SIZE - DRILL_MARK_SIZE / 2,
+                                              (i + 1) * DRILL_MARK_SIZE - DRILL_MARK_SIZE / 2, 0, 360);
       break;
     case 4:			/* square */
       for (i = 1; i <= size + 1; i++)
         {
-          fab_line (gc, x - i * DRILL_MARK_SIZE, y - i * DRILL_MARK_SIZE,
-                        x + i * DRILL_MARK_SIZE, y - i * DRILL_MARK_SIZE);
-          fab_line (gc, x - i * DRILL_MARK_SIZE, y - i * DRILL_MARK_SIZE,
-                        x - i * DRILL_MARK_SIZE, y + i * DRILL_MARK_SIZE);
-          fab_line (gc, x - i * DRILL_MARK_SIZE, y + i * DRILL_MARK_SIZE,
-                        x + i * DRILL_MARK_SIZE, y + i * DRILL_MARK_SIZE);
-          fab_line (gc, x + i * DRILL_MARK_SIZE, y - i * DRILL_MARK_SIZE,
-                        x + i * DRILL_MARK_SIZE, y + i * DRILL_MARK_SIZE);
+          dapi->graphics->draw_line (dapi->gc, x - i * DRILL_MARK_SIZE, y - i * DRILL_MARK_SIZE,
+                                           x + i * DRILL_MARK_SIZE, y - i * DRILL_MARK_SIZE);
+          dapi->graphics->draw_line (dapi->gc, x - i * DRILL_MARK_SIZE, y - i * DRILL_MARK_SIZE,
+                                           x - i * DRILL_MARK_SIZE, y + i * DRILL_MARK_SIZE);
+          dapi->graphics->draw_line (dapi->gc, x - i * DRILL_MARK_SIZE, y + i * DRILL_MARK_SIZE,
+                                           x + i * DRILL_MARK_SIZE, y + i * DRILL_MARK_SIZE);
+          dapi->graphics->draw_line (dapi->gc, x + i * DRILL_MARK_SIZE, y - i * DRILL_MARK_SIZE,
+                                           x + i * DRILL_MARK_SIZE, y + i * DRILL_MARK_SIZE);
         }
       break;
     }
@@ -216,7 +202,7 @@ PrintFab_overhang (void)
 }
 
 void
-PrintFab (hidGC gc)
+PrintFab (DrawAPI *dapi)
 {
   DrillInfoType *AllDrills;
   int i, n, yoff, total_drills = 0, ds = 0;
@@ -239,7 +225,7 @@ PrintFab (hidGC gc)
       yoff -= (4 - ds) * TEXT_LINE;
     }
 
-  gui->graphics->set_line_width (gc, FAB_LINE_W);
+  dapi->graphics->set_line_width (dapi->gc, FAB_LINE_W);
 
   for (n = AllDrills->DrillN - 1; n >= 0; n--)
     {
@@ -249,16 +235,16 @@ PrintFab (hidGC gc)
 	plated_sym = --ds;
       if (drill->UnplatedCount)
 	unplated_sym = --ds;
-      gui->graphics->set_color (gc, PCB->PinColor);
+      dapi->graphics->set_color (dapi->gc, PCB->PinColor);
       for (i = 0; i < drill->PinN; i++)
-	drill_sym (gc, TEST_FLAG (HOLEFLAG, drill->Pin[i]) ?
+	drill_sym (dapi, TEST_FLAG (HOLEFLAG, drill->Pin[i]) ?
 		   unplated_sym : plated_sym, drill->Pin[i]->X,
 		   drill->Pin[i]->Y);
       if (plated_sym != -1)
 	{
-	  drill_sym (gc, plated_sym, TEXT_SIZE, yoff + TEXT_SIZE / 4);
-	  text_at (gc, MIL_TO_COORD(1350), yoff, MIL_TO_COORD(2), "YES");
-	  text_at (gc, MIL_TO_COORD(980), yoff, MIL_TO_COORD(2), "%d",
+	  drill_sym (dapi, plated_sym, TEXT_SIZE, yoff + TEXT_SIZE / 4);
+	  text_at (dapi, MIL_TO_COORD(1350), yoff, MIL_TO_COORD(2), "YES");
+	  text_at (dapi, MIL_TO_COORD(980), yoff, MIL_TO_COORD(2), "%d",
 		   drill->PinCount + drill->ViaCount - drill->UnplatedCount);
 
 	  if (unplated_sym != -1)
@@ -266,28 +252,28 @@ PrintFab (hidGC gc)
 	}
       if (unplated_sym != -1)
 	{
-	  drill_sym (gc, unplated_sym, TEXT_SIZE, yoff + TEXT_SIZE / 4);
-	  text_at (gc, MIL_TO_COORD(1400), yoff, MIL_TO_COORD(2), "NO");
-	  text_at (gc, MIL_TO_COORD(980), yoff, MIL_TO_COORD(2), "%d", drill->UnplatedCount);
+	  drill_sym (dapi, unplated_sym, TEXT_SIZE, yoff + TEXT_SIZE / 4);
+	  text_at (dapi, MIL_TO_COORD(1400), yoff, MIL_TO_COORD(2), "NO");
+	  text_at (dapi, MIL_TO_COORD(980), yoff, MIL_TO_COORD(2), "%d", drill->UnplatedCount);
 	}
-      gui->graphics->set_color (gc, PCB->ElementColor);
-      text_at (gc, MIL_TO_COORD(450), yoff, MIL_TO_COORD(2), "%0.3f",
+      dapi->graphics->set_color (dapi->gc, PCB->ElementColor);
+      text_at (dapi, MIL_TO_COORD(450), yoff, MIL_TO_COORD(2), "%0.3f",
 	       COORD_TO_INCH(drill->DrillSize) + 0.0004);
       if (plated_sym != -1 && unplated_sym != -1)
-	text_at (gc, MIL_TO_COORD(450), yoff + TEXT_LINE, MIL_TO_COORD(2), "%0.3f",
+	text_at (dapi, MIL_TO_COORD(450), yoff + TEXT_LINE, MIL_TO_COORD(2), "%0.3f",
 	         COORD_TO_INCH(drill->DrillSize) + 0.0004);
       yoff -= TEXT_LINE;
       total_drills += drill->PinCount;
       total_drills += drill->ViaCount;
     }
 
-  gui->graphics->set_color (gc, PCB->ElementColor);
-  text_at (gc, 0, yoff, MIL_TO_COORD(9), "Symbol");
-  text_at (gc, MIL_TO_COORD(410), yoff, MIL_TO_COORD(9), "Diam. (Inch)");
-  text_at (gc, MIL_TO_COORD(950), yoff, MIL_TO_COORD(9), "Count");
-  text_at (gc, MIL_TO_COORD(1300), yoff, MIL_TO_COORD(9), "Plated?");
+  dapi->graphics->set_color (dapi->gc, PCB->ElementColor);
+  text_at (dapi, 0, yoff, MIL_TO_COORD(9), "Symbol");
+  text_at (dapi, MIL_TO_COORD(410), yoff, MIL_TO_COORD(9), "Diam. (Inch)");
+  text_at (dapi, MIL_TO_COORD(950), yoff, MIL_TO_COORD(9), "Count");
+  text_at (dapi, MIL_TO_COORD(1300), yoff, MIL_TO_COORD(9), "Plated?");
   yoff -= TEXT_LINE;
-  text_at (gc, 0, yoff, 0,
+  text_at (dapi, 0, yoff, 0,
 	   "There are %d different drill sizes used in this layout, %d holes total",
 	   AllDrills->DrillN, total_drills);
   /* Create a portable timestamp. */
@@ -311,19 +297,17 @@ PrintFab (hidGC gc)
     }
   if (i == max_copper_layer)
     {
-      gui->graphics->set_line_width (gc,  MIL_TO_COORD(10));
-      gui->graphics->draw_line (gc, 0, 0, PCB->MaxWidth, 0);
-      gui->graphics->draw_line (gc, 0, 0, 0, PCB->MaxHeight);
-      gui->graphics->draw_line (gc, PCB->MaxWidth, 0, PCB->MaxWidth,
-		      PCB->MaxHeight);
-      gui->graphics->draw_line (gc, 0, PCB->MaxHeight, PCB->MaxWidth,
-		      PCB->MaxHeight);
+      dapi->graphics->set_line_width (dapi->gc,  MIL_TO_COORD(10));
+      dapi->graphics->draw_line (dapi->gc, 0, 0, PCB->MaxWidth, 0);
+      dapi->graphics->draw_line (dapi->gc, 0, 0, 0, PCB->MaxHeight);
+      dapi->graphics->draw_line (dapi->gc, PCB->MaxWidth, 0, PCB->MaxWidth, PCB->MaxHeight);
+      dapi->graphics->draw_line (dapi->gc, 0, PCB->MaxHeight, PCB->MaxWidth, PCB->MaxHeight);
       /*FPrintOutline (); */
-      gui->graphics->set_line_width (gc, FAB_LINE_W);
-      text_at (gc, MIL_TO_COORD(2000), yoff, 0,
+      dapi->graphics->set_line_width (dapi->gc, FAB_LINE_W);
+      text_at (dapi, MIL_TO_COORD(2000), yoff, 0,
 	       "Maximum Dimensions: %f mils wide, %f mils high",
 	       COORD_TO_MIL(PCB->MaxWidth), COORD_TO_MIL(PCB->MaxHeight));
-      text_at (gc, PCB->MaxWidth / 2, PCB->MaxHeight + MIL_TO_COORD(20), 1,
+      text_at (dapi, PCB->MaxWidth / 2, PCB->MaxHeight + MIL_TO_COORD(20), 1,
 	       "Board outline is the centerline of this %f mil"
 	       " rectangle - 0,0 to %f,%f mils",
 	       COORD_TO_MIL(FAB_LINE_W), COORD_TO_MIL(PCB->MaxWidth), COORD_TO_MIL(PCB->MaxHeight));
@@ -331,33 +315,34 @@ PrintFab (hidGC gc)
   else
     {
       LayerType *layer = LAYER_PTR (i);
-      gui->graphics->set_line_width (gc, MIL_TO_COORD(10));
+      dapi->graphics->set_line_width (dapi->gc, MIL_TO_COORD(10));
       LINE_LOOP (layer);
       {
-	gui->graphics->draw_line (gc, line->Point1.X, line->Point1.Y,
-			line->Point2.X, line->Point2.Y);
+        // dapi->draw_pcb_line (dapi, layer, line);
+        dapi->graphics->draw_line (dapi->gc, line->Point1.X, line->Point1.Y, line->Point2.X, line->Point2.Y);
       }
       END_LOOP;
       ARC_LOOP (layer);
       {
-	gui->graphics->draw_arc (gc, arc->X, arc->Y, arc->Width,
-		       arc->Height, arc->StartAngle, arc->Delta);
+        // dapi->draw_pcb_arc (dapi, layer, arc);
+        dapi->graphics->draw_arc (dapi->gc, arc->X, arc->Y,
+                                  arc->Width, arc->Height, arc->StartAngle, arc->Delta);
       }
       END_LOOP;
       TEXT_LOOP (layer);
       {
-	DrawTextLowLevel (gc, text, 0);
+        dapi->draw_pcb_text (dapi, layer, text, 0);
       }
       END_LOOP;
-      gui->graphics->set_line_width (gc, FAB_LINE_W);
-      text_at (gc, PCB->MaxWidth / 2, PCB->MaxHeight + MIL_TO_COORD(20), 1,
+      dapi->graphics->set_line_width (dapi->gc, FAB_LINE_W);
+      text_at (dapi, PCB->MaxWidth / 2, PCB->MaxHeight + MIL_TO_COORD(20), 1,
 	       "Board outline is the centerline of this path");
     }
   yoff -= TEXT_LINE;
-  text_at (gc, MIL_TO_COORD(2000), yoff, 0, "Date: %s", utcTime);
+  text_at (dapi, MIL_TO_COORD(2000), yoff, 0, "Date: %s", utcTime);
   yoff -= TEXT_LINE;
-  text_at (gc, MIL_TO_COORD(2000), yoff, 0, "Author: %s", pcb_author ());
+  text_at (dapi, MIL_TO_COORD(2000), yoff, 0, "Author: %s", pcb_author ());
   yoff -= TEXT_LINE;
-  text_at (gc, MIL_TO_COORD(2000), yoff, 0,
+  text_at (dapi, MIL_TO_COORD(2000), yoff, 0,
 	   "Title: %s - Fabrication Drawing", UNKNOWN (PCB->Name));
 }
diff --git a/src/print.h b/src/print.h
index 85943f3..9f6361e 100644
--- a/src/print.h
+++ b/src/print.h
@@ -35,6 +35,6 @@
 #include "global.h"
 
 int PrintFab_overhang(void);
-void PrintFab (hidGC gc);
+void PrintFab (DrawAPI *dapi);
 
 #endif

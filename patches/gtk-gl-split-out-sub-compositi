Bottom: 9e06ada3d04d8b8e361e5e036839e51c95183196
Top:    04fe6dea19880b1b9c863cf66659a7a84dcae1ac
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-05-09 07:35:11 +0100

GTK/GL: Split out sub-compositing setup into a separate function.


---

diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 3c12833..8af8a03 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -60,12 +60,47 @@ typedef struct hid_gc_struct
 }
 hid_gc_struct;
 
+static void
+start_subcomposite (void)
+{
+  render_priv *priv = gport->render_priv;
+  int stencil_bit;
+
+  /* Flush out any existing geoemtry to be rendered */
+  hidgl_flush_triangles (&buffer);
+
+  glEnable (GL_STENCIL_TEST);                                 /* Enable Stencil test */
+  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);                 /* Stencil pass => replace stencil value (with 1) */
+
+  stencil_bit = hidgl_assign_clear_stencil_bit();             /* Get a new (clean) bitplane to stencil with */
+  glStencilMask (stencil_bit);                                /* Only write to our subcompositing stencil bitplane */
+  glStencilFunc (GL_GREATER, stencil_bit, stencil_bit);       /* Pass stencil test if our assigned bit is clear */
+
+  priv->subcomposite_stencil_bit = stencil_bit;
+}
+
+static void
+end_subcomposite (void)
+{
+  render_priv *priv = gport->render_priv;
+
+  /* Flush out any existing geoemtry to be rendered */
+  hidgl_flush_triangles (&buffer);
+
+  hidgl_return_stencil_bit (priv->subcomposite_stencil_bit);  /* Relinquish any bitplane we previously used */
+
+  glStencilMask (0);
+  glStencilFunc (GL_ALWAYS, 0, 0);                            /* Always pass stencil test */
+  glDisable (GL_STENCIL_TEST);                                /* Disable Stencil test */
+
+  priv->subcomposite_stencil_bit = 0;
+}
+
 
 int
 ghid_set_layer (const char *name, int group, int empty)
 {
   render_priv *priv = gport->render_priv;
-  int stencil_bit;
   int idx = group;
   if (idx >= 0 && idx < max_group)
     {
@@ -78,19 +113,10 @@ ghid_set_layer (const char *name, int group, int empty)
 	    break;
 	}
       idx = PCB->LayerGroups.Entries[group][idx];
-    }
-
-  /* Flush out any existing geoemtry to be rendered */
-  hidgl_flush_triangles (&buffer);
+  }
 
-  glEnable (GL_STENCIL_TEST);                                 /* Enable Stencil test */
-  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);                 /* Stencil pass => replace stencil value (with 1) */
-
-  hidgl_return_stencil_bit (priv->subcomposite_stencil_bit);  /* Relinquish any bitplane we previously used */
-  stencil_bit = hidgl_assign_clear_stencil_bit();             /* Get a new (clean) bitplane to stencil with */
-  glStencilFunc (GL_GREATER, stencil_bit, stencil_bit);       /* Pass stencil test if our assigned bit is clear */
-  glStencilMask (stencil_bit);                                /* Only write to our subcompositing stencil bitplane */
-  priv->subcomposite_stencil_bit = stencil_bit;
+  end_subcomposite ();
+  start_subcomposite ();
 
   if (idx >= 0 && idx < max_copper_layer + 2)
     {
@@ -129,18 +155,7 @@ ghid_set_layer (const char *name, int group, int empty)
 static void
 ghid_end_layer (void)
 {
-  render_priv *priv = gport->render_priv;
-
-  /* Flush out any existing geoemtry to be rendered */
-  hidgl_flush_triangles (&buffer);
-
-  /* Relinquish any bitplane we previously used */
-  hidgl_return_stencil_bit (priv->subcomposite_stencil_bit);
-  priv->subcomposite_stencil_bit = 0;
-
-  /* Always pass stencil test */
-  glStencilMask (0);
-  glStencilFunc (GL_ALWAYS, 0, 0);
+  end_subcomposite ();
 }
 
 void

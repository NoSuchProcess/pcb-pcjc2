Bottom: dbb67b88b5e3b5475f675431ebb034fd4d9fe6f6
Top:    493062a453bfbb6662f1cd280a6bebf092c4ead4
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-10-24 19:02:21 +0100

polygon1.c: Avoid re-starting the intersection routine for each new node

This seems to have a nice performance win for the NoHoles dicer, which
may have suffered due to other polygon changes.

Rather than inserting nodes when we find intersections in seg_in_seg(),
(which requires an immediate restart of the intersection search), build
a queue of deferred work to be executed at the end of each iteration.

A new search iteration is forced immediately if the seg_in_seg rountine
finds an intersection with a segment which already has deferred work
queued. The segment will be removed and split by the deferred node
insersion so futher intersection processing must be after that task.

Once a contour has enountered an intersection on one of its segments,
we skip that contour for the rest of the search iteration. This avoids
spending too much effort searching for things we are likely to skip
until the next iteration.

Whenever an ineration finishes and nodes are added by deferred work,
another iteration of the intersection loop is required. Processing
stops after an iteration when no new nodes are added



---

diff --git a/src/polygon1.c b/src/polygon1.c
index 1127fbd..6333474 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -46,6 +46,8 @@
 #include	<math.h>
 #include	<string.h>
 
+#include <glib.h>
+
 #include "global.h"
 #include "rtree.h"
 #include "heap.h"
@@ -180,26 +182,20 @@ node_add
  4 means the intersection was not on the dest point
 */
 static VNODE *
-node_add (VNODE * dest, Vector po, int *new_point)
+node_add_single (VNODE * dest, Vector po)
 {
   VNODE *p;
 
   if (vect_equal (po, dest->point))
     return dest;
   if (vect_equal (po, dest->next->point))
-    {
-      (*new_point) += 4;
-      return dest->next;
-    }
+    return dest->next;
   p = poly_CreateNode (po);
   if (p == NULL)
     return NULL;
-  (*new_point) += 5;
-  p->prev = dest;
-  p->next = dest->next;
   p->cvc_prev = p->cvc_next = NULL;
   p->Flags.status = UNKNWN;
-  return (dest->next = dest->next->prev = p);
+  return p;
 }				/* node_add */
 
 #define ISECT_BAD_PARAM (-1)
@@ -362,22 +358,22 @@ node_add_point
  return 1 if new node in b, 2 if new node in a and 3 if new node in both
 */
 
-static int
-node_add_point (VNODE * a, VNODE * b, Vector p)
+static VNODE *
+node_add_single_point (VNODE * a, Vector p)
 {
-  int res = 0;
+  VNODE *next_a, *new_node;
 
-  VNODE *node_a, *node_b;
+  next_a = a->next;
 
-  node_a = node_add (a, p, &res);
-  res += res;
-  node_b = node_add (b, p, &res);
+  new_node = node_add_single (a, p);
+  assert (new_node != NULL);
 
-  if (node_a == NULL || node_b == NULL)
-    return ISECT_NO_MEMORY;
-  node_b->cvc_prev = node_b->cvc_next = (CVCList *) - 1;
-  node_a->cvc_prev = node_a->cvc_next = (CVCList *) - 1;
-  return res;
+  new_node->cvc_prev = new_node->cvc_next = (CVCList *) - 1;
+
+  if (new_node == a || new_node == next_a)
+    return NULL;
+
+  return new_node;
 }				/* node_add_point */
 
 /*
@@ -501,8 +497,16 @@ typedef struct seg
   BoxType box;
   VNODE *v;
   PLINE *p;
+  int intersected;
 } seg;
 
+typedef struct insert_task
+{
+  VNODE *new_node;
+  seg *seg;
+
+} insert_task;
+
 typedef struct info
 {
   double m, b;
@@ -510,6 +514,8 @@ typedef struct info
   VNODE *v;
   struct seg *s;
   jmp_buf *env, sego, *touch;
+  int need_restart;
+  GList *node_insert_list;
 } info;
 
 typedef struct contour_info
@@ -517,6 +523,8 @@ typedef struct contour_info
   PLINE *pa;
   jmp_buf restart;
   jmp_buf *getout;
+  int need_restart;
+  GList *node_insert_list;
 } contour_info;
 
 
@@ -534,6 +542,7 @@ adjust_tree (rtree_t * tree, struct seg *s)
   q = malloc (sizeof (struct seg));
   if (!q)
     return 1;
+  q->intersected = 0;
   q->v = s->v;
   q->p = s->p;
   q->box.X1 = min (q->v->point[0], q->v->next->point[0]);
@@ -544,6 +553,7 @@ adjust_tree (rtree_t * tree, struct seg *s)
   q = malloc (sizeof (struct seg));
   if (!q)
     return 1;
+  q->intersected = 0;
   q->v = s->v->next;
   q->p = s->p;
   q->box.X1 = min (q->v->point[0], q->v->next->point[0]);
@@ -594,7 +604,14 @@ seg_in_seg (const BoxType * b, void *cl)
   struct info *i = (struct info *) cl;
   struct seg *s = (struct seg *) b;
   Vector s1, s2;
-  int cnt, res;
+  int cnt;
+  VNODE *new_node;
+
+  if (s->intersected || i->s->intersected)
+    {
+      i->need_restart = 1;
+      return 0;
+    }
 
   cnt = vect_inters2 (s->v->point, s->v->next->point,
 		      i->v->point, i->v->next->point, s1, s2);
@@ -606,30 +623,32 @@ seg_in_seg (const BoxType * b, void *cl)
   s->p->Flags.status = ISECTED;
   for (; cnt; cnt--)
     {
-      res = node_add_point (i->v, s->v, cnt > 1 ? s2 : s1);
-      if (res < 0)
-	return 1;		/* error */
-      /* adjust the bounding box and tree if necessary */
-      if (res & 2)
+      int done_insert = 0;
+      new_node = node_add_single_point (i->v, cnt > 1 ? s2 : s1);
+      if (new_node != NULL)
 	{
-	  cntrbox_adjust (i->s->p, cnt > 1 ? s2 : s1);
-	  if (adjust_tree (i->s->p->tree, i->s))
-	    return 1;
+	  insert_task *task = g_new0 (insert_task, 1);
+	  task->new_node = new_node;
+	  task->seg = i->s;
+	  task->seg->intersected = 1;
+	  i->node_insert_list = g_list_prepend (i->node_insert_list, task);
+	  done_insert = 1;
 	}
-      /* if we added a node in the tree we need to change the tree */
-      if (res & 1)
+      new_node = node_add_single_point (s->v, cnt > 1 ? s2 : s1);
+      if (new_node != NULL)
 	{
-	  cntrbox_adjust (s->p, cnt > 1 ? s2 : s1);
-	  if (adjust_tree (i->tree, s))
-	    return 1;
+	  insert_task *task = g_new0 (insert_task, 1);
+	  task->new_node = new_node;
+	  task->seg = s;
+	  task->seg->intersected = 1;
+	  i->node_insert_list = g_list_prepend (i->node_insert_list, task);
+	  return 0;		/* Don't do any more processing */
 	}
-      if (res & 3)		/* if a point was inserted start over */
+      if (done_insert)
 	{
-#ifdef DEBUG_INTERSECT
-	  DEBUGP ("new intersection at (%d, %d)\n", cnt > 1 ? s2[0] : s1[0],
-		  cnt > 1 ? s2[1] : s1[1]);
-#endif
-	  longjmp (*i->env, 1);
+	  longjmp (*i->env, 1);	/* Skip this contour if we intersected on i */
+	  i->need_restart = 1;	/* If we skip some processing, we definately need a restart */
+	  return 0;
 	}
     }
   return 0;
@@ -645,6 +664,7 @@ make_edge_tree (PLINE * pb)
   do
     {
       s = malloc (sizeof (struct seg));
+      s->intersected = 0;
       if (bv->point[0] < bv->next->point[0])
 	{
 	  s->box.X1 = bv->point[0];
@@ -715,10 +735,13 @@ contour_bounds_touch (const BoxType * b, void *cl)
   VNODE *av;			/* node iterators */
   struct info info;
   BoxType box;
+  jmp_buf restart;
 
   /* Have seg_in_seg return to our desired location if it touches */
-  info.env = &c_info->restart;
+  info.env = &restart;
   info.touch = c_info->getout;
+  info.need_restart = 0;
+  info.node_insert_list = c_info->node_insert_list;
 
   /* Pick which contour has the fewer points, and do the loop
    * over that. The r_tree makes hit-testing against a contour
@@ -760,23 +783,55 @@ contour_bounds_touch (const BoxType * b, void *cl)
 	  assert (0);
 	}
 
+      /* If we're going to have another pass anyway, skip this */
+      if (info.s->intersected && info.node_insert_list != NULL)
+	continue;
+
+      if (setjmp (restart))
+	continue;
+
       /* NB: If this actually hits anything, we are teleported back to the beginning */
       info.tree = rtree_over->tree;
       if (info.tree)
 	if (UNLIKELY (r_search (info.tree, &info.s->box,
 				seg_in_region, seg_in_seg, &info)))
-	  return err_no_memory;	/* error */
+	  assert (0); /* XXX: Memory allocation failure */
     }
   while ((av = av->next) != &looping_over->head);
+
+  c_info->node_insert_list = info.node_insert_list;
+  if (info.need_restart)
+    c_info->need_restart = 1;
   return 0;
 }
 
+static void
+insert_new_nodes_cb (gpointer data, gpointer userdata)
+{
+  insert_task *task = data;
+
+  /* Do insersion */
+  task->new_node->prev = task->seg->v;
+  task->new_node->next = task->seg->v->next;
+  task->seg->v->next->prev = task->new_node;
+  task->seg->v->next = task->new_node;
+  task->seg->p->Count++;
+
+  cntrbox_adjust (task->seg->p, task->new_node->point);
+  if (adjust_tree (task->seg->p->tree, task->seg))
+    assert (0); /* XXX: Memory allocation failure */
+  g_free (task);
+}
+
 static int
-intersect (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
+intersect_impl (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
 {
   POLYAREA *t;
   PLINE *pa;
   contour_info c_info;
+  int need_restart = 0;
+  c_info.need_restart = 0;
+  c_info.node_insert_list = NULL;
 
   /* Search the r-tree of the object with most contours
    * We loop over the contours of "a". Swap if necessary.
@@ -788,8 +843,6 @@ intersect (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
       a = t;
     }
 
-  setjmp (c_info.restart);	/* we loop back here whenever a vertex is inserted */
-
   for (pa = a->contours; pa; pa = pa->next)	/* Loop over the contours of POLYAREA "a" */
     {
       BoxType sb;
@@ -817,8 +870,24 @@ intersect (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
       sb.Y2 = pa->ymax + 1;
 
       r_search (b->contour_tree, &sb, NULL, contour_bounds_touch, &c_info);
+      if (c_info.need_restart)
+	need_restart = 1;
     }
 
+  if (c_info.node_insert_list != NULL)
+    need_restart = 1; /* Any new nodes could intersect */
+  g_list_foreach (c_info.node_insert_list, insert_new_nodes_cb, NULL);
+  g_list_free (c_info.node_insert_list);
+
+  return need_restart;
+}
+
+static int
+intersect (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
+{
+  int call_count = 1;
+  while (intersect_impl (jb, b, a, add))
+    call_count++;
   return 0;
 }

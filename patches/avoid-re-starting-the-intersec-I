Bottom: 74d9b97dad43186eb7ae67546a8d061fffc87f11
Top:    a7a4d704405587ab2550a23dca9483d54f50b99e
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-09-12 01:25:01 +0100

Avoid re-starting the intersection routine when we don't have to

Apparently this has a nice performance win for the NoHoles dicer.


---

diff --git a/src/polygon1.c b/src/polygon1.c
index 1a194b3..4a761d5 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -46,6 +46,8 @@
 #include	<math.h>
 #include	<string.h>
 
+#include <glib.h>
+
 #include "global.h"
 #include "rtree.h"
 #include "heap.h"
@@ -180,26 +182,26 @@ node_add
  4 means the intersection was not on the dest point
 */
 static VNODE *
-node_add (VNODE * dest, Vector po, int *new_point)
+node_add_single (VNODE * dest, Vector po)
 {
   VNODE *p;
 
   if (vect_equal (po, dest->point))
     return dest;
   if (vect_equal (po, dest->next->point))
-    {
-      (*new_point) += 4;
-      return dest->next;
-    }
+    return dest->next;
   p = poly_CreateNode (po);
   if (p == NULL)
     return NULL;
-  (*new_point) += 5;
+#if 0
   p->prev = dest;
   p->next = dest->next;
+  dest->next->prev = p;
+  dest->next = p;
+#endif
   p->cvc_prev = p->cvc_next = NULL;
   p->Flags.status = UNKNWN;
-  return (dest->next = dest->next->prev = p);
+  return p;
 }				/* node_add */
 
 #define ISECT_BAD_PARAM (-1)
@@ -362,22 +364,24 @@ node_add_point
  return 1 if new node in b, 2 if new node in a and 3 if new node in both
 */
 
-static int
-node_add_point (VNODE * a, VNODE * b, Vector p)
+static VNODE *
+node_add_single_point (VNODE * a, Vector p)
 {
-  int res = 0;
+  VNODE *next_a, *new_node;
 
-  VNODE *node_a, *node_b;
+  next_a = a->next;
 
-  node_a = node_add (a, p, &res);
-  res += res;
-  node_b = node_add (b, p, &res);
+  new_node = node_add_single (a, p);
 
-  if (node_a == NULL || node_b == NULL)
-    return ISECT_NO_MEMORY;
-  node_b->cvc_prev = node_b->cvc_next = (CVCList *) - 1;
-  node_a->cvc_prev = node_a->cvc_next = (CVCList *) - 1;
-  return res;
+  if (new_node == NULL)
+    exit (0);
+
+  new_node->cvc_prev = new_node->cvc_next = (CVCList *) - 1;
+
+  if (new_node == a || new_node == next_a)
+    return NULL;
+
+  return new_node;
 }				/* node_add_point */
 
 /*
@@ -501,8 +505,16 @@ typedef struct seg
   BoxType box;
   VNODE *v;
   PLINE *p;
+  int intersected;
 } seg;
 
+typedef struct insert_task
+{
+  VNODE *new_node;
+  seg *seg;
+
+} insert_task;
+
 typedef struct info
 {
   double m, b;
@@ -510,6 +522,8 @@ typedef struct info
   VNODE *v;
   struct seg *s;
   jmp_buf *env, sego, *touch;
+  int need_restart;
+  GList *node_insert_list;
 } info;
 
 typedef struct contour_info
@@ -517,6 +531,8 @@ typedef struct contour_info
   PLINE *pa;
   jmp_buf restart;
   jmp_buf *getout;
+  int need_restart;
+  GList *node_insert_list;
 } contour_info;
 
 
@@ -534,6 +550,7 @@ adjust_tree (rtree_t * tree, struct seg *s)
   q = malloc (sizeof (struct seg));
   if (!q)
     return 1;
+  q->intersected = 0;
   q->v = s->v;
   q->p = s->p;
   q->box.X1 = min (q->v->point[0], q->v->next->point[0]);
@@ -544,6 +561,7 @@ adjust_tree (rtree_t * tree, struct seg *s)
   q = malloc (sizeof (struct seg));
   if (!q)
     return 1;
+  q->intersected = 0;
   q->v = s->v->next;
   q->p = s->p;
   q->box.X1 = min (q->v->point[0], q->v->next->point[0]);
@@ -594,7 +612,18 @@ seg_in_seg (const BoxType * b, void *cl)
   struct info *i = (struct info *) cl;
   struct seg *s = (struct seg *) b;
   Vector s1, s2;
-  int cnt, res;
+  int cnt;
+  VNODE *new_node;
+
+//  printf ("Looking at intersection between %p(%i) and %p(%i)\n",
+//          s->v, s->v->Flags.intersected, i->v, i->v->Flags.intersected);
+
+  if (s->intersected || i->s->intersected)
+    {
+//    printf ("Need to restart intersection\n");
+      i->need_restart = 1;
+      return 0;
+    }
 
   cnt = vect_inters2 (s->v->point, s->v->next->point,
 		      i->v->point, i->v->next->point, s1, s2);
@@ -606,30 +635,37 @@ seg_in_seg (const BoxType * b, void *cl)
   s->p->Flags.status = ISECTED;
   for (; cnt; cnt--)
     {
-      res = node_add_point (i->v, s->v, cnt > 1 ? s2 : s1);
-      if (res < 0)
-	return 1;		/* error */
-      /* adjust the bounding box and tree if necessary */
-      if (res & 2)
+      int done_insert = 0;
+      new_node = node_add_single_point (i->v, cnt > 1 ? s2 : s1);
+      if (new_node != NULL)
 	{
-	  cntrbox_adjust (i->s->p, cnt > 1 ? s2 : s1);
-	  if (adjust_tree (i->s->p->tree, i->s))
-	    return 1;
+	  insert_task *task = g_new0 (insert_task, 1);
+	  task->new_node = new_node;
+	  task->seg = i->s;
+	  task->seg->intersected = 1;
+	  i->node_insert_list = g_list_prepend (i->node_insert_list, task);
+	  done_insert = 1;
 	}
-      /* if we added a node in the tree we need to change the tree */
-      if (res & 1)
+//      else
+//        printf (".");
+      new_node = node_add_single_point (s->v, cnt > 1 ? s2 : s1);
+      if (new_node != NULL)
 	{
-	  cntrbox_adjust (s->p, cnt > 1 ? s2 : s1);
-	  if (adjust_tree (i->tree, s))
-	    return 1;
+	  insert_task *task = g_new0 (insert_task, 1);
+	  task->new_node = new_node;
+	  task->seg = s;
+	  task->seg->intersected = 1;
+	  i->node_insert_list = g_list_prepend (i->node_insert_list, task);
+	  return 0;		/* Don't do any more processing */
 	}
-      if (res & 3)		/* if a point was inserted start over */
+//      else
+//        printf (":");
+      if (done_insert)
 	{
-#ifdef DEBUG_INTERSECT
-	  DEBUGP ("new intersection at (%d, %d)\n", cnt > 1 ? s2[0] : s1[0],
-		  cnt > 1 ? s2[1] : s1[1]);
-#endif
-	  longjmp (*i->env, 1);
+//        printf ("Long-jmping back, since we intersected on i\n");
+	  longjmp (*i->env, 1);	/* Skip this contour if we intersected on i */
+	  i->need_restart = 1;	/* If we skip some processing, we definately need a restart */
+	  return 0;
 	}
     }
   return 0;
@@ -645,6 +681,7 @@ make_edge_tree (PLINE * pb)
   do
     {
       s = malloc (sizeof (struct seg));
+      s->intersected = 0;
       if (bv->point[0] < bv->next->point[0])
 	{
 	  s->box.X1 = bv->point[0];
@@ -715,10 +752,14 @@ contour_bounds_touch (const BoxType * b, void *cl)
   VNODE *av;			/* node iterators */
   struct info info;
   BoxType box;
+  jmp_buf restart;
 
   /* Have seg_in_seg return to our desired location if it touches */
-  info.env = &c_info->restart;
+//  info.env = &c_info->restart;
+  info.env = &restart;
   info.touch = c_info->getout;
+  info.need_restart = 0;
+  info.node_insert_list = c_info->node_insert_list;
 
   /* Pick which contour has the fewer points, and do the loop
    * over that. The r_tree makes hit-testing against a contour
@@ -740,6 +781,17 @@ contour_bounds_touch (const BoxType * b, void *cl)
     {
       /* check this edge for any insertions */
       double dx;
+
+#if 0
+      /* We know we will just reject any intersections found until
+         the next pass anyway */
+      if (av->Flags.intersected)
+	{
+//        printf ("skip\n");
+	  continue;
+	}
+#endif
+
       info.v = av;
       /* compute the slant for region trimming */
       dx = av->next->point[0] - av->point[0];
@@ -760,23 +812,61 @@ contour_bounds_touch (const BoxType * b, void *cl)
 	  assert (0);
 	}
 
+      /* If we're going to have another pass anyway, skip this */
+      if (info.s->intersected && info.node_insert_list != NULL)
+	continue;
+
+      if (setjmp (restart))
+	continue;
+
       /* NB: If this actually hits anything, we are teleported back to the beginning */
       info.tree = rtree_over->tree;
       if (info.tree)
 	if (UNLIKELY (r_search (info.tree, &info.s->box,
 				seg_in_region, seg_in_seg, &info)))
-	  return err_no_memory;	/* error */
+	  exit (0);
+//            return err_no_memory;     /* error */
     }
   while ((av = av->next) != &looping_over->head);
+
+  c_info->node_insert_list = info.node_insert_list;
+  if (info.need_restart)
+    {
+//    printf ("info.needs_restart says we need to restart\n");
+      c_info->need_restart = 1;
+    }
   return 0;
 }
 
+static void
+insert_new_nodes_cb (gpointer data, gpointer userdata)
+{
+  insert_task *task = data;
+  /* Do insersion */
+  // task->new_node, inserted before task->parent into PLINE task->owner
+
+//  printf ("Seg affected: %p\n", task->seg);
+  task->new_node->prev = task->seg->v;
+  task->new_node->next = task->seg->v->next;
+  task->seg->v->next->prev = task->new_node;
+  task->seg->v->next = task->new_node;
+  task->seg->p->Count++;
+
+  cntrbox_adjust (task->seg->p, task->new_node->point);
+  if (adjust_tree (task->seg->p->tree, task->seg))
+    exit (0);
+  g_free (task);
+}
+
 static int
-intersect (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
+intersect_impl (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
 {
   POLYAREA *t;
   PLINE *pa;
   contour_info c_info;
+  int need_restart = 0;
+  c_info.need_restart = 0;
+  c_info.node_insert_list = NULL;
 
   /* Search the r-tree of the object with most contours
    * We loop over the contours of "a". Swap if necessary.
@@ -788,7 +878,7 @@ intersect (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
       a = t;
     }
 
-  setjmp (c_info.restart);	/* we loop back here whenever a vertex is inserted */
+//  setjmp (c_info.restart);            /* we loop back here whenever a vertex is inserted */
 
   for (pa = a->contours; pa; pa = pa->next)	/* Loop over the contours of POLYAREA "a" */
     {
@@ -817,8 +907,33 @@ intersect (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
       sb.Y2 = pa->ymax + 1;
 
       r_search (b->contour_tree, &sb, NULL, contour_bounds_touch, &c_info);
+      if (c_info.need_restart)
+	{
+	  need_restart = 1;
+//        printf ("contour_bounds_touch: need_restart\n");
+//        break;
+	}
+    }
+
+//  printf ("----\n");
+  if (c_info.node_insert_list != NULL)
+    {
+//    printf ("Processing %i new nodes\n", g_list_length (c_info.node_insert_list));
+      need_restart = 1;		/* Any new nodes could intersect */
     }
+  g_list_foreach (c_info.node_insert_list, insert_new_nodes_cb, NULL);
+  g_list_free (c_info.node_insert_list);
+//  printf ("====\n");
+
+  return need_restart;
+}
 
+static int
+intersect (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
+{
+  int call_count = 1;
+  while (intersect_impl (jb, b, a, add))
+    call_count++;
   return 0;
 }

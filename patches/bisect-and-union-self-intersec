Bottom: 8686948c34dc7ba936092edda8065411e8b5c1de
Top:    0db5f1df5625b92540dc6bc514bd35ce3fe5844a
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-02-17 23:56:14 +0000

Bisect and union self-intersecting arcs in ArcPoly()

Avoids creating a self-intersecting contour which produces incorrect
result. Bug noted when clearing a 360 degree arc from a polygon.

For self-intersecting arcs, we now bisect, produce two polygons (with
non-self-intersecting contours), then compute their union.


---

diff --git a/src/polygon.c b/src/polygon.c
index 2c74578..b65f0df 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -372,8 +372,8 @@ RoundRect (LocationType x1, LocationType x2, LocationType y1, LocationType y2,
 }
 
 #define ARC_ANGLE 5
-POLYAREA *
-ArcPoly (ArcType * a, BDimension thick)
+static POLYAREA *
+ArcPolyNoIntersect (ArcType * a, BDimension thick)
 {
   PLINE *contour = NULL;
   POLYAREA *np = NULL;
@@ -437,6 +437,37 @@ ArcPoly (ArcType * a, BDimension thick)
   return np;
 }
 
+#define MIN_CLEARANCE_BEFORE_BISECT 10.
+POLYAREA *
+ArcPoly (ArcType * a, BDimension thick)
+{
+  double delta;
+  ArcType seg1, seg2;
+  POLYAREA *tmp1, *tmp2, *res;
+
+  delta = (a->Delta < 0) ? -a->Delta : a->Delta;
+
+  /* If the arc segment would self-intersect, we need to construct it as the union of
+     two non-intersecting segments */
+
+  if (2 * M_PI * a->Width * (1. - (double)delta / 360.) - thick < MIN_CLEARANCE_BEFORE_BISECT)
+    {
+      int half_delta = a->Delta / 2;
+
+      seg1 = seg2 = *a;
+      seg1.Delta = half_delta;
+      seg2.Delta -= half_delta;
+      seg2.StartAngle += half_delta;
+
+      tmp1 = ArcPolyNoIntersect (&seg1, thick);
+      tmp2 = ArcPolyNoIntersect (&seg2, thick);
+      poly_Boolean_free (tmp1, tmp2, &res, PBO_UNITE);
+      return res;
+    }
+
+  return ArcPolyNoIntersect (a, thick);
+}
+
 POLYAREA *
 LinePoly (LineType * L, BDimension thick)
 {

Bottom: 204e1da04f7b4f3a0bc2ae0937ec2aa85e64a450
Top:    22586dd1636c8a416af9874989a3a7c1eed778e8
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-02-17 23:55:28 +0000

Bisect and union self-intersecting arcs in ArcPoly()

Avoids creating a self-intersecting contour which produces incorrect
result. Bug noted when clearing a 360 degree arc from a polygon.

For self-intersecting arcs, we now bisect, produce two polygons (with
non-self-intersecting contours), then compute their union.


---

diff --git a/src/polygon.c b/src/polygon.c
index f3bfb72..3594946 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -422,8 +422,8 @@ RoundRect (LocationType x1, LocationType x2, LocationType y1, LocationType y2,
 }
 
 #define ARC_ANGLE 5
-POLYAREA *
-ArcPoly (ArcType * a, BDimension thick)
+static POLYAREA *
+ArcPolyNoIntersect (ArcType * a, BDimension thick)
 {
   PLINE *contour = NULL;
   POLYAREA *np = NULL;
@@ -487,6 +487,37 @@ ArcPoly (ArcType * a, BDimension thick)
   return np;
 }
 
+#define MIN_CLEARANCE_BEFORE_BISECT 10.
+POLYAREA *
+ArcPoly (ArcType * a, BDimension thick)
+{
+  double delta;
+  ArcType seg1, seg2;
+  POLYAREA *tmp1, *tmp2, *res;
+
+  delta = (a->Delta < 0) ? -a->Delta : a->Delta;
+
+  /* If the arc segment would self-intersect, we need to construct it as the union of
+     two non-intersecting segments */
+
+  if (2 * M_PI * a->Width * (1. - (double)delta / 360.) - thick < MIN_CLEARANCE_BEFORE_BISECT)
+    {
+      int half_delta = a->Delta / 2;
+
+      seg1 = seg2 = *a;
+      seg1.Delta = half_delta;
+      seg2.Delta -= half_delta;
+      seg2.StartAngle += half_delta;
+
+      tmp1 = ArcPolyNoIntersect (&seg1, thick);
+      tmp2 = ArcPolyNoIntersect (&seg2, thick);
+      poly_Boolean_free (tmp1, tmp2, &res, PBO_UNITE);
+      return res;
+    }
+
+  return ArcPolyNoIntersect (a, thick);
+}
+
 POLYAREA *
 LinePoly (LineType * L, BDimension thick)
 {

Bottom: 871a10f0fdc8db28955f03b1709d3730ea62edb0
Top:    048241532db126b67555a1dc88bd858f098ba3ae
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2014-07-04 04:24:34 +0100

Tag VNODEs with details of circular contour segments

The idea here is to track that the PWL segments actually came from a
particular underlying curve. This should allow us to reconstruct that
curve (approximately at least) if these segments survive in the final
polygon (are not intersected or removed by boolean operations).

The convention is that the curve shape tagging of a vertex corresponds
to the edge spanning this, and the previous vertex around the list.

NB: STILL DOES NOT WORK CORRECTLY IN ALL CASES. SEE:

circ_segs_test4_still_procuces_bad_contour_when_starting_with_arc.pcb

(SUSPECTED BUG IN THE GATHER / JUMP ROUTINES)


---

diff --git a/src/hid/common/draw_helpers.c b/src/hid/common/draw_helpers.c
index 685b614..4343e82 100644
--- a/src/hid/common/draw_helpers.c
+++ b/src/hid/common/draw_helpers.c
@@ -151,12 +151,14 @@ thindraw_contour (hidGC gc, PLINE *pl)
   gui->graphics->set_line_width (gc, 0);
   gui->graphics->set_line_cap (gc, Round_Cap);
 
+#if 0
   /* If the contour is round, use an arc drawing routine. */
   if (pl->is_round)
     {
       gui->graphics->draw_arc (gc, pl->cx, pl->cy, pl->radius, pl->radius, 0, 360);
       return;
     }
+#endif
 
   /* Need at least two points in the contour */
   if (pl->head.next == NULL)
@@ -171,8 +173,33 @@ thindraw_contour (hidGC gc, PLINE *pl)
       this_x = v->point[0];
       this_y = v->point[1];
 
-      gui->graphics->draw_line (gc, last_x, last_y, this_x, this_y);
-      // gui->graphics->fill_circle (gc, this_x, this_y, 30);
+      if (v->is_round)
+        {
+          Angle start_angle, end_angle, delta_angle;
+
+          start_angle = 180. - TO_DEGREES (atan2 ((v->prev->point[1] - v->cy), (v->prev->point[0] - v->cx)));
+          end_angle   = 180. - TO_DEGREES (atan2 ((      v->point[1] - v->cy), (      v->point[0] - v->cx)));
+          delta_angle = end_angle - start_angle;
+
+          if (delta_angle > 180.) delta_angle -= 360.;
+          if (delta_angle < -180.) delta_angle += 360.;
+
+          gui->graphics->draw_arc (gc, v->cx, v->cy, v->radius, v->radius, start_angle, delta_angle);
+
+          /* Fill the head vertex */
+          if (v == &pl->head)
+            gui->graphics->fill_circle (gc, this_x, this_y, MIL_TO_COORD (3));
+          else
+            gui->graphics->draw_arc (gc, this_x, this_y, MIL_TO_COORD (3), MIL_TO_COORD (3), 0, 360);
+        }
+      else
+        {
+          if (v == &pl->head)
+            gui->graphics->fill_circle (gc, this_x, this_y, MIL_TO_COORD (1.5));
+          else
+            gui->graphics->draw_arc (gc, this_x, this_y, MIL_TO_COORD (1.5), MIL_TO_COORD (1.5), 0, 360);
+          gui->graphics->draw_line (gc, last_x, last_y, this_x, this_y);
+        }
 
       last_x = this_x;
       last_y = this_y;
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 44c811d..db8a28e 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -849,9 +849,11 @@ ghid_thindraw_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
 {
   double old_alpha_mult = gc->alpha_mult;
   common_thindraw_pcb_polygon (gc, poly, clip_box);
+#if 0
   ghid_set_alpha_mult (gc, gc->alpha_mult * 0.25);
   gui->graphics->fill_pcb_polygon (gc, poly, clip_box);
   ghid_set_alpha_mult (gc, old_alpha_mult);
+#endif
 }
 
 void
@@ -1600,7 +1602,8 @@ fill_board_outline (hidGC gc, const BoxType *drawn_area)
     polygon.BoundingBox = *drawn_area;
   polygon.Flags = NoFlags ();
   SET_FLAG (FULLPOLYFLAG, &polygon);
-  gui->graphics->fill_pcb_polygon (gc, &polygon, drawn_area);
+//  gui->graphics->fill_pcb_polygon (gc, &polygon, drawn_area);
+  gui->graphics->thindraw_pcb_polygon (gc, &polygon, drawn_area);
   poly_FreeContours (&polygon.NoHoles);
 }
 
@@ -2652,7 +2655,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glDisable (GL_LIGHTING);
 
   draw_crosshair (priv);
-  object3d_draw_debug ();
+  //object3d_draw_debug ();
 
   hidgl_flush_triangles (&buffer);
 
diff --git a/src/macro.h b/src/macro.h
index a34693a..a38d525 100644
--- a/src/macro.h
+++ b/src/macro.h
@@ -69,6 +69,7 @@
 #define XOR(a,b)		(((a) && !(b)) || (!(a) && (b)))
 #define SQUARE(x)		((float) (x) * (float) (x))
 #define TO_RADIANS(degrees)	(M180 * (degrees))
+#define TO_DEGREES(radians)	((radians) / M180)
 
 /* ---------------------------------------------------------------------------
  * layer macros
diff --git a/src/misc.c b/src/misc.c
index 31021c9..b01a5ae 100644
--- a/src/misc.c
+++ b/src/misc.c
@@ -1101,7 +1101,14 @@ ParseGroupString (char *group_string, LayerGroupType *LayerGroup, int *LayerN)
           /* ignore white spaces and check for separator */
           while (*s && isspace ((int) *s))
             s++;
-          if (!*s || *s == ':')
+
+          /* Backup so the outer loop terminates on the NULL termination */
+          if (*s == '\0') {
+            s--;
+            break;
+          }
+
+          if (*s == ':')
             break;
         }
       LayerGroup->Number[group] = member;
diff --git a/src/polyarea.h b/src/polyarea.h
index d49660b..be95bd2 100644
--- a/src/polyarea.h
+++ b/src/polyarea.h
@@ -88,6 +88,9 @@ struct VNODE
     CVCList *cvc_prev;
     CVCList *cvc_next;
     Vector point;
+    bool is_round;
+    Coord cx, cy;
+    Coord radius;
 };
 
 typedef struct PLINE PLINE;
@@ -110,7 +113,7 @@ struct PLINE
     float *tristrip_vertices;
 };
 
-PLINE *poly_NewContour(Vector v);
+PLINE *poly_NewContour(VNODE *node);
 
 void poly_IniContour(PLINE *  c);
 void poly_ClrContour(PLINE *  c);  /* clears list of vertices */
@@ -122,6 +125,7 @@ void poly_PreContour(PLINE * c, BOOLp optimize); /* prepare contour */
 void poly_InvContour(PLINE * c);  /* invert contour */
 
 VNODE *poly_CreateNode(Vector v);
+VNODE *poly_CreateNodeArcApproximation(Vector v, Coord cx, Coord cy, Coord radius);
 
 void poly_InclVertex(VNODE * after, VNODE * node);
 void poly_ExclVertex(VNODE * node);
diff --git a/src/polygon.c b/src/polygon.c
index 57e79a4..87470b5 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -104,11 +104,15 @@ dicer output is used for HIDs which cannot render things with holes
 #include <dmalloc.h>
 #endif
 
+
+#define DEBUG_CIRCSEGS
+
 #define ROUND(x) ((long)(((x) >= 0 ? (x) + 0.5  : (x) - 0.5)))
 
+//#define UNSUBTRACT_BLOAT MIL_TO_COORD (0.1)
 #define UNSUBTRACT_BLOAT 10
-#define SUBTRACT_PIN_VIA_BATCH_SIZE 100
-#define SUBTRACT_LINE_BATCH_SIZE 20
+#define SUBTRACT_PIN_VIA_BATCH_SIZE 100 /*100*/
+#define SUBTRACT_LINE_BATCH_SIZE 20 /*20*/
 
 static double rotate_circle_seg[4];
 static double bw_rotate_circle_seg[4];
@@ -283,6 +287,7 @@ degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Vector v /* First po
   /* We don't re-add a point at v, nor do we add the last point, sweep degrees around from (X,Y)-v */
   double e1, e2, t1;
   int i, range;
+  double radius = sqrt ((v[0] - X) * (v[0] - X) + (v[1] - Y) * (v[1] - Y));
 
 //  poly_InclVertex (c->head.prev, poly_CreateNode (v));
 
@@ -302,7 +307,7 @@ degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Vector v /* First po
           e1 = t1;
           v[0] = X + ROUND (e1);
           v[1] = Y + ROUND (e2);
-          poly_InclVertex (c->head.prev, poly_CreateNode (v));
+          poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
         }
     }
   else
@@ -317,7 +322,7 @@ degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Vector v /* First po
           e1 = t1;
           v[0] = X + ROUND (e1);
           v[1] = Y + ROUND (e2);
-          poly_InclVertex (c->head.prev, poly_CreateNode (v));
+          poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
         }
     }
 }
@@ -337,18 +342,30 @@ original_poly (PolygonType * p)
   /* first make initial polygon contour */
   for (n = 0; n < p->PointN; n++)
     {
+      VNODE *node;
+      //Cardinal prev_n;
+
       /* No current contour? Make a new one starting at point */
       /*   (or) Add point to existing contour */
 
       v[0] = p->Points[n].X, v[1] = p->Points[n].Y;
+
+      //prev_n = prev_contour_point (p, n);
+
+      /* XXX: Need to handle the case of a leftover circular contour point */
+      if (0)
+        node = poly_CreateNodeArcApproximation (v, 0, 0, 0);
+      else
+        node = poly_CreateNode (v);
+
       if (contour == NULL)
         {
-          if ((contour = poly_NewContour (v)) == NULL)
+          if ((contour = poly_NewContour (node)) == NULL)
             return NULL;
         }
       else
         {
-          poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+          poly_InclVertex (contour->head.prev, node);
         }
 
       if (p->Points[n].included_angle != 0)
@@ -461,7 +478,7 @@ RectPoly (Coord x1, Coord x2, Coord y1, Coord y2)
 
   v[0] = x1;
   v[1] = y1;
-  if ((contour = poly_NewContour (v)) == NULL)
+  if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
     return NULL;
   v[0] = x2;
   v[1] = y1;
@@ -483,7 +500,7 @@ OctagonPoly (Coord x, Coord y, Coord radius)
 
   v[0] = x + ROUND (radius * 0.5);
   v[1] = y + ROUND (radius * TAN_22_5_DEGREE_2);
-  if ((contour = poly_NewContour (v)) == NULL)
+  if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
     return NULL;
   v[0] = x + ROUND (radius * TAN_22_5_DEGREE_2);
   v[1] = y + ROUND (radius * 0.5);
@@ -518,14 +535,19 @@ frac_circle (PLINE * c, Coord X, Coord Y, Vector v, int fraction)
 {
   double e1, e2, t1;
   int i, range;
+  double radius = sqrt ((v[0] - X) * (v[0] - X) + (v[1] - Y) * (v[1] - Y));
+
 
-  poly_InclVertex (c->head.prev, poly_CreateNode (v));
+  /* XXX: Circle already has the first node added */
+//  if (fraction > 1)
+//    poly_InclVertex (c->head.prev, poly_CreateNode (v));
+//    poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
   /* move vector to origin */
   e1 = (v[0] - X) * POLY_CIRC_RADIUS_ADJ;
   e2 = (v[1] - Y) * POLY_CIRC_RADIUS_ADJ;
 
-  /* NB: the caller adds the last vertex, hence the -1 */
-  range = POLY_CIRC_SEGS / fraction - 1;
+  /* XXX */ /* NB: the caller adds the last vertex, hence the -1 */
+  range = POLY_CIRC_SEGS / fraction;
   for (i = 0; i < range; i++)
     {
       /* rotate the vector */
@@ -534,7 +556,7 @@ frac_circle (PLINE * c, Coord X, Coord Y, Vector v, int fraction)
       e1 = t1;
       v[0] = X + ROUND (e1);
       v[1] = Y + ROUND (e2);
-      poly_InclVertex (c->head.prev, poly_CreateNode (v));
+      poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
     }
 }
 
@@ -550,7 +572,7 @@ CirclePoly (Coord x, Coord y, Coord radius)
     return NULL;
   v[0] = x + radius;
   v[1] = y;
-  if ((contour = poly_NewContour (v)) == NULL)
+  if ((contour = poly_NewContour (poly_CreateNodeArcApproximation (v, x, y, radius))) == NULL)
     return NULL;
   frac_circle (contour, x, y, v, 1);
   contour->is_round = TRUE;
@@ -571,7 +593,7 @@ RoundRect (Coord x1, Coord x2, Coord y1, Coord y2, Coord t)
   assert (y2 > y1);
   v[0] = x1 - t;
   v[1] = y1;
-  if ((contour = poly_NewContour (v)) == NULL)
+  if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
     return NULL;
   frac_circle (contour, x1, y1, v, 4);
   v[0] = x2;
@@ -626,7 +648,7 @@ ArcPolyNoIntersect (ArcType * a, Coord thick)
   radius_adj = (M_PI*da/360)*(M_PI*da/360)/2;
   v[0] = a->X - rx * cos (ang * M180);
   v[1] = a->Y + ry * sin (ang * M180);
-  if ((contour = poly_NewContour (v)) == NULL)
+  if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
     return 0;
   for (i = 0; i < segs - 1; i++)
     {
@@ -730,28 +752,39 @@ LinePoly (LineType * L, Coord thick)
       l->Point2.X += dy;
       l->Point2.Y -= dx;
     }
-  v[0] = l->Point1.X - dx;
-  v[1] = l->Point1.Y - dy;
-  if ((contour = poly_NewContour (v)) == NULL)
-    return 0;
+
+
   v[0] = l->Point2.X - dx;
   v[1] = l->Point2.Y - dy;
+  if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
+    return 0;
+
   if (TEST_FLAG (SQUAREFLAG,l))
-    poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+    {
+      v[0] = l->Point2.X + dx;
+      v[1] = l->Point2.Y + dy;
+      poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+    }
   else
     frac_circle (contour, l->Point2.X, l->Point2.Y, v, 2);
-  v[0] = l->Point2.X + dx;
-  v[1] = l->Point2.Y + dy;
-  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+
   v[0] = l->Point1.X + dx;
   v[1] = l->Point1.Y + dy;
+  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+
   if (TEST_FLAG (SQUAREFLAG,l))
-    poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+    {
+      v[0] = l->Point1.X - dx;
+      v[1] = l->Point1.Y - dy;
+      poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+    }
   else
     frac_circle (contour, l->Point1.X, l->Point1.Y, v, 2);
+
   /* now we have the line contour */
   if (!(np = ContourToPoly (contour)))
     return NULL;
+
   return np;
 }
 
@@ -806,7 +839,7 @@ SquarePadPoly (PadType * pad, Coord clear)
 
   v[0] = c->Point1.X - tx;
   v[1] = c->Point1.Y - ty;
-  if ((contour = poly_NewContour (v)) == NULL)
+  if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
     return 0;
   frac_circle (contour, (t->Point1.X - tx), (t->Point1.Y - ty), v, 4);
 
@@ -1778,6 +1811,10 @@ ClearFromPolygon (DataType * Data, int type, void *ptr1, void *ptr2)
           strcmp (layer->Name, "route") == 0)
         Data->outline_valid = false;
     }
+  else if (type == PIN_TYPE || type == VIA_TYPE)
+    {
+        Data->outline_valid = false;
+    }
 
   if (type == POLYGON_TYPE)
     InitClip (PCB->Data, (LayerType *) ptr1, (PolygonType *) ptr2);
@@ -2113,10 +2150,18 @@ arc_outline_callback (const BoxType * b, void *cl)
   struct clip_outline_info *info = cl;
   POLYAREA *np, *res;
 
+#ifdef DEBUG_CIRCSEGS
+  if (!(np = ArcPoly (arc, arc->Thickness)))
+#else
   if (!(np = ArcPoly (arc, ROUTER_THICKNESS)))
+#endif
     return 0;
 
+#ifdef DEBUG_CIRCSEGS
+  poly_Boolean_free (info->poly, np, &res, PBO_UNITE);
+#else
   poly_Boolean_free (info->poly, np, &res, PBO_SUB);
+#endif
   info->poly = res;
 
   return 1;
@@ -2129,10 +2174,18 @@ line_outline_callback (const BoxType * b, void *cl)
   struct clip_outline_info *info = cl;
   POLYAREA *np, *res;
 
+#ifdef DEBUG_CIRCSEGS
+  if (!(np = LinePoly (line, line->Thickness)))
+#else
   if (!(np = LinePoly (line, ROUTER_THICKNESS)))
+#endif
     return 0;
 
+#ifdef DEBUG_CIRCSEGS
+  poly_Boolean_free (info->poly, np, &res, PBO_UNITE);
+#else
   poly_Boolean_free (info->poly, np, &res, PBO_SUB);
+#endif
   info->poly = res;
 
   return 1;
@@ -2145,10 +2198,18 @@ pv_outline_callback (const BoxType * b, void *cl)
   struct clip_outline_info *info = cl;
   POLYAREA *np, *res;
 
+#ifdef DEBUG_CIRCSEGS
+  if (!(np = CirclePoly (pv->X, pv->Y, pv->Thickness / 2)))
+#else
   if (!(np = CirclePoly (pv->X, pv->Y, pv->DrillingHole / 2)))
+#endif
     return 0;
 
+#ifdef DEBUG_CIRCSEGS
+  poly_Boolean_free (info->poly, np, &res, PBO_UNITE);
+#else
   poly_Boolean_free (info->poly, np, &res, PBO_SUB);
+#endif
   info->poly = res;
 
   return 1;
@@ -2164,8 +2225,11 @@ polygon_outline_callback (const BoxType * b, void *cl)
   if (!(np = original_poly (poly)))
     return 0;
 
-
+#ifdef DEBUG_CIRCSEGS
   poly_Boolean_free (info->poly, np, &res, PBO_UNITE);
+#else
+  poly_Boolean_free (info->poly, np, &res, PBO_SUB);
+#endif
   info->poly = res;
 
   return 1;
@@ -2256,13 +2320,19 @@ POLYAREA *board_outline_poly (bool include_holes)
   region.X2 = PCB->MaxWidth;
   region.Y2 = PCB->MaxHeight;
 
-#if 0
+#if 1
+#ifdef DEBUG_CIRCSEGS
+  info.poly = NULL;
+#else
   info.poly = whole_world;
+#endif
 
   r_search (Layer->line_tree, &region, NULL, line_outline_callback, &info);
   r_search (Layer->arc_tree,  &region, NULL, arc_outline_callback, &info);
 
+#ifndef DEBUG_CIRCSEGS
   if (include_holes)
+#endif
     {
       r_search (PCB->Data->pin_tree, &region, NULL, pv_outline_callback, &info);
       r_search (PCB->Data->via_tree, &region, NULL, pv_outline_callback, &info);
@@ -2270,6 +2340,10 @@ POLYAREA *board_outline_poly (bool include_holes)
 
   clipped = info.poly;
 
+#ifdef DEBUG_CIRCSEGS
+  return clipped;
+#endif
+
   /* Now we just need to work out which pieces of polygon are inside
      and outside the board! */
 
@@ -2305,6 +2379,7 @@ POLYAREA *board_outline_poly (bool include_holes)
   g_list_foreach (pieces_to_delete, delete_piece_cb, &clipped);
 #endif
 
+#ifdef DEBUG_CIRCSEGS
   // The actual operation we want is to split the test polygon into multiple pieces
   // along the intersection with the polygon contours of any polygon on the outer layer.
   // The result would be nested, touching (not normally produced by the PBO code),
@@ -2318,6 +2393,7 @@ POLYAREA *board_outline_poly (bool include_holes)
     return whole_world;
   else
     poly_Free (&whole_world);
+#endif
 
   return clipped;
 }
diff --git a/src/polygon.h b/src/polygon.h
index 369efea..2ed2b62 100644
--- a/src/polygon.h
+++ b/src/polygon.h
@@ -34,7 +34,8 @@
 
 /* Implementation constants */
 
-#define POLY_CIRC_SEGS 40
+//#define POLY_CIRC_SEGS 40
+#define POLY_CIRC_SEGS 8
 #define POLY_CIRC_SEGS_F ((float)POLY_CIRC_SEGS)
 
 #if 0
diff --git a/src/polygon1.c b/src/polygon1.c
index 7d6fab6..694a161 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -49,6 +49,7 @@
 #include "global.h"
 #include "rtree.h"
 #include "heap.h"
+#include "pcb-printf.h"
 
 #define ROUND(a) (long)((a) > 0 ? ((a) + 0.5) : ((a) - 0.5))
 
@@ -95,12 +96,13 @@ int vect_inters2 (Vector A, Vector B, Vector C, Vector D, Vector S1,
   if (UNLIKELY (((ptr) = (type *)malloc(sizeof(type))) == NULL))	\
     error(err_no_memory);
 
+//#define DEBUG_INTERSECT
 #undef DEBUG_LABEL
 #undef DEBUG_ALL_LABELS
-#undef DEBUG_JUMP
-#undef DEBUG_GATHER
+//#define DEBUG_JUMP
+//#define DEBUG_GATHER
 #undef DEBUG_ANGLE
-#undef DEBUG
+//#define DEBUG
 #ifdef DEBUG
 #define DEBUGP(...) pcb_fprintf(stderr, ## __VA_ARGS__)
 #else
@@ -162,6 +164,41 @@ poly_dump (POLYAREA * p)
 }
 #endif
 
+static VNODE *
+poly_CreateNodeFull (Vector v, bool is_round, Coord cx, Coord cy, Coord radius)
+{
+  VNODE *res;
+  Coord *c;
+
+  assert (v);
+  res = (VNODE *) calloc (1, sizeof (VNODE));
+  if (res == NULL)
+    return NULL;
+  // bzero (res, sizeof (VNODE) - sizeof(Vector));
+  c = res->point;
+  *c++ = *v++;
+  *c = *v;
+
+  res->is_round = is_round;
+  res->cx = cx;
+  res->cy = cy;
+  res->radius = radius;
+
+  return res;
+}
+
+VNODE *
+poly_CreateNode (Vector v)
+{
+  return poly_CreateNodeFull (v, false, 0, 0, 0);
+}
+
+VNODE *
+poly_CreateNodeArcApproximation (Vector v, Coord cx, Coord cy, Coord radius)
+{
+  return poly_CreateNodeFull (v, true, cx, cy, radius);
+}
+
 /***************************************************************/
 /* routines for processing intersections */
 
@@ -181,6 +218,7 @@ node_add_single (VNODE * dest, Vector po)
 {
   VNODE *p;
 
+/* XXX: MAY NOT BE CORRECT IF WE NEED TO SEPARATE STRAIGHT AND CURVED SEGMENTS */
   if (vect_equal (po, dest->point))
     return dest;
   if (vect_equal (po, dest->next->point))
@@ -875,6 +913,10 @@ intersect_impl (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
     {
       insert_node_task *next = task->next;
 
+      /* XXX: If a node was inserted due to an intersection, don't assume we're on the a round contour any more */
+//      task->node_seg->v->is_round = false;
+      task->node_seg->v->next->is_round = false;
+
       /* Do insersion */
       task->new_node->prev = task->node_seg->v;
       task->new_node->next = task->node_seg->v->next;
@@ -1615,25 +1657,54 @@ Gather (VNODE * start, PLINE ** result, J_Rule v_rule, DIRECTION initdir)
   assert (*result == NULL);
   do
     {
+      VNODE *jump_cur_temp;
+      DIRECTION jump_dir_temp;
+
+      jump_cur_temp = cur;
+      jump_dir_temp = dir;
+
+#if 1
+      /* see where to go next */
+      if (!jump (&jump_cur_temp, &jump_dir_temp, v_rule))
+	break;
+#endif
+
+#if 0
       /* see where to go next */
       if (!jump (&cur, &dir, v_rule))
 	break;
+#endif
       /* add edge to polygon */
+//      if ((newn = poly_CreateNodeFull (cur->point, cur->is_round, cur->cx, cur->cy, cur->radius)) == NULL) /* XXX: DIRECTION - might we need to query the previous point for arc details ?? */
+      /* XXX: The cur->next part of the line below is somewhat tested, but was determined by trial and error */
+      if ((newn = poly_CreateNodeFull (cur->point, (dir == FORW) ? cur->is_round : cur->next->is_round,
+                                                   (dir == FORW) ? cur->cx       : cur->next->cx,
+                                                   (dir == FORW) ? cur->cy       : cur->next->cy,
+                                                   (dir == FORW) ? cur->radius   : cur->next->radius)) == NULL) /* XXX: DIRECTION - might we need to query the previous point for arc details ?? */
+        return err_no_memory;
       if (!*result)
 	{
-	  *result = poly_NewContour (cur->point);
+	  *result = poly_NewContour (newn);
 	  if (*result == NULL)
 	    return err_no_memory;
 	}
       else
 	{
-	  if ((newn = poly_CreateNode (cur->point)) == NULL)
-	    return err_no_memory;
 	  poly_InclVertex ((*result)->head.prev, newn);
 	}
 #ifdef DEBUG_GATHER
-      DEBUGP ("gather vertex at %#mD\n", cur->point[0], cur->point[1]);
+      DEBUGP ("gather vertex at %mm, %mm, Dir=%i\n", cur->point[0], cur->point[1], dir);
+#endif
+#if 1
+      cur = jump_cur_temp;
+      dir = jump_dir_temp;
+#endif
+#if 0
+      /* see where to go next */
+      if (!jump (&cur, &dir, v_rule))
+	break;
 #endif
+
       /* Now mark the edge as included.  */
       newn = (dir == FORW ? cur : cur->prev);
       newn->Flags.mark = 1;
@@ -1643,6 +1714,11 @@ Gather (VNODE * start, PLINE ** result, J_Rule v_rule, DIRECTION initdir)
 
       /* Advance to the next edge.  */
       cur = (dir == FORW ? cur->next : cur->prev);
+#if 0
+      /* see where to go next */
+      if (!jump (&cur, &dir, v_rule))
+	break;
+#endif
     }
   while (1);
   return err_ok;
@@ -2293,6 +2369,8 @@ poly_Boolean (const POLYAREA * a_org, const POLYAREA * b_org,
   return poly_Boolean_free (a, b, res, action);
 }				/* poly_Boolean */
 
+static void test_polyInvContour (void);
+
 /* just like poly_Boolean but frees the input polys */
 int
 poly_Boolean_free (POLYAREA * ai, POLYAREA * bi, POLYAREA ** res, int action)
@@ -2303,6 +2381,8 @@ poly_Boolean_free (POLYAREA * ai, POLYAREA * bi, POLYAREA ** res, int action)
   jmp_buf e;
   int code;
 
+  test_polyInvContour ();
+
   *res = NULL;
 
   if (!a)
@@ -2486,23 +2566,6 @@ node_neighbours (VNODE * a, VNODE * b)
   return (a == b) || (a->next == b) || (b->next == a) || (a->next == b->next);
 }
 
-VNODE *
-poly_CreateNode (Vector v)
-{
-  VNODE *res;
-  Coord *c;
-
-  assert (v);
-  res = (VNODE *) calloc (1, sizeof (VNODE));
-  if (res == NULL)
-    return NULL;
-  // bzero (res, sizeof (VNODE) - sizeof(Vector));
-  c = res->point;
-  *c++ = *v++;
-  *c = *v;
-  return res;
-}
-
 void
 poly_IniContour (PLINE * c)
 {
@@ -2519,7 +2582,7 @@ poly_IniContour (PLINE * c)
 }
 
 PLINE *
-poly_NewContour (Vector v)
+poly_NewContour (VNODE *node)
 {
   PLINE *res;
 
@@ -2529,11 +2592,13 @@ poly_NewContour (Vector v)
 
   poly_IniContour (res);
 
-  if (v != NULL)
-    {
-      Vcopy (res->head.point, v);
-      cntrbox_adjust (res, v);
-    }
+  Vcopy (res->head.point, node->point);
+  res->head.is_round = node->is_round;
+  res->head.cx = node->cx;
+  res->head.cy = node->cy;
+  res->head.radius = node->radius;
+  cntrbox_adjust (res, res->head.point);
+  free (node);
 
   return res;
 }
@@ -2649,6 +2714,47 @@ flip_cb (const BoxType * b, void *cl)
   return 1;
 }
 
+#ifndef DEBUG
+static void
+pline_dump (VNODE * v)
+{
+  VNODE *s;
+
+  s = v;
+  do
+    {
+      pcb_fprintf (stderr, "%mm %mm  - %s\n", v->point[0], v->point[1], v->is_round ? "Round" : "Line");
+    }
+  while ((v = v->next) != s);
+}
+#endif
+
+static void
+test_polyInvContour (void)
+{
+  static bool done = false;
+  PLINE *contour;
+  Vector v;
+
+  if (done)
+    return;
+
+  printf ("Testing inv_contour\n");
+
+  v[0] = 0, v[1] = 0; contour = poly_NewContour (poly_CreateNode (v));
+  v[0] = 0, v[1] = 1; poly_InclVertex (contour->head.prev, poly_CreateNodeArcApproximation (v, 0, 0, 0));
+  v[0] = 1, v[1] = 1; poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+  v[0] = 1; v[1] = 0; poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+
+  pline_dump (&contour->head);
+  poly_InvContour (contour);
+  pline_dump (&contour->head);
+
+  poly_FreeContours (&contour);
+
+  done = true;
+}
+
 void
 poly_InvContour (PLINE * c)
 {
@@ -2657,16 +2763,46 @@ poly_InvContour (PLINE * c)
   int r;
 #endif
 
+  /* Stash the first data which will get over-written in the loop */
+
+  bool stash_is_round = c->head.prev->is_round;
+  Coord stash_cx = c->head.prev->cx;
+  Coord stash_cy = c->head.prev->cy;
+  Coord stash_radius = c->head.prev->radius;
+
+//  printf ("poly_InvContour\n");
+
   assert (c != NULL);
   cur = &c->head;
   do
     {
+#if 1
+      /* Swap the attachement of round contour information */
+      cur->prev->is_round = cur->is_round;
+      cur->prev->cx = cur->cx;
+      cur->prev->cy = cur->cy;
+      cur->prev->radius = cur->radius;
+#endif
+
       next = cur->next;
       cur->next = cur->prev;
       cur->prev = next;
+
       /* fix the segment tree */
     }
   while ((cur = next) != &c->head);
+
+  /* NB: Remember that the list just got reversed.. the last
+   *     entry in the old order got stale data from the wraparound
+   *     Fix that up now.
+   */
+#if 1
+  c->head.next->next->is_round = stash_is_round;
+  c->head.next->next->cx = stash_cx;
+  c->head.next->next->cy = stash_cy;
+  c->head.next->next->radius = stash_radius;
+#endif
+
   c->Flags.orient ^= 1;
   if (c->tree)
     {
@@ -2706,11 +2842,25 @@ poly_InclVertex (VNODE * after, VNODE * node)
   /* remove points on same line */
   if (node->prev->prev == node)
     return;			/* we don't have 3 points in the poly yet */
+
+  /* NB: a-b below is the two-dimensional cross product of the vectors
+   *     node->prev->prev->point -> node->prev->point  and
+   *     node->prev->prev->point -> node->point.
+   *
+   * Its magnitude is the area of the parallelogram with those vectors as sides.
+   * If the vectors are colinear, this is zero.
+   */
   a = (node->point[1] - node->prev->prev->point[1]);
   a *= (node->prev->point[0] - node->prev->prev->point[0]);
   b = (node->point[0] - node->prev->prev->point[0]);
   b *= (node->prev->point[1] - node->prev->prev->point[1]);
-  if (fabs (a - b) < EPSILON)
+
+//  printf ("a-b = %f\n", a-b);
+
+  /* XXX: HMM - This doesn't seem to be involved when extra points are left in polygon contours after boolean operations */
+  if (fabs (a - b) < 1000000) //EPSILON &&
+//      !node->prev->is_round && !node->is_round)
+//      !node->prev->is_round && !node->is_round)
     {
       VNODE *t = node->prev;
       t->prev->next = node;
@@ -2726,7 +2876,7 @@ poly_CopyContour (PLINE ** dst, PLINE * src)
 
   assert (src != NULL);
   *dst = NULL;
-  *dst = poly_NewContour (src->head.point);
+  *dst = poly_NewContour (poly_CreateNodeFull (src->head.point, src->head.is_round, src->head.cx, src->head.cy, src->head.radius));
   if (*dst == NULL)
     return FALSE;
 
@@ -2738,7 +2888,7 @@ poly_CopyContour (PLINE ** dst, PLINE * src)
 
   for (cur = src->head.next; cur != &src->head; cur = cur->next)
     {
-      if ((newnode = poly_CreateNode (cur->point)) == NULL)
+      if ((newnode = poly_CreateNodeFull (cur->point, cur->is_round, cur->cx, cur->cy, cur->radius)) == NULL)
 	return FALSE;
       // newnode->Flags = cur->Flags;
       poly_InclVertex ((*dst)->head.prev, newnode);
diff --git a/src/thermal.c b/src/thermal.c
index 2f91d7d..aadd20e 100644
--- a/src/thermal.c
+++ b/src/thermal.c
@@ -107,7 +107,7 @@ diag_line (Coord X, Coord Y, Coord l, Coord w, bool rt)
 
   v[0] = X + x1;
   v[1] = Y + y2;
-  if ((c = poly_NewContour (v)) == NULL)
+  if ((c = poly_NewContour (poly_CreateNode (v))) == NULL)
     return NULL;
   v[0] = X - x2;
   v[1] = Y - y1;
@@ -138,7 +138,7 @@ square_therm (PinType *pin, Cardinal style)
       /* top (actually bottom since +y is down) */
       v[0] = pin->X - in + d;
       v[1] = pin->Y + in;
-      if ((c = poly_NewContour (v)) == NULL)
+      if ((c = poly_NewContour (poly_CreateNode (v))) == NULL)
         return NULL;
       v[0] = pin->X + in - d;
       poly_InclVertex (c->head.prev, poly_CreateNode (v));
@@ -151,7 +151,7 @@ square_therm (PinType *pin, Cardinal style)
       /* right */
       v[0] = pin->X + in;
       v[1] = pin->Y + in - d;
-      if ((c = poly_NewContour (v)) == NULL)
+      if ((c = poly_NewContour (poly_CreateNode (v))) == NULL)
         return NULL;
       v[1] = pin->Y - in + d;
       poly_InclVertex (c->head.prev, poly_CreateNode (v));
@@ -166,7 +166,7 @@ square_therm (PinType *pin, Cardinal style)
       /* left */
       v[0] = pin->X - in;
       v[1] = pin->Y - in + d;
-      if ((c = poly_NewContour (v)) == NULL)
+      if ((c = poly_NewContour (poly_CreateNode (v))) == NULL)
         return NULL;
       v[1] = pin->Y + in - d;
       poly_InclVertex (c->head.prev, poly_CreateNode (v));
@@ -181,7 +181,7 @@ square_therm (PinType *pin, Cardinal style)
       /* bottom (actually top since +y is down) */
       v[0] = pin->X + in - d;
       v[1] = pin->Y - in;
-      if ((c = poly_NewContour (v)) == NULL)
+      if ((c = poly_NewContour (poly_CreateNode (v))) == NULL)
         return NULL;
       v[0] = pin->X - in + d;
       poly_InclVertex (c->head.prev, poly_CreateNode (v));
@@ -242,7 +242,7 @@ square_therm (PinType *pin, Cardinal style)
       /* topright */
       v[0] = pin->X + in;
       v[1] = pin->Y + in;
-      if ((c = poly_NewContour (v)) == NULL)
+      if ((c = poly_NewContour (poly_CreateNode (v))) == NULL)
         return NULL;
       v[1] = pin->Y + d;
       poly_InclVertex (c->head.prev, poly_CreateNode (v));
@@ -271,7 +271,7 @@ square_therm (PinType *pin, Cardinal style)
       /* bottom right */
       v[0] = pin->X + in;
       v[1] = pin->Y - d;
-      if ((c = poly_NewContour (v)) == NULL)
+      if ((c = poly_NewContour (poly_CreateNode (v))) == NULL)
         return NULL;
       v[1] = pin->Y - in;
       poly_InclVertex (c->head.prev, poly_CreateNode (v));
@@ -298,7 +298,7 @@ square_therm (PinType *pin, Cardinal style)
       /* bottom left */
       v[0] = pin->X - d;
       v[1] = pin->Y - in;
-      if ((c = poly_NewContour (v)) == NULL)
+      if ((c = poly_NewContour (poly_CreateNode (v))) == NULL)
         return NULL;
       v[0] = pin->X - in;
       poly_InclVertex (c->head.prev, poly_CreateNode (v));
@@ -325,7 +325,7 @@ square_therm (PinType *pin, Cardinal style)
       /* top left */
       v[0] = pin->X - d;
       v[1] = pin->Y + out;
-      if ((c = poly_NewContour (v)) == NULL)
+      if ((c = poly_NewContour (poly_CreateNode (v))) == NULL)
         return NULL;
       v[0] = pin->X - in;
       poly_InclVertex (c->head.prev, poly_CreateNode (v));

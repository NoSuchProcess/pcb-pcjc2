Bottom: 7ba0685e7a10fcdcbcaaf84c1e3a74eb9b6e1a6a
Top:    d76efaf70a63c95b36e280145249e139f1702731
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-11-11 05:26:03 +0000

Allow zero clearance pads and pins to touch polygons

This was already supported for vias, lets be consistent.


---

diff --git a/src/change.c b/src/change.c
index 0599ee4..67aa38a 100644
--- a/src/change.c
+++ b/src/change.c
@@ -531,7 +531,13 @@ ChangePinClearSize (ElementTypePtr Element, PinTypePtr Pin)
 
   if (TEST_FLAG (LOCKFLAG, Pin))
     return (NULL);
-  value = MIN (MAX_LINESIZE, MAX (value, PCB->Bloat * 2 + 2));
+  value = MIN (MAX_LINESIZE, value);
+  if (value < 0)
+    value = 0;
+  if (Delta < 0 && value < PCB->Bloat * 2)
+    value = 0;
+  if ((Delta > 0 || Absolute) && value < PCB->Bloat * 2)
+    value = PCB->Bloat * 2 + 2;
   if (Pin->Clearance == value)
     return NULL;
   RestoreToPolygon (PCB->Data, PIN_TYPE, Element, Pin);
@@ -586,21 +592,25 @@ ChangePadClearSize (ElementTypePtr Element, PadTypePtr Pad)
 
   if (TEST_FLAG (LOCKFLAG, Pad))
     return (NULL);
-  value = MIN (MAX_LINESIZE, MAX (value, PCB->Bloat * 2 + 2));
-  if (value <= MAX_PADSIZE && value >= MIN_PADSIZE && value != Pad->Clearance)
-    {
-      AddObjectToClearSizeUndoList (PAD_TYPE, Element, Pad, Pad);
-      RestoreToPolygon (PCB->Data, PAD_TYPE, Element, Pad);
-      ErasePad (Pad);
-      r_delete_entry (PCB->Data->pad_tree, &Pad->BoundingBox);
-      Pad->Clearance = value;
-      /* SetElementBB updates all associated rtrees */
-      SetElementBoundingBox (PCB->Data, Element, &PCB->Font);
-      ClearFromPolygon (PCB->Data, PAD_TYPE, Element, Pad);
-      DrawPad (Pad, 0);
-      return (Pad);
-    }
-  return (NULL);
+  value = MIN (MAX_LINESIZE, value);
+  if (value < 0)
+    value = 0;
+  if (Delta < 0 && value < PCB->Bloat * 2)
+    value = 0;
+  if ((Delta > 0 || Absolute) && value < PCB->Bloat * 2)
+    value = PCB->Bloat * 2 + 2;
+  if (value == Pad->Clearance)
+    return NULL;
+  AddObjectToClearSizeUndoList (PAD_TYPE, Element, Pad, Pad);
+  RestoreToPolygon (PCB->Data, PAD_TYPE, Element, Pad);
+  ErasePad (Pad);
+  r_delete_entry (PCB->Data->pad_tree, &Pad->BoundingBox);
+  Pad->Clearance = value;
+  /* SetElementBB updates all associated rtrees */
+  SetElementBoundingBox (PCB->Data, Element, &PCB->Font);
+  ClearFromPolygon (PCB->Data, PAD_TYPE, Element, Pad);
+  DrawPad (Pad, 0);
+  return Pad;
 }
 
 /* ---------------------------------------------------------------------------
diff --git a/src/draw.c b/src/draw.c
index 4657f7c..4d7c8de 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -1365,6 +1365,9 @@ DrawPadLowLevel (hidGC gc, PadTypePtr Pad, Boolean clear, Boolean mask)
       return;
     }
 
+  if (clear && !mask && Pad->Clearance <= 0)
+    return;
+
   if (TEST_FLAG (THINDRAWFLAG, PCB) ||
       (clear && TEST_FLAG (THINDRAWPOLYFLAG, PCB)))
     {
diff --git a/src/find.c b/src/find.c
index 6e81d29..c747b8f 100644
--- a/src/find.c
+++ b/src/find.c
@@ -2288,7 +2288,8 @@ LOCtoPadPoly_callback (const BoxType * b, void *cl)
   struct lo_info *i = (struct lo_info *) cl;
 
 
-  if (!TEST_FLAG (TheFlag, polygon) && !TEST_FLAG (CLEARPOLYFLAG, polygon))
+  if (!TEST_FLAG (TheFlag, polygon) &&
+      (!TEST_FLAG (CLEARPOLYFLAG, polygon) || !i->pad.Clearance))
     {
       if (IsPadInPolygon (&i->pad, polygon) &&
           ADD_POLYGON_TO_LIST (i->layer, polygon))
@@ -2529,15 +2530,12 @@ LookupLOConnectionsToPolygon (PolygonTypePtr Polygon, Cardinal LayerGroup)
         }
       else
         {
-          if (!TEST_FLAG (CLEARPOLYFLAG, Polygon))
-            {
-              info.layer = layer - max_layer;
-              if (setjmp (info.env) == 0)
-                r_search (PCB->Data->pad_tree, (BoxType *) & info.polygon,
-                          NULL, LOCtoPolyPad_callback, &info);
-              else
-                return True;
-            }
+          info.layer = layer - max_layer;
+          if (setjmp (info.env) == 0)
+            r_search (PCB->Data->pad_tree, (BoxType *) & info.polygon,
+                      NULL, LOCtoPolyPad_callback, &info);
+          else
+            return True;
         }
     }
   return (False);
@@ -3766,7 +3764,7 @@ drc_callback (DataTypePtr data, LayerTypePtr layer, PolygonTypePtr polygon,
         }
       break;
     case PAD_TYPE:
-      if (pad->Clearance < 2 * PCB->Bloat)
+      if (pad->Clearance && pad->Clearance < 2 * PCB->Bloat)
 	if (IsPadInPolygon(pad,polygon))
 	  {
 	    AddObjectToFlagUndoList (type, ptr1, ptr2, ptr2);
@@ -3776,7 +3774,7 @@ drc_callback (DataTypePtr data, LayerTypePtr layer, PolygonTypePtr polygon,
 	  }
       break;
     case PIN_TYPE:
-      if (pin->Clearance < 2 * PCB->Bloat)
+      if (pin->Clearance && pin->Clearance < 2 * PCB->Bloat)
         {
           AddObjectToFlagUndoList (type, ptr1, ptr2, ptr2);
           SET_FLAG (TheFlag, pin);
diff --git a/src/polygon.c b/src/polygon.c
index 451383b..c1784e0 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -763,6 +763,8 @@ SubtractPad (PadType * pad, PolygonType * p)
 {
   POLYAREA *np = NULL;
 
+  if (pad->Clearance == 0)
+    return 0;
   if (TEST_FLAG (SQUAREFLAG, pad))
     {
       if (!
@@ -864,6 +866,8 @@ pad_sub_callback (const BoxType * b, void *cl)
   /* don't subtract the object that was put back! */
   if (b == info->other)
     return 0;
+  if (pad->Clearance == 0)
+    return 0;
   polygon = info->polygon;
   if (XOR (TEST_FLAG (ONSOLDERFLAG, pad), !info->solder))
     {

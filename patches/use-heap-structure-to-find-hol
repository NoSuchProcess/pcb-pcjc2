Bottom: 7df9b83a2da52497d04fff46a3bc3a34e119497d
Top:    dcb1bed3b69c333e28f3c419b2c9fa0078b1c532
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-10-22 02:13:28 +0100

Use heap structure to find hole quicker


---

diff --git a/src/polygon1.c b/src/polygon1.c
index 436ecb6..5a0eabd 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -1152,14 +1152,21 @@ PutContour (jmp_buf * e, PLINE * cntr, POLYAREA ** contours, PLINE ** holes,
     }
 }				/* PutContour */
 
+struct polyarea_info
+{
+  BoxType BoundingBox;
+  POLYAREA *pa;
+}
+
 static int
 heap_it (const BoxType * b, void *cl)
 {
   heap_t *heap = (heap_t *) cl;
-  PLINE *p = (PLINE *) b;
+  struct polyarea_info *pa_info = (struct polyarea_info *)b;
+  PLINE *p = pa_info->pa->contours;
   if (p->Count == 0)
     return 0;  /* how did this happen? */
-  heap_insert (heap, p->area, (void *) p);
+  heap_insert (heap, p->area, pa_info);
   return 1;
 }
 
@@ -1170,20 +1177,40 @@ InsertHoles (jmp_buf * e, POLYAREA * dest, PLINE ** src)
   PLINE *curh, *container, *tmp;
   heap_t *heap;
   rtree_t *tree;
+  int i;
+  int num_polyareas = 0;
+  struct polyarea_info *all_pa_info, *pa_info;
 
   if (*src == NULL)
     return;			/* empty hole list */
   if (dest == NULL)
     error (err_bad_parm);	/* empty contour list */
 
-  /* make an rtree of outer contours */
+  /* Count dest polyareas */
+  curc = dest;
+  do
+    {
+      num_polyareas ++:
+    }
+  while ((curc = curc->f) != dest);
+
+  /* make a polyarea info table */
+  /* make an rtree of polyarea info table */
+  all_pa_info = malloc (sizeof (struct polyarea_info) * num_polyareas);
   tree = r_create_tree (NULL, 0, 0);
+  i = 0;
   curc = dest;
   do
     {
-      r_insert_entry (tree, (const BoxType *) curc->contours, 0);
+      all_pa_info[i].BoundingBox.X1 = (BoxType)curc->contours.xmin;
+      all_pa_info[i].BoundingBox.Y1 = (BoxType)curc->contours.ymin;
+      all_pa_info[i].BoundingBox.X2 = (BoxType)curc->contours.xmax;
+      all_pa_info[i].BoundingBox.Y2 = (BoxType)curc->contours.ymax;
+      all_pa_info[i].pa = curc;
+      r_insert_entry (tree, (const BoxType *) &all_pa_info[i], 0);
     }
   while ((curc = curc->f) != dest);
+
   /* loop through the holes and put them where they belong */
   while ((curh = *src) != NULL)
     {
@@ -1207,24 +1234,25 @@ InsertHoles (jmp_buf * e, POLYAREA * dest, PLINE ** src)
        * in the heap, assume it is the container without the expense of
        * proving it.
        */
-      tmp = (PLINE *) heap_remove_smallest (heap);
+      pa_info = heap_remove_smallest (heap);
       if (heap_is_empty (heap))
 	{			/* only one possibility it must be the right one */
-	  assert (poly_ContourInContour (tmp, curh));
-	  container = tmp;
+          if (!poly_ContourInContour (pa_info->pa->contours, curh))
+            assert (0);
+	  container = pa_info->pa->contours;
 	}
       else
 	{
 	  do
 	    {
-	      if (poly_ContourInContour (tmp, curh))
+	      if (poly_ContourInContour (pa_info->pa->contours, curh))
 		{
-		  container = tmp;
+		  container = pa_info->pa->contours;
 		  break;
 		}
 	      if (heap_is_empty (heap))
 		break;
-	      tmp = (PLINE *) heap_remove_smallest (heap);
+	      pa_info = heap_remove_smallest (heap);
 	    }
 	  while (1);
 	}
@@ -1244,29 +1272,13 @@ InsertHoles (jmp_buf * e, POLYAREA * dest, PLINE ** src)
       else
 	{
 	  /* link at front of hole list */
-	  tmp = container->next;
+	  curh->next = container->next;
 	  container->next = curh;
-	  curh->next = tmp;
-
-          /* Search for which POLYAREA the containing contour belongs to */
-          /* FIXME: Perhaps store this information in the heap structure? */
-          curc = dest;
-          do
-            {
-              if (curc->contours == container)
-                break;
-            }
-          while ((curc = curc->f) != dest);
-
-          if (curc->contours == container)
-            {
-              r_insert_entry (curc->contour_tree, (BoxTypePtr) curh, 0);
-            }
-          else
-            assert (0);
+	  r_insert_entry (pa_info->pa->contour_tree, (BoxTypePtr) curh, 0);
 	}
     }
   r_destroy_tree (&tree);
+  free (all_pa_info);
 }				/* InsertHoles */

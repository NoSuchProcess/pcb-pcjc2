Bottom: 682fd858497b379d36f503b41d6d16454d86b9f9
Top:    7c6f7e0ec0715f49b1faf8a71ffdd20cdd304fd3
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-04-29 18:20:23 +0100

hid/gtk: Invalidate the damaged region, not the whole view


---

diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index 27d62c6..aca24b6 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -34,6 +34,8 @@ typedef struct render_priv {
   GdkGC *mask_gc;
   GdkGC *u_gc;
   GdkGC *grid_gc;
+  bool clip;
+  GdkRectangle clip_rect;
   int attached_invalidate_depth;
   int mark_invalidate_depth;
 } render_priv;
@@ -119,6 +121,18 @@ ghid_make_gc (void)
 }
 
 static void
+set_clip (render_priv *priv, GdkGC *gc)
+{
+  if (gc == NULL)
+    return;
+
+  if (priv->clip)
+    gdk_gc_set_clip_rectangle (gc, &priv->clip_rect);
+  else
+    gdk_gc_set_clip_mask (gc, NULL);
+}
+
+static void
 ghid_draw_grid (void)
 {
   static GdkPoint *points = 0;
@@ -143,6 +157,8 @@ ghid_draw_grid (void)
       priv->grid_gc = gdk_gc_new (gport->drawable);
       gdk_gc_set_function (priv->grid_gc, GDK_XOR);
       gdk_gc_set_foreground (priv->grid_gc, &gport->grid_color);
+      gdk_gc_set_clip_origin (priv->grid_gc, 0, 0);
+      set_clip (priv, priv->grid_gc);
     }
   x1 = GRIDFIT_X (SIDE_X (gport->view_x0), PCB->Grid);
   y1 = GRIDFIT_Y (SIDE_Y (gport->view_y0), PCB->Grid);
@@ -283,6 +299,8 @@ ghid_use_mask (int use_it)
       if (!priv->mask_gc)
 	{
 	  priv->mask_gc = gdk_gc_new (gport->drawable);
+	  gdk_gc_set_clip_origin (priv->mask_gc, 0, 0);
+	  set_clip (priv, priv->mask_gc);
 	}
       color.pixel = 1;
       gdk_gc_set_foreground (priv->mask_gc, &color);
@@ -495,13 +513,14 @@ use_gc (hidGC gc)
       ghid_set_line_width (gc, gc->width);
       ghid_set_line_cap (gc, (EndCapStyle)gc->cap);
       ghid_set_draw_xor (gc, gc->xor_mask);
+      gdk_gc_set_clip_origin (gc->gc, 0, 0);
     }
   if (gc->mask_seq != mask_seq)
     {
       if (mask_seq)
 	gdk_gc_set_clip_mask (gc->gc, gport->mask);
       else
-	gdk_gc_set_clip_mask (gc->gc, NULL);
+	set_clip (priv, gc->gc);
       gc->mask_seq = mask_seq;
     }
   priv->u_gc = WHICH_GC (gc);
@@ -693,15 +712,7 @@ ghid_fill_rect (hidGC gc, int x1, int y1, int x2, int y2)
 		      x1, y1, x2 - x1 + 1, y2 - y1 + 1);
 }
 
-void
-ghid_invalidate_lr (int left, int right, int top, int bottom)
-{
-  ghid_invalidate_all ();
-}
-
-
-void
-ghid_invalidate_all ()
+void redraw_region (GdkRectangle *rect)
 {
   int eleft, eright, etop, ebottom;
   BoxType region;
@@ -710,10 +721,33 @@ ghid_invalidate_all ()
   if (!gport->pixmap)
     return;
 
-  region.X1 = MIN(Px(0), Px(gport->width + 1));
-  region.Y1 = MIN(Py(0), Py(gport->height + 1));
-  region.X2 = MAX(Px(0), Px(gport->width + 1));
-  region.Y2 = MAX(Py(0), Py(gport->height + 1));
+  if (rect != NULL)
+    {
+      priv->clip_rect = *rect;
+      priv->clip = true;
+    }
+  else
+    {
+      priv->clip_rect.x = 0;
+      priv->clip_rect.y = 0;
+      priv->clip_rect.width = gport->width;
+      priv->clip_rect.height = gport->height;
+      priv->clip = false;
+    }
+
+  set_clip (priv, priv->bg_gc);
+  set_clip (priv, priv->offlimits_gc);
+  set_clip (priv, priv->mask_gc);
+  set_clip (priv, priv->grid_gc);
+
+  region.X1 = MIN(Px(priv->clip_rect.x),
+                  Px(priv->clip_rect.x + priv->clip_rect.width + 1));
+  region.Y1 = MIN(Py(priv->clip_rect.y),
+                  Py(priv->clip_rect.y + priv->clip_rect.height + 1));
+  region.X2 = MAX(Px(priv->clip_rect.x),
+                  Px(priv->clip_rect.x + priv->clip_rect.width + 1));
+  region.Y2 = MAX(Py(priv->clip_rect.y),
+                  Py(priv->clip_rect.y + priv->clip_rect.height + 1));
 
   eleft = Vx (0);
   eright = Vx (PCB->MaxWidth);
@@ -734,28 +768,28 @@ ghid_invalidate_all ()
 
   if (eleft > 0)
     gdk_draw_rectangle (gport->drawable, priv->offlimits_gc,
-			1, 0, 0, eleft, gport->height);
+                        1, 0, 0, eleft, gport->height);
   else
     eleft = 0;
   if (eright < gport->width)
     gdk_draw_rectangle (gport->drawable, priv->offlimits_gc,
-			1, eright, 0, gport->width - eright, gport->height);
+                        1, eright, 0, gport->width - eright, gport->height);
   else
     eright = gport->width;
   if (etop > 0)
     gdk_draw_rectangle (gport->drawable, priv->offlimits_gc,
-			1, eleft, 0, eright - eleft + 1, etop);
+                        1, eleft, 0, eright - eleft + 1, etop);
   else
     etop = 0;
   if (ebottom < gport->height)
     gdk_draw_rectangle (gport->drawable, priv->offlimits_gc,
-			1, eleft, ebottom, eright - eleft + 1,
-			gport->height - ebottom);
+                        1, eleft, ebottom, eright - eleft + 1,
+                        gport->height - ebottom);
   else
     ebottom = gport->height;
 
   gdk_draw_rectangle (gport->drawable, priv->bg_gc, 1,
-		      eleft, etop, eright - eleft + 1, ebottom - etop + 1);
+                      eleft, etop, eright - eleft + 1, ebottom - etop + 1);
 
   ghid_draw_bg_image();
 
@@ -770,11 +804,44 @@ ghid_invalidate_all ()
   if (priv->mark_invalidate_depth == 0)
     DrawMark ();
 
+  priv->clip = false;
+}
+
+void
+ghid_invalidate_lr (int left, int right, int top, int bottom)
+{
+  int dleft, dright, dtop, dbottom;
+  int minx, maxx, miny, maxy;
+  GdkRectangle rect;
+
+  dleft = Vx ((double) left);
+  dright = Vy ((double) right);
+  dtop = Vx ((double) top);
+  dbottom = Vy ((double) bottom);
+
+  minx = MIN (dleft, dright);
+  maxx = MAX (dleft, dright);
+  miny = MIN (dtop, dbottom);
+  maxy = MAX (dtop, dbottom);
+
+  rect.x = minx;
+  rect.y = miny;
+  rect.width = maxx - minx;
+  rect.height = maxy - miny;
+
+  redraw_region (&rect);
   ghid_screen_update ();
 }
 
 
 void
+ghid_invalidate_all ()
+{
+  redraw_region (NULL);
+  ghid_screen_update ();
+}
+
+void
 ghid_notify_crosshair_change (bool changes_complete)
 {
   render_priv *priv = gport->render_priv;
@@ -949,6 +1016,7 @@ draw_crosshair (GdkGC *xor_gc, gint x, gint y)
 static void
 show_crosshair (gboolean paint_new_location)
 {
+  render_priv *priv = gport->render_priv;
   gint x, y;
   static gint x_prev = -1, y_prev = -1;
   static gboolean draw_markers, draw_markers_prev = FALSE;
@@ -963,6 +1031,8 @@ show_crosshair (gboolean paint_new_location)
       xor_gc = gdk_gc_new (ghid_port.drawing_area->window);
       gdk_gc_copy (xor_gc, ghid_port.drawing_area->style->white_gc);
       gdk_gc_set_function (xor_gc, GDK_XOR);
+      gdk_gc_set_clip_origin (xor_gc, 0, 0);
+      set_clip (priv, xor_gc);
       /* FIXME: when CrossColor changed from config */
       ghid_map_color_string (Settings.CrossColor, &cross_color);
     }
@@ -1035,9 +1105,11 @@ ghid_drawing_area_configure_hook (GHidPort *port)
     {
       priv->bg_gc = gdk_gc_new (port->drawable);
       gdk_gc_set_foreground (priv->bg_gc, &port->bg_color);
+      gdk_gc_set_clip_origin (priv->bg_gc, 0, 0);
 
       priv->offlimits_gc = gdk_gc_new (port->drawable);
       gdk_gc_set_foreground (priv->offlimits_gc, &port->offlimits_color);
+      gdk_gc_set_clip_origin (priv->offlimits_gc, 0, 0);
       done_once = 1;
     }

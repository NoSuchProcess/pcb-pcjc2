Bottom: 266d17396a6c44ce2322dbd6fb5081e8acaf09fc
Top:    9e393a2d1d67c2e4aecaf36843ad2fa82f5ee5d8
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-04-21 02:41:14 +0100

Demo of exporter specific export routine


---

diff --git a/src/draw.c b/src/draw.c
index 865bab2..8b9b86a 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -645,32 +645,22 @@ DrawTop (const BoxType * screen)
     r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
 }
 
-struct pin_info
-{
-  bool arg;
-  LayerTypePtr Layer;
-};
-
 static int
 clearPin_callback (const BoxType * b, void *cl)
 {
   PinType *pin = (PinTypePtr) b;
-  struct pin_info *i = (struct pin_info *) cl;
-  if (i->arg)
-    {
-      if (TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG (THINDRAWPOLYFLAG, PCB))
-        gui->thindraw_pcb_pv (Output.pmGC, Output.pmGC, pin, false, true);
-      else
-        gui->fill_pcb_pv (Output.pmGC, Output.pmGC, pin, false, true);
-    }
+  if (TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG (THINDRAWPOLYFLAG, PCB))
+    gui->thindraw_pcb_pv (Output.pmGC, Output.pmGC, pin, false, true);
+  else
+    gui->fill_pcb_pv (Output.pmGC, Output.pmGC, pin, false, true);
   return 1;
 }
 static int
 poly_callback (const BoxType * b, void *cl)
 {
-  struct pin_info *i = (struct pin_info *) cl;
+  LayerType *layer = cl;
 
-  DrawPlainPolygon (i->Layer, (PolygonTypePtr) b);
+  DrawPlainPolygon (layer, (PolygonTypePtr) b);
   return 1;
 }
 
@@ -694,7 +684,6 @@ DrawSilk (int new_swap, int layer, const BoxType * drawn_area)
   /* This code is used when you want to mask silk to avoid exposed
      pins and pads.  We decided it was a bad idea to do this
      unconditionally, but the code remains.  */
-  struct pin_info info;
 #endif
   int save_swap = SWAP_IDENT;
   SWAP_IDENT = new_swap;
@@ -714,10 +703,9 @@ DrawSilk (int new_swap, int layer, const BoxType * drawn_area)
     }
 
   gui->use_mask (HID_MASK_CLEAR);
-  info.arg = true;
-  r_search (PCB->Data->pin_tree, drawn_area, NULL, clearPin_callback, &info);
-  r_search (PCB->Data->via_tree, drawn_area, NULL, clearPin_callback, &info);
-  r_search (PCB->Data->pad_tree, drawn_area, NULL, clearPad_callback, &info);
+  r_search (PCB->Data->pin_tree, drawn_area, NULL, clearPin_callback, NULL);
+  r_search (PCB->Data->via_tree, drawn_area, NULL, clearPin_callback, NULL);
+  r_search (PCB->Data->pad_tree, drawn_area, NULL, clearPad_callback, NULL);
 
   if (gui->poly_after)
     {
@@ -758,11 +746,8 @@ DrawMaskBoardArea (int mask_type, BoxType *screen)
 static void
 DrawMask (BoxType * screen)
 {
-  struct pin_info info;
   int thin = TEST_FLAG(THINDRAWFLAG, PCB) || TEST_FLAG(THINDRAWPOLYFLAG, PCB);
 
-  info.arg = true;
-
   if (thin)
     gui->set_color (Output.pmGC, PCB->MaskColor);
   else
@@ -771,9 +756,9 @@ DrawMask (BoxType * screen)
       gui->use_mask (HID_MASK_CLEAR);
     }
 
-  r_search (PCB->Data->pin_tree, screen, NULL, clearPin_callback, &info);
-  r_search (PCB->Data->via_tree, screen, NULL, clearPin_callback, &info);
-  r_search (PCB->Data->pad_tree, screen, NULL, clearPad_callback, &info);
+  r_search (PCB->Data->pin_tree, screen, NULL, clearPin_callback, NULL);
+  r_search (PCB->Data->via_tree, screen, NULL, clearPin_callback, NULL);
+  r_search (PCB->Data->pad_tree, screen, NULL, clearPad_callback, NULL);
 
   if (thin)
     gui->set_color (Output.pmGC, "erase");
@@ -829,13 +814,9 @@ text_callback (const BoxType * b, void *cl)
 void
 DrawLayerCommon (LayerTypePtr Layer, const BoxType * screen, bool clear_pins)
 {
-  struct pin_info info;
-
   /* print the non-clearing polys */
-  info.Layer = Layer;
-  info.arg = clear_pins;
   clip_box = screen;
-  r_search (Layer->polygon_tree, screen, NULL, poly_callback, &info);
+  r_search (Layer->polygon_tree, screen, NULL, poly_callback, Layer);
 
   if (clear_pins && TEST_FLAG (CHECKPLANESFLAG, PCB))
     return;
diff --git a/src/hid/common/draw_helpers.c b/src/hid/common/draw_helpers.c
index b043d92..66e82bf 100644
--- a/src/hid/common/draw_helpers.c
+++ b/src/hid/common/draw_helpers.c
@@ -1,6 +1,10 @@
 #include "global.h"
 #include "hid.h"
 #include "polygon.h"
+#include "rtree.h"
+#include "misc.h"
+#include "print.h" /* FIXME */
+#include "data.h" /* FIXME */
 
 static void
 fill_contour (hidGC gc, PLINE *pl)
@@ -475,3 +479,267 @@ common_draw_helpers_init (HID *hid)
   hid->fill_pcb_pv          = common_fill_pcb_pv;
   hid->thindraw_pcb_pv      = common_thindraw_pcb_pv;
 }
+
+
+struct pin_info
+{
+  bool arg;
+  LayerTypePtr Layer;
+};
+
+/* ---------------------------------------------------------------------------
+ * draws one non-copper layer
+ */
+void
+DrawLayerCommon (LayerTypePtr Layer, const BoxType * screen, bool clear_pins)
+{
+  struct pin_info info;
+
+  /* print the non-clearing polys */
+  info.Layer = Layer;
+  info.arg = clear_pins;
+  clip_box = screen;
+  r_search (Layer->polygon_tree, screen, NULL, poly_callback, &info);
+
+  if (clear_pins && TEST_FLAG (CHECKPLANESFLAG, PCB))
+    return;
+
+  /* draw all visible lines this layer */
+  r_search (Layer->line_tree, screen, NULL, line_callback, Layer);
+
+  /* draw the layer arcs on screen */
+  r_search (Layer->arc_tree, screen, NULL, arc_callback, Layer);
+
+  /* draw the layer text on screen */
+  r_search (Layer->text_tree, screen, NULL, text_callback, Layer);
+
+  /* We should check for gui->gui here, but it's kinda cool seeing the
+     auto-outline magically disappear when you first add something to
+     the "outline" layer.  */
+  if (IsLayerEmpty (Layer) && (strcmp (Layer->Name, "outline") == 0 ||
+                               strcmp (Layer->Name, "route") == 0))
+    {
+      gui->set_color (Output.fgGC, Layer->Color);
+      gui->set_line_width (Output.fgGC, PCB->minWid);
+      gui->draw_rect (Output.fgGC,
+                      0, 0,
+                      PCB->MaxWidth, PCB->MaxHeight);
+    }
+
+  clip_box = NULL;
+}
+
+/* ---------------------------------------------------------------------------
+ * draws one layer group.  Returns non-zero if pins and pads should be
+ * drawn with this group.
+ */
+static int
+DrawLayerGroup (int group, const BoxType * screen)
+{
+  int i, rv = 1;
+  int layernum;
+  LayerTypePtr Layer;
+  int n_entries = PCB->LayerGroups.Number[group];
+  Cardinal *layers = PCB->LayerGroups.Entries[group];
+
+  clip_box = screen;
+  for (i = n_entries - 1; i >= 0; i--)
+    {
+      layernum = layers[i];
+      Layer = PCB->Data->Layer + layers[i];
+      if (strcmp (Layer->Name, "outline") == 0 ||
+          strcmp (Layer->Name, "route") == 0)
+        rv = 0;
+      if (layernum < max_copper_layer)
+        DrawLayerCommon (Layer, screen, true);
+    }
+  if (n_entries > 1)
+    rv = 1;
+  return rv;
+}
+
+typedef struct
+{
+  int nplated;
+  int nunplated;
+} HoleCountStruct;
+
+static int
+hole_counting_callback (const BoxType * b, void *cl)
+{
+  PinTypePtr pin = (PinTypePtr) b;
+  HoleCountStruct *hcs = cl;
+  if (TEST_FLAG (HOLEFLAG, pin))
+    hcs->nunplated++;
+  else
+    hcs->nplated++;
+  return 1;
+}
+
+static void
+count_holes (BoxType *region, int *plated, int *unplated)
+{
+  HoleCountStruct hcs;
+  hcs.nplated = hcs.nunplated = 0;
+  r_search (PCB->Data->pin_tree, region, NULL, hole_counting_callback, &hcs);
+  r_search (PCB->Data->via_tree, region, NULL, hole_counting_callback, &hcs);
+  if (plated != NULL) *plated = hcs.nplated;
+  if (unplated != NULL) *unplated = hcs.nunplated;
+}
+
+static int
+hole_callback (const BoxType * b, void *cl)
+{
+  PinTypePtr pin = (PinTypePtr) b;
+  int plated = cl ? *(int *) cl : -1;
+
+  if ((plated == 0 && !TEST_FLAG (HOLEFLAG, pin)) ||
+      (plated == 1 &&  TEST_FLAG (HOLEFLAG, pin)))
+    return 1;
+
+  //DrawHole ((PinTypePtr) b);
+  return 1;
+}
+
+static int
+pin_callback (const BoxType * b, void *cl)
+{
+  //DrawPlainPin ((PinTypePtr) b, false);
+  return 1;
+}
+
+static int
+pad_callback (const BoxType * b, void *cl)
+{
+  PadTypePtr pad = (PadTypePtr) b;
+  //if (FRONT (pad))
+    //DrawPad (pad, 0);
+  return 1;
+}
+
+static bool
+IsPasteEmpty (int side)
+{
+  bool paste_empty = true;
+  ALLPAD_LOOP (PCB->Data);
+  {
+    if (TEST_FLAG (ONSOLDERFLAG, pad) == (side == SOLDER_LAYER) &&
+        !TEST_FLAG (NOPASTEFLAG, pad) && pad->Mask > 0)
+      {
+        paste_empty = false;
+        break;
+      }
+  }
+  ENDALL_LOOP;
+  return paste_empty;
+}
+
+static void
+DrawPaste (int side)
+{
+  gui->set_color (Output.fgGC, PCB->ElementColor);
+  ALLPAD_LOOP (PCB->Data);
+  {
+    if (TEST_FLAG (ONSOLDERFLAG, pad) == (side == SOLDER_LAYER) &&
+        !TEST_FLAG (NOPASTEFLAG, pad) && pad->Mask > 0)
+      {
+        //if (pad->Mask < pad->Thickness)
+          //DrawPadLowLevel (Output.fgGC, pad, true, true);
+        //else
+          //DrawPadLowLevel (Output.fgGC, pad, false, false);
+      }
+  }
+  ENDALL_LOOP;
+}
+
+void
+common_export_region (HID *hid, BoxType *region)
+{
+  int plated;
+  int nplated;
+  int nunplated;
+  int component_group;
+  int solder_group;
+  int group;
+  int save_swap = SWAP_IDENT;
+  bool paste_empty;
+
+  PCB->Data->SILKLAYER.Color = PCB->ElementColor;
+  PCB->Data->BACKSILKLAYER.Color = PCB->InvisibleObjectsColor;
+
+  component_group = GetLayerGroupNumberByNumber (component_silk_layer);
+  solder_group    = GetLayerGroupNumberByNumber (solder_silk_layer);
+
+  /* draw all copper layer groups in group order */
+  for (group = 0; group < max_copper_layer; group++)
+    {
+      if (gui->set_layer (0, group, 0))
+        {
+          if (DrawLayerGroup (group, drawn_area))
+            {
+              r_search (PCB->Data->via_tree, drawn_area, NULL, pin_callback, NULL);
+              r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_callback, NULL);
+
+              if (group == component_group || group == solder_group)
+                {
+                  SWAP_IDENT = (group == solder_group);
+                  r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, NULL);
+                  SWAP_IDENT = save_swap;
+                }
+            }
+        }
+    }
+
+  count_holes (drawn_area, &nplated, &nunplated);
+
+  if (nplated && gui->set_layer ("plated-drill", SL (PDRILL, 0), 0))
+    {
+      plated = 1;
+      r_search (PCB->Data->pin_tree, drawn_area, NULL, hole_callback, &plated);
+      r_search (PCB->Data->via_tree, drawn_area, NULL, hole_callback, &plated);
+    }
+
+  if (nunplated && gui->set_layer ("unplated-drill", SL (UDRILL, 0), 0))
+    {
+      plated = 0;
+      r_search (PCB->Data->pin_tree, drawn_area, NULL, hole_callback, &plated);
+      r_search (PCB->Data->via_tree, drawn_area, NULL, hole_callback, &plated);
+    }
+
+  if (gui->set_layer ("componentmask", SL (MASK, TOP), 0))
+    {
+      SWAP_IDENT = 0;
+      DrawMask (drawn_area);
+      SWAP_IDENT = save_swap;
+    }
+
+  if (gui->set_layer ("soldermask", SL (MASK, BOTTOM), 0))
+    {
+      SWAP_IDENT = 1;
+      DrawMask (drawn_area);
+      SWAP_IDENT = save_swap;
+    }
+
+  if (gui->set_layer ("topsilk", SL (SILK, TOP), 0))
+    DrawSilk (0, component_silk_layer, drawn_area);
+
+  if (gui->set_layer ("bottomsilk", SL (SILK, BOTTOM), 0))
+    DrawSilk (1, solder_silk_layer, drawn_area);
+
+  paste_empty = IsPasteEmpty (COMPONENT_LAYER);
+  if (gui->set_layer ("toppaste", SL (PASTE, TOP), paste_empty))
+    DrawPaste (COMPONENT_LAYER);
+
+  paste_empty = IsPasteEmpty (SOLDER_LAYER);
+  if (gui->set_layer ("bottompaste", SL (PASTE, BOTTOM), paste_empty))
+    DrawPaste (SOLDER_LAYER);
+
+  //if (gui->set_layer ("topassembly", SL (ASSY, TOP), 0))
+    //PrintAssembly (drawn_area, component_group, 0);
+
+  if (gui->set_layer ("bottomassembly", SL (ASSY, BOTTOM), 0))
+    PrintAssembly (drawn_area, solder_group, 1);
+
+  if (gui->set_layer ("fab", SL (FAB, 0), 0))
+    PrintFab ();
+}

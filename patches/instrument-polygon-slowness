Bottom: d9893c5a5f6b9b8aec32bd42957293b9edc6c86b
Top:    5a64f4a1e31419df5c480d67f83ca130f27d2f63
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-02-06 20:38:05 +0000

Instrument polygon slowness


---

diff --git a/src/polygon1.c b/src/polygon1.c
index 8ade932..129faa3 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -1165,10 +1165,15 @@ PutContour (jmp_buf * e, PLINE * cntr, POLYAREA ** contours, PLINE ** holes,
   assert (cntr->Count > 2);
   cntr->next = NULL;
 
+  printf ("PutContour %p, %p, %p, %p, %p, %p\n",
+          cntr, contours, holes, owner, parent, parent_contour);
+
   if (cntr->Flags.orient == PLF_DIR)
     {
-      if (owner != NULL)
+      if (owner != NULL) {
+        printf ("PATH 1\n");
         r_delete_entry (owner->contour_tree, (BoxType *)cntr);
+      }
       InsCntr (e, cntr, contours);
     }
   /* put hole into temporary list */
@@ -1181,8 +1186,10 @@ PutContour (jmp_buf * e, PLINE * cntr, POLYAREA ** contours, PLINE ** holes,
 	  parent_contour->next = cntr;
           if (owner != parent)
             {
-              if (owner != NULL)
+              if (owner != NULL) {
+                printf ("PATH 2\n");
                 r_delete_entry (owner->contour_tree, (BoxType *)cntr);
+              }
               r_insert_entry (parent->contour_tree, (BoxType *)cntr, 0);
             }
 	}
@@ -1192,8 +1199,10 @@ PutContour (jmp_buf * e, PLINE * cntr, POLYAREA ** contours, PLINE ** holes,
 	  *holes = cntr;	/* let cntr be 1st hole in list */
           /* We don't insert the holes into an r-tree,
            * they just form a linked list */
-          if (owner != NULL)
+          if (owner != NULL) {
+            printf ("PATH 3\n");
             r_delete_entry (owner->contour_tree, (BoxType *)cntr);
+          }
 	}
     }
 }				/* PutContour */
@@ -1547,6 +1556,7 @@ Collect1 (jmp_buf * e, VNODE *cur, DIRECTION dir, POLYAREA **contours, PLINE **
 	    DEBUGP ("adding contour with %d verticies and direction %c\n",
 		    p->Count, p->Flags.orient ? 'F' : 'B');
 #endif
+            printf ("1: ");
 	    PutContour (e, p, contours, holes, NULL, NULL, NULL);
 	  }
 	else
@@ -1585,6 +1595,9 @@ cntr_Collect (jmp_buf * e, PLINE ** A, POLYAREA ** contours, PLINE ** holes,
 {
   PLINE *tmprev;
 
+  printf ("cntr_Collect %p, %p, %p, %i, %p, %p, %p\n",
+          A, contours, holes, action, owner, parent, parent_contour);
+
   if ((*A)->Flags.status == ISECTED)
     {
       switch (action)
@@ -1614,6 +1627,7 @@ cntr_Collect (jmp_buf * e, PLINE ** A, POLYAREA ** contours, PLINE ** holes,
 	      /* disappear this contour (rtree entry remove int PutContour) */
 	      *A = tmprev->next;
 	      tmprev->next = NULL;
+              printf ("2: ");
 	      PutContour (e, tmprev, contours, holes, owner, NULL, NULL);
 	      return TRUE;
 	    }
@@ -1626,6 +1640,7 @@ cntr_Collect (jmp_buf * e, PLINE ** A, POLYAREA ** contours, PLINE ** holes,
 	      *A = tmprev->next;
 	      tmprev->next = NULL;
 	      poly_InvContour (tmprev);
+              printf ("3: ");
 	      PutContour (e, tmprev, contours, holes, owner, NULL, NULL);
 	      return TRUE;
 	    }
@@ -1638,6 +1653,7 @@ cntr_Collect (jmp_buf * e, PLINE ** A, POLYAREA ** contours, PLINE ** holes,
 	      /* disappear this contour (rtree entry remove int PutContour) */
 	      *A = tmprev->next;
 	      tmprev->next = NULL;
+              printf ("4: ");
 	      PutContour (e, tmprev, contours, holes, owner, parent, parent_contour);
 	      return TRUE;
 	    }
@@ -1675,6 +1691,7 @@ M_B_AREA_Collect (jmp_buf * e, POLYAREA * bfst, POLYAREA ** contours,
 		next = cur;
 		tmp->next = NULL;
 		tmp->Flags.status = UNKNWN;
+                printf ("5: ");
 		PutContour (e, tmp, contours, holes, NULL, NULL, NULL); /* b */
 		break;
 	      case PBO_UNITE:
@@ -1691,6 +1708,7 @@ M_B_AREA_Collect (jmp_buf * e, POLYAREA * bfst, POLYAREA ** contours,
 		next = cur;
 		tmp->next = NULL;
 		tmp->Flags.status = UNKNWN;
+                printf ("6: ");
 		PutContour (e, tmp, contours, holes, NULL, NULL, NULL); /* b */
 		break;
 	      case PBO_ISECT:
@@ -1711,6 +1729,9 @@ M_POLYAREA_Collect (jmp_buf * e, POLYAREA * afst, POLYAREA ** contours,
   POLYAREA *parent = NULL; /* Quiet GCC warning */
   PLINE **cur, **next, *parent_contour;
 
+  printf ("M_POLYAREA_Collect %p, %p, %p, %i, %i\n",
+          afst, contours, holes, action, maybe);
+
   assert (a != NULL);
   while ((a = a->f) != afst);
   /* now the non-intersect parts are collected in temp/holes */
@@ -1729,6 +1750,7 @@ M_POLYAREA_Collect (jmp_buf * e, POLYAREA * afst, POLYAREA ** contours,
         {
           next = &((*cur)->next);
           /* if we disappear a contour, don't advance twice */
+          printf ("1: ");
           if (cntr_Collect (e, cur, contours, holes, action, a, NULL, NULL))
             {
               parent = *contours;
@@ -1744,6 +1766,7 @@ M_POLYAREA_Collect (jmp_buf * e, POLYAREA * afst, POLYAREA ** contours,
           /* if we disappear a contour, don't advance twice */
           if (*cur == parent_contour)
             printf ("WTF??\n");
+          printf ("2: ");
           if (cntr_Collect (e, cur, contours, holes, action, a, parent,
                             (*cur == parent_contour) ? NULL : parent_contour))
             next = cur;
@@ -1767,8 +1790,8 @@ Touching (POLYAREA * a, POLYAREA * b)
       if (!poly_Valid (b))
 	return -1;
 #endif
-//      M_POLYAREA_intersect (&e, a, b, False);
-      M_POLYAREA_intersect2 (&e, a, b, False);
+      M_POLYAREA_intersect (&e, a, b, False);
+//      M_POLYAREA_intersect2 (&e, a, b, False);
 
       if (M_POLYAREA_label (a, b, TRUE))
 	return TRUE;
@@ -1808,6 +1831,7 @@ poly_Boolean (const POLYAREA * a_org, const POLYAREA * b_org,
       M_POLYAREA_label (a, b, FALSE);
       M_POLYAREA_label (b, a, FALSE);
 
+      printf ("1:");
       M_POLYAREA_Collect (&e, a, res, &holes, action, b->f == b
 			  && !b->contours->next
 			  && b->contours->Flags.status != ISECTED);
@@ -1878,9 +1902,16 @@ poly_Boolean_free (POLYAREA * ai, POLYAREA * bi, POLYAREA ** res, int action)
 
       M_POLYAREA_intersect (&e, a, b, TRUE);
 
+      /* intersect needs to make a list of the contours in a and b which are relevant) */
+      /* Not sure if this needs to invlude any wholey containing, but non-intersecting contours */
+
+      /* We could speed things up a little here if we only processed the relevant contours */
       M_POLYAREA_label (a, b, FALSE);
       M_POLYAREA_label (b, a, FALSE);
 
+      printf ("2:");
+      /* And speed things up _A LOT_ here by only processing the relevant contours, specifically
+         keeping the source "a" as a starting point for the output polygon */
       M_POLYAREA_Collect (&e, a, res, &holes, action, b->f == b
 			  && !b->contours->next
 			  && b->contours->Flags.status != ISECTED);
@@ -1957,6 +1988,7 @@ poly_AndSubtract_free (POLYAREA * ai, POLYAREA * bi,
       M_POLYAREA_label (a, b, FALSE);
       M_POLYAREA_label (b, a, FALSE);
 
+      printf ("3:");
       M_POLYAREA_Collect (&e, a, aandb, &holes, PBO_ISECT, FALSE);
       InsertHoles (&e, *aandb, &holes);
       assert (poly_Valid (*aandb));
@@ -1969,6 +2001,7 @@ poly_AndSubtract_free (POLYAREA * ai, POLYAREA * bi,
       holes = NULL;
       clear_marks (a);
       clear_marks (b);
+      printf ("4:");
       M_POLYAREA_Collect (&e, a, aminusb, &holes, PBO_SUB, FALSE);
       InsertHoles (&e, *aminusb, &holes);
       poly_Free (&a);

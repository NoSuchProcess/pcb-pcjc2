Bottom: c105623658d88d9a98179340012819161b45c9e8
Top:    76f6972a119098d8aadcb0a268fdde2bd4c20356
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-04-01 13:40:25 +0100

Add raw polygons support for the GTK HID, bypassing the no-holes dicer




















---

diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index 143735a..5f3f276 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -36,7 +36,7 @@
 
 #include "hid.h"
 #include "hidgl.h"
-
+#include "rtree.h"
 
 
 #ifdef HAVE_LIBDMALLOC
@@ -469,6 +469,8 @@ myBegin (GLenum type)
   triangle_comp_idx = 0;
 }
 
+static double global_scale;
+
 static void
 myVertex (GLdouble *vertex_data)
 {
@@ -485,11 +487,23 @@ myVertex (GLdouble *vertex_data)
         }
       else
         {
+#if 1
           hidgl_ensure_triangle_space (&buffer, 1);
           hidgl_add_triangle (&buffer,
                               triangle_vertices [0], triangle_vertices [1],
                               triangle_vertices [2], triangle_vertices [3],
                               vertex_data [0], vertex_data [1]);
+#else
+          hidgl_draw_line (Square_Cap, global_scale,
+                           triangle_vertices [0], triangle_vertices [1],
+                           triangle_vertices [2], triangle_vertices [3], global_scale);
+          hidgl_draw_line (Square_Cap, global_scale,
+                           triangle_vertices [2], triangle_vertices [3],
+                           vertex_data [0],       vertex_data [1],       global_scale);
+          hidgl_draw_line (Square_Cap, global_scale,
+                           vertex_data [0],       vertex_data [1],
+                           triangle_vertices [0], triangle_vertices [1], global_scale);
+#endif
 
           if (tessVertexType == GL_TRIANGLE_STRIP)
             {
@@ -560,6 +574,105 @@ hidgl_fill_polygon (int n_coords, int *x, int *y)
   free (vertices);
 }
 
+void tesselate_contour (GLUtesselator *tobj, VNODE *vnode,
+                        GLdouble *vertices, int *i)
+{
+  VNODE *vn = vnode;
+  int offset = *i * 3;
+
+  gluTessBeginContour (tobj);
+  do {
+    vertices [0 + offset] = vn->point[0];
+    vertices [1 + offset] = vn->point[1];
+    vertices [2 + offset] = 0.;
+    gluTessVertex (tobj, &vertices [offset], &vertices [offset]);
+    (*i)++;
+    offset += 3;
+  } while ((vn = vn->next) != vnode);
+  gluTessEndContour (tobj);
+}
+
+struct do_hole_info {
+  GLUtesselator *tobj;
+  GLdouble *vertices;
+  int *i;
+};
+
+static int
+do_hole (const BoxType *b, void *cl)
+{
+  struct do_hole_info *info = cl;
+  PLINE *curc = (PLINE *) b;
+  /* Ignore the outer contour - we draw it first explicitly*/
+  if (curc->Flags.orient == PLF_DIR) {
+    return 0;
+  }
+  tesselate_contour (info->tobj, &curc->head, info->vertices, info->i);
+  return 1;
+}
+
+void
+hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale)
+{
+  int i, cc;
+  GLUtesselator *tobj;
+  GLdouble *vertices;
+  int vertex_count = 0;
+  POLYAREA *piece;
+  PLINE *contour;
+
+  global_scale = scale;
+
+  if (poly->Clipped == NULL) {
+    fprintf (stderr, "hidgl_fill_pcb_polygon: poly->Clipped == NULL\n");
+    return;
+  }
+
+  /* JUST DRAW THE FIRST PIECE */
+  /* Walk the polygon structure, counting vertices */
+  /* This gives an upper bound on the amount of storage required */
+  piece = poly->Clipped;
+//  do {
+    for (contour = piece->contours; contour != NULL; contour = contour->next)
+      vertex_count += contour->Count;
+//  } while ((piece = piece->f) != poly->Clipped);
+
+  vertices = malloc (sizeof(GLdouble) * vertex_count * 3);
+
+  tobj = gluNewTess ();
+  gluTessCallback(tobj, GLU_TESS_BEGIN, myBegin);
+  gluTessCallback(tobj, GLU_TESS_VERTEX, myVertex);
+  gluTessCallback(tobj, GLU_TESS_COMBINE, myCombine);
+  gluTessCallback(tobj, GLU_TESS_ERROR, myError);
+
+  gluTessBeginPolygon (tobj, NULL);
+
+  /* JUST DRAW THE FIRST PIECE */
+  /* Walk the polygon structure, adding the vertices */
+  i = 0;
+  cc = 1;
+  piece = poly->Clipped;
+  do {
+    struct do_hole_info info;
+    info.tobj = tobj;
+    info.vertices = vertices;
+    info.i = &i;
+
+    tesselate_contour (tobj, &piece->contours->head, vertices, &i);
+
+    /* Search for a contour to draw */
+    r_search (piece->contour_tree, clip_box, NULL, do_hole, &info);
+
+  } while (0);
+//  } while ((piece = piece->f) != poly->Clipped);
+
+  gluTessEndPolygon (tobj);
+  gluDeleteTess (tobj);
+
+  myFreeCombined ();
+  free (vertices);
+}
+
 void
 hidgl_fill_rect (int x1, int y1, int x2, int y2)
 {
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index fc2d41a..f7a6aeb 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -63,6 +63,7 @@ void hidgl_draw_arc (double width, int vx, int vy, int vrx, int vry, int start_a
 void hidgl_draw_rect (int x1, int y1, int x2, int y2);
 void hidgl_fill_circle (int vx, int vy, int vr, double scale);
 void hidgl_fill_polygon (int n_coords, int *x, int *y);
+void hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale);
 void hidgl_fill_rect (int x1, int y1, int x2, int y2);
 
 
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 0e3e6e3..a102426 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -926,6 +926,14 @@ ghid_fill_polygon (hidGC gc, int n_coords, int *x, int *y)
 }
 
 void
+ghid_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+{
+  USE_GC (gc);
+
+  hidgl_fill_pcb_polygon (poly, clip_box, gport->zoom);
+}
+
+void
 ghid_fill_rect (hidGC gc, int x1, int y1, int x2, int y2)
 {
   USE_GC (gc);
@@ -1444,7 +1452,7 @@ HID ghid_hid = {
   ghid_draw_rect,
   ghid_fill_circle,
   ghid_fill_polygon,
-  common_fill_pcb_polygon,
+  ghid_fill_pcb_polygon,
   common_thindraw_pcb_polygon,
   ghid_fill_rect,

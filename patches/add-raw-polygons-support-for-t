Bottom: 1de6213970c67b9c0aa53674d92d085b6114f62e
Top:    0993971b895596fb8c398268fef72231bde8adf8
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-08-13 01:45:41 +0100

Add raw polygons support for the GTK HID, bypassing the no-holes dicer

Uses the OpenGL stencil buffer to make drawing polygons with holes faster.

1. Turn Stenciling on, updates to colour buffer off
2. Clear stencil buffer to 0
3. Paint polygon holes, setting those areas of the stencil buffer to 1
4. Switch on stencil test (== 0), turn on updates to colour buffer
5. Paint outer polygon through areas of the stencil buffer still 0
6. Clear stencil buffer, switch off stencilling.

** BUGS? **

Probably throws up if the function is used whilst drawing the mask,
since that uses stenciling as well, and they don't know to co-operate.

For now, we don't use polygons on the mask, so its not a a problem (?).
(OR do we.. for some pins?)


---

diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index b0a5049..4594c63 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -36,6 +36,7 @@
 
 #include "hid.h"
 #include "hidgl.h"
+#include "rtree.h"
 
 
 #ifdef HAVE_LIBDMALLOC
@@ -478,6 +479,8 @@ myBegin (GLenum type)
   triangle_comp_idx = 0;
 }
 
+static double global_scale;
+
 static void
 myVertex (GLdouble *vertex_data)
 {
@@ -494,11 +497,23 @@ myVertex (GLdouble *vertex_data)
         }
       else
         {
+#if 1
           hidgl_ensure_triangle_space (&buffer, 1);
           hidgl_add_triangle (&buffer,
                               triangle_vertices [0], triangle_vertices [1],
                               triangle_vertices [2], triangle_vertices [3],
                               vertex_data [0], vertex_data [1]);
+#else
+          hidgl_draw_line (Square_Cap, global_scale,
+                           triangle_vertices [0], triangle_vertices [1],
+                           triangle_vertices [2], triangle_vertices [3], global_scale);
+          hidgl_draw_line (Square_Cap, global_scale,
+                           triangle_vertices [2], triangle_vertices [3],
+                           vertex_data [0],       vertex_data [1],       global_scale);
+          hidgl_draw_line (Square_Cap, global_scale,
+                           vertex_data [0],       vertex_data [1],
+                           triangle_vertices [0], triangle_vertices [1], global_scale);
+#endif
 
           if (tessVertexType == GL_TRIANGLE_STRIP)
             {
@@ -569,6 +584,114 @@ hidgl_fill_polygon (int n_coords, int *x, int *y)
   free (vertices);
 }
 
+void tesselate_contour (GLUtesselator *tobj, VNODE *vnode,
+                        GLdouble *vertices, int *i)
+{
+  VNODE *vn = vnode;
+  int offset = *i * 3;
+
+  gluTessBeginContour (tobj);
+  do {
+    vertices [0 + offset] = vn->point[0];
+    vertices [1 + offset] = vn->point[1];
+    vertices [2 + offset] = 0.;
+    gluTessVertex (tobj, &vertices [offset], &vertices [offset]);
+    (*i)++;
+    offset += 3;
+  } while ((vn = vn->next) != vnode);
+  gluTessEndContour (tobj);
+}
+
+struct do_hole_info {
+  GLUtesselator *tobj;
+  GLdouble *vertices;
+  int *i;
+};
+
+static int
+do_hole (const BoxType *b, void *cl)
+{
+  struct do_hole_info *info = cl;
+  PLINE *curc = (PLINE *) b;
+
+  /* Ignore the outer contour - we draw it first explicitly*/
+  if (curc->Flags.orient == PLF_DIR) {
+    return 0;
+  }
+  gluTessBeginPolygon (info->tobj, NULL);
+  tesselate_contour (info->tobj, &curc->head, info->vertices, info->i);
+  gluTessEndPolygon (info->tobj);
+  return 1;
+}
+
+void
+hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale)
+{
+  int i, cc;
+  int vertex_count = 0;
+  PLINE *contour;
+  struct do_hole_info info;
+
+
+  global_scale = scale;
+
+  if (poly->Clipped == NULL) {
+    fprintf (stderr, "hidgl_fill_pcb_polygon: poly->Clipped == NULL\n");
+    return;
+  }
+
+  /* TODO: Just draw our triangles, no need to flush the buffer */
+  hidgl_flush_triangles (&buffer);
+
+  /* JUST DRAW THE FIRST PIECE */
+  /* Walk the polygon structure, counting vertices */
+  /* This gives an upper bound on the amount of storage required */
+  for (contour = poly->Clipped->contours;
+       contour != NULL; contour = contour->next)
+    vertex_count += contour->Count;
+
+  info.vertices = malloc (sizeof(GLdouble) * vertex_count * 3);
+  info.tobj = gluNewTess ();
+  info.i = &i;
+  gluTessCallback(info.tobj, GLU_TESS_BEGIN, myBegin);
+  gluTessCallback(info.tobj, GLU_TESS_VERTEX, myVertex);
+  gluTessCallback(info.tobj, GLU_TESS_COMBINE, myCombine);
+  gluTessCallback(info.tobj, GLU_TESS_ERROR, myError);
+
+  glClearStencil (0);
+  glClear (GL_STENCIL_BUFFER_BIT);
+  glColorMask (0, 0, 0, 0);                   // Disable writting in color buffer
+  glEnable (GL_STENCIL_TEST);
+
+  i = 0;
+  cc = 1;
+
+  /* Drawing operations set the stencil buffer to '1' */
+  glStencilFunc (GL_ALWAYS, 1, 1);            // Test always passes, value written 1
+  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value (with 1)
+
+  r_search (poly->Clipped->contour_tree, clip_box, NULL, do_hole, &info);
+  hidgl_flush_triangles (&buffer);
+
+  /* Drawing operations as masked to areas where the stencil buffer is '1' */
+  glColorMask (1, 1, 1, 1);                   // Enable drawing of r, g, b & a
+  glStencilFunc (GL_EQUAL, 0, 1);             // Draw only where stencil buffer is 0
+  glStencilOp (GL_KEEP, GL_KEEP, GL_KEEP);    // Stencil buffer read only
+
+  /* Draw the polygon outer */
+  gluTessBeginPolygon (info.tobj, NULL);
+  tesselate_contour (info.tobj, &poly->Clipped->contours->head, info.vertices, &i);
+  gluTessEndPolygon (info.tobj);
+  hidgl_flush_triangles (&buffer);
+
+  glClear (GL_STENCIL_BUFFER_BIT);
+  glDisable (GL_STENCIL_TEST);                // Disable Stencil test
+
+  gluDeleteTess (info.tobj);
+  myFreeCombined ();
+  free (info.vertices);
+}
+
 void
 hidgl_fill_rect (int x1, int y1, int x2, int y2)
 {
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index 73d9a34..bb1383c 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -57,6 +57,7 @@ void hidgl_draw_arc (double width, int vx, int vy, int vrx, int vry, int start_a
 void hidgl_draw_rect (int x1, int y1, int x2, int y2);
 void hidgl_fill_circle (int vx, int vy, int vr, double scale);
 void hidgl_fill_polygon (int n_coords, int *x, int *y);
+void hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale);
 void hidgl_fill_rect (int x1, int y1, int x2, int y2);
 
 
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 3e41c35..430059b 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -522,6 +522,14 @@ ghid_fill_polygon (hidGC gc, int n_coords, int *x, int *y)
 }
 
 void
+ghid_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+{
+  USE_GC (gc);
+
+  hidgl_fill_pcb_polygon (poly, clip_box, gport->zoom);
+}
+
+void
 ghid_fill_rect (hidGC gc, int x1, int y1, int x2, int y2)
 {
   USE_GC (gc);
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 738636a..d92d7ec 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -1113,7 +1113,7 @@ HID ghid_hid = {
   ghid_draw_rect,
   ghid_fill_circle,
   ghid_fill_polygon,
-  common_fill_pcb_polygon,
+  ghid_fill_pcb_polygon,
   common_thindraw_pcb_polygon,
   ghid_fill_rect,
 
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index 2ebed06..4342f3f 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -530,6 +530,8 @@ void ghid_draw_arc (hidGC gc, int cx, int cy, int xradius, int yradius,
 void ghid_draw_rect (hidGC gc, int x1, int y1, int x2, int y2);
 void ghid_fill_circle (hidGC gc, int cx, int cy, int radius);
 void ghid_fill_polygon (hidGC gc, int n_coords, int *x, int *y);
+void ghid_fill_pcb_polygon (hidGC gc, PolygonType *poly,
+                            const BoxType *clip_box); /* GL ONLY */
 void ghid_fill_rect (hidGC gc, int x1, int y1, int x2, int y2);
 
 /* gtkhid-main.c */

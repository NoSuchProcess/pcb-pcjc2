Bottom: 422a52667ed2cf058851a4cd43718132c934c53b
Top:    728f68805c1a2a581049a64d5da3ba4518a726b6
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-05-05 21:05:51 +0100

Add raw polygons support for the GTK HID, bypassing the no-holes dicer

Uses the OpenGL stencil buffer to make drawing polygons with holes faster.

1. Turn Stenciling on, updates to colour buffer off
2. Clear stencil buffer to 0
3. Paint polygon holes, setting those areas of the stencil buffer to 1
4. Switch on stencil test (== 0), turn on updates to colour buffer
5. Paint outer polygon through areas of the stencil buffer still 0
6. Clear stencil buffer, switch off stencilling.

** BUGS? **

Probably throws up if the function is used whilst drawing the mask,
since that uses stenciling as well, and they don't know to co-operate.

For now, we don't use polygons on the mask, so its not a a problem (?).
(OR do we.. for some pins?)


---

diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index 1745891..64639d5 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -53,6 +53,7 @@
 
 #include "hid.h"
 #include "hidgl.h"
+#include "rtree.h"
 
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
@@ -459,6 +460,8 @@ myBegin (GLenum type)
   triangle_comp_idx = 0;
 }
 
+static double global_scale;
+
 static void
 myVertex (GLdouble *vertex_data)
 {
@@ -549,6 +552,116 @@ hidgl_fill_polygon (int n_coords, int *x, int *y)
 }
 
 void
+tesselate_contour (GLUtesselator *tobj, PLINE *contour, GLdouble *vertices,
+                   int *i)
+{
+  VNODE *vn = &contour->head;
+  int offset = *i * 3;
+
+  gluTessBeginContour (tobj);
+  do {
+    vertices [0 + offset] = vn->point[0];
+    vertices [1 + offset] = vn->point[1];
+    vertices [2 + offset] = 0.;
+    gluTessVertex (tobj, &vertices [offset], &vertices [offset]);
+    (*i)++;
+    offset += 3;
+  } while ((vn = vn->next) != &contour->head);
+  gluTessEndContour (tobj);
+}
+
+struct do_hole_info {
+  GLUtesselator *tobj;
+  GLdouble *vertices;
+  int *i;
+};
+
+static int
+do_hole (const BoxType *b, void *cl)
+{
+  struct do_hole_info *info = cl;
+  PLINE *curc = (PLINE *) b;
+
+  /* Ignore the outer contour - we draw it first explicitly*/
+  if (curc->Flags.orient == PLF_DIR) {
+    return 0;
+  }
+  gluTessBeginPolygon (info->tobj, NULL);
+  tesselate_contour (info->tobj, curc, info->vertices, info->i);
+  gluTessEndPolygon (info->tobj);
+  return 1;
+}
+
+void
+hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale)
+{
+  int i, cc;
+  int vertex_count = 0;
+  PLINE *contour;
+  struct do_hole_info info;
+
+
+  global_scale = scale;
+
+  if (poly->Clipped == NULL)
+    {
+      fprintf (stderr, "hidgl_fill_pcb_polygon: poly->Clipped == NULL\n");
+      return;
+    }
+
+  /* TODO: Just draw our triangles, no need to flush the buffer */
+  hidgl_flush_triangles (&buffer);
+
+  /* JUST DRAW THE FIRST PIECE */
+  /* Walk the polygon structure, counting vertices */
+  /* This gives an upper bound on the amount of storage required */
+  for (contour = poly->Clipped->contours;
+       contour != NULL; contour = contour->next)
+    vertex_count += contour->Count;
+
+  info.vertices = malloc (sizeof(GLdouble) * vertex_count * 3);
+  info.tobj = gluNewTess ();
+  info.i = &i;
+  gluTessCallback(info.tobj, GLU_TESS_BEGIN, myBegin);
+  gluTessCallback(info.tobj, GLU_TESS_VERTEX, myVertex);
+  gluTessCallback(info.tobj, GLU_TESS_COMBINE, myCombine);
+  gluTessCallback(info.tobj, GLU_TESS_ERROR, myError);
+
+  glClearStencil (0);
+  glClear (GL_STENCIL_BUFFER_BIT);
+  glColorMask (0, 0, 0, 0);                   /* Disable writting in color buffer */
+  glEnable (GL_STENCIL_TEST);
+
+  i = 0;
+  cc = 1;
+
+  /* Drawing operations set the stencil buffer to '1' */
+  glStencilFunc (GL_ALWAYS, 1, 1);            /* Test always passes, value written 1 */
+  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); /* Stencil pass => replace stencil value (with 1) */
+
+  r_search (poly->Clipped->contour_tree, clip_box, NULL, do_hole, &info);
+  hidgl_flush_triangles (&buffer);
+
+  /* Drawing operations as masked to areas where the stencil buffer is '1' */
+  glColorMask (1, 1, 1, 1);                   /* Enable drawing of r, g, b & a */
+  glStencilFunc (GL_EQUAL, 0, 1);             /* Draw only where stencil buffer is 0 */
+  glStencilOp (GL_KEEP, GL_KEEP, GL_KEEP);    /* Stencil buffer read only */
+
+  /* Draw the polygon outer */
+  gluTessBeginPolygon (info.tobj, NULL);
+  tesselate_contour (info.tobj, poly->Clipped->contours, info.vertices, &i);
+  gluTessEndPolygon (info.tobj);
+  hidgl_flush_triangles (&buffer);
+
+  glClear (GL_STENCIL_BUFFER_BIT);
+  glDisable (GL_STENCIL_TEST);                /* Disable Stencil test */
+
+  gluDeleteTess (info.tobj);
+  myFreeCombined ();
+  free (info.vertices);
+}
+
+void
 hidgl_fill_rect (int x1, int y1, int x2, int y2)
 {
   hidgl_ensure_triangle_space (&buffer, 2);
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index 282b144..d2ab3c4 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -73,6 +73,7 @@ void hidgl_draw_arc (double width, int vx, int vy, int vrx, int vry, int start_a
 void hidgl_draw_rect (int x1, int y1, int x2, int y2);
 void hidgl_fill_circle (int vx, int vy, int vr, double scale);
 void hidgl_fill_polygon (int n_coords, int *x, int *y);
+void hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale);
 void hidgl_fill_rect (int x1, int y1, int x2, int y2);
 
 
diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index 882af60..4cb9a02 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -10,6 +10,7 @@
 #include "clip.h"
 #include "../hidint.h"
 #include "gui.h"
+#include "hid/common/draw_helpers.h"
 
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
@@ -654,6 +655,12 @@ ghid_fill_polygon (hidGC gc, int n_coords, int *x, int *y)
 }
 
 void
+ghid_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+{
+  common_fill_pcb_polygon (gc, poly, clip_box);
+}
+
+void
 ghid_fill_rect (hidGC gc, int x1, int y1, int x2, int y2)
 {
   gint w, h, lw, xx, yy;
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 253ff3f..7dae38e 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -520,6 +520,14 @@ ghid_fill_polygon (hidGC gc, int n_coords, int *x, int *y)
 }
 
 void
+ghid_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
+{
+  USE_GC (gc);
+
+  hidgl_fill_pcb_polygon (poly, clip_box, gport->zoom);
+}
+
+void
 ghid_fill_rect (hidGC gc, int x1, int y1, int x2, int y2)
 {
   USE_GC (gc);
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 4a231c9..ea0a0dd 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -2296,6 +2296,7 @@ hid_gtk_init ()
   ghid_hid.draw_rect                = ghid_draw_rect;
   ghid_hid.fill_circle              = ghid_fill_circle;
   ghid_hid.fill_polygon             = ghid_fill_polygon;
+  ghid_hid.fill_pcb_polygon         = ghid_fill_pcb_polygon;
   ghid_hid.fill_rect                = ghid_fill_rect;
 
   ghid_hid.calibrate                = ghid_calibrate;
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index 31ee636..00856da 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -485,6 +485,8 @@ void ghid_draw_arc (hidGC gc, int cx, int cy, int xradius, int yradius,
 void ghid_draw_rect (hidGC gc, int x1, int y1, int x2, int y2);
 void ghid_fill_circle (hidGC gc, int cx, int cy, int radius);
 void ghid_fill_polygon (hidGC gc, int n_coords, int *x, int *y);
+void ghid_fill_pcb_polygon (hidGC gc, PolygonType *poly,
+                            const BoxType *clip_box); /* GL ONLY */
 void ghid_fill_rect (hidGC gc, int x1, int y1, int x2, int y2);
 void ghid_invalidate_lr (int left, int right, int top, int bottom);
 void ghid_invalidate_all ();

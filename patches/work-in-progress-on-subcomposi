Bottom: ec1a74f78d785c7314c927422916dae7c1c24f70
Top:    31882b6f90fa8e0de1eddbd73b348316c27bcf15
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-05-05 21:05:51 +0100

Work in progress on subcompositing / stencil buffers

If we have many stencil buffer bits, we may as well use all of them before
resorting to a costly clear and re-using the same bit-planes over.




---

diff --git a/src/draw.c b/src/draw.c
index e1ae2dc..994dd1c 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -693,6 +693,7 @@ DrawEverything (BoxTypePtr drawn_area)
 	  DrawLayer (&(PCB->Data->Layer[max_copper_layer + side]), drawn_area);
 	}
       r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, &side);
+      gui->end_layer ();
     }
 
   /* draw all layers in layerstack order */
@@ -701,8 +702,11 @@ DrawEverything (BoxTypePtr drawn_area)
       int group = drawn_groups[i];
 
       if (gui->set_layer (0, group, 0))
-        if (DrawLayerGroup (group, drawn_area) && !gui->gui)
-          DrawPPV (group, drawn_area);
+        {
+          if (DrawLayerGroup (group, drawn_area) && !gui->gui)
+            DrawPPV (group, drawn_area);
+          gui->end_layer ();
+        }
     }
 
   if (TEST_FLAG (CHECKPLANESFLAG, PCB) && gui->gui)
@@ -716,24 +720,42 @@ DrawEverything (BoxTypePtr drawn_area)
       CountHoles (&plated, &unplated, drawn_area);
 
       if (plated && gui->set_layer ("plated-drill", SL (PDRILL, 0), 0))
-        DrawHoles (true, false, drawn_area);
+        {
+          DrawHoles (true, false, drawn_area);
+          gui->end_layer ();
+        }
 
       if (unplated && gui->set_layer ("unplated-drill", SL (PDRILL, 0), 0))
-        DrawHoles (false, true, drawn_area);
+        {
+          DrawHoles (false, true, drawn_area);
+          gui->end_layer ();
+        }
     }
 
   /* Draw the solder mask if turned on */
   if (gui->set_layer ("componentmask", SL (MASK, TOP), 0))
-    DrawMask (COMPONENT_LAYER, drawn_area);
+    {
+      DrawMask (COMPONENT_LAYER, drawn_area);
+      gui->end_layer ();
+    }
 
   if (gui->set_layer ("soldermask", SL (MASK, BOTTOM), 0))
-    DrawMask (SOLDER_LAYER, drawn_area);
+    {
+      DrawMask (SOLDER_LAYER, drawn_area);
+      gui->end_layer ();
+    }
 
   if (gui->set_layer ("topsilk", SL (SILK, TOP), 0))
-    DrawSilk (COMPONENT_LAYER, drawn_area);
+    {
+      DrawSilk (COMPONENT_LAYER, drawn_area);
+      gui->end_layer ();
+    }
 
   if (gui->set_layer ("bottomsilk", SL (SILK, BOTTOM), 0))
-    DrawSilk (SOLDER_LAYER, drawn_area);
+    {
+      DrawSilk (SOLDER_LAYER, drawn_area);
+      gui->end_layer ();
+    }
 
   if (gui->gui)
     {
@@ -743,27 +765,47 @@ DrawEverything (BoxTypePtr drawn_area)
 		  NULL);
       /* Draw rat lines on top */
       if (gui->set_layer ("rats", SL (RATS, 0), 0))
-	DrawRats(drawn_area);
+        {
+          DrawRats(drawn_area);
+          gui->end_layer ();
+        }
     }
 
   paste_empty = IsPasteEmpty (COMPONENT_LAYER);
   if (gui->set_layer ("toppaste", SL (PASTE, TOP), paste_empty))
-    DrawPaste (COMPONENT_LAYER, drawn_area);
+    {
+      DrawPaste (COMPONENT_LAYER, drawn_area);
+      gui->end_layer ();
+    }
 
   paste_empty = IsPasteEmpty (SOLDER_LAYER);
   if (gui->set_layer ("bottompaste", SL (PASTE, BOTTOM), paste_empty))
-    DrawPaste (SOLDER_LAYER, drawn_area);
+    {
+      DrawPaste (SOLDER_LAYER, drawn_area);
+      gui->end_layer ();
+    }
 
   doing_assy = true;
+
   if (gui->set_layer ("topassembly", SL (ASSY, TOP), 0))
-    PrintAssembly (COMPONENT_LAYER, drawn_area);
+    {
+      PrintAssembly (COMPONENT_LAYER, drawn_area);
+      gui->end_layer ();
+    }
 
   if (gui->set_layer ("bottomassembly", SL (ASSY, BOTTOM), 0))
-    PrintAssembly (SOLDER_LAYER, drawn_area);
+    {
+      PrintAssembly (SOLDER_LAYER, drawn_area);
+      gui->end_layer ();
+    }
+
   doing_assy = false;
 
   if (gui->set_layer ("fab", SL (FAB, 0), 0))
-    PrintFab (Output.fgGC);
+    {
+      PrintFab (Output.fgGC);
+      gui->end_layer ();
+    }
 }
 
 static void
@@ -1126,6 +1168,10 @@ DrawLayerGroup (int group, const BoxType *drawn_area)
         rv = 0;
       if (layernum < max_copper_layer && Layer->On)
         DrawLayerCommon (Layer, drawn_area, true);
+
+      /* HACK: Let GTK/GL subcomposite each layer in the group separately */
+      if (gui->gui)
+        gui->set_layer (0, group, 0);
     }
   if (n_entries > 1)
     rv = 1;
diff --git a/src/hid.h b/src/hid.h
index 3919db0..eeb09ab 100644
--- a/src/hid.h
+++ b/src/hid.h
@@ -311,6 +311,9 @@ typedef enum
        layer is empty, if zero it may be non-empty.  */
     int (*set_layer) (const char *name_, int group_, int _empty);
 
+    /* Tell the GUI the layer last selected has been finished with */
+    void (*end_layer) (void);
+
     /* Drawing Functions.  Coordinates and distances are ALWAYS in PCB's
        default coordinates (1/100 mil at the time this comment was
        written).  Angles are always in degrees, with 0 being "right"
diff --git a/src/hid/common/hidnogui.c b/src/hid/common/hidnogui.c
index 5289c71..08061fe 100644
--- a/src/hid/common/hidnogui.c
+++ b/src/hid/common/hidnogui.c
@@ -68,6 +68,11 @@ nogui_set_layer (const char *name, int idx, int empty)
   return 0;
 }
 
+static void
+nogui_end_layer (void)
+{
+}
+
 static hidGC
 nogui_make_gc (void)
 {
@@ -456,6 +461,7 @@ HID hid_nogui = {
   0 /* nogui_notify_crosshair_change */ ,
   0 /* nogui_notify_mark_change */ ,
   nogui_set_layer,
+  nogui_end_layer,
   nogui_make_gc,
   nogui_destroy_gc,
   nogui_use_mask,
@@ -521,6 +527,7 @@ apply_default_hid (HID * d, HID * s)
   AD (notify_crosshair_change);
   AD (notify_mark_change);
   AD (set_layer);
+  AD (end_layer);
   AD (make_gc);
   AD (destroy_gc);
   AD (use_mask);
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 910fd2d..ea7d73a 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -44,6 +44,7 @@ typedef struct render_priv {
   GdkGLConfig *glconfig;
   bool trans_lines;
   bool in_context;
+  int subcomposite_stencil_bit;
 } render_priv;
 
 
@@ -64,6 +65,7 @@ int
 ghid_set_layer (const char *name, int group, int empty)
 {
   render_priv *priv = gport->render_priv;
+  int stencil_bit;
   int idx = group;
   if (idx >= 0 && idx < max_group)
     {
@@ -78,6 +80,21 @@ ghid_set_layer (const char *name, int group, int empty)
       idx = PCB->LayerGroups.Entries[group][idx];
     }
 
+#define SUBCOMPOSITE_LAYERS
+#ifdef SUBCOMPOSITE_LAYERS
+  /* Flush out any existing geoemtry to be rendered */
+  hidgl_flush_triangles (&buffer);
+
+  glEnable (GL_STENCIL_TEST);                                 /* Enable Stencil test */
+  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);                 /* Stencil pass => replace stencil value (with 1) */
+
+  hidgl_return_stencil_bit (priv->subcomposite_stencil_bit);  /* Relinquish any bitplane we previously used */
+  stencil_bit = hidgl_assign_clear_stencil_bit();             /* Get a new (clean) bitplane to stencil with */
+  glStencilFunc (GL_GREATER, stencil_bit, stencil_bit);       /* Pass stencil test if our assigned bit is clear */
+  glStencilMask (stencil_bit);                                /* Only write to our subcompositing stencil bitplane */
+  priv->subcomposite_stencil_bit = stencil_bit;
+#endif
+
   if (idx >= 0 && idx < max_copper_layer + 2)
     {
       priv->trans_lines = true;
@@ -94,7 +111,7 @@ ghid_set_layer (const char *name, int group, int empty)
 	    return TEST_FLAG (SHOWMASKFLAG, PCB);
 	  return 0;
 	case SL_SILK:
-	  priv->trans_lines = false;
+	  priv->trans_lines = true;
 	  if (SL_MYSIDE (idx))
 	    return PCB->ElementOn;
 	  return 0;
@@ -112,6 +129,23 @@ ghid_set_layer (const char *name, int group, int empty)
   return 0;
 }
 
+static void
+ghid_end_layer (void)
+{
+  render_priv *priv = gport->render_priv;
+
+  /* Flush out any existing geoemtry to be rendered */
+  hidgl_flush_triangles (&buffer);
+
+  /* Relinquish any bitplane we previously used */
+  hidgl_return_stencil_bit (priv->subcomposite_stencil_bit);
+  priv->subcomposite_stencil_bit = 0;
+
+  /* Always pass stencil test */
+  glStencilMask (0);
+  glStencilFunc (GL_ALWAYS, 0, 0);
+}
+
 void
 ghid_destroy_gc (hidGC gc)
 {
@@ -751,6 +785,9 @@ ghid_init_renderer (int *argc, char ***argv, GHidPort *port)
       printf ("Could not setup GL-context!\n");
       return; /* Should we abort? */
     }
+
+  /* Setup HID function pointers specific to the GL renderer*/
+  ghid_hid.end_layer = ghid_end_layer;
 }
 
 void
@@ -1169,6 +1206,12 @@ ghid_request_debug_draw (void)
   hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
 
+  /* Setup stenciling */
+  /* Drawing operations set the stencil buffer to '1' */
+  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); /* Stencil pass => replace stencil value (with 1) */
+  /* Drawing operations as masked to areas where the stencil buffer is '0' */
+  /* glStencilFunc (GL_GREATER, 1, 1); */           /* Draw only where stencil buffer is 0 */
+
   glPushMatrix ();
   glScalef ((ghid_flip_x ? -1. : 1.) / port->zoom,
             (ghid_flip_y ? -1. : 1.) / port->zoom,

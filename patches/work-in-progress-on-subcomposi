Bottom: 5b8c66c1b49277f14a8163de93218d93000be119
Top:    fd9c823e40ffc9f9337995ec18a0ebeacfa9fe7c
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-05-05 21:05:51 +0100

Work in progress on subcompositing / stencil buffers

If we have many stencil buffer bits, we may as well use all of them before
resorting to a costly clear and re-using the same bit-planes over.




---

diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index e7614db..c3f4fc1 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -44,6 +44,7 @@ typedef struct render_priv {
   GdkGLConfig *glconfig;
   bool trans_lines;
   bool in_context;
+  int subcomposite_stencil_bit;
 } render_priv;
 
 
@@ -64,6 +65,7 @@ int
 ghid_set_layer (const char *name, int group, int empty)
 {
   render_priv *priv = gport->render_priv;
+  int stencil_bit;
   int idx = group;
   if (idx >= 0 && idx < max_group)
     {
@@ -78,6 +80,18 @@ ghid_set_layer (const char *name, int group, int empty)
       idx = PCB->LayerGroups.Entries[group][idx];
     }
 
+  /* Flush out any existing geoemtry to be rendered */
+  hidgl_flush_triangles (&buffer);
+
+  glEnable (GL_STENCIL_TEST);                                 /* Enable Stencil test */
+  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);                 /* Stencil pass => replace stencil value (with 1) */
+
+  hidgl_return_stencil_bit (priv->subcomposite_stencil_bit);  /* Relinquish any bitplane we previously used */
+  stencil_bit = hidgl_assign_clear_stencil_bit();             /* Get a new (clean) bitplane to stencil with */
+  glStencilFunc (GL_GREATER, stencil_bit, stencil_bit);       /* Pass stencil test if our assigned bit is clear */
+  glStencilMask (stencil_bit);                                /* Only write to our subcompositing stencil bitplane */
+  priv->subcomposite_stencil_bit = stencil_bit;
+
   if (idx >= 0 && idx < max_copper_layer + 2)
     {
       priv->trans_lines = false;
@@ -94,7 +108,7 @@ ghid_set_layer (const char *name, int group, int empty)
 	    return TEST_FLAG (SHOWMASKFLAG, PCB);
 	  return 0;
 	case SL_SILK:
-	  priv->trans_lines = false;
+	  priv->trans_lines = true;
 	  if (SL_MYSIDE (idx))
 	    return PCB->ElementOn;
 	  return 0;
@@ -112,6 +126,23 @@ ghid_set_layer (const char *name, int group, int empty)
   return 0;
 }
 
+static void
+ghid_end_layer (void)
+{
+  render_priv *priv = gport->render_priv;
+
+  /* Flush out any existing geoemtry to be rendered */
+  hidgl_flush_triangles (&buffer);
+
+  /* Relinquish any bitplane we previously used */
+  hidgl_return_stencil_bit (priv->subcomposite_stencil_bit);
+  priv->subcomposite_stencil_bit = 0;
+
+  /* Always pass stencil test */
+  glStencilMask (0);
+  glStencilFunc (GL_ALWAYS, 0, 0);
+}
+
 void
 ghid_destroy_gc (hidGC gc)
 {
@@ -751,6 +782,9 @@ ghid_init_renderer (int *argc, char ***argv, GHidPort *port)
       printf ("Could not setup GL-context!\n");
       return; /* Should we abort? */
     }
+
+  /* Setup HID function pointers specific to the GL renderer*/
+  ghid_hid.end_layer = ghid_end_layer;
 }
 
 void
@@ -1169,6 +1203,9 @@ ghid_request_debug_draw (void)
   hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
 
+  /* Setup stenciling */
+  glDisable (GL_STENCIL_TEST);
+
   glPushMatrix ();
   glScalef ((ghid_flip_x ? -1. : 1.) / port->zoom,
             (ghid_flip_y ? -1. : 1.) / port->zoom,

Bottom: 69ca588085996176b5944a29f3fa7a284886a53b
Top:    03d790a55db762a6157f5a3c2fb93fdc7b0a7522
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-04-26 19:19:09 +0100

Work in progress on subcompositing / stencil buffers

If we have many stencil buffer bits, we may as well use all of them before
resorting to a costly clear and re-using the same bit-planes over.




---

diff --git a/src/draw.c b/src/draw.c
index 6eb0d81..d1fab5d 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -693,6 +693,7 @@ DrawEverything (BoxTypePtr drawn_area)
 	  DrawLayer (&(PCB->Data->Layer[max_copper_layer + side]), drawn_area);
 	}
       r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, &side);
+      gui->set_layer (NULL, SL (FINISHED, 0), 0);
     }
 
   /* draw all layers in layerstack order */
@@ -701,8 +702,11 @@ DrawEverything (BoxTypePtr drawn_area)
       int group = drawn_groups[i];
 
       if (gui->set_layer (0, group, 0))
-        if (DrawLayerGroup (group, drawn_area) && !gui->gui)
-          DrawPPV (group, drawn_area);
+        {
+          if (DrawLayerGroup (group, drawn_area) && !gui->gui)
+            DrawPPV (group, drawn_area);
+          gui->set_layer (NULL, SL (FINISHED, 0), 0);
+        }
     }
 
   if (TEST_FLAG (CHECKPLANESFLAG, PCB) && gui->gui)
@@ -724,16 +728,28 @@ DrawEverything (BoxTypePtr drawn_area)
 
   /* Draw the solder mask if turned on */
   if (gui->set_layer ("componentmask", SL (MASK, TOP), 0))
-    DrawMask (COMPONENT_LAYER, drawn_area);
+    {
+      DrawMask (COMPONENT_LAYER, drawn_area);
+      gui->set_layer (NULL, SL (FINISHED, 0), 0);
+    }
 
   if (gui->set_layer ("soldermask", SL (MASK, BOTTOM), 0))
-    DrawMask (SOLDER_LAYER, drawn_area);
+    {
+      DrawMask (SOLDER_LAYER, drawn_area);
+      gui->set_layer (NULL, SL (FINISHED, 0), 0);
+    }
 
   if (gui->set_layer ("topsilk", SL (SILK, TOP), 0))
-    DrawSilk (COMPONENT_LAYER, drawn_area);
+    {
+      DrawSilk (COMPONENT_LAYER, drawn_area);
+      gui->set_layer (NULL, SL (FINISHED, 0), 0);
+    }
 
   if (gui->set_layer ("bottomsilk", SL (SILK, BOTTOM), 0))
-    DrawSilk (SOLDER_LAYER, drawn_area);
+    {
+      DrawSilk (SOLDER_LAYER, drawn_area);
+      gui->set_layer (NULL, SL (FINISHED, 0), 0);
+    }
 
   if (gui->gui)
     {
@@ -743,27 +759,47 @@ DrawEverything (BoxTypePtr drawn_area)
 		  NULL);
       /* Draw rat lines on top */
       if (gui->set_layer ("rats", SL (RATS, 0), 0))
-	DrawRats(drawn_area);
+        {
+          DrawRats(drawn_area);
+          gui->set_layer (NULL, SL (FINISHED, 0), 0);
+        }
     }
 
   paste_empty = IsPasteEmpty (COMPONENT_LAYER);
   if (gui->set_layer ("toppaste", SL (PASTE, TOP), paste_empty))
-    DrawPaste (COMPONENT_LAYER, drawn_area);
+    {
+      DrawPaste (COMPONENT_LAYER, drawn_area);
+      gui->set_layer (NULL, SL (FINISHED, 0), 0);
+    }
 
   paste_empty = IsPasteEmpty (SOLDER_LAYER);
   if (gui->set_layer ("bottompaste", SL (PASTE, BOTTOM), paste_empty))
-    DrawPaste (SOLDER_LAYER, drawn_area);
+    {
+      DrawPaste (SOLDER_LAYER, drawn_area);
+      gui->set_layer (NULL, SL (FINISHED, 0), 0);
+    }
 
   doing_assy = true;
+
   if (gui->set_layer ("topassembly", SL (ASSY, TOP), 0))
-    PrintAssembly (COMPONENT_LAYER, drawn_area);
+    {
+      PrintAssembly (COMPONENT_LAYER, drawn_area);
+      gui->set_layer (NULL, SL (FINISHED, 0), 0);
+    }
 
   if (gui->set_layer ("bottomassembly", SL (ASSY, BOTTOM), 0))
-    PrintAssembly (SOLDER_LAYER, drawn_area);
+    {
+      PrintAssembly (SOLDER_LAYER, drawn_area);
+      gui->set_layer (NULL, SL (FINISHED, 0), 0);
+    }
+
   doing_assy = false;
 
   if (gui->set_layer ("fab", SL (FAB, 0), 0))
-    PrintFab ();
+    {
+      PrintFab ();
+      gui->set_layer (NULL, SL (FINISHED, 0), 0);
+    }
 }
 
 static void
@@ -1110,7 +1146,8 @@ DrawLayerGroup (int group, const BoxType *drawn_area)
   int n_entries = PCB->LayerGroups.Number[group];
   Cardinal *layers = PCB->LayerGroups.Entries[group];
 
-  for (i = n_entries - 1; i >= 0; i--)
+  for (i = n_entries - 1; i >= 0;
+      i--, gui->set_layer (0, group, 0)) /* HACK: Subcomposite each layer in a layer group separately */
     {
       layernum = layers[i];
       Layer = PCB->Data->Layer + layers[i];
diff --git a/src/draw_funcs.c b/src/draw_funcs.c
new file mode 100644
index 0000000..ad207ba
--- /dev/null
+++ b/src/draw_funcs.c
@@ -0,0 +1,406 @@
+
+#include "global.h"
+#include "data.h"
+#include "misc.h"
+#include "rtree.h"
+#include "draw_funcs.h"
+#include "draw.h"
+
+static void
+_draw_pv (PinType *pv, bool draw_hole)
+{
+  if (TEST_FLAG (THINDRAWFLAG, PCB))
+    gui->thindraw_pcb_pv (Output.fgGC, Output.fgGC, pv, draw_hole, false);
+  else
+    gui->fill_pcb_pv (Output.fgGC, Output.bgGC, pv, draw_hole, false);
+}
+
+static void
+draw_pin (PinType *pin, const BoxType *drawn_area, void *userdata)
+{
+  _draw_pv (pin, false);
+}
+
+static void
+draw_pin_mask (PinType *pin, const BoxType *drawn_area, void *userdata)
+{
+  if (TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG (THINDRAWPOLYFLAG, PCB))
+    gui->thindraw_pcb_pv (Output.pmGC, Output.pmGC, pin, false, true);
+  else
+    gui->fill_pcb_pv (Output.pmGC, Output.pmGC, pin, false, true);
+}
+
+static void
+draw_via (PinType *via, const BoxType *drawn_area, void *userdata)
+{
+  _draw_pv (via, false);
+}
+
+static void
+draw_via_mask (PinType *via, const BoxType *drawn_area, void *userdata)
+{
+  if (TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG (THINDRAWPOLYFLAG, PCB))
+    gui->thindraw_pcb_pv (Output.pmGC, Output.pmGC, via, false, true);
+  else
+    gui->fill_pcb_pv (Output.pmGC, Output.pmGC, via, false, true);
+}
+
+static void
+draw_hole (PinType *pv, const BoxType *drawn_area, void *userdata)
+{
+  gui->set_line_cap (Output.fgGC, Round_Cap);
+  gui->set_line_width (Output.fgGC, 0);
+
+  if (!TEST_FLAG (THINDRAWFLAG, PCB))
+    gui->fill_circle (Output.bgGC, pv->X, pv->Y, pv->DrillingHole / 2);
+
+  if (TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG (HOLEFLAG, pv))
+    gui->draw_arc (Output.fgGC, pv->X, pv->Y,
+                   pv->DrillingHole / 2, pv->DrillingHole / 2, 0, 360);
+}
+
+static void
+_draw_pad (hidGC gc, PadType *pad, bool clear, bool mask)
+{
+  if (clear && !mask && pad->Clearance <= 0)
+    return;
+
+  if (TEST_FLAG (THINDRAWFLAG, PCB) ||
+      (clear && TEST_FLAG (THINDRAWPOLYFLAG, PCB)))
+    gui->thindraw_pcb_pad (gc, pad, clear, mask);
+  else
+    gui->fill_pcb_pad (gc, pad, clear, mask);
+}
+
+static void
+draw_pad (PadType *pad, const BoxType *drawn_area, void *userdata)
+{
+  _draw_pad (Output.fgGC, pad, false, false);
+}
+
+static void
+draw_pad_mask (PadType *pad, const BoxType *drawn_area, void *userdata)
+{
+  if (pad->Mask <= 0)
+    return;
+
+  _draw_pad (Output.pmGC, pad, true, true);
+}
+
+static void
+draw_pad_paste (PadType *pad, const BoxType *drawn_area, void *userdata)
+{
+  if (TEST_FLAG (NOPASTEFLAG, pad) || pad->Mask <= 0)
+    return;
+
+  if (pad->Mask < pad->Thickness)
+    _draw_pad (Output.fgGC, pad, true, true);
+  else
+    _draw_pad (Output.fgGC, pad, false, false);
+}
+
+static void
+_draw_line (LineType *line)
+{
+  gui->set_line_cap (Output.fgGC, Trace_Cap);
+  if (TEST_FLAG (THINDRAWFLAG, PCB))
+    gui->set_line_width (Output.fgGC, 0);
+  else
+    gui->set_line_width (Output.fgGC, line->Thickness);
+
+  gui->draw_line (Output.fgGC,
+                  line->Point1.X, line->Point1.Y,
+                  line->Point2.X, line->Point2.Y);
+}
+
+static void
+draw_line (LineType *line, const BoxType *drawn_area, void *userdata)
+{
+  _draw_line (line);
+}
+
+static void
+draw_rat (RatType *rat, const BoxType *drawn_area, void *userdata)
+{
+  if (Settings.RatThickness < 20)
+    rat->Thickness = pixel_slop * Settings.RatThickness;
+  /* rats.c set VIAFLAG if this rat goes to a containing poly: draw a donut */
+  if (TEST_FLAG(VIAFLAG, rat))
+    {
+      int w = rat->Thickness;
+
+      if (TEST_FLAG (THINDRAWFLAG, PCB))
+        gui->set_line_width (Output.fgGC, 0);
+      else
+        gui->set_line_width (Output.fgGC, w);
+      gui->draw_arc (Output.fgGC, rat->Point1.X, rat->Point1.Y,
+                     w * 2, w * 2, 0, 360);
+    }
+  else
+    _draw_line ((LineType *) rat);
+}
+
+static void
+draw_arc (ArcType *arc, const BoxType *drawn_area, void *userdata)
+{
+  if (!arc->Thickness)
+    return;
+
+  if (TEST_FLAG (THINDRAWFLAG, PCB))
+    gui->set_line_width (Output.fgGC, 0);
+  else
+    gui->set_line_width (Output.fgGC, arc->Thickness);
+  gui->set_line_cap (Output.fgGC, Trace_Cap);
+
+  gui->draw_arc (Output.fgGC, arc->X, arc->Y, arc->Width,
+                 arc->Height, arc->StartAngle, arc->Delta);
+}
+
+static void
+draw_poly (PolygonType *polygon, const BoxType *drawn_area, void *userdata)
+{
+  if (!polygon->Clipped)
+    return;
+
+  if (gui->thindraw_pcb_polygon != NULL &&
+      (TEST_FLAG (THINDRAWFLAG, PCB) ||
+       TEST_FLAG (THINDRAWPOLYFLAG, PCB)))
+    gui->thindraw_pcb_polygon (Output.fgGC, polygon, drawn_area);
+  else
+    gui->fill_pcb_polygon (Output.fgGC, polygon, drawn_area);
+
+  /* If checking planes, thin-draw any pieces which have been clipped away */
+  if (gui->thindraw_pcb_polygon != NULL &&
+      TEST_FLAG (CHECKPLANESFLAG, PCB) &&
+      !TEST_FLAG (FULLPOLYFLAG, polygon))
+    {
+      PolygonType poly = *polygon;
+
+      for (poly.Clipped = polygon->Clipped->f;
+           poly.Clipped != polygon->Clipped;
+           poly.Clipped = poly.Clipped->f)
+        gui->thindraw_pcb_polygon (Output.fgGC, &poly, drawn_area);
+    }
+}
+
+static int
+line_callback (const BoxType * b, void *cl)
+{
+  LayerType *layer = cl;
+  LineType *line = (LineType *)b;
+
+  if (TEST_FLAG (SELECTEDFLAG, line))   gui->set_color (Output.fgGC, layer->SelectedColor);
+  else if (TEST_FLAG (FOUNDFLAG, line)) gui->set_color (Output.fgGC, PCB->ConnectedColor);
+  else                                  gui->set_color (Output.fgGC, layer->Color);
+
+  dapi->draw_line (line, NULL, NULL);
+  return 1;
+}
+
+static int
+arc_callback (const BoxType * b, void *cl)
+{
+  LayerType *layer = cl;
+  ArcType *arc = (ArcType *)b;
+
+  if (TEST_FLAG (SELECTEDFLAG, arc))   gui->set_color (Output.fgGC, layer->SelectedColor);
+  else if (TEST_FLAG (FOUNDFLAG, arc)) gui->set_color (Output.fgGC, PCB->ConnectedColor);
+  else                                 gui->set_color (Output.fgGC, layer->Color);
+
+  dapi->draw_arc (arc, NULL, NULL);
+  return 1;
+}
+
+struct poly_info {
+  const const BoxType *drawn_area;
+  LayerType *layer;
+};
+
+static int
+poly_callback (const BoxType * b, void *cl)
+{
+  struct poly_info *i = cl;
+  PolygonType *polygon = (PolygonType *)b;
+
+  if (TEST_FLAG (SELECTEDFLAG, polygon))   gui->set_color (Output.fgGC, i->layer->SelectedColor);
+  else if (TEST_FLAG (FOUNDFLAG, polygon)) gui->set_color (Output.fgGC, PCB->ConnectedColor);
+  else                                     gui->set_color (Output.fgGC, i->layer->Color);
+
+  dapi->draw_poly (polygon, i->drawn_area, NULL);
+  return 1;
+}
+
+static int
+text_callback (const BoxType * b, void *cl)
+{
+  LayerType *layer = cl;
+  TextType *text = (TextType *)b;
+  int min_silk_line;
+
+  if (TEST_FLAG (SELECTEDFLAG, text))
+    gui->set_color (Output.fgGC, layer->SelectedColor);
+  else
+    gui->set_color (Output.fgGC, layer->Color);
+  if (layer == &PCB->Data->SILKLAYER ||
+      layer == &PCB->Data->BACKSILKLAYER)
+    min_silk_line = PCB->minSlk;
+  else
+    min_silk_line = PCB->minWid;
+  DrawTextLowLevel (text, min_silk_line);
+  return 1;
+}
+
+static void
+set_pv_inlayer_color (PinType *pv, LayerType *layer, int type)
+{
+  if (TEST_FLAG (WARNFLAG, pv))          gui->set_color (Output.fgGC, PCB->WarnColor);
+  else if (TEST_FLAG (SELECTEDFLAG, pv)) gui->set_color (Output.fgGC, (type == VIA_TYPE) ? PCB->ViaSelectedColor
+                                                                                         : PCB->PinSelectedColor);
+  else if (TEST_FLAG (FOUNDFLAG, pv))    gui->set_color (Output.fgGC, PCB->ConnectedColor);
+  else                                   gui->set_color (Output.fgGC, layer->Color);
+}
+
+static int
+pin_inlayer_callback (const BoxType * b, void *cl)
+{
+  set_pv_inlayer_color ((PinType *)b, cl, PIN_TYPE);
+  dapi->draw_pin ((PinType *)b, NULL, NULL);
+  return 1;
+}
+
+static int
+via_inlayer_callback (const BoxType * b, void *cl)
+{
+  set_pv_inlayer_color ((PinType *)b, cl, VIA_TYPE);
+  dapi->draw_via ((PinType *)b, NULL, NULL);
+  return 1;
+}
+
+static int
+pad_inlayer_callback (const BoxType * b, void *cl)
+{
+  PadTypePtr pad = (PadTypePtr) b;
+  LayerType *layer = cl;
+  int solder_group = GetLayerGroupNumberByNumber (solder_silk_layer);
+  int group = GetLayerGroupNumberByPointer (layer);
+
+  int side = (group == solder_group) ? SOLDER_LAYER : COMPONENT_LAYER;
+
+  if (ON_SIDE (pad, side))
+    {
+      if (TEST_FLAG (WARNFLAG, pad))          gui->set_color (Output.fgGC, PCB->WarnColor);
+      else if (TEST_FLAG (SELECTEDFLAG, pad)) gui->set_color (Output.fgGC, PCB->PinSelectedColor);
+      else if (TEST_FLAG (FOUNDFLAG, pad))    gui->set_color (Output.fgGC, PCB->ConnectedColor);
+      else                                    gui->set_color (Output.fgGC, layer->Color);
+
+      dapi->draw_pad (pad, NULL, NULL);
+    }
+  return 1;
+}
+
+static int
+hole_callback (const BoxType * b, void *cl)
+{
+  PinTypePtr pv = (PinTypePtr) b;
+  int plated = cl ? *(int *) cl : -1;
+
+  if ((plated == 0 && !TEST_FLAG (HOLEFLAG, pv)) ||
+      (plated == 1 &&  TEST_FLAG (HOLEFLAG, pv)))
+    return 1;
+
+  if (TEST_FLAG (WARNFLAG, pv))          gui->set_color (Output.fgGC, PCB->WarnColor);
+  else if (TEST_FLAG (SELECTEDFLAG, pv)) gui->set_color (Output.fgGC, PCB->PinSelectedColor);
+  else                                   gui->set_color (Output.fgGC, Settings.BlackColor);
+
+  dapi->draw_hole (pv, NULL, NULL);
+  return 1;
+}
+
+static void
+draw_layer (LayerType *layer, const BoxType *drawn_area, void *userdata)
+{
+  int component_group = GetLayerGroupNumberByNumber (component_silk_layer);
+  int solder_group = GetLayerGroupNumberByNumber (solder_silk_layer);
+  int layer_num = GetLayerNumber (PCB->Data, layer);
+  int group = GetLayerGroupNumberByPointer (layer);
+  struct poly_info info = {drawn_area, layer};
+
+  /* print the non-clearing polys */
+  r_search (layer->polygon_tree, drawn_area, NULL, poly_callback, &info);
+
+  /* HACK: Subcomposite polygons separately from other layer primitives */
+  /* Reset the compositing */
+  gui->set_layer (0, group, 0);
+
+  if (TEST_FLAG (CHECKPLANESFLAG, PCB))
+    return;
+
+  /* draw all visible lines this layer */
+  r_search (layer->line_tree, drawn_area, NULL, line_callback, layer);
+
+  /* draw the layer arcs on drawn_area */
+  r_search (layer->arc_tree, drawn_area, NULL, arc_callback, layer);
+
+  /* draw the layer text on drawn_area */
+  r_search (layer->text_tree, drawn_area, NULL, text_callback, layer);
+
+  /* We should check for gui->gui here, but it's kinda cool seeing the
+     auto-outline magically disappear when you first add something to
+     the "outline" layer.  */
+
+  if (strcmp (layer->Name, "outline") == 0 ||
+      strcmp (layer->Name, "route") == 0)
+    {
+      if (IsLayerEmpty (layer))
+        {
+          gui->set_color (Output.fgGC, layer->Color);
+          gui->set_line_width (Output.fgGC, PCB->minWid);
+          gui->draw_rect (Output.fgGC, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
+        }
+      return;
+    }
+
+  /* Don't draw vias on silk layers */
+  if (layer_num >= max_copper_layer)
+    return;
+
+#if 0
+  /* Don't draw vias on layers which are out of the layer stack */
+  if ((group >= component_group && group >= solder_group) ||
+      (group <= component_group && group <= solder_group))
+    return;
+#endif
+
+  /* draw element pins */
+  r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_inlayer_callback, layer);
+
+  /* draw element pads */
+  if (group == component_group)
+    r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_inlayer_callback, layer);
+
+  if (group == solder_group)
+    r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_inlayer_callback, layer);
+
+  /* draw vias */
+  r_search (PCB->Data->via_tree, drawn_area, NULL, via_inlayer_callback, layer);
+  r_search (PCB->Data->pin_tree, drawn_area, NULL, hole_callback, NULL);
+  r_search (PCB->Data->via_tree, drawn_area, NULL, hole_callback, NULL);
+}
+
+struct draw_funcs d_f = {
+  .draw_pin       = draw_pin,
+  .draw_pin_mask  = draw_pin_mask,
+  .draw_via       = draw_via,
+  .draw_via_mask  = draw_via_mask,
+  .draw_hole      = draw_hole,
+  .draw_pad       = draw_pad,
+  .draw_pad_mask  = draw_pad_mask,
+  .draw_pad_paste = draw_pad_paste,
+  .draw_line      = draw_line,
+  .draw_rat       = draw_rat,
+  .draw_arc       = draw_arc,
+  .draw_poly      = draw_poly,
+  .draw_layer     = draw_layer,
+};
+
+struct draw_funcs *dapi = &d_f;
diff --git a/src/hid.h b/src/hid.h
index 36aca75..2229d00 100644
--- a/src/hid.h
+++ b/src/hid.h
@@ -207,6 +207,7 @@ extern "C"
 #define SL_FAB		0x0070
 #define SL_ASSY		0x0080
 #define SL_RATS		0x0090
+#define SL_FINISHED	0x00A0
 /* Callers should use this.  */
 #define SL(type,side) (~0xfff | SL_##type | SL_##side##_SIDE)
 
diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index 2a6a749..3dc1991 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -576,28 +576,27 @@ hidgl_fill_polygon (int n_coords, int *x, int *y)
 }
 
 void
-tesselate_contour (GLUtesselator *tobj, PLINE *contour, GLdouble *vertices,
-                   int *i)
+tesselate_contour (GLUtesselator *tobj, PLINE *contour, GLdouble *vertices)
 {
   VNODE *vn = &contour->head;
-  int offset = *i * 3;
+  int offset = 0;
 
+  gluTessBeginPolygon (tobj, NULL);
   gluTessBeginContour (tobj);
   do {
     vertices [0 + offset] = vn->point[0];
     vertices [1 + offset] = vn->point[1];
     vertices [2 + offset] = 0.;
     gluTessVertex (tobj, &vertices [offset], &vertices [offset]);
-    (*i)++;
     offset += 3;
   } while ((vn = vn->next) != &contour->head);
   gluTessEndContour (tobj);
+  gluTessEndPolygon (tobj);
 }
 
 struct do_hole_info {
   GLUtesselator *tobj;
   GLdouble *vertices;
-  int *i;
 };
 
 static int
@@ -610,20 +609,23 @@ do_hole (const BoxType *b, void *cl)
   if (curc->Flags.orient == PLF_DIR) {
     return 0;
   }
-  gluTessBeginPolygon (info->tobj, NULL);
-  tesselate_contour (info->tobj, curc, info->vertices, info->i);
-  gluTessEndPolygon (info->tobj);
+
+  tesselate_contour (info->tobj, curc, info->vertices);
   return 1;
 }
 
+static GLint stencil_bits;
+static int dirty_bits = 0;
+static int assigned_bits = 0;
+
+/* FIXME: JUST DRAWS THE FIRST PIECE.. TODO: SUPPORT FOR FULLPOLY POLYGONS */
 void
 hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale)
 {
-  int i, cc;
   int vertex_count = 0;
   PLINE *contour;
   struct do_hole_info info;
-
+  int stencil_bit;
 
   global_scale = scale;
 
@@ -633,52 +635,64 @@ hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale
       return;
     }
 
-  /* TODO: Just draw our triangles, no need to flush the buffer */
+  stencil_bit = hidgl_assign_clear_stencil_bit ();
+  if (!stencil_bit)
+    {
+      printf ("hidgl_fill_pcb_polygon: No free stencil bits, aborting polygon\n");
+      return;
+    }
+
+  /* Flush out any existing geoemtry to be rendered */
   hidgl_flush_triangles (&buffer);
 
-  /* JUST DRAW THE FIRST PIECE */
   /* Walk the polygon structure, counting vertices */
   /* This gives an upper bound on the amount of storage required */
   for (contour = poly->Clipped->contours;
        contour != NULL; contour = contour->next)
-    vertex_count += contour->Count;
+    vertex_count = MAX (vertex_count, contour->Count);
 
   info.vertices = malloc (sizeof(GLdouble) * vertex_count * 3);
   info.tobj = gluNewTess ();
-  info.i = &i;
   gluTessCallback(info.tobj, GLU_TESS_BEGIN, myBegin);
   gluTessCallback(info.tobj, GLU_TESS_VERTEX, myVertex);
   gluTessCallback(info.tobj, GLU_TESS_COMBINE, myCombine);
   gluTessCallback(info.tobj, GLU_TESS_ERROR, myError);
 
-  glClearStencil (0);
-  glClear (GL_STENCIL_BUFFER_BIT);
-  glColorMask (0, 0, 0, 0);                   // Disable writting in color buffer
-  glEnable (GL_STENCIL_TEST);
-
-  i = 0;
-  cc = 1;
+  glPushAttrib (GL_STENCIL_BUFFER_BIT);                   // Save the write mask etc.. for final restore
+  glPushAttrib (GL_STENCIL_BUFFER_BIT |                   // Resave the stencil write-mask etc.., and
+                GL_COLOR_BUFFER_BIT);                     // the colour buffer write mask etc.. for part way restore
+  glStencilMask (stencil_bit);                            // Only write to our stencil bit
+  glStencilFunc (GL_ALWAYS, stencil_bit, stencil_bit);    // Always pass stencil test, ref value is our bit
+  glColorMask (0, 0, 0, 0);                               // Disable writting in color buffer
 
-  /* Drawing operations set the stencil buffer to '1' */
-  glStencilFunc (GL_ALWAYS, 1, 1);            // Test always passes, value written 1
-  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value (with 1)
+  /* It will already be setup like this (so avoid prodding the state-machine):
+   * glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value
+   */
+  /* Drawing operations now set our reference bit in the stencil buffer */
 
   r_search (poly->Clipped->contour_tree, clip_box, NULL, do_hole, &info);
   hidgl_flush_triangles (&buffer);
 
-  /* Drawing operations as masked to areas where the stencil buffer is '1' */
-  glColorMask (1, 1, 1, 1);                   // Enable drawing of r, g, b & a
-  glStencilFunc (GL_EQUAL, 0, 1);             // Draw only where stencil buffer is 0
-  glStencilOp (GL_KEEP, GL_KEEP, GL_KEEP);    // Stencil buffer read only
+  /* Drawing operations as masked to areas where the stencil buffer is '0' */
+
+  glPopAttrib ();                                             // Restore the colour and stencil buffer write-mask etc..
+
+  glStencilOp (GL_KEEP, GL_KEEP, GL_INVERT); // This allows us to toggle the bit on the subcompositing bitplane
+                                             // If the stencil test has passed, we know that bit is 0, so we're
+                                             // effectively just setting it to 1.
+  glStencilFunc (GL_GEQUAL, 0, assigned_bits);
+//  glStencilFunc (GL_GREATER, assigned_bits, assigned_bits);   // Pass stencil test if all assigned bits clear,
+                                                              // reference is all assigned bits so we set
+                                                              // any bits permitted by the stencil writemask
 
   /* Draw the polygon outer */
-  gluTessBeginPolygon (info.tobj, NULL);
-  tesselate_contour (info.tobj, poly->Clipped->contours, info.vertices, &i);
-  gluTessEndPolygon (info.tobj);
+  tesselate_contour (info.tobj, poly->Clipped->contours, info.vertices);
   hidgl_flush_triangles (&buffer);
 
-  glClear (GL_STENCIL_BUFFER_BIT);
-  glDisable (GL_STENCIL_TEST);                // Disable Stencil test
+  /* Unassign our stencil buffer bit */
+  hidgl_return_stencil_bit (stencil_bit);
+
+  glPopAttrib ();                                             // Restore the stencil buffer write-mask etc..
 
   gluDeleteTess (info.tobj);
   myFreeCombined ();
@@ -693,6 +707,92 @@ hidgl_fill_rect (int x1, int y1, int x2, int y2)
   hidgl_add_triangle (&buffer, x2, y1, x2, y2, x1, y1);
 }
 
+void
+hidgl_init (void)
+{
+  glGetIntegerv (GL_STENCIL_BITS, &stencil_bits);
+
+  if (stencil_bits == 0)
+    {
+      printf ("No stencil bits available.\n"
+              "Cannot mask polygon holes or subcomposite layers\n");
+      /* TODO: Flag this to the HID so it can revert to the dicer? */
+    }
+  else if (stencil_bits == 1)
+    {
+      printf ("Only one stencil bitplane avilable\n"
+              "Cannot use stencil buffer to sub-composite layers.\n");
+      /* Do we need to disable that somewhere? */
+    }
+}
+
+int
+hidgl_stencil_bits (void)
+{
+  return stencil_bits;
+}
+
+static void
+hidgl_clean_unassigned_stencil (void)
+{
+  glPushAttrib (GL_STENCIL_BUFFER_BIT);
+  glStencilMask (~assigned_bits);
+  glClearStencil (0);
+  glClear (GL_STENCIL_BUFFER_BIT);
+  glPopAttrib ();
+}
+
+int
+hidgl_assign_clear_stencil_bit (void)
+{
+  int stencil_bitmask = (1 << stencil_bits) - 1;
+  int test;
+  int first_dirty = 0;
+
+  if (assigned_bits == stencil_bitmask)
+    {
+      printf ("No more stencil bits available, total of %i already assigned\n",
+              stencil_bits);
+      return 0;
+    }
+
+  /* Look for a bitplane we don't have to clear */
+  for (test = 1; test & stencil_bitmask; test <<= 1)
+    {
+      if (!(test & dirty_bits))
+        {
+          assigned_bits |= test;
+          dirty_bits |= test;
+          return test;
+        }
+      else if (!first_dirty && !(test & assigned_bits))
+        {
+          first_dirty = test;
+        }
+    }
+
+  /* Didn't find any non dirty planes. Clear those dirty ones which aren't in use */
+  hidgl_clean_unassigned_stencil ();
+  assigned_bits |= first_dirty;
+  dirty_bits = assigned_bits;
+
+  return first_dirty;
+}
+
+void
+hidgl_return_stencil_bit (int bit)
+{
+  assigned_bits &= ~bit;
+}
+
+void
+hidgl_reset_stencil_usage (void)
+{
+  assigned_bits = 0;
+  dirty_bits = 0;
+}
+
+
 /* ---------------------------------------------------------------------- */
 
 #endif /* DISABLE EVERYTHING! */
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index 99ffffc..9dd76e3 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -76,5 +76,10 @@ void hidgl_fill_polygon (int n_coords, int *x, int *y);
 void hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale);
 void hidgl_fill_rect (int x1, int y1, int x2, int y2);
 
+void hidgl_init (void);
+int hidgl_stencil_bits (void);
+int hidgl_assign_clear_stencil_bit (void);
+void hidgl_return_stencil_bit (int bit);
+void hidgl_reset_stencil_usage (void);
 
 #endif /* __HIDGL_INCLUDED__  */
diff --git a/src/hid/gerber/gerber.c b/src/hid/gerber/gerber.c
index d5843ef..b65d678 100644
--- a/src/hid/gerber/gerber.c
+++ b/src/hid/gerber/gerber.c
@@ -516,6 +516,9 @@ gerber_set_layer (const char *name, int group, int empty)
 	     && group <
 	     max_group) ? PCB->LayerGroups.Entries[group][0] : group;
 
+  if (SL_TYPE (idx) == SL_FINISHED)
+    return 0;
+
   if (name == 0)
     name = PCB->Data->Layer[idx].Name;
 
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 1885e46..dae3366 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -21,6 +21,7 @@
 #include <GL/gl.h>
 #include <gtk/gtkgl.h>
 #include "hid/common/hidgl.h"
+#include "hid/common/draw_helpers.h"
 
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
@@ -63,6 +64,7 @@ int
 ghid_set_layer (const char *name, int group, int empty)
 {
   render_priv *priv = gport->render_priv;
+  static int stencil_bit = 0;
   int idx = group;
   if (idx >= 0 && idx < max_group)
     {
@@ -77,6 +79,31 @@ ghid_set_layer (const char *name, int group, int empty)
       idx = PCB->LayerGroups.Entries[group][idx];
     }
 
+#define SUBCOMPOSITE_LAYERS
+#ifdef SUBCOMPOSITE_LAYERS
+  /* Flush out any existing geoemtry to be rendered */
+  hidgl_flush_triangles (&buffer);
+
+  glEnable (GL_STENCIL_TEST);                // Enable Stencil test
+  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value (with 1)
+  /* Reset stencil buffer so we can paint anywhere */
+  hidgl_return_stencil_bit (stencil_bit);               // Relinquish any bitplane we previously used
+  if (SL_TYPE (idx) != SL_FINISHED)
+    {
+      stencil_bit = hidgl_assign_clear_stencil_bit();       // Get a new (clean) bitplane to stencil with
+      glStencilFunc (GL_GREATER, stencil_bit, stencil_bit); // Pass stencil test if our assigned bit is clear
+      glStencilMask (stencil_bit);                          // Only write to our subcompositing stencil bitplane
+    }
+  else
+    {
+#endif
+      stencil_bit = 0;
+      glStencilMask (0);
+      glStencilFunc (GL_ALWAYS, 0, 0);  // Always pass stencil test
+#ifdef SUBCOMPOSITE_LAYERS
+    }
+#endif
+
   if (idx >= 0 && idx < max_copper_layer + 2)
     {
       priv->trans_lines = true;
@@ -93,7 +120,7 @@ ghid_set_layer (const char *name, int group, int empty)
 	    return TEST_FLAG (SHOWMASKFLAG, PCB);
 	  return 0;
 	case SL_SILK:
-	  priv->trans_lines = false;
+	  priv->trans_lines = true;
 	  if (SL_MYSIDE (idx))
 	    return PCB->ElementOn;
 	  return 0;
@@ -281,13 +308,7 @@ ghid_draw_bg_image (void)
 void
 ghid_use_mask (int use_it)
 {
-  /* NOTE: We are assuming the stencil buffer bit plane is clear at the start
-   *       of a masked drawing operation.
-   *
-   *       For our current usage we know that it will start clean at the
-   *       beginning of the frame - and that the mask is only used at most
-   *       once during rendering (for the solder-mask layer).
-   */
+  static int stencil_bit = 0;
 
   /* THE FOLLOWING IS COMPLETE ABUSE OF THIS MASK RENDERING API... NOT IMPLEMENTED */
   if (use_it == HID_LIVE_DRAWING ||
@@ -299,6 +320,7 @@ ghid_use_mask (int use_it)
   if (use_it == cur_mask)
     return;
 
+  /* Flush out any existing geoemtry to be rendered */
   hidgl_flush_triangles (&buffer);
 
   switch (use_it)
@@ -309,21 +331,24 @@ ghid_use_mask (int use_it)
 
     case HID_MASK_CLEAR:
       /* Write '1' to the stencil buffer where the solder-mask should not be drawn. */
-      glColorMask (0, 0, 0, 0);                   // Disable writting in color buffer
-      glEnable (GL_STENCIL_TEST);                 // Enable Stencil test
-      glStencilFunc (GL_ALWAYS, 1, 1);            // Test always passes, value written 1
-      glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value (with 1)
+      glColorMask (0, 0, 0, 0);                             // Disable writting in color buffer
+      glEnable (GL_STENCIL_TEST);                           // Enable Stencil test
+      stencil_bit = hidgl_assign_clear_stencil_bit();       // Get a new (clean) bitplane to stencil with
+      glStencilFunc (GL_ALWAYS, stencil_bit, stencil_bit);  // Always pass stencil test, write stencil_bit
+      glStencilMask (stencil_bit);                          // Only write to our subcompositing stencil bitplane
+      glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);           // Stencil pass => replace stencil value (with 1)
       break;
 
     case HID_MASK_AFTER:
       /* Drawing operations as masked to areas where the stencil buffer is '0' */
       glColorMask (1, 1, 1, 1);                   // Enable drawing of r, g, b & a
-      glStencilFunc (GL_EQUAL, 0, 1);             // Draw only where stencil buffer is 1
+      glStencilFunc (GL_GEQUAL, 0, stencil_bit);  // Draw only where our bit of the stencil buffer is clear
       glStencilOp (GL_KEEP, GL_KEEP, GL_KEEP);    // Stencil buffer read only
       break;
 
     case HID_MASK_OFF:
       /* Disable stenciling */
+      hidgl_return_stencil_bit (stencil_bit);     // Relinquish any bitplane we previously used
       glDisable (GL_STENCIL_TEST);                // Disable Stencil test
       break;
     }
@@ -897,6 +922,17 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   ghid_start_drawing (port);
 
+  hidgl_init ();
+
+  /* If we don't have any stencil bits available,
+     we can't use the hidgl polygon drawing routine */
+  /* TODO: We could use the GLU tessellator though */
+  if (hidgl_stencil_bits() == 0)
+    {
+      ghid_hid.fill_pcb_polygon = common_fill_pcb_polygon;
+      ghid_hid.poly_dicer = 1;
+    }
+
   glEnable (GL_BLEND);
   glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
 
@@ -914,12 +950,20 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glLoadIdentity ();
   glTranslatef (0.0f, 0.0f, -Z_NEAR);
 
+  glEnable (GL_STENCIL_TEST);
   glClearColor (port->offlimits_color.red / 65535.,
                 port->offlimits_color.green / 65535.,
                 port->offlimits_color.blue / 65535.,
                 1.);
 
+  glStencilMask (~0);
+  glClearStencil (0);
   glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
+  hidgl_reset_stencil_usage ();
+
+  /* Disable the stencil test until we need it - otherwise it gets dirty */
+  glDisable (GL_STENCIL_TEST);
+  glStencilFunc (GL_ALWAYS, 0, 0);
 
   region.X1 = MIN (Px (ev->area.x), Px (ev->area.x + ev->area.width + 1));
   region.X2 = MAX (Px (ev->area.x), Px (ev->area.x + ev->area.width + 1));
@@ -945,6 +989,12 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
 
+  /* Setup stenciling */
+  /* Drawing operations set the stencil buffer to '1' */
+  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value (with 1)
+  /* Drawing operations as masked to areas where the stencil buffer is '0' */
+//  glStencilFunc (GL_GREATER, 1, 1);             // Draw only where stencil buffer is 0
+
   glPushMatrix ();
   glScalef ((ghid_flip_x ? -1. : 1.) / port->zoom,
             (ghid_flip_y ? -1. : 1.) / port->zoom,
@@ -1066,9 +1116,12 @@ ghid_pinout_preview_expose (GtkWidget *widget,
                 gport->bg_color.green / 65535.,
                 gport->bg_color.blue / 65535.,
                 1.);
-
+  glStencilMask (~0);
+  glClearStencil (0);
   glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
 
+  hidgl_reset_stencil_usage ();
+
   /* call the drawing routine */
   hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
@@ -1176,8 +1229,10 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
                 gport->bg_color.green / 65535.,
                 gport->bg_color.blue / 65535.,
                 1.);
+  glStencilMask (~0);
   glClearStencil (0);
   glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
+  hidgl_reset_stencil_usage ();
 
   /* call the drawing routine */
   hidgl_init_triangle_array (&buffer);
diff --git a/src/hid/nelma/nelma.c b/src/hid/nelma/nelma.c
index 6e911ff..7f69d75 100644
--- a/src/hid/nelma/nelma.c
+++ b/src/hid/nelma/nelma.c
@@ -706,6 +706,10 @@ nelma_set_layer(const char *name, int group, int empty)
 	int             idx = (group >= 0 && group < max_group) ?
 	PCB->LayerGroups.Entries[group][0] : group;
 
+	if (SL_TYPE (idx) == SL_FINISHED) {
+		return 0;
+	}
+
 	if (name == 0) {
 		name = PCB->Data->Layer[idx].Name;
 	}
diff --git a/src/hid/png/png.c b/src/hid/png/png.c
index ab64e5a..1556b46 100644
--- a/src/hid/png/png.c
+++ b/src/hid/png/png.c
@@ -909,6 +909,10 @@ png_set_layer (const char *name, int group, int empty)
   int idx = (group >= 0
 	     && group <
 	     max_group) ? PCB->LayerGroups.Entries[group][0] : group;
+
+  if (SL_TYPE (idx) == SL_FINISHED)
+    return 0;
+
   if (name == 0)
     name = PCB->Data->Layer[idx].Name;
 
diff --git a/src/hid/ps/eps.c b/src/hid/ps/eps.c
index f94175f..c37dcbf 100644
--- a/src/hid/ps/eps.c
+++ b/src/hid/ps/eps.c
@@ -339,6 +339,10 @@ eps_set_layer (const char *name, int group, int empty)
   int idx = (group >= 0
 	     && group <
 	     max_group) ? PCB->LayerGroups.Entries[group][0] : group;
+
+  if (SL_TYPE (idx) == SL_FINISHED)
+    return 0;
+
   if (name == 0)
     name = PCB->Data->Layer[idx].Name;
 
diff --git a/src/hid/ps/ps.c b/src/hid/ps/ps.c
index a417753..e5b12cb 100644
--- a/src/hid/ps/ps.c
+++ b/src/hid/ps/ps.c
@@ -651,6 +651,10 @@ ps_set_layer (const char *name, int group, int empty)
   int idx = (group >= 0
 	     && group <
 	     max_group) ? PCB->LayerGroups.Entries[group][0] : group;
+
+  if (SL_TYPE (idx) == SL_FINISHED)
+    return 0;
+
   if (name == 0)
     name = PCB->Data->Layer[idx].Name;

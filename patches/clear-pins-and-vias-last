Bottom: 184864d916f813a76376f70f8cf8e83cb30b85b2
Top:    a04f243905db0740aaa891a853c1327e6cd408ed
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-10-22 04:48:51 +0100

Clear pins and vias last...

There is a chance these objects are simpler, and just end up as holes in
the main polygon, rather than causing a contour intersection. This means
it is cheaper to add them last.

If we add them first, and make the polygon complex, objects (usually
lines) which pierce the polygon's outer contour cause all the holes to
be removed and queued for re-insersion after the new contour is
constructed.

Also, some serious speedup....

Accumulate polygons to clear from lines and pins in batches, then
clear from the polygon. Not quite sure why, but this _really_ seems to
speed up loading very complex boards. (e.g. 50sec -> 10sec for one example).

Possibly this is because withing the assembled batches, it is cheaper to
produce a more unified contour (touching lines), and the complex contours
of the main polygon are broken less frequently.

It isn't quite clear why this helps so much for pins / vias (which won't
usually touch each-other), however it changes a 50sec load time to 10 sec.
This could perhaps be because any contours which are smashed by clearance
of closely spaced vias / pins now only incurr the penalty of breaking the
main contour once every batch (100 vias / pins).

Batch sizes (20 for lines, 100 for pins / vias) aren't necessarily optimal!


---

diff --git a/src/polygon.c b/src/polygon.c
index ca69338..3ecf0ac 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -791,22 +791,54 @@ struct cpInfo
   LayerType *layer;
   PolygonType *polygon;
   Boolean solder;
+  POLYAREA *accumulate;
   jmp_buf env;
 };
 
 static int
 pin_sub_callback (const BoxType * b, void *cl)
 {
+  static int counter = 0;
   PinTypePtr pin = (PinTypePtr) b;
   struct cpInfo *info = (struct cpInfo *) cl;
   PolygonTypePtr polygon;
+  POLYAREA *np;
+  POLYAREA *merged;
+  Cardinal i;
 
   /* don't subtract the object that was put back! */
   if (b == info->other)
     return 0;
   polygon = info->polygon;
-  if (SubtractPin (info->data, pin, info->layer, polygon) < 0)
-    longjmp (info->env, 1);
+
+  if (pin->Clearance == 0)
+    return 0;
+  i = GetLayerNumber (info->data, info->layer);
+  if (TEST_THERM (i, pin))
+    {
+      np = ThermPoly ((PCBTypePtr) (info->data->pcb), pin, i);
+      if (!np)
+        return 0;
+    }
+  else
+    {
+      np = PinPoly (pin, pin->Thickness, pin->Clearance);
+      if (!np)
+        return -1;
+    }
+
+  poly_Boolean_free (info->accumulate, np, &merged, PBO_UNITE);
+  info->accumulate = merged;
+
+  counter ++;
+
+  if (counter == 100)
+    {
+      counter = 0;
+      Subtract (info->accumulate, polygon, True);
+      info->accumulate = NULL;
+    }
+
   return 1;
 }
 
@@ -851,9 +883,12 @@ pad_sub_callback (const BoxType * b, void *cl)
 static int
 line_sub_callback (const BoxType * b, void *cl)
 {
+  static int counter = 0;
   LineTypePtr line = (LineTypePtr) b;
   struct cpInfo *info = (struct cpInfo *) cl;
   PolygonTypePtr polygon;
+  POLYAREA *np;
+  POLYAREA *merged;
 
   /* don't subtract the object that was put back! */
   if (b == info->other)
@@ -861,8 +896,22 @@ line_sub_callback (const BoxType * b, void *cl)
   if (!TEST_FLAG (CLEARLINEFLAG, line))
     return 0;
   polygon = info->polygon;
-  if (SubtractLine (line, polygon) < 0)
+
+  if (!(np = LinePoly (line, line->Thickness + line->Clearance)))
     longjmp (info->env, 1);
+
+  poly_Boolean_free (info->accumulate, np, &merged, PBO_UNITE);
+  info->accumulate = merged;
+
+  counter ++;
+
+  if (counter == 20)
+    {
+      counter = 0;
+      Subtract (info->accumulate, polygon, True);
+      info->accumulate = NULL;
+    }
+
   return 1;
 }
 
@@ -921,21 +970,27 @@ clearPoly (DataTypePtr Data, LayerTypePtr Layer, PolygonType * polygon,
 
   if (setjmp (info.env) == 0)
     {
-      r = r_search (Data->via_tree, &region, NULL, pin_sub_callback, &info);
-      r += r_search (Data->pin_tree, &region, NULL, pin_sub_callback, &info);
+      r = 0;
+      info.accumulate = NULL;
+      if (info.solder || group == Group (Data, max_layer + COMPONENT_LAYER))
+	r += r_search (Data->pad_tree, &region, NULL, pad_sub_callback, &info);
       GROUP_LOOP (Data, group);
       {
         r +=
           r_search (layer->line_tree, &region, NULL, line_sub_callback,
                     &info);
+        Subtract (info.accumulate, polygon, True);
+        info.accumulate = NULL;
         r +=
           r_search (layer->arc_tree, &region, NULL, arc_sub_callback, &info);
 	r +=
           r_search (layer->text_tree, &region, NULL, text_sub_callback, &info);
       }
       END_LOOP;
-      if (info.solder || group == Group (Data, max_layer + COMPONENT_LAYER))
-	r += r_search (Data->pad_tree, &region, NULL, pad_sub_callback, &info);
+      r += r_search (Data->via_tree, &region, NULL, pin_sub_callback, &info);
+      r += r_search (Data->pin_tree, &region, NULL, pin_sub_callback, &info);
+      Subtract (info.accumulate, polygon, True);
+      info.accumulate = NULL;
     }
   polygon->NoHolesValid = 0;
   return r;

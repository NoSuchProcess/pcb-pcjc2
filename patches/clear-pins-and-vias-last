Bottom: 43652651f7dfb911aa4b39019f332261704d94c5
Top:    8de7882cdf5c40d0529c9a9eef4c97a25ccadbad
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-02-23 01:08:53 +0000

Clear pins and vias last...

There is a chance these objects are simpler, and just end up as holes in
the main polygon, rather than causing a contour intersection. This means
it is cheaper to add them last.

If we add them first, and make the polygon complex, objects (usually
lines) which pierce the polygon's outer contour cause all the holes to
be removed and queued for re-insersion after the new contour is
constructed.


---

diff --git a/src/polygon.c b/src/polygon.c
index 57fb94e..49834af 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -791,22 +791,54 @@ struct cpInfo
   LayerType *layer;
   PolygonType *polygon;
   Boolean solder;
+  POLYAREA *accumulate;
   jmp_buf env;
 };
 
 static int
 pin_sub_callback (const BoxType * b, void *cl)
 {
+  static int counter = 0;
   PinTypePtr pin = (PinTypePtr) b;
   struct cpInfo *info = (struct cpInfo *) cl;
   PolygonTypePtr polygon;
+  POLYAREA *np;
+  POLYAREA *merged;
+  Cardinal i;
 
   /* don't subtract the object that was put back! */
   if (b == info->other)
     return 0;
   polygon = info->polygon;
-  if (SubtractPin (info->data, pin, info->layer, polygon) < 0)
-    longjmp (info->env, 1);
+
+  if (pin->Clearance == 0)
+    return 0;
+  i = GetLayerNumber (info->data, info->layer);
+  if (TEST_THERM (i, pin))
+    {
+      np = ThermPoly ((PCBTypePtr) (info->data->pcb), pin, i);
+      if (!np)
+        return 0;
+    }
+  else
+    {
+      np = PinPoly (pin, pin->Thickness, pin->Clearance);
+      if (!np)
+        return -1;
+    }
+
+  poly_Boolean_free (info->accumulate, np, &merged, PBO_UNITE);
+  info->accumulate = merged;
+
+  counter ++;
+
+  if (counter == 100)
+    {
+      counter = 0;
+      Subtract (info->accumulate, polygon, True);
+      info->accumulate = NULL;
+    }
+
   return 1;
 }
 
@@ -851,9 +883,12 @@ pad_sub_callback (const BoxType * b, void *cl)
 static int
 line_sub_callback (const BoxType * b, void *cl)
 {
+  static int counter = 0;
   LineTypePtr line = (LineTypePtr) b;
   struct cpInfo *info = (struct cpInfo *) cl;
   PolygonTypePtr polygon;
+  POLYAREA *np;
+  POLYAREA *merged;
 
   /* don't subtract the object that was put back! */
   if (b == info->other)
@@ -861,8 +896,22 @@ line_sub_callback (const BoxType * b, void *cl)
   if (!TEST_FLAG (CLEARLINEFLAG, line))
     return 0;
   polygon = info->polygon;
-  if (SubtractLine (line, polygon) < 0)
+
+  if (!(np = LinePoly (line, line->Thickness + line->Clearance)))
     longjmp (info->env, 1);
+
+  poly_Boolean_free (info->accumulate, np, &merged, PBO_UNITE);
+  info->accumulate = merged;
+
+  counter ++;
+
+  if (counter == 20)
+    {
+      counter = 0;
+      Subtract (info->accumulate, polygon, True);
+      info->accumulate = NULL;
+    }
+
   return 1;
 }
 
@@ -921,21 +970,27 @@ clearPoly (DataTypePtr Data, LayerTypePtr Layer, PolygonType * polygon,
 
   if (setjmp (info.env) == 0)
     {
-      r = r_search (Data->via_tree, &region, NULL, pin_sub_callback, &info);
-      r += r_search (Data->pin_tree, &region, NULL, pin_sub_callback, &info);
+      r = 0;
+      info.accumulate = NULL;
+      if (info.solder || group == Group (Data, max_layer + COMPONENT_LAYER))
+	r += r_search (Data->pad_tree, &region, NULL, pad_sub_callback, &info);
       GROUP_LOOP (Data, group);
       {
         r +=
           r_search (layer->line_tree, &region, NULL, line_sub_callback,
                     &info);
+        Subtract (info.accumulate, polygon, True);
+        info.accumulate = NULL;
         r +=
           r_search (layer->arc_tree, &region, NULL, arc_sub_callback, &info);
 	r +=
           r_search (layer->text_tree, &region, NULL, text_sub_callback, &info);
       }
       END_LOOP;
-      if (info.solder || group == Group (Data, max_layer + COMPONENT_LAYER))
-	r += r_search (Data->pad_tree, &region, NULL, pad_sub_callback, &info);
+      r += r_search (Data->via_tree, &region, NULL, pin_sub_callback, &info);
+      r += r_search (Data->pin_tree, &region, NULL, pin_sub_callback, &info);
+      Subtract (info.accumulate, polygon, True);
+      info.accumulate = NULL;
     }
   polygon->NoHolesValid = 0;
   return r;

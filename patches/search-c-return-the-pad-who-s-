Bottom: 7250e4ed08e6ffabeb1859e937216eedbc30d3e4
Top:    2870d358f80dad12290610813bf5ee4a1a506857
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-12-16 00:56:12 +0000

search.c: Return the pad who's center is closest to the queried coordinate

When snapping to pads we often find the case where the search radius is
wider than the spacing between pads. SearchPadByLocation() previously
returned the first pad it found whthin the search area, meaning you could
have the crosshair right above a particular pad, yet snap to a different
pad due to it being within the search radius of the crosshair, and
happening to be tested first by the r-tree search code.

This proof of concept change makes SearchPadByLocation() return the pad
whos center coordinate is closest to the center of the search location.

This fixes another annoying snapping behaviour for some parts such as
"0805", when operating with a fairly course grid. (NB: Search radius
for snapping is related to the size of the current grid).


---

diff --git a/src/search.c b/src/search.c
index 5d02a53..5417462 100644
--- a/src/search.c
+++ b/src/search.c
@@ -106,6 +106,8 @@ struct ans_info
   double area;
   jmp_buf env;
   int locked;			/* This will be zero or LOCKFLAG */
+  bool found_anything;
+  double nearest_sq_dist;
 };
 
 static int
@@ -182,19 +184,28 @@ pad_callback (const BoxType * b, void *cl)
   PadTypePtr pad = (PadTypePtr) b;
   struct ans_info *i = (struct ans_info *) cl;
   AnyObjectType *ptr1 = pad->Element;
+  double sq_dist;
 
-  if (TEST_FLAG (i->locked, ptr1))
+  /* Reject locked pads, backside pads (if !BackToo), and non-hit pads */
+  if (TEST_FLAG (i->locked, ptr1) ||
+      (!FRONT (pad) && !i->BackToo) ||
+      !IsPointInPad (PosX, PosY, SearchRadius, pad))
     return 0;
 
-  if (FRONT (pad) || i->BackToo)
+  /* Determine how close our test-position was to the center of the pad  */
+  sq_dist = (PosX - (pad->Point1.X + (pad->Point2.X - pad->Point1.X) / 2)) *
+            (PosX - (pad->Point1.X + (pad->Point2.X - pad->Point1.X) / 2)) +
+            (PosY - (pad->Point1.Y + (pad->Point2.Y - pad->Point1.Y) / 2)) *
+            (PosY - (pad->Point1.Y + (pad->Point2.Y - pad->Point1.Y) / 2));
+
+  /* If this was the closest hit so far, record it */
+  if (!i->found_anything || sq_dist < i->nearest_sq_dist)
     {
-      if (IsPointInPad (PosX, PosY, SearchRadius, pad))
-	    {
-	      *i->ptr1 = ptr1;
-	      *i->ptr2 = *i->ptr3 = pad;
-	      longjmp (i->env, 1);
-	    }
-	}
+      *i->ptr1 = ptr1;
+      *i->ptr2 = *i->ptr3 = pad;
+      i->found_anything = true;
+      i->nearest_sq_dist = sq_dist;
+    }
   return 0;
 }
 
@@ -216,11 +227,9 @@ SearchPadByLocation (int locked, ElementTypePtr * Element, PadTypePtr * Pad,
   info.ptr3 = (void **) Dummy;
   info.locked = (locked & LOCKED_TYPE) ? 0 : LOCKFLAG;
   info.BackToo = (BackToo && PCB->InvisibleObjectsOn);
-  if (setjmp (info.env) == 0)
-    r_search (PCB->Data->pad_tree, &SearchBox, NULL, pad_callback, &info);
-  else
-    return true;
-  return false;
+  info.found_anything = false;
+  r_search (PCB->Data->pad_tree, &SearchBox, NULL, pad_callback, &info);
+  return info.found_anything;
 }
 
 /* ---------------------------------------------------------------------------

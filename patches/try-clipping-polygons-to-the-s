Bottom: 31da5598b70aab97ecc1de4e5413283b8edd0475
Top:    eb2748402cd5024c83576b62490298f61c414326
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-02-06 19:45:38 +0000

Try clipping polygons to the screen using our own algebra, not GL









---

diff --git a/src/draw.c b/src/draw.c
index d814c6d..e3f8dff 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -103,7 +103,7 @@ static void DrawPolygonLowLevel (PolygonTypePtr);
 static void DrawPourLowLevel (PourTypePtr);
 static void DrawArcLowLevel (ArcTypePtr);
 static void DrawElementPackageLowLevel (ElementTypePtr Element, int);
-static void DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon);
+static void DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon, const BoxType *);
 static void AddPart (void *);
 static void SetPVColor (PinTypePtr, int);
 /* static */ void DrawEMark (ElementTypePtr, LocationType, LocationType, bool);
@@ -697,7 +697,7 @@ poly_callback (const BoxType * b, void *cl)
   struct pin_info *i = (struct pin_info *) cl;
 
 //  printf ("Got one poly callback, %p\n", b);
-  DrawPlainPolygon (i->Layer, (PolygonTypePtr) b);
+  DrawPlainPolygon (i->Layer, (PolygonTypePtr) b, i->clip);
 
   return 1;
 }
@@ -2105,7 +2105,7 @@ thin_callback (PLINE * pl, LayerTypePtr lay, PolygonTypePtr poly)
  * draws a polygon
  */
 static void
-DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
+DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon, const BoxType * clip)
 {
   static char *color;
 
@@ -2118,8 +2118,15 @@ DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
 
   if (Gathering)
     {
+<<<<<<< current
       AddPart (Polygon);
       return;
+=======
+      if (TEST_FLAG (SELECTEDFLAG, Polygon))
+        gui->set_color (Output.fgGC, Layer->SelectedColor);
+      else
+        gui->set_color (Output.fgGC, PCB->ConnectedColor);
+>>>>>>> patched
     }
 
   if (TEST_FLAG (SELECTEDFLAG, Polygon))
@@ -2127,6 +2134,7 @@ DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
   else if (TEST_FLAG (FOUNDFLAG, Polygon))
     color = PCB->ConnectedColor;
   else
+<<<<<<< current
     color = Layer->Color;
   gui->set_color (Output.fgGC, color);
 
@@ -2148,6 +2156,80 @@ DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
            poly.Clipped != Polygon->Clipped;
            poly.Clipped = poly.Clipped->f)
         gui->thindraw_pcb_polygon (Output.fgGC, &poly, clip_box);
+=======
+    gui->set_color (Output.fgGC, Layer->Color);
+
+  /* if the gui has the dicer flag set then it won't accept thin draw */
+  if ((TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG (THINDRAWPOLYFLAG, PCB))
+      && !gui->poly_dicer)
+    {
+      DrawPolygonLowLevel (Polygon, NULL);
+      if (!Gathering)
+        PolygonHoles (clip_box, Layer, Polygon, thin_callback);
+    }
+  else if (Polygon->Clipped)
+    {
+      if (!Polygon->NoHolesValid)
+        ComputeNoHoles (Polygon);
+      if (Polygon->NoHoles != NULL)
+        {
+          int x;
+          POLYAREA *tmp, *clip_poly, *noholes_piece;
+          PolygonType poly = *Polygon;
+
+          if (clip != NULL)
+            clip_poly = BoxPolyBloated (clip, 0);
+
+          noholes_piece = Polygon->NoHoles;
+          do
+            {
+              POLYAREA *tmp_b, *tmp_f;
+
+              tmp_b = noholes_piece->b;
+              tmp_f = noholes_piece->f;
+
+              noholes_piece->b = noholes_piece;
+              noholes_piece->f = noholes_piece;
+
+              poly.Clipped = noholes_piece;
+
+              if (clip != NULL)
+                {
+                  x = poly_Boolean (noholes_piece, clip_poly,
+                                    &poly.Clipped, PBO_ISECT);
+                  if (x != err_ok)
+                    {
+                      poly_Free (&clip_poly);
+                      fprintf (stderr, "Error while clipping PBO_ISECT: %d\n", x);
+                      return;
+                    }
+                }
+
+              if (poly.Clipped != NULL)
+                {
+                  tmp = poly.Clipped;
+                  do
+                    {
+                      DrawPolygonLowLevel (&poly, NULL);
+                      poly.Clipped = poly.Clipped->f;
+                    }
+                  while (poly.Clipped != tmp);
+
+                  if (clip != NULL)
+                    poly_Free (&poly.Clipped);
+                }
+
+              noholes_piece->b = tmp_b;
+              noholes_piece->f = tmp_f;
+
+              noholes_piece = tmp_f;
+            }
+          while (noholes_piece != Polygon->NoHoles);
+
+          if (clip != NULL)
+            poly_Free (&clip_poly);
+        }
+>>>>>>> patched
     }
 }
 
diff --git a/src/polygon.c b/src/polygon.c
index e7dab26..1b13a19 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -700,7 +700,7 @@ PinPoly (PinType * pin, BDimension thick, BDimension clear)
 }
 
 POLYAREA *
-BoxPolyBloated (BoxType *box, BDimension bloat)
+BoxPolyBloated (const BoxType *box, BDimension bloat)
 {
   return RectPoly (box->X1 - bloat, box->X2 + bloat,
                    box->Y1 - bloat, box->Y2 + bloat);
diff --git a/src/polygon.h b/src/polygon.h
index 05a6fec..73d4b2d 100644
--- a/src/polygon.h
+++ b/src/polygon.h
@@ -51,7 +51,7 @@ POLYAREA * LinePoly(LineType *l, BDimension thick);
 POLYAREA * SquarePadPoly (PadType * pad, BDimension clear);
 
 POLYAREA * PinPoly(PinType *l, BDimension thick, BDimension clear);
-POLYAREA * BoxPolyBloated (BoxType *box, BDimension radius);
+POLYAREA * BoxPolyBloated (const BoxType *box, BDimension radius);
 
 int InitClip(DataType *d, LayerType *l, PolygonType *p);
 void RestoreToPolygon(DataType *, int, void *, void *);
diff --git a/src/pour.c b/src/pour.c
index cf51bd9..729f06a 100644
--- a/src/pour.c
+++ b/src/pour.c
@@ -351,7 +351,7 @@ unite_poly (POLYAREA * np, POLYAREA ** pg)
   return 1;
 }
 
-static int
+int
 intersect_poly (POLYAREA * np, POLYAREA ** pg)
 {
   POLYAREA *merged;

Bottom: 8e7763275343cec76c886177ec77088f52190d70
Top:    f86dd044c4a8091f130c41a1b70a7b21092a5f68
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2012-12-24 00:45:33 +0000

find.c: Pass flags to sub-functions without using static variable "TheFlag".


---

diff --git a/src/find.c b/src/find.c
index 2b22abe..ee8c82a 100644
--- a/src/find.c
+++ b/src/find.c
@@ -268,7 +268,6 @@ typedef struct
  * some local identifiers
  */
 static Coord Bloat = 0;
-static int TheFlag = FOUNDFLAG;
 static void *thing_ptr1, *thing_ptr2, *thing_ptr3;
 static int thing_type;
 static bool User = false;    /* user action causing this */
@@ -281,11 +280,11 @@ static ListType LineList[MAX_LAYER],    /* list of objects to */
 /* ---------------------------------------------------------------------------
  * some local prototypes
  */
-static bool LookupLOConnectionsToLine (LineType *, Cardinal, bool, bool);
-static bool LookupLOConnectionsToPad (PadType *, Cardinal, bool);
-static bool LookupLOConnectionsToPolygon (PolygonType *, Cardinal, bool);
-static bool LookupLOConnectionsToArc (ArcType *, Cardinal, bool);
-static bool LookupLOConnectionsToRatEnd (PointType *, Cardinal);
+static bool LookupLOConnectionsToLine (LineType *, Cardinal, int, bool, bool);
+static bool LookupLOConnectionsToPad (PadType *, Cardinal, int, bool);
+static bool LookupLOConnectionsToPolygon (PolygonType *, Cardinal, int, bool);
+static bool LookupLOConnectionsToArc (ArcType *, Cardinal, int, bool);
+static bool LookupLOConnectionsToRatEnd (PointType *, Cardinal, int);
 static bool IsRatPointOnLineEnd (PointType *, LineType *);
 static bool ArcArcIntersect (ArcType *, ArcType *);
 static bool PrepareNextLoop (FILE *);
@@ -316,14 +315,14 @@ ArcPadIntersect (ArcType *Arc, PadType *Pad)
 }
 
 static bool
-add_object_to_list (ListType *list, int type, void *ptr1, void *ptr2, void *ptr3)
+add_object_to_list (ListType *list, int type, void *ptr1, void *ptr2, void *ptr3, int flag)
 {
   AnyObjectType *object = (AnyObjectType *)ptr2;
 
   if (User)
     AddObjectToFlagUndoList (type, ptr1, ptr2, ptr3);
 
-  SET_FLAG (TheFlag, object);
+  SET_FLAG (flag, object);
   LIST_ENTRY (list, list->Number) = object;
   list->Number++;
 
@@ -338,40 +337,40 @@ add_object_to_list (ListType *list, int type, void *ptr1, void *ptr2, void *ptr3
 }
 
 static bool
-ADD_PV_TO_LIST (PinType *Pin)
+ADD_PV_TO_LIST (PinType *Pin, int flag)
 {
   return add_object_to_list (&PVList, Pin->Element ? PIN_TYPE : VIA_TYPE,
-                             Pin->Element ? Pin->Element : Pin, Pin, Pin);
+                             Pin->Element ? Pin->Element : Pin, Pin, Pin, flag);
 }
 
 static bool
-ADD_PAD_TO_LIST (Cardinal L, PadType *Pad)
-{
-  return add_object_to_list (&PadList[L], PAD_TYPE, Pad->Element, Pad, Pad);
+ADD_PAD_TO_LIST (Cardinal L, PadType *Pad, int flag)
+{ 
+  return add_object_to_list (&PadList[L], PAD_TYPE, Pad->Element, Pad, Pad, flag);
 }
 
 static bool
-ADD_LINE_TO_LIST (Cardinal L, LineType *Ptr)
+ADD_LINE_TO_LIST (Cardinal L, LineType *Ptr, int flag)
 {
-  return add_object_to_list (&LineList[L], LINE_TYPE, LAYER_PTR (L), Ptr, Ptr);
+  return add_object_to_list (&LineList[L], LINE_TYPE, LAYER_PTR (L), Ptr, Ptr, flag);
 }
 
 static bool
-ADD_ARC_TO_LIST (Cardinal L, ArcType *Ptr)
+ADD_ARC_TO_LIST (Cardinal L, ArcType *Ptr, int flag)
 {
-  return add_object_to_list (&ArcList[L], ARC_TYPE, LAYER_PTR (L), Ptr, Ptr);
+  return add_object_to_list (&ArcList[L], ARC_TYPE, LAYER_PTR (L), Ptr, Ptr, flag);
 }
 
 static bool
-ADD_RAT_TO_LIST (RatType *Ptr)
+ADD_RAT_TO_LIST (RatType *Ptr, int flag)
 {
-  return add_object_to_list (&RatList, RATLINE_TYPE, Ptr, Ptr, Ptr);
+  return add_object_to_list (&RatList, RATLINE_TYPE, Ptr, Ptr, Ptr, flag);
 }
 
 static bool
-ADD_POLYGON_TO_LIST (Cardinal L, PolygonType *Ptr)
+ADD_POLYGON_TO_LIST (Cardinal L, PolygonType *Ptr, int flag)
 {
-  return add_object_to_list (&PolygonList[L], POLYGON_TYPE, LAYER_PTR (L), Ptr, Ptr);
+  return add_object_to_list (&PolygonList[L], POLYGON_TYPE, LAYER_PTR (L), Ptr, Ptr, flag);
 }
 
 static BoxType
@@ -605,6 +604,7 @@ struct pv_info
 {
   Cardinal layer;
   PinType *pv;
+  int flag;
   jmp_buf env;
 };
 
@@ -614,10 +614,10 @@ LOCtoPVline_callback (const BoxType * b, void *cl)
   LineType *line = (LineType *) b;
   struct pv_info *i = (struct pv_info *) cl;
 
-  if (!TEST_FLAG (TheFlag, line) && PinLineIntersect (i->pv, line) &&
+  if (!TEST_FLAG (i->flag, line) && PinLineIntersect (i->pv, line) &&
       !TEST_FLAG (HOLEFLAG, i->pv))
     {
-      if (ADD_LINE_TO_LIST (i->layer, line))
+      if (ADD_LINE_TO_LIST (i->layer, line, i->flag))
         longjmp (i->env, 1);
     }
   return 0;
@@ -629,10 +629,10 @@ LOCtoPVarc_callback (const BoxType * b, void *cl)
   ArcType *arc = (ArcType *) b;
   struct pv_info *i = (struct pv_info *) cl;
 
-  if (!TEST_FLAG (TheFlag, arc) && IS_PV_ON_ARC (i->pv, arc) &&
+  if (!TEST_FLAG (i->flag, arc) && IS_PV_ON_ARC (i->pv, arc) &&
       !TEST_FLAG (HOLEFLAG, i->pv))
     {
-      if (ADD_ARC_TO_LIST (i->layer, arc))
+      if (ADD_ARC_TO_LIST (i->layer, arc, i->flag))
         longjmp (i->env, 1);
     }
   return 0;
@@ -644,10 +644,10 @@ LOCtoPVpad_callback (const BoxType * b, void *cl)
   PadType *pad = (PadType *) b;
   struct pv_info *i = (struct pv_info *) cl;
 
-  if (!TEST_FLAG (TheFlag, pad) && IS_PV_ON_PAD (i->pv, pad) &&
+  if (!TEST_FLAG (i->flag, pad) && IS_PV_ON_PAD (i->pv, pad) &&
       !TEST_FLAG (HOLEFLAG, i->pv) &&
       ADD_PAD_TO_LIST (TEST_FLAG (ONSOLDERFLAG, pad) ? SOLDER_LAYER :
-                       COMPONENT_LAYER, pad))
+                       COMPONENT_LAYER, pad, i->flag))
     longjmp (i->env, 1);
   return 0;
 }
@@ -658,8 +658,8 @@ LOCtoPVrat_callback (const BoxType * b, void *cl)
   RatType *rat = (RatType *) b;
   struct pv_info *i = (struct pv_info *) cl;
 
-  if (!TEST_FLAG (TheFlag, rat) && IS_PV_ON_RAT (i->pv, rat) &&
-      ADD_RAT_TO_LIST (rat))
+  if (!TEST_FLAG (i->flag, rat) && IS_PV_ON_RAT (i->pv, rat) &&
+      ADD_RAT_TO_LIST (rat, i->flag))
     longjmp (i->env, 1);
   return 0;
 }
@@ -675,7 +675,7 @@ LOCtoPVpoly_callback (const BoxType * b, void *cl)
    * because it might not be inside the polygon, or it could
    * be on an edge such that it doesn't actually touch.
    */
-  if (!TEST_FLAG (TheFlag, polygon) && !TEST_FLAG (HOLEFLAG, i->pv) &&
+  if (!TEST_FLAG (i->flag, polygon) && !TEST_FLAG (HOLEFLAG, i->pv) &&
                                        (TEST_THERM (i->layer, i->pv) ||
                                         !TEST_FLAG (CLEARPOLYFLAG,
                                                     polygon)
@@ -689,19 +689,19 @@ LOCtoPVpoly_callback (const BoxType * b, void *cl)
           Coord y1 = i->pv->Y - (i->pv->Thickness + 1 + Bloat) / 2;
           Coord y2 = i->pv->Y + (i->pv->Thickness + 1 + Bloat) / 2;
           if (IsRectangleInPolygon (x1, y1, x2, y2, polygon)
-              && ADD_POLYGON_TO_LIST (i->layer, polygon))
+              && ADD_POLYGON_TO_LIST (i->layer, polygon, i->flag))
             longjmp (i->env, 1);
         }
       else if (TEST_FLAG (OCTAGONFLAG, i->pv))
         {
           POLYAREA *oct = OctagonPoly (i->pv->X, i->pv->Y, i->pv->Thickness / 2);
           if (isects (oct, polygon, true)
-              && ADD_POLYGON_TO_LIST (i->layer, polygon))
+              && ADD_POLYGON_TO_LIST (i->layer, polygon, i->flag))
             longjmp (i->env, 1);
         }
       else if (IsPointInPolygon (i->pv->X, i->pv->Y, wide,
                                  polygon)
-               && ADD_POLYGON_TO_LIST (i->layer, polygon))
+               && ADD_POLYGON_TO_LIST (i->layer, polygon, i->flag))
         longjmp (i->env, 1);
     }
   return 0;
@@ -712,11 +712,13 @@ LOCtoPVpoly_callback (const BoxType * b, void *cl)
  * the appropriate list and the 'used' flag is set
  */
 static bool
-LookupLOConnectionsToPVList (bool AndRats)
+LookupLOConnectionsToPVList (int flag, bool AndRats)
 {
   Cardinal layer_no;
   struct pv_info info;
 
+  info.flag = flag;
+
   /* loop over all PVs currently on list */
   while (PVList.Location < PVList.Number)
     {
@@ -780,7 +782,7 @@ LookupLOConnectionsToPVList (bool AndRats)
  * find all connections between LO at the current list position and new LOs
  */
 static bool
-LookupLOConnectionsToLOList (bool AndRats)
+LookupLOConnectionsToLOList (int flag, bool AndRats)
 {
   bool done;
   Cardinal i, group, layer, ratposition,
@@ -815,11 +817,11 @@ LookupLOConnectionsToLOList (bool AndRats)
             {
               group = RATLIST_ENTRY (*position)->group1;
               if (LookupLOConnectionsToRatEnd
-                  (&(RATLIST_ENTRY (*position)->Point1), group))
+                  (&(RATLIST_ENTRY (*position)->Point1), group, flag))
                 return (true);
               group = RATLIST_ENTRY (*position)->group2;
               if (LookupLOConnectionsToRatEnd
-                  (&(RATLIST_ENTRY (*position)->Point2), group))
+                  (&(RATLIST_ENTRY (*position)->Point2), group, flag))
                 return (true);
             }
         }
@@ -841,21 +843,21 @@ LookupLOConnectionsToLOList (bool AndRats)
                   position = &lineposition[layer];
                   for (; *position < LineList[layer].Number; (*position)++)
                     if (LookupLOConnectionsToLine
-                        (LINELIST_ENTRY (layer, *position), group, true, AndRats))
+                        (LINELIST_ENTRY (layer, *position), group, flag, true, AndRats))
                       return (true);
 
                   /* try all new arcs */
                   position = &arcposition[layer];
                   for (; *position < ArcList[layer].Number; (*position)++)
                     if (LookupLOConnectionsToArc
-                        (ARCLIST_ENTRY (layer, *position), group, AndRats))
+                        (ARCLIST_ENTRY (layer, *position), group, flag, AndRats))
                       return (true);
 
                   /* try all new polygons */
                   position = &polyposition[layer];
                   for (; *position < PolygonList[layer].Number; (*position)++)
                     if (LookupLOConnectionsToPolygon
-                        (POLYGONLIST_ENTRY (layer, *position), group, AndRats))
+                        (POLYGONLIST_ENTRY (layer, *position), group, flag, AndRats))
                       return (true);
                 }
               else
@@ -871,7 +873,7 @@ LookupLOConnectionsToLOList (bool AndRats)
                   position = &padposition[layer];
                   for (; *position < PadList[layer].Number; (*position)++)
                     if (LookupLOConnectionsToPad
-                        (PADLIST_ENTRY (layer, *position), group, AndRats))
+                        (PADLIST_ENTRY (layer, *position), group, flag, AndRats))
                       return (true);
                 }
             }
@@ -899,7 +901,7 @@ pv_pv_callback (const BoxType * b, void *cl)
   PinType *pin = (PinType *) b;
   struct pv_info *i = (struct pv_info *) cl;
 
-  if (!TEST_FLAG (TheFlag, pin) && PV_TOUCH_PV (i->pv, pin))
+  if (!TEST_FLAG (i->flag, pin) && PV_TOUCH_PV (i->pv, pin))
     {
       if (TEST_FLAG (HOLEFLAG, pin) || TEST_FLAG (HOLEFLAG, i->pv))
         {
@@ -910,7 +912,7 @@ pv_pv_callback (const BoxType * b, void *cl)
           else
             Message (_("WARNING: Hole too close to via.\n"));
         }
-      else if (ADD_PV_TO_LIST (pin))
+      else if (ADD_PV_TO_LIST (pin, i->flag))
         longjmp (i->env, 1);
     }
   return 0;
@@ -920,11 +922,12 @@ pv_pv_callback (const BoxType * b, void *cl)
  * searches for new PVs that are connected to PVs on the list
  */
 static bool
-LookupPVConnectionsToPVList (void)
+LookupPVConnectionsToPVList (int flag)
 {
   Cardinal save_place;
   struct pv_info info;
 
+  info.flag = flag;
 
   /* loop over all PVs on list */
   save_place = PVList.Location;
@@ -960,6 +963,7 @@ struct lo_info
   ArcType *arc;
   PolygonType *polygon;
   RatType *rat;
+  int flag;
   jmp_buf env;
 };
 
@@ -969,7 +973,7 @@ pv_line_callback (const BoxType * b, void *cl)
   PinType *pv = (PinType *) b;
   struct lo_info *i = (struct lo_info *) cl;
 
-  if (!TEST_FLAG (TheFlag, pv) && PinLineIntersect (pv, i->line))
+  if (!TEST_FLAG (i->flag, pv) && PinLineIntersect (pv, i->line))
     {
       if (TEST_FLAG (HOLEFLAG, pv))
         {
@@ -977,7 +981,7 @@ pv_line_callback (const BoxType * b, void *cl)
           Settings.RatWarn = true;
           Message (_("WARNING: Hole too close to line.\n"));
         }
-      else if (ADD_PV_TO_LIST (pv))
+      else if (ADD_PV_TO_LIST (pv, i->flag))
         longjmp (i->env, 1);
     }
   return 0;
@@ -989,7 +993,7 @@ pv_pad_callback (const BoxType * b, void *cl)
   PinType *pv = (PinType *) b;
   struct lo_info *i = (struct lo_info *) cl;
 
-  if (!TEST_FLAG (TheFlag, pv) && IS_PV_ON_PAD (pv, i->pad))
+  if (!TEST_FLAG (i->flag, pv) && IS_PV_ON_PAD (pv, i->pad))
     {
       if (TEST_FLAG (HOLEFLAG, pv))
         {
@@ -997,7 +1001,7 @@ pv_pad_callback (const BoxType * b, void *cl)
           Settings.RatWarn = true;
           Message (_("WARNING: Hole too close to pad.\n"));
         }
-      else if (ADD_PV_TO_LIST (pv))
+      else if (ADD_PV_TO_LIST (pv, i->flag))
         longjmp (i->env, 1);
     }
   return 0;
@@ -1009,7 +1013,7 @@ pv_arc_callback (const BoxType * b, void *cl)
   PinType *pv = (PinType *) b;
   struct lo_info *i = (struct lo_info *) cl;
 
-  if (!TEST_FLAG (TheFlag, pv) && IS_PV_ON_ARC (pv, i->arc))
+  if (!TEST_FLAG (i->flag, pv) && IS_PV_ON_ARC (pv, i->arc))
     {
       if (TEST_FLAG (HOLEFLAG, pv))
         {
@@ -1017,7 +1021,7 @@ pv_arc_callback (const BoxType * b, void *cl)
           Settings.RatWarn = true;
           Message (_("WARNING: Hole touches arc.\n"));
         }
-      else if (ADD_PV_TO_LIST (pv))
+      else if (ADD_PV_TO_LIST (pv, i->flag))
         longjmp (i->env, 1);
     }
   return 0;
@@ -1030,7 +1034,7 @@ pv_poly_callback (const BoxType * b, void *cl)
   struct lo_info *i = (struct lo_info *) cl;
 
   /* note that holes in polygons are ok, so they don't generate warnings. */
-  if (!TEST_FLAG (TheFlag, pv) && !TEST_FLAG (HOLEFLAG, pv) &&
+  if (!TEST_FLAG (i->flag, pv) && !TEST_FLAG (HOLEFLAG, pv) &&
                                   (TEST_THERM (i->layer, pv) ||
                                    !TEST_FLAG (CLEARPOLYFLAG, i->polygon) ||
                                    !pv->Clearance))
@@ -1043,20 +1047,20 @@ pv_poly_callback (const BoxType * b, void *cl)
           y1 = pv->Y - (PIN_SIZE (pv) + 1 + Bloat) / 2;
           y2 = pv->Y + (PIN_SIZE (pv) + 1 + Bloat) / 2;
           if (IsRectangleInPolygon (x1, y1, x2, y2, i->polygon)
-              && ADD_PV_TO_LIST (pv))
+              && ADD_PV_TO_LIST (pv, i->flag))
             longjmp (i->env, 1);
         }
       else if (TEST_FLAG (OCTAGONFLAG, pv))
         {
           POLYAREA *oct = OctagonPoly (pv->X, pv->Y, PIN_SIZE (pv) / 2);
-          if (isects (oct, i->polygon, true) && ADD_PV_TO_LIST (pv))
+          if (isects (oct, i->polygon, true) && ADD_PV_TO_LIST (pv, i->flag))
             longjmp (i->env, 1);
         }
       else
         {
           if (IsPointInPolygon
               (pv->X, pv->Y, PIN_SIZE (pv) * 0.5 + Bloat, i->polygon)
-              && ADD_PV_TO_LIST (pv))
+              && ADD_PV_TO_LIST (pv, i->flag))
             longjmp (i->env, 1);
         }
     }
@@ -1070,8 +1074,8 @@ pv_rat_callback (const BoxType * b, void *cl)
   struct lo_info *i = (struct lo_info *) cl;
 
   /* rats can't cause DRC so there is no early exit */
-  if (!TEST_FLAG (TheFlag, pv) && IS_PV_ON_RAT (pv, i->rat))
-    ADD_PV_TO_LIST (pv);
+  if (!TEST_FLAG (i->flag, pv) && IS_PV_ON_RAT (pv, i->rat))
+    ADD_PV_TO_LIST (pv, i->flag);
   return 0;
 }
 
@@ -1080,11 +1084,13 @@ pv_rat_callback (const BoxType * b, void *cl)
  * This routine updates the position counter of the lists too.
  */
 static bool
-LookupPVConnectionsToLOList (bool AndRats)
+LookupPVConnectionsToLOList (int flag, bool AndRats)
 {
   Cardinal layer_no;
   struct lo_info info;
 
+  info.flag = flag;
+
   /* loop over all layers */
   for (layer_no = 0; layer_no < max_copper_layer; layer_no++)
     {
@@ -1664,9 +1670,9 @@ LOCtoArcLine_callback (const BoxType * b, void *cl)
   LineType *line = (LineType *) b;
   struct lo_info *i = (struct lo_info *) cl;
 
-  if (!TEST_FLAG (TheFlag, line) && LineArcIntersect (line, i->arc))
+  if (!TEST_FLAG (i->flag, line) && LineArcIntersect (line, i->arc))
     {
-      if (ADD_LINE_TO_LIST (i->layer, line))
+      if (ADD_LINE_TO_LIST (i->layer, line, i->flag))
         longjmp (i->env, 1);
     }
   return 0;
@@ -1680,9 +1686,9 @@ LOCtoArcArc_callback (const BoxType * b, void *cl)
 
   if (!arc->Thickness)
     return 0;
-  if (!TEST_FLAG (TheFlag, arc) && ArcArcIntersect (i->arc, arc))
+  if (!TEST_FLAG (i->flag, arc) && ArcArcIntersect (i->arc, arc))
     {
-      if (ADD_ARC_TO_LIST (i->layer, arc))
+      if (ADD_ARC_TO_LIST (i->layer, arc, i->flag))
         longjmp (i->env, 1);
     }
   return 0;
@@ -1694,9 +1700,9 @@ LOCtoArcPad_callback (const BoxType * b, void *cl)
   PadType *pad = (PadType *) b;
   struct lo_info *i = (struct lo_info *) cl;
 
-  if (!TEST_FLAG (TheFlag, pad) && i->layer ==
+  if (!TEST_FLAG (i->flag, pad) && i->layer ==
       (TEST_FLAG (ONSOLDERFLAG, pad) ? SOLDER_LAYER : COMPONENT_LAYER)
-      && ArcPadIntersect (i->arc, pad) && ADD_PAD_TO_LIST (i->layer, pad))
+      && ArcPadIntersect (i->arc, pad) && ADD_PAD_TO_LIST (i->layer, pad, i->flag))
     longjmp (i->env, 1);
   return 0;
 }
@@ -1709,12 +1715,13 @@ LOCtoArcPad_callback (const BoxType * b, void *cl)
  * Xij means Xj at arc i
  */
 static bool
-LookupLOConnectionsToArc (ArcType *Arc, Cardinal LayerGroup, bool AndRats)
+LookupLOConnectionsToArc (ArcType *Arc, Cardinal LayerGroup, int flag, bool AndRats)
 {
   Cardinal entry;
   struct lo_info info;
   BoxType search_box;
 
+  info.flag = flag;
   info.arc = Arc;
   search_box = expand_bounds ((BoxType *)info.arc);
 
@@ -1749,8 +1756,8 @@ LookupLOConnectionsToArc (ArcType *Arc, Cardinal LayerGroup, bool AndRats)
           for (i = layer->Polygon; i != NULL; i = g_list_next (i))
             {
               PolygonType *polygon = i->data;
-              if (!TEST_FLAG (TheFlag, polygon) && IsArcInPolygon (Arc, polygon)
-                  && ADD_POLYGON_TO_LIST (layer_no, polygon))
+              if (!TEST_FLAG (flag, polygon) && IsArcInPolygon (Arc, polygon)
+                  && ADD_POLYGON_TO_LIST (layer_no, polygon, flag))
                 return true;
             }
         }
@@ -1773,9 +1780,9 @@ LOCtoLineLine_callback (const BoxType * b, void *cl)
   LineType *line = (LineType *) b;
   struct lo_info *i = (struct lo_info *) cl;
 
-  if (!TEST_FLAG (TheFlag, line) && LineLineIntersect (i->line, line))
+  if (!TEST_FLAG (i->flag, line) && LineLineIntersect (i->line, line))
     {
-      if (ADD_LINE_TO_LIST (i->layer, line))
+      if (ADD_LINE_TO_LIST (i->layer, line, i->flag))
         longjmp (i->env, 1);
     }
   return 0;
@@ -1789,9 +1796,9 @@ LOCtoLineArc_callback (const BoxType * b, void *cl)
 
   if (!arc->Thickness)
     return 0;
-  if (!TEST_FLAG (TheFlag, arc) && LineArcIntersect (i->line, arc))
+  if (!TEST_FLAG (i->flag, arc) && LineArcIntersect (i->line, arc))
     {
-      if (ADD_ARC_TO_LIST (i->layer, arc))
+      if (ADD_ARC_TO_LIST (i->layer, arc, i->flag))
         longjmp (i->env, 1);
     }
   return 0;
@@ -1803,18 +1810,18 @@ LOCtoLineRat_callback (const BoxType * b, void *cl)
   RatType *rat = (RatType *) b;
   struct lo_info *i = (struct lo_info *) cl;
 
-  if (!TEST_FLAG (TheFlag, rat))
+  if (!TEST_FLAG (i->flag, rat))
     {
       if ((rat->group1 == i->layer)
           && IsRatPointOnLineEnd (&rat->Point1, i->line))
         {
-          if (ADD_RAT_TO_LIST (rat))
+          if (ADD_RAT_TO_LIST (rat, i->flag))
             longjmp (i->env, 1);
         }
       else if ((rat->group2 == i->layer)
                && IsRatPointOnLineEnd (&rat->Point2, i->line))
         {
-          if (ADD_RAT_TO_LIST (rat))
+          if (ADD_RAT_TO_LIST (rat, i->flag))
             longjmp (i->env, 1);
         }
     }
@@ -1827,9 +1834,9 @@ LOCtoLinePad_callback (const BoxType * b, void *cl)
   PadType *pad = (PadType *) b;
   struct lo_info *i = (struct lo_info *) cl;
 
-  if (!TEST_FLAG (TheFlag, pad) && i->layer ==
+  if (!TEST_FLAG (i->flag, pad) && i->layer ==
       (TEST_FLAG (ONSOLDERFLAG, pad) ? SOLDER_LAYER : COMPONENT_LAYER)
-      && LinePadIntersect (i->line, pad) && ADD_PAD_TO_LIST (i->layer, pad))
+      && LinePadIntersect (i->line, pad) && ADD_PAD_TO_LIST (i->layer, pad, i->flag))
     longjmp (i->env, 1);
   return 0;
 }
@@ -1843,12 +1850,13 @@ LOCtoLinePad_callback (const BoxType * b, void *cl)
  */
 static bool
 LookupLOConnectionsToLine (LineType *Line, Cardinal LayerGroup,
-                           bool PolysTo, bool AndRats)
+                           int flag, bool PolysTo, bool AndRats)
 {
   Cardinal entry;
   struct lo_info info;
   BoxType search_box;
 
+  info.flag = flag;
   info.layer = LayerGroup;
   info.line = Line;
   search_box = expand_bounds ((BoxType *)info.line);
@@ -1895,9 +1903,8 @@ LookupLOConnectionsToLine (LineType *Line, Cardinal LayerGroup,
               for (i = layer->Polygon; i != NULL; i = g_list_next (i))
                 {
                   PolygonType *polygon = i->data;
-                  if (!TEST_FLAG
-                      (TheFlag, polygon) && IsLineInPolygon (Line, polygon)
-                      && ADD_POLYGON_TO_LIST (layer_no, polygon))
+                  if (!TEST_FLAG (flag, polygon) && IsLineInPolygon (Line, polygon)
+                      && ADD_POLYGON_TO_LIST (layer_no, polygon, flag))
                     return true;
                 }
             }
@@ -1920,6 +1927,7 @@ struct rat_info
 {
   Cardinal layer;
   PointType *Point;
+  int flag;
   jmp_buf env;
 };
 
@@ -1929,12 +1937,12 @@ LOCtoRat_callback (const BoxType * b, void *cl)
   LineType *line = (LineType *) b;
   struct rat_info *i = (struct rat_info *) cl;
 
-  if (!TEST_FLAG (TheFlag, line) &&
+  if (!TEST_FLAG (i->flag, line) &&
       ((line->Point1.X == i->Point->X &&
         line->Point1.Y == i->Point->Y) ||
        (line->Point2.X == i->Point->X && line->Point2.Y == i->Point->Y)))
     {
-      if (ADD_LINE_TO_LIST (i->layer, line))
+      if (ADD_LINE_TO_LIST (i->layer, line, i->flag))
         longjmp (i->env, 1);
     }
   return 0;
@@ -1945,11 +1953,11 @@ PolygonToRat_callback (const BoxType * b, void *cl)
   PolygonType *polygon = (PolygonType *) b;
   struct rat_info *i = (struct rat_info *) cl;
 
-  if (!TEST_FLAG (TheFlag, polygon) && polygon->Clipped &&
+  if (!TEST_FLAG (i->flag, polygon) && polygon->Clipped &&
       (i->Point->X == polygon->Clipped->contours->head.point[0]) &&
       (i->Point->Y == polygon->Clipped->contours->head.point[1]))
     {
-      if (ADD_POLYGON_TO_LIST (i->layer, polygon))
+      if (ADD_POLYGON_TO_LIST (i->layer, polygon, i->flag))
         longjmp (i->env, 1);
     }
   return 0;
@@ -1961,13 +1969,13 @@ LOCtoPad_callback (const BoxType * b, void *cl)
   PadType *pad = (PadType *) b;
   struct rat_info *i = (struct rat_info *) cl;
 
-  if (!TEST_FLAG (TheFlag, pad) && i->layer ==
+  if (!TEST_FLAG (i->flag, pad) && i->layer ==
 	(TEST_FLAG (ONSOLDERFLAG, pad) ? SOLDER_LAYER : COMPONENT_LAYER) &&
       ((pad->Point1.X == i->Point->X && pad->Point1.Y == i->Point->Y) ||
        (pad->Point2.X == i->Point->X && pad->Point2.Y == i->Point->Y) ||
        ((pad->Point1.X + pad->Point2.X) / 2 == i->Point->X &&
         (pad->Point1.Y + pad->Point2.Y) / 2 == i->Point->Y)) &&
-      ADD_PAD_TO_LIST (i->layer, pad))
+      ADD_PAD_TO_LIST (i->layer, pad, i->flag))
     longjmp (i->env, 1);
   return 0;
 }
@@ -1980,11 +1988,12 @@ LOCtoPad_callback (const BoxType * b, void *cl)
  * Xij means Xj at line i
  */
 static bool
-LookupLOConnectionsToRatEnd (PointType *Point, Cardinal LayerGroup)
+LookupLOConnectionsToRatEnd (PointType *Point, Cardinal LayerGroup, int flag)
 {
   Cardinal entry;
   struct rat_info info;
 
+  info.flag = flag;
   info.Point = Point;
   /* loop over all layers of this group */
   for (entry = 0; entry < PCB->LayerGroups.Number[LayerGroup]; entry++)
@@ -2031,9 +2040,9 @@ LOCtoPadLine_callback (const BoxType * b, void *cl)
   LineType *line = (LineType *) b;
   struct lo_info *i = (struct lo_info *) cl;
 
-  if (!TEST_FLAG (TheFlag, line) && LinePadIntersect (line, i->pad))
+  if (!TEST_FLAG (i->flag, line) && LinePadIntersect (line, i->pad))
     {
-      if (ADD_LINE_TO_LIST (i->layer, line))
+      if (ADD_LINE_TO_LIST (i->layer, line, i->flag))
         longjmp (i->env, 1);
     }
   return 0;
@@ -2047,9 +2056,9 @@ LOCtoPadArc_callback (const BoxType * b, void *cl)
 
   if (!arc->Thickness)
     return 0;
-  if (!TEST_FLAG (TheFlag, arc) && ArcPadIntersect (arc, i->pad))
+  if (!TEST_FLAG (i->flag, arc) && ArcPadIntersect (arc, i->pad))
     {
-      if (ADD_ARC_TO_LIST (i->layer, arc))
+      if (ADD_ARC_TO_LIST (i->layer, arc, i->flag))
         longjmp (i->env, 1);
     }
   return 0;
@@ -2062,11 +2071,11 @@ LOCtoPadPoly_callback (const BoxType * b, void *cl)
   struct lo_info *i = (struct lo_info *) cl;
 
 
-  if (!TEST_FLAG (TheFlag, polygon) &&
+  if (!TEST_FLAG (i->flag, polygon) &&
       (!TEST_FLAG (CLEARPOLYFLAG, polygon) || !i->pad->Clearance))
     {
       if (IsPadInPolygon (i->pad, polygon) &&
-          ADD_POLYGON_TO_LIST (i->layer, polygon))
+          ADD_POLYGON_TO_LIST (i->layer, polygon, i->flag))
         longjmp (i->env, 1);
     }
   return 0;
@@ -2078,7 +2087,7 @@ LOCtoPadRat_callback (const BoxType * b, void *cl)
   RatType *rat = (RatType *) b;
   struct lo_info *i = (struct lo_info *) cl;
 
-  if (!TEST_FLAG (TheFlag, rat))
+  if (!TEST_FLAG (i->flag, rat))
     {
       if (rat->group1 == i->layer &&
 	  ((rat->Point1.X == i->pad->Point1.X && rat->Point1.Y == i->pad->Point1.Y) ||
@@ -2086,7 +2095,7 @@ LOCtoPadRat_callback (const BoxType * b, void *cl)
 	   (rat->Point1.X == (i->pad->Point1.X + i->pad->Point2.X) / 2 &&
 	    rat->Point1.Y == (i->pad->Point1.Y + i->pad->Point2.Y) / 2)))
         {
-          if (ADD_RAT_TO_LIST (rat))
+          if (ADD_RAT_TO_LIST (rat, i->flag))
             longjmp (i->env, 1);
         }
       else if (rat->group2 == i->layer &&
@@ -2095,7 +2104,7 @@ LOCtoPadRat_callback (const BoxType * b, void *cl)
 		(rat->Point2.X == (i->pad->Point1.X + i->pad->Point2.X) / 2 &&
 		 rat->Point2.Y == (i->pad->Point1.Y + i->pad->Point2.Y) / 2)))
         {
-          if (ADD_RAT_TO_LIST (rat))
+          if (ADD_RAT_TO_LIST (rat, i->flag))
             longjmp (i->env, 1);
         }
     }
@@ -2108,9 +2117,9 @@ LOCtoPadPad_callback (const BoxType * b, void *cl)
   PadType *pad = (PadType *) b;
   struct lo_info *i = (struct lo_info *) cl;
 
-  if (!TEST_FLAG (TheFlag, pad) && i->layer ==
+  if (!TEST_FLAG (i->flag, pad) && i->layer ==
       (TEST_FLAG (ONSOLDERFLAG, pad) ? SOLDER_LAYER : COMPONENT_LAYER)
-      && PadPadIntersect (pad, i->pad) && ADD_PAD_TO_LIST (i->layer, pad))
+      && PadPadIntersect (pad, i->pad) && ADD_PAD_TO_LIST (i->layer, pad, i->flag))
     longjmp (i->env, 1);
   return 0;
 }
@@ -2120,15 +2129,16 @@ LOCtoPadPad_callback (const BoxType * b, void *cl)
  * layergroup. All found connections are added to the list
  */
 static bool
-LookupLOConnectionsToPad (PadType *Pad, Cardinal LayerGroup, bool AndRats)
+LookupLOConnectionsToPad (PadType *Pad, Cardinal LayerGroup, int flag, bool AndRats)
 {
   Cardinal entry;
   struct lo_info info;
   BoxType search_box;
 
   if (!TEST_FLAG (SQUAREFLAG, Pad))
-    return (LookupLOConnectionsToLine ((LineType *) Pad, LayerGroup, false, AndRats));
+    return (LookupLOConnectionsToLine ((LineType *) Pad, LayerGroup, flag, false, AndRats));
 
+  info.flag = flag;
   info.pad = Pad;
   search_box = expand_bounds ((BoxType *)info.pad);
 
@@ -2196,9 +2206,9 @@ LOCtoPolyLine_callback (const BoxType * b, void *cl)
   LineType *line = (LineType *) b;
   struct lo_info *i = (struct lo_info *) cl;
 
-  if (!TEST_FLAG (TheFlag, line) && IsLineInPolygon (line, i->polygon))
+  if (!TEST_FLAG (i->flag, line) && IsLineInPolygon (line, i->polygon))
     {
-      if (ADD_LINE_TO_LIST (i->layer, line))
+      if (ADD_LINE_TO_LIST (i->layer, line, i->flag))
         longjmp (i->env, 1);
     }
   return 0;
@@ -2212,9 +2222,9 @@ LOCtoPolyArc_callback (const BoxType * b, void *cl)
 
   if (!arc->Thickness)
     return 0;
-  if (!TEST_FLAG (TheFlag, arc) && IsArcInPolygon (arc, i->polygon))
+  if (!TEST_FLAG (i->flag, arc) && IsArcInPolygon (arc, i->polygon))
     {
-      if (ADD_ARC_TO_LIST (i->layer, arc))
+      if (ADD_ARC_TO_LIST (i->layer, arc, i->flag))
         longjmp (i->env, 1);
     }
   return 0;
@@ -2226,11 +2236,11 @@ LOCtoPolyPad_callback (const BoxType * b, void *cl)
   PadType *pad = (PadType *) b;
   struct lo_info *i = (struct lo_info *) cl;
 
-  if (!TEST_FLAG (TheFlag, pad) && i->layer ==
+  if (!TEST_FLAG (i->flag, pad) && i->layer ==
       (TEST_FLAG (ONSOLDERFLAG, pad) ? SOLDER_LAYER : COMPONENT_LAYER)
       && IsPadInPolygon (pad, i->polygon))
     {
-      if (ADD_PAD_TO_LIST (i->layer, pad))
+      if (ADD_PAD_TO_LIST (i->layer, pad, i->flag))
         longjmp (i->env, 1);
     }
   return 0;
@@ -2242,7 +2252,7 @@ LOCtoPolyRat_callback (const BoxType * b, void *cl)
   RatType *rat = (RatType *) b;
   struct lo_info *i = (struct lo_info *) cl;
 
-  if (!TEST_FLAG (TheFlag, rat))
+  if (!TEST_FLAG (i->flag, rat))
     {
       if ((rat->Point1.X == (i->polygon->Clipped->contours->head.point[0]) &&
            rat->Point1.Y == (i->polygon->Clipped->contours->head.point[1]) &&
@@ -2250,7 +2260,7 @@ LOCtoPolyRat_callback (const BoxType * b, void *cl)
           (rat->Point2.X == (i->polygon->Clipped->contours->head.point[0]) &&
            rat->Point2.Y == (i->polygon->Clipped->contours->head.point[1]) &&
            rat->group2 == i->layer))
-        if (ADD_RAT_TO_LIST (rat))
+        if (ADD_RAT_TO_LIST (rat, i->flag))
           longjmp (i->env, 1);
     }
   return 0;
@@ -2262,7 +2272,7 @@ LOCtoPolyRat_callback (const BoxType * b, void *cl)
  * on the given layergroup. All found connections are added to the list
  */
 static bool
-LookupLOConnectionsToPolygon (PolygonType *Polygon, Cardinal LayerGroup, bool AndRats)
+LookupLOConnectionsToPolygon (PolygonType *Polygon, Cardinal LayerGroup, int flag, bool AndRats)
 {
   Cardinal entry;
   struct lo_info info;
@@ -2270,6 +2280,8 @@ LookupLOConnectionsToPolygon (PolygonType *Polygon, Cardinal LayerGroup, bool An
 
   if (!Polygon->Clipped)
     return false;
+
+  info.flag = flag;
   info.polygon = Polygon;
   search_box = expand_bounds ((BoxType *)info.polygon);
 
@@ -2303,9 +2315,9 @@ LookupLOConnectionsToPolygon (PolygonType *Polygon, Cardinal LayerGroup, bool An
           for (i = layer->Polygon; i != NULL; i = g_list_next (i))
             {
               PolygonType *polygon = i->data;
-              if (!TEST_FLAG (TheFlag, polygon)
+              if (!TEST_FLAG (flag, polygon)
                   && IsPolygonInPolygon (polygon, Polygon)
-                  && ADD_POLYGON_TO_LIST (layer_no, polygon))
+                  && ADD_POLYGON_TO_LIST (layer_no, polygon, flag))
                 return true;
             }
 
@@ -2635,7 +2647,7 @@ reassign_no_drc_flags (void)
  * loops till no more connections are found 
  */
 static bool
-DoIt (bool AndRats, bool AndDraw)
+DoIt (int flag, bool AndRats, bool AndDraw)
 {
   bool newone = false;
   reassign_no_drc_flags ();
@@ -2644,10 +2656,10 @@ DoIt (bool AndRats, bool AndDraw)
       /* lookup connections; these are the steps (2) to (4)
        * from the description
        */
-      newone = LookupPVConnectionsToPVList () ||
-               LookupLOConnectionsToPVList (AndRats) ||
-               LookupLOConnectionsToLOList (AndRats) ||
-               LookupPVConnectionsToLOList (AndRats);
+      newone = LookupPVConnectionsToPVList (flag) ||
+               LookupLOConnectionsToPVList (flag, AndRats) ||
+               LookupLOConnectionsToLOList (flag, AndRats) ||
+               LookupPVConnectionsToLOList (flag, AndRats);
       if (AndDraw)
         DrawNewConnections ();
     }
@@ -2661,7 +2673,7 @@ DoIt (bool AndRats, bool AndDraw)
  * prints all unused pins of an element to file FP
  */
 static bool
-PrintAndSelectUnusedPinsAndPadsOfElement (ElementType *Element, FILE * FP)
+PrintAndSelectUnusedPinsAndPadsOfElement (ElementType *Element, FILE * FP, int flag)
 {
   bool first = true;
   Cardinal number;
@@ -2674,12 +2686,12 @@ PrintAndSelectUnusedPinsAndPadsOfElement (ElementType *Element, FILE * FP)
     if (!TEST_FLAG (HOLEFLAG, pin))
       {
         /* pin might have bee checked before, add to list if not */
-        if (!TEST_FLAG (TheFlag, pin) && FP)
+        if (!TEST_FLAG (flag, pin) && FP)
           {
             int i;
-            if (ADD_PV_TO_LIST (pin))
+            if (ADD_PV_TO_LIST (pin, flag))
               return true;
-            DoIt (true, true);
+            DoIt (flag, true, true);
             number = PadList[COMPONENT_LAYER].Number
               + PadList[SOLDER_LAYER].Number + PVList.Number;
             /* the pin has no connection if it's the only
@@ -2717,13 +2729,13 @@ PrintAndSelectUnusedPinsAndPadsOfElement (ElementType *Element, FILE * FP)
   {
     /* lookup pad in list */
     /* pad might has bee checked before, add to list if not */
-    if (!TEST_FLAG (TheFlag, pad) && FP)
+    if (!TEST_FLAG (flag, pad) && FP)
       {
         int i;
         if (ADD_PAD_TO_LIST (TEST_FLAG (ONSOLDERFLAG, pad)
-                             ? SOLDER_LAYER : COMPONENT_LAYER, pad))
+                             ? SOLDER_LAYER : COMPONENT_LAYER, pad, flag))
           return true;
-        DoIt (true, true);
+        DoIt (flag, true, true);
         number = PadList[COMPONENT_LAYER].Number
           + PadList[SOLDER_LAYER].Number + PVList.Number;
         /* the pin has no connection if it's the only
@@ -2797,7 +2809,7 @@ PrepareNextLoop (FILE * FP)
  * Returns true if operation was aborted
  */
 static bool
-PrintElementConnections (ElementType *Element, FILE * FP, bool AndDraw)
+PrintElementConnections (ElementType *Element, FILE * FP, int flag, bool AndDraw)
 {
   PrintConnectionElementName (Element, FP);
 
@@ -2805,15 +2817,15 @@ PrintElementConnections (ElementType *Element, FILE * FP, bool AndDraw)
   PIN_LOOP (Element);
   {
     /* pin might have been checked before, add to list if not */
-    if (TEST_FLAG (TheFlag, pin))
+    if (TEST_FLAG (flag, pin))
       {
         PrintConnectionListEntry ((char *)EMPTY (pin->Name), NULL, true, FP);
         fputs ("\t\t__CHECKED_BEFORE__\n\t}\n", FP);
         continue;
       }
-    if (ADD_PV_TO_LIST (pin))
+    if (ADD_PV_TO_LIST (pin, flag))
       return true;
-    DoIt (true, AndDraw);
+    DoIt (flag, true, AndDraw);
     /* printout all found connections */
     PrintPinConnections (FP, true);
     PrintPadConnections (COMPONENT_LAYER, FP, false);
@@ -2829,16 +2841,16 @@ PrintElementConnections (ElementType *Element, FILE * FP, bool AndDraw)
   {
     Cardinal layer;
     /* pad might have been checked before, add to list if not */
-    if (TEST_FLAG (TheFlag, pad))
+    if (TEST_FLAG (flag, pad))
       {
         PrintConnectionListEntry ((char *)EMPTY (pad->Name), NULL, true, FP);
         fputs ("\t\t__CHECKED_BEFORE__\n\t}\n", FP);
         continue;
       }
     layer = TEST_FLAG (ONSOLDERFLAG, pad) ? SOLDER_LAYER : COMPONENT_LAYER;
-    if (ADD_PAD_TO_LIST (layer, pad))
+    if (ADD_PAD_TO_LIST (layer, pad, flag))
       return true;
-    DoIt (true, AndDraw);
+    DoIt (flag, true, AndDraw);
     /* print all found connections */
     PrintPadConnections (layer, FP, true);
     PrintPadConnections (layer ==
@@ -2936,10 +2948,9 @@ LookupElementConnections (ElementType *Element, FILE * FP)
 {
   /* reset all currently marked connections */
   User = true;
-  TheFlag = FOUNDFLAG;
   ClearFlagOnAllObjects (true, FOUNDFLAG);
   InitConnectionLookup ();
-  PrintElementConnections (Element, FP, true);
+  PrintElementConnections (Element, FP, FOUNDFLAG, true);
   SetChangedFlag (true);
   if (Settings.RingBellWhenFinished)
     gui->beep ();
@@ -2957,14 +2968,13 @@ LookupConnectionsToAllElements (FILE * FP)
 {
   /* reset all currently marked connections */
   User = false;
-  TheFlag = FOUNDFLAG;
   ClearFlagOnAllObjects (false, FOUNDFLAG);
   InitConnectionLookup ();
 
   ELEMENT_LOOP (PCB->Data);
   {
     /* break if abort dialog returned true */
-    if (PrintElementConnections (element, FP, false))
+    if (PrintElementConnections (element, FP, FOUNDFLAG, false))
       break;
     SEPARATE (FP);
     if (Settings.ResetAfterElement && n != 1)
@@ -2982,7 +2992,7 @@ LookupConnectionsToAllElements (FILE * FP)
  * add the starting object to the list of found objects
  */
 static bool
-ListStart (int type, void *ptr1, void *ptr2, void *ptr3)
+ListStart (int type, void *ptr1, void *ptr2, void *ptr3, int flag)
 {
   DumpList ();
   switch (type)
@@ -2990,14 +3000,14 @@ ListStart (int type, void *ptr1, void *ptr2, void *ptr3)
     case PIN_TYPE:
     case VIA_TYPE:
       {
-        if (ADD_PV_TO_LIST ((PinType *) ptr2))
+        if (ADD_PV_TO_LIST ((PinType *) ptr2, flag))
           return true;
         break;
       }
 
     case RATLINE_TYPE:
       {
-        if (ADD_RAT_TO_LIST ((RatType *) ptr1))
+        if (ADD_RAT_TO_LIST ((RatType *) ptr1, flag))
           return true;
         break;
       }
@@ -3007,7 +3017,7 @@ ListStart (int type, void *ptr1, void *ptr2, void *ptr3)
         int layer = GetLayerNumber (PCB->Data,
                                     (LayerType *) ptr1);
 
-        if (ADD_LINE_TO_LIST (layer, (LineType *) ptr2))
+        if (ADD_LINE_TO_LIST (layer, (LineType *) ptr2, flag))
           return true;
         break;
       }
@@ -3017,7 +3027,7 @@ ListStart (int type, void *ptr1, void *ptr2, void *ptr3)
         int layer = GetLayerNumber (PCB->Data,
                                     (LayerType *) ptr1);
 
-        if (ADD_ARC_TO_LIST (layer, (ArcType *) ptr2))
+        if (ADD_ARC_TO_LIST (layer, (ArcType *) ptr2, flag))
           return true;
         break;
       }
@@ -3027,7 +3037,7 @@ ListStart (int type, void *ptr1, void *ptr2, void *ptr3)
         int layer = GetLayerNumber (PCB->Data,
                                     (LayerType *) ptr1);
 
-        if (ADD_POLYGON_TO_LIST (layer, (PolygonType *) ptr2))
+        if (ADD_POLYGON_TO_LIST (layer, (PolygonType *) ptr2, flag))
           return true;
         break;
       }
@@ -3037,7 +3047,7 @@ ListStart (int type, void *ptr1, void *ptr2, void *ptr3)
         PadType *pad = (PadType *) ptr2;
         if (ADD_PAD_TO_LIST
             (TEST_FLAG
-             (ONSOLDERFLAG, pad) ? SOLDER_LAYER : COMPONENT_LAYER, pad))
+             (ONSOLDERFLAG, pad) ? SOLDER_LAYER : COMPONENT_LAYER, pad, flag))
           return true;
         break;
       }
@@ -3053,7 +3063,7 @@ ListStart (int type, void *ptr1, void *ptr2, void *ptr3)
  * also the action is marked as undoable if AndDraw is true
  */
 void
-LookupConnection (Coord X, Coord Y, bool AndDraw, Coord Range, int which_flag,
+LookupConnection (Coord X, Coord Y, bool AndDraw, Coord Range, int flag,
                   bool AndRats)
 {
   void *ptr1, *ptr2, *ptr3;
@@ -3087,15 +3097,14 @@ LookupConnection (Coord X, Coord Y, bool AndDraw, Coord Range, int which_flag,
   name = ConnectionName (type, ptr1, ptr2);
   hid_actionl ("NetlistShow", name, NULL);
 
-  TheFlag = which_flag;
   User = AndDraw;
   InitConnectionLookup ();
 
   /* now add the object to the appropriate list and start scanning
    * This is step (1) from the description
    */
-  ListStart (type, ptr1, ptr2, ptr3);
-  DoIt (AndRats, AndDraw);
+  ListStart (type, ptr1, ptr2, ptr3, flag);
+  DoIt (flag, AndRats, AndDraw);
   if (User)
     IncrementUndoSerialNumber ();
   User = false;
@@ -3117,10 +3126,9 @@ RatFindHook (int type, void *ptr1, void *ptr2, void *ptr3,
              bool undo, int flag, bool AndRats)
 {
   User = undo;
-  TheFlag = flag;
   DumpList ();
-  ListStart (type, ptr1, ptr2, ptr3);
-  DoIt (AndRats, false);
+  ListStart (type, ptr1, ptr2, ptr3, flag);
+  DoIt (flag, AndRats, false);
   User = false;
 }
 
@@ -3132,7 +3140,6 @@ LookupUnusedPins (FILE * FP)
 {
   /* reset all currently marked connections */
   User = true;
-  TheFlag = FOUNDFLAG;
   ClearFlagOnAllObjects (true, FOUNDFLAG);
   InitConnectionLookup ();
 
@@ -3141,7 +3148,7 @@ LookupUnusedPins (FILE * FP)
     /* break if abort dialog returned true;
      * passing NULL as filedescriptor discards the normal output
      */
-    if (PrintAndSelectUnusedPinsAndPadsOfElement (element, FP))
+    if (PrintAndSelectUnusedPinsAndPadsOfElement (element, FP, FOUNDFLAG))
       break;
   }
   END_LOOP;
@@ -3324,6 +3331,11 @@ DumpList (void)
   RatList.DrawLocation = 0;
 }
 
+struct drc_info
+{
+  int flag;
+};
+
 /*-----------------------------------------------------------------------------
  * Check for DRC violations on a single net starting from the pad or pin
  * sees if the connectivity changes when everything is bloated, or shrunk
@@ -3336,37 +3348,38 @@ DRCFind (int What, void *ptr1, void *ptr2, void *ptr3)
   long int *object_id_list;
   int *object_type_list;
   DrcViolationType *violation;
+  int flag;
 
   if (PCB->Shrink != 0)
     {
       Bloat = -PCB->Shrink;
-      TheFlag = DRCFLAG | SELECTEDFLAG;
-      ListStart (What, ptr1, ptr2, ptr3);
-      DoIt (true, false);
+      flag = DRCFLAG | SELECTEDFLAG;
+      ListStart (What, ptr1, ptr2, ptr3, flag);
+      DoIt (flag, true, false);
       /* ok now the shrunk net has the SELECTEDFLAG set */
       DumpList ();
-      TheFlag = FOUNDFLAG;
-      ListStart (What, ptr1, ptr2, ptr3);
+      flag = FOUNDFLAG;
+      ListStart (What, ptr1, ptr2, ptr3, flag);
       Bloat = 0;
       drc = true;               /* abort the search if we find anything not already found */
-      if (DoIt (true, false))
+      if (DoIt (flag, true, false))
         {
           DumpList ();
           /* make the flag changes undoable */
-          TheFlag = FOUNDFLAG | SELECTEDFLAG;
-          ClearFlagOnAllObjects (false, TheFlag);
+          flag = FOUNDFLAG | SELECTEDFLAG;
+          ClearFlagOnAllObjects (false, flag);
           User = true;
           drc = false;
           Bloat = -PCB->Shrink;
-          TheFlag = SELECTEDFLAG;
-          ListStart (What, ptr1, ptr2, ptr3);
-          DoIt (true, true);
+          flag = SELECTEDFLAG;
+          ListStart (What, ptr1, ptr2, ptr3, flag);
+          DoIt (flag, true, true);
           DumpList ();
-          ListStart (What, ptr1, ptr2, ptr3);
-          TheFlag = FOUNDFLAG;
+          ListStart (What, ptr1, ptr2, ptr3, flag);
+          flag = FOUNDFLAG;
           Bloat = 0;
           drc = true;
-          DoIt (true, true);
+          DoIt (flag, true, true);
           DumpList ();
           User = false;
           drc = false;
@@ -3398,29 +3411,29 @@ DRCFind (int What, void *ptr1, void *ptr2, void *ptr3)
     }
   /* now check the bloated condition */
   drc = false;
-  ClearFlagOnAllObjects (false, TheFlag);
-  TheFlag = FOUNDFLAG;
-  ListStart (What, ptr1, ptr2, ptr3);
+  ClearFlagOnAllObjects (false, flag);
+  flag = FOUNDFLAG;
+  ListStart (What, ptr1, ptr2, ptr3, flag);
   Bloat = PCB->Bloat;
   drc = true;
-  while (DoIt (true, false))
+  while (DoIt (flag, true, false))
     {
       DumpList ();
       /* make the flag changes undoable */
-      TheFlag = FOUNDFLAG | SELECTEDFLAG;
-      ClearFlagOnAllObjects (false, TheFlag);
+      flag = FOUNDFLAG | SELECTEDFLAG;
+      ClearFlagOnAllObjects (false, flag);
       User = true;
       drc = false;
       Bloat = 0;
-      TheFlag = SELECTEDFLAG;
-      ListStart (What, ptr1, ptr2, ptr3);
-      DoIt (true, true);
+      flag = SELECTEDFLAG;
+      ListStart (What, ptr1, ptr2, ptr3, flag);
+      DoIt (flag, true, true);
       DumpList ();
-      TheFlag = FOUNDFLAG;
-      ListStart (What, ptr1, ptr2, ptr3);
+      flag = FOUNDFLAG;
+      ListStart (What, ptr1, ptr2, ptr3, flag);
       Bloat = PCB->Bloat;
       drc = true;
-      DoIt (true, true);
+      DoIt (flag, true, true);
       DumpList ();
       drcerr_count++;
       LocateError (&x, &y);
@@ -3447,19 +3460,19 @@ DRCFind (int What, void *ptr1, void *ptr2, void *ptr3)
       IncrementUndoSerialNumber ();
       Undo (true);
       /* highlight the rest of the encroaching net so it's not reported again */
-      TheFlag |= SELECTEDFLAG;
+      flag |= SELECTEDFLAG;
       Bloat = 0;
-      ListStart (thing_type, thing_ptr1, thing_ptr2, thing_ptr3);
-      DoIt (true, true);
+      ListStart (thing_type, thing_ptr1, thing_ptr2, thing_ptr3, flag);
+      DoIt (flag, true, true);
       DumpList ();
       drc = true;
       Bloat = PCB->Bloat;
-      ListStart (What, ptr1, ptr2, ptr3);
+      ListStart (What, ptr1, ptr2, ptr3, flag);
     }
   drc = false;
   DumpList ();
-  TheFlag = FOUNDFLAG | SELECTEDFLAG;
-  ClearFlagOnAllObjects (false, TheFlag);
+  flag = FOUNDFLAG | SELECTEDFLAG;
+  ClearFlagOnAllObjects (false, flag);
   return (false);
 }
 
@@ -3469,6 +3482,7 @@ static int
 drc_callback (DataType *data, LayerType *layer, PolygonType *polygon,
               int type, void *ptr1, void *ptr2, void *userdata)
 {
+  struct drc_info *i = (struct drc_info *) userdata;
   char *message;
   Coord x, y;
   int object_count;
@@ -3491,7 +3505,7 @@ drc_callback (DataType *data, LayerType *layer, PolygonType *polygon,
       if (line->Clearance < 2 * PCB->Bloat)
         {
           AddObjectToFlagUndoList (type, ptr1, ptr2, ptr2);
-          SET_FLAG (TheFlag, line);
+          SET_FLAG (i->flag, line);
           message = _("Line with insufficient clearance inside polygon\n");
           goto doIsBad;
         }
@@ -3500,7 +3514,7 @@ drc_callback (DataType *data, LayerType *layer, PolygonType *polygon,
       if (arc->Clearance < 2 * PCB->Bloat)
         {
           AddObjectToFlagUndoList (type, ptr1, ptr2, ptr2);
-          SET_FLAG (TheFlag, arc);
+          SET_FLAG (i->flag, arc);
           message = _("Arc with insufficient clearance inside polygon\n");
           goto doIsBad;
         }
@@ -3510,7 +3524,7 @@ drc_callback (DataType *data, LayerType *layer, PolygonType *polygon,
 	if (IsPadInPolygon(pad,polygon))
 	  {
 	    AddObjectToFlagUndoList (type, ptr1, ptr2, ptr2);
-	    SET_FLAG (TheFlag, pad);
+	    SET_FLAG (i->flag, pad);
 	    message = _("Pad with insufficient clearance inside polygon\n");
 	    goto doIsBad;
 	  }
@@ -3519,7 +3533,7 @@ drc_callback (DataType *data, LayerType *layer, PolygonType *polygon,
       if (pin->Clearance && pin->Clearance < 2 * PCB->Bloat)
         {
           AddObjectToFlagUndoList (type, ptr1, ptr2, ptr2);
-          SET_FLAG (TheFlag, pin);
+          SET_FLAG (i->flag, pin);
           message = _("Pin with insufficient clearance inside polygon\n");
           goto doIsBad;
         }
@@ -3528,7 +3542,7 @@ drc_callback (DataType *data, LayerType *layer, PolygonType *polygon,
       if (pin->Clearance && pin->Clearance < 2 * PCB->Bloat)
         {
           AddObjectToFlagUndoList (type, ptr1, ptr2, ptr2);
-          SET_FLAG (TheFlag, pin);
+          SET_FLAG (i->flag, pin);
           message = _("Via with insufficient clearance inside polygon\n");
           goto doIsBad;
         }
@@ -3585,6 +3599,8 @@ DRCAll (void)
   int tmpcnt;
   int nopastecnt = 0;
   bool IsBad;
+  int flag;
+  struct drc_info info;
 
   reset_drc_dialog_message();
 
@@ -3595,9 +3611,9 @@ DRCAll (void)
   hid_action ("LayersChanged");
   InitConnectionLookup ();
 
-  TheFlag = FOUNDFLAG | DRCFLAG | SELECTEDFLAG;
+  flag = FOUNDFLAG | DRCFLAG | SELECTEDFLAG;
 
-  if (ClearFlagOnAllObjects (true, TheFlag))
+  if (ClearFlagOnAllObjects (true, flag))
     {
       IncrementUndoSerialNumber ();
       Draw ();
@@ -3650,16 +3666,17 @@ DRCAll (void)
   }
   END_LOOP;
 
-  TheFlag = (IsBad) ? DRCFLAG : (FOUNDFLAG | DRCFLAG | SELECTEDFLAG);
-  ClearFlagOnAllObjects (false, TheFlag);
-  TheFlag = SELECTEDFLAG;
+  flag = (IsBad) ? DRCFLAG : (FOUNDFLAG | DRCFLAG | SELECTEDFLAG);
+  ClearFlagOnAllObjects (false, flag);
+  flag = SELECTEDFLAG;
+  info.flag = flag;
   /* check minimum widths and polygon clearances */
   if (!IsBad)
     {
       COPPERLINE_LOOP (PCB->Data);
       {
         /* check line clearances in polygons */
-        if (PlowsPolygon (PCB->Data, LINE_TYPE, layer, line, drc_callback, NULL))
+        if (PlowsPolygon (PCB->Data, LINE_TYPE, layer, line, drc_callback, &info))
           {
             IsBad = true;
             break;
@@ -3667,7 +3684,7 @@ DRCAll (void)
         if (line->Thickness < PCB->minWid)
           {
             AddObjectToFlagUndoList (LINE_TYPE, layer, line, line);
-            SET_FLAG (TheFlag, line);
+            SET_FLAG (flag, line);
             DrawLine (layer, line);
             drcerr_count++;
             SetThing (LINE_TYPE, layer, line, line);
@@ -3703,7 +3720,7 @@ DRCAll (void)
     {
       COPPERARC_LOOP (PCB->Data);
       {
-        if (PlowsPolygon (PCB->Data, ARC_TYPE, layer, arc, drc_callback, NULL))
+        if (PlowsPolygon (PCB->Data, ARC_TYPE, layer, arc, drc_callback, &info))
           {
             IsBad = true;
             break;
@@ -3711,7 +3728,7 @@ DRCAll (void)
         if (arc->Thickness < PCB->minWid)
           {
             AddObjectToFlagUndoList (ARC_TYPE, layer, arc, arc);
-            SET_FLAG (TheFlag, arc);
+            SET_FLAG (flag, arc);
             DrawArc (layer, arc);
             drcerr_count++;
             SetThing (ARC_TYPE, layer, arc, arc);
@@ -3747,7 +3764,7 @@ DRCAll (void)
     {
       ALLPIN_LOOP (PCB->Data);
       {
-        if (PlowsPolygon (PCB->Data, PIN_TYPE, element, pin, drc_callback, NULL))
+        if (PlowsPolygon (PCB->Data, PIN_TYPE, element, pin, drc_callback, &info))
           {
             IsBad = true;
             break;
@@ -3756,7 +3773,7 @@ DRCAll (void)
             pin->Thickness - pin->DrillingHole < 2 * PCB->minRing)
           {
             AddObjectToFlagUndoList (PIN_TYPE, element, pin, pin);
-            SET_FLAG (TheFlag, pin);
+            SET_FLAG (flag, pin);
             DrawPin (pin);
             drcerr_count++;
             SetThing (PIN_TYPE, element, pin, pin);
@@ -3788,7 +3805,7 @@ DRCAll (void)
         if (pin->DrillingHole < PCB->minDrill)
           {
             AddObjectToFlagUndoList (PIN_TYPE, element, pin, pin);
-            SET_FLAG (TheFlag, pin);
+            SET_FLAG (flag, pin);
             DrawPin (pin);
             drcerr_count++;
             SetThing (PIN_TYPE, element, pin, pin);
@@ -3823,7 +3840,7 @@ DRCAll (void)
     {
       ALLPAD_LOOP (PCB->Data);
       {
-        if (PlowsPolygon (PCB->Data, PAD_TYPE, element, pad, drc_callback, NULL))
+        if (PlowsPolygon (PCB->Data, PAD_TYPE, element, pad, drc_callback, &info))
           {
             IsBad = true;
             break;
@@ -3831,7 +3848,7 @@ DRCAll (void)
         if (pad->Thickness < PCB->minWid)
           {
             AddObjectToFlagUndoList (PAD_TYPE, element, pad, pad);
-            SET_FLAG (TheFlag, pad);
+            SET_FLAG (flag, pad);
             DrawPad (pad);
             drcerr_count++;
             SetThing (PAD_TYPE, element, pad, pad);
@@ -3867,7 +3884,7 @@ DRCAll (void)
     {
       VIA_LOOP (PCB->Data);
       {
-        if (PlowsPolygon (PCB->Data, VIA_TYPE, via, via, drc_callback, NULL))
+        if (PlowsPolygon (PCB->Data, VIA_TYPE, via, via, drc_callback, &info))
           {
             IsBad = true;
             break;
@@ -3876,7 +3893,7 @@ DRCAll (void)
             via->Thickness - via->DrillingHole < 2 * PCB->minRing)
           {
             AddObjectToFlagUndoList (VIA_TYPE, via, via, via);
-            SET_FLAG (TheFlag, via);
+            SET_FLAG (flag, via);
             DrawVia (via);
             drcerr_count++;
             SetThing (VIA_TYPE, via, via, via);
@@ -3908,7 +3925,7 @@ DRCAll (void)
         if (via->DrillingHole < PCB->minDrill)
           {
             AddObjectToFlagUndoList (VIA_TYPE, via, via, via);
-            SET_FLAG (TheFlag, via);
+            SET_FLAG (flag, via);
             DrawVia (via);
             drcerr_count++;
             SetThing (VIA_TYPE, via, via, via);
@@ -3941,19 +3958,19 @@ DRCAll (void)
     }
 
   FreeConnectionLookupMemory ();
-  TheFlag = FOUNDFLAG;
+  flag = FOUNDFLAG;
   Bloat = 0;
 
   /* check silkscreen minimum widths outside of elements */
   /* XXX - need to check text and polygons too! */
-  TheFlag = SELECTEDFLAG;
+  flag = SELECTEDFLAG;
   if (!IsBad)
     {
       SILKLINE_LOOP (PCB->Data);
       {
         if (line->Thickness < PCB->minSlk)
           {
-            SET_FLAG (TheFlag, line);
+            SET_FLAG (flag, line);
             DrawLine (layer, line);
             drcerr_count++;
             SetThing (LINE_TYPE, layer, line, line);
@@ -3986,7 +4003,7 @@ DRCAll (void)
 
   /* check silkscreen minimum widths inside of elements */
   /* XXX - need to check text and polygons too! */
-  TheFlag = SELECTEDFLAG;
+  flag = SELECTEDFLAG;
   if (!IsBad)
     {
       ELEMENT_LOOP (PCB->Data);
@@ -4005,7 +4022,7 @@ DRCAll (void)
             char *buffer;
             int buflen;
 
-            SET_FLAG (TheFlag, element);
+            SET_FLAG (flag, element);
             DrawElement (element);
             drcerr_count++;
             SetThing (ELEMENT_TYPE, element, element, element);

Bottom: 28f3a0fe7f84747dff3ec269302a64aa45ae9542
Top:    eeb1c29afd422cdcafd2a9d6753b03916c8a59d6
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-12-26 23:29:46 +0000

hid/gtk: Refactor storage semantics of view_x, view_y coordinates

They now directly represent actual cursor coordinates, and don't require
passing through SIDE_{X,Y} before use.

To avoid confusion, view_x and view_y have been renamed to pcb_x and pcb_y
to reflect the change of semantics.


---

diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 6a8d904..915656a 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -241,28 +241,30 @@ zoom_to (double new_zoom, int x, int y)
       gdouble xtmp, ytmp;
       gint x0, y0;
 
-      xtmp = (gport->view_x - gport->view_x0) / (gdouble) gport->view_width;
-      ytmp = (gport->view_y - gport->view_y0) / (gdouble) gport->view_height;
-      
+      xtmp = (SIDE_X (gport->view_x) - gport->view_x0) /
+                (gdouble) gport->view_width;
+      ytmp = (SIDE_Y (gport->view_y) - gport->view_y0) /
+                (gdouble) gport->view_height;
+
       gport->zoom = new_zoom;
       pixel_slop = new_zoom;
       ghid_port_ranges_scale(FALSE);
 
-      x0 = gport->view_x - xtmp * gport->view_width;
+      x0 = SIDE_X (gport->view_x) - xtmp * gport->view_width;
       if (x0 < 0)
-	x0 = 0;
+        x0 = 0;
       gport->view_x0 = x0;
 
-      y0 = gport->view_y - ytmp * gport->view_height;
+      y0 = SIDE_Y (gport->view_y) - ytmp * gport->view_height;
       if (y0 < 0)
-	y0 = 0;
+        y0 = 0;
       gport->view_y0 = y0;
-      
+
       ghidgui->adjustment_changed_holdoff = TRUE;
       gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view_x0);
       gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view_y0);
       ghidgui->adjustment_changed_holdoff = FALSE;
-      
+
       ghid_port_ranges_changed();
     }
 
@@ -1516,12 +1518,12 @@ SwapSides (int argc, char **argv, int x, int y)
      location */
   if (do_flip_x)
     {
-	flipd = PCB->MaxWidth / 2 - gport->view_x;
+	flipd = PCB->MaxWidth / 2 - SIDE_X (gport->view_x);
 	ghid_port_ranges_pan (2 * flipd, 0, TRUE);
     }
   if (do_flip_y)
     {
-	flipd = PCB->MaxHeight / 2 - gport->view_y;
+	flipd = PCB->MaxHeight / 2 - SIDE_Y (gport->view_y);
 	ghid_port_ranges_pan (0, 2 * flipd, TRUE);
     }
 
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index 1f9a31a..694a712 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -166,19 +166,21 @@ ghid_port_ranges_zoom (gdouble zoom)
   if ((zoom > xtmp && zoom > ytmp) || zoom == 0.0)
     zoom = (xtmp > ytmp) ? xtmp : ytmp;
 
-  xtmp = (gport->view_x - gport->view_x0) / (gdouble) gport->view_width;
-  ytmp = (gport->view_y - gport->view_y0) / (gdouble) gport->view_height;
+  xtmp = (SIDE_X (gport->view_x) - gport->view_x0) /
+            (gdouble) gport->view_width;
+  ytmp = (SIDE_Y (gport->view_y) - gport->view_y0) /
+            (gdouble) gport->view_height;
 
   gport->zoom = zoom;
   pixel_slop = zoom;
   ghid_port_ranges_scale(FALSE);
 
-  x0 = gport->view_x - xtmp * gport->view_width;
+  x0 = SIDE_X (gport->view_x) - xtmp * gport->view_width;
   if (x0 < 0)
     x0 = 0;
   gport->view_x0 = x0;
 
-  y0 = gport->view_y - ytmp * gport->view_height;
+  y0 = SIDE_Y (gport->view_y) - ytmp * gport->view_height;
   if (y0 < 0)
     y0 = 0;
   gport->view_y0 = y0;
@@ -203,8 +205,8 @@ ghid_get_coords (const char *msg, int *x, int *y)
     ghid_get_user_xy (msg);
   if (ghid_port.has_entered)
     {
-      *x = SIDE_X (gport->view_x);
-      *y = SIDE_Y (gport->view_y);
+      *x = gport->view_x;
+      *y = gport->view_y;
     }
 }
 
@@ -224,11 +226,10 @@ ghid_note_event_location (GdkEventButton * ev)
       event_x = ev->x;
       event_y = ev->y;
     }
-  gport->view_x = event_x * gport->zoom + gport->view_x0;
-  gport->view_y = event_y * gport->zoom + gport->view_y0;
+  gport->view_x = VIEW_X (event_x);
+  gport->view_y = VIEW_Y (event_y);
 
-  moved = MoveCrosshairAbsolute (SIDE_X (gport->view_x), 
-				 SIDE_Y (gport->view_y));
+  moved = MoveCrosshairAbsolute (gport->view_x, gport->view_y);
   if (moved)
     {
       AdjustAttachedObjects ();

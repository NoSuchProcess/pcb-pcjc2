Bottom: d080e0fdeac708f61640e985a278e64034e0ea77
Top:    35fe52cdd9a2e667196edf15d34caf9c6cd652ef
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-11-11 16:38:34 +0000

Work in progress

---

diff --git a/src/cairo/cairo-bentley-ottmann.c b/src/cairo/cairo-bentley-ottmann.c
index 03795fb..b7156b9 100644
--- a/src/cairo/cairo-bentley-ottmann.c
+++ b/src/cairo/cairo-bentley-ottmann.c
@@ -53,7 +53,7 @@
 #define _cairo_error(x) (x)
 
 #define DEBUG_PRINT_STATE 0
-#define DEBUG_EVENTS 1
+#define DEBUG_EVENTS 0
 #define DEBUG_TRAPS 0
 
 typedef cairo_point_t cairo_bo_point32_t;
@@ -86,11 +86,19 @@ struct _cairo_bo_edge {
 /* left and right children are index * 2 and (index * 2) +1 respectively */
 #define PQ_LEFT_CHILD_INDEX(i) ((i) << 1)
 
+#if 0
 typedef enum {
     CAIRO_BO_EVENT_TYPE_STOP,
     CAIRO_BO_EVENT_TYPE_INTERSECTION,
     CAIRO_BO_EVENT_TYPE_START
 } cairo_bo_event_type_t;
+#endif
+
+typedef enum {
+    CAIRO_BO_EVENT_TYPE_START,
+    CAIRO_BO_EVENT_TYPE_INTERSECTION,
+    CAIRO_BO_EVENT_TYPE_STOP
+} cairo_bo_event_type_t;
 
 typedef struct _cairo_bo_event {
     cairo_bo_event_type_t type;
@@ -205,6 +213,12 @@ _line_compute_intersection_x_for_y (const cairo_line_t *line,
 {
     cairo_fixed_t x, dy;
 
+#if 0
+    if (y == line->p1.y &&
+        y == line->p2.y)
+      printf ("Horizontal line, so what x coord do we report?\n");
+#endif
+
     if (y == line->p1.y)
         return line->p1.x;
     if (y == line->p2.y)
@@ -526,16 +540,22 @@ edges_compare_x_for_y (const cairo_bo_edge_t *a,
     } have_ax_bx = HAVE_BOTH;
     int32_t ax, bx;
 
+//    if (y == a->edge.line.p2.y)
+//        ax = a->edge.line.p2.x;
+//    else if (y == a->edge.line.p1.y)
     if (y == a->edge.line.p1.y)
         ax = a->edge.line.p1.x;
-    else if (y == a->edge.line.p2.y)
+    else if (y == a->edge.line.p2.y) /* WE MISS THE STOP EVENT FOR A HORIZONTAL LINE? */
         ax = a->edge.line.p2.x;
     else
         have_ax_bx &= ~HAVE_AX;
 
+//    if (y == b->edge.line.p2.y) /* WE MISS THE STOP EVENT FOR A HORIZONTAL LINE? */
+//        bx = b->edge.line.p2.x;
+//    else if (y == b->edge.line.p1.y)
     if (y == b->edge.line.p1.y)
         bx = b->edge.line.p1.x;
-    else if (y == b->edge.line.p2.y)
+    else if (y == b->edge.line.p2.y) /* WE MISS THE STOP EVENT FOR A HORIZONTAL LINE? */
         bx = b->edge.line.p2.x;
     else
         have_ax_bx &= ~HAVE_BX;
@@ -561,9 +581,9 @@ _line_equal (const cairo_line_t *a, const cairo_line_t *b)
 }
 
 static int
-_cairo_bo_sweep_line_compare_edges (cairo_bo_sweep_line_t        *sweep_line,
-                                    const cairo_bo_edge_t        *a,
-                                    const cairo_bo_edge_t        *b)
+_cairo_bo_sweep_line_compare_edges (cairo_bo_sweep_line_t *sweep_line,
+                                    const cairo_bo_edge_t *a,
+                                    const cairo_bo_edge_t *b)
 {
     int cmp;
 
@@ -578,13 +598,19 @@ _cairo_bo_sweep_line_compare_edges (cairo_bo_sweep_line_t        *sweep_line,
          * called only when starting a new edge, (not when stopping an
          * edge), so we don't have to worry about conditionally inverting
          * the sense of _slope_compare. */
-        cmp = _slope_compare (a, b);
-        if (cmp)
-            return cmp;
+        //cmp = _slope_compare (a, b);
+        //if (cmp)
+        //    return cmp;
+        return 1;
     }
 
     /* We've got two collinear edges now. */
-    return b->edge.bottom - a->edge.bottom;
+    if (b->edge.bottom - a->edge.bottom)
+      return b->edge.bottom - a->edge.bottom;
+
+    /* Horizontal case */
+//    printf ("Horizontal case\n");
+    return b->edge.line.p2.x - b->edge.line.p2.x;
 }
 
 static inline cairo_int64_t
@@ -659,10 +685,12 @@ intersect_lines (cairo_bo_edge_t                *a,
                   b->edge.line.p1.x - a->edge.line.p1.x,
                   b->edge.line.p1.y - a->edge.line.p1.y);
     if (_cairo_int64_negative (den_det)) {
-        if (_cairo_int64_ge (den_det, R))
+//        if (_cairo_int64_ge (den_det, R))
+        if (_cairo_int64_gt (den_det, R))
             return FALSE;
     } else {
-        if (_cairo_int64_le (den_det, R))
+//        if (_cairo_int64_le (den_det, R))
+        if (_cairo_int64_lt (den_det, R))
             return FALSE;
     }
 
@@ -670,10 +698,12 @@ intersect_lines (cairo_bo_edge_t                *a,
                   a->edge.line.p1.y - b->edge.line.p1.y,
                   a->edge.line.p1.x - b->edge.line.p1.x);
     if (_cairo_int64_negative (den_det)) {
-        if (_cairo_int64_ge (den_det, R))
+//        if (_cairo_int64_ge (den_det, R))
+        if (_cairo_int64_gt (den_det, R))
             return FALSE;
     } else {
-        if (_cairo_int64_le (den_det, R))
+//        if (_cairo_int64_le (den_det, R))
+        if (_cairo_int64_lt (den_det, R))
             return FALSE;
     }
 
@@ -733,6 +763,7 @@ intersect_lines (cairo_bo_edge_t                *a,
     return TRUE;
 }
 
+#if 0
 static int
 _cairo_bo_intersect_ordinate_32_compare (cairo_bo_intersect_ordinate_t        a,
                                          int32_t                        b)
@@ -817,6 +848,7 @@ _cairo_bo_edge_contains_intersect_point (cairo_bo_edge_t                *edge,
         return _cairo_bo_intersect_ordinate_32_compare (point->x, bot_x) < 0;
     }
 }
+#endif
 
 /* Compute the intersection of two edges. The result is provided as a
  * coordinate pair of 128-bit integers.
@@ -841,14 +873,19 @@ _cairo_bo_edge_intersect (cairo_bo_edge_t        *a,
 {
     cairo_bo_intersect_point_t quorem;
 
+    /* FIXME: Can we cheat... we know our polygons don't self-intersect
+     * FIXME: Perhaps we need to let it do the test if one piece is _new_, due to snap-rounding? */
+
     if (! intersect_lines (a, b, &quorem))
         return FALSE;
 
+#if 0
     if (! _cairo_bo_edge_contains_intersect_point (a, &quorem))
         return FALSE;
 
     if (! _cairo_bo_edge_contains_intersect_point (b, &quorem))
         return FALSE;
+#endif
 
     /* Now that we've correctly compared the intersection point and
      * determined that it lies within the edge, then we know that we
@@ -1077,9 +1114,9 @@ _cairo_bo_event_queue_fini (cairo_bo_event_queue_t *event_queue)
 }
 
 static inline cairo_status_t
-_cairo_bo_event_queue_insert_if_intersect_below_current_y (cairo_bo_event_queue_t        *event_queue,
+_cairo_bo_event_queue_insert_if_intersect_below_current_y (cairo_bo_event_queue_t *event_queue,
                                                            cairo_bo_edge_t        *left,
-                                                           cairo_bo_edge_t *right)
+                                                           cairo_bo_edge_t        *right)
 {
     cairo_bo_point32_t intersection;
 
@@ -1091,8 +1128,30 @@ _cairo_bo_event_queue_insert_if_intersect_below_current_y (cairo_bo_event_queue_
      * slope comparison also puts left less than right, then we know
      * that the intersection of these two segments has already
      * occurred before the current sweep line position. */
-    if (_slope_compare (left, right) <= 0)
+
+    /* CAN THIS THROW AWAY AN INTERSECT ON THE EXACT POINT THE LINE STARTS? */
+    if (_slope_compare (left, right) <= 0) {
+#if 0
+      printf ("Dropping lines (%i,%i)-(%i,%i), (%i,%i)-(%i,%i)\n",
+              left->edge.line.p1.x, left->edge.line.p1.y,
+              left->edge.line.p2.x, left->edge.line.p2.y,
+              right->edge.line.p1.x, right->edge.line.p1.y,
+              right->edge.line.p2.x, right->edge.line.p2.y);
+#endif
+#if 0
+      printf ("\tLine[%i %i %i %i 1500 2000 \"clearline\"] #%s\n",
+              left->edge.line.p1.x, left->edge.line.p1.y,
+              left->edge.line.p2.x, left->edge.line.p2.y,
+              (left->edge.line.p1.x == left->edge.line.p2.x) ? "V" :
+              ((left->edge.line.p1.y == left->edge.line.p2.y) ? "H" : ""));
+      printf ("\tLine[%i %i %i %i 1500 2000 \"clearline\"] #%s\n",
+              right->edge.line.p1.x, right->edge.line.p1.y,
+              right->edge.line.p2.x, right->edge.line.p2.y,
+              (right->edge.line.p1.x == right->edge.line.p2.x) ? "V" :
+              ((right->edge.line.p1.y == right->edge.line.p2.y) ? "H" : ""));
+#endif
         return CAIRO_STATUS_SUCCESS;
+    }
 
     if (! _cairo_bo_edge_intersect (left, right, &intersection))
         return CAIRO_STATUS_SUCCESS;
@@ -1302,6 +1361,7 @@ event_log (const char *fmt, ...)
 }
 #endif
 
+#if 0
 static inline cairo_bool_t
 edges_colinear (const cairo_bo_edge_t *a, const cairo_bo_edge_t *b)
 {
@@ -1326,6 +1386,7 @@ edges_colinear (const cairo_bo_edge_t *a, const cairo_bo_edge_t *b)
                                              b->edge.line.p1.x) == 0;
     }
 }
+#endif
 
 
 static cairo_status_t
@@ -1353,10 +1414,11 @@ _add_result_edge (cairo_array_t *array,
     printf ("Emitting result edge (%i,%i)-(%i,%i)\n",
             edge->line.p1.x, edge->line.p1.y,
             edge->line.p2.x, edge->line.p2.y);
-#else
-//    printf ("\tLine[%i %i %i %i 1500 2000 \"clearline\"]\n",
-//            edge->line.p1.x, edge->line.p1.y,
-//            edge->line.p2.x, edge->line.p2.y);
+#endif
+#if 0
+    printf ("\tLine[%i %i %i %i 1500 2000 \"clearline\"]\n",
+            edge->line.p1.x, edge->line.p1.y,
+            edge->line.p2.x, edge->line.p2.y);
 #endif
 
 //    return _cairo_array_append (array, edge);
@@ -1488,10 +1550,41 @@ _cairo_bentley_ottmann_tessellate_bo_edges (cairo_bo_event_t   **start_events,
 
             /* skip this intersection if its edges are not adjacent */
             if (e2 != e1->next) {
-                printf ("Breaking because edges not adjacent - will we return?\n");
+//                printf ("Breaking because edges not adjacent - will we return?\n");
+#if 0
+                printf ("event: (%i,%i), e1: (%i,%i)-(%i,%i), e2: (%i,%i)-(%i,%i)\n",
+                        event->point.x, event->point.y,
+                        e1->edge.line.p1.x, e1->edge.line.p1.y,
+                        e1->edge.line.p2.x, e1->edge.line.p2.y,
+                        e2->edge.line.p1.x, e2->edge.line.p1.y,
+                        e2->edge.line.p2.x, e2->edge.line.p2.y);
+
+                if (e1->next)
+                  printf ("e1->next: (%i,%i)-(%i,%i)\n", e1->next->edge.line.p1.x,
+                                                         e1->next->edge.line.p1.y,
+                                                         e1->next->edge.line.p2.x,
+                                                         e1->next->edge.line.p2.y);
+                else
+                  printf ("e1->next = NULL\n");
+
+                if (e1 == e2->next)
+                  printf ("Oops, we were backwards adjacent\n");
+#endif
+
+                // Do the intersection anyway?
+                // do_intersect (e1, e2, event->point);
+
                 break;
             }
 
+#if 0
+            printf ("EVENT: (%i,%i), e1: (%i,%i)-(%i,%i), e2: (%i,%i)-(%i,%i)\n",
+                    event->point.x, event->point.y,
+                    e1->edge.line.p1.x, e1->edge.line.p1.y,
+                    e1->edge.line.p2.x, e1->edge.line.p2.y,
+                    e2->edge.line.p1.x, e2->edge.line.p1.y,
+                    e2->edge.line.p2.x, e2->edge.line.p2.y);
+#endif
             intersection_count++;
 
             do_intersect (e1, e2, event->point);
@@ -1555,6 +1648,7 @@ _cairo_bentley_ottmann_tessellate_bo_edges (cairo_bo_event_t   **start_events,
     return status;
 }
 
+#if 0
 cairo_status_t
 _cairo_bentley_ottmann_tessellate_polygon (cairo_traps_t         *traps,
                                            const cairo_polygon_t *polygon)
@@ -1620,6 +1714,7 @@ _cairo_bentley_ottmann_tessellate_polygon (cairo_traps_t         *traps,
 
     return status;
 }
+#endif
 
 #if 0
 cairo_status_t
@@ -2099,14 +2194,14 @@ my_cairo_test (void)
   i++;
 #endif
 
-  /* Line from (10,10)-(20,20) */
-  points[i].a.x = 10; points[i].a.y = 10;
+  /* Line from (10,20)-(20,20) */
+  points[i].a.x = 10; points[i].a.y = 20;
   points[i].b.x = 20; points[i].b.y = 20;
   points[i].num = i;
   data = g_list_prepend (data, &points[i]);
   i++;
 
-  /* Line from (15,20)-(15,10) */
+  /* Line from (15,10)-(15,20) */
   points[i].a.x = 15; points[i].a.y = 10;
   points[i].b.x = 15; points[i].b.y = 20;
   points[i].num = i;
@@ -2184,7 +2279,7 @@ adjust_tree (PLINE *p, VNODE *v)
   q->box.Y2 = max (q->v->point[1], q->v->next->point[1]) + 1;
   r_insert_entry (p->tree, (const BoxType *) q, 1);
   r_delete_entry (p->tree, (const BoxType *) s);
-  free (s);
+  /* r_delete_entry deletes the seg */
   return 0;
 }
 
@@ -2194,38 +2289,8 @@ node_add
  (C) 1993 Klamer Schutte
  (C) 1997 Alexey Nikitin, Michael Leonov
  (C) 2006 harry eaton
-
- returns a bit field in new_point that indicates where the
- point was.
- 1 means a new node was created and inserted
- 4 means the intersection was not on the dest point
 */
 static VNODE *
-node_add (VNODE * dest, cairo_point_t po, int *new_point)
-{
-  VNODE *p;
-  Vector v;
-
-  if (vect_equal (po, dest->point))
-    return dest;
-  if (vect_equal (po, dest->next->point))
-    {
-      (*new_point) += 4;
-      return dest->next;
-    }
-  v[0] = po.x;  v[1] = po.y;
-  p = poly_CreateNode (v);
-  if (p == NULL)
-    return NULL;
-  (*new_point) += 5;
-  p->prev = dest;
-  p->next = dest->next;
-  p->cvc_prev = p->cvc_next = NULL;
-  p->Flags.status = UNKNWN;
-  return (dest->next = dest->next->prev = p);
-}				/* node_add */
-
-static VNODE *
 node_add_single (VNODE * dest, cairo_point_t po)
 {
   VNODE *p;
@@ -2254,39 +2319,19 @@ node_add_point
 
  return 1 if new node in b, 2 if new node in a and 3 if new node in both
 */
-
-static int
-node_add_point (VNODE * a, VNODE * b, cairo_point_t p)
-{
-  int res = 0;
-
-  VNODE *node_a, *node_b;
-
-  node_a = node_add (a, p, &res);
-  res += res;
-  node_b = node_add (b, p, &res);
-
-  if (node_a == NULL || node_b == NULL)
-    return ISECT_NO_MEMORY;
-  node_b->cvc_prev = node_b->cvc_next = (CVCList *) - 1;
-  node_a->cvc_prev = node_a->cvc_next = (CVCList *) - 1;
-  return res;
-}				/* node_add_point */
-
 static VNODE *
 node_add_single_point (VNODE *inp_node, cairo_point_t p)
 {
+  VNODE *next_node = inp_node->next;
   VNODE *out_node;
 
-  /* JUST A HUNCH: */
-//  inp_node->cvc_prev = inp_node->cvc_next = (CVCList *) - 1;
-
   out_node = node_add_single (inp_node, p);
   out_node->cvc_prev = out_node->cvc_next = (CVCList *) - 1;
 
   if (out_node == inp_node ||
-      out_node == inp_node->next) {
+      out_node == next_node) {
     /* No node was added - apparently it already existed */
+//    printf ("X ");
     return NULL;
   }
 
@@ -2314,50 +2359,47 @@ do_intersect (cairo_bo_edge_t *e1, cairo_bo_edge_t *e2, cairo_point_t point)
   // BUT: We know our _single_ intersection is passed as (point.x,point.y) - so why bother?
   // Just need to check that intersection isn't with one of our existing vertex end-points?
 
+  if (e1->p == e2->p) {
+//    printf ("do_intersect: SAME CONTOUR\n");
+    return;
+  }
+
+//  printf ("do_intersect: ");
+
   e1->p->Flags.status = ISECTED;
   e2->p->Flags.status = ISECTED;
 
-//  if (cnt == 0) {
-//    printf ("Alleged no intersection error\n");
-//  }
-//  if (cnt == 2) {
-//    printf ("ALLEGED TWO INTERSECTIONS ERROR");
-//  }
-
   new_node = node_add_single_point (e1->v, point);
   /* adjust the bounding box and tree if necessary */
   if (new_node != NULL) {
+//    printf ("1 ");
     e1->p->Count ++; /* ??? */
     cntrbox_adjust (e1->p, point);
     if (adjust_tree (e1->p, e1->v)) return; /* error */
     /* Need to decide whether the new piece, or the old piece is
        going to continue seeing "action" in the sweepline algorithm */
-#if 0
     if (new_node->point[1] > e1->v->point[1]) {
       e1->v = new_node;
     } else if (new_node->point[1] == e1->v->point[1]) {
       if (new_node->point[0] > e1->v->point[0])
         e1->v = new_node;
     }
-#endif
-//    e1->v = new_node;
   }
   /* if we added a node in the tree we need to change the tree */
   new_node = node_add_single_point (e2->v, point);
   if (new_node != NULL) {
+//    printf ("2");
     e2->p->Count ++; /* ??? */
     cntrbox_adjust (e2->p, point);
     if (adjust_tree (e2->p, e2->v)) return /*1*/;
-#if 0
     if (new_node->point[1] > e2->v->point[1]) {
       e2->v = new_node;
     } else if (new_node->point[1] == e2->v->point[1]) {
       if (new_node->point[0] > e2->v->point[0])
         e2->v = new_node;
     }
-#endif
-//    e2->v = new_node;
   }
+//  printf ("\n");
   return;
 }
 
@@ -2370,68 +2412,73 @@ poly_area_to_start_events (POLYAREA                *poly,
 {
     int i = *counter;
     PLINE *contour;
-
-    /* Loop over contours */
-    for (contour = poly->contours; contour != NULL; contour = contour->next) {
-      /* Loop over nodes, adding edges */
-      VNODE *bv;
-      bv = &contour->head;
-      do {
-        int x1, y1, x2, y2;
-        cairo_edge_t cairo_edge;
-        /* Node is between bv->point[0,1] and bv->next->point[0,1] */
-
-        /* HACK TEST: */
-        bv->cvc_prev = bv->cvc_next = NULL;
+    POLYAREA *pa;
+
+    pa = poly;
+    do {
+      /* Loop over contours */
+      for (contour = pa->contours; contour != NULL; contour = contour->next) {
+        /* Loop over nodes, adding edges */
+        VNODE *bv;
+        bv = &contour->head;
+        do {
+          int x1, y1, x2, y2;
+          cairo_edge_t cairo_edge;
+          /* Node is between bv->point[0,1] and bv->next->point[0,1] */
+
+          /* HACK TEST: */
+//        bv->cvc_prev = bv->cvc_next = NULL;
 //        bv->cvc_prev = bv->cvc_next = (CVCList *) - 1;
 
-        if (bv->point[1] == bv->next->point[1]) {
-            if (bv->point[0] < bv->next->point[0]) {
-              x1 = bv->point[0];
-              y1 = bv->point[1];
-              x2 = bv->next->point[0];
-              y2 = bv->next->point[1];
-            } else {
-              x1 = bv->next->point[0];
-              y1 = bv->next->point[1];
-              x2 = bv->point[0];
-              y2 = bv->point[1];
-            }
-        } else if (bv->point[1] < bv->next->point[1]) {
-          x1 = bv->point[0];
-          y1 = bv->point[1];
-          x2 = bv->next->point[0];
-          y2 = bv->next->point[1];
-        } else {
-          x1 = bv->next->point[0];
-          y1 = bv->next->point[1];
-          x2 = bv->point[0];
-          y2 = bv->point[1];
-        }
-
-        cairo_edge.line.p1.x = x1;
-        cairo_edge.line.p1.y = cairo_edge.top = y1;
-        cairo_edge.line.p2.x = x2;
-        cairo_edge.line.p2.y = cairo_edge.bottom = y2;
-        cairo_edge.dir = 0;
-
-        event_ptrs[i] = (cairo_bo_event_t *) &events[i];
-
-        events[i].type = CAIRO_BO_EVENT_TYPE_START;
-        events[i].point.y = cairo_edge.top;
-        events[i].point.x =
-            _line_compute_intersection_x_for_y (&cairo_edge.line,
-                                                events[i].point.y);
-
-        events[i].edge.edge = cairo_edge;
-        events[i].edge.prev = NULL;
-        events[i].edge.next = NULL;
-        events[i].edge.p = contour;
-        events[i].edge.v = bv;
-        i++;
-
-      } while ((bv = bv->next) != &contour->head);
-    }
+          if (bv->point[1] == bv->next->point[1]) {
+              if (bv->point[0] < bv->next->point[0]) {
+                x1 = bv->point[0];
+                y1 = bv->point[1];
+                x2 = bv->next->point[0];
+                y2 = bv->next->point[1];
+              } else {
+                x1 = bv->next->point[0];
+                y1 = bv->next->point[1];
+                x2 = bv->point[0];
+                y2 = bv->point[1];
+              }
+          } else if (bv->point[1] < bv->next->point[1]) {
+            x1 = bv->point[0];
+            y1 = bv->point[1];
+            x2 = bv->next->point[0];
+            y2 = bv->next->point[1];
+          } else {
+            x1 = bv->next->point[0];
+            y1 = bv->next->point[1];
+            x2 = bv->point[0];
+            y2 = bv->point[1];
+          }
+
+          cairo_edge.line.p1.x = x1;
+          cairo_edge.line.p1.y = cairo_edge.top = y1;
+          cairo_edge.line.p2.x = x2;
+          cairo_edge.line.p2.y = cairo_edge.bottom = y2;
+          cairo_edge.dir = 0;
+
+          event_ptrs[i] = (cairo_bo_event_t *) &events[i];
+
+          events[i].type = CAIRO_BO_EVENT_TYPE_START;
+          events[i].point.y = cairo_edge.top;
+          events[i].point.x =
+              _line_compute_intersection_x_for_y (&cairo_edge.line,
+                                                  events[i].point.y);
+
+          events[i].edge.edge = cairo_edge;
+          events[i].edge.prev = NULL;
+          events[i].edge.next = NULL;
+          events[i].edge.p = contour;
+          events[i].edge.v = bv;
+          i++;
+
+        } while ((bv = bv->next) != &contour->head);
+      }
+
+    } while ((pa = pa->f) != poly);
 
     *counter = i;
 }
@@ -2447,40 +2494,23 @@ bo_intersect (jmp_buf *jb, POLYAREA *b, POLYAREA *a)
     cairo_bo_start_event_t *events;
     cairo_bo_event_t *stack_event_ptrs[ARRAY_LENGTH (stack_events) + 1];
     cairo_bo_event_t **event_ptrs;
-    int num_events;
-    int i, j, k;
-    VNODE *doh;
+    int num_events = 0;
+    int i;
+    POLYAREA *pa;
     cairo_traps_t *traps = NULL;
 
     PLINE *contour;
 
-    num_events = 0;
-
-    j = 0; k = 0;
-    for (contour = a->contours; contour != NULL; contour = contour->next) {
-        int tmp = 0;
-        j += contour->Count;
-        doh = &contour->head;
-        do {tmp++;} while ((doh = doh->next) != &contour->head);
-        k+= tmp;
-        contour->Count = tmp;
-    }
-    num_events += k;
-    if (k != j)
-      printf ("OH CRAPPY DOODLE, j=%i, k=%i\n", j, k);
-
-    j = 0; k = 0;
-    for (contour = b->contours; contour != NULL; contour = contour->next) {
-        int tmp = 0;
-        j += contour->Count;
-        doh = &contour->head;
-        do {tmp++;} while ((doh = doh->next) != &contour->head);
-        k+= tmp;
-        contour->Count = tmp;
-    }
-    if (k != j)
-      printf ("OH CRAPPY DOODLE, j=%i, k=%i\n", j, k);
-    num_events += MAX(j,k);
+    pa = a;
+    do {
+      for (contour = pa->contours; contour != NULL; contour = contour->next)
+        num_events += contour->Count;
+    } while ((pa = pa->f) != a);
+    pa = b;
+    do {
+      for (contour = pa->contours; contour != NULL; contour = contour->next)
+        num_events += contour->Count;
+    } while ((pa = pa->f) != b);
 
     if (unlikely (0 == num_events))
         return CAIRO_STATUS_SUCCESS;
@@ -2511,7 +2541,7 @@ bo_intersect (jmp_buf *jb, POLYAREA *b, POLYAREA *a)
                                                          num_events,
                                                          traps,
                                                          &intersections);
-    printf ("Number of intersections was %i\n", intersections);
+//    printf ("Number of intersections was %i\n", intersections);
 #if DEBUG_TRAPS
     dump_traps (traps, "bo-polygon-out.txt");
 #endif
diff --git a/src/polygon1.c b/src/polygon1.c
index ad664cb..9f184b3 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -192,7 +192,6 @@ node_add_single (VNODE * dest, Vector po)
   p->Flags.status = UNKNWN;
   return p;
 }				/* node_add */
-
 /*
 new_descriptor
   (C) 2006 harry eaton
@@ -592,12 +591,11 @@ seg_in_seg (const BoxType * b, void *cl)
 //  printf ("Looking at intersection between %p(%i) and %p(%i)\n",
 //          s->v, s->v->Flags.intersected, i->v, i->v->Flags.intersected);
 
-  if (s->intersected || i->s->intersected)
-    {
+  if (s->intersected || i->s->intersected) {
 //    printf ("Need to restart intersection\n");
-      i->need_restart = 1;
-      return 0;
-    }
+    i->need_restart = 1;
+    return 0;
+  }
 
   cnt = vect_inters2 (s->v->point, s->v->next->point,
 		      i->v->point, i->v->next->point, s1, s2);
@@ -612,35 +610,36 @@ seg_in_seg (const BoxType * b, void *cl)
       int done_insert = 0;
       new_node = node_add_single_point (i->v, cnt > 1 ? s2 : s1);
       if (new_node != NULL)
-	{
-	  insert_task *task = g_new0 (insert_task, 1);
-	  task->new_node = new_node;
-	  task->seg = i->s;
-	  task->seg->intersected = 1;
-	  i->node_insert_list = g_list_prepend (i->node_insert_list, task);
-	  done_insert = 1;
-	}
+        {
+          insert_task *task = g_new0 (insert_task, 1);
+          task->new_node = new_node;
+          task->seg = i->s;
+          task->seg->intersected = 1;
+          i->node_insert_list = g_list_prepend (i->node_insert_list, task);
+          done_insert = 1;
+        }
 //      else
 //        printf (".");
       new_node = node_add_single_point (s->v, cnt > 1 ? s2 : s1);
       if (new_node != NULL)
-	{
-	  insert_task *task = g_new0 (insert_task, 1);
-	  task->new_node = new_node;
-	  task->seg = s;
-	  task->seg->intersected = 1;
-	  i->node_insert_list = g_list_prepend (i->node_insert_list, task);
-	  return 0;		/* Don't do any more processing */
-	}
+        {
+          insert_task *task = g_new0 (insert_task, 1);
+          task->new_node = new_node;
+          task->seg = s;
+          task->seg->intersected = 1;
+          i->node_insert_list = g_list_prepend (i->node_insert_list, task);
+          printf ("Looks like we missed something\n");
+          return 0; /* Don't do any more processing */
+        }
 //      else
 //        printf (":");
-      if (done_insert)
-	{
+      if (done_insert) {
 //        printf ("Long-jmping back, since we intersected on i\n");
-	  longjmp (*i->env, 1);	/* Skip this contour if we intersected on i */
-	  i->need_restart = 1;	/* If we skip some processing, we definately need a restart */
-	  return 0;
-	}
+        longjmp (*i->env, 1); /* Skip this contour if we intersected on i */
+        i->need_restart = 1; /* If we skip some processing, we definately need a restart */
+        printf ("Looks like we missed something\n");
+        return 0;
+      }
     }
   return 0;
 }
@@ -698,7 +697,7 @@ get_seg (const BoxType * b, void *cl)
 }
 
 struct seg *
-lookup_seg (PLINE * contour, VNODE * vertex)
+lookup_seg (PLINE *contour, VNODE *vertex)
 {
   struct info info;
   BoxType box;
@@ -737,9 +736,9 @@ lookup_seg (PLINE * contour, VNODE * vertex)
 static int
 contour_bounds_touch (const BoxType * b, void *cl)
 {
-  contour_info *c_info = (contour_info *) cl;
+  contour_info *c_info = (contour_info *)cl;
   PLINE *pa = c_info->pa;
-  PLINE *pb = (PLINE *) b;
+  PLINE *pb = (PLINE *)b;
   PLINE *rtree_over;
   PLINE *looping_over;
   VNODE *av;			/* node iterators */
@@ -760,17 +759,17 @@ contour_bounds_touch (const BoxType * b, void *cl)
    */
   if (pa->Count < pb->Count)
     {
-      rtree_over = pb;
+      rtree_over   = pb;
       looping_over = pa;
     }
   else
     {
-      rtree_over = pa;
+      rtree_over   = pa;
       looping_over = pb;
     }
 
   av = &looping_over->head;
-  do				/* Loop over the nodes in the smaller contour */
+  do  /* Loop over the nodes in the smaller contour */
     {
       /* check this edge for any insertions */
       double dx;
@@ -778,56 +777,54 @@ contour_bounds_touch (const BoxType * b, void *cl)
 #if 0
       /* We know we will just reject any intersections found until
          the next pass anyway */
-      if (av->Flags.intersected)
-	{
+      if (av->Flags.intersected) {
 //        printf ("skip\n");
-	  continue;
-	}
+        continue;
+      }
 #endif
 
       info.v = av;
       /* compute the slant for region trimming */
       dx = av->next->point[0] - av->point[0];
       if (dx == 0)
-	info.m = 0;
+        info.m = 0;
       else
-	{
-	  info.m = (av->next->point[1] - av->point[1]) / dx;
-	  info.b = av->point[1] - info.m * av->point[0];
-	}
+        {
+          info.m = (av->next->point[1] - av->point[1]) / dx;
+          info.b = av->point[1] - info.m * av->point[0];
+        }
       box.X2 = (box.X1 = av->point[0]) + 1;
       box.Y2 = (box.Y1 = av->point[1]) + 1;
 
       /* fill in the segment in info corresponding to this node */
       if (setjmp (info.sego) == 0)
-	{
-	  r_search (looping_over->tree, &box, NULL, get_seg, &info);
-	  assert (0);
-	}
+        {
+          r_search (looping_over->tree, &box, NULL, get_seg, &info);
+          assert (0);
+        }
 
       /* If we're going to have another pass anyway, skip this */
       if (info.s->intersected && info.node_insert_list != NULL)
-	continue;
+        continue;
 
       if (setjmp (restart))
-	continue;
+        continue;
 
-      /* NB: If this actually hits anything, we are teleported back to the beginning */
-      info.tree = rtree_over->tree;
-      if (info.tree)
-	if (UNLIKELY (r_search (info.tree, &info.s->box,
-				seg_in_region, seg_in_seg, &info)))
-	  exit (0);
-//            return err_no_memory;     /* error */
+        /* NB: If this actually hits anything, we are teleported back to the beginning */
+        info.tree = rtree_over->tree;
+        if (info.tree)
+          if (UNLIKELY (r_search (info.tree, &info.s->box,
+                                  seg_in_region, seg_in_seg, &info)))
+            exit (0);
+//            return err_no_memory;	/* error */
     }
   while ((av = av->next) != &looping_over->head);
 
   c_info->node_insert_list = info.node_insert_list;
-  if (info.need_restart)
-    {
+  if (info.need_restart) {
 //    printf ("info.needs_restart says we need to restart\n");
-      c_info->need_restart = 1;
-    }
+    c_info->need_restart = 1;
+  }
   return 0;
 }
 
@@ -843,7 +840,7 @@ insert_new_nodes_cb (gpointer data, gpointer userdata)
   task->new_node->next = task->seg->v->next;
   task->seg->v->next->prev = task->new_node;
   task->seg->v->next = task->new_node;
-  task->seg->p->Count++;
+  task->seg->p->Count ++;
 
   cntrbox_adjust (task->seg->p, task->new_node->point);
   if (adjust_tree (task->seg->p->tree, task->seg))
@@ -871,9 +868,9 @@ intersect_impl (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
       a = t;
     }
 
-//  setjmp (c_info.restart);            /* we loop back here whenever a vertex is inserted */
+//  setjmp (c_info.restart);		/* we loop back here whenever a vertex is inserted */
 
-  for (pa = a->contours; pa; pa = pa->next)	/* Loop over the contours of POLYAREA "a" */
+  for (pa = a->contours; pa; pa = pa->next)     /* Loop over the contours of POLYAREA "a" */
     {
       BoxType sb;
       jmp_buf out;
@@ -883,16 +880,16 @@ intersect_impl (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
       c_info.pa = pa;
 
       if (!add)
-	{
-	  retval = setjmp (out);
-	  if (retval)
-	    {
-	      /* The intersection test short-circuited back here,
-	       * we need to clean up, then longjmp to jb */
-	      longjmp (*jb, retval);
-	    }
-	  c_info.getout = &out;
-	}
+        {
+          retval = setjmp (out);
+          if (retval)
+            {
+              /* The intersection test short-circuited back here,
+               * we need to clean up, then longjmp to jb */
+              longjmp (*jb, retval);
+            }
+          c_info.getout = &out;
+        }
 
       sb.X1 = pa->xmin;
       sb.Y1 = pa->ymin;
@@ -900,20 +897,18 @@ intersect_impl (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
       sb.Y2 = pa->ymax + 1;
 
       r_search (b->contour_tree, &sb, NULL, contour_bounds_touch, &c_info);
-      if (c_info.need_restart)
-	{
-	  need_restart = 1;
+      if (c_info.need_restart) {
+        need_restart = 1;
 //        printf ("contour_bounds_touch: need_restart\n");
 //        break;
-	}
+      }
     }
 
 //  printf ("----\n");
-  if (c_info.node_insert_list != NULL)
-    {
+  if (c_info.node_insert_list != NULL) {
 //    printf ("Processing %i new nodes\n", g_list_length (c_info.node_insert_list));
-      need_restart = 1;		/* Any new nodes could intersect */
-    }
+    need_restart = 1; /* Any new nodes could intersect */
+  }
   g_list_foreach (c_info.node_insert_list, insert_new_nodes_cb, NULL);
   g_list_free (c_info.node_insert_list);
 //  printf ("====\n");
@@ -925,8 +920,7 @@ static int
 intersect (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
 {
   int call_count = 1;
-  while (intersect_impl (jb, b, a, add))
-    call_count++;
+  while (intersect_impl (jb, b, a, add)) call_count++;
   return 0;
 }
 
@@ -937,64 +931,57 @@ M_POLYAREA_intersect (jmp_buf * e, POLYAREA * afst, POLYAREA * bfst, int add)
   PLINE *curcA, *curcB;
   CVCList *the_list = NULL;
 
+//  printf ("M_POLYAREA_intersect: bo_intersect\n");
   if (a == NULL || b == NULL)
     error (err_bad_parm);
+  if (add)
+    bo_intersect (e, a, b);
   do
     {
-      do
-	{
-	  if (a->contours->xmax >= b->contours->xmin &&
-	      a->contours->ymax >= b->contours->ymin &&
-	      a->contours->xmin <= b->contours->xmax &&
-	      a->contours->ymin <= b->contours->ymax)
-	    {
-#if 1
-	      if (!add)
-		{
-		  if (UNLIKELY (intersect (e, a, b, add)))
-		    {
-		      printf ("is_enom\n");
-		      error (err_no_memory);
-		    }
-		}
-	      else
-#endif
-		{
-		  if (UNLIKELY (bo_intersect (e, a, b)))
-		    {
-		      printf ("bo_is_enom\n");
-		      error (err_no_memory);
-		    }
-		}
-	    }
-	}
-      while (add && (a = a->f) != afst);
+      if (!add)
+        {
+          do
+            {
+              if (a->contours->xmax >= b->contours->xmin &&
+                  a->contours->ymax >= b->contours->ymin &&
+                  a->contours->xmin <= b->contours->xmax &&
+                  a->contours->ymin <= b->contours->ymax)
+                {
+                  if (UNLIKELY (intersect (e, a, b, add))) {
+                    printf ("is_enom\n");
+                    error (err_no_memory);
+                  }
+                }
+            }
+          while (add && (a = a->f) != afst);
+        }
+
       for (curcB = b->contours; curcB != NULL; curcB = curcB->next)
 	if (curcB->Flags.status == ISECTED)
 	  {
 	    the_list = add_descriptors (curcB, 'B', the_list);
-	    if (UNLIKELY (the_list == NULL))
-	      {
-		printf ("add_desc\n");
-		error (err_no_memory);
-	      }
+	    if (UNLIKELY (the_list == NULL)) {
+              printf ("add_desc\n");
+	      error (err_no_memory);
+            }
 	  }
     }
   while (add && (b = b->f) != bfst);
+//  printf ("M_POLYAREA_intersect: Descriptors\n");
   do
     {
       for (curcA = a->contours; curcA != NULL; curcA = curcA->next)
 	if (curcA->Flags.status == ISECTED)
 	  {
 	    the_list = add_descriptors (curcA, 'A', the_list);
-	    if (UNLIKELY (the_list == NULL))
-	      {
-		printf ("add_desc2\n");
-		error (err_no_memory);
-	      }
+	    if (UNLIKELY (the_list == NULL)) {
+              printf ("add_desc2\n");
+	      error (err_no_memory);
+            }
 	  }
     }
   while (add && (a = a->f) != afst);
+//  printf ("M_POLYAREA_intersect: Done\n");
 }				/* M_POLYAREA_intersect */
 
 static inline int
@@ -1010,7 +997,7 @@ cntrbox_inside (PLINE * c1, PLINE * c2)
 /* Routines for making labels */
 
 static int
-count_contours_i_am_inside (const BoxType * b, void *cl)
+count_contours_i_am_inside (const BoxType *b, void *cl)
 {
   PLINE *me = cl;
   PLINE *check = (PLINE *) b;
@@ -1048,22 +1035,19 @@ cntr_in_M_POLYAREA (PLINE * poly, POLYAREA * outfst, BOOLp test)
 	break;
       outer = (POLYAREA *) heap_remove_smallest (heap);
 
-      switch (r_search
-	      (outer->contour_tree, (BoxType *) poly, NULL,
-	       count_contours_i_am_inside, poly))
-	{
-	case 0:		/* Didn't find anything in this piece, Keep looking */
-	  break;
-	case 1:		/* Found we are inside this piece, and not any of its holes */
-	  heap_destroy (&heap);
-	  return TRUE;
-	case 2:		/* Found inside a hole in the smallest polygon so far. No need to check the other polygons */
-	  heap_destroy (&heap);
-	  return FALSE;
-	default:
-	  printf ("Something strange here\n");
-	  break;
-	}
+      switch (r_search (outer->contour_tree, (BoxType *)poly, NULL, count_contours_i_am_inside, poly)) {
+        case 0: /* Didn't find anything in this piece, Keep looking */
+          break;
+        case 1: /* Found we are inside this piece, and not any of its holes */
+          heap_destroy (&heap);
+          return TRUE;
+        case 2: /* Found inside a hole in the smallest polygon so far. No need to check the other polygons */
+          heap_destroy (&heap);
+          return FALSE;
+        default:
+          printf ("Something strange here\n");
+          break;
+      }
     }
   while (1);
   heap_destroy (&heap);
@@ -1127,28 +1111,28 @@ label_contour (PLINE * a)
   do
     {
       if (cur->cvc_next)	/* _always_ examine cross vertex */
-	{
-	  label = node_label (cur);
-	  if (first_not_unknown == NULL)
-	    first_not_unknown = cur;
-	  continue;
-	}
+        {
+          label = node_label (cur);
+          if (first_not_unknown == NULL)
+            first_not_unknown = cur;
+          continue;
+        }
 
       if (NODE_LABEL (cur) != UNKNWN)
-	{
-	  /* This might get hit if the last cross vertex labelling
-	   * pass was a bit keen, and labeled past its own edges?
-	   */
-	  label = NODE_LABEL (cur);
-	  continue;
-	}
+        {
+          /* This might get hit if the last cross vertex labelling
+           * pass was a bit keen, and labeled past its own edges?
+           */
+          label = NODE_LABEL (cur);
+          continue;
+        }
 
       if (label == INSIDE || label == OUTSIDE)
-	{
-	  /* This labels nodes which aren't cross-connected */
-	  LABEL_NODE (cur, label);
-	  continue;
-	}
+        {
+          /* This labels nodes which aren't cross-connected */
+          LABEL_NODE (cur, label);
+          continue;
+        }
     }
   while ((cur = cur->next) != first_not_unknown);
 #ifdef DEBUG_ALL_LABELS
@@ -1186,11 +1170,10 @@ M_POLYAREA_label_separated (PLINE * afst, POLYAREA * b, BOOLp touch)
 {
   PLINE *curc = afst;
 
-  for (curc = afst; curc != NULL; curc = curc->next)
-    {
-      if (cntr_label_POLYAREA (curc, b, touch) && touch)
-	return TRUE;
-    }
+  for (curc = afst; curc != NULL; curc = curc->next) {
+    if (cntr_label_POLYAREA (curc, b, touch) && touch)
+      return TRUE;
+  }
   return FALSE;
 }
 
@@ -1243,7 +1226,7 @@ InsCntr (jmp_buf * e, PLINE * c, POLYAREA ** dst)
 
 static void
 PutContour (jmp_buf * e, PLINE * cntr, POLYAREA ** contours, PLINE ** holes,
-	    POLYAREA * owner, POLYAREA * parent, PLINE * parent_contour)
+            POLYAREA *owner, POLYAREA * parent, PLINE * parent_contour)
 {
   assert (cntr != NULL);
   assert (cntr->Count > 2);
@@ -1252,7 +1235,7 @@ PutContour (jmp_buf * e, PLINE * cntr, POLYAREA ** contours, PLINE ** holes,
   if (cntr->Flags.orient == PLF_DIR)
     {
       if (owner != NULL)
-	r_delete_entry (owner->contour_tree, (BoxType *) cntr);
+        r_delete_entry (owner->contour_tree, (BoxType *)cntr);
       InsCntr (e, cntr, contours);
     }
   /* put hole into temporary list */
@@ -1263,28 +1246,28 @@ PutContour (jmp_buf * e, PLINE * cntr, POLYAREA ** contours, PLINE ** holes,
 	{
 	  cntr->next = parent_contour->next;
 	  parent_contour->next = cntr;
-	  if (owner != parent)
-	    {
-	      if (owner != NULL)
-		r_delete_entry (owner->contour_tree, (BoxType *) cntr);
-	      r_insert_entry (parent->contour_tree, (BoxType *) cntr, 0);
-	    }
+          if (owner != parent)
+            {
+              if (owner != NULL)
+                r_delete_entry (owner->contour_tree, (BoxType *)cntr);
+              r_insert_entry (parent->contour_tree, (BoxType *)cntr, 0);
+            }
 	}
       else
 	{
 	  cntr->next = *holes;
 	  *holes = cntr;	/* let cntr be 1st hole in list */
-	  /* We don't insert the holes into an r-tree,
-	   * they just form a linked list */
-	  if (owner != NULL)
-	    r_delete_entry (owner->contour_tree, (BoxType *) cntr);
+          /* We don't insert the holes into an r-tree,
+           * they just form a linked list */
+          if (owner != NULL)
+            r_delete_entry (owner->contour_tree, (BoxType *)cntr);
 	}
     }
 }				/* PutContour */
 
 static inline void
-remove_contour (POLYAREA * piece, PLINE * prev_contour, PLINE * contour,
-		int remove_rtree_entry)
+remove_contour (POLYAREA *piece, PLINE *prev_contour, PLINE *contour,
+                int remove_rtree_entry)
 {
   if (piece->contours == contour)
     piece->contours = contour->next;
@@ -1297,7 +1280,7 @@ remove_contour (POLYAREA * piece, PLINE * prev_contour, PLINE * contour,
   contour->next = NULL;
 
   if (remove_rtree_entry)
-    r_delete_entry (piece->contour_tree, (BoxType *) contour);
+    r_delete_entry (piece->contour_tree, (BoxType *)contour);
 }
 
 struct polyarea_info
@@ -1310,37 +1293,34 @@ static int
 heap_it (const BoxType * b, void *cl)
 {
   heap_t *heap = (heap_t *) cl;
-  struct polyarea_info *pa_info = (struct polyarea_info *) b;
+  struct polyarea_info *pa_info = (struct polyarea_info *)b;
   PLINE *p = pa_info->pa->contours;
   if (p->Count == 0)
-    return 0;			/* how did this happen? */
+    return 0;  /* how did this happen? */
   heap_insert (heap, p->area, pa_info);
   return 1;
 }
 
-struct find_inside_info
-{
+struct find_inside_info {
   jmp_buf jb;
   PLINE *want_inside;
   PLINE *result;
 };
 
 static int
-find_inside (const BoxType * b, void *cl)
+find_inside (const BoxType *b, void *cl)
 {
   struct find_inside_info *info = cl;
   PLINE *check = (PLINE *) b;
   /* Do test on check to see if it inside info->want_inside */
   /* If it is: */
-  if (check->Flags.orient == PLF_DIR)
-    {
-      return 0;
-    }
-  if (poly_ContourInContour (info->want_inside, check))
-    {
-      info->result = check;
-      longjmp (info->jb, 1);
-    }
+  if (check->Flags.orient == PLF_DIR) {
+    return 0;
+  }
+  if (poly_ContourInContour (info->want_inside, check)) {
+    info->result = check;
+    longjmp (info->jb, 1);
+  }
   return 0;
 }
 
@@ -1364,7 +1344,7 @@ InsertHoles (jmp_buf * e, POLYAREA * dest, PLINE ** src)
   curc = dest;
   do
     {
-      num_polyareas++;
+      num_polyareas ++;
     }
   while ((curc = curc->f) != dest);
 
@@ -1412,7 +1392,7 @@ InsertHoles (jmp_buf * e, POLYAREA * dest, PLINE ** src)
       pa_info = heap_remove_smallest (heap);
       if (heap_is_empty (heap))
 	{			/* only one possibility it must be the right one */
-	  assert (poly_ContourInContour (pa_info->pa->contours, curh));
+          assert (poly_ContourInContour (pa_info->pa->contours, curh));
 	  container = pa_info->pa->contours;
 	}
       else
@@ -1445,48 +1425,42 @@ InsertHoles (jmp_buf * e, POLYAREA * dest, PLINE ** src)
 	}
       else
 	{
-	  /* Need to check if this new hole means we need to kick out any old ones for reprocessing */
-	  while (1)
-	    {
-	      struct find_inside_info info;
-	      PLINE *prev;
-
-	      info.want_inside = curh;
-
-	      /* Set jump return */
-	      if (setjmp (info.jb))
-		{
-		  /* Returned here! */
-		}
-	      else
-		{
-		  info.result = NULL;
-		  /* Rtree search, calling back a routine to longjmp back with data about any hole inside the added one */
-		  /*   Be sure not to bother jumping back to report the main contour! */
-		  r_search (pa_info->pa->contour_tree, (BoxType *) curh, NULL,
-			    find_inside, &info);
-
-		  /* Nothing found? */
-		  break;
-		}
-
-	      /* We need to find the contour before it, so we can update its next pointer */
-	      printf ("Found inside??\n");
+          /* Need to check if this new hole means we need to kick out any old ones for reprocessing */
+          while (1) {
+            struct find_inside_info info;
+            PLINE *prev;
+
+            info.want_inside = curh;
+
+            /* Set jump return */
+            if (setjmp (info.jb)) {
+              /* Returned here! */
+            } else {
+              info.result = NULL;
+              /* Rtree search, calling back a routine to longjmp back with data about any hole inside the added one */
+              /*   Be sure not to bother jumping back to report the main contour! */
+              r_search (pa_info->pa->contour_tree, (BoxType *)curh, NULL, find_inside, &info);
+
+              /* Nothing found? */
+              break;
+            }
+
+            /* We need to find the contour before it, so we can update its next pointer */
+            printf ("Found inside??\n");
 //            exit (0);
-	      prev = container;
-	      while (prev->next != info.result)
-		{
-		  prev = prev->next;
-		}
+            prev = container;
+            while (prev->next != info.result) {
+              prev = prev->next;
+            }
 
-	      /* Remove hole from the contour */
-	      remove_contour (pa_info->pa, prev, info.result, TRUE);
+            /* Remove hole from the contour */
+            remove_contour (pa_info->pa, prev, info.result, TRUE);
 
-	      /* Add hole as the next on the list to be processed in this very function */
-	      info.result->next = *src;
-	      *src = info.result;
-	    }
-	  /* End check for kicked out holes */
+            /* Add hole as the next on the list to be processed in this very function */
+            info.result->next = *src;
+            *src = info.result;
+          }
+          /* End check for kicked out holes */
 
 	  /* link at front of hole list */
 	  curh->next = container->next;
@@ -1707,37 +1681,37 @@ Gather (VNODE * start, PLINE ** result, J_Rule v_rule, DIRECTION initdir)
 }				/* Gather */
 
 static void
-Collect1 (jmp_buf * e, VNODE * cur, DIRECTION dir, POLYAREA ** contours,
-	  PLINE ** holes, J_Rule j_rule)
+Collect1 (jmp_buf * e, VNODE *cur, DIRECTION dir, POLYAREA **contours, PLINE ** holes, J_Rule j_rule)
 {
   PLINE *p = NULL;		/* start making contour */
   int errc = err_ok;
-  if ((errc =
-       Gather (dir == FORW ? cur : cur->next, &p, j_rule, dir)) != err_ok)
-    {
-      if (p != NULL)
-	poly_DelContour (&p);
-      error (errc);
-    }
-  if (!p)
-    return;
-  poly_PreContour (p, TRUE);
-  if (p->Count > 2)
-    {
+	if ((errc =
+	     Gather (dir == FORW ? cur : cur->next, &p, j_rule,
+		     dir)) != err_ok)
+	  {
+	    if (p != NULL)
+	      poly_DelContour (&p);
+	    error (errc);
+	  }
+	if (!p)
+	  return;
+	poly_PreContour (p, TRUE);
+	if (p->Count > 2)
+	  {
 #ifdef DEBUG_GATHER
-      DEBUGP ("adding contour with %d verticies and direction %c\n",
-	      p->Count, p->Flags.orient ? 'F' : 'B');
+	    DEBUGP ("adding contour with %d verticies and direction %c\n",
+		    p->Count, p->Flags.orient ? 'F' : 'B');
 #endif
-      PutContour (e, p, contours, holes, NULL, NULL, NULL);
-    }
-  else
-    {
-      /* some sort of computation error ? */
+	    PutContour (e, p, contours, holes, NULL, NULL, NULL);
+	  }
+	else
+	  {
+	    /* some sort of computation error ? */
 #ifdef DEBUG_GATHER
-      DEBUGP ("Bad contour! Not enough points!!\n");
+	    DEBUGP ("Bad contour! Not enough points!!\n");
 #endif
-      poly_DelContour (&p);
-    }
+	    poly_DelContour (&p);
+	  }
 }
 
 static void
@@ -1749,21 +1723,20 @@ Collect (jmp_buf * e, PLINE * a, POLYAREA ** contours, PLINE ** holes,
 
   cur = &a->head;
   do
-    {
-      if (s_rule (cur, &dir) && cur->Flags.mark == 0)
-	Collect1 (e, cur, dir, contours, holes, j_rule);
-      other = cur;
-      if ((other->cvc_prev && jump (&other, &dir, j_rule)))
-	Collect1 (e, other, dir, contours, holes, j_rule);
-    }
+   {
+    if (s_rule (cur, &dir) && cur->Flags.mark == 0)
+        Collect1(e, cur, dir, contours, holes, j_rule);
+    other = cur;
+    if ((other->cvc_prev && jump(&other, &dir, j_rule)))
+        Collect1(e, other, dir, contours, holes, j_rule);
+   }
   while ((cur = cur->next) != &a->head);
 }				/* Collect */
 
 
 static int
 cntr_Collect (jmp_buf * e, PLINE ** A, POLYAREA ** contours, PLINE ** holes,
-	      int action, POLYAREA * owner, POLYAREA * parent,
-	      PLINE * parent_contour)
+	      int action, POLYAREA *owner, POLYAREA * parent, PLINE *parent_contour)
 {
   PLINE *tmprev;
 
@@ -1811,7 +1784,7 @@ cntr_Collect (jmp_buf * e, PLINE ** A, POLYAREA ** contours, PLINE ** holes,
 	      PutContour (e, tmprev, contours, holes, owner, NULL, NULL);
 	      return TRUE;
 	    }
-	  /* break; *//* Fall through (I think this is correct! pcjc2) */
+	  /* break; */ /* Fall through (I think this is correct! pcjc2) */
 	case PBO_UNITE:
 	case PBO_SUB:
 	  if ((*A)->Flags.status == OUTSIDE)
@@ -1820,8 +1793,7 @@ cntr_Collect (jmp_buf * e, PLINE ** A, POLYAREA ** contours, PLINE ** holes,
 	      /* disappear this contour (rtree entry removed in PutContour) */
 	      *A = tmprev->next;
 	      tmprev->next = NULL;
-	      PutContour (e, tmprev, contours, holes, owner, parent,
-			  parent_contour);
+	      PutContour (e, tmprev, contours, holes, owner, parent, parent_contour);
 	      return TRUE;
 	    }
 	  break;
@@ -1887,21 +1859,21 @@ M_B_AREA_Collect (jmp_buf * e, POLYAREA * bfst, POLYAREA ** contours,
 
 
 static inline int
-contour_is_first (POLYAREA * a, PLINE * cur)
+contour_is_first (POLYAREA *a, PLINE *cur)
 {
   return (a->contours == cur);
 }
 
 
 static inline int
-contour_is_last (PLINE * cur)
+contour_is_last (PLINE *cur)
 {
   return (cur->next == NULL);
 }
 
 
 static inline void
-remove_polyarea (POLYAREA ** list, POLYAREA * piece)
+remove_polyarea (POLYAREA **list, POLYAREA *piece)
 {
   /* If this item was the start of the list, advance that pointer */
   if (*list == piece)
@@ -1918,7 +1890,7 @@ remove_polyarea (POLYAREA ** list, POLYAREA * piece)
 
 static void
 M_POLYAREA_separate_isected (jmp_buf * e, POLYAREA ** pieces,
-			     PLINE ** holes, PLINE ** isected)
+                             PLINE ** holes, PLINE ** isected)
 {
   POLYAREA *a = *pieces;
   POLYAREA *anext;
@@ -1929,88 +1901,75 @@ M_POLYAREA_separate_isected (jmp_buf * e, POLYAREA ** pieces,
     return;
 
   /* TODO: STASH ENOUGH INFORMATION EARLIER ON, SO WE CAN REMOVE THE INTERSECTED
-     CONTOURS WITHOUT HAVING TO WALK THE FULL DATA-STRUCTURE LOOKING FOR THEM. */
-
-  do
-    {
-      int hole_contour = 0;
-      int is_outline = 1;
+           CONTOURS WITHOUT HAVING TO WALK THE FULL DATA-STRUCTURE LOOKING FOR THEM. */
 
-      anext = a->f;
-      finished = (anext == *pieces);
+  do {
+    int hole_contour = 0;
+    int is_outline = 1;
 
-      prev = NULL;
-      for (curc = a->contours; curc != NULL; curc = next, is_outline = 0)
-	{
-	  int is_first = contour_is_first (a, curc);
-	  int is_last = contour_is_last (curc);
-	  int isect_contour = (curc->Flags.status == ISECTED);
+    anext = a->f;
+    finished = (anext == *pieces);
 
-	  next = curc->next;
+    prev = NULL;
+    for (curc = a->contours; curc != NULL; curc = next, is_outline = 0) {
+      int is_first = contour_is_first (a, curc);
+      int is_last = contour_is_last (curc);
+      int isect_contour = (curc->Flags.status == ISECTED);
 
-	  if (isect_contour || hole_contour)
-	    {
+      next = curc->next;
 
-	      /* Reset the intersection flags, since we keep these pieces */
-	      if (curc->Flags.status != ISECTED)
-		curc->Flags.status = UNKNWN;
+      if (isect_contour || hole_contour) {
 
-	      remove_contour (a, prev, curc, !(is_first && is_last));
+        /* Reset the intersection flags, since we keep these pieces */
+        if (curc->Flags.status != ISECTED)
+          curc->Flags.status = UNKNWN;
 
-	      if (isect_contour)
-		{
-		  /* Link into the list of intersected contours */
-		  curc->next = *isected;
-		  *isected = curc;
-		}
-	      else if (hole_contour)
-		{
-		  /* Link into the list of holes */
-		  curc->next = *holes;
-		  *holes = curc;
-		}
-	      else
-		{
-		  assert (0);
-		}
+        remove_contour (a, prev, curc, !(is_first && is_last));
 
-	      if (is_first && is_last)
-		{
-		  remove_polyarea (pieces, a);
-		  poly_Free (&a);	/* NB: Sets a to NULL */
-		}
+        if (isect_contour) {
+          /* Link into the list of intersected contours */
+          curc->next = *isected;
+          *isected = curc;
+        } else if (hole_contour) {
+          /* Link into the list of holes */
+          curc->next = *holes;
+          *holes = curc;
+        } else {
+          assert (0);
+        }
 
-	    }
-	  else
-	    {
-	      /* Note the item we just didn't delete as the next
-	         candidate for having its "next" pointer adjusted.
-	         Saves walking the contour list when we delete one. */
-	      prev = curc;
-	    }
+        if (is_first && is_last) {
+          remove_polyarea (pieces, a);
+          poly_Free (&a); /* NB: Sets a to NULL */
+        }
 
-	  /* If we move or delete an outer contour, we need to move any holes
-	     we wish to keep within that contour to the holes list. */
-	  if (is_outline && isect_contour)
-	    hole_contour = 1;
+      } else {
+        /* Note the item we just didn't delete as the next
+           candidate for having its "next" pointer adjusted.
+           Saves walking the contour list when we delete one. */
+        prev = curc;
+      }
 
-	}
+      /* If we move or delete an outer contour, we need to move any holes
+         we wish to keep within that contour to the holes list. */
+      if (is_outline && isect_contour)
+        hole_contour = 1;
 
-      /* If we deleted all the pieces of the polyarea, *pieces is NULL */
     }
-  while ((a = anext), *pieces != NULL && !finished);
+
+    /* If we deleted all the pieces of the polyarea, *pieces is NULL */
+  } while ((a = anext), *pieces !=NULL && !finished);
 }
 
 
-struct find_inside_m_pa_info
-{
+struct find_inside_m_pa_info {
   jmp_buf jb;
   POLYAREA *want_inside;
   PLINE *result;
 };
 
 static int
-find_inside_m_pa (const BoxType * b, void *cl)
+find_inside_m_pa (const BoxType *b, void *cl)
 {
   struct find_inside_m_pa_info *info = cl;
   PLINE *check = (PLINE *) b;
@@ -2020,18 +1979,17 @@ find_inside_m_pa (const BoxType * b, void *cl)
   /* Don't look at contours marked as being intersected */
   if (check->Flags.status == ISECTED)
     return 0;
-  if (cntr_in_M_POLYAREA (check, info->want_inside, FALSE))
-    {
-      info->result = check;
-      longjmp (info->jb, 1);
-    }
+  if (cntr_in_M_POLYAREA (check, info->want_inside, FALSE)) {
+    info->result = check;
+    longjmp (info->jb, 1);
+  }
   return 0;
 }
 
 
 static void
 M_POLYAREA_update_primary (jmp_buf * e, POLYAREA ** pieces,
-			   PLINE ** holes, int action, POLYAREA * bpa)
+                           PLINE ** holes, int action, POLYAREA *bpa)
 {
   POLYAREA *a = *pieces;
   POLYAREA *b;
@@ -2046,8 +2004,7 @@ M_POLYAREA_update_primary (jmp_buf * e, POLYAREA ** pieces,
   if (a == NULL)
     return;
 
-  switch (action)
-    {
+  switch (action) {
     case PBO_ISECT:
       del_outside = 1;
       break;
@@ -2055,213 +2012,184 @@ M_POLYAREA_update_primary (jmp_buf * e, POLYAREA ** pieces,
     case PBO_SUB:
       del_inside = 1;
       break;
-    case PBO_XOR:		/* NOT IMPLEMENTED OR USED */
+    case PBO_XOR: /* NOT IMPLEMENTED OR USED */
       inv_inside = 1;
       assert (0);
       break;
-    }
+  }
 
-  box = *((BoxType *) bpa->contours);
+  box = *((BoxType *)bpa->contours);
   b = bpa;
-  while ((b = b->f) != bpa)
-    {
-      BoxType *b_box = (BoxType *) b->contours;
-      MAKEMIN (box.X1, b_box->X1);
-      MAKEMIN (box.Y1, b_box->Y1);
-      MAKEMAX (box.X2, b_box->X2);
-      MAKEMAX (box.Y2, b_box->Y2);
-    }
-
-  if (del_inside)
-    {
-
-      do
-	{
-	  anext = a->f;
-	  finished = (anext == *pieces);
-
-	  /* Test the outer contour first, as we may need to remove all children */
-
-	  /* We've not yet split intersected contours out, just ignore them */
-	  if (a->contours->Flags.status != ISECTED &&
-	      /* Pre-filter on bounding box */
-	      ((a->contours->xmin >= box.X1) && (a->contours->ymin >= box.Y1)
-	       && (a->contours->xmax <= box.X2)
-	       && (a->contours->ymax <= box.Y2)) &&
-	      /* Then test properly */
-	      cntr_in_M_POLYAREA (a->contours, bpa, FALSE))
-	    {
-
-	      /* Delete this contour, all children -> holes queue */
-
-	      /* Delete the outer contour */
-	      curc = a->contours;
-	      remove_contour (a, NULL, curc, FALSE);	/* Rtree deleted in poly_Free below */
-	      /* a->contours now points to the remaining holes */
-	      poly_DelContour (&curc);
-
-	      if (a->contours != NULL)
-		{
-		  /* Find the end of the list of holes */
-		  curc = a->contours;
-		  while (curc->next != NULL)
-		    curc = curc->next;
-
-		  /* Take the holes and prepend to the holes queue */
-		  curc->next = *holes;
-		  *holes = a->contours;
-		  a->contours = NULL;
-		}
-
-	      remove_polyarea (pieces, a);
-	      poly_Free (&a);	/* NB: Sets a to NULL */
-
-	      continue;
-	    }
-
-	  /* Loop whilst we find INSIDE contours to delete */
-	  while (1)
-	    {
-	      struct find_inside_m_pa_info info;
-	      PLINE *prev;
-
-	      info.want_inside = bpa;
-
-	      /* Set jump return */
-	      if (setjmp (info.jb))
-		{
-		  /* Returned here! */
-		}
-	      else
-		{
-		  info.result = NULL;
-		  /* r-tree search, calling back a routine to longjmp back with
-		   * data about any hole inside the B polygon.
-		   * NB: Does not jump back to report the main contour!
-		   */
-		  r_search (a->contour_tree, &box, NULL, find_inside_m_pa,
-			    &info);
-
-		  /* Nothing found? */
-		  break;
-		}
+  while ((b = b->f) != bpa) {
+    BoxType *b_box = (BoxType *)b->contours;
+    MAKEMIN (box.X1, b_box->X1);
+    MAKEMIN (box.Y1, b_box->Y1);
+    MAKEMAX (box.X2, b_box->X2);
+    MAKEMAX (box.Y2, b_box->Y2);
+  }
 
-	      /* We need to find the contour before it, so we can update its next pointer */
-	      prev = a->contours;
-	      while (prev->next != info.result)
-		{
-		  prev = prev->next;
-		}
+  if (del_inside) {
 
-	      /* Remove hole from the contour */
-	      remove_contour (a, prev, info.result, TRUE);
-	      poly_DelContour (&info.result);
-	    }
-	  /* End check for deleted holes */
+    do {
+      anext = a->f;
+      finished = (anext == *pieces);
 
-	  /* If we deleted all the pieces of the polyarea, *pieces is NULL */
-	}
-      while ((a = anext), *pieces != NULL && !finished);
+      /* Test the outer contour first, as we may need to remove all children */
+
+      /* We've not yet split intersected contours out, just ignore them */
+      if (a->contours->Flags.status != ISECTED &&
+          /* Pre-filter on bounding box */
+          ((a->contours->xmin >= box.X1) && (a->contours->ymin >= box.Y1) &&
+           (a->contours->xmax <= box.X2) && (a->contours->ymax <= box.Y2)) &&
+          /* Then test properly */
+          cntr_in_M_POLYAREA (a->contours, bpa, FALSE)) {
+
+        /* Delete this contour, all children -> holes queue */
+
+        /* Delete the outer contour */
+        curc = a->contours;
+        remove_contour (a, NULL, curc, FALSE); /* Rtree deleted in poly_Free below */
+        /* a->contours now points to the remaining holes */
+        poly_DelContour (&curc);
+
+        if (a->contours != NULL) {
+          /* Find the end of the list of holes */
+          curc = a->contours;
+          while (curc->next != NULL)
+            curc = curc->next;
+
+          /* Take the holes and prepend to the holes queue */
+          curc->next = *holes;
+          *holes = a->contours;
+          a->contours = NULL;
+        }
+
+        remove_polyarea (pieces, a);
+        poly_Free (&a); /* NB: Sets a to NULL */
+
+        continue;
+      }
+
+      /* Loop whilst we find INSIDE contours to delete */
+      while (1) {
+        struct find_inside_m_pa_info info;
+        PLINE *prev;
+
+        info.want_inside = bpa;
+
+        /* Set jump return */
+        if (setjmp (info.jb)) {
+          /* Returned here! */
+        } else {
+          info.result = NULL;
+          /* r-tree search, calling back a routine to longjmp back with
+           * data about any hole inside the B polygon.
+           * NB: Does not jump back to report the main contour!
+           */
+          r_search (a->contour_tree, &box, NULL, find_inside_m_pa, &info);
+
+          /* Nothing found? */
+          break;
+        }
+
+        /* We need to find the contour before it, so we can update its next pointer */
+        prev = a->contours;
+        while (prev->next != info.result) {
+          prev = prev->next;
+        }
+
+        /* Remove hole from the contour */
+        remove_contour (a, prev, info.result, TRUE);
+        poly_DelContour (&info.result);
+      }
+      /* End check for deleted holes */
+
+    /* If we deleted all the pieces of the polyarea, *pieces is NULL */
+    } while ((a = anext), *pieces != NULL && !finished);
 
-      return;
-    }
-  else
-    {
-      /* This path isn't optimised for speed */
-    }
+    return;
+  } else {
+    /* This path isn't optimised for speed */
+  }
 
-  do
-    {
-      int hole_contour = 0;
-      int is_outline = 1;
+  do {
+    int hole_contour = 0;
+    int is_outline = 1;
 
-      anext = a->f;
-      finished = (anext == *pieces);
+    anext = a->f;
+    finished = (anext == *pieces);
 
-      prev = NULL;
-      for (curc = a->contours; curc != NULL; curc = next, is_outline = 0)
-	{
-	  int is_first = contour_is_first (a, curc);
-	  int is_last = contour_is_last (curc);
-	  int del_contour = 0;
+    prev = NULL;
+    for (curc = a->contours; curc != NULL; curc = next, is_outline = 0) {
+      int is_first = contour_is_first (a, curc);
+      int is_last = contour_is_last (curc);
+      int del_contour = 0;
 
-	  next = curc->next;
+      next = curc->next;
 
-	  if (del_outside)
-	    del_contour = curc->Flags.status != ISECTED &&
-	      !cntr_in_M_POLYAREA (curc, bpa, FALSE);
+      if (del_outside)
+        del_contour = curc->Flags.status != ISECTED &&
+                     !cntr_in_M_POLYAREA (curc, bpa, FALSE);
 
-	  /* Skip intersected contours */
-	  if (curc->Flags.status == ISECTED)
-	    {
-	      prev = curc;
-	      continue;
-	    }
+      /* Skip intersected contours */
+      if (curc->Flags.status == ISECTED) {
+        prev = curc;
+        continue;
+      }
 
-	  /* Reset the intersection flags, since we keep these pieces */
-	  curc->Flags.status = UNKNWN;
+      /* Reset the intersection flags, since we keep these pieces */
+      curc->Flags.status = UNKNWN;
 
-	  if (del_contour || hole_contour)
-	    {
+      if (del_contour || hole_contour) {
 
-	      remove_contour (a, prev, curc, !(is_first && is_last));
+        remove_contour (a, prev, curc, !(is_first && is_last));
 
-	      if (del_contour)
-		{
-		  /* Delete the contour */
-		  poly_DelContour (&curc);	/* NB: Sets curc to NULL */
-		}
-	      else if (hole_contour)
-		{
-		  /* Link into the list of holes */
-		  curc->next = *holes;
-		  *holes = curc;
-		}
-	      else
-		{
-		  assert (0);
-		}
+        if (del_contour) {
+          /* Delete the contour */
+          poly_DelContour (&curc); /* NB: Sets curc to NULL */
+        } else if (hole_contour) {
+          /* Link into the list of holes */
+          curc->next = *holes;
+          *holes = curc;
+        } else {
+          assert (0);
+        }
 
-	      if (is_first && is_last)
-		{
-		  remove_polyarea (pieces, a);
-		  poly_Free (&a);	/* NB: Sets a to NULL */
-		}
+        if (is_first && is_last) {
+          remove_polyarea (pieces, a);
+          poly_Free (&a); /* NB: Sets a to NULL */
+        }
 
-	    }
-	  else
-	    {
-	      /* Note the item we just didn't delete as the next
-	         candidate for having its "next" pointer adjusted.
-	         Saves walking the contour list when we delete one. */
-	      prev = curc;
-	    }
+      } else {
+        /* Note the item we just didn't delete as the next
+           candidate for having its "next" pointer adjusted.
+           Saves walking the contour list when we delete one. */
+        prev = curc;
+      }
 
-	  /* If we move or delete an outer contour, we need to move any holes
-	     we wish to keep within that contour to the holes list. */
-	  if (is_outline && del_contour)
-	    hole_contour = 1;
+      /* If we move or delete an outer contour, we need to move any holes
+         we wish to keep within that contour to the holes list. */
+      if (is_outline && del_contour)
+        hole_contour = 1;
 
-	}
-
-      /* If we deleted all the pieces of the polyarea, *pieces is NULL */
     }
-  while ((a = anext), *pieces != NULL && !finished);
+
+  /* If we deleted all the pieces of the polyarea, *pieces is NULL */
+  } while ((a = anext), *pieces != NULL && !finished);
 }
 
 static void
 M_POLYAREA_Collect_separated (jmp_buf * e, PLINE * afst, POLYAREA ** contours,
-			      PLINE ** holes, int action, BOOLp maybe)
+                              PLINE ** holes, int action, BOOLp maybe)
 {
   PLINE **cur, **next;
 
-  for (cur = &afst; *cur != NULL; cur = next)
-    {
-      next = &((*cur)->next);
-      /* if we disappear a contour, don't advance twice */
-      if (cntr_Collect (e, cur, contours, holes, action, NULL, NULL, NULL))
-	next = cur;
-    }
+  for (cur = &afst; *cur != NULL; cur = next) {
+    next = &((*cur)->next);
+    /* if we disappear a contour, don't advance twice */
+    if (cntr_Collect (e, cur, contours, holes, action, NULL, NULL, NULL))
+      next = cur;
+  }
 }
 
 static void
@@ -2269,7 +2197,7 @@ M_POLYAREA_Collect (jmp_buf * e, POLYAREA * afst, POLYAREA ** contours,
 		    PLINE ** holes, int action, BOOLp maybe)
 {
   POLYAREA *a = afst;
-  POLYAREA *parent = NULL;	/* Quiet compiler warning */
+  POLYAREA *parent = NULL; /* Quiet compiler warning */
   PLINE **cur, **next, *parent_contour;
 
   assert (a != NULL);
@@ -2278,35 +2206,35 @@ M_POLYAREA_Collect (jmp_buf * e, POLYAREA * afst, POLYAREA ** contours,
   do
     {
       if (maybe && a->contours->Flags.status != ISECTED)
-	parent_contour = a->contours;
+          parent_contour = a->contours;
       else
-	parent_contour = NULL;
+          parent_contour = NULL;
 
       /* Take care of the first contour - so we know if we
        * can shortcut reparenting some of its children
        */
       cur = &a->contours;
       if (*cur != NULL)
-	{
-	  next = &((*cur)->next);
-	  /* if we disappear a contour, don't advance twice */
-	  if (cntr_Collect (e, cur, contours, holes, action, a, NULL, NULL))
-	    {
-	      parent = (*contours)->b;	/* InsCntr inserts behind the head */
-	      next = cur;
-	    }
-	  else
-	    parent = a;
-	  cur = next;
-	}
-      for (; *cur != NULL; cur = next)
-	{
-	  next = &((*cur)->next);
-	  /* if we disappear a contour, don't advance twice */
-	  if (cntr_Collect (e, cur, contours, holes, action, a, parent,
-			    parent_contour))
-	    next = cur;
-	}
+        {
+          next = &((*cur)->next);
+          /* if we disappear a contour, don't advance twice */
+          if (cntr_Collect (e, cur, contours, holes, action, a, NULL, NULL))
+            {
+              parent = (*contours)->b; /* InsCntr inserts behind the head */
+              next = cur;
+            }
+          else
+            parent = a;
+          cur = next;
+        }
+      for ( ; *cur != NULL; cur = next)
+        {
+          next = &((*cur)->next);
+          /* if we disappear a contour, don't advance twice */
+          if (cntr_Collect (e, cur, contours, holes, action, a, parent,
+                            parent_contour))
+            next = cur;
+        }
     }
   while ((a = a->f) != afst);
 }
@@ -2412,17 +2340,16 @@ poly_Boolean_free (POLYAREA * ai, POLYAREA * bi, POLYAREA ** res, int action)
       M_POLYAREA_update_primary (&e, res, &holes, action, b);
       M_POLYAREA_separate_isected (&e, res, &holes, &a_isected);
       M_POLYAREA_label_separated (a_isected, b, FALSE);
-      M_POLYAREA_Collect_separated (&e, a_isected, res, &holes, action,
-				    FALSE);
+      M_POLYAREA_Collect_separated (&e, a_isected, res, &holes, action, FALSE);
       M_B_AREA_Collect (&e, b, res, &holes, action);
       poly_Free (&b);
 
       /* free a_isected */
       while ((p = a_isected) != NULL)
-	{
-	  a_isected = p->next;
-	  poly_DelContour (&p);
-	}
+      {
+        a_isected = p->next;
+        poly_DelContour (&p);
+      }
 
       InsertHoles (&e, *res, &holes);
     }
@@ -2617,10 +2544,10 @@ poly_DelContour (PLINE ** c)
     {
       prev = cur->prev;
       if (cur->cvc_next != NULL)
-	{
-	  free (cur->cvc_next);
-	  free (cur->cvc_prev);
-	}
+        {
+          free (cur->cvc_next);
+          free (cur->cvc_prev);
+        }
       free (cur);
     }
   if ((*c)->head.cvc_next != NULL)
@@ -2818,7 +2745,7 @@ poly_Copy1 (POLYAREA * dst, const POLYAREA * src)
     {
       if (!poly_CopyContour (last, cur))
 	return FALSE;
-      r_insert_entry (dst->contour_tree, (BoxTypePtr) * last, 0);
+      r_insert_entry (dst->contour_tree, (BoxTypePtr) *last, 0);
       last = &(*last)->next;
     }
   return TRUE;
@@ -3017,7 +2944,7 @@ poly_Create (void)
 }
 
 void
-poly_FreeContours (PLINE ** pline)
+poly_FreeContours (PLINE **pline)
 {
   PLINE *pl;

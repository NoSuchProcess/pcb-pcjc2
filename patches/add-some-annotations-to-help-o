Bottom: f92a4a392c31b6b1e249da16c44f06d492a4d932
Top:    74b44e48b2e266a5bc29dad021f51c967db03588
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-02-10 13:20:43 +0000

Add some annotations to help optimise branch prediction.

Macros G_LIKELY and G_UNLIKELY were taken from GLib (LGPL 2), and
renamed without the G_ prefix.

This hasn't had much discernable effect












---

diff --git a/src/polygon1.c b/src/polygon1.c
index 7eabb81..5fb701d 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -764,121 +764,92 @@ contour_bounds_touch (const BoxType * b, void *cl)
       looping_over = pa;
     }
   else
-    {
-      rtree_over   = pa;
-      looping_over = pb;
-    }
-
-  av = &looping_over->head;
-  do  /* Loop over the nodes in the smaller contour */
-    {
-      /* check this edge for any insertions */
-      double dx;
-      info.v = av;
-      /* compute the slant for region trimming */
-      dx = av->next->point[0] - av->point[0];
-      if (dx == 0)
-        info.m = 0;
-      else
-        {
-          info.m = (av->next->point[1] - av->point[1]) / dx;
-          info.b = av->point[1] - info.m * av->point[0];
-        }
-      box.X2 = (box.X1 = av->point[0]) + 1;
-      box.Y2 = (box.Y1 = av->point[1]) + 1;
-
-      /* fill in the segment in info corresponding to this node */
-      if (setjmp (info.sego) == 0)
-        {
-          r_search ((rtree_t *) (looping_over->tree), &box, NULL, get_seg, &info);
-          assert (0);
-        }
-
-        /* NB: If this actually hits anything, we are teleported back to the beginning */
-        info.tree = (rtree_t *) rtree_over->tree;
-        if (info.tree)
-          if (UNLIKELY (r_search (info.tree, &info.s->box,
-                                  seg_in_region, seg_in_seg, &info)))
-            return err_no_memory;	/* error */
-    }
-  while ((av = av->next) != &looping_over->head);
-  return 0;
-}
-
-static int
-intersect (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
-{
-  POLYAREA *t;
-  PLINE *pa, *pb;
-  int ca = 0, cb = 0;
-  contour_info c_info;
-  rtree_t *b_contour_tree = NULL;
-
-  /* count the contours in a and b */
-  for (pa = a->contours; pa; pa = pa->next, ca++);
-  for (pb = b->contours; pb; pb = pb->next, cb++);
-
-  /* Make the contour r-tree from the one with fewest contours */
-  /* Inserting entries is more expensive than searching
-   * the r-tree. We do one ca times, the other cb times. */
-  if (ca < cb)
-    {
-      t = b;
-      b = a;
-      a = t;
-    }
-
-#if 0
-  setjmp (c_info.restart);		/* we loop back here whenever a vertex is inserted */
-
-  /* Since we may have already executed the function body already, we need to clean up */
-  if (b_contour_tree != NULL)
-    r_destroy_tree (&b_contour_tree);
-#endif
-
-  /* make an rtree of b's contours */
-  b_contour_tree = r_create_tree (NULL, 0, 0);
-  for (pb = b->contours; pb != NULL; pb = pb->next)
-    r_insert_entry (b_contour_tree, (const BoxType *) pb, 0);
-
-#if 1
-#warning We might actually need to re-build the r_tree if the geometry changes
-  setjmp (c_info.restart);		/* we loop back here whenever a vertex is inserted */
-#endif
-
-//  printf ("Done making r-tree of b's contours\n");
-
-  for (pa = a->contours; pa; pa = pa->next)     /* Loop over the contours of POLYAREA "a" */
-    {
-      BoxType sb;
-      jmp_buf out;
-      int retval;
-
-      c_info.getout = NULL;
-      c_info.pa = pa;
-
-      if (!add)
-        {
-          retval = setjmp (out);
-          if (retval)
-            {
-              /* The intersection test short-circuited back here,
-               * we need to clean up, then longjmp to jb */
-//                printf ("short circuited here\n");
-              r_destroy_tree (&b_contour_tree);
-              longjmp (*jb, retval);
-            }
-          c_info.getout = &out;
-        }
-
-      sb.X1 = pa->xmin;
-      sb.Y1 = pa->ymin;
-      sb.X2 = pa->xmax + 1;
-      sb.Y2 = pa->ymax + 1;
-
-      r_search ((rtree_t *) (b_contour_tree), &sb, NULL, contour_bounds_touch, &c_info);
-    }
-
+    info.touch = jb;
+  setjmp (info.env);		/* we loop back here whenever a vertex is inserted */
+  {
+    pa = a->contours;
+    pb = b->contours;
+    while (pa)     /* Loop over the contours of POLYAREA "a" */
+      {
+        int found_overlapping_a_b_contour = FALSE;
+
+        while (pb) /* Loop over the contours of POLYAREA "b" */
+          {
+            /* Are there overlapping bounds? */
+            if (pb->xmin <= pa->xmax && pb->xmax >= pa->xmin &&
+                pb->ymin <= pa->ymax && pb->ymax >= pa->ymin)
+              {
+                found_overlapping_a_b_contour = TRUE;
+                break;
+              }
+            pb = pb->next;
+          }
+
+        /* If we didn't find anything intersting, move onto the next "a" contour */
+        if (!found_overlapping_a_b_contour)
+          {
+            pa = pa->next;
+            pb = b->contours;
+            continue;
+          }
+
+        /* something intersects so check the edges of the contour */
+
+        /* Pick which contour has the fewer points, and do the loop
+         * over that. The r_tree makes hit-testing against a contour
+         * faster, so we want to do that on the bigger contour.
+         */
+        if (pa->Count < pb->Count)
+          {
+            rtree_over   = pb;
+            looping_over = pa;
+          }
+        else
+          {
+            rtree_over   = pa;
+            looping_over = pb;
+          }
+
+        av = &looping_over->head;
+        do  /* Loop over the nodes in the smaller contour */
+          {
+            /* check this edge for any insertions */
+            double dx;
+            info.v = av;
+            /* compute the slant for region trimming */
+            dx = av->next->point[0] - av->point[0];
+            if (dx == 0)
+              info.m = 0;
+            else
+              {
+                info.m = (av->next->point[1] - av->point[1]) / dx;
+                info.b = av->point[1] - info.m * av->point[0];
+              }
+            box.X2 = (box.X1 = av->point[0]) + 1;
+            box.Y2 = (box.Y1 = av->point[1]) + 1;
+
+            /* fill in the segment in info corresponding to this node */
+            if (setjmp (info.sego) == 0)
+              {
+                r_search ((rtree_t *) (looping_over->tree), &box, NULL, get_seg, &info);
+                assert (0);
+              }
+
+              /* NB: If this actually hits anything, we are teleported back to the beginning */
+              info.tree = (rtree_t *) rtree_over->tree;
+              if (info.tree)
+                if (UNLIKELY (r_search (info.tree, &info.s->box,
+                                        seg_in_region, seg_in_seg, &info)))
+                  return err_no_memory;	/* error */
+          }
+        while ((av = av->next) != &looping_over->head);
+
+        /* Continue the with the _same_ "a" contour,
+         * testing it against the next "b" contour.
+         */
+        pb = pb->next;
+      }
+  }				/* end of setjmp loop */
   return 0;
 }

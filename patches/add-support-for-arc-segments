Bottom: ee553f29278b58f13870ec74d19708de73c99444
Top:    c129eab31243f1e259ee91e8c4463178b28b9918
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2014-06-13 01:22:11 +0100

Add support for arc segments in polygon object outline definitions

Test with a polygon like this:

  Polygon("clearpoly")
  (
    [5.0000mm 7.0000mm included_angle: 90] [7.0000mm 5.0000mm]
    [28.000mm 5.0000mm included_angle: 90] [30.000mm 7.0000mm]
    [30.000mm 28.000mm included_angle: 90] [28.000mm 30.000mm]
    [7.0000mm 30.000mm included_angle: 90] [5.0000mm 28.000mm]
  )


NOTE THAT THE ARC BOUNDS ARE NOT YET INCLUDED IN THE BOUNDING BOX CALCULATION,
SO THIS WILL BREAK VARIOUS THINGS PRETTY HORRIBLY IF AN ARC PROTRUDES AS AN
EXTREME FEATURE IN EITHER THE +/-X or +/-Y DIRECTIONS.


---

diff --git a/src/action.c b/src/action.c
index 5d2b4df..184cefa 100644
--- a/src/action.c
+++ b/src/action.c
@@ -1428,7 +1428,8 @@ NotifyMode (void)
 	  {
 	    CreateNewPointInPolygon (&Crosshair.AttachedPolygon,
 				     Crosshair.AttachedLine.Point2.X,
-				     Crosshair.AttachedLine.Point2.Y);
+				     Crosshair.AttachedLine.Point2.Y,
+				     0);
 
 	    /* copy the coordinates */
 	    Crosshair.AttachedLine.Point1.X = Crosshair.AttachedLine.Point2.X;
@@ -1519,7 +1520,8 @@ NotifyMode (void)
 		{
 		  CreateNewPointInPolygon (&Crosshair.AttachedPolygon,
 					   Crosshair.AttachedLine.Point2.X,
-					   Crosshair.AttachedLine.Point2.Y);
+					   Crosshair.AttachedLine.Point2.Y,
+					   0);
 
 		  /* copy the coordinates */
 		  Crosshair.AttachedLine.Point1.X = Crosshair.AttachedLine.Point2.X;
diff --git a/src/copy.c b/src/copy.c
index b0cd9c8..a580e8e 100644
--- a/src/copy.c
+++ b/src/copy.c
@@ -101,7 +101,7 @@ CopyPolygonLowLevel (PolygonType *Dest, PolygonType *Src)
           CreateNewHoleInPolygon (Dest);
           hole++;
         }
-      CreateNewPointInPolygon (Dest, Src->Points[n].X, Src->Points[n].Y);
+      CreateNewPointInPolygon (Dest, Src->Points[n].X, Src->Points[n].Y, Src->Points[n].included_angle);
     }
   SetPolygonBoundingBox (Dest);
   Dest->Flags = Src->Flags;
diff --git a/src/create.c b/src/create.c
index a1c8867..64a22ec 100644
--- a/src/create.c
+++ b/src/create.c
@@ -576,10 +576,10 @@ CreateNewPolygonFromRectangle (LayerType *Layer,
   if (!polygon)
     return (polygon);
 
-  CreateNewPointInPolygon (polygon, X1, Y1);
-  CreateNewPointInPolygon (polygon, X2, Y1);
-  CreateNewPointInPolygon (polygon, X2, Y2);
-  CreateNewPointInPolygon (polygon, X1, Y2);
+  CreateNewPointInPolygon (polygon, X1, Y1, 0);
+  CreateNewPointInPolygon (polygon, X2, Y1, 0);
+  CreateNewPointInPolygon (polygon, X2, Y2, 0);
+  CreateNewPointInPolygon (polygon, X1, Y2, 0);
   SetPolygonBoundingBox (polygon);
   if (!Layer->polygon_tree)
     Layer->polygon_tree = r_create_tree (NULL, 0, 0);
@@ -644,13 +644,14 @@ CreateNewPolygon (LayerType *Layer, FlagType Flags)
  * creates a new point in a polygon
  */
 PointType *
-CreateNewPointInPolygon (PolygonType *Polygon, Coord X, Coord Y)
+CreateNewPointInPolygon (PolygonType *Polygon, Coord X, Coord Y, Angle included_angle)
 {
   PointType *point = GetPointMemoryInPolygon (Polygon);
 
   /* copy values */
   point->X = X;
   point->Y = Y;
+  point->included_angle = included_angle;
   point->ID = ID++;
   return (point);
 }
diff --git a/src/create.h b/src/create.h
index fa49a1b..5b6cfdd 100644
--- a/src/create.h
+++ b/src/create.h
@@ -51,7 +51,7 @@ ArcType * CreateNewArcOnLayer (LayerType *, Coord, Coord, Coord, Coord, Angle, A
 PolygonType * CreateNewPolygonFromRectangle (LayerType *, Coord, Coord, Coord, Coord, FlagType);
 TextType * CreateNewText (LayerType *, FontType *, Coord, Coord, unsigned, int, char *, FlagType);
 PolygonType * CreateNewPolygon (LayerType *, FlagType);
-PointType * CreateNewPointInPolygon (PolygonType *, Coord, Coord);
+PointType * CreateNewPointInPolygon (PolygonType *, Coord, Coord, Angle included_angle);
 PolygonType * CreateNewHoleInPolygon (PolygonType *polygon);
 void RefdesMapInit (void);
 ElementType * CreateNewElement (DataType *, FontType *, FlagType, char *, char *, char *, Coord, Coord, BYTE, int, FlagType, bool);
diff --git a/src/global.h b/src/global.h
index 8a0d6ee..6e4bd9c 100644
--- a/src/global.h
+++ b/src/global.h
@@ -236,8 +236,10 @@ typedef struct			/* a line/polygon point */
 {
   Coord X, Y, X2, Y2;	/* so Point type can be cast as BoxType */
   long int ID;
+  Angle included_angle;
 } PointType;
 
+
 /* Lines, rats, pads, etc.  */
 typedef struct {
   ANYLINEFIELDS;
diff --git a/src/insert.c b/src/insert.c
index a254998..8868d8b 100644
--- a/src/insert.c
+++ b/src/insert.c
@@ -180,7 +180,7 @@ InsertPointIntoPolygon (LayerType *Layer, PolygonType *Polygon)
    */
   ErasePolygon (Polygon);
   r_delete_entry (Layer->polygon_tree, (BoxType *) Polygon);
-  save = *CreateNewPointInPolygon (Polygon, InsertX, InsertY);
+  save = *CreateNewPointInPolygon (Polygon, InsertX, InsertY, 0);
   for (n = Polygon->PointN - 1; n > InsertAt; n--)
     Polygon->Points[n] = Polygon->Points[n - 1];
 
diff --git a/src/parse_l.l b/src/parse_l.l
index 4f64880..a4e0a05 100644
--- a/src/parse_l.l
+++ b/src/parse_l.l
@@ -123,6 +123,7 @@ Groups		{ return(T_GROUPS); }
 Styles		{ return(T_STYLES); }
 Polygon		{ return(T_POLYGON); }
 Hole		{ return(T_POLYGON_HOLE); }
+included_angle: { return(T_INCLUDED_ANGLE); }
 Arc		{ return(T_ARC); }
 NetList		{ return(T_NETLIST); }
 Net		{ return(T_NET); }
diff --git a/src/parse_y.y b/src/parse_y.y
index 6cd4c7b..a82eb5b 100644
--- a/src/parse_y.y
+++ b/src/parse_y.y
@@ -119,7 +119,7 @@ static Coord new_units (PLMeasure m);
 
 %token	T_FILEVERSION T_PCB T_LAYER T_VIA T_RAT T_LINE T_ARC T_RECTANGLE T_TEXT T_ELEMENTLINE
 %token	T_ELEMENT T_PIN T_PAD T_GRID T_FLAGS T_SYMBOL T_SYMBOLLINE T_CURSOR
-%token	T_ELEMENTARC T_MARK T_GROUPS T_STYLES T_POLYGON T_POLYGON_HOLE T_NETLIST T_NET T_CONN
+%token	T_ELEMENTARC T_MARK T_GROUPS T_STYLES T_POLYGON T_POLYGON_HOLE T_INCLUDED_ANGLE T_NETLIST T_NET T_CONN
 %token	T_AREA T_THERMAL T_DRC T_ATTRIBUTE
 %token	T_UMIL T_CMIL T_MIL T_IN T_NM T_UM T_MM T_M T_KM T_PX
 %type	<integer>	symbolid
@@ -1184,11 +1184,15 @@ polygonpoint
 			/* xcoord ycoord */
 		: '(' measure measure ')'
 			{
-				CreateNewPointInPolygon(Polygon, OU ($2), OU ($3));
+				CreateNewPointInPolygon(Polygon, OU ($2), OU ($3), 0);
 			}
 		| '[' measure measure ']'
 			{
-				CreateNewPointInPolygon(Polygon, NU ($2), NU ($3));
+				CreateNewPointInPolygon(Polygon, NU ($2), NU ($3), 0);
+			}
+		| '[' measure measure T_INCLUDED_ANGLE measure ']'
+			{
+				CreateNewPointInPolygon(Polygon, NU ($2), NU ($3), NU ($5));
 			}
 		;
 
diff --git a/src/polygon.c b/src/polygon.c
index 4623b52..013b6aa 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -303,6 +303,8 @@ original_poly (PolygonType * p)
           poly_InclVertex (contour->head.prev, poly_CreateNode (v));
         }
 
+      frac_circle (..);
+
       /* Is current point last in contour? If so process it. */
       if (n == p->PointN - 1 ||
           (hole < p->HoleIndexN && n == p->HoleIndex[hole] - 1))
@@ -1837,9 +1839,9 @@ MorphPolygon (LayerType *layer, PolygonType *poly)
             return false;
           many = true;
           v = &p->contours->head;
-          CreateNewPointInPolygon (newone, v->point[0], v->point[1]);
+          CreateNewPointInPolygon (newone, v->point[0], v->point[1], 0);
           for (v = v->next; v != &p->contours->head; v = v->next)
-            CreateNewPointInPolygon (newone, v->point[0], v->point[1]);
+            CreateNewPointInPolygon (newone, v->point[0], v->point[1], 0);
           newone->BoundingBox.X1 = p->contours->xmin;
           newone->BoundingBox.X2 = p->contours->xmax + 1;
           newone->BoundingBox.Y1 = p->contours->ymin;
@@ -1951,7 +1953,8 @@ PolyToPolygonsOnLayer (DataType *Destination, LayerType *Layer,
           do
             {
               CreateNewPointInPolygon (Polygon, node->point[0],
-                                                node->point[1]);
+                                                node->point[1],
+                                                0);
             }
           while ((node = node->next) != &pline->head);

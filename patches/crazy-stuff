Bottom: e0d80c7c3275af70212a64eab77d6584d71f746a
Top:    d2aa94fb9237205488b30f5087ed8a076403f679
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-09-09 14:17:31 +0100

Crazy stuff


---

diff --git a/src/action.c b/src/action.c
index 58c8580..2738bee 100644
--- a/src/action.c
+++ b/src/action.c
@@ -1396,7 +1396,7 @@ NotifyMode (void)
 		int flag = NOFLAG;
 
 		if (GetLayerGroupNumberByNumber (INDEXOFCURRENT) ==
-		    GetLayerGroupNumberByNumber (max_layer + SOLDER_LAYER))
+		    GetLayerGroupNumberByNumber (solder_silk_layer))
 		  flag = ONSOLDERFLAG;
 		if ((text = CreateNewText (CURRENT, &PCB->Font, Note.X,
 					   Note.Y, 0, Settings.TextScale,
@@ -8003,7 +8003,7 @@ ActionAttributes (int argc, char **argv, int x, int y)
 	  {
 	    int i;
 	    layer = NULL;
-	    for (i=0; i<max_layer; i++)
+	    for (i=0; i<max_copper_layer; i++)
 	      if (strcmp (PCB->Data->Layer[i].Name, layername) == 0)
 		{
 		  layer = & (PCB->Data->Layer[i]);
diff --git a/src/autoplace.c b/src/autoplace.c
index 2572755..ed2014a 100644
--- a/src/autoplace.c
+++ b/src/autoplace.c
@@ -158,8 +158,8 @@ UpdateXY (NetListTypePtr Nets)
   Cardinal SLayer, CLayer;
   Cardinal i, j;
   /* find layer groups of the component side and solder side */
-  SLayer = GetLayerGroupNumberByNumber (max_layer + SOLDER_LAYER);
-  CLayer = GetLayerGroupNumberByNumber (max_layer + COMPONENT_LAYER);
+  SLayer = GetLayerGroupNumberByNumber (solder_silk_layer);
+  CLayer = GetLayerGroupNumberByNumber (component_silk_layer);
   /* update all nets */
   for (i = 0; i < Nets->NetN; i++)
     {
@@ -214,7 +214,7 @@ static void
 showboxes (BoxListTypePtr blist)
 {
   Cardinal i;
-  LayerTypePtr SLayer = &(PCB->Data->Layer[max_layer + SOLDER_LAYER]);
+  LayerTypePtr SLayer = &(PCB->Data->Layer[solder_silk_layer]);
   for (i = 0; i < blist->BoxN; i++)
     {
       CreateNewLineOnLayer (SLayer, blist->Box[i].X1, blist->Box[i].Y1,
diff --git a/src/autoroute.c b/src/autoroute.c
index 3361f79..a25a327 100644
--- a/src/autoroute.c
+++ b/src/autoroute.c
@@ -404,7 +404,7 @@ static int total_via_count = 0;
 static int
 __routebox_is_good (routebox_t * rb)
 {
-  assert (rb && (rb->group < max_layer) &&
+  assert (rb && (rb->group < max_group) &&
 	  (rb->box.X1 <= rb->box.X2) && (rb->box.Y1 <= rb->box.Y2) &&
 	  (rb->flags.homeless ?
 	   (rb->box.X1 != rb->box.X2) || (rb->box.Y1 != rb->box.Y2) :
@@ -606,7 +606,7 @@ AddPin (PointerListType layergroupboxes[], PinTypePtr pin, bool is_via,
   routebox_t **rbpp, *lastrb = NULL;
   int i, ht;
   /* a pin cuts through every layer group */
-  for (i = 0; i < max_layer; i++)
+  for (i = 0; i < max_group; i++)
     {
       rbpp = (routebox_t **) GetPointerMemory (&layergroupboxes[i]);
       *rbpp = malloc (sizeof (**rbpp));
@@ -653,7 +653,7 @@ AddPad (PointerListType layergroupboxes[],
   BDimension halfthick;
   routebox_t **rbpp;
   int layergroup = (TEST_FLAG (ONSOLDERFLAG, pad) ? back : front);
-  assert (0 <= layergroup && layergroup < max_layer);
+  assert (0 <= layergroup && layergroup < max_group);
   assert (PCB->LayerGroups.Number[layergroup] > 0);
   rbpp = (routebox_t **) GetPointerMemory (&layergroupboxes[layergroup]);
   assert (rbpp);
@@ -687,7 +687,7 @@ AddLine (PointerListType layergroupboxes[], int layergroup, LineTypePtr line,
 {
   routebox_t **rbpp;
   assert (layergroupboxes && line);
-  assert (0 <= layergroup && layergroup < max_layer);
+  assert (0 <= layergroup && layergroup < max_group);
   assert (PCB->LayerGroups.Number[layergroup] > 0);
 
   rbpp = (routebox_t **) GetPointerMemory (&layergroupboxes[layergroup]);
@@ -735,7 +735,7 @@ AddIrregularObstacle (PointerListType layergroupboxes[],
   LocationType keep = style->Keepaway;
   assert (layergroupboxes && parent);
   assert (X1 <= X2 && Y1 <= Y2);
-  assert (0 <= layergroup && layergroup < max_layer);
+  assert (0 <= layergroup && layergroup < max_group);
   assert (PCB->LayerGroups.Number[layergroup] > 0);
 
   rbpp = (routebox_t **) GetPointerMemory (&layergroupboxes[layergroup]);
@@ -760,7 +760,7 @@ AddPolygon (PointerListType layergroupboxes[], Cardinal layer,
   int is_not_rectangle = 1;
   int layergroup = GetLayerGroupNumberByNumber (layer);
   routebox_t *rb;
-  assert (0 <= layergroup && layergroup < max_layer);
+  assert (0 <= layergroup && layergroup < max_group);
   rb = AddIrregularObstacle (layergroupboxes,
 			     polygon->BoundingBox.X1,
 			     polygon->BoundingBox.Y1,
@@ -904,11 +904,11 @@ CreateRouteData ()
 
   /* check which layers are active first */
   routing_layers = 0;
-  for (group = 0; group < max_layer; group++)
+  for (group = 0; group < max_group; group++)
     {
       for (i = 0; i < PCB->LayerGroups.Number[group]; i++)
-	/* layer must be 1) not silk (ie, < max_layer) and 2) on */
-	if ((PCB->LayerGroups.Entries[group][i] < max_layer) &&
+	/* layer must be 1) not silk (ie, < max_copper_layer) and 2) on */
+	if ((PCB->LayerGroups.Entries[group][i] < max_copper_layer) &&
 	    PCB->Data->Layer[PCB->LayerGroups.Entries[group][i]].On)
 	  {
 	    routing_layers++;
@@ -920,10 +920,10 @@ CreateRouteData ()
     }
   /* if via visibility is turned off, don't use them */
   AutoRouteParameters.use_vias = routing_layers > 1 && PCB->ViaOn;
-  front = GetLayerGroupNumberByNumber (max_layer + COMPONENT_LAYER);
-  back = GetLayerGroupNumberByNumber (max_layer + SOLDER_LAYER);
+  front = GetLayerGroupNumberByNumber (component_silk_layer);
+  back = GetLayerGroupNumberByNumber (solder_silk_layer);
   /* determine preferred routing direction on each group */
-  for (i = 0; i < max_layer; i++)
+  for (i = 0; i < max_group; i++)
     {
       if (i != back && i != front)
 	{
@@ -963,7 +963,7 @@ CreateRouteData ()
     }
 
   /* initialize pointerlisttype */
-  for (i = 0; i < max_layer; i++)
+  for (i = 0; i < max_group; i++)
     {
       layergroupboxes[i].Ptr = NULL;
       layergroupboxes[i].PtrN = 0;
@@ -1137,7 +1137,7 @@ CreateRouteData ()
   }
   END_LOOP;
 
-  for (i = 0; i < max_layer; i++)
+  for (i = 0; i < max_copper_layer; i++)
     {
       int layergroup = GetLayerGroupNumberByNumber (i);
       /* add all (non-rat) lines */
@@ -1206,7 +1206,7 @@ CreateRouteData ()
     }
 
   /* create r-trees from pointer lists */
-  for (i = 0; i < max_layer; i++)
+  for (i = 0; i < max_group; i++)
     {
       /* create the r-tree */
       rd->layergrouptree[i] =
@@ -1220,7 +1220,7 @@ CreateRouteData ()
 
       /* create "empty-space" structures for via placement (now that we know
        * appropriate keepaways for all the fixed elements) */
-      for (i = 0; i < max_layer; i++)
+      for (i = 0; i < max_group; i++)
 	{
 	  POINTER_LOOP (&layergroupboxes[i]);
 	  {
@@ -1232,7 +1232,7 @@ CreateRouteData ()
 	}
     }
   /* free pointer lists */
-  for (i = 0; i < max_layer; i++)
+  for (i = 0; i < max_group; i++)
     FreePointerListMemory (&layergroupboxes[i]);
   /* done! */
   return rd;
@@ -1242,7 +1242,7 @@ void
 DestroyRouteData (routedata_t ** rd)
 {
   int i;
-  for (i = 0; i < max_layer; i++)
+  for (i = 0; i < max_group; i++)
     r_destroy_tree (&(*rd)->layergrouptree[i]);
   if (AutoRouteParameters.use_vias)
     mtspace_destroy (&(*rd)->mtspace);
@@ -1385,7 +1385,7 @@ cost_to_routebox (const CheapPointType * p, Cardinal point_layer,
   if ((p2.X - p->X) * (p2.Y - p->Y) != 0)
     trial += AutoRouteParameters.JogPenalty;
   /* special case for defered via searching */
-  if (point_layer > max_layer || point_layer == rb->group)
+  if (point_layer > max_group || point_layer == rb->group)
     return trial + ABS (p2.X - p->X) + ABS (p2.Y - p->Y);
   /* if this target is only a via away, then the via is cheaper than the congestion */
   if (p->X == p2.X && p->Y == p2.Y)
@@ -1454,34 +1454,34 @@ showbox (BoxType b, Dimension thickness, int group)
 #if 1
   if (b.Y1 == b.Y2 || b.X1 == b.X2)
     thickness = 5;
-  line = CreateNewLineOnLayer (LAYER_PTR (max_layer + COMPONENT_LAYER),
+  line = CreateNewLineOnLayer (LAYER_PTR (component_silk_layer),
 			       b.X1, b.Y1, b.X2, b.Y1, thickness, 0,
 			       MakeFlags (0));
   AddObjectToCreateUndoList (LINE_TYPE,
-			     LAYER_PTR (max_layer + COMPONENT_LAYER), line,
+			     LAYER_PTR (component_silk_layer), line,
 			     line);
   if (b.Y1 != b.Y2)
     {
-      line = CreateNewLineOnLayer (LAYER_PTR (max_layer + COMPONENT_LAYER),
+      line = CreateNewLineOnLayer (LAYER_PTR (component_silk_layer),
 				   b.X1, b.Y2, b.X2, b.Y2, thickness, 0,
 				   MakeFlags (0));
       AddObjectToCreateUndoList (LINE_TYPE,
-				 LAYER_PTR (max_layer + COMPONENT_LAYER),
+				 LAYER_PTR (component_silk_layer),
 				 line, line);
     }
-  line = CreateNewLineOnLayer (LAYER_PTR (max_layer + COMPONENT_LAYER),
+  line = CreateNewLineOnLayer (LAYER_PTR (component_silk_layer),
 			       b.X1, b.Y1, b.X1, b.Y2, thickness, 0,
 			       MakeFlags (0));
   AddObjectToCreateUndoList (LINE_TYPE,
-			     LAYER_PTR (max_layer + COMPONENT_LAYER), line,
+			     LAYER_PTR (component_silk_layer), line,
 			     line);
   if (b.X1 != b.X2)
     {
-      line = CreateNewLineOnLayer (LAYER_PTR (max_layer + COMPONENT_LAYER),
+      line = CreateNewLineOnLayer (LAYER_PTR (component_silk_layer),
 				   b.X2, b.Y1, b.X2, b.Y2, thickness, 0,
 				   MakeFlags (0));
       AddObjectToCreateUndoList (LINE_TYPE,
-				 LAYER_PTR (max_layer + COMPONENT_LAYER),
+				 LAYER_PTR (component_silk_layer),
 				 line, line);
     }
 #endif
@@ -1525,7 +1525,7 @@ static void
 showroutebox (routebox_t * rb)
 {
   showbox (rb->sbox, rb->flags.source ? 20 : (rb->flags.target ? 10 : 1),
-	   rb->flags.is_via ? max_layer + COMPONENT_LAYER : rb->group);
+	   rb->flags.is_via ? component_silk_layer : rb->group);
 }
 #endif
 
@@ -3202,7 +3202,7 @@ RD_DrawVia (routedata_t * rd, LocationType X, LocationType Y,
   int ka = AutoRouteParameters.style->Keepaway;
 
   /* a via cuts through every layer group */
-  for (i = 0; i < max_layer; i++)
+  for (i = 0; i < max_group; i++)
     {
       if (!is_layer_group_active[i])
 	continue;
@@ -3833,7 +3833,7 @@ do_via_search (edge_t * search, struct routeone_state *s,
 	  free (area);
 	  assert (box_is_good (&cliparea));
 	  count++;
-	  for (j = 0; j < max_layer; j++)
+	  for (j = 0; j < max_group; j++)
 	    {
 	      edge_t *ne;
 	      if (j == within->group || !is_layer_group_active[j])
@@ -4560,7 +4560,7 @@ InitAutoRouteParameters (int pass,
   AutoRouteParameters.JogPenalty = 1000 * (is_smoothing ? 20 : 4);
   AutoRouteParameters.CongestionPenalty = 1e6;
   AutoRouteParameters.MinPenalty = EXPENSIVE;
-  for (i = 0; i < max_layer; i++)
+  for (i = 0; i < max_group; i++)
     {
       if (is_layer_group_active[i])
 	{
@@ -4602,7 +4602,7 @@ no_expansion_boxes (routedata_t * rd)
   big.X2 = MAX_COORD;
   big.Y1 = 0;
   big.Y2 = MAX_COORD;
-  for (i = 0; i < max_layer; i++)
+  for (i = 0; i < max_group; i++)
     {
       if (r_search (rd->layergrouptree[i], &big, NULL, bad_boy, NULL))
 	return false;
diff --git a/src/buffer.c b/src/buffer.c
index b6d1e2b..1b2d27c 100644
--- a/src/buffer.c
+++ b/src/buffer.c
@@ -966,14 +966,12 @@ SmashBufferElement (BufferTypePtr Buffer)
   }
   END_LOOP;
   group =
-    GetLayerGroupNumberByNumber (max_layer +
-				 (SWAP_IDENT ? SOLDER_LAYER :
-				  COMPONENT_LAYER));
+    GetLayerGroupNumberByNumber (SWAP_IDENT ? solder_silk_layer :
+					      component_silk_layer);
   clayer = &Buffer->Data->Layer[PCB->LayerGroups.Entries[group][0]];
   group =
-    GetLayerGroupNumberByNumber (max_layer +
-				 (SWAP_IDENT ? COMPONENT_LAYER :
-				  SOLDER_LAYER));
+    GetLayerGroupNumberByNumber (SWAP_IDENT ? component_silk_layer :
+					      solder_silk_layer);
   slayer = &Buffer->Data->Layer[PCB->LayerGroups.Entries[group][0]];
   PAD_LOOP (element);
   {
@@ -1074,9 +1072,8 @@ ConvertBufferToElement (BufferTypePtr Buffer)
   }
   END_LOOP;
   /* get the component-side SM pads */
-  group = GetLayerGroupNumberByNumber (max_layer +
-				       (SWAP_IDENT ? SOLDER_LAYER :
-					COMPONENT_LAYER));
+  group = GetLayerGroupNumberByNumber (SWAP_IDENT ? solder_silk_layer :
+						    component_silk_layer);
   GROUP_LOOP (Buffer->Data, group);
   {
     char num[8];
@@ -1124,9 +1121,8 @@ ConvertBufferToElement (BufferTypePtr Buffer)
   }
   END_LOOP;
   /* now get the opposite side pads */
-  group = GetLayerGroupNumberByNumber (max_layer +
-				       (SWAP_IDENT ? COMPONENT_LAYER :
-					SOLDER_LAYER));
+  group = GetLayerGroupNumberByNumber (SWAP_IDENT ? component_silk_layer :
+						    solder_silk_layer);
   GROUP_LOOP (Buffer->Data, group);
   {
     bool warned = false;
@@ -1488,7 +1484,7 @@ MirrorBuffer (BufferTypePtr Buffer)
       Message (_("You can't mirror a buffer that has elements!\n"));
       return;
     }
-  for (i = 0; i < max_layer + 2; i++)
+  for (i = 0; i < max_copper_layer + 2; i++)
     {
       LayerTypePtr layer = Buffer->Data->Layer + i;
       if (layer->TextN)
@@ -1613,14 +1609,14 @@ SwapBuffer (BufferTypePtr Buffer)
   }
   ENDALL_LOOP;
   /* swap silkscreen layers */
-  swap = Buffer->Data->Layer[max_layer + SOLDER_LAYER];
-  Buffer->Data->Layer[max_layer + SOLDER_LAYER] =
-    Buffer->Data->Layer[max_layer + COMPONENT_LAYER];
-  Buffer->Data->Layer[max_layer + COMPONENT_LAYER] = swap;
+  swap = Buffer->Data->Layer[solder_silk_layer];
+  Buffer->Data->Layer[solder_silk_layer] =
+    Buffer->Data->Layer[component_silk_layer];
+  Buffer->Data->Layer[component_silk_layer] = swap;
 
   /* swap layer groups when balanced */
-  sgroup = GetLayerGroupNumberByNumber (max_layer + SOLDER_LAYER);
-  cgroup = GetLayerGroupNumberByNumber (max_layer + COMPONENT_LAYER);
+  sgroup = GetLayerGroupNumberByNumber (solder_silk_layer);
+  cgroup = GetLayerGroupNumberByNumber (component_silk_layer);
   if (PCB->LayerGroups.Number[cgroup] == PCB->LayerGroups.Number[sgroup])
     {
       for (j = k = 0; j < PCB->LayerGroups.Number[sgroup]; j++)
@@ -1629,11 +1625,11 @@ SwapBuffer (BufferTypePtr Buffer)
 	  Cardinal cnumber = PCB->LayerGroups.Entries[cgroup][k];
 	  Cardinal snumber = PCB->LayerGroups.Entries[sgroup][j];
 
-	  if (snumber >= max_layer)
+	  if (snumber >= max_copper_layer)
 	    continue;
 	  swap = Buffer->Data->Layer[snumber];
 
-	  while (cnumber >= max_layer)
+	  while (cnumber >= max_copper_layer)
 	    {
 	      k++;
 	      cnumber = PCB->LayerGroups.Entries[cgroup][k];
diff --git a/src/copy.c b/src/copy.c
index 58ce9df..c8244ed 100644
--- a/src/copy.c
+++ b/src/copy.c
@@ -338,7 +338,7 @@ CopyPastebufferToLayout (LocationType X, LocationType Y)
   DeltaX = X - PASTEBUFFER->X, DeltaY = Y - PASTEBUFFER->Y;
 
   /* paste all layers */
-  for (i = 0; i < max_layer + 2; i++)
+  for (i = 0; i < max_copper_layer + 2; i++)
     {
       LayerTypePtr sourcelayer = &PASTEBUFFER->Data->Layer[i],
 	destlayer = LAYER_PTR (i);
diff --git a/src/create.c b/src/create.c
index cb0fb2c..14996ff 100644
--- a/src/create.c
+++ b/src/create.c
@@ -117,15 +117,15 @@ pcb_colors_from_settings (PCBTypePtr ptr)
       ptr->Data->Layer[i].Color = Settings.LayerColor[i];
       ptr->Data->Layer[i].SelectedColor = Settings.LayerSelectedColor[i];
     }
-  ptr->Data->Layer[max_layer + COMPONENT_LAYER].Color =
+  ptr->Data->Layer[component_silk_layer].Color =
     Settings.ShowSolderSide ?
     Settings.InvisibleObjectsColor : Settings.ElementColor;
-  ptr->Data->Layer[max_layer + COMPONENT_LAYER].SelectedColor =
+  ptr->Data->Layer[component_silk_color].SelectedColor =
     Settings.ElementSelectedColor;
-  ptr->Data->Layer[max_layer + SOLDER_LAYER].Color =
+  ptr->Data->Layer[solder_silk_layer].Color =
     Settings.ShowSolderSide ?
     Settings.ElementColor : Settings.InvisibleObjectsColor;
-  ptr->Data->Layer[max_layer + SOLDER_LAYER].SelectedColor =
+  ptr->Data->Layer[solder_silk_layer].SelectedColor =
     Settings.ElementSelectedColor;
 }
 
@@ -216,9 +216,9 @@ CreateNewPCBPost (PCBTypePtr pcb, int use_defaults)
       if (ParseGroupString (Settings.Groups, &pcb->LayerGroups, DEF_LAYER))
 	return 1;
 
-      pcb->Data->Layer[max_layer + COMPONENT_LAYER].Name =
+      pcb->Data->Layer[component_silk_layer].Name =
 	MyStrdup ("silk", "CreateNewPCB()");
-      pcb->Data->Layer[max_layer + SOLDER_LAYER].Name =
+      pcb->Data->Layer[solder_silk_layer].Name =
 	MyStrdup ("silk", "CreateNewPCB()");
     }
   return 0;
diff --git a/src/crosshair.c b/src/crosshair.c
index 2c17911..6da0ea2 100644
--- a/src/crosshair.c
+++ b/src/crosshair.c
@@ -314,7 +314,7 @@ XORDrawBuffer (BufferTypePtr Buffer)
   y = Crosshair.Y - Buffer->Y;
 
   /* draw all visible layers */
-  for (i = 0; i < max_layer + 2; i++)
+  for (i = 0; i < max_copper_layer + 2; i++)
     if (PCB->Data->Layer[i].On)
       {
 	LayerTypePtr layer = &Buffer->Data->Layer[i];
@@ -869,8 +869,8 @@ FitCrosshairIntoGrid (LocationType X, LocationType Y)
         }
 
       /* find layer groups of the component side and solder side */
-      SLayer = GetLayerGroupNumberByNumber (max_layer + SOLDER_LAYER);
-      CLayer = GetLayerGroupNumberByNumber (max_layer + COMPONENT_LAYER);
+      SLayer = GetLayerGroupNumberByNumber (solder_silk_layer);
+      CLayer = GetLayerGroupNumberByNumber (component_silk_layer);
       desired_group = TEST_FLAG (ONSOLDERFLAG, pad) ? SLayer : CLayer;
 
       GROUP_LOOP (PCB->Data, desired_group);
diff --git a/src/data.h b/src/data.h
index ce27339..8dc674a 100644
--- a/src/data.h
+++ b/src/data.h
@@ -46,7 +46,10 @@ extern OutputType Output;
 
 extern PCBTypePtr PCB;
 
-#define max_layer (PCB->Data->LayerN)
+#define max_group (PCB->Data->LayerN)
+#define max_copper_layer (PCB->Data->LayerN)
+#define solder_silk_layer (max_copper_layer + SOLDER_LAYER)
+#define component_silk_layer (max_copper_layer + COMPONENT_LAYER)
 
 extern SettingType Settings;
 
diff --git a/src/djopt.c b/src/djopt.c
index 92fd2b8..240b86b 100644
--- a/src/djopt.c
+++ b/src/djopt.c
@@ -555,7 +555,7 @@ new_line (corner_s * s, corner_s * e, int layer, LineType * example)
 {
   line_s *ls;
 
-  if (layer >= max_layer)
+  if (layer >= max_copper_layer)
     dj_abort ("layer %d\n", layer);
 
   if (example == NULL)
@@ -2026,7 +2026,7 @@ vianudge ()
 	  counts[c->lines[i]->layer]++;
 	  directions[c->lines[i]->layer] |= o;
 	}
-      for (o = 0, i = 0; i < max_layer; i++)
+      for (o = 0, i = 0; i < max_copper_layer; i++)
 	if (counts[i] == 1)
 	  {
 	    o = directions[i];
@@ -2045,7 +2045,7 @@ vianudge ()
 	default:
 	  continue;
 	}
-      for (i = 0; i < max_layer; i++)
+      for (i = 0; i < max_copper_layer; i++)
 	if (counts[i] && directions[i] != o && directions[i] != oboth)
 	  goto vianudge_continue;
 
@@ -2661,7 +2661,7 @@ pinsnap ()
 
 	  dprintf ("%s x %d-%d y %d-%d\n", corner_name (c), left, right,
 		   bottom, top);
-	  for (l = 0; l <= max_layer; l++)
+	  for (l = 0; l <= max_copper_layer; l++)
 	    {
 	      best_dist[l] = close * 2;
 	      best_c[l] = 0;
@@ -2707,10 +2707,10 @@ pinsnap ()
 		}
 	      if (!got_one && c->n_lines == (c->pad ? 1 : 0))
 		{
-		  for (l = 0; l <= max_layer; l++)
+		  for (l = 0; l <= max_copper_layer; l++)
 		    if (best_c[l])
 		      dprintf ("best[%d] = %s\n", l, corner_name (best_c[l]));
-		  for (l = 0; l <= max_layer; l++)
+		  for (l = 0; l <= max_copper_layer; l++)
 		    if (best_c[l])
 		      {
 			dprintf ("move %s to %s\n", corner_name (best_c[l]),
@@ -2882,24 +2882,24 @@ grok_layer_groups ()
   LayerGroupType *l = &(PCB->LayerGroups);
 
   solder_layer = component_layer = -1;
-  for (i = 0; i < max_layer; i++)
+  for (i = 0; i < max_copper_layer; i++)
     {
       layer_type[i] = 0;
       layer_groupings[i] = 0;
     }
-  for (i = 0; i < max_layer; i++)
+  for (i = 0; i < max_group; i++)
     {
       f = 0;
       for (j = 0; j < l->Number[i]; j++)
 	{
-	  if (l->Entries[i][j] == max_layer + SOLDER_LAYER)
+	  if (l->Entries[i][j] == solder_silk_layer)
 	    f |= LT_SOLDER;
-	  if (l->Entries[i][j] == max_layer + COMPONENT_LAYER)
+	  if (l->Entries[i][j] == component_silk_layer)
 	    f |= LT_COMPONENT;
 	}
       for (j = 0; j < l->Number[i]; j++)
 	{
-	  if (l->Entries[i][j] >= 0 && l->Entries[i][j] < max_layer)
+	  if (l->Entries[i][j] >= 0 && l->Entries[i][j] < max_copper_layer)
 	    {
 	      layer_type[l->Entries[i][j]] |= f;
 	      layer_groupings[l->Entries[i][j]] = i;
@@ -3036,7 +3036,7 @@ ActionDJopt (int argc, char **argv, int x, int y)
       return 0;
     }
 
-  for (layn = 0; layn < max_layer; layn++)
+  for (layn = 0; layn < max_copper_layer; layn++)
     {
       LayerType *layer = LAYER_PTR (layn);
       int ln;
diff --git a/src/draw.c b/src/draw.c
index d5a0a57..c1f7ec0 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -361,7 +361,7 @@ PrintAssembly (const BoxType * drawn_area, int side_group, int swap_ident)
 
   /* draw package */
   DrawSilk (swap_ident,
-	    swap_ident ? SOLDER_LAYER : COMPONENT_LAYER,
+	    swap_ident ? solder_silk_layer : component_silk_layer,
 	    drawn_area);
   SWAP_IDENT = save_swap;
 }
@@ -384,7 +384,7 @@ DrawEverything (BoxTypePtr drawn_area)
   PCB->Data->BACKSILKLAYER.Color = PCB->InvisibleObjectsColor;
 
   memset (do_group, 0, sizeof (do_group));
-  for (ngroups = 0, i = 0; i < max_layer; i++)
+  for (ngroups = 0, i = 0; i < max_copper_layer; i++)
     {
       LayerType *l = LAYER_ON_STACK (i);
       int group = GetLayerGroupNumberByNumber (LayerStack[i]);
@@ -395,8 +395,8 @@ DrawEverything (BoxTypePtr drawn_area)
 	}
     }
 
-  component = GetLayerGroupNumberByNumber (max_layer + COMPONENT_LAYER);
-  solder = GetLayerGroupNumberByNumber (max_layer + SOLDER_LAYER);
+  component = GetLayerGroupNumberByNumber (component_silk_layer);
+  solder = GetLayerGroupNumberByNumber (solder_silk_layer);
 
   /*
    * first draw all 'invisible' stuff
@@ -507,13 +507,13 @@ DrawEverything (BoxTypePtr drawn_area)
   /* Draw top silkscreen */
   if (gui->set_layer ("topsilk", SL (SILK, TOP), 0))
     {
-      DrawSilk (0, COMPONENT_LAYER, drawn_area);
+      DrawSilk (0, component_silk_layer, drawn_area);
       gui->set_layer (NULL, SL (FINISHED, 0), 0);
     }
 
   if (gui->set_layer ("bottomsilk", SL (SILK, BOTTOM), 0))
     {
-      DrawSilk (1, SOLDER_LAYER, drawn_area);
+      DrawSilk (1, solder_silk_layer, drawn_area);
       gui->set_layer (NULL, SL (FINISHED, 0), 0);
     }
 
@@ -721,7 +721,7 @@ DrawSilk (int new_swap, int layer, const BoxType * drawn_area)
     {
       gui->use_mask (HID_MASK_BEFORE);
 #endif
-      DrawLayer (LAYER_PTR (max_layer + layer), drawn_area);
+      DrawLayer (LAYER_PTR (layer), drawn_area);
       /* draw package */
       r_search (PCB->Data->element_tree, drawn_area, NULL, frontE_callback,
 		NULL);
@@ -739,7 +739,7 @@ DrawSilk (int new_swap, int layer, const BoxType * drawn_area)
   if (gui->poly_after)
     {
       gui->use_mask (HID_MASK_AFTER);
-      DrawLayer (LAYER_PTR (max_layer + layer), drawn_area);
+      DrawLayer (LAYER_PTR (max_copper_layer + layer), drawn_area);
       /* draw package */
       r_search (PCB->Data->element_tree, drawn_area, NULL, frontE_callback,
 		NULL);
@@ -898,7 +898,7 @@ DrawLayerGroup (int group, const BoxType * screen)
       if (strcmp (Layer->Name, "outline") == 0 ||
 	  strcmp (Layer->Name, "route") == 0)
 	rv = 0;
-      if (layernum < max_layer && Layer->On)
+      if (layernum < max_copper_layer && Layer->On)
 	{
 	  /* draw all polygons on this layer */
 	  if (Layer->PolygonN)
diff --git a/src/file.c b/src/file.c
index 18abbd2..7f167dc 100644
--- a/src/file.c
+++ b/src/file.c
@@ -870,7 +870,7 @@ WriteBuffer (FILE * FP)
 
   WriteViaData (FP, PASTEBUFFER->Data);
   WriteElementData (FP, PASTEBUFFER->Data);
-  for (i = 0; i < max_layer + 2; i++)
+  for (i = 0; i < max_copper_layer + 2; i++)
     WriteLayerData (FP, i, &(PASTEBUFFER->Data->Layer[i]));
   return (STATUS_OK);
 }
@@ -890,7 +890,7 @@ WritePCB (FILE * FP)
   WriteViaData (FP, PCB->Data);
   WriteElementData (FP, PCB->Data);
   WritePCBRatData (FP);
-  for (i = 0; i < max_layer + 2; i++)
+  for (i = 0; i < max_copper_layer + 2; i++)
     WriteLayerData (FP, i, &(PCB->Data->Layer[i]));
   WritePCBNetlistData (FP);
 
diff --git a/src/find.c b/src/find.c
index f473788..c478f7f 100644
--- a/src/find.c
+++ b/src/find.c
@@ -567,7 +567,7 @@ FreeLayoutLookupMemory (void)
 {
   Cardinal i;
 
-  for (i = 0; i < max_layer; i++)
+  for (i = 0; i < max_copper_layer; i++)
     {
       MYFREE (LineList[i].Data);
       MYFREE (ArcList[i].Data);
@@ -630,7 +630,7 @@ InitLayoutLookup (void)
   Cardinal i;
 
   /* initialize line arc and polygon data */
-  for (i = 0; i < max_layer; i++)
+  for (i = 0; i < max_copper_layer; i++)
     {
       LayerTypePtr layer = LAYER_PTR (i);
 
@@ -824,7 +824,7 @@ LookupLOConnectionsToPVList (bool AndRats)
         return true;
 
       /* now all lines, arcs and polygons of the several layers */
-      for (layer = 0; layer < max_layer; layer++)
+      for (layer = 0; layer < max_copper_layer; layer++)
         {
           info.layer = layer;
           /* add touching lines */
@@ -875,7 +875,7 @@ LookupLOConnectionsToLOList (bool AndRats)
    * by 'LookupPVConnectionsToLOList()' which has to check the same
    * list entries plus the new ones
    */
-  for (i = 0; i < max_layer; i++)
+  for (i = 0; i < max_copper_layer; i++)
     {
       lineposition[i] = LineList[i].Location;
       polyposition[i] = PolygonList[i].Location;
@@ -908,7 +908,7 @@ LookupLOConnectionsToLOList (bool AndRats)
             }
         }
       /* loop over all layergroups */
-      for (group = 0; group < max_layer; group++)
+      for (group = 0; group < max_group; group++)
         {
           Cardinal entry;
 
@@ -916,10 +916,10 @@ LookupLOConnectionsToLOList (bool AndRats)
             {
               layer = PCB->LayerGroups.Entries[group][entry];
 
-              /* be aware that the layer number equal max_layer
-               * and max_layer+1 have a special meaning for pads
+              /* be aware that the layer number equal max_copper_layer
+               * and max_copper_layer+1 have a special meaning for pads
                */
-              if (layer < max_layer)
+              if (layer < max_copper_layer)
                 {
                   /* try all new lines */
                   position = &lineposition[layer];
@@ -945,11 +945,11 @@ LookupLOConnectionsToLOList (bool AndRats)
               else
                 {
                   /* try all new pads */
-                  layer -= max_layer;
+                  layer -= max_copper_layer;
                   if (layer > 1)
                     {
-                      Message (_("bad layer number %d max_layer=%d in find.c\n"),
-                               layer, max_layer);
+                      Message (_("bad layer number %d max_copper_layer=%d in find.c\n"),
+                               layer, max_copper_layer);
                       return false;
                     }
                   position = &padposition[layer];
@@ -965,17 +965,17 @@ LookupLOConnectionsToLOList (bool AndRats)
        * may have changed the prior lists
        */
       done = !AndRats || ratposition >= RatList.Number;
-      for (layer = 0; layer < max_layer + 2; layer++)
+      for (layer = 0; layer < max_copper_layer + 2; layer++)
         {
-          if (layer < max_layer)
+          if (layer < max_copper_layer)
             done = done &&
               lineposition[layer] >= LineList[layer].Number
               && arcposition[layer] >= ArcList[layer].Number
               && polyposition[layer] >= PolygonList[layer].Number;
           else
             done = done
-              && padposition[layer - max_layer] >=
-              PadList[layer - max_layer].Number;
+              && padposition[layer - max_copper_layer] >=
+              PadList[layer - max_copper_layer].Number;
         }
     }
   while (!done);
@@ -1171,7 +1171,7 @@ LookupPVConnectionsToLOList (bool AndRats)
   struct lo_info info;
 
   /* loop over all layers */
-  for (layer = 0; layer < max_layer; layer++)
+  for (layer = 0; layer < max_copper_layer; layer++)
     {
       /* do nothing if there are no PV's */
       if (TotalP + TotalV == 0)
@@ -1944,7 +1944,7 @@ LookupLOConnectionsToArc (ArcTypePtr Arc, Cardinal LayerGroup)
       layer = PCB->LayerGroups.Entries[LayerGroup][entry];
 
       /* handle normal layers */
-      if (layer < max_layer)
+      if (layer < max_copper_layer)
         {
           PolygonTypePtr polygon;
 
@@ -1972,7 +1972,7 @@ LookupLOConnectionsToArc (ArcTypePtr Arc, Cardinal LayerGroup)
         }
       else
         {
-          info.layer = layer - max_layer;
+          info.layer = layer - max_copper_layer;
           if (setjmp (info.env) == 0)
             r_search (PCB->Data->pad_tree, &info.arc.BoundingBox, NULL,
                       LOCtoArcPad_callback, &info);
@@ -2082,7 +2082,7 @@ LookupLOConnectionsToLine (LineTypePtr Line, Cardinal LayerGroup,
       layer = PCB->LayerGroups.Entries[LayerGroup][entry];
 
       /* handle normal layers */
-      if (layer < max_layer)
+      if (layer < max_copper_layer)
         {
           PolygonTypePtr polygon;
 
@@ -2114,7 +2114,7 @@ LookupLOConnectionsToLine (LineTypePtr Line, Cardinal LayerGroup,
       else
         {
           /* handle special 'pad' layers */
-          info.layer = layer - max_layer;
+          info.layer = layer - max_copper_layer;
           if (setjmp (info.env) == 0)
             r_search (PCB->Data->pad_tree, &info.line.BoundingBox, NULL,
                       LOCtoLinePad_callback, &info);
@@ -2181,7 +2181,7 @@ LOTouchesLine (LineTypePtr Line, Cardinal LayerGroup)
       Cardinal layer = PCB->LayerGroups.Entries[LayerGroup][entry];
 
       /* handle normal layers */
-      if (layer < max_layer)
+      if (layer < max_copper_layer)
         {
           PolygonTypePtr polygon;
 
@@ -2209,7 +2209,7 @@ LOTouchesLine (LineTypePtr Line, Cardinal LayerGroup)
       else
         {
           /* handle special 'pad' layers */
-          info.layer = layer - max_layer;
+          info.layer = layer - max_copper_layer;
           if (setjmp (info.env) == 0)
             r_search (PCB->Data->pad_tree, &info.line.BoundingBox, NULL,
                       LOT_Padcallback, &info);
@@ -2301,7 +2301,7 @@ LookupLOConnectionsToRatEnd (PointTypePtr Point, Cardinal LayerGroup)
          arcs by definition
        */
 
-      if (layer < max_layer)
+      if (layer < max_copper_layer)
         {
           info.layer = layer;
           if (setjmp (info.env) == 0)
@@ -2316,7 +2316,7 @@ LookupLOConnectionsToRatEnd (PointTypePtr Point, Cardinal LayerGroup)
       else
         {
           /* handle special 'pad' layers */
-          info.layer = layer - max_layer;
+          info.layer = layer - max_copper_layer;
           if (setjmp (info.env) == 0)
             r_search_pt (PCB->Data->pad_tree, Point, 1, NULL,
                       LOCtoPad_callback, &info);
@@ -2447,7 +2447,7 @@ LookupLOConnectionsToPad (PadTypePtr Pad, Cardinal LayerGroup)
 
       layer = PCB->LayerGroups.Entries[LayerGroup][entry];
       /* handle normal layers */
-      if (layer < max_layer)
+      if (layer < max_copper_layer)
         {
           info.layer = layer;
           /* add lines */
@@ -2472,7 +2472,7 @@ LookupLOConnectionsToPad (PadTypePtr Pad, Cardinal LayerGroup)
       else
         {
           /* handle special 'pad' layers */
-          info.layer = layer - max_layer;
+          info.layer = layer - max_copper_layer;
           if (setjmp (info.env) == 0)
             r_search (PCB->Data->pad_tree, (BoxType *) & info.pad, NULL,
                       LOCtoPadPad_callback, &info);
@@ -2580,7 +2580,7 @@ LookupLOConnectionsToPolygon (PolygonTypePtr Polygon, Cardinal LayerGroup)
       layer = PCB->LayerGroups.Entries[LayerGroup][entry];
 
       /* handle normal layers */
-      if (layer < max_layer)
+      if (layer < max_copper_layer)
         {
           PolygonTypePtr polygon;
 
@@ -2610,7 +2610,7 @@ LookupLOConnectionsToPolygon (PolygonTypePtr Polygon, Cardinal LayerGroup)
         }
       else
         {
-          info.layer = layer - max_layer;
+          info.layer = layer - max_copper_layer;
           if (setjmp (info.env) == 0)
             r_search (PCB->Data->pad_tree, (BoxType *) & info.polygon,
                       NULL, LOCtoPolyPad_callback, &info);
@@ -2893,7 +2893,7 @@ ListsEmpty (bool AndRats)
   empty = (PVList.Location >= PVList.Number);
   if (AndRats)
     empty = empty && (RatList.Location >= RatList.Number);
-  for (i = 0; i < max_layer && empty; i++)
+  for (i = 0; i < max_copper_layer && empty; i++)
     empty = empty && LineList[i].Location >= LineList[i].Number
       && ArcList[i].Location >= ArcList[i].Number
       && PolygonList[i].Location >= PolygonList[i].Number;
@@ -3059,7 +3059,7 @@ PrepareNextLoop (FILE * FP)
   Cardinal layer;
 
   /* reset found LOs for the next pin */
-  for (layer = 0; layer < max_layer; layer++)
+  for (layer = 0; layer < max_copper_layer; layer++)
     {
       LineList[layer].Location = LineList[layer].Number = 0;
       ArcList[layer].Location = ArcList[layer].Number = 0;
@@ -3151,7 +3151,7 @@ DrawNewConnections (void)
   Cardinal position;
 
   /* decrement 'i' to keep layerstack order */
-  for (i = max_layer - 1; i != -1; i--)
+  for (i = max_copper_layer - 1; i != -1; i--)
     {
       Cardinal layer = LayerStack[i];
 
@@ -3366,7 +3366,7 @@ LookupConnection (LocationType X, LocationType Y, bool AndDraw,
                                        (LayerTypePtr) ptr1);
 
           /* don't mess with silk objects! */
-          if (laynum >= max_layer)
+          if (laynum >= max_copper_layer)
             return;
         }
     }
@@ -3611,7 +3611,7 @@ DumpList (void)
   PVList.Number = 0;
   PVList.Location = 0;
 
-  for (i = 0; i < max_layer; i++)
+  for (i = 0; i < max_copper_layer; i++)
     {
       LineList[i].Location = 0;
       LineList[i].DrawLocation = 0;
diff --git a/src/flags.c b/src/flags.c
index 60688dd..c33cfb6 100644
--- a/src/flags.c
+++ b/src/flags.c
@@ -143,7 +143,7 @@ FlagLayerShown (int n)
     case FL_MASK:
       return TEST_FLAG (SHOWMASKFLAG, PCB);
     default:
-      if (n >= 0 && n < max_layer)
+      if (n >= 0 && n < max_copper_layer)
 	return PCB->Data->Layer[n].On;
     }
   return 0;
diff --git a/src/hid/batch/batch.c b/src/hid/batch/batch.c
index 3129466..f3b7d3c 100644
--- a/src/hid/batch/batch.c
+++ b/src/hid/batch/batch.c
@@ -82,8 +82,8 @@ info (int argc, char **argv, int x, int y)
 	 PCB->MaxHeight / 100.0,
 	 PCB->MaxWidth * COOR_TO_MM,
 	 PCB->MaxHeight * COOR_TO_MM);
-  cg = GetLayerGroupNumberByNumber (max_layer + COMPONENT_LAYER);
-  sg = GetLayerGroupNumberByNumber (max_layer + SOLDER_LAYER);
+  cg = GetLayerGroupNumberByNumber (component_silk_layer);
+  sg = GetLayerGroupNumberByNumber (solder_silk_layer);
   for (i=0; i<MAX_LAYER; i++)
     {
       
diff --git a/src/hid/common/extents.c b/src/hid/common/extents.c
index a0dbf6b..e8bd8ab 100644
--- a/src/hid/common/extents.c
+++ b/src/hid/common/extents.c
@@ -38,11 +38,11 @@ static int
 extents_set_layer (const char *name, int group, int empty)
 {
   int idx = group;
-  if (idx >= 0 && idx < max_layer)
+  if (idx >= 0 && idx < max_group)
     {
       idx = PCB->LayerGroups.Entries[idx][0];
     }
-  if (idx >= 0 && idx < max_layer + 2)
+  if (idx >= 0 && idx < max_copper_layer + 2)
     return 1;
   if (idx < 0)
     {
diff --git a/src/hid/common/flags.c b/src/hid/common/flags.c
index 3915c7a..e4a566d 100644
--- a/src/hid/common/flags.c
+++ b/src/hid/common/flags.c
@@ -132,7 +132,7 @@ void
 hid_save_and_show_layer_ons (int *save_array)
 {
   int i;
-  for (i = 0; i < max_layer + 2; i++)
+  for (i = 0; i < max_copper_layer + 2; i++)
     {
       save_array[i] = PCB->Data->Layer[i].On;
       PCB->Data->Layer[i].On = 1;
@@ -143,7 +143,7 @@ void
 hid_restore_layer_ons (int *save_array)
 {
   int i;
-  for (i = 0; i < max_layer + 2; i++)
+  for (i = 0; i < max_copper_layer + 2; i++)
     PCB->Data->Layer[i].On = save_array[i];
 }
 
@@ -180,9 +180,9 @@ layer_type_to_file_name (int idx)
       return "backassembly";
     default:
       group = GetLayerGroupNumberByNumber(idx);
-      if (group == GetLayerGroupNumberByNumber(max_layer+COMPONENT_LAYER))
+      if (group == GetLayerGroupNumberByNumber(component_silk_layer))
 	return "front";
-      else if (group == GetLayerGroupNumberByNumber(max_layer+SOLDER_LAYER))
+      else if (group == GetLayerGroupNumberByNumber(solder_silk_layer))
 	return "back";
       else if (PCB->LayerGroups.Number[group] == 1
 	       && (strcmp (PCB->Data->Layer[idx].Name, "route") == 0 ||
diff --git a/src/hid/gcode/gcode.c b/src/hid/gcode/gcode.c
index c3c2e4e..452bd0f 100644
--- a/src/hid/gcode/gcode.c
+++ b/src/hid/gcode/gcode.c
@@ -277,7 +277,7 @@ gcode_choose_groups ()
   /* Set entire array to 0 (don't export any layer groups by default */
   memset (gcode_export_group, 0, sizeof (gcode_export_group));
 
-  for (n = 0; n < max_layer; n++)
+  for (n = 0; n < max_copper_layer; n++)
     {
       layer = &PCB->Data->Layer[n];
 
@@ -458,12 +458,12 @@ gcode_do_export (HID_Attr_Val * options)
 	  gcode_cur_group = i;
 
 	  /* magic */
-	  idx = (i >= 0 && i < max_layer) ?
+	  idx = (i >= 0 && i < max_group) ?
 	    PCB->LayerGroups.Entries[i][0] : i;
 	  printf ("idx=%d %s\n", idx, layer_type_to_file_name (idx));
 	  is_solder =
 	    (GetLayerGroupNumberByNumber (idx) ==
-	     GetLayerGroupNumberByNumber (max_layer + SOLDER_LAYER)) ? 1 : 0;
+	     GetLayerGroupNumberByNumber (solder_silk_layer) ? 1 : 0;
 	  save_drill = is_solder;	/* save drills for one layer only */
 	  gcode_start_png (gcode_basename, layer_type_to_file_name (idx));
 	  hid_save_and_show_layer_ons (save_ons);
@@ -627,7 +627,7 @@ gcode_do_export (HID_Attr_Val * options)
 static int
 gcode_set_layer (const char *name, int group, int empty)
 {
-  int idx = (group >= 0 && group < max_layer) ?
+  int idx = (group >= 0 && group < max_group) ?
     PCB->LayerGroups.Entries[group][0] : group;
 
   if (name == 0)
diff --git a/src/hid/gerber/gerber.c b/src/hid/gerber/gerber.c
index 8a46c3c..cb2310e 100644
--- a/src/hid/gerber/gerber.c
+++ b/src/hid/gerber/gerber.c
@@ -302,10 +302,10 @@ gerber_get_export_options (int *n)
 static int
 group_for_layer (int l)
 {
-  if (l < max_layer + 2 && l >= 0)
+  if (l < max_copper_layer + 2 && l >= 0)
     return GetLayerGroupNumberByNumber (l);
   /* else something unique */
-  return max_layer + 3 + l;
+  return max_group + 3 + l;
 }
 
 static int
@@ -380,20 +380,20 @@ gerber_do_export (HID_Attr_Val * options)
     }
 
   hid_save_and_show_layer_ons (save_ons);
-  for (i = 0; i < max_layer; i++)
+  for (i = 0; i < max_copper_layer; i++)
     {
       LayerType *layer = PCB->Data->Layer + i;
       if (layer->LineN || layer->TextN || layer->ArcN || layer->PolygonN)
 	print_group[GetLayerGroupNumberByNumber (i)] = 1;
     }
-  print_group[GetLayerGroupNumberByNumber (max_layer)] = 1;
-  print_group[GetLayerGroupNumberByNumber (max_layer + 1)] = 1;
-  for (i = 0; i < max_layer; i++)
+  print_group[GetLayerGroupNumberByNumber (solder_silk_layer)] = 1;
+  print_group[GetLayerGroupNumberByNumber (component_silk_layer)] = 1;
+  for (i = 0; i < max_copper_layer; i++)
     if (print_group[GetLayerGroupNumberByNumber (i)])
       print_layer[i] = 1;
 
   memcpy (saved_layer_stack, LayerStack, sizeof (LayerStack));
-  qsort (LayerStack, max_layer, sizeof (LayerStack[0]), layer_sort);
+  qsort (LayerStack, max_copper_layer, sizeof (LayerStack[0]), layer_sort);
   linewidth = -1;
   lastcap = -1;
   lastgroup = -1;
@@ -453,7 +453,7 @@ gerber_set_layer (const char *name, int group, int empty)
   char *cp;
   int idx = (group >= 0
 	     && group <
-	     max_layer) ? PCB->LayerGroups.Entries[group][0] : group;
+	     max_group) ? PCB->LayerGroups.Entries[group][0] : group;
 
   if (SL_TYPE (idx) == SL_FINISHED)
     return 0;
@@ -461,7 +461,7 @@ gerber_set_layer (const char *name, int group, int empty)
   if (name == 0)
     name = PCB->Data->Layer[idx].Name;
 
-  if (idx >= 0 && idx < max_layer && !print_layer[idx])
+  if (idx >= 0 && idx < max_copper_layer && !print_layer[idx])
     return 0;
 
   if (strcmp (name, "invisible") == 0)
diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index fe87ad0..f83b3d0 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -71,44 +71,46 @@ hid_gc_struct;
 int
 ghid_set_layer (const char *name, int group, int empty)
 {
-  int idx = group;
-  if (idx >= 0 && idx < max_layer)
+  if (group >= 0 && group < max_group)
     {
-      int n = PCB->LayerGroups.Number[group];
-      for (idx = 0; idx < n-1; idx ++)
+      int layer_idx;
+      int entry;
+      for (entry = 0; entry < PCB->LayerGroups.Number[group]; entry ++)
 	{
-	  int ni = PCB->LayerGroups.Entries[group][idx];
-	  if (ni >= 0 && ni < max_layer + 2
-	      && PCB->Data->Layer[ni].On)
-	    break;
+	  layer_idx = PCB->LayerGroups.Entries[group][entry];
+	  /* Only return TRUE for visible non-silk layers.
+	   * NB: Silk layers ocupy layer_idx
+	   * max_copper_layer and max_copper_layer + 1
+	   */
+	  if (layer_idx >= 0 && layer_idx < max_copper_layer &&
+	      PCB->Data->Layer[layer_idx].On)
+	    return TRUE;
 	}
-      idx = PCB->LayerGroups.Entries[group][idx];
+      return FALSE;
     }
 
-  if (idx >= 0 && idx < max_layer + 2)
-    return /*pinout ? 1 : */ PCB->Data->Layer[idx].On;
-  if (idx < 0)
+  /* If we didn't hit a match above, group is being used as a
+     special symbolic layer type, and will be negative. */
+
+  switch (SL_TYPE (group))
     {
-      switch (SL_TYPE (idx))
-	{
-	case SL_INVISIBLE:
-	  return /* pinout ? 0 : */ PCB->InvisibleObjectsOn;
-	case SL_MASK:
-	  if (SL_MYSIDE (idx) /*&& !pinout */ )
-	    return TEST_FLAG (SHOWMASKFLAG, PCB);
-	  return 0;
-	case SL_SILK:
-	  if (SL_MYSIDE (idx) /*|| pinout */ )
-	    return PCB->ElementOn;
-	  return 0;
-	case SL_ASSY:
-	  return 0;
-	case SL_PDRILL:
-	case SL_UDRILL:
-	  return 1;
-	case SL_RATS:
-	  return PCB->RatOn;
-	}
+    case SL_INVISIBLE:
+      return /* pinout ? 0 : */ PCB->InvisibleObjectsOn;
+    case SL_MASK:
+      if (SL_MYSIDE (idx) /*&& !pinout */ )
+        return TEST_FLAG (SHOWMASKFLAG, PCB);
+      return 0;
+    case SL_SILK:
+      if (SL_MYSIDE (idx) /*|| pinout */ )
+        return PCB->ElementOn;
+      return 0;
+    case SL_ASSY:
+      return 0;
+    case SL_PDRILL:
+    case SL_UDRILL:
+      return 1;
+    case SL_RATS:
+      return PCB->RatOn;
     }
   return 0;
 }
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 4d5abe4..653e833 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -96,17 +96,17 @@ compute_depth (int group)
   int newgroup;
   int idx = (group >= 0
              && group <
-             max_layer) ? PCB->LayerGroups.Entries[group][0] : group;
+             max_group) ? PCB->LayerGroups.Entries[group][0] : group;
 
-  solder_group = GetLayerGroupNumberByNumber (max_layer + SOLDER_LAYER);
-  component_group = GetLayerGroupNumberByNumber (max_layer + COMPONENT_LAYER);
+  solder_group = GetLayerGroupNumberByNumber (solder_silk_layer);
+  component_group = GetLayerGroupNumberByNumber (component_silk_layer);
 
   min_phys_group = MIN (solder_group, component_group);
   max_phys_group = MAX (solder_group, component_group);
 
   max_depth = (1 + max_phys_group - min_phys_group) * 10;
 
-  if (group >= 0 && group < max_layer) {
+  if (group >= 0 && group < group) {
     newgroup = group;
 
     depth = (max_depth - (newgroup - min_phys_group) * 10) * 200 / gport->zoom;
@@ -140,13 +140,13 @@ ghid_set_layer (const char *name, int group, int empty)
   render_priv *priv = gport->render_priv;
   static int stencil_bit = 0;
   int idx = group;
-  if (idx >= 0 && idx < max_layer)
+  if (idx >= 0 && idx < max_group)
     {
       int n = PCB->LayerGroups.Number[group];
       for (idx = 0; idx < n-1; idx ++)
 	{
 	  int ni = PCB->LayerGroups.Entries[group][idx];
-	  if (ni >= 0 && ni < max_layer + 2
+	  if (ni >= 0 && ni < max_copper_layer + 2
 	      && PCB->Data->Layer[ni].On)
 	    break;
 	}
@@ -171,7 +171,7 @@ ghid_set_layer (const char *name, int group, int empty)
     glStencilFunc (GL_ALWAYS, 0, 0);  // Always pass stencil test
   }
 
-  if (idx >= 0 && idx < max_layer + 2)
+  if (idx >= 0 && idx < max_copper_layer + 2)
     {
       priv->trans_lines = true;
       return PCB->Data->Layer[idx].On;
@@ -1101,8 +1101,8 @@ SetPVColor_inlayer (PinTypePtr Pin, LayerTypePtr Layer, int Type)
     color = PCB->ConnectedColor;
   else
     {
-      int component_group = GetLayerGroupNumberByNumber (max_layer + COMPONENT_LAYER);
-      int solder_group    = GetLayerGroupNumberByNumber (max_layer + SOLDER_LAYER);
+      int component_group = GetLayerGroupNumberByNumber (component_silk_layer);
+      int solder_group    = GetLayerGroupNumberByNumber (solder_silk_layer);
       int this_group      = GetLayerGroupNumberByPointer (Layer);
 
       if (this_group == component_group || this_group == solder_group)
@@ -1425,8 +1425,8 @@ DrawLayerGroup (int group, const BoxType * screen)
   int n_entries = PCB->LayerGroups.Number[group];
   Cardinal *layers = PCB->LayerGroups.Entries[group];
   int first_run = 1;
-  int component_group = GetLayerGroupNumberByNumber (max_layer + COMPONENT_LAYER);
-  int solder_group    = GetLayerGroupNumberByNumber (max_layer + SOLDER_LAYER);
+  int component_group = GetLayerGroupNumberByNumber (component_silk_layer);
+  int solder_group    = GetLayerGroupNumberByNumber (solder_silk_layer);
 
   if (!gui->set_layer (0, group, 0)) {
     gui->set_layer (NULL, SL (FINISHED, 0), 0);
@@ -1442,7 +1442,7 @@ DrawLayerGroup (int group, const BoxType * screen)
         strcmp (Layer->Name, "route") == 0)
       rv = 0;
 
-    if (layernum < max_layer && Layer->On) {
+    if (layernum < max_copper_layer && Layer->On) {
 
       if (!first_run)
         gui->set_layer (0, group, 0);
@@ -1609,27 +1609,43 @@ ghid_draw_everything (BoxTypePtr drawn_area)
   PCB->Data->SILKLAYER.Color = PCB->ElementColor;
   PCB->Data->BACKSILKLAYER.Color = PCB->InvisibleObjectsColor;
 
-  solder_group = GetLayerGroupNumberByNumber (max_layer + SOLDER_LAYER);
-  component_group = GetLayerGroupNumberByNumber (max_layer + COMPONENT_LAYER);
+  solder_group = GetLayerGroupNumberByNumber (solder_silk_layer);
+  component_group = GetLayerGroupNumberByNumber (component_silk_layer);
 
   min_phys_group = MIN (solder_group, component_group);
   max_phys_group = MAX (solder_group, component_group);
 
   memset (do_group, 0, sizeof (do_group));
-  for (ngroups = 0, i = 0; i < max_layer; i++) {
-    int group;
-    int orderi;
-
-    orderi = reverse_layers ? max_layer - i - 1 : i;
+  if (global_view_2d)
+    { // Draw in layer stack order when in 2D view
+      int group;
+      int orderi;
+      for (ngroups = 0, i = 0; i < max_copper_layer; i++)
+        {
+          group = GetLayerGroupNumberByNumber (LayerStack[i]);
 
-    // Draw in numerical order when in 3D view
-    group = global_view_2d ? GetLayerGroupNumberByNumber (LayerStack[i]) : orderi;
+          if (!do_group[group])
+            {
+              do_group[group] = 1;
+              drawn_groups[ngroups++] = group;
+            }
+        }
+    }
+  else
+    { // Draw in numerical order when in 3D view
+      int group;
+      int orderi;
+      for (ngroups = 0, i = 0; i < max_group; i++)
+        {
+          group = reverse_layers ? max_group -1 - i : i;
 
-    if (!do_group[group]) {
-      do_group[group] = 1;
-      drawn_groups[ngroups++] = group;
+          if (!do_group[group])
+            {
+              do_group[group] = 1;
+              drawn_groups[ngroups++] = group;
+            }
+        }
     }
-  }
 
   /*
    * first draw all 'invisible' stuff
@@ -1742,13 +1758,13 @@ ghid_draw_everything (BoxTypePtr drawn_area)
   /* Draw top silkscreen */
   if (!Settings.ShowSolderSide &&
       gui->set_layer ("topsilk", SL (SILK, TOP), 0)) {
-    DrawSilk (0, COMPONENT_LAYER, drawn_area);
+    DrawSilk (0, component_silk_layer, drawn_area);
     gui->set_layer (NULL, SL (FINISHED, 0), 0);
   }
 
   if (Settings.ShowSolderSide &&
       gui->set_layer ("bottomsilk", SL (SILK, BOTTOM), 0)) {
-    DrawSilk (1, SOLDER_LAYER, drawn_area);
+    DrawSilk (1, solder_silk_layer, drawn_area);
     gui->set_layer (NULL, SL (FINISHED, 0), 0);
   }
 
@@ -1842,8 +1858,8 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glStencilFunc (GL_ALWAYS, 0, 0);
 
   /* Test the 8 corners of a cube spanning the event */
-  min_depth = -50 + compute_depth (0);         /* FIXME */
-  max_depth =  50 + compute_depth (max_layer); /* FIXME */
+  min_depth = -50 + compute_depth (0);                /* FIXME */
+  max_depth =  50 + compute_depth (max_copper_layer); /* FIXME */
 
   ghid_unproject_to_z_plane (ev->area.x,
                              ev->area.y,
@@ -1943,8 +1959,8 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
     int max_phys_group;
     int i;
 
-    solder_group = GetLayerGroupNumberByNumber (max_layer + SOLDER_LAYER);
-    component_group = GetLayerGroupNumberByNumber (max_layer + COMPONENT_LAYER);
+    solder_group = GetLayerGroupNumberByNumber (solder_silk_layer);
+    component_group = GetLayerGroupNumberByNumber (component_silk_layer);
 
     min_phys_group = MIN (solder_group, component_group);
     max_phys_group = MAX (solder_group, component_group);
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 08e8567..e5418af 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -1398,8 +1398,8 @@ SwapSides (int argc, char **argv, int x, int y)
   gint flipd;
   int do_flip_x = 0;
   int do_flip_y = 0;
-  int comp_group = GetLayerGroupNumberByNumber (max_layer + COMPONENT_LAYER);
-  int solder_group = GetLayerGroupNumberByNumber (max_layer + SOLDER_LAYER);
+  int comp_group = GetLayerGroupNumberByNumber (component_silk_layer);
+  int solder_group = GetLayerGroupNumberByNumber (solder_silk_layer);
   int active_group = GetLayerGroupNumberByNumber (LayerStack[0]);
   int comp_showing =
     PCB->Data->Layer[PCB->LayerGroups.Entries[comp_group][0]].On;
diff --git a/src/hid/gtk/gui-config.c b/src/hid/gtk/gui-config.c
index 5e8121b..36277eb 100644
--- a/src/hid/gtk/gui-config.c
+++ b/src/hid/gtk/gui-config.c
@@ -1430,16 +1430,16 @@ make_layer_group_string (LayerGroupType * lg)
 
   string = g_string_new ("");
 
-  for (group = 0; group < max_layer; group++)
+  for (group = 0; group < max_group; group++)
     {
       if (lg->Number[group] == 0)
 	continue;
       for (entry = 0; entry < lg->Number[group]; entry++)
 	{
 	  layer = lg->Entries[group][entry];
-	  if (layer == max_layer + COMPONENT_LAYER)
+	  if (layer == component_silk_layer)
 	    string = g_string_append (string, "c");
-	  else if (layer == max_layer + SOLDER_LAYER)
+	  else if (layer == solder_silk_layer)
 	    string = g_string_append (string, "s");
 	  else
 	    g_string_append_printf (string, "%d", layer + 1);
@@ -1447,7 +1447,7 @@ make_layer_group_string (LayerGroupType * lg)
 	  if (entry != lg->Number[group] - 1)
 	    string = g_string_append (string, ",");
 	}
-      if (group != max_layer - 1)
+      if (group != max_group - 1)
 	string = g_string_append (string, ":");
     }
   return g_string_free (string, FALSE);	/* Don't free string->str */
@@ -1471,7 +1471,7 @@ config_layers_apply (void)
   /* Get each layer name entry and dup if modified into the PCB layer names
      |  and, if to use as default, the Settings layer names.
    */
-  for (i = 0; i < max_layer; ++i)
+  for (i = 0; i < max_copper_layer; ++i)
     {
       layer = &PCB->Data->Layer[i];
       s = ghid_entry_get_text (layer_entry[i]);
@@ -1494,17 +1494,17 @@ config_layers_apply (void)
     {
       /* clear all entries and read layer by layer
        */
-      for (group = 0; group < max_layer; group++)
+      for (group = 0; group < max_group; group++)
 	layer_groups.Number[group] = 0;
 
-      for (i = 0; i < max_layer + 2; i++)
+      for (i = 0; i < max_copper_layer + 2; i++)
 	{
 	  group = config_layer_group[i] - 1;
 	  layer_groups.Entries[group][layer_groups.Number[group]++] = i;
 
-	  if (i == max_layer + COMPONENT_LAYER)
+	  if (i == component_silk_layer)
 	    componentgroup = group;
-	  else if (i == max_layer + SOLDER_LAYER)
+	  else if (i == solder_silk_layer)
 	    soldergroup = group;
 	}
 
@@ -1536,7 +1536,7 @@ config_layers_apply (void)
       s = make_layer_group_string (&PCB->LayerGroups);
       if (dup_string (&Settings.Groups, s))
 	{
-	  ParseGroupString (Settings.Groups, &Settings.LayerGroups, max_layer);
+	  ParseGroupString (Settings.Groups, &Settings.LayerGroups, max_copper_layer);
 	  ghidgui->config_modified = TRUE;
 	}
       g_free (s);
@@ -1551,7 +1551,7 @@ config_layer_group_button_state_update (void)
   /* Set button active corresponding to layer group state.
    */
   groups_holdoff = TRUE;
-  for (g = 0; g < max_layer; g++)
+  for (g = 0; g < max_group; g++)
     for (i = 0; i < layer_groups.Number[g]; i++)
       {
 /*			printf("layer %d in group %d\n", layer_groups.Entries[g][i], g +1); */
@@ -1604,7 +1604,7 @@ ghid_config_groups_changed(void)
   gtk_widget_show (scrolled_window);
 
 
-  table = gtk_table_new (max_layer + 3, max_layer + 1, FALSE);
+  table = gtk_table_new (max_copper_layer + 3, max_group + 1, FALSE);
   config_groups_table = table;
   gtk_table_set_row_spacings (GTK_TABLE (table), 3);
   gtk_scrolled_window_add_with_viewport (
@@ -1618,7 +1618,7 @@ ghid_config_groups_changed(void)
   gtk_table_attach_defaults (GTK_TABLE (table), label, 0, 1, 0, 1);
   gtk_misc_set_alignment (GTK_MISC (label), 1.0, 0.5);
 
-  for (i = 1; i < max_layer + 1; ++i)
+  for (i = 1; i < max_group + 1; ++i)
     {
 	if (i < 10)
 		snprintf (buf, sizeof (buf), "  %d", i);
@@ -1631,16 +1631,16 @@ ghid_config_groups_changed(void)
   /* Create a row of radio toggle buttons for layer.  So each layer
      |  can have an active radio button set for the group it needs to be in.
    */
-  for (layer = 0; layer < max_layer + 2; ++layer)
+  for (layer = 0; layer < max_copper_layer + 2; ++layer)
     {
-      if (layer == max_layer + COMPONENT_LAYER)
+      if (layer == component_silk_layer)
 	name = _("component side");
-      else if (layer == max_layer + SOLDER_LAYER)
+      else if (layer == solder_silk_layer)
 	name = _("solder side");
       else
 	name = UNKNOWN (PCB->Data->Layer[layer].Name);
 
-      if (layer >= max_layer)
+      if (layer >= max_copper_layer)
 	{
 	  label = gtk_label_new (name);
 	  gtk_misc_set_alignment (GTK_MISC (label), 0.0, 0.5);
@@ -1658,7 +1658,7 @@ ghid_config_groups_changed(void)
 	}
 
       group = NULL;
-      for (i = 0; i < max_layer; ++i)
+      for (i = 0; i < max_group; ++i)
 	{
 	  snprintf (buf, sizeof (buf), "%2.2d", i+1);
 	  button = gtk_radio_button_new_with_label (group, buf);
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index 2da5137..476b196 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -598,7 +598,7 @@ describe_location (LocationType X, LocationType Y)
 
   /* don't mess with silk objects! */
   if (type & SILK_TYPE &&
-      GetLayerNumber (PCB->Data, (LayerTypePtr) ptr1) >= max_layer)
+      GetLayerNumber (PCB->Data, (LayerTypePtr) ptr1) >= max_copper_layer)
     return NULL;
 
   if (type == PIN_TYPE || type == PAD_TYPE)
diff --git a/src/hid/gtk/gui-top-window.c b/src/hid/gtk/gui-top-window.c
index fa25836..f0456ea 100644
--- a/src/hid/gtk/gui-top-window.c
+++ b/src/hid/gtk/gui-top-window.c
@@ -378,7 +378,7 @@ ghid_update_toggle_flags ()
       a = gtk_action_group_get_action (ghidgui->main_actions, tmpnm);
       if (a != NULL)
 	{
-	  g_object_set_property (G_OBJECT (a), "visible", (i >= max_layer && i < MAX_LAYER) ? &setfalse : &settrue);
+	  g_object_set_property (G_OBJECT (a), "visible", (i >= max_copper_layer && i < MAX_LAYER) ? &setfalse : &settrue);
 	}
 
     }
@@ -1050,7 +1050,7 @@ ghid_make_programmed_menu_actions ()
     {
       layer_process (NULL, &text, NULL, i);
 #ifdef DEBUG_MENUS
-      printf ("ghid_make_programmed_menu_actions():  Added #%2d \"%s\".  max_layer = %d, MAX_LAYER = %d\n", i, text, max_layer, MAX_LAYER);
+      printf ("ghid_make_programmed_menu_actions():  Added #%2d \"%s\".  max_copper_layer = %d, MAX_LAYER = %d\n", i, text, max_copper_layer, MAX_LAYER);
 #endif
       /* name, stock_id, label, accelerator, tooltip, callback */
       layerview_toggle_entries[i].name = g_strdup_printf ("%s%d", LAYERVIEW, i);
@@ -1349,7 +1349,7 @@ layer_select_button_cb (GtkWidget * widget, LayerButtonSet * lb)
   PCB->SilkActive = (lb->index == LAYER_BUTTON_SILK);
   PCB->RatDraw = (lb->index == LAYER_BUTTON_RATS);
 
-  if (lb->index < max_layer)
+  if (lb->index < max_copper_layer)
     ChangeGroupVisibility (lb->index, true, true);
 
   layer_select_button_index = lb->index;
@@ -1421,10 +1421,10 @@ layer_enable_button_cb (GtkWidget * widget, gpointer data)
          |  Xt PCB code.
        */
       if ((group = GetGroupOfLayer (layer)) ==
-	  GetGroupOfLayer (MIN (max_layer, INDEXOFCURRENT)))
+	  GetGroupOfLayer (MIN (max_copper_layer, INDEXOFCURRENT)))
 	{
-	  for (i = (layer + 1) % (max_layer + 1); i != layer;
-	       i = (i + 1) % (max_layer + 1))
+	  for (i = (layer + 1) % (max_copper_layer + 1); i != layer;
+	       i = (i + 1) % (max_copper_layer + 1))
 	    if (PCB->Data->Layer[i].On == true &&
 		GetGroupOfLayer (i) != group)
 	      break;
@@ -1493,7 +1493,7 @@ ghid_show_layer_buttons(void)
 	for (i = 0; i < MAX_LAYER; ++i)
 	{
 		lb = &layer_buttons[i];
-		if (i < max_layer)
+		if (i < max_copper_layer)
 		  {
 			gtk_widget_show(lb->layer_enable_button);
 			gtk_widget_show(lb->radio_select_button);
@@ -1621,7 +1621,7 @@ ghid_layer_enable_buttons_update (void)
   /* Update layer button labels and active state to state inside of PCB
    */
   layer_enable_button_cb_hold_off = TRUE;
-  for (i = 0; i < max_layer; ++i)
+  for (i = 0; i < max_copper_layer; ++i)
     {
       lb = &layer_buttons[i];
       s = UNKNOWN (PCB->Data->Layer[i].Name);
@@ -1726,7 +1726,7 @@ ghid_layer_buttons_update (void)
   else
     layer = PCB->SilkActive ? LAYER_BUTTON_SILK : LayerStack[0];
 
-  if (layer < max_layer)
+  if (layer < max_copper_layer)
     active = PCB->Data->Layer[layer].On;
   else if (layer == LAYER_BUTTON_SILK)
     active = PCB->ElementOn;
@@ -1756,7 +1756,7 @@ ghid_layer_buttons_update (void)
 
       if (a != NULL)
 	{
-	  g_object_set_property (G_OBJECT (a), "visible", (i >= max_layer && i < MAX_LAYER) ? &setfalse : &settrue);
+	  g_object_set_property (G_OBJECT (a), "visible", (i >= max_copper_layer && i < MAX_LAYER) ? &setfalse : &settrue);
 	  gtk_toggle_action_set_active (GTK_TOGGLE_ACTION (a), (set && (i == layer) ) ? TRUE : FALSE);
 	  g_object_set_property (G_OBJECT (a), "label", &setlabel);
 	}
@@ -1765,7 +1765,7 @@ ghid_layer_buttons_update (void)
       a = gtk_action_group_get_action (ghidgui->main_actions, tmpnm);
       if (a != NULL)
 	{
-	  g_object_set_property (G_OBJECT (a), "visible", (i >= max_layer && i < MAX_LAYER) ? &setfalse : &settrue);
+	  g_object_set_property (G_OBJECT (a), "visible", (i >= max_copper_layer && i < MAX_LAYER) ? &setfalse : &settrue);
 	  gtk_toggle_action_set_active (GTK_TOGGLE_ACTION (a), set ? TRUE : FALSE);
 	  g_value_set_string (&setlabel, text);
 	  g_object_set_property (G_OBJECT (a), "label", &setlabel);
@@ -2833,7 +2833,7 @@ ToggleView (int argc, char **argv, int x, int y)
   else
     {
       l = -1;
-      for (i = 0; i < max_layer + 2; i++)
+      for (i = 0; i < max_copper_layer + 2; i++)
 	if (strcmp (argv[0], PCB->Data->Layer[i].Name) == 0)
 	  {
 	    l = i;
diff --git a/src/hid/lesstif/dialogs.c b/src/hid/lesstif/dialogs.c
index 6ab4b78..544a718 100644
--- a/src/hid/lesstif/dialogs.c
+++ b/src/hid/lesstif/dialogs.c
@@ -1368,10 +1368,10 @@ lgbutton_cb (Widget w, int ij, void *cbs)
 {
   int layer, group, k;
 
-  layer = ij / max_layer;
-  group = ij % max_layer;
+  layer = ij / max_group;
+  group = ij % max_group;
   group = MoveLayerToGroup (layer, group);
-  for (k = 0; k < max_layer; k++)
+  for (k = 0; k < max_group; k++)
     {
       if (k == group)
 	XmToggleButtonSetState (lgbuttons[layer][k], 1, 0);
@@ -1400,20 +1400,20 @@ lgbutton_expose (Widget w, XtPointer u, XmDrawingAreaCallbackStruct *cbs)
   XSetForeground (display, lg_gc, lgr.bg);
   XFillRectangle (display, win, lg_gc, 0, 0, lg_width, lg_height);
   XSetForeground (display, lg_gc, lgr.fg);
-  for (i=0; i<max_layer; i++)
+  for (i = 0; i < max_group; i++)
     XDrawLine(display, win, lg_gc, lg_c[i], 0, lg_c[i], lg_height);
-  for (i=1; i<max_layer+2; i++)
+  for (i = 1; i < max_copper_layer + 2; i++)
     XDrawLine(display, win, lg_gc, lg_label_width, lg_r[i], lg_width, lg_r[i]);
-  for (i=0; i<max_layer+2; i++)
+  for (i = 0; i < max_copper_layer + 2; i++)
     {
       int dir;
       XCharStruct size;
       int swidth;
       const char *name;
 
-      if (i == max_layer)
+      if (i == solder_silk_layer)
 	name = SOLDER_SIDE_NAME;
-      else if (i == max_layer + 1)
+      else if (i == component_silk_layer)
 	name = COMPONENT_SIDE_NAME;
       else
 	name = PCB->Data->Layer[i].Name;
@@ -1425,7 +1425,7 @@ lgbutton_expose (Widget w, XtPointer u, XmDrawingAreaCallbackStruct *cbs)
 		  name, strlen(name));
     }
   XSetForeground (display, lg_gc, lgr.sel);
-  for (i=0; i<max_layer+2; i++)
+  for (i = 0; i < max_copper_layer + 2; i++)
     {
       int c = lg_setcol[i];
       int x1 = lg_c[c] + 2;
@@ -1442,8 +1442,8 @@ lgbutton_input (Widget w, XtPointer u, XmDrawingAreaCallbackStruct *cbs)
   int layer, group;
   if (cbs->event->type != ButtonPress)
     return;
-  layer = cbs->event->xbutton.y * (max_layer+2) / lg_height;
-  group = (cbs->event->xbutton.x - lg_label_width) * max_layer / (lg_width - lg_label_width);
+  layer = cbs->event->xbutton.y * (max_copper_layer + 2) / lg_height;
+  group = (cbs->event->xbutton.x - lg_label_width) * max_group / (lg_width - lg_label_width);
   group = MoveLayerToGroup (layer, group);
   lg_setcol[layer] = group;
   lgbutton_expose (w, 0, 0);
@@ -1462,10 +1462,10 @@ lgbutton_resize (Widget w, XtPointer u, XmDrawingAreaCallbackStruct *cbs)
   lg_width = width;
   lg_height = height;
 
-  for (i=0; i<=max_layer; i++)
-    lg_c[i] = lg_label_width + (lg_width - lg_label_width) * i / max_layer;
-  for (i=0; i<=max_layer+2; i++)
-    lg_r[i] = lg_height * i / (max_layer+2);
+  for (i=0; i<=max_group; i++)
+    lg_c[i] = lg_label_width + (lg_width - lg_label_width) * i / max_group;
+  for (i=0; i<=max_copper_layer+2; i++)
+    lg_r[i] = lg_height * i / (max_copper_layer + 2);
   lgbutton_expose (w, 0, 0);
 }
 
@@ -1481,7 +1481,7 @@ lesstif_update_layer_groups ()
 
   memset (sets, 0, sizeof (sets));
 
-  for (i = 0; i < max_layer; i++)
+  for (i = 0; i < max_group; i++)
     for (j = 0; j < l->Number[i]; j++)
       {
 	sets[l->Entries[i][j]][i] = 1;
@@ -1489,16 +1489,16 @@ lesstif_update_layer_groups ()
       }
 
   lg_label_width = 0;
-  for (i=0; i<max_layer+2; i++)
+  for (i = 0; i < max_copper_layer + 2; i++)
     {
       int dir;
       XCharStruct size;
       int swidth;
       const char *name;
 
-      if (i == max_layer)
+      if (i == solder_silk_layer)
 	name = SOLDER_SIDE_NAME;
-      else if (i == max_layer + 1)
+      else if (i == component_silk_layer)
 	name = COMPONENT_SIDE_NAME;
       else
 	name = PCB->Data->Layer[i].Name;
@@ -1510,25 +1510,25 @@ lesstif_update_layer_groups ()
   lg_label_width += 4;
 
   n = 0;
-  stdarg(XmNwidth, lg_label_width + (lg_fa+lg_fd) * max_layer);
-  stdarg(XmNheight, (lg_fa+lg_fd) * (max_layer + 2));
+  stdarg(XmNwidth, lg_label_width + (lg_fa+lg_fd) * max_group);
+  stdarg(XmNheight, (lg_fa+lg_fd) * (max_copper_layer + 2));
   XtSetValues(lg_buttonform, args, n);
   lgbutton_expose (lg_buttonform, 0, 0);
 
 #if 0
-  for (i = 0; i < max_layer + 2; i++)
+  for (i = 0; i < max_copper_layer + 2; i++)
     {
       char *name = "unknown";
       n = 0;
-      if (i < max_layer)
+      if (i < max_copper_layer)
 	name = PCB->Data->Layer[i].Name;
-      else if (i == max_layer)
+      else if (i == solder_silk_layer)
 	name = SOLDER_SIDE_NAME;
-      else if (i == max_layer + 1)
+      else if (i == component_silk_layer)
 	name = COMPONENT_SIDE_NAME;
       stdarg (XmNlabelString, XmStringCreateLocalized (name));
       XtSetValues (lglabels[i], args, n);
-      for (j = 0; j < max_layer; j++)
+      for (j = 0; j < max_group; j++)
 	{
 	  if (sets[i][j] != XmToggleButtonGetState (lgbuttons[i][j]))
 	    {
@@ -1540,24 +1540,24 @@ lesstif_update_layer_groups ()
   for (i = 0; i < MAX_LAYER + 2; i++)
     for (j = 0; j < MAX_LAYER; j++)
       {
-	if (i < max_layer + 2 && j < max_layer)
+	if (i < max_copper_layer + 2 && j < max_group)
 	  {
 	    XtManageChild(lgbuttons[i][j]);
 	    n = 0;
-	    stdarg (XmNleftPosition, j * (max_layer + 2));
-	    stdarg (XmNrightPosition, (j + 1) * (max_layer + 2));
-	    stdarg (XmNtopPosition, i * max_layer);
-	    stdarg (XmNbottomPosition, (i + 1) * max_layer);
+	    stdarg (XmNleftPosition, j * (max_copper_layer + 2));
+	    stdarg (XmNrightPosition, (j + 1) * (max_copper_layer + 2));
+	    stdarg (XmNtopPosition, i * max_group);
+	    stdarg (XmNbottomPosition, (i + 1) * max_group);
 	    XtSetValues(lgbuttons[i][j], args, n);
 	  }
 	else
 	  XtUnmanageChild(lgbuttons[i][j]);
       }
   n = 0;
-  stdarg (XmNfractionBase, max_layer + 2);
+  stdarg (XmNfractionBase, max_copper_layer + 2);
   XtSetValues (layer_groups_form, args, n);
   n = 0;
-  stdarg (XmNfractionBase, max_layer * (max_layer + 2));
+  stdarg (XmNfractionBase, max_group * (max_copper_layer + 2));
   XtSetValues (lg_buttonform, args, n);
   XtManageChild(lg_buttonform);
 #endif
@@ -1588,7 +1588,7 @@ EditLayerGroups (int argc, char **argv, int x, int y)
     {
 
       n = 0;
-      stdarg (XmNfractionBase, max_layer + 2);
+      stdarg (XmNfractionBase, max_copper_layer + 2);
       stdarg (XmNtitle, "Layer Groups");
       layer_groups_form = XmCreateFormDialog (mainwind, "layers", args, n);
 
@@ -1611,7 +1611,7 @@ EditLayerGroups (int argc, char **argv, int x, int y)
 			 "layergroups", "LayerGroups",
 			 lg_resources, XtNumber(lg_resources), 0, 0);
 #if 0
-      stdarg (XmNfractionBase, max_layer * (MAX_LAYER + 2));
+      stdarg (XmNfractionBase, max_group * (MAX_LAYER + 2));
       lg_buttonform = XmCreateForm (layer_groups_form, "lgbutton", args, n);
 
       for (i = 0; i < MAX_LAYER + 2; i++)
@@ -1652,7 +1652,7 @@ EditLayerGroups (int argc, char **argv, int x, int y)
 
 	      XtAddCallback (lgbuttons[i][j], XmNvalueChangedCallback,
 			     (XtCallbackProc) lgbutton_cb,
-			     (XtPointer) (i * max_layer + j));
+			     (XtPointer) (i * max_group + j));
 	    }
 	}
 #endif
diff --git a/src/hid/lesstif/main.c b/src/hid/lesstif/main.c
index c270992..c73a26e 100644
--- a/src/hid/lesstif/main.c
+++ b/src/hid/lesstif/main.c
@@ -547,8 +547,8 @@ static int
 SwapSides (int argc, char **argv, int x, int y)
 {
   int old_shown_side = Settings.ShowSolderSide;
-  int comp_group = GetLayerGroupNumberByNumber (max_layer + COMPONENT_LAYER);
-  int solder_group = GetLayerGroupNumberByNumber (max_layer + SOLDER_LAYER);
+  int comp_group = GetLayerGroupNumberByNumber (component_silk_layer);
+  int solder_group = GetLayerGroupNumberByNumber (solder_silk_layer);
   int active_group = GetLayerGroupNumberByNumber (LayerStack[0]);
   int comp_showing =
     PCB->Data->Layer[PCB->LayerGroups.Entries[comp_group][0]].On;
@@ -2812,13 +2812,13 @@ static int
 lesstif_set_layer (const char *name, int group, int empty)
 {
   int idx = group;
-  if (idx >= 0 && idx < max_layer)
+  if (idx >= 0 && idx < max_group)
     {
       int n = PCB->LayerGroups.Number[group];
       for (idx = 0; idx < n-1; idx ++)
 	{
 	  int ni = PCB->LayerGroups.Entries[group][idx];
-	  if (ni >= 0 && ni < max_layer + 2
+	  if (ni >= 0 && ni < max_copper_layer + 2
 	      && PCB->Data->Layer[ni].On)
 	    break;
 	}
@@ -2836,7 +2836,7 @@ lesstif_set_layer (const char *name, int group, int empty)
   else
     autofade = 0;
 #endif
-  if (idx >= 0 && idx < max_layer + 2)
+  if (idx >= 0 && idx < max_copper_layer + 2)
     return pinout ? 1 : PCB->Data->Layer[idx].On;
   if (idx < 0)
     {
diff --git a/src/hid/lesstif/menu.c b/src/hid/lesstif/menu.c
index 5a43fa8..9983d42 100644
--- a/src/hid/lesstif/menu.c
+++ b/src/hid/lesstif/menu.c
@@ -275,7 +275,7 @@ LayersChanged (int argc, char **argv, int x, int y)
 	    }
 	  XtSetValues (lb->w[i], args, n);
 
-	  if (i >= max_layer && i < MAX_LAYER)
+	  if (i >= max_copper_layer && i < MAX_LAYER)
 	    XtUnmanageChild(lb->w[i]);
 	  else
 	    XtManageChild(lb->w[i]);
@@ -365,14 +365,14 @@ layer_button_callback (Widget w, int layer, XmPushButtonCallbackStruct * pbcs)
     }
 
   show_one_layer_button (layer, set);
-  if (layer < max_layer)
+  if (layer < max_copper_layer)
     {
       int i;
       int group = GetLayerGroupNumberByNumber (layer);
       for (i = 0; i < PCB->LayerGroups.Number[group]; i++)
 	{
 	  l = PCB->LayerGroups.Entries[group][i];
-	  if (l != layer && l < max_layer)
+	  if (l != layer && l < max_copper_layer)
 	    {
 	      show_one_layer_button (l, set);
 	      PCB->Data->Layer[l].On = set;
@@ -390,7 +390,7 @@ layerpick_button_callback (Widget w, int layer,
   char *name;
   PCB->RatDraw = (layer == LB_RATS);
   PCB->SilkActive = (layer == LB_SILK);
-  if (layer < max_layer)
+  if (layer < max_copper_layer)
     ChangeGroupVisibility (layer, 1, 1);
   for (l = 0; l < num_layer_buttons; l++)
     {
@@ -497,7 +497,7 @@ ToggleView (int argc, char **argv, int x, int y)
   else
     {
       l = -1;
-      for (i = 0; i < max_layer + 2; i++)
+      for (i = 0; i < max_copper_layer + 2; i++)
 	if (strcmp (argv[0], PCB->Data->Layer[i].Name) == 0)
 	  {
 	    l = i;
diff --git a/src/hid/nelma/nelma.c b/src/hid/nelma/nelma.c
index 688adce..4a323f5 100644
--- a/src/hid/nelma/nelma.c
+++ b/src/hid/nelma/nelma.c
@@ -249,7 +249,7 @@ nelma_write_space(FILE * out)
 	z = 10;
 	for (i = 0; i < MAX_LAYER; i++)
 		if (nelma_export_group[i]) {
-			idx = (i >= 0 && i < max_layer) ?
+			idx = (i >= 0 && i < max_group) ?
 				PCB->LayerGroups.Entries[i][0] : i;
 			ext = layer_type_to_file_name(idx);
 
@@ -319,7 +319,7 @@ nelma_write_nets(FILE * out)
 
 			for (i = 0; i < MAX_LAYER; i++)
 				if (nelma_export_group[i]) {
-					idx = (i >= 0 && i < max_layer) ?
+					idx = (i >= 0 && i < max_group) ?
 						PCB->LayerGroups.Entries[i][0] : i;
 					ext = layer_type_to_file_name(idx);
 
@@ -397,7 +397,7 @@ nelma_write_layers(FILE * out)
 	z = 10;
 	for (i = 0; i < MAX_LAYER; i++)
 		if (nelma_export_group[i]) {
-			idx = (i >= 0 && i < max_layer) ?
+			idx = (i >= 0 && i < max_group) ?
 				PCB->LayerGroups.Entries[i][0] : i;
 			ext = layer_type_to_file_name(idx);
 
@@ -437,7 +437,7 @@ nelma_write_object(FILE * out, LibraryEntryTypePtr pin)
 
 	for (i = 0; i < MAX_LAYER; i++)
 		if (nelma_export_group[i]) {
-			idx = (i >= 0 && i < max_layer) ?
+			idx = (i >= 0 && i < max_group) ?
 				PCB->LayerGroups.Entries[i][0] : i;
 			ext = layer_type_to_file_name(idx);
 
@@ -522,7 +522,7 @@ nelma_choose_groups()
 	/* Set entire array to 0 (don't export any layer groups by default */
 	memset(nelma_export_group, 0, sizeof(nelma_export_group));
 
-	for (n = 0; n < max_layer; n++) {
+	for (n = 0; n < max_copper_layer; n++) {
 		layer = &PCB->Data->Layer[n];
 
 		if (layer->LineN || layer->TextN || layer->ArcN ||
@@ -661,7 +661,7 @@ nelma_do_export(HID_Attr_Val * options)
 			nelma_cur_group = i;
 
 			/* magic */
-			idx = (i >= 0 && i < max_layer) ?
+			idx = (i >= 0 && i < max_group) ?
 				PCB->LayerGroups.Entries[i][0] : i;
 
 			nelma_start_png(nelma_basename,
@@ -701,7 +701,7 @@ nelma_do_export(HID_Attr_Val * options)
 static int 
 nelma_set_layer(const char *name, int group, int empty)
 {
-	int             idx = (group >= 0 && group < max_layer) ?
+	int             idx = (group >= 0 && group < max_group) ?
 	PCB->LayerGroups.Entries[group][0] : group;
 
 	if (SL_TYPE (idx) == SL_FINISHED) {
diff --git a/src/hid/png/png.c b/src/hid/png/png.c
index 0c292cd..666d893 100644
--- a/src/hid/png/png.c
+++ b/src/hid/png/png.c
@@ -250,10 +250,10 @@ static int comp_layer, solder_layer;
 static int
 group_for_layer (int l)
 {
-  if (l < max_layer + 2 && l >= 0)
+  if (l < max_copper_layer + 2 && l >= 0)
     return GetLayerGroupNumberByNumber (l);
   /* else something unique */
-  return max_layer + 3 + l;
+  return max_group + 3 + l;
 }
 
 static int
@@ -265,7 +265,7 @@ layer_sort (const void *va, const void *vb)
   int bl = group_for_layer (b);
   int d = bl - al;
 
-  if (a >= 0 && a <= max_layer + 1)
+  if (a >= 0 && a <= max_copper_layer + 1)
     {
       int aside = (al == solder_layer ? 0 : al == comp_layer ? 2 : 1);
       int bside = (bl == solder_layer ? 0 : bl == comp_layer ? 2 : 1);
@@ -330,15 +330,15 @@ png_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
   memset (print_group, 0, sizeof (print_group));
   memset (print_layer, 0, sizeof (print_layer));
 
-  for (i = 0; i < max_layer; i++)
+  for (i = 0; i < max_copper_layer; i++)
     {
       LayerType *layer = PCB->Data->Layer + i;
       if (layer->LineN || layer->TextN || layer->ArcN || layer->PolygonN)
 	print_group[GetLayerGroupNumberByNumber (i)] = 1;
     }
-  print_group[GetLayerGroupNumberByNumber (max_layer)] = 1;
-  print_group[GetLayerGroupNumberByNumber (max_layer + 1)] = 1;
-  for (i = 0; i < max_layer; i++)
+  print_group[GetLayerGroupNumberByNumber (solder_silk_layer)] = 1;
+  print_group[GetLayerGroupNumberByNumber (component_silk_layer)] = 1;
+  for (i = 0; i < max_copper_layer; i++)
     if (print_group[GetLayerGroupNumberByNumber (i)])
       print_layer[i] = 1;
 
@@ -352,9 +352,9 @@ png_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
       CLEAR_FLAG (SHOWMASKFLAG, PCB);
       Settings.ShowSolderSide = 0;
 
-      comp_layer = GetLayerGroupNumberByNumber (max_layer + COMPONENT_LAYER);
-      solder_layer = GetLayerGroupNumberByNumber (max_layer + SOLDER_LAYER);
-      qsort (LayerStack, max_layer, sizeof (LayerStack[0]), layer_sort);
+      comp_layer = GetLayerGroupNumberByNumber (component_silk_layer);
+      solder_layer = GetLayerGroupNumberByNumber (solder_silk_layer);
+      qsort (LayerStack, max_copper_layer, sizeof (LayerStack[0]), layer_sort);
 
       CLEAR_FLAG(THINDRAWFLAG, PCB);
       CLEAR_FLAG(THINDRAWPOLYFLAG, PCB);
@@ -393,7 +393,7 @@ png_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
   if (!photo_mode && Settings.ShowSolderSide)
     {
       int i, j;
-      for (i=0, j=max_layer-1; i<j; i++, j--)
+      for (i=0, j=max_copper_layer-1; i<j; i++, j--)
 	{
 	  int k = LayerStack[i];
 	  LayerStack[i] = LayerStack[j];
@@ -889,7 +889,7 @@ png_set_layer (const char *name, int group, int empty)
 {
   int idx = (group >= 0
 	     && group <
-	     max_layer) ? PCB->LayerGroups.Entries[group][0] : group;
+	     max_group) ? PCB->LayerGroups.Entries[group][0] : group;
 
   if (SL_TYPE (idx) == SL_FINISHED)
     return 0;
@@ -897,7 +897,7 @@ png_set_layer (const char *name, int group, int empty)
   if (name == 0)
     name = PCB->Data->Layer[idx].Name;
 
-  if (idx >= 0 && idx < max_layer && !print_layer[idx])
+  if (idx >= 0 && idx < max_copper_layer && !print_layer[idx])
     return 0;
   if (SL_TYPE (idx) == SL_ASSY || SL_TYPE (idx) == SL_FAB)
     return 0;
diff --git a/src/hid/ps/eps.c b/src/hid/ps/eps.c
index d67947d..3abe356 100644
--- a/src/hid/ps/eps.c
+++ b/src/hid/ps/eps.c
@@ -87,10 +87,10 @@ static int comp_layer, solder_layer;
 static int
 group_for_layer (int l)
 {
-  if (l < max_layer + 2 && l >= 0)
+  if (l < max_copper_layer + 2 && l >= 0)
     return GetLayerGroupNumberByNumber (l);
   /* else something unique */
-  return max_layer + 3 + l;
+  return max_group + 3 + l;
 }
 
 static int
@@ -102,7 +102,7 @@ layer_sort (const void *va, const void *vb)
   int bl = group_for_layer (b);
   int d = bl - al;
 
-  if (a >= 0 && a <= max_layer + 1)
+  if (a >= 0 && a <= max_copper_layer + 1)
     {
       int aside = (al == solder_layer ? 0 : al == comp_layer ? 2 : 1);
       int bside = (bl == solder_layer ? 0 : bl == comp_layer ? 2 : 1);
@@ -146,7 +146,7 @@ eps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
   memset (print_layer, 0, sizeof (print_layer));
 
   /* Figure out which layers actually have stuff on them.  */
-  for (i = 0; i < max_layer; i++)
+  for (i = 0; i < max_copper_layer; i++)
     {
       LayerType *layer = PCB->Data->Layer + i;
       if (layer->On)
@@ -158,7 +158,7 @@ eps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
      erase logic.  Otherwise, we have to use the expensive multi-mask
      erase.  */
   fast_erase = 0;
-  for (i = 0; i < max_layer; i++)
+  for (i = 0; i < max_group; i++)
     if (print_group[i])
       fast_erase ++;
 
@@ -166,7 +166,7 @@ eps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
      layer to get the pins.  */
   if (fast_erase == 0)
     {
-      print_group[GetLayerGroupNumberByNumber (max_layer + COMPONENT_LAYER)] = 1;
+      print_group[GetLayerGroupNumberByNumber (component_silk_layer)] = 1;
       fast_erase = 1;
     }
 
@@ -175,7 +175,7 @@ eps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
 
   /* Now, for each group we're printing, mark its layers for
      printing.  */
-  for (i = 0; i < max_layer; i++)
+  for (i = 0; i < max_copper_layer; i++)
     if (print_group[GetLayerGroupNumberByNumber (i)])
       print_layer[i] = 1;
 
@@ -191,9 +191,9 @@ eps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
   as_shown = options[HA_as_shown].int_value;
   if (!options[HA_as_shown].int_value)
     {
-      comp_layer = GetLayerGroupNumberByNumber (max_layer + COMPONENT_LAYER);
-      solder_layer = GetLayerGroupNumberByNumber (max_layer + SOLDER_LAYER);
-      qsort (LayerStack, max_layer, sizeof (LayerStack[0]), layer_sort);
+      comp_layer = GetLayerGroupNumberByNumber (component_silk_layer);
+      solder_layer = GetLayerGroupNumberByNumber (solder_silk_layer);
+      qsort (LayerStack, max_copper_layer, sizeof (LayerStack[0]), layer_sort);
     }
   fprintf (f, "%%!PS-Adobe-3.0 EPSF-3.0\n");
   linewidth = -1;
@@ -312,7 +312,7 @@ eps_set_layer (const char *name, int group, int empty)
 {
   int idx = (group >= 0
 	     && group <
-	     max_layer) ? PCB->LayerGroups.Entries[group][0] : group;
+	     max_group) ? PCB->LayerGroups.Entries[group][0] : group;
 
   if (SL_TYPE (idx) == SL_FINISHED)
     return 0;
@@ -320,7 +320,7 @@ eps_set_layer (const char *name, int group, int empty)
   if (name == 0)
     name = PCB->Data->Layer[idx].Name;
 
-  if (idx >= 0 && idx < max_layer && !print_layer[idx])
+  if (idx >= 0 && idx < max_copper_layer && !print_layer[idx])
     return 0;
   if (SL_TYPE (idx) == SL_ASSY || SL_TYPE (idx) == SL_FAB)
     return 0;
diff --git a/src/hid/ps/ps.c b/src/hid/ps/ps.c
index 2a7a4d7..dffbd68 100644
--- a/src/hid/ps/ps.c
+++ b/src/hid/ps/ps.c
@@ -231,10 +231,10 @@ ps_get_export_options (int *n)
 static int
 group_for_layer (int l)
 {
-  if (l < max_layer + 2 && l >= 0)
+  if (l < max_copper_layer + 2 && l >= 0)
     return GetLayerGroupNumberByNumber (l);
   /* else something unique */
-  return max_layer + 3 + l;
+  return max_group + 3 + l;
 }
 
 static int
@@ -478,7 +478,7 @@ ps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
 
   outline_layer = NULL;
 
-  for (i = 0; i < max_layer; i++)
+  for (i = 0; i < max_copper_layer; i++)
     {
       LayerType *layer = PCB->Data->Layer + i;
       if (layer->LineN || layer->TextN || layer->ArcN || layer->PolygonN)
@@ -491,14 +491,14 @@ ps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
 	  outline_layer = layer;
 	}
     }
-  print_group[GetLayerGroupNumberByNumber (max_layer)] = 1;
-  print_group[GetLayerGroupNumberByNumber (max_layer + 1)] = 1;
-  for (i = 0; i < max_layer; i++)
+  print_group[GetLayerGroupNumberByNumber (solder_silk_layer)] = 1;
+  print_group[GetLayerGroupNumberByNumber (component_silk_layer)] = 1;
+  for (i = 0; i < max_copper_layer; i++)
     if (print_group[GetLayerGroupNumberByNumber (i)])
       print_layer[i] = 1;
 
   memcpy (saved_layer_stack, LayerStack, sizeof (LayerStack));
-  qsort (LayerStack, max_layer, sizeof (LayerStack[0]), layer_sort);
+  qsort (LayerStack, max_copper_layer, sizeof (LayerStack[0]), layer_sort);
 
   lastgroup = -1;
   linewidth = -1;
@@ -635,7 +635,7 @@ ps_set_layer (const char *name, int group, int empty)
   time_t currenttime;
   int idx = (group >= 0
 	     && group <
-	     max_layer) ? PCB->LayerGroups.Entries[group][0] : group;
+	     max_group) ? PCB->LayerGroups.Entries[group][0] : group;
 
   if (SL_TYPE (idx) == SL_FINISHED)
     return 0;
@@ -646,7 +646,7 @@ ps_set_layer (const char *name, int group, int empty)
   if (empty)
     return 0;
 
-  if (idx >= 0 && idx < max_layer && !print_layer[idx])
+  if (idx >= 0 && idx < max_copper_layer && !print_layer[idx])
     return 0;
 
   if (strcmp (name, "invisible") == 0)
@@ -728,7 +728,7 @@ ps_set_layer (const char *name, int group, int empty)
 	mirror_this = 1 - mirror_this;
       if (automirror
 	  &&
-	  ((idx >= 0 && group == GetLayerGroupNumberByNumber (max_layer))
+	  ((idx >= 0 && group == GetLayerGroupNumberByNumber (solder_silk_layer))
 	   || (idx < 0 && SL_SIDE (idx) == SL_BOTTOM_SIDE)))
 	mirror_this = 1 - mirror_this;
 
diff --git a/src/line.c b/src/line.c
index 943660a..d1faaec 100644
--- a/src/line.c
+++ b/src/line.c
@@ -320,13 +320,13 @@ drc_lines (PointTypePtr end, bool way)
       length = abs (dy);
     }
   group = GetGroupOfLayer (INDEXOFCURRENT);
-  comp = max_layer + 10;	/* this out-of-range group might save a call */
-  if (GetLayerGroupNumberByNumber (max_layer + SOLDER_LAYER) == group)
+  comp = max_group + 10;	/* this out-of-range group might save a call */
+  if (GetLayerGroupNumberByNumber (solder_silk_layer) == group)
     info.solder = true;
   else
     {
       info.solder = false;
-      comp = GetLayerGroupNumberByNumber (max_layer + COMPONENT_LAYER);
+      comp = GetLayerGroupNumberByNumber (component_silk_layer);
     }
   temp = length;
   /* assume the worst */
@@ -490,7 +490,7 @@ EnforceLineDRC (void)
   float r1, r2;
 
   if ( gui->mod1_is_pressed() || gui->control_is_pressed () || PCB->RatDraw
-      || INDEXOFCURRENT >= max_layer)
+      || INDEXOFCURRENT >= max_copper_layer)
     return;
   rs.X = r45.X = Crosshair.X;
   rs.Y = r45.Y = Crosshair.Y;
diff --git a/src/macro.h b/src/macro.h
index 819d202..ddb1fb3 100644
--- a/src/macro.h
+++ b/src/macro.h
@@ -161,18 +161,18 @@
  */
 #define	LAYER_ON_STACK(n)	(&PCB->Data->Layer[LayerStack[(n)]])
 #define LAYER_PTR(n)            (&PCB->Data->Layer[(n)])
-#define	CURRENT			(PCB->SilkActive ? &PCB->Data->Layer[max_layer + \
-				(Settings.ShowSolderSide ? SOLDER_LAYER : COMPONENT_LAYER)] \
+#define	CURRENT			(PCB->SilkActive ? &PCB->Data->Layer[ \
+				(Settings.ShowSolderSide ? solder_silk_layer : component_silk_layer)] \
 				: LAYER_ON_STACK(0))
-#define	INDEXOFCURRENT		(PCB->SilkActive ? max_layer + \
-				(Settings.ShowSolderSide ? SOLDER_LAYER : COMPONENT_LAYER) \
+#define	INDEXOFCURRENT		(PCB->SilkActive ? \
+				(Settings.ShowSolderSide ? solder_silk_layer : component_silk_layer) \
 				: LayerStack[0])
-#define SILKLAYER		Layer[max_layer + \
-				(Settings.ShowSolderSide ? SOLDER_LAYER : COMPONENT_LAYER)]
-#define BACKSILKLAYER		Layer[max_layer + \
-				(Settings.ShowSolderSide ? COMPONENT_LAYER : SOLDER_LAYER)]
+#define SILKLAYER		Layer[ \
+				(Settings.ShowSolderSide ? solder_silk_layer : component_silk_layer)]
+#define BACKSILKLAYER		Layer[ \
+				(Settings.ShowSolderSide ? component_silk_layer : solder_silk_layer)]
 
-#define TEST_SILK_LAYER(layer)	(GetLayerNumber (PCB->Data, layer) >= max_layer)
+#define TEST_SILK_LAYER(layer)	(GetLayerNumber (PCB->Data, layer) >= max_copper_layer)
 
 
 /* ---------------------------------------------------------------------------
@@ -418,49 +418,49 @@ extern int mem_any_set (unsigned char *, int);
 #define	ALLLINE_LOOP(top) do	{		\
 	Cardinal		l;			\
 	LayerTypePtr	layer = (top)->Layer;		\
-	for (l = 0; l < max_layer + 2; l++, layer++)	\
+	for (l = 0; l < max_copper_layer + 2; l++, layer++)	\
 	{ \
 		LINE_LOOP(layer)
 
 #define ALLARC_LOOP(top) do {		\
 	Cardinal		l;			\
 	LayerTypePtr	layer = (top)->Layer;		\
-	for (l =0; l < max_layer + 2; l++, layer++)		\
+	for (l =0; l < max_copper_layer + 2; l++, layer++)		\
 	{ \
 		ARC_LOOP(layer)
 
 #define	ALLPOLYGON_LOOP(top)	do {		\
 	Cardinal		l;			\
 	LayerTypePtr	layer = (top)->Layer;		\
-	for (l = 0; l < max_layer + 2; l++, layer++)	\
+	for (l = 0; l < max_copper_layer + 2; l++, layer++)	\
 	{ \
 		POLYGON_LOOP(layer)
 
 #define	COPPERLINE_LOOP(top) do	{		\
 	Cardinal		l;			\
 	LayerTypePtr	layer = (top)->Layer;		\
-	for (l = 0; l < max_layer; l++, layer++)	\
+	for (l = 0; l < max_copper_layer; l++, layer++)	\
 	{ \
 		LINE_LOOP(layer)
 
 #define COPPERARC_LOOP(top) do	{		\
 	Cardinal		l;			\
 	LayerTypePtr	layer = (top)->Layer;		\
-	for (l =0; l < max_layer; l++, layer++)		\
+	for (l =0; l < max_copper_layer; l++, layer++)		\
 	{ \
 		ARC_LOOP(layer)
 
 #define	COPPERPOLYGON_LOOP(top) do	{		\
 	Cardinal		l;			\
 	LayerTypePtr	layer = (top)->Layer;		\
-	for (l = 0; l < max_layer; l++, layer++)	\
+	for (l = 0; l < max_copper_layer; l++, layer++)	\
 	{ \
 		POLYGON_LOOP(layer)
 
 #define	SILKLINE_LOOP(top) do	{		\
 	Cardinal		l;			\
 	LayerTypePtr	layer = (top)->Layer;		\
-	layer += max_layer;				\
+	layer += max_copper_layer;			\
 	for (l = 0; l < 2; l++, layer++)		\
 	{ \
 		LINE_LOOP(layer)
@@ -468,7 +468,7 @@ extern int mem_any_set (unsigned char *, int);
 #define SILKARC_LOOP(top) do	{		\
 	Cardinal		l;			\
 	LayerTypePtr	layer = (top)->Layer;		\
-	layer += max_layer;				\
+	layer += max_copper_layer;			\
 	for (l = 0; l < 2; l++, layer++)		\
 	{ \
 		ARC_LOOP(layer)
@@ -476,7 +476,7 @@ extern int mem_any_set (unsigned char *, int);
 #define	SILKPOLYGON_LOOP(top) do	{		\
 	Cardinal		l;			\
 	LayerTypePtr	layer = (top)->Layer;		\
-	layer += max_layer;				\
+	layer += max_copper_layer;			\
 	for (l = 0; l < 2; l++, layer++)		\
 	{ \
 		POLYGON_LOOP(layer)
@@ -484,14 +484,14 @@ extern int mem_any_set (unsigned char *, int);
 #define	ALLTEXT_LOOP(top)	do {		\
 	Cardinal		l;			\
 	LayerTypePtr	layer = (top)->Layer;		\
-	for (l = 0; l < max_layer + 2; l++, layer++)	\
+	for (l = 0; l < max_copper_layer + 2; l++, layer++)	\
 	{ \
 		TEXT_LOOP(layer)
 
 #define	VISIBLELINE_LOOP(top) do	{		\
 	Cardinal		l;			\
 	LayerTypePtr	layer = (top)->Layer;		\
-	for (l = 0; l < max_layer + 2; l++, layer++)	\
+	for (l = 0; l < max_copper_layer + 2; l++, layer++)	\
 	{ \
 		if (layer->On)				\
 			LINE_LOOP(layer)
@@ -499,7 +499,7 @@ extern int mem_any_set (unsigned char *, int);
 #define	VISIBLEARC_LOOP(top) do	{		\
 	Cardinal		l;			\
 	LayerTypePtr	layer = (top)->Layer;		\
-	for (l = 0; l < max_layer + 2; l++, layer++)	\
+	for (l = 0; l < max_copper_layer + 2; l++, layer++)	\
 	{ \
 		if (layer->On)				\
 			ARC_LOOP(layer)
@@ -507,7 +507,7 @@ extern int mem_any_set (unsigned char *, int);
 #define	VISIBLETEXT_LOOP(board) do	{		\
 	Cardinal		l;			\
 	LayerTypePtr	layer = (board)->Data->Layer;		\
-	for (l = 0; l < max_layer + 2; l++, layer++)	\
+	for (l = 0; l < max_copper_layer + 2; l++, layer++)	\
 	{ \
                 TEXT_LOOP(layer);                                      \
                   if (TEXT_IS_VISIBLE((board), layer, text))
@@ -515,7 +515,7 @@ extern int mem_any_set (unsigned char *, int);
 #define	VISIBLEPOLYGON_LOOP(top) do	{	\
 	Cardinal		l;			\
 	LayerTypePtr	layer = (top)->Layer;		\
-	for (l = 0; l < max_layer + 2; l++, layer++)	\
+	for (l = 0; l < max_copper_layer + 2; l++, layer++)	\
 	{ \
 		if (layer->On)				\
 			POLYGON_LOOP(layer)
@@ -548,7 +548,7 @@ extern int mem_any_set (unsigned char *, int);
 		LayerTypePtr layer;		\
 		Cardinal number; 		\
 		number = ((PCBTypePtr)(data->pcb))->LayerGroups.Entries[(group)][entry]; \
-		if (number >= max_layer)	\
+		if (number >= max_copper_layer)	\
 		  continue;			\
 		layer = &data->Layer[number];
 
diff --git a/src/misc.c b/src/misc.c
index 34d103c..faeefa8 100644
--- a/src/misc.c
+++ b/src/misc.c
@@ -504,7 +504,7 @@ IsDataEmpty (DataTypePtr Data)
 
   hasNoObjects = (Data->ViaN == 0);
   hasNoObjects &= (Data->ElementN == 0);
-  for (i = 0; i < max_layer + 2; i++)
+  for (i = 0; i < max_copper_layer + 2; i++)
     hasNoObjects = hasNoObjects &&
       Data->Layer[i].LineN == 0 &&
       Data->Layer[i].ArcN == 0 &&
@@ -1011,11 +1011,11 @@ PushOnTopOfLayerStack (int NewTop)
 {
   int i;
 
-  /* ignore COMPONENT_LAYER and SOLDER_LAYER */
-  if (NewTop < max_layer)
+  /* ignore silk layers */
+  if (NewTop < max_copper_layer)
     {
       /* first find position of passed one */
-      for (i = 0; i < max_layer; i++)
+      for (i = 0; i < max_copper_layer; i++)
         if (LayerStack[i] == NewTop)
           break;
 
@@ -1045,13 +1045,13 @@ ChangeGroupVisibility (int Layer, bool On, bool ChangeStackOrder)
             Layer, On, ChangeStackOrder);
 
   /* decrement 'i' to keep stack in order of layergroup */
-  if ((group = GetGroupOfLayer (Layer)) < max_layer)
+  if ((group = GetGroupOfLayer (Layer)) < max_group)
     for (i = PCB->LayerGroups.Number[group]; i;)
       {
         int layer = PCB->LayerGroups.Entries[group][--i];
 
         /* don't count the passed member of the group */
-        if (layer != Layer && layer < max_layer)
+        if (layer != Layer && layer < max_copper_layer)
           {
             PCB->Data->Layer[layer].On = On;
 
@@ -1110,9 +1110,9 @@ LayerStringToLayerStack (char *s)
 	}
     }
 
-  for (i = 0; i < max_layer + 2; i++)
+  for (i = 0; i < max_copper_layer + 2; i++)
     {
-      if (i < max_layer)
+      if (i < max_copper_layer)
         LayerStack[i] = i;
       PCB->Data->Layer[i].On = false;
     }
@@ -1149,7 +1149,7 @@ LayerStringToLayerStack (char *s)
       else
 	{
 	  int found = 0;
-	  for (lno = 0; lno < max_layer; lno++)
+	  for (lno = 0; lno < max_copper_layer; lno++)
 	    if (strcasecmp (args[i], PCB->Data->Layer[lno].Name) == 0)
 	      {
 		ChangeGroupVisibility (lno, true, true);
@@ -1163,7 +1163,7 @@ LayerStringToLayerStack (char *s)
 		{
 		  fprintf (stderr, "Named layers in this board are:\n");
 		  listed_layers = 1;
-		  for (lno=0; lno < max_layer; lno ++)
+		  for (lno=0; lno < max_copper_layer; lno ++)
 		    fprintf(stderr, "\t%s\n", PCB->Data->Layer[lno].Name);
 		  fprintf(stderr, "Also: component, solder, rats, invisible, pins, vias, elements or silk, mask, solderside.\n");
 		}
@@ -1174,20 +1174,21 @@ LayerStringToLayerStack (char *s)
 
 /* ----------------------------------------------------------------------
  * lookup the group to which a layer belongs to
- * returns max_layer if no group is found
+ * returns max_group if no group is found, or is
+ * passed Layer is equal to max_copper_layer
  */
 int
 GetGroupOfLayer (int Layer)
 {
   int group, i;
 
-  if (Layer == max_layer)
-    return (Layer);
-  for (group = 0; group < max_layer; group++)
+  if (Layer == max_copper_layer)
+    return max_group;
+  for (group = 0; group < max_group; group++)
     for (i = 0; i < PCB->LayerGroups.Number[group]; i++)
       if (PCB->LayerGroups.Entries[group][i] == Layer)
         return (group);
-  return (max_layer);
+  return max_group;
 }
 
 
@@ -1208,7 +1209,7 @@ GetLayerGroupNumberByNumber (Cardinal Layer)
 {
   int group, entry;
 
-  for (group = 0; group < max_layer; group++)
+  for (group = 0; group < max_group; group++)
     for (entry = 0; entry < PCB->LayerGroups.Number[group]; entry++)
       if (PCB->LayerGroups.Entries[group][entry] == Layer)
         return (group);
@@ -1343,9 +1344,9 @@ ResetStackAndVisibility (void)
   int comp_group;
   Cardinal i;
 
-  for (i = 0; i < max_layer + 2; i++)
+  for (i = 0; i < max_copper_layer + 2; i++)
     {
-      if (i < max_layer)
+      if (i < max_copper_layer)
         LayerStack[i] = i;
       PCB->Data->Layer[i].On = true;
     }
@@ -1356,7 +1357,7 @@ ResetStackAndVisibility (void)
   PCB->RatOn = true;
 
   /* Bring the component group to the front and make it active.  */
-  comp_group = GetLayerGroupNumberByNumber (max_layer + COMPONENT_LAYER);
+  comp_group = GetLayerGroupNumberByNumber (component_silk_layer);
   ChangeGroupVisibility (PCB->LayerGroups.Entries[comp_group][0], 1, 1);
 }
 
@@ -1382,9 +1383,9 @@ SaveStackAndVisibility (void)
                "yet restored.  cnt = %d\n", SavedStack.cnt);
     }
 
-  for (i = 0; i < max_layer + 2; i++)
+  for (i = 0; i < max_copper_layer + 2; i++)
     {
-      if (i < max_layer)
+      if (i < max_copper_layer)
         SavedStack.LayerStack[i] = LayerStack[i];
       SavedStack.LayerOn[i] = PCB->Data->Layer[i].On;
     }
@@ -1416,9 +1417,9 @@ RestoreStackAndVisibility (void)
                " wrong.  cnt = %d\n", SavedStack.cnt);
     }
 
-  for (i = 0; i < max_layer + 2; i++)
+  for (i = 0; i < max_copper_layer + 2; i++)
     {
-      if (i < max_layer)
+      if (i < max_copper_layer)
         LayerStack[i] = SavedStack.LayerStack[i];
       PCB->Data->Layer[i].On = SavedStack.LayerOn[i];
     }
@@ -1769,14 +1770,14 @@ MoveLayerToGroup (int layer, int group)
 {
   int prev, i, j;
 
-  if (layer < 0 || layer > max_layer + 1)
+  if (layer < 0 || layer > max_copper_layer + 1)
     return -1;
   prev = GetLayerGroupNumberByNumber (layer);
-  if ((layer == max_layer
-       && group == GetLayerGroupNumberByNumber (max_layer + 1))
-      || (layer == max_layer + 1
-          && group == GetLayerGroupNumberByNumber (max_layer))
-      || (group < 0 || group >= max_layer) || (prev == group))
+  if ((layer == solder_silk_layer
+        && group == GetLayerGroupNumberByNumber (component_silk_layer))
+      || (layer == component_silk_layer
+          && group == GetLayerGroupNumberByNumber (solder_silk_layer))
+      || (group < 0 || group >= max_group) || (prev == group))
     return prev;
 
   /* Remove layer from prev group */
@@ -1802,7 +1803,7 @@ LayerGroupsToString (LayerGroupTypePtr lg)
   char *cp = buf;
   char sep = 0;
   int group, entry;
-  for (group = 0; group < max_layer; group++)
+  for (group = 0; group < max_group; group++)
     if (PCB->LayerGroups.Number[group])
       {
         if (sep)
@@ -1811,11 +1812,11 @@ LayerGroupsToString (LayerGroupTypePtr lg)
         for (entry = 0; entry < PCB->LayerGroups.Number[group]; entry++)
           {
             int layer = PCB->LayerGroups.Entries[group][entry];
-            if (layer == max_layer + COMPONENT_LAYER)
+            if (layer == component_silk_layer)
               {
                 *cp++ = 'c';
               }
-            else if (layer == max_layer + SOLDER_LAYER)
+            else if (layer == solder_silk_layer)
               {
                 *cp++ = 's';
               }
diff --git a/src/move.c b/src/move.c
index cd23253..29b2d65 100644
--- a/src/move.c
+++ b/src/move.c
@@ -654,7 +654,7 @@ MoveTextToLayerLowLevel (LayerTypePtr Source, TextTypePtr Text,
   r_substitute (Source->text_tree, (BoxType *) & Source->Text[Source->TextN],
 		(BoxType *) Text);
   memset (&Source->Text[Source->TextN], 0, sizeof (TextType));
-  if (GetLayerGroupNumberByNumber (max_layer + SOLDER_LAYER) ==
+  if (GetLayerGroupNumberByNumber (solder_silk_layer) ==
       GetLayerGroupNumberByPointer (Destination))
     SET_FLAG (ONSOLDERFLAG, new);
   else
@@ -932,16 +932,16 @@ MoveLayer (int old_index, int new_index)
   AddLayerChangeToUndoList (old_index, new_index);
   IncrementUndoSerialNumber ();
 
-  if (old_index < -1 || old_index >= max_layer)
+  if (old_index < -1 || old_index >= max_copperlayer)
     {
       Message ("Invalid old layer %d for move: must be -1..%d\n",
-	       old_index, max_layer - 1);
+	       old_index, max_copper_layer - 1);
       return 1;
     }
-  if (new_index < -1 || new_index > max_layer || new_index >= MAX_LAYER)
+  if (new_index < -1 || new_index > max_copper_layer || new_index >= MAX_LAYER)
     {
       Message ("Invalid new layer %d for move: must be -1..%d\n",
-	       new_index, max_layer);
+	       new_index, max_copper_layer);
       return 1;
     }
   if (old_index == new_index)
@@ -954,7 +954,7 @@ MoveLayer (int old_index, int new_index)
   if (old_index == -1)
     {
       LayerTypePtr lp;
-      if (max_layer == MAX_LAYER)
+      if (max_copper_layer == MAX_LAYER)
 	{
 	  Message ("No room for new layers\n");
 	  return 1;
@@ -963,38 +963,38 @@ MoveLayer (int old_index, int new_index)
       lp = &PCB->Data->Layer[new_index];
       memmove (&PCB->Data->Layer[new_index + 1],
 	       &PCB->Data->Layer[new_index],
-	       (max_layer - new_index + 2) * sizeof (LayerType));
+	       (max_copper_layer - new_index + 2) * sizeof (LayerType));
       memmove (&groups[new_index + 1],
 	       &groups[new_index],
-	       (max_layer - new_index + 2) * sizeof (int));
-      max_layer++;
+	       (max_copper_layer - new_index + 2) * sizeof (int));
+      max_copper_layer++;
       memset (lp, 0, sizeof (LayerType));
       lp->On = 1;
       lp->Name = MyStrdup ("New Layer", "MoveLayer");
       lp->Color = Settings.LayerColor[new_index];
       lp->SelectedColor = Settings.LayerSelectedColor[new_index];
-      for (l = 0; l < max_layer; l++)
+      for (l = 0; l < max_copper_layer; l++)
 	if (LayerStack[l] >= new_index)
 	  LayerStack[l]++;
-      LayerStack[max_layer - 1] = new_index;
+      LayerStack[max_copper_layer - 1] = new_index;
     }
   else if (new_index == -1)
     {
       /* Delete the layer at old_index */
       memmove (&PCB->Data->Layer[old_index],
 	       &PCB->Data->Layer[old_index + 1],
-	       (max_layer - old_index + 2 - 1) * sizeof (LayerType));
-      memset (&PCB->Data->Layer[max_layer + 1], 0, sizeof (LayerType));
+	       (max_copper_layer - old_index + 2 - 1) * sizeof (LayerType));
+      memset (&PCB->Data->Layer[max_copper_layer + 1], 0, sizeof (LayerType));
       memmove (&groups[old_index],
 	       &groups[old_index + 1],
-	       (max_layer - old_index + 2 - 1) * sizeof (int));
-      for (l = 0; l < max_layer; l++)
+	       (max_copper_layer - old_index + 2 - 1) * sizeof (int));
+      for (l = 0; l < max_copper_layer; l++)
 	if (LayerStack[l] == old_index)
 	  memmove (LayerStack + l,
 		   LayerStack + l + 1,
-		   (max_layer - l - 1) * sizeof (LayerStack[0]));
-      max_layer--;
-      for (l = 0; l < max_layer; l++)
+		   (max_copper_layer - l - 1) * sizeof (LayerStack[0]));
+      max_copper_layer--;
+      for (l = 0; l < max_copper_layer; l++)
 	if (LayerStack[l] > old_index)
 	  LayerStack[l]--;
     }
@@ -1029,7 +1029,7 @@ MoveLayer (int old_index, int new_index)
 
   for (g = 0; g < MAX_LAYER; g++)
     PCB->LayerGroups.Number[g] = 0;
-  for (l = 0; l < max_layer + 2; l++)
+  for (l = 0; l < max_copper_layer + 2; l++)
     {
       int i;
       g = groups[l];
@@ -1134,7 +1134,7 @@ MoveLayerAction (int argc, char **argv, int x, int y)
   else if (strcmp (argv[1], "down") == 0)
     {
       new_index = INDEXOFCURRENT + 1;
-      if (new_index >= max_layer)
+      if (new_index >= max_copper_layer)
 	return 1;
       new_top = new_index;
     }
@@ -1147,7 +1147,7 @@ MoveLayerAction (int argc, char **argv, int x, int y)
   if (new_index == -1)
     {
       new_top = old_index;
-      if (new_top >= max_layer)
+      if (new_top >= max_copper_layer)
 	new_top--;
       new_index = new_top;
     }
diff --git a/src/polygon.c b/src/polygon.c
index d379a6b..96c9218 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -1015,7 +1015,7 @@ static int
 Group (DataTypePtr Data, Cardinal layer)
 {
   Cardinal i, j;
-  for (i = 0; i < max_layer; i++)
+  for (i = 0; i < max_group; i++)
     for (j = 0; j < ((PCBType *) (Data->pcb))->LayerGroups.Number[i]; j++)
       if (layer == ((PCBType *) (Data->pcb))->LayerGroups.Entries[i][j])
         return i;
@@ -1032,10 +1032,10 @@ clearPoly (DataTypePtr Data, LayerTypePtr Layer, PolygonType * polygon,
   Cardinal group;
 
   if (!TEST_FLAG (CLEARPOLYFLAG, polygon)
-      || GetLayerNumber (Data, Layer) >= max_layer)
+      || GetLayerNumber (Data, Layer) >= max_copper_layer)
     return 0;
   group = Group (Data, GetLayerNumber (Data, Layer));
-  info.solder = (group == Group (Data, max_layer + SOLDER_LAYER));
+  info.solder = (group == Group (Data, solder_silk_layer));
   info.data = Data;
   info.other = here;
   info.layer = Layer;
@@ -1051,7 +1051,7 @@ clearPoly (DataTypePtr Data, LayerTypePtr Layer, PolygonType * polygon,
       r = 0;
       info.accumulate = NULL;
       info.batch_size = 0;
-      if (info.solder || group == Group (Data, max_layer + COMPONENT_LAYER))
+      if (info.solder || group == Group (Data, component_silk_layer))
 	r += r_search (Data->pad_tree, &region, NULL, pad_sub_callback, &info);
       GROUP_LOOP (Data, group);
       {
@@ -1547,7 +1547,7 @@ PlowsPolygon (DataType * Data, int type, void *ptr1, void *ptr2,
     case VIA_TYPE:
       if (type == PIN_TYPE || ptr1 == ptr2 || ptr1 == NULL)
         {
-          LAYER_LOOP (Data, max_layer);
+          LAYER_LOOP (Data, max_copper_layer);
           {
             info.layer = layer;
             r +=
@@ -1574,7 +1574,7 @@ PlowsPolygon (DataType * Data, int type, void *ptr1, void *ptr2,
       if (!TEST_FLAG (CLEARLINEFLAG, (LineTypePtr) ptr2))
         return 0;
       /* silk doesn't plow */
-      if (GetLayerNumber (Data, ptr1) >= max_layer)
+      if (GetLayerNumber (Data, ptr1) >= max_copper_layer)
         return 0;
       GROUP_LOOP (Data, GetLayerGroupNumberByNumber (GetLayerNumber (Data,
                                                                      ((LayerTypePtr) ptr1))));
@@ -1586,10 +1586,9 @@ PlowsPolygon (DataType * Data, int type, void *ptr1, void *ptr2,
       break;
     case PAD_TYPE:
       {
-        Cardinal group = TEST_FLAG (ONSOLDERFLAG,
-                                    (PadType *) ptr2) ? SOLDER_LAYER :
-          COMPONENT_LAYER;
-        group = GetLayerGroupNumberByNumber (max_layer + group);
+        Cardinal group = GetLayerGroupNumberByNumber (
+                            TEST_FLAG (ONSOLDERFLAG, (PadType *) ptr2) ?
+                              solder_silk_layer : component_silk_layer);
         GROUP_LOOP (Data, group);
         {
           info.layer = layer;
@@ -2036,7 +2035,7 @@ POLYAREA *board_outline_poly ()
   whole_world = RectPoly (-BLOAT_WORLD, BLOAT_WORLD + PCB->MaxWidth,
                           -BLOAT_WORLD, BLOAT_WORLD + PCB->MaxHeight);
 
-  for (i = 0; i < max_layer; i++)
+  for (i = 0; i < max_copper_layer; i++)
     {
       Layer = PCB->Data->Layer + i;
 
diff --git a/src/print.c b/src/print.c
index 3831b4a..b5fec1c 100644
--- a/src/print.c
+++ b/src/print.c
@@ -293,7 +293,7 @@ PrintFab (void)
     strftime (utcTime, sizeof utcTime, fmt, gmtime (&currenttime));
   }
   yoff = -TEXT_LINE;
-  for (i = 0; i < max_layer; i++)
+  for (i = 0; i < max_copper_layer; i++)
     {
       LayerType *l = LAYER_PTR (i);
       if (l->Name && (l->LineN || l->ArcN))
@@ -304,7 +304,7 @@ PrintFab (void)
 	    break;
 	}
     }
-  if (i == max_layer)
+  if (i == max_copper_layer)
     {
       gui->set_line_width (Output.fgGC, 1000);
       gui->draw_line (Output.fgGC, 0, 0, PCB->MaxWidth, 0);
diff --git a/src/puller.c b/src/puller.c
index 848d394..66a5a03 100644
--- a/src/puller.c
+++ b/src/puller.c
@@ -2598,9 +2598,9 @@ GlobalPuller(int argc, char **argv, int x, int y)
   /* hid_actionl ("djopt", "puller", 0); */
 
   current_is_solder = (GetLayerGroupNumberByPointer(CURRENT)
-		       == GetLayerGroupNumberByNumber (max_layer + SOLDER_LAYER));
+		       == GetLayerGroupNumberByNumber (solder_silk_layer));
   current_is_component = (GetLayerGroupNumberByPointer(CURRENT)
-			  == GetLayerGroupNumberByNumber (max_layer + COMPONENT_LAYER));
+			  == GetLayerGroupNumberByNumber (component_silk_layer));
 
   max_lines = nlines = CURRENT->LineN;
   lines = (Extra *) calloc (nlines, sizeof (Extra));
diff --git a/src/rats.c b/src/rats.c
index 29e9831..46a18c8 100644
--- a/src/rats.c
+++ b/src/rats.c
@@ -233,8 +233,8 @@ ProcNetlist (LibraryTypePtr net_menu)
   badnet = false;
 
   /* find layer groups of the component side and solder side */
-  SLayer = GetLayerGroupNumberByNumber (max_layer + SOLDER_LAYER);
-  CLayer = GetLayerGroupNumberByNumber (max_layer + COMPONENT_LAYER);
+  SLayer = GetLayerGroupNumberByNumber (solder_silk_layer);
+  CLayer = GetLayerGroupNumberByNumber (component_silk_layer);
 
   Wantlist = MyCalloc (1, sizeof (NetListType), "ProcNetlist()");
   if (Wantlist)
@@ -880,8 +880,8 @@ AddNet (void)
 
   /* will work for pins to since the FLAG is common */
   group1 = (TEST_FLAG (ONSOLDERFLAG, (PadTypePtr) ptr2) ?
-	    GetLayerGroupNumberByNumber (max_layer + SOLDER_LAYER) :
-	    GetLayerGroupNumberByNumber (max_layer + COMPONENT_LAYER));
+	    GetLayerGroupNumberByNumber (solder_silk_layer) :
+	    GetLayerGroupNumberByNumber (component_silk_layer));
   strcpy (name1, ConnectionName (found, ptr1, ptr2));
   found = SearchObjectByLocation (PAD_TYPE | PIN_TYPE, &ptr1, &ptr2, &ptr3,
 				  Crosshair.AttachedLine.Point2.X,
@@ -898,8 +898,8 @@ AddNet (void)
       return (NULL);
     }
   group2 = (TEST_FLAG (ONSOLDERFLAG, (PadTypePtr) ptr2) ?
-	    GetLayerGroupNumberByNumber (max_layer + SOLDER_LAYER) :
-	    GetLayerGroupNumberByNumber (max_layer + COMPONENT_LAYER));
+	    GetLayerGroupNumberByNumber (solder_silk_layer) :
+	    GetLayerGroupNumberByNumber (component_silk_layer));
   name2 = ConnectionName (found, ptr1, ptr2);
 
   menu = netnode_to_netname (name1);
diff --git a/src/rtree.c b/src/rtree.c
index 0d5bf51..a6fe712 100644
--- a/src/rtree.c
+++ b/src/rtree.c
@@ -246,7 +246,7 @@ __r_dump_tree (struct rtree_node *node, int depth)
                                   GDK_LINE_SOLID, GDK_CAP_ROUND,
                                   GDK_JOIN_ROUND);
 
-      if (depth < max_layer + 1)
+      if (depth < max_copper_layer + 1)
         gdk_gc_set_foreground (Output.fgGC, (LAYER_PTR (depth)->Color));
       else
         gdk_gc_set_foreground (Output.fgGC, PCB->WarnColor);
diff --git a/src/rubberband.c b/src/rubberband.c
index e5fb797..31ed1b7 100644
--- a/src/rubberband.c
+++ b/src/rubberband.c
@@ -236,8 +236,7 @@ CheckPadForRubberbandConnection (PadTypePtr Pad)
   info.box.Y2 = MAX (Pad->Point1.Y, Pad->Point2.Y) + half;
   info.radius = 0;
   info.line = NULL;
-  i = max_layer +
-    (TEST_FLAG (ONSOLDERFLAG, Pad) ? SOLDER_LAYER : COMPONENT_LAYER);
+  i = TEST_FLAG (ONSOLDERFLAG, Pad) ? solder_silk_layer : component_silk_layer;
   group = GetLayerGroupNumberByNumber (i);
 
   /* check all visible layers in the same group */
@@ -325,8 +324,7 @@ CheckPadForRat (PadTypePtr Pad)
   struct rinfo info;
   Cardinal i;
 
-  i = max_layer +
-    (TEST_FLAG (ONSOLDERFLAG, Pad) ? SOLDER_LAYER : COMPONENT_LAYER);
+  i = TEST_FLAG (ONSOLDERFLAG, Pad) ? solder_silk_layer : component_silk_layer;
   info.group = GetLayerGroupNumberByNumber (i);
   info.pad = Pad;
   info.type = PAD_TYPE;
@@ -387,7 +385,7 @@ CheckPinForRubberbandConnection (PinTypePtr Pin)
       info.Y = Pin->Y;
     }
 
-  for (n = 0; n < max_layer; n++)
+  for (n = 0; n < max_copper_layer; n++)
     {
       info.layer = LAYER_PTR (n);
       r_search (info.layer->line_tree, &info.box, NULL, rubber_callback,
@@ -515,7 +513,7 @@ LookupRubberbandLines (int Type, void *Ptr1, void *Ptr2, void *Ptr3)
       {
 	LayerTypePtr layer = (LayerTypePtr) Ptr1;
 	LineTypePtr line = (LineTypePtr) Ptr2;
-	if (GetLayerNumber (PCB->Data, layer) < max_layer)
+	if (GetLayerNumber (PCB->Data, layer) < max_copper_layer)
 	  {
 	    CheckLinePointForRubberbandConnection (layer, line,
 						   &line->Point1, false);
@@ -526,7 +524,7 @@ LookupRubberbandLines (int Type, void *Ptr1, void *Ptr2, void *Ptr3)
       }
 
     case LINEPOINT_TYPE:
-      if (GetLayerNumber (PCB->Data, (LayerTypePtr) Ptr1) < max_layer)
+      if (GetLayerNumber (PCB->Data, (LayerTypePtr) Ptr1) < max_copper_layer)
 	CheckLinePointForRubberbandConnection ((LayerTypePtr) Ptr1,
 					       (LineTypePtr) Ptr2,
 					       (PointTypePtr) Ptr3, true);
@@ -537,7 +535,7 @@ LookupRubberbandLines (int Type, void *Ptr1, void *Ptr2, void *Ptr3)
       break;
 
     case POLYGON_TYPE:
-      if (GetLayerNumber (PCB->Data, (LayerTypePtr) Ptr1) < max_layer)
+      if (GetLayerNumber (PCB->Data, (LayerTypePtr) Ptr1) < max_copper_layer)
 	CheckPolygonForRubberbandConnection ((LayerTypePtr) Ptr1,
 					     (PolygonTypePtr) Ptr2);
       break;
diff --git a/src/search.c b/src/search.c
index c05a4b4..3fafcd4 100644
--- a/src/search.c
+++ b/src/search.c
@@ -1226,11 +1226,11 @@ SearchObjectByLocation (int Type,
       HigherAvail = ELEMENT_TYPE;
     }
 
-  for (i = -1; i < max_layer + 1; i++)
+  for (i = -1; i < max_copper_layer + 1; i++)
     {
       if (i < 0)
 	SearchLayer = &PCB->Data->SILKLAYER;
-      else if (i < max_layer)
+      else if (i < max_copper_layer)
 	SearchLayer = LAYER_ON_STACK (i);
       else
 	{
diff --git a/src/select.c b/src/select.c
index aa65f36..c4b5e17 100644
--- a/src/select.c
+++ b/src/select.c
@@ -290,7 +290,7 @@ SelectBlock (BoxTypePtr Box, bool Flag)
   END_LOOP;
 
   /* check layers */
-  LAYER_LOOP(PCB->Data, max_layer + 2);
+  LAYER_LOOP(PCB->Data, max_copper_layer + 2);
   {
     if (layer == & PCB->Data->SILKLAYER)
       {
diff --git a/src/toporouter.c b/src/toporouter.c
index fa57635..a723a27 100644
--- a/src/toporouter.c
+++ b/src/toporouter.c
@@ -1240,7 +1240,7 @@ groupcount(void)
   int group;
   guint count = 0;
 
-  for (group = 0; group < max_layer; group++) {
+  for (group = 0; group < max_group; group++) {
     if(PCB->LayerGroups.Number[group] > 0) count++;
   }
   
@@ -1909,8 +1909,8 @@ read_pads(toporouter_t *r, toporouter_layer_t *l, guint layer)
   GList *vlist = NULL;
   toporouter_bbox_t *bbox = NULL;
 
-  guint front = GetLayerGroupNumberByNumber (max_layer + COMPONENT_LAYER);
-  guint back = GetLayerGroupNumberByNumber (max_layer + SOLDER_LAYER);
+  guint front = GetLayerGroupNumberByNumber (component_silk_layer);
+  guint back = GetLayerGroupNumberByNumber (solder_silk_layer);
 
 //  printf("read_pads: front = %d back = %d layer = %d\n", 
 //     front, back, layer);
@@ -2886,7 +2886,7 @@ import_geometry(toporouter_t *r)
   int group;
 
 #ifdef DEBUG_IMPORT    
-  for (group = 0; group < max_layer; group++) {
+  for (group = 0; group < max_group; group++) {
     printf("Group %d: Number %d:\n", group, PCB->LayerGroups.Number[group]);
 
     for (int entry = 0; entry < PCB->LayerGroups.Number[group]; entry++) {
@@ -2898,7 +2898,7 @@ import_geometry(toporouter_t *r)
   cur_layer = r->layers = malloc(groupcount() * sizeof(toporouter_layer_t));
 
   /* Foreach layer, read in pad vertices and constraints, and build CDT */
-  for (group = 0; group < max_layer; group++) {
+  for (group = 0; group < max_group; group++) {
 #ifdef DEBUG_IMPORT    
     printf("*** LAYER GROUP %d ***\n", group);
 #endif
@@ -7840,9 +7840,9 @@ parse_arguments(toporouter_t *r, int argc, char **argv)
     }
   }
   
-  for (guint group = 0; group < max_layer; group++) 
+  for (guint group = 0; group < max_group; group++) 
     for (i = 0; i < PCB->LayerGroups.Number[group]; i++) 
-      if ((PCB->LayerGroups.Entries[group][i] < max_layer) && !(PCB->Data->Layer[PCB->LayerGroups.Entries[group][i]].On)) {
+      if ((PCB->LayerGroups.Entries[group][i] < max_copper_layer) && !(PCB->Data->Layer[PCB->LayerGroups.Entries[group][i]].On)) {
         gdouble *layer = malloc(sizeof(gdouble));
         *layer = (double)group;
         r->keepoutlayers = g_list_prepend(r->keepoutlayers, layer);

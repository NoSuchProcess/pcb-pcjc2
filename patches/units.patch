Bottom: b0ab9dc59aa949a005bd680a049c6fc1a6921d1e
Top:    f78779c6b36f2402186bdabfac2b309bc85c00c9
Author: Andrew Poelstra <asp11@sfu.ca>
Date:   2011-04-27 20:20:48 +0100

PCB/Physical unit macros patch


---

diff --git a/globalconst.h b/globalconst.h
index ff8e696..71bc61a 100755
--- a/globalconst.h
+++ b/globalconst.h
@@ -60,36 +60,36 @@
 /* ---------------------------------------------------------------------------
  * some limit specifications
  */
-#define LARGE_VALUE		10000000 /* maximum extent of board and elements in 1/100 mil */
+#define LARGE_VALUE		10000000 /* maximum extent of board and elements */
  
 #define	MAX_LAYER		16	/* max number of layer, check source */
 					/* code for more changes, a *lot* more changes */
 #define DEF_LAYER		8	/* default number of layers for new boards */
 #define NUM_STYLES		4
-#define	MIN_LINESIZE		1	/* thickness of lines in 1/100000'' */
+#define	MIN_LINESIZE		MIL_TO_COORD(0.01)	/* thickness of lines */
 #define	MAX_LINESIZE		LARGE_VALUE
 #define	MIN_TEXTSCALE		10	/* scaling of text objects in percent */
 #define	MAX_TEXTSCALE		10000
-#define	MIN_PINORVIASIZE	2000	/* size of a pin or via in 1/100 mils */
-#define	MIN_PINORVIAHOLE	400	/* size of a pins or vias drilling hole */
+#define	MIN_PINORVIASIZE	MIL_TO_COORD(20)	/* size of a pin or via */
+#define	MIN_PINORVIAHOLE	MIL_TO_COORD(4)	/* size of a pins or vias drilling hole */
 #define	MAX_PINORVIASIZE	LARGE_VALUE
-#define	MIN_PINORVIACOPPER	400	/* min difference outer-inner diameter */
-#define	MIN_PADSIZE		100	/* min size of a pad */
+#define	MIN_PINORVIACOPPER	MIL_TO_COORD(4)	/* min difference outer-inner diameter */
+#define	MIN_PADSIZE		MIL_TO_COORD(1)	/* min size of a pad */
 #define	MAX_PADSIZE		LARGE_VALUE   /* max size of a pad */
-#define	MIN_DRC_VALUE		10
-#define	MAX_DRC_VALUE		50000
-#define	MIN_DRC_SILK		100
-#define	MAX_DRC_SILK		3000
-#define	MIN_DRC_DRILL		100
-#define	MAX_DRC_DRILL		5000
+#define	MIN_DRC_VALUE		MIL_TO_COORD(0.1)
+#define	MAX_DRC_VALUE		MIL_TO_COORD(500)
+#define	MIN_DRC_SILK		MIL_TO_COORD(1)
+#define	MAX_DRC_SILK		MIL_TO_COORD(30)
+#define	MIN_DRC_DRILL		MIL_TO_COORD(1)
+#define	MAX_DRC_DRILL		MIL_TO_COORD(50)
 #define	MIN_DRC_RING		0
-#define	MAX_DRC_RING		10000
-#define	MIN_GRID		1	/* min grid in 1/100 mils */
-#define	MAX_GRID		100000 /* max grid in 1/100 mils */ 
+#define	MAX_DRC_RING		MIL_TO_COORD(100)
+#define	MIN_GRID		1
+#define	MAX_GRID		MIL_TO_COORD(1000)
 #define	MAX_FONTPOSITION	255	/* upper limit of characters in my font */
 
 #define	MAX_COORD		LARGE_VALUE	/* coordinate limits */
-#define	MIN_SIZE		1000	/* lowest width and height of the board */
+#define	MIN_SIZE		MIL_TO_COORD(10)	/* lowest width and height of the board */
 #define	MAX_BUFFER		5	/* number of pastebuffers */
 					/* additional changes in menu.c are */
 					/* also required to select more buffers */
diff --git a/src/action.c b/src/action.c
index 7744cd1..53dde28 100644
--- a/src/action.c
+++ b/src/action.c
@@ -1857,15 +1857,15 @@ ActionDRCheck (int argc, char **argv, int x, int y)
 
   if (gui->drc_gui == NULL || gui->drc_gui->log_drc_overview)
     {
-      Message (_("Rules are minspace %d.%02d, minoverlap %d.%d "
-		 "minwidth %d.%02d, minsilk %d.%02d\n"
-		 "min drill %d.%02d, min annular ring %d.%02d\n"),
-	       (PCB->Bloat + 1) / 100, (PCB->Bloat + 1) % 100,
-	       PCB->Shrink / 100, PCB->Shrink % 100,
-	       PCB->minWid / 100, PCB->minWid % 100,
-	       PCB->minSlk / 100, PCB->minSlk % 100,
-	       PCB->minDrill / 100, PCB->minDrill % 100,
-	       PCB->minRing / 100, PCB->minRing % 100);
+      Message (_("Rules are minspace %.2f, minoverlap %.2f "
+		 "minwidth %.2f, minsilk %.2f\n"
+		 "min drill %.2f, min annular ring %.2f\n"),
+	       COORD_TO_MIL(PCB->Bloat + 1),
+	       COORD_TO_MIL(PCB->Shrink),
+	       COORD_TO_MIL(PCB->minWid),
+	       COORD_TO_MIL(PCB->minSlk),
+	       COORD_TO_MIL(PCB->minDrill),
+	       COORD_TO_MIL(PCB->minRing));
     }
   count = DRCAll ();
   if (gui->drc_gui == NULL || gui->drc_gui->log_drc_overview)
@@ -2393,7 +2393,7 @@ from.
 
 %end-doc */
 
-#define GAP 10000
+#define GAP MIL_TO_COORD(100)
 
 static int
 ActionDisperseElements (int argc, char **argv, int x, int y)
diff --git a/src/autoplace.c b/src/autoplace.c
index b9db528..65eef92 100644
--- a/src/autoplace.c
+++ b/src/autoplace.c
@@ -379,7 +379,7 @@ ComputeCost (NetListTypePtr Nets, double T0, double T)
 	box->Y2 = maxy;
       }
       /* okay, add half-perimeter to cost! */
-      W += (maxx - minx) / 100 + (maxy - miny) / 100 +
+      W += COORD_TO_MIL(maxx - minx) + COORD_TO_MIL(maxy - miny) +
 	((allpads && !allsameside) ? CostParameter.via_cost : 0);
     }
   /* now compute penalty function Wc which is proportional to
diff --git a/src/buffer.c b/src/buffer.c
index 4f746e9..907c7e6 100644
--- a/src/buffer.c
+++ b/src/buffer.c
@@ -1064,7 +1064,7 @@ ConvertBufferToElement (BufferTypePtr Buffer)
   {
     char num[8];
     if (via->Mask < via->Thickness)
-      via->Mask = via->Thickness + 2 * MASKFRAME * 100;	/* MASKFRAME is in mils */
+      via->Mask = via->Thickness + 2 * MIL_TO_COORD(MASKFRAME);	/* MASKFRAME is in mils */
     if (via->Name)
       CreateNewPin (Element, via->X, via->Y, via->Thickness,
 		    via->Clearance, via->Mask, via->DrillingHole,
diff --git a/src/change.c b/src/change.c
index 277717a..c65c534 100644
--- a/src/change.c
+++ b/src/change.c
@@ -739,7 +739,7 @@ ChangeLineClearSize (LayerTypePtr Layer, LineTypePtr Line)
       if (Line->Clearance == 0)
 	{
 	  CLEAR_FLAG (CLEARLINEFLAG, Line);
-	  Line->Clearance = 1000;
+	  Line->Clearance = MIL_TO_COORD(10);
 	}
       SetLineBoundingBox (Line);
       r_insert_entry (Layer->line_tree, (BoxTypePtr) Line, 0);
@@ -820,7 +820,7 @@ ChangeArcClearSize (LayerTypePtr Layer, ArcTypePtr Arc)
       if (Arc->Clearance == 0)
 	{
 	  CLEAR_FLAG (CLEARLINEFLAG, Arc);
-	  Arc->Clearance = 1000;
+	  Arc->Clearance = MIL_TO_COORD(10);
 	}
       SetArcBoundingBox (Arc);
       r_insert_entry (Layer->arc_tree, (BoxTypePtr) Arc, 0);
diff --git a/src/const.h b/src/const.h
index 3b6cd30..724b3be 100644
--- a/src/const.h
+++ b/src/const.h
@@ -65,12 +65,16 @@
 #define COS_22_5_DEGREE		0.923879533	/* cos(22.5) */
 #define	TAN_30_DEGREE		0.577350269	/* tan(30) */
 #define	TAN_60_DEGREE		1.732050808	/* tan(60) */
-#define MIL_TO_MM               0.025400000
-#define MM_TO_MIL               (1./MIL_TO_MM)
-#define COOR_TO_MM		0.000254000
-#define MM_TO_COOR		(1./COOR_TO_MM)
 #define LN_2_OVER_2		0.346573590
 
+/* PCB/physical unit conversions */
+#define COORD_TO_MIL(n)	((n) / 100.0)
+#define MIL_TO_COORD(n)	((n) * 100.0)
+#define COORD_TO_MM(n)	((n) * 0.000254)
+#define MM_TO_COORD(n)	((n) / 0.000254)
+#define COORD_TO_INCH(n)	(COORD_TO_MIL(n) / 1000.0)
+#define INCH_TO_COORD(n)	(MIL_TO_COORD(n) * 1000.0)
+
 /* ---------------------------------------------------------------------------
  * modes
  */
diff --git a/src/create.c b/src/create.c
index f942c40..6409139 100644
--- a/src/create.c
+++ b/src/create.c
@@ -248,8 +248,8 @@ CreateNewVia (DataTypePtr Data,
 	if (SQUARE (via->X - X) + SQUARE (via->Y - Y) <=
 	    SQUARE (via->DrillingHole / 2 + DrillingHole / 2)) 
 	  {
-	    Message (_("Dropping via at (%d, %d) because it's hole would overlap with the via "
-		       "at (%d, %d)\n"), X/100, Y/100, via->X/100, via->Y/100);
+	    Message (_("Dropping via at (%f, %f) because it's hole would overlap with the via "
+		       "at (%f, %f)\n"), COORD_TO_MIL(X), COORD_TO_MIL(Y), COORD_TO_MIL(via->X), COORD_TO_MIL(via->Y));
 	    return (NULL);		/* don't allow via stacking */
 	  }
       }
diff --git a/src/djopt.c b/src/djopt.c
index 4995c08..09abdc5 100644
--- a/src/djopt.c
+++ b/src/djopt.c
@@ -1719,7 +1719,7 @@ orthopull ()
       c = c->next;
     }
   if (rv)
-    printf ("orthopull: %d mils saved\n", rv / 100);
+    printf ("orthopull: %f mils saved\n", COORD_TO_MIL(rv));
   return rv;
 }
 
@@ -2099,8 +2099,8 @@ vianudge ()
 
       /* at this point, we know we can move it */
 
-      dprintf ("vianudge: nudging via at %d,%d by %d mils saving %d\n",
-	       c->x, c->y, len / 100, saved / 100);
+      dprintf ("vianudge: nudging via at %d,%d by %f mils saving %f\n",
+	       c->x, c->y, COORD_TO_MIL(len), COORD_TO_MIL(saved));
       rv += len * saved;
       move_corner (c, c2->x, c2->y);
 
@@ -2111,7 +2111,7 @@ vianudge ()
     }
 
   if (rv)
-    printf ("vianudge: %d mils saved\n", rv / 100);
+    printf ("vianudge: %f mils saved\n", COORD_TO_MIL(rv));
   return rv;
 }
 
diff --git a/src/find.c b/src/find.c
index 47bd68c..b740890 100644
--- a/src/find.c
+++ b/src/find.c
@@ -157,7 +157,7 @@ RCSID ("$Id$");
 #define	IS_PV_ON_PAD(PV,Pad) \
 	( IsPointInPad((PV)->X, (PV)->Y, MAX((PV)->Thickness/2 +Bloat,0), (Pad)))
 
-#define LENGTH_TO_HUMAN(value) (Settings.grid_units_mm ? ((value) / 100000.0 * 25.4) : ((value) / 100.0))
+#define LENGTH_TO_HUMAN(value) (Settings.grid_units_mm ? COORD_TO_MM(value) : COORD_TO_MIL(value))
 #define LENGTH_DIGITS (Settings.grid_units_mm ? 4 : 2)
 #define LENGTH_UNITS_STRING (Settings.grid_units_mm ? "mm" : "mils")
 
diff --git a/src/hid/batch/batch.c b/src/hid/batch/batch.c
index 99c2220..f14d75f 100644
--- a/src/hid/batch/batch.c
+++ b/src/hid/batch/batch.c
@@ -85,8 +85,8 @@ info (int argc, char **argv, int x, int y)
     }
   printf("Filename: %s\n", PCB->Filename);
   printf("Size: %g x %g mils, %g x %g mm\n",
-	 PCB->MaxWidth / 100.0,
-	 PCB->MaxHeight / 100.0,
+	 COORD_TO_MIL(PCB->MaxWidth),
+	 COORD_TO_MIL(PCB->MaxHeight),
 	 PCB->MaxWidth * COOR_TO_MM,
 	 PCB->MaxHeight * COOR_TO_MM);
   cg = GetLayerGroupNumberByNumber (component_silk_layer);
diff --git a/src/hid/gcode/gcode.c b/src/hid/gcode/gcode.c
index 6491afd..50f22cb 100644
--- a/src/hid/gcode/gcode.c
+++ b/src/hid/gcode/gcode.c
@@ -68,7 +68,7 @@
 #endif
 
 #define CRASH fprintf(stderr, "HID error: pcb called unimplemented GCODE function %s.\n", __FUNCTION__); abort()
-#define pcb_unit 100000.0	/* pcb internal units per inch */
+#define pcb_unit (INCH_TO_COORD(1)) /* pcb internal units per inch */
 struct color_struct
 {
   /* the descriptor used by the gd library */
@@ -182,7 +182,7 @@ REGISTER_ATTRIBUTES (gcode_attribute_list)
 
 /* *** Utility funcions **************************************************** */
 
-/* convert from default PCB units (1/100 mil) to gcode units */
+/* convert from default PCB units to gcode units */
      static int pcb_to_gcode (int pcb)
 {
   int gcode;
@@ -446,7 +446,7 @@ gcode_do_export (HID_Attr_Val * options)
   gcode_cutdepth = options[HA_cutdepth].real_value * scale;
   gcode_drilldepth = options[HA_drilldepth].real_value * scale;
   gcode_safeZ = options[HA_safeZ].real_value * scale;
-  gcode_toolradius = options[HA_toolradius].real_value * scale * pcb_unit;	/* in PCB units (1/100 mil) */
+  gcode_toolradius = options[HA_toolradius].real_value * scale * pcb_unit;	/* in PCB units */
   if (metric)
     gcode_toolradius *= 1 / 25.4;
   gcode_choose_groups ();
diff --git a/src/hid/gerber/gerber.c b/src/hid/gerber/gerber.c
index d5843ef..9642579 100644
--- a/src/hid/gerber/gerber.c
+++ b/src/hid/gerber/gerber.c
@@ -145,7 +145,7 @@ int n_pending_drills = 0, max_pending_drills = 0;
 /*----------------------------------------------------------------------------*/
 /* Defined Constants                                                          */
 /*----------------------------------------------------------------------------*/
-#define AUTO_OUTLINE_WIDTH 800       /* Auto-geneated outline width of 8 mils */
+#define AUTO_OUTLINE_WIDTH MIL_TO_COORD(8)       /* Auto-geneated outline width of 8 mils */
 
 
 /*----------------------------------------------------------------------------*/
@@ -203,16 +203,16 @@ printAperture(FILE *f, int i)
     {
     case ROUND:
       fprintf (f, "%%ADD%dC,%.4f*%%\015\012", dCode,
-	       width / 100000.0);
+	       COORD_TO_INCH(width));
       break;
     case SQUARE:
       fprintf (f, "%%ADD%dR,%.4fX%.4f*%%\015\012",
-	       dCode, width / 100000.0, width / 100000.0);
+	       dCode, COORD_TO_INCH(width), COORD_TO_INCH(width));
       break;
     case OCTAGON:
       fprintf (f, "%%AMOCT%d*5,0,8,0,0,%.4f,22.5*%%\015\012"
 	       "%%ADD%dOCT%d*%%\015\012", dCode,
-	       width / (100000.0 * COS_22_5_DEGREE), dCode,
+	       COORD_TO_INCH(width) / COS_22_5_DEGREE, dCode,
 	       dCode);
       break;
 #if 0
@@ -628,7 +628,7 @@ gerber_set_layer (const char *name, int group, int empty)
 	    if (curapp->aperture_used[i])
 	      fprintf (f, "T%02dC%.3f\015\012",
 		       i + DCODE_BASE,
-		       global_aperture_sizes[i] / 100000.0);
+		       COORD_TO_INCH(global_aperture_sizes[i]));
 	  fprintf (f, "%%\015\012");
 	  /* FIXME */
 	  return 1;
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index a51d167..0df478d 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -1652,9 +1652,9 @@ CursorAction(int argc, char **argv, int x, int y)
    * come up with PCB internal units.
    */
   if (strncasecmp (argv[3], "mm", 2) == 0)
-    xu = yu = MM_TO_COOR;
+    xu = yu = MM_TO_COORD(1);
   else if (strncasecmp (argv[3], "mil", 3) == 0)
-    xu = yu = 100;
+    xu = yu = MIL_TO_COORD(1);
   else if (strncasecmp (argv[3], "grid", 4) == 0)
     xu = yu = PCB->Grid;
   else if (strncasecmp (argv[3], "view", 4) == 0)
diff --git a/src/hid/gtk/gui-drc-window.c b/src/hid/gtk/gui-drc-window.c
index 70a097e..674e495 100644
--- a/src/hid/gtk/gui-drc-window.c
+++ b/src/hid/gtk/gui-drc-window.c
@@ -962,9 +962,6 @@ ghid_drc_window_show (gboolean raise)
   gtk_widget_show_all (drc_window);
 }
 
-#define UNIT1(value) (Settings.grid_units_mm ? ((value) / 100000.0 * 25.4) : ((value) / 100.0))
-#define UNIT(value) UNIT1(value) , (Settings.grid_units_mm ? "mm" : "mils")
-
 void ghid_drc_window_append_violation (DrcViolationType *violation)
 {
   GhidDrcViolation *violation_obj;
diff --git a/src/hid/gtk/gui-misc.c b/src/hid/gtk/gui-misc.c
index 75ba763..21c8161 100644
--- a/src/hid/gtk/gui-misc.c
+++ b/src/hid/gtk/gui-misc.c
@@ -509,17 +509,17 @@ ghid_set_status_line_label (void)
 		"<b>text</b>=%i%%  "
 		"<b>buffer</b>=#%i"),
 	      Settings.ShowSolderSide ? _("solder") : _("component"),
-	      PCB->Grid / 100.0,
+	      COORD_TO_MIL(PCB->Grid),
 	      (int) Settings.GridFactor,
 	      TEST_FLAG (ALLDIRECTIONFLAG, PCB) ? "all" :
 	      (PCB->Clipping == 0 ? "45" :
 	       (PCB->Clipping == 1 ? "45_/" : "45\\_")),
 	      TEST_FLAG (RUBBERBANDFLAG, PCB) ? ",R  " : "  ",
-	      Settings.LineThickness / 100.0,
-	      Settings.ViaThickness / 100.0,
-	      Settings.ViaDrillingHole / 100.0,
+	      COORD_TO_MIL(Settings.LineThickness),
+	      COORD_TO_MIL(Settings.ViaThickness),
+	      COORD_TO_MIL(Settings.ViaDrillingHole),
 	      ghidgui->compact_horizontal ? "\n" : "",
-	      Settings.Keepaway / 100.0,
+	      COORD_TO_MIL(Settings.Keepaway),
 	      Settings.TextScale, Settings.BufferNumber + 1);
   else
     snprintf (text, sizeof (text),
@@ -532,16 +532,16 @@ ghid_set_status_line_label (void)
 		"<b>text</b>=%i%%  "
 		"<b>buffer</b>=#%i"),
 	      Settings.ShowSolderSide ? _("solder") : _("component"),
-	      PCB->Grid * COOR_TO_MM, (int) Settings.GridFactor,
+	      COORD_TO_MM(PCB->Grid), (int) Settings.GridFactor,
 	      TEST_FLAG (ALLDIRECTIONFLAG, PCB) ? "all" :
 	      (PCB->Clipping == 0 ? "45" :
 	       (PCB->Clipping == 1 ? "45_/" : "45\\_")),
 	      TEST_FLAG (RUBBERBANDFLAG, PCB) ? ",R  " : "  ",
-	      Settings.LineThickness * COOR_TO_MM,
-	      Settings.ViaThickness * COOR_TO_MM,
-	      Settings.ViaDrillingHole * COOR_TO_MM,
+	      COORD_TO_MM(Settings.LineThickness),
+	      COORD_TO_MM(Settings.ViaThickness),
+	      COORD_TO_MM(Settings.ViaDrillingHole),
 	      ghidgui->compact_horizontal ? "\n" : "",
-	      Settings.Keepaway * COOR_TO_MM,
+	      COORD_TO_MM(Settings.Keepaway),
 	      Settings.TextScale, Settings.BufferNumber + 1);
 
   ghid_status_line_set_text (text);
@@ -569,7 +569,7 @@ ghid_get_grid_factor(void)
   if (!Settings.grid_units_mm)
     return -1;
 
-  factor = PCB->Grid * COOR_TO_MM * grid_scale;
+  factor = COORD_TO_MM(PCB->Grid) * grid_scale;
   rounded_factor = floor (factor + .5);
 
   /* check whether the grid is actually metric
@@ -585,20 +585,20 @@ ghid_get_grid_factor(void)
 static double
 ghid_grid_pcb_to_units (double x, double grid_factor)
 {
-  double x_scaled = (Settings.grid_units_mm? COOR_TO_MM: 1./100) * x;
+  double x_scaled = (Settings.grid_units_mm ? COORD_TO_MM(1): COORD_TO_MIL(1)) * x;
   double nearest_gridpoint;
 
   if (grid_factor < 0)
     return x_scaled;
 
-  x *= COOR_TO_MM;
+  x = COORD_TO_MM(x);
 
   nearest_gridpoint = floor (x / grid_factor + .5);
   /* honour snapping to an unaligned object */
-  if (fabs (nearest_gridpoint * grid_factor - x) > COOR_TO_MM)
+  if (fabs (nearest_gridpoint * grid_factor - x) > COORD_TO_MM(1))
     return x_scaled;
   /* without mm-adjusted grid_factor
-     (return floor (x / PCB->Grid + .5) *  PCB->Grid * COOR_TO_MM),
+     (return floor (x / PCB->Grid + .5) * COORD_TO_MM(PCB->Grid)),
      the round-off errors redintroduce the bug for 0.1 or 0.05 mm grid
      at coordinates more than 1500 mm.
      grid_factor makes the stuff work at least up to 254 m,
diff --git a/src/hid/gtk/gui-top-window.c b/src/hid/gtk/gui-top-window.c
index 1a81c58..ca82b96 100644
--- a/src/hid/gtk/gui-top-window.c
+++ b/src/hid/gtk/gui-top-window.c
@@ -408,34 +408,32 @@ ghid_update_toggle_flags ()
 
 #define	N_GRID_SETTINGS		11
 
-#define	MM_TO_PCB(mm)	((mm) * 100000 / 25.4)
-
 static gdouble grid_mil_values[N_GRID_SETTINGS] = {
-  10.0,
-  20.0,
-  50.0,
-  100.0,
-  200.0,
-  500.0,
-  1000.0,
-  2000.0,
-  2500.0,
-  5000.0,
-  10000.0
+  MIL_TO_COORD (0.10),
+  MIL_TO_COORD (0.20),
+  MIL_TO_COORD (0.50),
+  MIL_TO_COORD (1.00),
+  MIL_TO_COORD (2.00),
+  MIL_TO_COORD (5.00),
+  MIL_TO_COORD (10.0),
+  MIL_TO_COORD (20.0),
+  MIL_TO_COORD (25.0),
+  MIL_TO_COORD (50.0),
+  MIL_TO_COORD (100)
 };
 
 static gdouble grid_mm_values[N_GRID_SETTINGS] = {
-  MM_TO_PCB (0.002),
-  MM_TO_PCB (0.005),
-  MM_TO_PCB (0.01),
-  MM_TO_PCB (0.02),
-  MM_TO_PCB (0.05),
-  MM_TO_PCB (0.1),
-  MM_TO_PCB (0.2),
-  MM_TO_PCB (0.25),
-  MM_TO_PCB (0.5),
-  MM_TO_PCB (1.0),
-  MM_TO_PCB (2.0)
+  MM_TO_COORD (0.002),
+  MM_TO_COORD (0.005),
+  MM_TO_COORD (0.01),
+  MM_TO_COORD (0.02),
+  MM_TO_COORD (0.05),
+  MM_TO_COORD (0.1),
+  MM_TO_COORD (0.2),
+  MM_TO_COORD (0.25),
+  MM_TO_COORD (0.5),
+  MM_TO_COORD (1.0),
+  MM_TO_COORD (2.0)
 };
 
   /* When the user toggles grid units mil<->mm, call this to get an
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index 5616489..cfb9708 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -55,14 +55,11 @@
 
   /* Go from from the grid units in use (millimeters or mils) to PCB units
      |  and back again.
-     |  PCB keeps values internally to 1/100000 inch (0.01 mils), but gui
+     |  PCB keeps values internally higher precision, but gui
      |  widgets (spin buttons, labels, etc) need mils or millimeters.
    */
-#define	FROM_PCB_UNITS(v)	(Settings.grid_units_mm ? \
-								((v) * 0.000254) : ((v) * 0.01))
-
-#define TO_PCB_UNITS(v)		(Settings.grid_units_mm ? \
-								((v) / 0.000254 + 0.5) : ((v) * 100.0 + 0.5))
+#define	FROM_PCB_UNITS(v)	(Settings.grid_units_mm ? COORD_TO_MM(v) : COORD_TO_MIL(v))
+#define	TO_PCB_UNITS(v)		(Settings.grid_units_mm ? MM_TO_COORD(v) : MIL_TO_COORD(v))
 
 extern int ghid_flip_x, ghid_flip_y;
 #define SIDE_X(x)   ((ghid_flip_x ? PCB->MaxWidth - (x) : (x)))
diff --git a/src/hid/lesstif/dialogs.c b/src/hid/lesstif/dialogs.c
index 8756d1f..ffe99eb 100644
--- a/src/hid/lesstif/dialogs.c
+++ b/src/hid/lesstif/dialogs.c
@@ -1140,9 +1140,9 @@ sz_str2val (Widget w, int pcbu)
     return atoi (buf);
   sscanf (buf, "%lf", &d);
   if (Settings.grid_units_mm)
-    return MM_TO_PCB (d);
+    return MM_TO_COORD (d);
   else
-    return MIL_TO_PCB (d);
+    return MIL_TO_COORD (d);
 }
 
 static void
@@ -1153,9 +1153,9 @@ sz_val2str (Widget w, int u, int pcbu)
   if (pcbu)
     {
       if (Settings.grid_units_mm)
-	d = PCB_TO_MM (u);
+	d = COORD_TO_MM (u);
       else
-	d = PCB_TO_MIL (u);
+	d = COORD_TO_MIL (u);
       sprintf (buf, "%.2f", d + 0.002);
     }
   else
diff --git a/src/hid/lesstif/lesstif.h b/src/hid/lesstif/lesstif.h
index 66a5c12..1bd368f 100644
--- a/src/hid/lesstif/lesstif.h
+++ b/src/hid/lesstif/lesstif.h
@@ -60,7 +60,3 @@ extern void lesstif_attributes_dialog (char *, AttributeListType *);
 #define need_idle_proc lesstif_need_idle_proc
 #define show_crosshair lesstif_show_crosshair
 
-#define PCB_TO_MIL(n) ((n) / 100.0)
-#define PCB_TO_MM(n) ((n) / 100000.0 * 25.4)
-#define MIL_TO_PCB(n) (int)((n) * 100.0 + 0.2)
-#define MM_TO_PCB(n) (int)((n) / 25.4 * 100000.0 + 0.2)
diff --git a/src/hid/lesstif/main.c b/src/hid/lesstif/main.c
index 928a1ae..b22328c 100644
--- a/src/hid/lesstif/main.c
+++ b/src/hid/lesstif/main.c
@@ -890,9 +890,9 @@ CursorAction(int argc, char **argv, int x, int y)
     dy = -dy;
 
   if (strncasecmp (argv[3], "mm", 2) == 0)
-    xu = yu = MM_TO_COOR;
+    xu = yu = MM_TO_COORD(1);
   else if (strncasecmp (argv[3], "mil", 3) == 0)
-    xu = yu = 100;
+    xu = yu = MIL_TO_COORD(1);
   else if (strncasecmp (argv[3], "grid", 4) == 0)
     xu = yu = PCB->Grid;
   else if (strncasecmp (argv[3], "view", 4) == 0)
@@ -906,7 +906,7 @@ CursorAction(int argc, char **argv, int x, int y)
       yu = PCB->MaxHeight / 100.0;
     }
   else
-    xu = yu = 100;
+    xu = yu = MIL_TO_COORD(1);
 
   EventMoveCrosshair (Crosshair.X+(int)(dx*xu), Crosshair.Y+(int)(dy*yu));
   gui->set_crosshair (Crosshair.X, Crosshair.Y, pan_warp);
@@ -2316,16 +2316,16 @@ coords_to_widget (int x, int y, Widget w, int prev_state)
   if (Settings.grid_units_mm)
     {
       /* MM */
-      dx = PCB_TO_MM (x);
-      dy = PCB_TO_MM (y);
-      g = PCB_TO_MM (PCB->Grid);
+      dx = COORD_TO_MM (x);
+      dy = COORD_TO_MM (y);
+      g = COORD_TO_MM (PCB->Grid);
     }
   else
     {
       /* Mils */
-      dx = PCB_TO_MIL (x);
-      dy = PCB_TO_MIL (y);
-      g = PCB_TO_MIL (PCB->Grid);
+      dx = COORD_TO_MIL (x);
+      dy = COORD_TO_MIL (y);
+      g = COORD_TO_MIL (PCB->Grid);
     }
   if (x < 0 && prev_state >= 0)
     buf[0] = 0;
@@ -2376,9 +2376,9 @@ pcb2str (int pcbval)
 
   bufp = (bufp + 1) % 20;
   if (Settings.grid_units_mm)
-    d = PCB_TO_MM (pcbval);
+    d = COORD_TO_MM (pcbval);
   else
-    d = PCB_TO_MIL (pcbval);
+    d = COORD_TO_MIL (pcbval);
 
   if ((int) (d * 100 + 0.5) == (int) (d + 0.005) * 100)
     sprintf (buf[bufp], "%d", (int) d);
@@ -2638,16 +2638,16 @@ idle_proc (XtPointer dummy)
 	  {
 	    if (Settings.grid_units_mm)
 	      {
-		g = PCB_TO_MM (old_grid);
-		x = PCB_TO_MM (old_gx);
-		y = PCB_TO_MM (old_gy);
+		g = COORD_TO_MM (old_grid);
+		x = COORD_TO_MM (old_gx);
+		y = COORD_TO_MM (old_gy);
 		u = "mm";
 	      }
 	    else
 	      {
-		g = PCB_TO_MIL (old_grid);
-		x = PCB_TO_MIL (old_gx);
-		y = PCB_TO_MIL (old_gy);
+		g = COORD_TO_MIL (old_grid);
+		x = COORD_TO_MIL (old_gx);
+		y = COORD_TO_MIL (old_gy);
 		u = "mil";
 	      }
 	    if (x || y)
@@ -2677,12 +2677,12 @@ idle_proc (XtPointer dummy)
 
 	if (Settings.grid_units_mm)
 	  {
-	    g = PCB_TO_MM (view_zoom);
+	    g = COORD_TO_MM (view_zoom);
 	    units = "mm";
 	  }
 	else
 	  {
-	    g = PCB_TO_MIL (view_zoom);
+	    g = COORD_TO_MIL (view_zoom);
 	    units = "mil";
 	  }
 	if ((int) (g * 100 + 0.5) == (int) (g + 0.005) * 100)
diff --git a/src/hid/lesstif/styles.c b/src/hid/lesstif/styles.c
index 829caab..9e9b61c 100644
--- a/src/hid/lesstif/styles.c
+++ b/src/hid/lesstif/styles.c
@@ -101,9 +101,9 @@ update_one_value (int i, int v)
   char buf[100];
   double d;
   if (use_mm)
-    d = PCB_TO_MM (v);
+    d = COORD_TO_MM (v);
   else
-    d = PCB_TO_MIL (v);
+    d = COORD_TO_MIL (v);
 
   sprintf (buf, "%.2f", d);
   XmTextSetString (style_values[i], buf);
@@ -172,9 +172,9 @@ style_value_cb (Widget w, int i, void *cbs)
   s = XmTextGetString (w);
   sscanf (s, "%lf", &d);
   if (use_mm)
-    n = MM_TO_PCB (d);
+    n = MM_TO_COORD (d);
   else
-    n = MIL_TO_PCB (d);
+    n = MIL_TO_COORD (d);
   switch (i)
     {
     case SSthick:
diff --git a/src/hid/nelma/nelma.c b/src/hid/nelma/nelma.c
index 6e911ff..7d136d6 100644
--- a/src/hid/nelma/nelma.c
+++ b/src/hid/nelma/nelma.c
@@ -182,12 +182,12 @@ REGISTER_ATTRIBUTES(nelma_attribute_list)
 
 /* *** Utility funcions **************************************************** */
 
-/* convert from default PCB units (1/100 mil) to nelma units */
+/* convert from default PCB units to nelma units */
 	static int      pcb_to_nelma(int pcb)
 {
 	int             nelma;
 
-	nelma = (pcb * nelma_dpi) / 100000;
+	nelma = COORD_TO_INCH(pcb) * nelma_dpi;
 
 	return nelma;
 }
diff --git a/src/hid/png/png.c b/src/hid/png/png.c
index ab64e5a..cb38659 100644
--- a/src/hid/png/png.c
+++ b/src/hid/png/png.c
@@ -316,13 +316,13 @@ parse_bloat (char *str)
   suf[0] = 0;
   sscanf (str, "%lf %s", &val, suf);
   if (strcasecmp (suf, "in") == 0)
-    bloat = val * 100000.0;
+    bloat = INCH_TO_COORD(val);
   else if (strcasecmp (suf, "mil") == 0)
-    bloat = val * 100.0;
+    bloat = MIL_TO_COORD(val);
   else if (strcasecmp (suf, "mm") == 0)
-    bloat = val * MM_TO_COOR;
+    bloat = MM_TO_COORD(val);
   else if (strcasecmp (suf, "um") == 0)
-    bloat = val * MM_TO_COOR / 1000.0;
+    bloat = MM_TO_COORD(val) / 1000.0;
   else if (strcasecmp (suf, "pix") == 0
 	   || strcasecmp (suf, "px") == 0)
     bloat = val * scale;
@@ -628,13 +628,10 @@ png_do_export (HID_Attr_Val * options)
   if (dpi > 0)
     {
       /*
-       * a scale of 1 means 1 pixel is 1/100 mil 
-       * a scale of 100,000 means 1 pixel is 1 inch
-       * FIXME -- need to use a macro to go from PCB units
-       * so if we ever change pcb's internal units, this 
-       * will get updated.
+       * a scale of 1  means 1 pixel is 1 inch
+       * a scale of 10 means 1 pixel is 10 inches
        */
-      scale = 100000.0 / dpi;
+      scale = INCH_TO_COORD(1) / dpi;
       w = w / scale;
       h = h / scale;
     }
diff --git a/src/hid/ps/eps.c b/src/hid/ps/eps.c
index f94175f..afcfb73 100644
--- a/src/hid/ps/eps.c
+++ b/src/hid/ps/eps.c
@@ -231,7 +231,7 @@ eps_hid_export_to_file (FILE * the_file, HID_Attr_Val * options)
 
   in_mono = options[HA_mono].int_value;
 
-#define pcb2em(x) (int)((x) / 100000.0 * 72.0 * options[HA_scale].real_value + 1)
+#define pcb2em(x) (int)(COORD_TO_INCH(x) * 72.0 * options[HA_scale].real_value + 1)
   fprintf (f, "%%%%BoundingBox: 0 0 %d %d\n",
 	   pcb2em (bounds->X2 - bounds->X1),
 	   pcb2em (bounds->Y2 - bounds->Y1));
diff --git a/src/hid/ps/ps.c b/src/hid/ps/ps.c
index a417753..79459d6 100644
--- a/src/hid/ps/ps.c
+++ b/src/hid/ps/ps.c
@@ -110,44 +110,44 @@ typedef struct
  * {A,B,C,D,E}-Size here are the ANSI sizes and not the architectural sizes.
  */
 
-#define MARGINX 50000
-#define MARGINY 50000
+#define MARGINX MIL_TO_COORD(500)
+#define MARGINY MIL_TO_COORD(500)
 
 static MediaType media_data[] = {
-  {"A0", 3311023, 4681102, MARGINX, MARGINY},
-  {"A1", 2338582, 3311023, MARGINX, MARGINY},
-  {"A2", 1653543, 2338582, MARGINX, MARGINY},
-  {"A3", 1169291, 1653543, MARGINX, MARGINY},
-  {"A4", 826771, 1169291, MARGINX, MARGINY},
-  {"A5", 582677, 826771, MARGINX, MARGINY},
-  {"A6", 413385, 582677, MARGINX, MARGINY},
-  {"A7", 291338, 413385, MARGINX, MARGINY},
-  {"A8", 204724, 291338, MARGINX, MARGINY},
-  {"A9", 145669, 204724, MARGINX, MARGINY},
-  {"A10", 102362, 145669, MARGINX, MARGINY},
-  {"B0", 3937007, 5566929, MARGINX, MARGINY},
-  {"B1", 2783464, 3937007, MARGINX, MARGINY},
-  {"B2", 1968503, 2783464, MARGINX, MARGINY},
-  {"B3", 1389763, 1968503, MARGINX, MARGINY},
-  {"B4", 984251, 1389763, MARGINX, MARGINY},
-  {"B5", 692913, 984251, MARGINX, MARGINY},
-  {"B6", 492125, 692913, MARGINX, MARGINY},
-  {"B7", 346456, 492125, MARGINX, MARGINY},
-  {"B8", 244094, 346456, MARGINX, MARGINY},
-  {"B9", 173228, 244094, MARGINX, MARGINY},
-  {"B10", 122047, 173228, MARGINX, MARGINY},
-  {"Letter", 850000, 1100000, MARGINX, MARGINY},
-  {"11x17", 1100000, 1700000, MARGINX, MARGINY},
-  {"Ledger", 1700000, 1100000, MARGINX, MARGINY},
-  {"Legal", 850000, 1400000, MARGINX, MARGINY},
-  {"Executive", 750000, 1000000, MARGINX, MARGINY},
-  {"A-size",  850000, 1100000, MARGINX, MARGINY},
-  {"B-size", 1100000, 1700000, MARGINX, MARGINY},
-  {"C-size", 1700000, 2200000, MARGINX, MARGINY},
-  {"D-size", 2200000, 3400000, MARGINX, MARGINY},
-  {"E-size", 3400000, 4400000, MARGINX, MARGINY},
-  {"US-Business_Card", 350000, 200000, 0, 0},
-  {"Intl-Business_Card", 337500, 212500, 0, 0}
+  {"A0", MM_TO_COORD(841), MM_TO_COORD(1189), MARGINX, MARGINY},
+  {"A1", MM_TO_COORD(594), MM_TO_COORD(841), MARGINX, MARGINY},
+  {"A2", MM_TO_COORD(420), MM_TO_COORD(594), MARGINX, MARGINY},
+  {"A3", MM_TO_COORD(297), MM_TO_COORD(420), MARGINX, MARGINY},
+  {"A4", MM_TO_COORD(210), MM_TO_COORD(297), MARGINX, MARGINY},
+  {"A5", MM_TO_COORD(148), MM_TO_COORD(210), MARGINX, MARGINY},
+  {"A6", MM_TO_COORD(105), MM_TO_COORD(148), MARGINX, MARGINY},
+  {"A7", MM_TO_COORD(74), MM_TO_COORD(105), MARGINX, MARGINY},
+  {"A8", MM_TO_COORD(52), MM_TO_COORD(74), MARGINX, MARGINY},
+  {"A9", MM_TO_COORD(37), MM_TO_COORD(52), MARGINX, MARGINY},
+  {"A10", MM_TO_COORD(26), MM_TO_COORD(37), MARGINX, MARGINY},
+  {"B0", MM_TO_COORD(1000), MM_TO_COORD(1414), MARGINX, MARGINY},
+  {"B1", MM_TO_COORD(707), MM_TO_COORD(1000), MARGINX, MARGINY},
+  {"B2", MM_TO_COORD(500), MM_TO_COORD(707), MARGINX, MARGINY},
+  {"B3", MM_TO_COORD(353), MM_TO_COORD(500), MARGINX, MARGINY},
+  {"B4", MM_TO_COORD(250), MM_TO_COORD(353), MARGINX, MARGINY},
+  {"B5", MM_TO_COORD(176), MM_TO_COORD(250), MARGINX, MARGINY},
+  {"B6", MM_TO_COORD(125), MM_TO_COORD(176), MARGINX, MARGINY},
+  {"B7", MM_TO_COORD(88), MM_TO_COORD(125), MARGINX, MARGINY},
+  {"B8", MM_TO_COORD(62), MM_TO_COORD(88), MARGINX, MARGINY},
+  {"B9", MM_TO_COORD(44), MM_TO_COORD(62), MARGINX, MARGINY},
+  {"B10", MM_TO_COORD(31), MM_TO_COORD(44), MARGINX, MARGINY},
+  {"Letter", INCH_TO_COORD(8.5), INCH_TO_COORD(11), MARGINX, MARGINY},
+  {"11x17", INCH_TO_COORD(11), INCH_TO_COORD(17), MARGINX, MARGINY},
+  {"Ledger", INCH_TO_COORD(17), INCH_TO_COORD(11), MARGINX, MARGINY},
+  {"Legal", INCH_TO_COORD(8.5), INCH_TO_COORD(14), MARGINX, MARGINY},
+  {"Executive", INCH_TO_COORD(7.5), INCH_TO_COORD(10), MARGINX, MARGINY},
+  {"A-size",  INCH_TO_COORD(8.5), INCH_TO_COORD(11), MARGINX, MARGINY},
+  {"B-size", INCH_TO_COORD(11), INCH_TO_COORD(17), MARGINX, MARGINY},
+  {"C-size", INCH_TO_COORD(17), INCH_TO_COORD(22), MARGINX, MARGINY},
+  {"D-size", INCH_TO_COORD(22), INCH_TO_COORD(34), MARGINX, MARGINY},
+  {"E-size", INCH_TO_COORD(34), INCH_TO_COORD(44), MARGINX, MARGINY},
+  {"US-Business_Card", INCH_TO_COORD(3.5), INCH_TO_COORD(2.0), 0, 0},
+  {"Intl-Business_Card", INCH_TO_COORD(3.375), INCH_TO_COORD(2.125), 0, 0}
 };
 
 #undef MARGINX
@@ -349,8 +349,8 @@ ps_start_file (FILE *f)
    */
   fprintf (f, "%%%%DocumentMedia: %s %g %g 0 \"\" \"\"\n",
 	   media_data[media].name,
-	   media_data[media].Width * 72.0 / 100000.0,
-	   media_data[media].Height * 72.0 / 100000.0);
+	   COORD_TO_INCH(media_data[media].Width) * 72.0,
+	   COORD_TO_INCH(media_data[media].Height) * 72.0);
   fprintf (f, "%%%%DocumentPaperSizes: %s\n",
 	   media_data[media].name);
 
@@ -615,8 +615,8 @@ corner (int x, int y, int dx, int dy)
   int len = (PCB->MaxWidth + PCB->MaxHeight) / 10;
   int len2 = (PCB->MaxWidth + PCB->MaxHeight) / 50;
 #else
-  int len = 200000;
-  int len2 = 20000;
+  int len = MIL_TO_COORD(2000);
+  int len2 = MIL_TO_COORD(200);
 #endif
   int thick = 0;
   /*
@@ -790,7 +790,7 @@ ps_set_layer (const char *name, int group, int empty)
        * If users don't want to make smaller boards, or use fewer drill
        * sizes, they can always ignore this sheet. */
       if (SL_TYPE (idx) == SL_FAB) {
-        int natural = (int) ((boffset - 0.5) * 100000) - PCB->MaxHeight / 2;
+        int natural = (int) ((boffset - 0.5) * INCH_TO_COORD(1)) - PCB->MaxHeight / 2;
 	int needed  = PrintFab_overhang();
         fprintf (f, "%% PrintFab overhang natural %d, needed %d\n", natural, needed);
 	if (needed > natural)
@@ -840,7 +840,7 @@ ps_set_layer (const char *name, int group, int empty)
       fprintf (f, "/a { gsave setlinewidth translate scale 0 0 1 5 3 roll arc stroke grestore} bind def\n");
       if (drill_helper)
 	fprintf (f,
-		 "/dh { gsave %d setlinewidth 0 gray %d 0 360 arc stroke grestore} bind def\n",
+		 "/dh { gsave %f setlinewidth 0 gray %f 0 360 arc stroke grestore} bind def\n",
 		 MIN_PINORVIAHOLE, MIN_PINORVIAHOLE * 3 / 2);
     }
 #if 0
diff --git a/src/main.c b/src/main.c
index d14c935..ab9a614 100644
--- a/src/main.c
+++ b/src/main.c
@@ -484,24 +484,24 @@ HID_Attribute main_attribute_list[] = {
   COLOR (WarnColor, "#ff8000", "warn-color", "color for warnings"),
   COLOR (MaskColor, "#ff0000", "mask-color", "color for solder mask"),
 
-  ISET (ViaThickness, 6000, "via-thickness", 0),
-  ISET (ViaDrillingHole, 2800, "via-drilling-hole", 0),
-  ISET (LineThickness, 1000, "line-thickness",
+  ISET (ViaThickness, MIL_TO_COORD(60), "via-thickness", 0),
+  ISET (ViaDrillingHole, MIL_TO_COORD(28), "via-drilling-hole", 0),
+  ISET (LineThickness, MIL_TO_COORD(10), "line-thickness",
 	"Initial thickness of new lines."),
-  ISET (RatThickness, 1000, "rat-thickness", 0),
-  ISET (Keepaway, 1000, "keepaway", 0),
-  ISET (MaxWidth, 600000, "default-PCB-width", 0),
-  ISET (MaxHeight, 500000, "default-PCB-height", 0),
+  ISET (RatThickness, MIL_TO_COORD(10), "rat-thickness", 0),
+  ISET (Keepaway, MIL_TO_COORD(10), "keepaway", 0),
+  ISET (MaxWidth, MIL_TO_COORD(MIL_TO_COORD(60)), "default-PCB-width", 0),
+  ISET (MaxHeight, MIL_TO_COORD(MIL_TO_COORD(50)), "default-PCB-height", 0),
   ISET (TextScale, 100, "text-scale", 0),
-  ISET (AlignmentDistance, 200, "alignment-distance", 0),
-  ISET (Bloat, 1000, "bloat", 0),
-  ISET (Shrink, 1000, "shrink", 0),
-  ISET (minWid, 1000, "min-width", "DRC minimum copper spacing"),
-  ISET (minSlk, 1000, "min-silk", "DRC minimum silk width"),
-  ISET (minDrill, 1500, "min-drill", "DRC minimum drill diameter"),
-  ISET (minRing, 1000, "min-ring", "DRC minimum annular ring"),
-
-  RSET (Grid, 1000, "grid", 0),
+  ISET (AlignmentDistance, MIL_TO_COORD(2), "alignment-distance", 0),
+  ISET (Bloat, MIL_TO_COORD(10), "bloat", 0),
+  ISET (Shrink, MIL_TO_COORD(10), "shrink", 0),
+  ISET (minWid, MIL_TO_COORD(10), "min-width", "DRC minimum copper spacing"),
+  ISET (minSlk, MIL_TO_COORD(10), "min-silk", "DRC minimum silk width"),
+  ISET (minDrill, MIL_TO_COORD(15), "min-drill", "DRC minimum drill diameter"),
+  ISET (minRing, MIL_TO_COORD(10), "min-ring", "DRC minimum annular ring"),
+
+  RSET (Grid, MIL_TO_COORD(10), "grid", 0),
   RSET (grid_increment_mm, 0.1, "grid-increment-mm", 0),
   RSET (grid_increment_mil, 5.0, "grid-increment-mil", 0),
   RSET (size_increment_mm, 0.2, "size-increment-mm", 0),
@@ -510,7 +510,7 @@ HID_Attribute main_attribute_list[] = {
   RSET (line_increment_mil, 5.0, "line-increment-mil", 0),
   RSET (clear_increment_mm, 0.05, "clear-increment-mm", 0),
   RSET (clear_increment_mil, 2.0, "clear-increment-mil", 0),
-  RSET (IsleArea, 200000000, "minimum polygon area", 0),
+  RSET (IsleArea, MIL_TO_COORD(1400) * MIL_TO_COORD(1400), "minimum polygon area", 0),
 
   ISET (BackupInterval, 60, "backup-interval", 0),
 
@@ -564,10 +564,10 @@ HID_Attribute main_attribute_list[] = {
   SSET (GnetlistProgram, NULL, "gnetlist",
 	"Sets the name and optionally full path to the gnetlist(3) program"),
 
-  ISET (PinoutOffsetX, 100, "pinout-offset-x", 0),
-  ISET (PinoutOffsetY, 100, "pinout-offset-y", 0),
-  ISET (PinoutTextOffsetX, 800, "pinout-text-offset-x", 0),
-  ISET (PinoutTextOffsetY, -100, "pinout-text-offset-y", 0),
+  ISET (PinoutOffsetX, MIL_TO_COORD(1), "pinout-offset-x", 0),
+  ISET (PinoutOffsetY, MIL_TO_COORD(1), "pinout-offset-y", 0),
+  ISET (PinoutTextOffsetX, MIL_TO_COORD(8), "pinout-text-offset-x", 0),
+  ISET (PinoutTextOffsetY, MIL_TO_COORD(-1), "pinout-text-offset-y", 0),
 
   BSET (DrawGrid, 0, "draw-grid", "default to drawing the grid at startup"),
   BSET (ClearLine, 1, "clear-line", 0),
@@ -609,11 +609,11 @@ REGISTER_ATTRIBUTES (main_attribute_list)
 
   if (Settings.LineThickness > MAX_LINESIZE
       || Settings.LineThickness < MIN_LINESIZE)
-    Settings.LineThickness = 1000;
+    Settings.LineThickness = MIL_TO_COORD(10);
 
   if (Settings.ViaThickness > MAX_PINORVIASIZE
       || Settings.ViaThickness < MIN_PINORVIASIZE)
-    Settings.ViaThickness = 4000;
+    Settings.ViaThickness = MIL_TO_COORD(40);
 
   if (Settings.ViaDrillingHole <= 0)
     Settings.ViaDrillingHole =
diff --git a/src/misc.c b/src/misc.c
index 5bea138..0e25089 100644
--- a/src/misc.c
+++ b/src/misc.c
@@ -139,13 +139,13 @@ GetValue (const char *val, const char *units, bool * absolute)
   if (units && *units)
     {
       if (strncasecmp (units, "mm", 2) == 0)
-        value *= MM_TO_COOR;
+        value = MM_TO_COORD(value);
       else if (strncasecmp (units, "cm", 2) == 0)
-        value *= MM_TO_COOR * 10;
+        value = 10 * MM_TO_COORD(value);
       else if (strncasecmp (units, "mil", 3) == 0)
-        value *= 100;
+        value = MIL_TO_COORD(value);
       else if (strncasecmp (units, "in", 3) == 0)
-        value *= 100000;
+        value = INCH_TO_COORD(value);
     }
   return value;
 }
@@ -841,7 +841,7 @@ ParseRouteString (char *s, RouteStyleTypePtr routeStyle, int scale)
       /* for backwards-compatibility, we use a 10-mil default
        * for styles which omit the keepaway specification. */
       if (*s != ',')
-        routeStyle->Keepaway = 1000;
+        routeStyle->Keepaway = MIL_TO_COORD(10);
       else
         {
           s++;
diff --git a/src/parse_l.l b/src/parse_l.l
index 57cd1c6..56d3b84 100644
--- a/src/parse_l.l
+++ b/src/parse_l.l
@@ -143,10 +143,10 @@ Attribute	{ return(T_ATTRIBUTE); }
 						yylval.number = (unsigned) *(yytext+1);
 						return(CHAR_CONST);
 					}
-{FLOATINGMM}		{	return parse_number(3937.0079); }
-{FLOATINGUM}		{	return parse_number(3.9370079); }
-{FLOATINGIN}		{	return parse_number(100000.0); }
-{FLOATINGMIL}		{	return parse_number(100.0); }
+{FLOATINGMM}		{	return parse_number(MM_TO_COORD(1)); }
+{FLOATINGUM}		{	return parse_number(MM_TO_COORD(1) * 1000); }
+{FLOATINGIN}		{	return parse_number(INCH_TO_COORD(1)); }
+{FLOATINGMIL}		{	return parse_number(MIL_TO_COORD(1)); }
 {DECIMAL}		{	return parse_number(1.0); }
 
 {HEX}			{
diff --git a/src/print.c b/src/print.c
index cd19d31..286888d 100644
--- a/src/print.c
+++ b/src/print.c
@@ -316,12 +316,12 @@ PrintFab (void)
       /*FPrintOutline (); */
       gui->set_line_width (Output.fgGC, FAB_LINE_W);
       text_at (200000, yoff, 0,
-	       "Maximum Dimensions: %d mils wide, %d mils high",
-	       PCB->MaxWidth / 100, PCB->MaxHeight / 100);
+	       "Maximum Dimensions: %f mils wide, %f mils high",
+	       COORD_TO_MIL(PCB->MaxWidth), COORD_TO_MIL(PCB->MaxHeight));
       text_at (PCB->MaxWidth / 2, PCB->MaxHeight + 2000, 1,
-	       "Board outline is the centerline of this %d mil"
-	       " rectangle - 0,0 to %d,%d mils",
-	       FAB_LINE_W / 100, PCB->MaxWidth / 100, PCB->MaxHeight / 100);
+	       "Board outline is the centerline of this %f mil"
+	       " rectangle - 0,0 to %f,%f mils",
+	       COORD_TO_MIL(FAB_LINE_W), COORD_TO_MIL(PCB->MaxWidth), COORD_TO_MIL(PCB->MaxHeight));
     }
   else
     {
diff --git a/src/report.c b/src/report.c
index 6adf368..5131ec6 100644
--- a/src/report.c
+++ b/src/report.c
@@ -54,7 +54,7 @@
 
 static double
 units(double value)
-{return (Settings.grid_units_mm ? (value * COOR_TO_MM) : (value / 100.0));}
+{return (Settings.grid_units_mm ? COORD_TO_MM(value) : COORD_TO_MIL(value));}
 
 #define UNIT(value) units(value), (Settings.grid_units_mm ? "mm" : "mils")
 
@@ -619,17 +619,17 @@ ReportAllNetLengths (int argc, char **argv, int x, int y)
   if (strcasecmp (units_name, "mm") == 0)
     {
       prec = 4;
-      scale = COOR_TO_MM;
+      scale = COORD_TO_MM(1);
     }
   else if (strcasecmp (units_name, "mil") == 0)
     {
       prec = 2;
-      scale = .01;
+      scale = COORD_TO_MIL(1);
     }
   else if (strcasecmp (units_name, "in") == 0)
     {
       prec = 5;
-      scale = 1./100000;
+      scale = COORD_TO_INCH(1);
     }
   else
     {
diff --git a/src/vendor.c b/src/vendor.c
index 754f7d1..aa766bb 100644
--- a/src/vendor.c
+++ b/src/vendor.c
@@ -327,29 +327,25 @@ ActionLoadVendorFrom (int argc, char **argv, int x, int y)
   sval = resource_value (res, "units");
   if (sval == NULL)
     {
-      sf = 100;
+      sf = MIL_TO_COORD(1);
     }
   else if ((NSTRCMP (sval, "mil") == 0) || (NSTRCMP (sval, "mils") == 0))
     {
-      sf = 100;
+      sf = MIL_TO_COORD(1);
     }
   else if ((NSTRCMP (sval, "inch") == 0) || (NSTRCMP (sval, "inches") == 0))
     {
-      sf = 100000;
+      sf = INCH_TO_COORD(1);
     }
   else if (NSTRCMP (sval, "mm") == 0)
     {
-      /* 
-       * divide by .0254 to convert mm to mils.  Then multiply by 100
-       * for PCB units
-       */
-      sf = (100.0 / 0.0254);
+      sf = MM_TO_COORD(1);
     }
   else
     {
       Message ("\"%s\" is not a supported units.  Defaulting to inch\n",
 	       sval);
-      sf = 100000;
+      sf = INCH_TO_COORD(1);
     }

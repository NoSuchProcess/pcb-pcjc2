Bottom: 998694800e6685c6283a4191877a80c0cf44fa3f
Top:    c5882c19beacfd53f5ad72082476dde4ab6a0093
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-11-17 01:35:54 +0000

Play with some lighting effects (SLOW!!!)


---

diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index a2b1d2a..d8cae7f 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -951,7 +951,6 @@ hidgl_fill_rect (int x1, int y1, int x2, int y2)
 static void
 printLog(GLuint obj)
 {
-  return;
   int infologLength = 0;
   int maxLength;
   char *infoLog;
@@ -1012,11 +1011,13 @@ file2string (const char *path)
 }
 
 GLuint sp; /* Shader Program */
+GLuint sp2; /* Shader Program2 */
 
 void
 hidgl_load_frag_shader (void)
 {
 //  char *vs_source;
+
   char *fs_source = "void main()\n"
                     "{\n"
                     "  float sqdist;\n"
@@ -1026,6 +1027,31 @@ hidgl_load_frag_shader (void)
                     "  gl_FragColor = gl_Color;\n"
                     "}\n";
 
+  char *fs2_source =
+                    "uniform sampler1D detail_tex;\n"
+                    "uniform sampler2D bump_tex;\n"
+                    "\n"
+                    "void main()\n"
+                    "{\n"
+                    "  vec3 detailColor = texture1D (detail_tex, gl_TexCoord[0].s).rgb;\n"
+                    "  vec3 bumpHeight = texture2D (bump_tex, gl_TexCoord[1].st).rgb;\n"
+                    "\n"
+                    "  /* Uncompress vectors ([0, 1] -> [-1, 1]) */\n"
+                    "  vec3 lightVectorFinal = 2.0 * (gl_Color.rgb - 0.5);\n"
+                    "  vec3 bumpNormalVectorFinal = 2.0 * (bumpHeight - 0.5);\n"
+                    "\n"
+                    "  /* Compute diffuse factor */\n"
+//                    "  float diffuse = clamp(dot(bumpNormalVectorFinal, lightVectorFinal),0.0, 1.0);\n"
+                    "  float diffuse = pow(clamp(dot(bumpNormalVectorFinal, lightVectorFinal),0.0, 1.0), 70);\n"
+                    "\n"
+//                    "  vec3 eye_light = vec3 (0.0, -0.5, 1.0);\n"
+//                    "  vec3 
+//                    ""
+                    "\n"
+//                    "  gl_FragColor = vec4(clamp((diffuse * 1.0 + 0.0) * detailColor, 0.0, 1.0), 1.0);\n"
+                    "   gl_FragColor = vec4(detailColor + vec3(diffuse, diffuse, diffuse), 1.0);\n"
+                    "}\n";
+
   /* Compile and load the program */
 
 //  GLuint vs; /* Vertex Shader */
@@ -1070,6 +1096,16 @@ hidgl_load_frag_shader (void)
   glUniform1f(waveHeightLoc, waveHeight);
 
   }
+
+  fs = glCreateShader (GL_FRAGMENT_SHADER);
+  glShaderSource (fs, 1, &fs2_source, NULL);
+  glCompileShader (fs);
+  printLog (fs);
+  sp2 = glCreateProgram ();
+  glAttachShader (sp2, fs);
+  glLinkProgram (sp2);
+  glUseProgram (sp2);
+
 }
 
 void
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index e41eac9..c14d33d 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -325,10 +325,94 @@ ghid_draw_grid (BoxTypePtr drawn_area)
   glEnable (GL_STENCIL_TEST);
 }
 
+static int
+compute_offset (int x, int y, int width, int height)
+{
+  x = (x + width) % width;
+  y = (y + height) % height;
+  return (y * width + x) * 4;
+}
+
+static void
+load_texture_from_png (char *filename)
+{
+  GError *error = NULL;
+  GdkPixbuf *pixbuf;
+  int width;
+  int height;
+  int rowstride;
+  int has_alpha;
+  int bits_per_sample;
+  int n_channels;
+  unsigned char *pixels;
+  unsigned char *new_pixels;
+  int x, y;
+
+  pixbuf = gdk_pixbuf_new_from_file (filename, &error);
+
+  if (pixbuf == NULL) {
+    g_error ("%s", error->message);
+    g_error_free (error);
+    error = NULL;
+    return;
+  }
+
+  width = gdk_pixbuf_get_width (pixbuf);
+  height = gdk_pixbuf_get_height (pixbuf);
+  rowstride = gdk_pixbuf_get_rowstride (pixbuf);
+  has_alpha = gdk_pixbuf_get_has_alpha (pixbuf);
+  bits_per_sample = gdk_pixbuf_get_bits_per_sample (pixbuf);
+  n_channels = gdk_pixbuf_get_n_channels (pixbuf);
+  pixels = gdk_pixbuf_get_pixels (pixbuf);
+
+  g_warn_if_fail (bits_per_sample == 8);
+  g_warn_if_fail (n_channels == 4);
+  g_warn_if_fail (rowstride == width * n_channels);
+
+  new_pixels = malloc (width * height * 4);
+
+  /* XXX: Move computing bump map out of the texture loading function */
+  for (y = 0; y < height; y++)
+    for (x = 0; x < width; x++) {
+      float r, g, b;
+      float lenvec;
+
+      float dx = (pixels[compute_offset (x + 1, y, width, height)] - pixels[compute_offset (x - 1, y, width, height)]) / 255.;
+      float dy = (pixels[compute_offset (x, y + 1, width, height)] - pixels[compute_offset (x, y - 1, width, height)]) / 255.;
+
+      r = -dx;
+      g = -dy;
+      b = 1.;
+      lenvec = sqrt (r * r + g * g + b * b);
+
+      r /= lenvec;
+      g /= lenvec;
+      b /= lenvec;
+
+      new_pixels [compute_offset (x, y, width, height) + 0] =
+        (unsigned char)((r / 2. + 0.5) * 255.);
+      new_pixels [compute_offset (x, y, width, height) + 1] =
+        (unsigned char)((g / 2. + 0.5) * 255.);
+      new_pixels [compute_offset (x, y, width, height) + 2] =
+        (unsigned char)((b / 2. + 0.5) * 255.);
+      new_pixels [compute_offset (x, y, width, height) + 3] = 255;
+    }
+
+  memcpy (pixels, new_pixels, width * height * 4);
+  gdk_pixbuf_save (pixbuf, "debug_bumps.png", "png", NULL, NULL);
+
+  glTexImage2D (GL_TEXTURE_2D, 0, GL_RGB, width, height, 0,
+                (n_channels == 4) ? GL_RGBA : GL_RGB, GL_UNSIGNED_BYTE, new_pixels);
+
+  free (new_pixels);
+  g_object_unref (pixbuf);
+}
+
+
 static void
 setup_resistor_texture (GLfloat *body_color, float value)
 {
-  GLuint texture;
+//  GLuint texture;
   GLfloat tex_data[] = {body_color[0], body_color[1], body_color[2],
                         body_color[0], body_color[1], body_color[2],
                         body_color[0], body_color[1], body_color[2],
@@ -340,14 +424,115 @@ setup_resistor_texture (GLfloat *body_color, float value)
                         body_color[0], body_color[1], body_color[2],
                         body_color[0], body_color[1], body_color[2]};
 
-  glGenTextures (1, &texture);
-  glBindTexture (GL_TEXTURE_1D, texture);
+//  glGenTextures (1, &texture);
+//  glBindTexture (GL_TEXTURE_1D, texture);
   glTexImage1D (GL_TEXTURE_1D, 0, GL_RGB, 10, 1, GL_RGB, GL_FLOAT, tex_data);
 }
 
+static void invert_4x4 (float m[4][4], float out[4][4]);
+
+/* b1{x,y,z} is the basis vector along "s" texture space */
+/* b2{x,y,z} is the basis vector along "t" texture space */
+static void
+compute_light_vector (float b1x, float b1y, float b1z,
+                      float b2x, float b2y, float b2z,
+                      float *lx, float *ly, float *lz)
+{
+  float tb1x, tb1y, tb1z;
+  float tb2x, tb2y, tb2z;
+  float tb3x, tb3y, tb3z;
+  float mvm[16]; /* NB: TRANSPOSED IN MEMORY */
+  float light_direction[] = {0., 0.5, -1. /* + 1.0 */}; /* XXX: HARDCODEED! */
+  float texspace_to_eye[4][4];
+  float eye_to_texspace[4][4];
+  float lenb1, lenb2;
+
+  float len_light;
+  len_light = sqrt (light_direction[0] * light_direction[0] + light_direction[1] * light_direction[1] + light_direction[2] * light_direction[2]);
+  light_direction[0] /= len_light;
+  light_direction[1] /= len_light;
+  light_direction[2] /= len_light;
+
+  light_direction[0] /= 2.;
+  light_direction[1] /= 2.;
+  light_direction[2] /= 2.;
+
+  light_direction[0] += 0. / 2.;
+  light_direction[1] += 0. / 2.;
+  light_direction[2] += -1. / 2.;
+
+  /* XXX: Should cache this ourselves */
+  glGetFloatv (GL_MODELVIEW_MATRIX, (GLfloat *)mvm);
+
+  /* Transform the S, T texture space bases into eye coordinates */
+  tb1x = mvm[0] * b1x + mvm[4] * b1y + mvm[ 8] * b1z;// + mvm[12] * 1;
+  tb1y = mvm[1] * b1x + mvm[5] * b1y + mvm[ 9] * b1z;// + mvm[13] * 1;
+  tb1z = mvm[2] * b1x + mvm[6] * b1y + mvm[10] * b1z;// + mvm[14] * 1;
+  // tb1w = mvm[3] * b1x + mvm[7] * b1y + mvm[11] * b1z + mvm[15] * 1;
+
+  tb2x = mvm[0] * b2x + mvm[4] * b2y + mvm[ 8] * b2z;// + mvm[12] * 1;
+  tb2y = mvm[1] * b2x + mvm[5] * b2y + mvm[ 9] * b2z;// + mvm[13] * 1;
+  tb2z = mvm[2] * b2x + mvm[6] * b2y + mvm[10] * b2z;// + mvm[14] * 1;
+  // tb2w = mvm[3] * b2x + mvm[7] * b2y + mvm[11] * b2z + mvm[15] * 1;
+
+  /* Normalise tb1 and tb2 */
+  lenb1 = sqrt (tb1x * tb1x + tb1y * tb1y + tb1z * tb1z);
+  lenb2 = sqrt (tb2x * tb2x + tb2y * tb2y + tb2z * tb2z);
+  tb1x /= lenb1;  tb1y /= lenb1;  tb1z /= lenb1;
+  tb2x /= lenb2;  tb2y /= lenb2;  tb2z /= lenb2;
+
+  /* Third basis vector is the cross product of tb1 and tb2 */
+  tb3x = tb1y * tb2z - tb1z * tb2y;
+  tb3y = tb1z * tb2x - tb1x * tb2z;
+  tb3z = tb1x * tb2y - tb1y * tb2x;
+
+  texspace_to_eye[0][0] = tb1x; texspace_to_eye[0][1] = tb2x; texspace_to_eye[0][2] = tb3x;  texspace_to_eye[0][3] = 0.0;
+  texspace_to_eye[1][0] = tb1y; texspace_to_eye[1][1] = tb2y; texspace_to_eye[1][2] = tb3y;  texspace_to_eye[1][3] = 0.0;
+  texspace_to_eye[2][0] = tb1z; texspace_to_eye[2][1] = tb2z; texspace_to_eye[2][2] = tb3z;  texspace_to_eye[2][3] = 0.0;
+  texspace_to_eye[3][0] = 0.0;  texspace_to_eye[3][1] = 0.0;  texspace_to_eye[3][2] = 0.0;   texspace_to_eye[3][3] = 1.0;
+
+  invert_4x4 (texspace_to_eye, eye_to_texspace);
+
+  /* light_direction is in eye space, we need to transform this into texture space */
+  *lx = eye_to_texspace[0][0] * light_direction[0] +
+        eye_to_texspace[0][1] * light_direction[1] +
+        eye_to_texspace[0][2] * light_direction[2];// +
+//        eye_to_texspace[0][3];
+  *ly = eye_to_texspace[1][0] * light_direction[0] +
+        eye_to_texspace[1][1] * light_direction[1] +
+        eye_to_texspace[1][2] * light_direction[2];// +
+//        eye_to_texspace[1][3];
+  *lz = eye_to_texspace[2][0] * light_direction[0] +
+        eye_to_texspace[2][1] * light_direction[1] +
+        eye_to_texspace[2][2] * light_direction[2];// +
+//        eye_to_texspace[2][3];
+  /* Could assert the lw coordinate ends up as 1, but can't be bothered */
+
+  /* Light comes FROM the direction above, flip the vector */
+//  *lx = -*lx;
+//  *ly = -*ly;
+//  *lz = -*lz;
+
+  {
+    float lenvec;
+    lenvec = sqrt (*lx * *lx + *ly * *ly + *lz * *lz);
+    *lx /= lenvec;
+    *ly /= lenvec;
+    *lz /= lenvec;
+
+    *lx = *lx / 2. + 0.5;
+    *ly = *ly / 2. + 0.5;
+    *lz = *lz / 2. + 0.5;
+  }
+}
+
+
 #define NUM_RESISTOR_STRIPS 100
 #define NUM_PIN_RINGS 15
 #define MIL_TO_INTERNAL 100.
+#define REPS 4.
+#define REPT 4.
+
 static void
 ghid_draw_acy_resistor (ElementType *element)
 {
@@ -362,8 +547,14 @@ ghid_draw_acy_resistor (ElementType *element)
   int ring;
   int no_rings = NUM_PIN_RINGS;
   int end;
+//  float lx, ly, lz;
 
-  GLint sp;
+  static bool first_run = true;
+  static int texture1;
+  static int texture2;
+
+  extern GLuint sp;
+  extern GLuint sp2;
 
   /* XXX: Hard-coded magic */
   float resistor_bulge_radius = 45. * MIL_TO_INTERNAL;
@@ -395,22 +586,54 @@ ghid_draw_acy_resistor (ElementType *element)
   glRotatef (90, 1., 0., 0.);
 
   /* TEXTURE SETUP */
-  glGetIntegerv (GL_CURRENT_PROGRAM, &sp);
-  glUseProgram (0);
-  setup_resistor_texture (resistor_body_color, 0);
-  glEnable (GL_TEXTURE_1D);
+  //glGetIntegerv (GL_CURRENT_PROGRAM, &sp);
+  //glUseProgram (0);
+  glUseProgram (sp2);
 
+  {
+    int tex0_location = glGetUniformLocation (sp2, "detail_tex");
+    int tex1_location = glGetUniformLocation (sp2, "bump_tex");
+    glUniform1i (tex0_location, 0);
+    glUniform1i (tex1_location, 1);
+  }
+
+  glActiveTextureARB (GL_TEXTURE0_ARB);
+  if (first_run) {
+    glGenTextures (1, &texture1);
+    glBindTexture (GL_TEXTURE_1D, texture1);
+    setup_resistor_texture (resistor_body_color, 0);
+  } else {
+    glBindTexture (GL_TEXTURE_1D, texture1);
+  }
   glTexEnvf (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
   glTexParameterf (GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
   glTexParameterf (GL_TEXTURE_1D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
   glTexParameterf (GL_TEXTURE_1D, GL_TEXTURE_WRAP_S, GL_CLAMP);
+  glEnable (GL_TEXTURE_1D);
+
+  glActiveTextureARB (GL_TEXTURE1_ARB);
+  if (first_run) {
+    glGenTextures (1, &texture2);
+    glBindTexture (GL_TEXTURE_2D, texture2);
+    load_texture_from_png ("bumps.png");
+  } else {
+    glBindTexture (GL_TEXTURE_2D, texture2);
+  }
+  glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+  glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+  glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
+  glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
+  glEnable (GL_TEXTURE_2D);
 
   /* COLOR / MATERIAL SETUP */
-  glColorMaterial (GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
-  glEnable (GL_COLOR_MATERIAL);
+//  glColorMaterial (GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
+//  glEnable (GL_COLOR_MATERIAL);
 
   glPushAttrib (GL_CURRENT_BIT);
-  glColor4f (1., 1., 1., 1.);
+//  glColor4f (1., 1., 1., 1.);
+  glColor4f (0., 0., 1., 0.);
+
+  glDisable (GL_LIGHTING);
 
   if (1) {
     GLfloat emission[] = {0.0f, 0.0f, 0.0f, 1.0f};
@@ -421,6 +644,37 @@ ghid_draw_acy_resistor (ElementType *element)
     glMaterialfv (GL_FRONT_AND_BACK, GL_SHININESS, &shininess);
   }
 
+#if 0
+#define WIDTH 4000
+#define LENGTH 10000
+
+  glBegin (GL_TRIANGLE_STRIP);
+    compute_light_vector (1, 0, 0, 0, 0, 1, &lx, &ly, &lz);
+    glColor3f (lx, ly, lz);
+    glMultiTexCoord1f (GL_TEXTURE0, 0.);
+    glMultiTexCoord2f (GL_TEXTURE1, REPS, -REPT);
+    glVertex3f (WIDTH, 0., -LENGTH);
+
+    compute_light_vector (1, 0, 0, 0, 0, 1, &lx, &ly, &lz);
+    glColor3f (lx, ly, lz);
+    glMultiTexCoord1f (GL_TEXTURE0, 1.);
+    glMultiTexCoord2f (GL_TEXTURE1, REPS, REPT);
+    glVertex3f (WIDTH, 0., LENGTH);
+
+    compute_light_vector (1, 0, 0, 0, 0, 1, &lx, &ly, &lz);
+    glColor3f (lx, ly, lz);
+    glMultiTexCoord1f (GL_TEXTURE0, 0.);
+    glMultiTexCoord2f (GL_TEXTURE1, -REPS, -REPT);
+    glVertex3f (-WIDTH, 0., -LENGTH);
+
+    compute_light_vector (1, 0, 0, 0, 0, 1, &lx, &ly, &lz);
+    glColor3f (lx, ly, lz);
+    glMultiTexCoord1f (GL_TEXTURE0, 1.);
+    glMultiTexCoord2f (GL_TEXTURE1, -REPS, REPT);
+    glVertex3f (-WIDTH, 0., LENGTH);
+#endif
+
+#if 1
   glBegin (GL_TRIANGLE_STRIP);
 
   for (strip = 0; strip < no_strips; strip++) {
@@ -435,114 +689,275 @@ ghid_draw_acy_resistor (ElementType *element)
     float z;
     float r;
 
+    float lx, ly, lz;
+
     z = -resistor_width / 2.;
     r = resistor_pin_radius;
     /* repeat first vertex */
-    glTexCoord1f (0.);
+    compute_light_vector (y_strip_edge1, -x_strip_edge1, 0,
+                          y_strip_edge1 * (resistor_barrel_radius - resistor_pin_radius), -x_strip_edge1 * (resistor_barrel_radius - resistor_pin_radius), resistor_bulge_offset,
+                          &lx, &ly, &lz);
+    glColor3f (lx, ly, lz);
+    glMultiTexCoord1f (GL_TEXTURE0, 0.);
+    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
+                                    (angle_strip_edge1 / 2. / M_PI) * REPT);
     glNormal3f (0., 0., -1.);
     glVertex3f (r * x_strip_edge1, r * y_strip_edge1, z);
-    glTexCoord1f (0.);
+    compute_light_vector (y_strip_edge1, -x_strip_edge1, 0,
+                          y_strip_edge1 * (resistor_barrel_radius - resistor_pin_radius), -x_strip_edge1 * (resistor_barrel_radius - resistor_pin_radius), resistor_bulge_offset,
+                          &lx, &ly, &lz);
+    glColor3f (lx, ly, lz);
+    glMultiTexCoord1f (GL_TEXTURE0, 0.);
+    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
+                                    (angle_strip_edge1 / 2. / M_PI) * REPT);
     glNormal3f (0., 0., -1.);
     glVertex3f (r * x_strip_edge1, r * y_strip_edge1, z);
-    glTexCoord1f (0.);
+    compute_light_vector (y_strip_edge2, -x_strip_edge2, 0,
+                          y_strip_edge2 * (resistor_barrel_radius - resistor_pin_radius), -x_strip_edge2 * (resistor_barrel_radius - resistor_pin_radius), resistor_bulge_offset,
+                          &lx, &ly, &lz);
+    glColor3f (lx, ly, lz);
+    glMultiTexCoord1f (GL_TEXTURE0, 0.);
+    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
+                                    (angle_strip_edge2 / 2. / M_PI) * REPT);
     glNormal3f (0., 0., -1.);
     glVertex3f (r * x_strip_edge2, r * y_strip_edge2, z);
 
+
+
     z = -resistor_width / 2. + resistor_bulge_offset;
     r = resistor_barrel_radius;
-    glTexCoord1f (0.);
+    compute_light_vector (y_strip_edge1, -x_strip_edge1, 0,
+                          y_strip_edge1 * (resistor_bulge_radius - resistor_barrel_radius), -x_strip_edge1 * (resistor_bulge_radius - resistor_barrel_radius), resistor_bulge_width * 1. / 4.,
+                          &lx, &ly, &lz);
+    glColor3f (lx, ly, lz);
+    glMultiTexCoord1f (GL_TEXTURE0, 0.);
+    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
+                                    (angle_strip_edge1 / 2. / M_PI) * REPT);
     glNormal3f (x_strip_edge1, y_strip_edge1, 0.);
     glVertex3f (r * x_strip_edge1, r * y_strip_edge1, z);
-    glTexCoord1f (0.);
+    compute_light_vector (y_strip_edge2, -x_strip_edge2, 0,
+                          y_strip_edge2 * (resistor_bulge_radius - resistor_barrel_radius), -x_strip_edge2 * (resistor_bulge_radius - resistor_barrel_radius), resistor_bulge_width * 1. / 4.,
+                          &lx, &ly, &lz);
+    glColor3f (lx, ly, lz);
+    glMultiTexCoord1f (GL_TEXTURE0, 0.);
+    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
+                                    (angle_strip_edge2 / 2. / M_PI) * REPT);
     glNormal3f (x_strip_edge2, y_strip_edge2, 0.);
     glVertex3f (r * x_strip_edge2, r * y_strip_edge2, z);
 
+
+
     z = -resistor_width / 2. + resistor_bulge_offset + resistor_bulge_width * 1. / 4.;
     r = resistor_bulge_radius;
-    glTexCoord1f (0.);
+    compute_light_vector (y_strip_edge1, -x_strip_edge1, 0,
+                          0, 0, 1,
+                          &lx, &ly, &lz);
+    glColor3f (lx, ly, lz);
+    glMultiTexCoord1f (GL_TEXTURE0, 0.);
+    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
+                                    (angle_strip_edge1 / 2. / M_PI) * REPT);
     glNormal3f (x_strip_edge1, y_strip_edge1, 0.);
     glVertex3f (r * x_strip_edge1, r * y_strip_edge1, z);
-    glTexCoord1f (0.);
+    compute_light_vector (y_strip_edge2, -x_strip_edge2, 0,
+                          0, 0, 1,
+                          &lx, &ly, &lz);
+    glColor3f (lx, ly, lz);
+    glMultiTexCoord1f (GL_TEXTURE0, 0.);
+    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
+                                    (angle_strip_edge2 / 2. / M_PI) * REPT);
     glNormal3f (x_strip_edge2, y_strip_edge2, 0.);
     glVertex3f (r * x_strip_edge2, r * y_strip_edge2, z);
 
+
+
     z = -resistor_width / 2. + resistor_bulge_offset + resistor_bulge_width * 3. / 4.;
     r = resistor_bulge_radius;
-    glTexCoord1f (0.);
+    compute_light_vector (y_strip_edge1, -x_strip_edge1, 0,
+                          y_strip_edge1 * (resistor_barrel_radius - resistor_bulge_radius), -x_strip_edge2 * (resistor_barrel_radius - resistor_bulge_radius), resistor_bulge_width * 1. / 4.,
+                          &lx, &ly, &lz);
+    glColor3f (lx, ly, lz);
+    glMultiTexCoord1f (GL_TEXTURE0, 0.);
+    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
+                                    (angle_strip_edge1 / 2. / M_PI) * REPT);
 //    glNormal3f (x_strip_edge1, y_strip_edge1, 0.);
     glNormal3f (0., 0., 1.);
     glVertex3f (r * x_strip_edge1, r * y_strip_edge1, z);
-    glTexCoord1f (0.);
+    compute_light_vector (y_strip_edge2, -x_strip_edge2, 0,
+                          y_strip_edge2 * (resistor_barrel_radius - resistor_bulge_radius), -x_strip_edge2 * (resistor_barrel_radius - resistor_bulge_radius), resistor_bulge_width * 1. / 4.,
+                          &lx, &ly, &lz);
+    glColor3f (lx, ly, lz);
+    glMultiTexCoord1f (GL_TEXTURE0, 0.);
+    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
+                                    (angle_strip_edge2 / 2. / M_PI) * REPT);
 //    glNormal3f (x_strip_edge2, y_strip_edge2, 0.);
     glNormal3f (0., 0., 1.);
     glVertex3f (r * x_strip_edge2, r * y_strip_edge2, z);
 
+
+
     z = -resistor_width / 2. + resistor_bulge_offset + resistor_bulge_width;
     r = resistor_barrel_radius;
-    glTexCoord1f (0.);
+    compute_light_vector (y_strip_edge1, -x_strip_edge1, 0,
+                          0, 0, 1,
+                          &lx, &ly, &lz);
+    glColor3f (lx, ly, lz);
+    glMultiTexCoord1f (GL_TEXTURE0, 0.);
+    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
+                                    (angle_strip_edge1 / 2. / M_PI) * REPT);
     glNormal3f (x_strip_edge1, y_strip_edge1, 0.);
     glVertex3f (r * x_strip_edge1, r * y_strip_edge1, z);
-    glTexCoord1f (0.);
+    compute_light_vector (y_strip_edge2, -x_strip_edge2, 0,
+                          0, 0, 1,
+                          &lx, &ly, &lz);
+    glColor3f (lx, ly, lz);
+    glMultiTexCoord1f (GL_TEXTURE0, 0.);
+    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
+                                    (angle_strip_edge2 / 2. / M_PI) * REPT);
     glNormal3f (x_strip_edge2, y_strip_edge2, 0.);
     glVertex3f (r * x_strip_edge2, r * y_strip_edge2, z);
 
+
+
     z = resistor_width / 2. - resistor_bulge_offset - resistor_bulge_width;
     r = resistor_barrel_radius;
-    glTexCoord1f (1.);
+    compute_light_vector (y_strip_edge1, -x_strip_edge1, 0,
+                          y_strip_edge1 * (resistor_bulge_radius - resistor_barrel_radius), -x_strip_edge1 * (resistor_bulge_radius - resistor_barrel_radius), resistor_bulge_width * 1. / 4.,
+                          &lx, &ly, &lz);
+    glColor3f (lx, ly, lz);
+    glMultiTexCoord1f (GL_TEXTURE0, 1.);
+    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
+                                    (angle_strip_edge1 / 2. / M_PI) * REPT);
     glNormal3f (x_strip_edge1, y_strip_edge1, 0.);
     glVertex3f (r * x_strip_edge1, r * y_strip_edge1, z);
-    glTexCoord1f (1.);
+    compute_light_vector (y_strip_edge2, -x_strip_edge2, 0,
+                          y_strip_edge2 * (resistor_bulge_radius - resistor_barrel_radius), -x_strip_edge2 * (resistor_bulge_radius - resistor_barrel_radius), resistor_bulge_width * 1. / 4.,
+                          &lx, &ly, &lz);
+    glColor3f (lx, ly, lz);
+    glMultiTexCoord1f (GL_TEXTURE0, 1.);
+    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
+                                    (angle_strip_edge2 / 2. / M_PI) * REPT);
     glNormal3f (x_strip_edge2, y_strip_edge2, 0.);
     glVertex3f (r * x_strip_edge2, r * y_strip_edge2, z);
 
+
+
     z = resistor_width / 2. - resistor_bulge_offset - resistor_bulge_width * 3. / 4.;
     r = resistor_bulge_radius;
-    glTexCoord1f (1.);
+    compute_light_vector (y_strip_edge1, -x_strip_edge1, 0,
+                          0, 0, 1,
+                          &lx, &ly, &lz);
+    glColor3f (lx, ly, lz);
+    glMultiTexCoord1f (GL_TEXTURE0, 1.);
+    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
+                                    (angle_strip_edge1 / 2. / M_PI) * REPT);
 //    glNormal3f (x_strip_edge1, y_strip_edge1, 0.);
     glNormal3f (0., 0., -1.);
     glVertex3f (r * x_strip_edge1, r * y_strip_edge1, z);
-    glTexCoord1f (1.);
+    compute_light_vector (y_strip_edge2, -x_strip_edge2, 0,
+                          0, 0, 1,
+                          &lx, &ly, &lz);
+    glColor3f (lx, ly, lz);
+    glMultiTexCoord1f (GL_TEXTURE0, 1.);
+    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
+                                    (angle_strip_edge2 / 2. / M_PI) * REPT);
 //    glNormal3f (x_strip_edge2, y_strip_edge2, 0.);
     glNormal3f (0., 0., -1.);
     glVertex3f (r * x_strip_edge2, r * y_strip_edge2, z);
 
+
+
     z = resistor_width / 2. - resistor_bulge_offset - resistor_bulge_width * 1. / 4.;
     r = resistor_bulge_radius;
-    glTexCoord1f (1.);
+    compute_light_vector (y_strip_edge1, -x_strip_edge1, 0,
+                          y_strip_edge1 * (resistor_barrel_radius - resistor_bulge_radius), -x_strip_edge1 * (resistor_barrel_radius - resistor_bulge_radius), resistor_bulge_width * 1. / 4.,
+                          &lx, &ly, &lz);
+    glColor3f (lx, ly, lz);
+    glMultiTexCoord1f (GL_TEXTURE0, 1.);
+    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
+                                    (angle_strip_edge1 / 2. / M_PI) * REPT);
     glNormal3f (x_strip_edge1, y_strip_edge1, 0.);
     glVertex3f (r * x_strip_edge1, r * y_strip_edge1, z);
-    glTexCoord1f (1.);
+    compute_light_vector (y_strip_edge2, -x_strip_edge2, 0,
+                          y_strip_edge2 * (resistor_barrel_radius - resistor_bulge_radius), -x_strip_edge2 * (resistor_barrel_radius - resistor_bulge_radius), resistor_bulge_width * 1. / 4.,
+                          &lx, &ly, &lz);
+    glColor3f (lx, ly, lz);
+    glMultiTexCoord1f (GL_TEXTURE0, 1.);
+    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
+                                    (angle_strip_edge2 / 2. / M_PI) * REPT);
     glNormal3f (x_strip_edge2, y_strip_edge2, 0.);
     glVertex3f (r * x_strip_edge2, r * y_strip_edge2, z);
 
+
+
     z = resistor_width / 2. - resistor_bulge_offset;
     r = resistor_barrel_radius;
-    glTexCoord1f (1.);
+    compute_light_vector (y_strip_edge1, -x_strip_edge1, 0,
+                          y_strip_edge1 * (resistor_pin_radius - resistor_barrel_radius), -x_strip_edge1 * (resistor_pin_radius - resistor_barrel_radius), resistor_bulge_offset,
+                          &lx, &ly, &lz);
+    glColor3f (lx, ly, lz);
+    glMultiTexCoord1f (GL_TEXTURE0, 1.);
+    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
+                                    (angle_strip_edge1 / 2. / M_PI) * REPT);
     glNormal3f (x_strip_edge1, y_strip_edge1, 0.);
     glVertex3f (r * x_strip_edge1, r * y_strip_edge1, z);
-    glTexCoord1f (1.);
+    compute_light_vector (y_strip_edge2, -x_strip_edge2, 0,
+                          y_strip_edge2 * (resistor_pin_radius - resistor_barrel_radius), -x_strip_edge2 * (resistor_pin_radius - resistor_barrel_radius), resistor_bulge_offset,
+                          &lx, &ly, &lz);
+    glColor3f (lx, ly, lz);
+    glMultiTexCoord1f (GL_TEXTURE0, 1.);
+    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
+                                    (angle_strip_edge2 / 2. / M_PI) * REPT);
     glNormal3f (x_strip_edge2, y_strip_edge2, 0.);
     glVertex3f (r * x_strip_edge2, r * y_strip_edge2, z);
 
+
+
     z = resistor_width / 2.;
     r = resistor_pin_radius;
-    glTexCoord1f (1.);
+    compute_light_vector (y_strip_edge1, -x_strip_edge1, 0,
+                          y_strip_edge1 * (resistor_pin_radius - resistor_barrel_radius), -x_strip_edge1 * (resistor_pin_radius - resistor_barrel_radius), resistor_bulge_offset,
+                          &lx, &ly, &lz);
+    glColor3f (lx, ly, lz);
+    glMultiTexCoord1f (GL_TEXTURE0, 1.);
+    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
+                                    (angle_strip_edge1 / 2. / M_PI) * REPT);
     glNormal3f (0., 0., 1.);
     glVertex3f (r * x_strip_edge1, r * y_strip_edge1, z);
-    glTexCoord1f (1.);
+    compute_light_vector (y_strip_edge2, -x_strip_edge2, 0,
+                          y_strip_edge2 * (resistor_pin_radius - resistor_barrel_radius), -x_strip_edge2 * (resistor_pin_radius - resistor_barrel_radius), resistor_bulge_offset,
+                          &lx, &ly, &lz);
+    glColor3f (lx, ly, lz);
+    glMultiTexCoord1f (GL_TEXTURE0, 1.);
+    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
+                                    (angle_strip_edge2 / 2. / M_PI) * REPT);
     glNormal3f (0., 0., 1.);
     glVertex3f (r * x_strip_edge2, r * y_strip_edge2, z);
     /* repeat last vertex */
-    glTexCoord1f (1.);
+    compute_light_vector (y_strip_edge2, -x_strip_edge2, 0,
+                          y_strip_edge2 * (resistor_pin_radius - resistor_barrel_radius), -x_strip_edge2 * (resistor_pin_radius - resistor_barrel_radius), resistor_bulge_offset,
+                          &lx, &ly, &lz);
+    glColor3f (lx, ly, lz);
+    glMultiTexCoord1f (GL_TEXTURE0, 1.);
+    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
+                                    (angle_strip_edge2 / 2. / M_PI) * REPT);
     glNormal3f (0., 0., 1.);
     glVertex3f (r * x_strip_edge2, r * y_strip_edge2, z);
 
   }
+#endif
 
   glEnd ();
 
+  glActiveTextureARB (GL_TEXTURE1_ARB);
+  glDisable (GL_TEXTURE_2D);
+
+  glActiveTextureARB (GL_TEXTURE0_ARB);
   glDisable (GL_TEXTURE_1D);
 
+  glEnable (GL_LIGHTING);
+
+  glUseProgram (0);
+
   glColor3f (resistor_pin_color[0],
              resistor_pin_color[1],
              resistor_pin_color[2]);
@@ -646,6 +1061,8 @@ ghid_draw_acy_resistor (ElementType *element)
   glUseProgram (sp);
 
   glDisable (GL_COLOR_MATERIAL);
+
+  first_run = false;
 }
 
 #if 0
@@ -2779,7 +3196,6 @@ determinant_2x2 (double m[2][2])
   return det;
 }
 
-#if 0
 static float
 determinant_4x4 (float m[4][4])
 {
@@ -2798,7 +3214,6 @@ determinant_4x4 (float m[4][4])
         m[0][1] * m[1][0] * m[2][2] * m[3][3]+m[0][0] * m[1][1] * m[2][2] * m[3][3];
    return det;
 }
-#endif
 
 static void
 invert_2x2 (double m[2][2], double out[2][2])
@@ -2810,7 +3225,6 @@ invert_2x2 (double m[2][2], double out[2][2])
   out[1][1] =  m[0][0] * scale;
 }
 
-#if 0
 static void
 invert_4x4 (float m[4][4], float out[4][4])
 {
@@ -2865,7 +3279,6 @@ invert_4x4 (float m[4][4], float out[4][4])
                m[0][2] * m[1][0] * m[2][1] - m[0][0] * m[1][2] * m[2][1] -
                m[0][1] * m[1][0] * m[2][2] + m[0][0] * m[1][1] * m[2][2]) * scale;
 }
-#endif
 
 
 bool

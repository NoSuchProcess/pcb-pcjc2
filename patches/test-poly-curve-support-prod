Bottom: 66e2b7d5e12aaa88b7e70d004fe368f8394465bc
Top:    957c3aeacbe1577289a14b715e2335793767f52e
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2014-06-15 05:28:42 +0100

Test poly-curve support, prod at fixing cursor to pcb mapping in ORTHO view


---

diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 8075ccc..c769a2b 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -2320,6 +2320,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 #endif
 
   /* Push the space coordinates board back into the middle of the z-view volume */
+  /* XXX: THIS CAUSES NEED FOR SCALING BY 11 IN ghid_unproject_to_z_plane(), FOR ORTHO VIEW ONLY! */
   glTranslatef (0., 0., -11.);
 
   /* Rotate about the center of the board space */
@@ -3123,12 +3124,58 @@ ghid_unproject_to_z_plane (int ex, int ey, Coord pcb_z, double *pcb_x, double *p
   J = last_modelview_matrix[1][2];
   K = last_modelview_matrix[2][2];
   L = last_modelview_matrix[3][2];
+
   /* I could assert that the last row is (as assumed) [0 0 0 1], but again.. I'm lazy */
 
+  /* XXX: Actually the last element is not 1, we use it to scale the PCB coordinates! */
+#if 0
+  printf ("row %f %f %f %f\n", last_modelview_matrix[0][0],
+                               last_modelview_matrix[1][0],
+                               last_modelview_matrix[2][0],
+                               last_modelview_matrix[3][0]);
+  printf ("row %f %f %f %f\n", last_modelview_matrix[0][1],
+                               last_modelview_matrix[1][1],
+                               last_modelview_matrix[2][1],
+                               last_modelview_matrix[3][1]);
+  printf ("row %f %f %f %f\n", last_modelview_matrix[0][2],
+                               last_modelview_matrix[1][2],
+                               last_modelview_matrix[2][2],
+                               last_modelview_matrix[3][2]);
+  printf ("Last row %f %f %f %f\n", last_modelview_matrix[0][3],
+                                    last_modelview_matrix[1][3],
+                                    last_modelview_matrix[2][3],
+                                    last_modelview_matrix[3][3]);
+#endif
+
+/*
+    ex = view_matrix[0][0] * vx +
+         view_matrix[0][1] * vy +
+         view_matrix[0][2] * vz +
+         view_matrix[0][3] * 1;
+    ey = view_matrix[1][0] * vx +
+         view_matrix[1][1] * vy +
+         view_matrix[1][2] * vz +
+         view_matrix[1][3] * 1;
+    UNKNOWN ez = view_matrix[2][0] * vx +
+                 view_matrix[2][1] * vy +
+                 view_matrix[2][2] * vz +
+                 view_matrix[2][3] * 1;
+    UNKNOWN ew = view_matrix[3][0] * vx +
+                 view_matrix[3][1] * vy +
+                 view_matrix[3][2] * vz +
+                 view_matrix[3][3] * 1;
+*/
+
   /* Convert from event coordinates to viewport coordinates */
   vpx = (float)ex / (float)widget->allocation.width * 2. - 1.;
   vpy = (float)ey / (float)widget->allocation.height * 2. - 1.;
 
+#ifdef VIEW_ORTHO
+  /* XXX: NOT SURE WHAT IS WRONG TO REQUIRE THIS... SOMETHING IS INCONSISTENT */
+  vpx /= 11.;
+  vpy /= 11.;
+#endif
+
   /* Convert our model space Z plane coordinte to float for convenience */
   fvz = (float)pcb_z;
 
diff --git a/src/polygon.c b/src/polygon.c
index c544ac6..2ccb417 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -1364,6 +1364,7 @@ RemoveExcessPolygonPoints (LayerType *Layer, PolygonType *Polygon)
   if (Undoing ())
     return (false);
 
+if (0) {
   for (n = 0; n < Polygon->PointN; n++)
     {
       prev = prev_contour_point (Polygon, n);
@@ -1373,6 +1374,7 @@ RemoveExcessPolygonPoints (LayerType *Layer, PolygonType *Polygon)
       line.Point1 = Polygon->Points[prev];
       line.Point2 = Polygon->Points[next];
       line.Thickness = 0;
+#warning THIS TEST IS NOT SUFFICIENT.. DOESNT ACCOUNT FOR DIFFERENT ARC CENTERS
       if (Polygon->Points[prev].included_angle == Polygon->Points[n].included_angle &&
           IsPointOnLine (p->X, p->Y, 0.0, &line))
         {
@@ -1380,6 +1382,7 @@ RemoveExcessPolygonPoints (LayerType *Layer, PolygonType *Polygon)
           changed = true;
         }
     }
+}
   return (changed);
 }
 
@@ -2151,6 +2154,23 @@ pv_outline_callback (const BoxType * b, void *cl)
   return 1;
 }
 
+static int
+polygon_outline_callback (const BoxType * b, void *cl)
+{
+  PolygonType *poly = (PolygonType *)b;
+  struct clip_outline_info *info = cl;
+  POLYAREA *np, *res;
+
+  if (!(np = original_poly (poly)))
+    return 0;
+
+
+  poly_Boolean_free (info->poly, np, &res, PBO_UNITE);
+  info->poly = res;
+
+  return 1;
+}
+
 static void
 delete_piece_cb (gpointer data, gpointer userdata)
 {
@@ -2231,13 +2251,14 @@ POLYAREA *board_outline_poly (bool include_holes)
    *  \_____________/
    */
 
-  info.poly = whole_world;
-
   region.X1 = 0;
   region.Y1 = 0;
   region.X2 = PCB->MaxWidth;
   region.Y2 = PCB->MaxHeight;
 
+#if 0
+  info.poly = whole_world;
+
   r_search (Layer->line_tree, &region, NULL, line_outline_callback, &info);
   r_search (Layer->arc_tree,  &region, NULL, arc_outline_callback, &info);
 
@@ -2282,6 +2303,21 @@ POLYAREA *board_outline_poly (bool include_holes)
   } while ((piece = piece->f) != clipped);
 
   g_list_foreach (pieces_to_delete, delete_piece_cb, &clipped);
+#endif
+
+  // The actual operation we want is to split the test polygon into multiple pieces
+  // along the intersection with the polygon contours of any polygon on the outer layer.
+  // The result would be nested, touching (not normally produced by the PBO code),
+  // polygon pieces which could then be culled appropriately by the above contour
+  // classification code to delete the regions outside the board.
+  info.poly = NULL; //clipped;
+  r_search (Layer->polygon_tree, &region, NULL, polygon_outline_callback, &info);
+  clipped = info.poly;
+
+  if (clipped == NULL)
+    return whole_world;
+  else
+    poly_Free (&whole_world);
 
   return clipped;
 }

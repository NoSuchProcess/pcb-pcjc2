Bottom: 4b918a53bd9e515903d459787da07658d55d4b1a
Top:    a9529158cd264e0699a5a7827c95c42e82b5adee
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-11-14 18:39:54 +0000

Use the OpenGL stencil buffer to make drawing polygons with holes faster.

1. Turn Stenciling on, updates to colour buffer off
2. Clear stencil buffer to 0
3. Paint polygon holes, setting those areas of the stencil buffer to 1
4. Switch on stencil test (== 0), turn on updates to colour buffer
5. Paint outer polygon through areas of the stencil buffer still 0
6. Clear stencil buffer, switch off stencilling.

** BUGS? **

Probably throws up if the function is used whilst drawing the mask,
since that uses stenciling as well, and they don't know to co-operate.

For now, we don't use polygons on the mask, so its not a a problem (?).
(OR do we.. for some pins?)



---

diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index 0b1645f..413d92f 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -617,7 +617,9 @@ do_hole (const BoxType *b, void *cl)
   if (curc->Flags.orient == PLF_DIR) {
     return 0;
   }
+  gluTessBeginPolygon (info->tobj, NULL);
   tesselate_contour (info->tobj, &curc->head, info->vertices, info->i);
+  gluTessEndPolygon (info->tobj);
   return 1;
 }
 
@@ -625,11 +627,10 @@ void
 hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale)
 {
   int i, cc;
-  GLUtesselator *tobj;
-  GLdouble *vertices;
   int vertex_count = 0;
-  POLYAREA *piece;
   PLINE *contour;
+  struct do_hole_info info;
+
 
   global_scale = scale;
 
@@ -638,49 +639,56 @@ hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale
     return;
   }
 
+  /* TODO: Just draw our triangles, no need to flush the buffer */
+  hidgl_flush_triangles (&buffer);
+
   /* JUST DRAW THE FIRST PIECE */
   /* Walk the polygon structure, counting vertices */
   /* This gives an upper bound on the amount of storage required */
-  piece = poly->Clipped;
-//  do {
-    for (contour = piece->contours; contour != NULL; contour = contour->next)
-      vertex_count += contour->Count;
-//  } while ((piece = piece->f) != poly->Clipped);
-
-  vertices = malloc (sizeof(GLdouble) * vertex_count * 3);
+  for (contour = poly->Clipped->contours;
+       contour != NULL; contour = contour->next)
+    vertex_count += contour->Count;
+
+  info.vertices = malloc (sizeof(GLdouble) * vertex_count * 3);
+  info.tobj = gluNewTess ();
+  info.i = &i;
+  gluTessCallback(info.tobj, GLU_TESS_BEGIN, myBegin);
+  gluTessCallback(info.tobj, GLU_TESS_VERTEX, myVertex);
+  gluTessCallback(info.tobj, GLU_TESS_COMBINE, myCombine);
+  gluTessCallback(info.tobj, GLU_TESS_ERROR, myError);
+
+  glClearStencil (0);
+  glClear (GL_STENCIL_BUFFER_BIT);
+  glColorMask (0, 0, 0, 0);                   // Disable writting in color buffer
+  glEnable (GL_STENCIL_TEST);
 
-  tobj = gluNewTess ();
-  gluTessCallback(tobj, GLU_TESS_BEGIN, myBegin);
-  gluTessCallback(tobj, GLU_TESS_VERTEX, myVertex);
-  gluTessCallback(tobj, GLU_TESS_COMBINE, myCombine);
-  gluTessCallback(tobj, GLU_TESS_ERROR, myError);
-
-  gluTessBeginPolygon (tobj, NULL);
-
-  /* JUST DRAW THE FIRST PIECE */
-  /* Walk the polygon structure, adding the vertices */
   i = 0;
   cc = 1;
-  piece = poly->Clipped;
-  do {
-    struct do_hole_info info;
-    info.tobj = tobj;
-    info.vertices = vertices;
-    info.i = &i;
 
-    tesselate_contour (tobj, &piece->contours->head, vertices, &i);
+  /* Drawing operations set the stencil buffer to '1' */
+  glStencilFunc (GL_ALWAYS, 1, 1);            // Test always passes, value written 1
+  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value (with 1)
 
-    /* Search for a contour to draw */
-    r_search (piece->contour_tree, clip_box, NULL, do_hole, &info);
+  r_search (poly->Clipped->contour_tree, clip_box, NULL, do_hole, &info);
+  hidgl_flush_triangles (&buffer);
 
-  } while (0);
-//  } while ((piece = piece->f) != poly->Clipped);
+  /* Drawing operations as masked to areas where the stencil buffer is '1' */
+  glColorMask (1, 1, 1, 1);                   // Enable drawing of r, g, b & a
+  glStencilFunc (GL_EQUAL, 0, 1);             // Draw only where stencil buffer is 0
+  glStencilOp (GL_KEEP, GL_KEEP, GL_KEEP);    // Stencil buffer read only
 
-  gluTessEndPolygon (tobj);
-  gluDeleteTess (tobj);
+  /* Draw the polygon outer */
+  gluTessBeginPolygon (info.tobj, NULL);
+  tesselate_contour (info.tobj, &poly->Clipped->contours->head, info.vertices, &i);
+  gluTessEndPolygon (info.tobj);
+  hidgl_flush_triangles (&buffer);
 
+  glClear (GL_STENCIL_BUFFER_BIT);
+  glDisable (GL_STENCIL_TEST);                // Disable Stencil test
+
+  gluDeleteTess (info.tobj);
   myFreeCombined ();
-  free (vertices);
+  free (info.vertices);
 }
 
 void

Bottom: 0cba386a52bcae3ea43d0d5b308a1ce4ec1d6af2
Top:    05cb9deb03b6db173916c7cd2da65ade580f0f2f
Author: Robert Spanton <rspanton@zepler.net>
Date:   2010-06-05 03:55:54 +0100

Change all Booleans to bool.

c99 provides bool.  Declaring Boolean adds some obscurity to the code,
and could also miss out on some machine-specific optimisations.

This patch removes the definition of Boolean, and changes all
instances of it to bool.

If you've come across this commit because it's causing you issues when
rebasing on mainline pcb, then you should find the following script
useful.  You can use it to rewrite all of your local commits to use
bool instead of Boolean like so:

	git filter-branch --tree-filter rename-bool.sh HEAD...${HASH}

Replacing ${HASH} with the latest commit that's in mainline.

if [ ! -f src/autoplace.c ]
    then
    echo "This doesn't look like the PCB source directory."
    echo "Cowardly exiting to avoid causing misery!"
    exit
fi

chg_bool ()
{
    FNAME=$1
    ADDR=$2

    sed -i -e "${ADDR}s/\bBoolean\b/bool/g" "$FNAME"
    sed -i -e "${ADDR}s/\bTrue\b/true/g" "$FNAME"
    sed -i -e "${ADDR}s/\bFalse\b/false/g" "$FNAME"
}

find -name '*.[ch]' | while read f
do
    chg_bool "$f"
done

find -name '*.[yl]' | while read f
do
    # Replace first '%%' line with __TMP_MARKER_
    sed -i -e '0,/^%%/s/^%%/__TMP_MARKER_/' "$f"

    # Replace in section before the first '%%'
    chg_bool "$f" "0,/^__TMP_MARKER_/"
    # Replace in section after the last '%%'
    chg_bool "$f" "/^%%/,$"

    # Remove the temporary marker:
    sed -i -e 's/^__TMP_MARKER_/%%/' "$f"
done


---

diff --git a/src/action.c b/src/action.c
index dde6484..6546be1 100644
--- a/src/action.c
+++ b/src/action.c
@@ -306,8 +306,8 @@ static struct
   int X;
   int Y;
   Cardinal Buffer;
-  Boolean Click;
-  Boolean Moving;		/* selected type clicked on */
+  bool Click;
+  bool Moving;		/* selected type clicked on */
   int Hit;			/* move type clicked on */
   void *ptr1;
   void *ptr2;
@@ -319,10 +319,10 @@ static int defer_updates = 0;
 static int defer_needs_update = 0;
 
 static Cardinal polyIndex = 0;
-static Boolean IgnoreMotionEvents = False;
-static Boolean saved_mode = False;
+static bool IgnoreMotionEvents = false;
+static bool saved_mode = false;
 #ifdef HAVE_LIBSTROKE
-static Boolean mid_stroke = False;
+static bool mid_stroke = false;
 static BoxType StrokeBox;
 #endif
 static FunctionType Functions[] = {
@@ -475,7 +475,7 @@ FinishStroke (void)
   unsigned long num;
   void *ptr1, *ptr2, *ptr3;
 
-  mid_stroke = False;
+  mid_stroke = false;
   if (stroke_trans (msg))
     {
       num = atoi (msg);
@@ -512,7 +512,7 @@ FinishStroke (void)
 	case 147423:
 	case 147523:
 	case 1474123:
-	  Redo (True);
+	  Redo (true);
 	  break;
 	case 148963:
 	case 147863:
@@ -555,7 +555,7 @@ FinishStroke (void)
 		   log (2.0));
 	    SetZoom (z);
 
-	    CenterDisplay (x, y, False);
+	    CenterDisplay (x, y, false);
 	    break;
 	  }
 
@@ -575,7 +575,7 @@ FinishStroke (void)
 static void
 ClearWarnings ()
 {
-  Settings.RatWarn = False;
+  Settings.RatWarn = false;
   ALLPIN_LOOP (PCB->Data);
   {
     if (TEST_FLAG (WARNFLAG, pin))
@@ -602,53 +602,53 @@ click_cb (hidval hv)
 {
   if (Note.Click)
     {
-      Note.Click = False;
+      Note.Click = false;
       if (Note.Moving && !gui->shift_is_pressed ())
 	{
-	  HideCrosshair (True);
+	  HideCrosshair (true);
 	  Note.Buffer = Settings.BufferNumber;
 	  SetBufferNumber (MAX_BUFFER - 1);
 	  ClearBuffer (PASTEBUFFER);
-	  AddSelectedToBuffer (PASTEBUFFER, Note.X, Note.Y, True);
+	  AddSelectedToBuffer (PASTEBUFFER, Note.X, Note.Y, true);
 	  SaveUndoSerialNumber ();
 	  RemoveSelected ();
 	  SaveMode ();
-	  saved_mode = True;
+	  saved_mode = true;
 	  SetMode (PASTEBUFFER_MODE);
-	  RestoreCrosshair (True);
+	  RestoreCrosshair (true);
 	}
       else if (Note.Hit && !gui->shift_is_pressed ())
 	{
-	  HideCrosshair (True);
+	  HideCrosshair (true);
 	  SaveMode ();
-	  saved_mode = True;
+	  saved_mode = true;
 	  SetMode (gui->control_is_pressed ()? COPY_MODE : MOVE_MODE);
 	  Crosshair.AttachedObject.Ptr1 = Note.ptr1;
 	  Crosshair.AttachedObject.Ptr2 = Note.ptr2;
 	  Crosshair.AttachedObject.Ptr3 = Note.ptr3;
 	  Crosshair.AttachedObject.Type = Note.Hit;
 	  AttachForCopy (Note.X, Note.Y);
-	  RestoreCrosshair (True);
+	  RestoreCrosshair (true);
 	}
       else
 	{
 	  BoxType box;
 
 	  Note.Hit = 0;
-	  Note.Moving = False;
-	  HideCrosshair (True);
+	  Note.Moving = false;
+	  HideCrosshair (true);
 	  SaveUndoSerialNumber ();
 	  box.X1 = -MAX_COORD;
 	  box.Y1 = -MAX_COORD;
 	  box.X2 = MAX_COORD;
 	  box.Y2 = MAX_COORD;
 	  /* unselect first if shift key not down */
-	  if (!gui->shift_is_pressed () && SelectBlock (&box, False))
-	    SetChangedFlag (True);
+	  if (!gui->shift_is_pressed () && SelectBlock (&box, false))
+	    SetChangedFlag (true);
 	  NotifyBlock ();
 	  Crosshair.AttachedBox.Point1.X = Note.X;
 	  Crosshair.AttachedBox.Point1.Y = Note.Y;
-	  RestoreCrosshair (True);
+	  RestoreCrosshair (true);
 	}
     }
 }
@@ -667,13 +667,13 @@ ReleaseMode (void)
       box.X2 = MAX_COORD;
       box.Y2 = MAX_COORD;
 
-      Note.Click = False;	/* inhibit timer action */
+      Note.Click = false;	/* inhibit timer action */
       SaveUndoSerialNumber ();
       /* unselect first if shift key not down */
       if (!gui->shift_is_pressed ())
 	{
-	  if (SelectBlock (&box, False))
-	    SetChangedFlag (True);
+	  if (SelectBlock (&box, false))
+	    SetChangedFlag (true);
 	  if (Note.Moving)
 	    {
 	      Note.Moving = 0;
@@ -683,7 +683,7 @@ ReleaseMode (void)
 	}
       RestoreUndoSerialNumber ();
       if (SelectObject ())
-	SetChangedFlag (True);
+	SetChangedFlag (true);
       Note.Hit = 0;
       Note.Moving = 0;
     }
@@ -693,7 +693,7 @@ ReleaseMode (void)
       NotifyMode ();
       ClearBuffer (PASTEBUFFER);
       SetBufferNumber (Note.Buffer);
-      Note.Moving = False;
+      Note.Moving = false;
       Note.Hit = 0;
     }
   else if (Note.Hit)
@@ -712,15 +712,15 @@ ReleaseMode (void)
       box.Y2 = MAX (Crosshair.AttachedBox.Point1.Y,
 		    Crosshair.AttachedBox.Point2.Y);
       RestoreUndoSerialNumber ();
-      if (SelectBlock (&box, True))
-	SetChangedFlag (True);
+      if (SelectBlock (&box, true))
+	SetChangedFlag (true);
       else if (Bumped)
 	IncrementUndoSerialNumber ();
       Crosshair.AttachedBox.State = STATE_FIRST;
     }
   if (saved_mode)
     RestoreMode ();
-  saved_mode = False;
+  saved_mode = false;
 }
 
 /* ---------------------------------------------------------------------------
@@ -873,7 +873,7 @@ NotifyLine (void)
   void *ptr1, *ptr2, *ptr3;
 
   if (!Marked.status || TEST_FLAG (LOCALREFFLAG, PCB))
-    SetLocalRef (Crosshair.X, Crosshair.Y, True);
+    SetLocalRef (Crosshair.X, Crosshair.Y, true);
   switch (Crosshair.AttachedLine.State)
     {
     case STATE_FIRST:		/* first point */
@@ -889,7 +889,7 @@ NotifyLine (void)
 	  type = SearchScreen (Crosshair.X, Crosshair.Y,
 			       PIN_TYPE | PAD_TYPE | VIA_TYPE, &ptr1, &ptr2,
 			       &ptr3);
-	  LookupConnection (Crosshair.X, Crosshair.Y, True, TO_PCB (1),
+	  LookupConnection (Crosshair.X, Crosshair.Y, true, TO_PCB (1),
 			    FOUNDFLAG);
 	}
       if (type == PIN_TYPE || type == VIA_TYPE)
@@ -943,7 +943,7 @@ NotifyLine (void)
 static void
 NotifyBlock (void)
 {
-  HideCrosshair (True);
+  HideCrosshair (true);
   switch (Crosshair.AttachedBox.State)
     {
     case STATE_FIRST:		/* setup first point */
@@ -958,7 +958,7 @@ NotifyBlock (void)
       Crosshair.AttachedBox.State = STATE_THIRD;
       break;
     }
-  RestoreCrosshair (True);
+  RestoreCrosshair (true);
 }
 
 
@@ -984,7 +984,7 @@ NotifyMode (void)
 	int test;
 	hidval hv;
 
-	Note.Click = True;
+	Note.Click = true;
 	/* do something after click time */
 	gui->add_timer (click_cb, CLICK_TIME, hv);
 
@@ -1006,7 +1006,7 @@ NotifyMode (void)
 	      }
 	    if (!Note.Moving && (type & SELECT_TYPES) &&
 		TEST_FLAG (SELECTEDFLAG, (PinTypePtr) ptr2))
-	      Note.Moving = True;
+	      Note.Moving = true;
 	    if ((Note.Hit && Note.Moving) || type == NO_TYPE)
 	      break;
 	  }
@@ -1474,7 +1474,7 @@ NotifyMode (void)
 	      }
 	  }
 	if (CopyPastebufferToLayout (Note.X, Note.Y))
-	  SetChangedFlag (True);
+	  SetChangedFlag (true);
 	if (e)
 	  {
 	    int type =
@@ -1539,7 +1539,7 @@ NotifyMode (void)
 	    }
 	  RemoveObject (type, ptr1, ptr2, ptr3);
 	  IncrementUndoSerialNumber ();
-	  SetChangedFlag (True);
+	  SetChangedFlag (true);
 	}
       break;
 
@@ -1598,9 +1598,9 @@ NotifyMode (void)
 				       Crosshair.AttachedObject.Ptr3,
 				       Note.X - Crosshair.AttachedObject.X,
 				       Note.Y - Crosshair.AttachedObject.Y);
-	      SetLocalRef (0, 0, False);
+	      SetLocalRef (0, 0, false);
 	    }
-	  SetChangedFlag (True);
+	  SetChangedFlag (true);
 
 	  /* reset identifiers */
 	  Crosshair.AttachedObject.Type = NO_TYPE;
@@ -1659,14 +1659,14 @@ NotifyMode (void)
 	    InsertPointIntoObject (POLYGON_TYPE,
 				   Crosshair.AttachedObject.Ptr1, fake.poly,
 				   &polyIndex,
-				   InsertedPoint.X, InsertedPoint.Y, False);
+				   InsertedPoint.X, InsertedPoint.Y, false);
 	  else
 	    InsertPointIntoObject (Crosshair.AttachedObject.Type,
 				   Crosshair.AttachedObject.Ptr1,
 				   Crosshair.AttachedObject.Ptr2,
 				   &polyIndex,
-				   InsertedPoint.X, InsertedPoint.Y, False);
-	  SetChangedFlag (True);
+				   InsertedPoint.X, InsertedPoint.Y, false);
+	  SetChangedFlag (true);
 
 	  /* reset identifiers */
 	  Crosshair.AttachedObject.Type = NO_TYPE;
@@ -1773,7 +1773,7 @@ ActionDRCheck (int argc, char **argv, int x, int y)
 	       PCB->minDrill / 100, PCB->minDrill % 100,
 	       PCB->minRing / 100, PCB->minRing % 100);
     }
-  HideCrosshair (True);
+  HideCrosshair (true);
   count = DRCAll ();
   if (gui->drc_gui == NULL || gui->drc_gui->log_drc_overview)
     {
@@ -1784,7 +1784,7 @@ ActionDRCheck (int argc, char **argv, int x, int y)
       else
 	Message (_("Aborted DRC after %d design rule errors.\n"), -count);
     }
-  RestoreCrosshair (True);
+  RestoreCrosshair (true);
   return 0;
 }
 
@@ -1869,7 +1869,7 @@ ActionFlip (int argc, char **argv, int x, int y)
 
   if (function)
     {
-      HideCrosshair (True);
+      HideCrosshair (true);
       switch (GetFunctionID (function))
 	{
 	case F_Object:
@@ -1890,7 +1890,7 @@ ActionFlip (int argc, char **argv, int x, int y)
 	  err = 1;
 	  break;
 	}
-      RestoreCrosshair (True);
+      RestoreCrosshair (true);
       if (!err)
 	return 0;
     }
@@ -1974,10 +1974,10 @@ ActionSetThermal (int argc, char **argv, int x, int y)
 
   if (function && *function && style && *style)
     {
-      Boolean absolute;
+      bool absolute;
 
       kind = GetValue (style, NULL, &absolute);
-      HideCrosshair (True);
+      HideCrosshair (true);
       if (absolute)
 	switch (GetFunctionID (function))
 	  {
@@ -2007,7 +2007,7 @@ ActionSetThermal (int argc, char **argv, int x, int y)
 	  }
       else
 	err = 1;
-      RestoreCrosshair (True);
+      RestoreCrosshair (true);
       if (!err)
 	return 0;
     }
@@ -2034,11 +2034,11 @@ ActionMovePointer (char *deltax, char *deltay)
   /* restore crosshair for erasure */
   Crosshair.X = x;
   Crosshair.Y = y;
-  HideCrosshair (False);
+  HideCrosshair (false);
   MoveCrosshairRelative (TO_SCREEN_SIGN_X (dx), TO_SCREEN_SIGN_Y (dy));
   /* update object position and cursor location */
   AdjustAttachedObjects ();
-  RestoreCrosshair (False);
+  RestoreCrosshair (false);
 }
 
 /* ---------------------------------------------------------------------------
@@ -2067,11 +2067,11 @@ EventMoveCrosshair (int ev_x, int ev_y)
 
 	  /* update object position and cursor location */
 	  AdjustAttachedObjects ();
-	  RestoreCrosshair (False);
+	  RestoreCrosshair (false);
 	}
     }
   else
-    IgnoreMotionEvents = False;
+    IgnoreMotionEvents = false;
 }
 
 /* --------------------------------------------------------------------------- */
@@ -2114,19 +2114,19 @@ ActionSetValue (int argc, char **argv, int x, int y)
   char *function = ARG (0);
   char *val = ARG (1);
   char *units = ARG (2);
-  Boolean r;			/* flag for 'relative' value */
+  bool r;			/* flag for 'relative' value */
   float value;
   int err = 0;
 
   if (function && val)
     {
-      HideCrosshair (True);
+      HideCrosshair (true);
       value = GetValue (val, units, &r);
       switch (GetFunctionID (function))
 	{
 	case F_ViaDrillingHole:
 	  SetViaDrillingHole (r ? value : value + Settings.ViaDrillingHole,
-			      False);
+			      false);
 	  hid_action ("RouteStylesChanged");
 	  break;
 
@@ -2142,11 +2142,11 @@ ActionSetValue (int argc, char **argv, int x, int y)
 		   * PCB drawing unit 
 		   */
                   if ((value + PCB->Grid) < 1)
-                     SetGrid (1, False);
+                     SetGrid (1, false);
                   else if (PCB->Grid == 1)
-                    SetGrid ( value, False);
+                    SetGrid ( value, false);
                   else
-                    SetGrid (value + PCB->Grid, False);
+                    SetGrid (value + PCB->Grid, false);
                 }
 
 	      else
@@ -2154,7 +2154,7 @@ ActionSetValue (int argc, char **argv, int x, int y)
 			 ("Don't combine metric/English grids like that!\n"));
 	    }
 	  else
-	    SetGrid (value, False);
+	    SetGrid (value, false);
 	  break;
 
 	case F_LineSize:
@@ -2165,7 +2165,7 @@ ActionSetValue (int argc, char **argv, int x, int y)
 
 	case F_Via:
 	case F_ViaSize:
-	  SetViaSize (r ? value : value + Settings.ViaThickness, False);
+	  SetViaSize (r ? value : value + Settings.ViaThickness, false);
 	  hid_action ("RouteStylesChanged");
 	  break;
 
@@ -2178,7 +2178,7 @@ ActionSetValue (int argc, char **argv, int x, int y)
 	  err = 1;
 	  break;
 	}
-      RestoreCrosshair (True);
+      RestoreCrosshair (true);
       if (!err)
 	return 0;
     }
@@ -2255,32 +2255,32 @@ ActionConnection (int argc, char **argv, int x, int y)
   char *function = ARG (0);
   if (function)
     {
-      HideCrosshair (True);
+      HideCrosshair (true);
       switch (GetFunctionID (function))
 	{
 	case F_Find:
 	  {
 	    gui->get_coords (_("Click on a connection"), &x, &y);
-	    LookupConnection (x, y, True, 1, FOUNDFLAG);
+	    LookupConnection (x, y, true, 1, FOUNDFLAG);
 	    break;
 	  }
 
 	case F_ResetLinesAndPolygons:
-	  ResetFoundLinesAndPolygons (True);
+	  ResetFoundLinesAndPolygons (true);
 	  break;
 
 	case F_ResetPinsViasAndPads:
-	  ResetFoundPinsViasAndPads (True);
+	  ResetFoundPinsViasAndPads (true);
 	  break;
 
 	case F_Reset:
 	  SaveUndoSerialNumber ();
-	  ResetFoundPinsViasAndPads (True);
+	  ResetFoundPinsViasAndPads (true);
 	  RestoreUndoSerialNumber ();
-	  ResetFoundLinesAndPolygons (True);
+	  ResetFoundLinesAndPolygons (true);
 	  break;
 	}
-      RestoreCrosshair (True);
+      RestoreCrosshair (true);
       return 0;
     }
 
@@ -2407,7 +2407,7 @@ ActionDisperseElements (int argc, char **argv, int x, int y)
   IncrementUndoSerialNumber ();
 
   ClearAndRedrawOutput ();
-  SetChangedFlag (True);
+  SetChangedFlag (true);
 
   return 0;
 }
@@ -2559,7 +2559,7 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 
   if (function && (!str_dir || !*str_dir))
     {
-      HideCrosshair (True);
+      HideCrosshair (true);
       switch (id = GetFunctionID (function))
 	{
 
@@ -2691,12 +2691,12 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 	  if (TEST_FLAG (AUTODRCFLAG, PCB) && Settings.Mode == LINE_MODE)
 	    {
 	      SaveUndoSerialNumber ();
-	      ResetFoundPinsViasAndPads (True);
+	      ResetFoundPinsViasAndPads (true);
 	      RestoreUndoSerialNumber ();
-	      ResetFoundLinesAndPolygons (True);
+	      ResetFoundLinesAndPolygons (true);
 	      if (Crosshair.AttachedLine.State != STATE_FIRST)
 		LookupConnection (Crosshair.AttachedLine.Point1.X,
-				  Crosshair.AttachedLine.Point1.Y, True, 1,
+				  Crosshair.AttachedLine.Point1.Y, true, 1,
 				  FOUNDFLAG);
 	    }
 	  break;
@@ -2736,8 +2736,8 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 	    oldGrid = PCB->Grid;
 	    PCB->Grid = 1.0;
 	    if (MoveCrosshairAbsolute (childX, childY))
-	      RestoreCrosshair (False);	/* was hidden by MoveCrosshairAbs */
-	    SetGrid (oldGrid, True);
+	      RestoreCrosshair (false);	/* was hidden by MoveCrosshairAbs */
+	    SetGrid (oldGrid, true);
 	  }
 	  break;
 
@@ -2796,7 +2796,7 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 		  TOGGLE_FLAG (DISPLAYNAMEFLAG, pad);
 		}
 		END_LOOP;
-		SetChangedFlag (True);
+		SetChangedFlag (true);
 		IncrementUndoSerialNumber ();
 		Draw ();
 		break;
@@ -2808,7 +2808,7 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 		  DrawPinName ((PinTypePtr) ptr2, 0);
 		AddObjectToFlagUndoList (PIN_TYPE, ptr1, ptr2, ptr3);
 		TOGGLE_FLAG (DISPLAYNAMEFLAG, (PinTypePtr) ptr2);
-		SetChangedFlag (True);
+		SetChangedFlag (true);
 		IncrementUndoSerialNumber ();
 		Draw ();
 		break;
@@ -2820,7 +2820,7 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 		  DrawPadName ((PadTypePtr) ptr2, 0);
 		AddObjectToFlagUndoList (PAD_TYPE, ptr1, ptr2, ptr3);
 		TOGGLE_FLAG (DISPLAYNAMEFLAG, (PadTypePtr) ptr2);
-		SetChangedFlag (True);
+		SetChangedFlag (true);
 		IncrementUndoSerialNumber ();
 		Draw ();
 		break;
@@ -2831,7 +2831,7 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 		  DrawViaName ((PinTypePtr) ptr2, 0);
 		AddObjectToFlagUndoList (VIA_TYPE, ptr1, ptr2, ptr3);
 		TOGGLE_FLAG (DISPLAYNAMEFLAG, (PinTypePtr) ptr2);
-		SetChangedFlag (True);
+		SetChangedFlag (true);
 		IncrementUndoSerialNumber ();
 		Draw ();
 		break;
@@ -2841,7 +2841,7 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 	default:
 	  err = 1;
 	}
-      RestoreCrosshair (True);
+      RestoreCrosshair (true);
     }
   else if (function && str_dir)
     {
@@ -2940,7 +2940,7 @@ ActionMode (int argc, char **argv, int x, int y)
     {
       Note.X = Crosshair.X;
       Note.Y = Crosshair.Y;
-      HideCrosshair (True);
+      HideCrosshair (true);
       switch (GetFunctionID (function))
 	{
 	case F_Arc:
@@ -3074,7 +3074,7 @@ ActionMode (int argc, char **argv, int x, int y)
 	  break;
 	case F_Stroke:
 #ifdef HAVE_LIBSTROKE
-	  mid_stroke = True;
+	  mid_stroke = true;
 	  StrokeBox.X1 = Crosshair.X;
 	  StrokeBox.Y1 = Crosshair.Y;
 	  break;
@@ -3099,7 +3099,7 @@ ActionMode (int argc, char **argv, int x, int y)
 	  else
 	    {
 	      SaveMode ();
-	      saved_mode = True;
+	      saved_mode = true;
 	      SetMode (ARROW_MODE);
 	      NotifyMode ();
 	    }
@@ -3123,7 +3123,7 @@ ActionMode (int argc, char **argv, int x, int y)
 	  SaveMode ();
 	  break;
 	}
-      RestoreCrosshair (True);
+      RestoreCrosshair (true);
       return 0;
     }
 
@@ -3143,10 +3143,10 @@ static const char removeselected_help[] = "Removes any selected objects.";
 static int
 ActionRemoveSelected (int argc, char **argv, int x, int y)
 {
-  HideCrosshair (True);
+  HideCrosshair (true);
   if (RemoveSelected ())
-    SetChangedFlag (True);
-  RestoreCrosshair (True);
+    SetChangedFlag (true);
+  RestoreCrosshair (true);
   return 0;
 }
 
@@ -3165,7 +3165,7 @@ static const char renumber_help[] =
 static int
 ActionRenumber (int argc, char **argv, int x, int y)
 {
-  Boolean changed = False;
+  bool changed = false;
   ElementTypePtr *element_list;
   ElementTypePtr *locked_element_list;
   unsigned int i, j, k, cnt, lock_cnt;
@@ -3425,7 +3425,7 @@ ActionRenumber (int argc, char **argv, int x, int y)
 
 	      ChangeObjectName (ELEMENT_TYPE, element_list[i], NULL, NULL,
 				tmps);
-	      changed = True;
+	      changed = true;
 
 	      /* we don't free tmps in this case because it is used */
 	    }
@@ -3496,7 +3496,7 @@ ActionRenumber (int argc, char **argv, int x, int y)
 
       NetlistChanged (0);
       IncrementUndoSerialNumber ();
-      SetChangedFlag (True);
+      SetChangedFlag (true);
     }
 
   free (locked_element_list);
@@ -3536,11 +3536,11 @@ static int
 ActionRipUp (int argc, char **argv, int x, int y)
 {
   char *function = ARG (0);
-  Boolean changed = False;
+  bool changed = false;
 
   if (function)
     {
-      HideCrosshair (True);
+      HideCrosshair (true);
       switch (GetFunctionID (function))
 	{
 	case F_All:
@@ -3549,7 +3549,7 @@ ActionRipUp (int argc, char **argv, int x, int y)
 	    if (TEST_FLAG (AUTOFLAG, line) && !TEST_FLAG (LOCKFLAG, line))
 	      {
 		RemoveObject (LINE_TYPE, layer, line, line);
-		changed = True;
+		changed = true;
 	      }
 	  }
 	  ENDALL_LOOP;
@@ -3558,7 +3558,7 @@ ActionRipUp (int argc, char **argv, int x, int y)
 	    if (TEST_FLAG (AUTOFLAG, via) && !TEST_FLAG (LOCKFLAG, via))
 	      {
 		RemoveObject (VIA_TYPE, via, via, via);
-		changed = True;
+		changed = true;
 	      }
 	  }
 	  END_LOOP;
@@ -3566,7 +3566,7 @@ ActionRipUp (int argc, char **argv, int x, int y)
 	  if (changed)
 	    {
 	      IncrementUndoSerialNumber ();
-	      SetChangedFlag (True);
+	      SetChangedFlag (true);
 	    }
 	  break;
 	case F_Selected:
@@ -3576,7 +3576,7 @@ ActionRipUp (int argc, char **argv, int x, int y)
 		&& !TEST_FLAG (LOCKFLAG, line))
 	      {
 		RemoveObject (LINE_TYPE, layer, line, line);
-		changed = True;
+		changed = true;
 	      }
 	  }
 	  ENDALL_LOOP;
@@ -3587,14 +3587,14 @@ ActionRipUp (int argc, char **argv, int x, int y)
 		&& !TEST_FLAG (LOCKFLAG, via))
 	      {
 		RemoveObject (VIA_TYPE, via, via, via);
-		changed = True;
+		changed = true;
 	      }
 	  }
 	  END_LOOP;
 	  if (changed)
 	    {
 	      IncrementUndoSerialNumber ();
-	      SetChangedFlag (True);
+	      SetChangedFlag (true);
 	    }
 	  break;
 	case F_Element:
@@ -3618,12 +3618,12 @@ ActionRipUp (int argc, char **argv, int x, int y)
 		RestoreUndoSerialNumber ();
 		CopyPastebufferToLayout (0, 0);
 		SetBufferNumber (Note.Buffer);
-		SetChangedFlag (True);
+		SetChangedFlag (true);
 	      }
 	  }
 	  break;
 	}
-      RestoreCrosshair (True);
+      RestoreCrosshair (true);
     }
   return 0;
 }
@@ -3664,17 +3664,17 @@ ActionAddRats (int argc, char **argv, int x, int y)
     {
       if (Settings.RatWarn)
 	ClearWarnings ();
-      HideCrosshair (True);
+      HideCrosshair (true);
       switch (GetFunctionID (function))
 	{
 	case F_AllRats:
-	  if (AddAllRats (False, NULL))
-	    SetChangedFlag (True);
+	  if (AddAllRats (false, NULL))
+	    SetChangedFlag (true);
 	  break;
 	case F_SelectedRats:
 	case F_Selected:
-	  if (AddAllRats (True, NULL))
-	    SetChangedFlag (True);
+	  if (AddAllRats (true, NULL))
+	    SetChangedFlag (true);
 	  break;
 	case F_Close:
 	  small = SQUARE (MAX_COORD);
@@ -3700,11 +3700,11 @@ ActionAddRats (int argc, char **argv, int x, int y)
 	      Draw ();
 	      CenterDisplay ((shorty->Point2.X + shorty->Point1.X) / 2,
 			     (shorty->Point2.Y + shorty->Point1.Y) / 2,
-			     False);
+			     false);
 	    }
 	  break;
 	}
-      RestoreCrosshair (True);
+      RestoreCrosshair (true);
     }
   return 0;
 }
@@ -3733,11 +3733,11 @@ ActionDelete (int argc, char **argv, int x, int y)
 
   if (id == -1) /* no arg */
     {
-      if (RemoveSelected() == False)
+      if (RemoveSelected() == false)
 	id = F_Object;
     }
 
-  HideCrosshair (True);
+  HideCrosshair (true);
   switch (id)
     {
     case F_Object:
@@ -3750,16 +3750,16 @@ ActionDelete (int argc, char **argv, int x, int y)
       RemoveSelected();
       break;
     case F_AllRats:
-      if (DeleteRats (False))
-	SetChangedFlag (True);
+      if (DeleteRats (false))
+	SetChangedFlag (true);
       break;
     case F_SelectedRats:
-      if (DeleteRats (True))
-	SetChangedFlag (True);
+      if (DeleteRats (true))
+	SetChangedFlag (true);
       break;
     }
 
-  RestoreCrosshair (True);
+  RestoreCrosshair (true);
   return 0;
 }
 
@@ -3782,20 +3782,20 @@ ActionDeleteRats (int argc, char **argv, int x, int y)
     {
       if (Settings.RatWarn)
 	ClearWarnings ();
-      HideCrosshair (True);
+      HideCrosshair (true);
       switch (GetFunctionID (function))
 	{
 	case F_AllRats:
-	  if (DeleteRats (False))
-	    SetChangedFlag (True);
+	  if (DeleteRats (false))
+	    SetChangedFlag (true);
 	  break;
 	case F_SelectedRats:
 	case F_Selected:
-	  if (DeleteRats (True))
-	    SetChangedFlag (True);
+	  if (DeleteRats (true))
+	    SetChangedFlag (true);
 	  break;
 	}
-      RestoreCrosshair (True);
+      RestoreCrosshair (true);
     }
   return 0;
 }
@@ -3820,10 +3820,10 @@ ActionAutoPlaceSelected (int argc, char **argv, int x, int y)
   if (gui->confirm_dialog (_("Auto-placement can NOT be undone.\n"
 			     "Do you want to continue anyway?\n"), 0))
     {
-      HideCrosshair (True);
+      HideCrosshair (true);
       if (AutoPlaceSelected ())
-	SetChangedFlag (True);
-      RestoreCrosshair (True);
+	SetChangedFlag (true);
+      RestoreCrosshair (true);
     }
   return 0;
 }
@@ -3864,20 +3864,20 @@ ActionAutoRoute (int argc, char **argv, int x, int y)
   hid_action("Busy");
   if (function)			/* one parameter */
     {
-      HideCrosshair (True);
+      HideCrosshair (true);
       switch (GetFunctionID (function))
 	{
 	case F_AllRats:
-	  if (AutoRoute (False))
-	    SetChangedFlag (True);
+	  if (AutoRoute (false))
+	    SetChangedFlag (true);
 	  break;
 	case F_SelectedRats:
 	case F_Selected:
-	  if (AutoRoute (True))
-	    SetChangedFlag (True);
+	  if (AutoRoute (true))
+	    SetChangedFlag (true);
 	  break;
 	}
-      RestoreCrosshair (True);
+      RestoreCrosshair (true);
     }
   return 0;
 }
@@ -3911,24 +3911,24 @@ ActionMarkCrosshair (int argc, char **argv, int x, int y)
     {
       if (Marked.status)
 	{
-	  DrawMark (True);
-	  Marked.status = False;
+	  DrawMark (true);
+	  Marked.status = false;
 	}
       else
 	{
-	  Marked.status = True;
+	  Marked.status = true;
 	  Marked.X = Crosshair.X;
 	  Marked.Y = Crosshair.Y;
-	  DrawMark (False);
+	  DrawMark (false);
 	}
     }
   else if (GetFunctionID (function) == F_Center)
     {
-      DrawMark (True);
-      Marked.status = True;
+      DrawMark (true);
+      Marked.status = true;
       Marked.X = Crosshair.X;
       Marked.Y = Crosshair.Y;
-      DrawMark (False);
+      DrawMark (false);
     }
   return 0;
 }
@@ -3960,13 +3960,13 @@ ActionChangeSize (int argc, char **argv, int x, int y)
   char *function = ARG (0);
   char *delta = ARG (1);
   char *units = ARG (2);
-  Boolean r;			/* indicates if absolute size is given */
+  bool r;			/* indicates if absolute size is given */
   float value;
 
   if (function && delta)
     {
       value = GetValue (delta, units, &r);
-      HideCrosshair (True);
+      HideCrosshair (true);
       switch (GetFunctionID (function))
 	{
 	case F_Object:
@@ -3980,57 +3980,57 @@ ActionChangeSize (int argc, char **argv, int x, int y)
 	      if (TEST_FLAG (LOCKFLAG, (PinTypePtr) ptr2))
 		Message (_("Sorry, the object is locked\n"));
 	    if (ChangeObjectSize (type, ptr1, ptr2, ptr3, value, r))
-	      SetChangedFlag (True);
+	      SetChangedFlag (true);
 	    break;
 	  }
 
 	case F_SelectedVias:
 	  if (ChangeSelectedSize (VIA_TYPE, value, r))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 
 	case F_SelectedPins:
 	  if (ChangeSelectedSize (PIN_TYPE, value, r))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 
 	case F_SelectedPads:
 	  if (ChangeSelectedSize (PAD_TYPE, value, r))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 
 	case F_SelectedArcs:
 	  if (ChangeSelectedSize (ARC_TYPE, value, r))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 
 	case F_SelectedLines:
 	  if (ChangeSelectedSize (LINE_TYPE, value, r))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 
 	case F_SelectedTexts:
 	  if (ChangeSelectedSize (TEXT_TYPE, value, r))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 
 	case F_SelectedNames:
 	  if (ChangeSelectedSize (ELEMENTNAME_TYPE, value, r))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 
 	case F_SelectedElements:
 	  if (ChangeSelectedSize (ELEMENT_TYPE, value, r))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 
 	case F_Selected:
 	case F_SelectedObjects:
 	  if (ChangeSelectedSize (CHANGESIZE_TYPES, value, r))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 	}
-      RestoreCrosshair (True);
+      RestoreCrosshair (true);
     }
   return 0;
 }
@@ -4054,13 +4054,13 @@ ActionChange2ndSize (int argc, char **argv, int x, int y)
   char *function = ARG (0);
   char *delta = ARG (1);
   char *units = ARG (2);
-  Boolean r;
+  bool r;
   float value;
 
   if (function && delta)
     {
       value = GetValue (delta, units, &r);
-      HideCrosshair (True);
+      HideCrosshair (true);
       switch (GetFunctionID (function))
 	{
 	case F_Object:
@@ -4073,27 +4073,27 @@ ActionChange2ndSize (int argc, char **argv, int x, int y)
 		 SearchScreen (x, y, CHANGE2NDSIZE_TYPES,
 			       &ptr1, &ptr2, &ptr3)) != NO_TYPE)
 	      if (ChangeObject2ndSize
-		  (type, ptr1, ptr2, ptr3, value, r, True))
-		SetChangedFlag (True);
+		  (type, ptr1, ptr2, ptr3, value, r, true))
+		SetChangedFlag (true);
 	    break;
 	  }
 
 	case F_SelectedVias:
 	  if (ChangeSelected2ndSize (VIA_TYPE, value, r))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 
 	case F_SelectedPins:
 	  if (ChangeSelected2ndSize (PIN_TYPE, value, r))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 	case F_Selected:
 	case F_SelectedObjects:
 	  if (ChangeSelected2ndSize (PIN_TYPES, value, r))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 	}
-      RestoreCrosshair (True);
+      RestoreCrosshair (true);
     }
   return 0;
 }
@@ -4123,13 +4123,13 @@ ActionChangeClearSize (int argc, char **argv, int x, int y)
   char *function = ARG (0);
   char *delta = ARG (1);
   char *units = ARG (2);
-  Boolean r;
+  bool r;
   float value;
 
   if (function && delta)
     {
       value = 2 * GetValue (delta, units, &r);
-      HideCrosshair (True);
+      HideCrosshair (true);
       switch (GetFunctionID (function))
 	{
 	case F_Object:
@@ -4143,36 +4143,36 @@ ActionChangeClearSize (int argc, char **argv, int x, int y)
 			       CHANGECLEARSIZE_TYPES, &ptr1, &ptr2,
 			       &ptr3)) != NO_TYPE)
 	      if (ChangeObjectClearSize (type, ptr1, ptr2, ptr3, value, r))
-		SetChangedFlag (True);
+		SetChangedFlag (true);
 	    break;
 	  }
 	case F_SelectedVias:
 	  if (ChangeSelectedClearSize (VIA_TYPE, value, r))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 	case F_SelectedPads:
 	  if (ChangeSelectedClearSize (PAD_TYPE, value, r))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 	case F_SelectedPins:
 	  if (ChangeSelectedClearSize (PIN_TYPE, value, r))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 	case F_SelectedLines:
 	  if (ChangeSelectedClearSize (LINE_TYPE, value, r))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 	case F_SelectedArcs:
 	  if (ChangeSelectedClearSize (ARC_TYPE, value, r))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 	case F_Selected:
 	case F_SelectedObjects:
 	  if (ChangeSelectedClearSize (CHANGECLEARSIZE_TYPES, value, r))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 	}
-      RestoreCrosshair (True);
+      RestoreCrosshair (true);
     }
   return 0;
 }
@@ -4199,7 +4199,7 @@ ActionMinMaskGap (int argc, char **argv, int x, int y)
   char *function = ARG (0);
   char *delta = ARG (1);
   char *units = ARG (2);
-  Boolean r;
+  bool r;
   int value;
   int flags;
 
@@ -4215,7 +4215,7 @@ ActionMinMaskGap (int argc, char **argv, int x, int y)
     }
   value = 2 * GetValue (delta, units, &r);
 
-  HideCrosshair (True);
+  HideCrosshair (true);
   SaveUndoSerialNumber ();
   ELEMENT_LOOP (PCB->Data);
   {
@@ -4283,7 +4283,7 @@ ActionMinClearGap (int argc, char **argv, int x, int y)
   char *function = ARG (0);
   char *delta = ARG (1);
   char *units = ARG (2);
-  Boolean r;
+  bool r;
   int value;
   int flags;
 
@@ -4299,7 +4299,7 @@ ActionMinClearGap (int argc, char **argv, int x, int y)
     }
   value = 2 * GetValue (delta, units, &r);
 
-  HideCrosshair (True);
+  HideCrosshair (true);
   SaveUndoSerialNumber ();
   ELEMENT_LOOP (PCB->Data);
   {
@@ -4417,7 +4417,7 @@ ActionChangePinName (int argc, char **argv, int x, int y)
 	       * it is used in the undo list
 	       */
 	      pin->Name = strdup (pinname);
-	      SetChangedFlag (True);
+	      SetChangedFlag (true);
 	      changed = 1;
 	    }
 	}
@@ -4434,7 +4434,7 @@ ActionChangePinName (int argc, char **argv, int x, int y)
 	       * it is used in the undo list
 	       */
 	      pad->Name = strdup (pinname);
-	      SetChangedFlag (True);
+	      SetChangedFlag (true);
 	      changed = 1;
 	    }
 	}
@@ -4492,7 +4492,7 @@ ActionChangeName (int argc, char **argv, int x, int y)
 
   if (function)
     {
-      HideCrosshair (True);
+      HideCrosshair (true);
       switch (GetFunctionID (function))
 	{
 	  /* change the name of an object */
@@ -4509,7 +4509,7 @@ ActionChangeName (int argc, char **argv, int x, int y)
 		SaveUndoSerialNumber ();
 		if (QueryInputAndChangeObjectName (type, ptr1, ptr2, ptr3))
 		  {
-		    SetChangedFlag (True);
+		    SetChangedFlag (true);
 		    if (type == ELEMENT_TYPE)
 		      {
 			RubberbandTypePtr ptr;
@@ -4541,7 +4541,7 @@ ActionChangeName (int argc, char **argv, int x, int y)
 	  name =
 	    gui->prompt_for (_("Enter the layout name:"), EMPTY (PCB->Name));
 	  if (name && ChangeLayoutName (name))	/* XXX memory leak */
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 
 	  /* change the name of the active layer */
@@ -4549,10 +4549,10 @@ ActionChangeName (int argc, char **argv, int x, int y)
 	  name = gui->prompt_for (_("Enter the layer name:"),
 				  EMPTY (CURRENT->Name));
 	  if (name && ChangeLayerName (CURRENT, name))	/* XXX memory leak */
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 	}
-      RestoreCrosshair (True);
+      RestoreCrosshair (true);
     }
   return 0;
 }
@@ -4581,7 +4581,7 @@ ActionMorphPolygon (int argc, char **argv, int x, int y)
   char *function = ARG (0);
   if (function)
     {
-      HideCrosshair (True);
+      HideCrosshair (true);
       switch (GetFunctionID (function))
 	{
 	case F_Object:
@@ -4636,7 +4636,7 @@ ActionToggleHideName (int argc, char **argv, int x, int y)
   char *function = ARG (0);
   if (function && PCB->ElementOn)
     {
-      HideCrosshair (True);
+      HideCrosshair (true);
       switch (GetFunctionID (function))
 	{
 	case F_Object:
@@ -4660,7 +4660,7 @@ ActionToggleHideName (int argc, char **argv, int x, int y)
 	case F_SelectedElements:
 	case F_Selected:
 	  {
-	    Boolean changed = False;
+	    bool changed = false;
 	    ELEMENT_LOOP (PCB->Data);
 	    {
 	      if ((TEST_FLAG (SELECTEDFLAG, element) ||
@@ -4673,7 +4673,7 @@ ActionToggleHideName (int argc, char **argv, int x, int y)
 		  EraseElementName (element);
 		  TOGGLE_FLAG (HIDENAMEFLAG, element);
 		  DrawElementName (element, 0);
-		  changed = True;
+		  changed = true;
 		}
 	    }
 	    END_LOOP;
@@ -4684,7 +4684,7 @@ ActionToggleHideName (int argc, char **argv, int x, int y)
 	      }
 	  }
 	}
-      RestoreCrosshair (True);
+      RestoreCrosshair (true);
     }
   return 0;
 }
@@ -4713,7 +4713,7 @@ ActionChangeJoin (int argc, char **argv, int x, int y)
   char *function = ARG (0);
   if (function)
     {
-      HideCrosshair (True);
+      HideCrosshair (true);
       switch (GetFunctionID (function))
 	{
 	case F_ToggleObject:
@@ -4727,27 +4727,27 @@ ActionChangeJoin (int argc, char **argv, int x, int y)
 		 SearchScreen (x, y, CHANGEJOIN_TYPES,
 			       &ptr1, &ptr2, &ptr3)) != NO_TYPE)
 	      if (ChangeObjectJoin (type, ptr1, ptr2, ptr3))
-		SetChangedFlag (True);
+		SetChangedFlag (true);
 	    break;
 	  }
 
 	case F_SelectedLines:
 	  if (ChangeSelectedJoin (LINE_TYPE))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 
 	case F_SelectedArcs:
 	  if (ChangeSelectedJoin (ARC_TYPE))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 
 	case F_Selected:
 	case F_SelectedObjects:
 	  if (ChangeSelectedJoin (CHANGEJOIN_TYPES))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 	}
-      RestoreCrosshair (True);
+      RestoreCrosshair (true);
     }
   return 0;
 }
@@ -4776,7 +4776,7 @@ ActionChangeSquare (int argc, char **argv, int x, int y)
   char *function = ARG (0);
   if (function)
     {
-      HideCrosshair (True);
+      HideCrosshair (true);
       switch (GetFunctionID (function))
 	{
 	case F_ToggleObject:
@@ -4790,27 +4790,27 @@ ActionChangeSquare (int argc, char **argv, int x, int y)
 		 SearchScreen (x, y, CHANGESQUARE_TYPES,
 			       &ptr1, &ptr2, &ptr3)) != NO_TYPE)
 	      if (ChangeObjectSquare (type, ptr1, ptr2, ptr3))
-		SetChangedFlag (True);
+		SetChangedFlag (true);
 	    break;
 	  }
 
 	case F_SelectedElements:
 	  if (ChangeSelectedSquare (ELEMENT_TYPE))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 
 	case F_SelectedPins:
 	  if (ChangeSelectedSquare (PIN_TYPE | PAD_TYPE))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 
 	case F_Selected:
 	case F_SelectedObjects:
 	  if (ChangeSelectedSquare (PIN_TYPE | PAD_TYPE))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 	}
-      RestoreCrosshair (True);
+      RestoreCrosshair (true);
     }
   return 0;
 }
@@ -4836,7 +4836,7 @@ ActionSetSquare (int argc, char **argv, int x, int y)
   char *function = ARG (0);
   if (function && *function)
     {
-      /* HideCrosshair (True); */
+      /* HideCrosshair (true); */
       switch (GetFunctionID (function))
 	{
 	case F_ToggleObject:
@@ -4850,27 +4850,27 @@ ActionSetSquare (int argc, char **argv, int x, int y)
 		 SearchScreen (x, y, CHANGESQUARE_TYPES,
 			       &ptr1, &ptr2, &ptr3)) != NO_TYPE)
 	      if (SetObjectSquare (type, ptr1, ptr2, ptr3))
-		SetChangedFlag (True);
+		SetChangedFlag (true);
 	    break;
 	  }
 
 	case F_SelectedElements:
 	  if (SetSelectedSquare (ELEMENT_TYPE))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 
 	case F_SelectedPins:
 	  if (SetSelectedSquare (PIN_TYPE | PAD_TYPE))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 
 	case F_Selected:
 	case F_SelectedObjects:
 	  if (SetSelectedSquare (PIN_TYPE | PAD_TYPE))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 	}
-      /* RestoreCrosshair (True); */
+      /* RestoreCrosshair (true); */
     }
   return 0;
 }
@@ -4897,7 +4897,7 @@ ActionClearSquare (int argc, char **argv, int x, int y)
   char *function = ARG (0);
   if (function && *function)
     {
-      /* HideCrosshair (True); */
+      /* HideCrosshair (true); */
       switch (GetFunctionID (function))
 	{
 	case F_ToggleObject:
@@ -4911,27 +4911,27 @@ ActionClearSquare (int argc, char **argv, int x, int y)
 		 SearchScreen (x, y, CHANGESQUARE_TYPES,
 			       &ptr1, &ptr2, &ptr3)) != NO_TYPE)
 	      if (ClrObjectSquare (type, ptr1, ptr2, ptr3))
-		SetChangedFlag (True);
+		SetChangedFlag (true);
 	    break;
 	  }
 
 	case F_SelectedElements:
 	  if (ClrSelectedSquare (ELEMENT_TYPE))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 
 	case F_SelectedPins:
 	  if (ClrSelectedSquare (PIN_TYPE | PAD_TYPE))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 
 	case F_Selected:
 	case F_SelectedObjects:
 	  if (ClrSelectedSquare (PIN_TYPE | PAD_TYPE))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 	}
-      /* RestoreCrosshair (True); */
+      /* RestoreCrosshair (true); */
     }
   return 0;
 }
@@ -4957,7 +4957,7 @@ ActionChangeOctagon (int argc, char **argv, int x, int y)
   char *function = ARG (0);
   if (function)
     {
-      /* HideCrosshair (True); */
+      /* HideCrosshair (true); */
       switch (GetFunctionID (function))
 	{
 	case F_ToggleObject:
@@ -4971,32 +4971,32 @@ ActionChangeOctagon (int argc, char **argv, int x, int y)
 		 SearchScreen (x, y, CHANGEOCTAGON_TYPES,
 			       &ptr1, &ptr2, &ptr3)) != NO_TYPE)
 	      if (ChangeObjectOctagon (type, ptr1, ptr2, ptr3))
-		SetChangedFlag (True);
+		SetChangedFlag (true);
 	    break;
 	  }
 
 	case F_SelectedElements:
 	  if (ChangeSelectedOctagon (ELEMENT_TYPE))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 
 	case F_SelectedPins:
 	  if (ChangeSelectedOctagon (PIN_TYPE))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 
 	case F_SelectedVias:
 	  if (ChangeSelectedOctagon (VIA_TYPE))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 
 	case F_Selected:
 	case F_SelectedObjects:
 	  if (ChangeSelectedOctagon (PIN_TYPES))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 	}
-      /* RestoreCrosshair (True); */
+      /* RestoreCrosshair (true); */
     }
   return 0;
 }
@@ -5020,7 +5020,7 @@ ActionSetOctagon (int argc, char **argv, int x, int y)
   char *function = ARG (0);
   if (function)
     {
-      /* HideCrosshair (True); */
+      /* HideCrosshair (true); */
       switch (GetFunctionID (function))
 	{
 	case F_ToggleObject:
@@ -5034,32 +5034,32 @@ ActionSetOctagon (int argc, char **argv, int x, int y)
 		 SearchScreen (x, y, CHANGEOCTAGON_TYPES,
 			       &ptr1, &ptr2, &ptr3)) != NO_TYPE)
 	      if (SetObjectOctagon (type, ptr1, ptr2, ptr3))
-		SetChangedFlag (True);
+		SetChangedFlag (true);
 	    break;
 	  }
 
 	case F_SelectedElements:
 	  if (SetSelectedOctagon (ELEMENT_TYPE))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 
 	case F_SelectedPins:
 	  if (SetSelectedOctagon (PIN_TYPE))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 
 	case F_SelectedVias:
 	  if (SetSelectedOctagon (VIA_TYPE))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 
 	case F_Selected:
 	case F_SelectedObjects:
 	  if (SetSelectedOctagon (PIN_TYPES))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 	}
-      /* RestoreCrosshair (True); */
+      /* RestoreCrosshair (true); */
     }
   return 0;
 }
@@ -5085,7 +5085,7 @@ ActionClearOctagon (int argc, char **argv, int x, int y)
   char *function = ARG (0);
   if (function)
     {
-      /* HideCrosshair (True); */
+      /* HideCrosshair (true); */
       switch (GetFunctionID (function))
 	{
 	case F_ToggleObject:
@@ -5099,32 +5099,32 @@ ActionClearOctagon (int argc, char **argv, int x, int y)
 		 SearchScreen (Crosshair.X, Crosshair.Y, CHANGEOCTAGON_TYPES,
 			       &ptr1, &ptr2, &ptr3)) != NO_TYPE)
 	      if (ClrObjectOctagon (type, ptr1, ptr2, ptr3))
-		SetChangedFlag (True);
+		SetChangedFlag (true);
 	    break;
 	  }
 
 	case F_SelectedElements:
 	  if (ClrSelectedOctagon (ELEMENT_TYPE))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 
 	case F_SelectedPins:
 	  if (ClrSelectedOctagon (PIN_TYPE))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 
 	case F_SelectedVias:
 	  if (ClrSelectedOctagon (VIA_TYPE))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 
 	case F_Selected:
 	case F_SelectedObjects:
 	  if (ClrSelectedOctagon (PIN_TYPES))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 	}
-      /* RestoreCrosshair (True); */
+      /* RestoreCrosshair (true); */
     }
   return 0;
 }
@@ -5149,7 +5149,7 @@ ActionChangeHole (int argc, char **argv, int x, int y)
   char *function = ARG (0);
   if (function)
     {
-      /* HideCrosshair (True); */
+      /* HideCrosshair (true); */
       switch (GetFunctionID (function))
 	{
 	case F_ToggleObject:
@@ -5169,10 +5169,10 @@ ActionChangeHole (int argc, char **argv, int x, int y)
 	case F_SelectedVias:
 	case F_Selected:
 	  if (ChangeSelectedHole ())
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 	}
-      /* RestoreCrosshair (True); */
+      /* RestoreCrosshair (true); */
     }
   return 0;
 }
@@ -5199,7 +5199,7 @@ ActionChangePaste (int argc, char **argv, int x, int y)
   char *function = ARG (0);
   if (function)
     {
-      /* HideCrosshair (True); */
+      /* HideCrosshair (true); */
       switch (GetFunctionID (function))
 	{
 	case F_ToggleObject:
@@ -5219,10 +5219,10 @@ ActionChangePaste (int argc, char **argv, int x, int y)
 	case F_SelectedPads:
 	case F_Selected:
 	  if (ChangeSelectedPaste ())
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 	}
-      /* RestoreCrosshair (True); */
+      /* RestoreCrosshair (true); */
     }
   return 0;
 }
@@ -5283,7 +5283,7 @@ ActionSelect (int argc, char **argv, int x, int y)
   if (function)
     {
 
-      HideCrosshair (True);
+      HideCrosshair (true);
       switch (GetFunctionID (function))
 	{
 #if defined(HAVE_REGCOMP) || defined(HAVE_RE_COMP)
@@ -5316,8 +5316,8 @@ ActionSelect (int argc, char **argv, int x, int y)
 		|| (pattern =
 		    gui->prompt_for (_("Enter pattern:"), "")) != NULL)
 	      {
-		if (SelectObjectByName (type, pattern, True))
-		  SetChangedFlag (True);
+		if (SelectObjectByName (type, pattern, true))
+		  SetChangedFlag (true);
 		if (ARG (1) == 0)
 		  free (pattern);
 	      }
@@ -5329,7 +5329,7 @@ ActionSelect (int argc, char **argv, int x, int y)
 	case F_ToggleObject:
 	case F_Object:
 	  if (SelectObject ())
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 
 	  /* all objects in block */
@@ -5347,9 +5347,9 @@ ActionSelect (int argc, char **argv, int x, int y)
 			  Crosshair.AttachedBox.Point2.Y);
 	    NotifyBlock ();
 	    if (Crosshair.AttachedBox.State == STATE_THIRD &&
-		SelectBlock (&box, True))
+		SelectBlock (&box, true))
 	      {
-		SetChangedFlag (True);
+		SetChangedFlag (true);
 		Crosshair.AttachedBox.State = STATE_FIRST;
 	      }
 	    break;
@@ -5364,17 +5364,17 @@ ActionSelect (int argc, char **argv, int x, int y)
 	    box.Y1 = -MAX_COORD;
 	    box.X2 = MAX_COORD;
 	    box.Y2 = MAX_COORD;
-	    if (SelectBlock (&box, True))
-	      SetChangedFlag (True);
+	    if (SelectBlock (&box, true))
+	      SetChangedFlag (true);
 	    break;
 	  }
 
 	  /* all found connections */
 	case F_Connection:
-	  if (SelectConnection (True))
+	  if (SelectConnection (true))
 	    {
 	      IncrementUndoSerialNumber ();
-	      SetChangedFlag (True);
+	      SetChangedFlag (true);
 	    }
 	  break;
 
@@ -5387,7 +5387,7 @@ ActionSelect (int argc, char **argv, int x, int y)
 	    gui->get_coords (_("Select the Element's Mark Location"), &x, &y);
 	    x = GRIDFIT_X (x, PCB->Grid);
 	    y = GRIDFIT_Y (y, PCB->Grid);
-	    AddSelectedToBuffer (PASTEBUFFER, x, y, True);
+	    AddSelectedToBuffer (PASTEBUFFER, x, y, true);
 	    SaveUndoSerialNumber ();
 	    RemoveSelected ();
 	    ConvertBufferToElement (PASTEBUFFER);
@@ -5398,11 +5398,11 @@ ActionSelect (int argc, char **argv, int x, int y)
 	  break;
 
 	default:
-	  RestoreCrosshair (True);
+	  RestoreCrosshair (true);
 	  AFAIL (select);
 	  break;
 	}
-      RestoreCrosshair (True);
+      RestoreCrosshair (true);
     }
   return 0;
 }
@@ -5466,7 +5466,7 @@ ActionUnselect (int argc, char **argv, int x, int y)
 
   if (function)
     {
-      HideCrosshair (True);
+      HideCrosshair (true);
       switch (GetFunctionID (function))
 	{
 #if defined(HAVE_REGCOMP) || defined(HAVE_RE_COMP)
@@ -5499,8 +5499,8 @@ ActionUnselect (int argc, char **argv, int x, int y)
 		|| (pattern =
 		    gui->prompt_for (_("Enter pattern:"), "")) != NULL)
 	      {
-		if (SelectObjectByName (type, pattern, False))
-		  SetChangedFlag (True);
+		if (SelectObjectByName (type, pattern, false))
+		  SetChangedFlag (true);
 		if (ARG (1) == 0)
 		  free (pattern);
 	      }
@@ -5523,9 +5523,9 @@ ActionUnselect (int argc, char **argv, int x, int y)
 			  Crosshair.AttachedBox.Point2.Y);
 	    NotifyBlock ();
 	    if (Crosshair.AttachedBox.State == STATE_THIRD &&
-		SelectBlock (&box, False))
+		SelectBlock (&box, false))
 	      {
-		SetChangedFlag (True);
+		SetChangedFlag (true);
 		Crosshair.AttachedBox.State = STATE_FIRST;
 	      }
 	    break;
@@ -5540,27 +5540,27 @@ ActionUnselect (int argc, char **argv, int x, int y)
 	    box.Y1 = -MAX_COORD;
 	    box.X2 = MAX_COORD;
 	    box.Y2 = MAX_COORD;
-	    if (SelectBlock (&box, False))
-	      SetChangedFlag (True);
+	    if (SelectBlock (&box, false))
+	      SetChangedFlag (true);
 	    break;
 	  }
 
 	  /* all found connections */
 	case F_Connection:
-	  if (SelectConnection (False))
+	  if (SelectConnection (false))
 	    {
 	      IncrementUndoSerialNumber ();
-	      SetChangedFlag (True);
+	      SetChangedFlag (true);
 	    }
 	  break;
 
 	default:
-	  RestoreCrosshair (True);
+	  RestoreCrosshair (true);
 	  AFAIL (unselect);
 	  break;
 
 	}
-      RestoreCrosshair (True);
+      RestoreCrosshair (true);
     }
   return 0;
 }
@@ -5629,12 +5629,12 @@ ActionSaveTo (int argc, char **argv, int x, int y)
   if (strcasecmp (function, "AllConnections") == 0)
     {
       FILE *fp;
-      Boolean result;
-      if ((fp = CheckAndOpenFile (name, True, False, &result, NULL)) != NULL)
+      bool result;
+      if ((fp = CheckAndOpenFile (name, true, false, &result, NULL)) != NULL)
 	{
 	  LookupConnectionsToAllElements (fp);
 	  fclose (fp);
-	  SetChangedFlag (True);
+	  SetChangedFlag (true);
 	}
       return 0;
     }
@@ -5642,12 +5642,12 @@ ActionSaveTo (int argc, char **argv, int x, int y)
   if (strcasecmp (function, "AllUnusedPins") == 0)
     {
       FILE *fp;
-      Boolean result;
-      if ((fp = CheckAndOpenFile (name, True, False, &result, NULL)) != NULL)
+      bool result;
+      if ((fp = CheckAndOpenFile (name, true, false, &result, NULL)) != NULL)
 	{
 	  LookupUnusedPins (fp);
 	  fclose (fp);
-	  SetChangedFlag (True);
+	  SetChangedFlag (true);
 	}
       return 0;
     }
@@ -5657,18 +5657,18 @@ ActionSaveTo (int argc, char **argv, int x, int y)
       ElementTypePtr element;
       void *ptrtmp;
       FILE *fp;
-      Boolean result;
+      bool result;
 
       if ((SearchScreen (Crosshair.X, Crosshair.Y, ELEMENT_TYPE,
 			 &ptrtmp, &ptrtmp, &ptrtmp)) != NO_TYPE)
 	{
 	  element = (ElementTypePtr) ptrtmp;
 	  if ((fp =
-	       CheckAndOpenFile (name, True, False, &result, NULL)) != NULL)
+	       CheckAndOpenFile (name, true, false, &result, NULL)) != NULL)
 	    {
 	      LookupElementConnections (element, fp);
 	      fclose (fp);
-	      SetChangedFlag (True);
+	      SetChangedFlag (true);
 	    }
 	}
       return 0;
@@ -5756,11 +5756,11 @@ ActionLoadFrom (int argc, char **argv, int x, int y)
   function = argv[0];
   name = argv[1];
 
-  HideCrosshair (True);
+  HideCrosshair (true);
 
   if (strcasecmp (function, "ElementToBuffer") == 0)
     {
-      if (LoadElementToBuffer (PASTEBUFFER, name, True))
+      if (LoadElementToBuffer (PASTEBUFFER, name, true))
 	SetMode (PASTEBUFFER_MODE);
     }
 
@@ -5794,7 +5794,7 @@ ActionLoadFrom (int argc, char **argv, int x, int y)
       LoadPCB (fname);
     }
 
-  RestoreCrosshair (True);
+  RestoreCrosshair (true);
   return 0;
 }
 
@@ -5815,7 +5815,7 @@ ActionNew (int argc, char **argv, int x, int y)
 {
   char *name = ARG (0);
 
-  HideCrosshair (True);
+  HideCrosshair (true);
   if (!PCB->Changed || gui->confirm_dialog (_("OK to clear layout data?"), 0))
     {
       if (name)
@@ -5825,7 +5825,7 @@ ActionNew (int argc, char **argv, int x, int y)
 
       if (!name)
 	{
-	  RestoreCrosshair(True);
+	  RestoreCrosshair(true);
 	  return 1;
 	}
 
@@ -5835,7 +5835,7 @@ ActionNew (int argc, char **argv, int x, int y)
       if (PCB->Changed && Settings.SaveInTMP)
 	SaveInTMP ();
       RemovePCB (PCB);
-      PCB = CreateNewPCB (True);
+      PCB = CreateNewPCB (true);
       PCB->Data->LayerN = DEF_LAYER;
       CreateNewPCBPost (PCB, 1);
 
@@ -5845,14 +5845,14 @@ ActionNew (int argc, char **argv, int x, int y)
       ResetStackAndVisibility ();
       CreateDefaultFont ();
       SetCrosshairRange (0, 0, PCB->MaxWidth, PCB->MaxHeight);
-      CenterDisplay (PCB->MaxWidth / 2, PCB->MaxHeight / 2, False);
+      CenterDisplay (PCB->MaxWidth / 2, PCB->MaxHeight / 2, false);
       ClearAndRedrawOutput ();
 
       hid_action ("PCBChanged");
-      RestoreCrosshair(True);
+      RestoreCrosshair(true);
       return 0;
     }
-  RestoreCrosshair (True);
+  RestoreCrosshair (true);
   return 1;
 }
 
@@ -5937,7 +5937,7 @@ ActionPasteBuffer (int argc, char **argv, int x, int y)
   static char *default_file = NULL;
   int free_name = 0;
 
-  HideCrosshair (True);
+  HideCrosshair (true);
   if (function)
     {
       switch (GetFunctionID (function))
@@ -5949,7 +5949,7 @@ ActionPasteBuffer (int argc, char **argv, int x, int y)
 
 	  /* copies objects to paste buffer */
 	case F_AddSelected:
-	  AddSelectedToBuffer (PASTEBUFFER, 0, 0, False);
+	  AddSelectedToBuffer (PASTEBUFFER, 0, 0, false);
 	  break;
 
 	  /* converts buffer contents into an element */
@@ -6027,7 +6027,7 @@ ActionPasteBuffer (int argc, char **argv, int x, int y)
 	  {
 	    static int oldx = 0, oldy = 0;
 	    int x, y;
-	    Boolean r;
+	    bool r;
 
 	    if (argc == 1)
 	      {
@@ -6044,14 +6044,14 @@ ActionPasteBuffer (int argc, char **argv, int x, int y)
 	      }
 	    else
 	      {
-		RestoreCrosshair (True);
+		RestoreCrosshair (true);
 		AFAIL (pastebuffer);
 	      }
 
 	    oldx = x;
 	    oldy = y;
 	    if (CopyPastebufferToLayout (x, y))
-	      SetChangedFlag (True);
+	      SetChangedFlag (true);
 	  }
 	  break;
 
@@ -6067,7 +6067,7 @@ ActionPasteBuffer (int argc, char **argv, int x, int y)
 	}
     }
 
-  RestoreCrosshair (True);
+  RestoreCrosshair (true);
   return 0;
 }
 
@@ -6106,11 +6106,11 @@ ActionUndo (int argc, char **argv, int x, int y)
 	return 1;
       /* undo the last operation */
 
-      HideCrosshair (True);
+      HideCrosshair (true);
       if (Settings.Mode == POLYGON_MODE && Crosshair.AttachedPolygon.PointN)
 	{
 	  GoToPreviousPoint ();
-	  RestoreCrosshair (True);
+	  RestoreCrosshair (true);
 	  return 0;
 	}
       /* move anchor point if undoing during line creation */
@@ -6119,10 +6119,10 @@ ActionUndo (int argc, char **argv, int x, int y)
 	  if (Crosshair.AttachedLine.State == STATE_SECOND)
 	    {
 	      if (TEST_FLAG (AUTODRCFLAG, PCB))
-		Undo (True);	/* undo the connection find */
+		Undo (true);	/* undo the connection find */
 	      Crosshair.AttachedLine.State = STATE_FIRST;
-	      SetLocalRef (0, 0, False);
-	      RestoreCrosshair (True);
+	      SetLocalRef (0, 0, false);
+	      RestoreCrosshair (true);
 	      return 0;
 	    }
 	  if (Crosshair.AttachedLine.State == STATE_THIRD)
@@ -6140,8 +6140,8 @@ ActionUndo (int argc, char **argv, int x, int y)
 	      /* save both ends of line */
 	      Crosshair.AttachedLine.Point2.X = ptr2->Point1.X;
 	      Crosshair.AttachedLine.Point2.Y = ptr2->Point1.Y;
-	      if ((type = Undo (True)))
-		SetChangedFlag (True);
+	      if ((type = Undo (true)))
+		SetChangedFlag (true);
 	      /* check that the undo was of the right type */
 	      if ((type & UNDO_CREATE) == 0)
 		{
@@ -6150,7 +6150,7 @@ ActionUndo (int argc, char **argv, int x, int y)
 		    Crosshair.AttachedLine.Point1.X;
 		  Crosshair.AttachedLine.Point2.Y =
 		    Crosshair.AttachedLine.Point1.Y;
-		  RestoreCrosshair (True);
+		  RestoreCrosshair (true);
 		  return 0;
 		}
 	      /* move to new anchor */
@@ -6197,7 +6197,7 @@ ActionUndo (int argc, char **argv, int x, int y)
 		  ptr2 = (LineTypePtr) ptrtmp;
 		  lastLayer = (LayerTypePtr) ptr1;
 		}
-	      RestoreCrosshair (True);
+	      RestoreCrosshair (true);
 	      return 0;
 	    }
 	}
@@ -6206,7 +6206,7 @@ ActionUndo (int argc, char **argv, int x, int y)
 	  if (Crosshair.AttachedBox.State == STATE_SECOND)
 	    {
 	      Crosshair.AttachedBox.State = STATE_FIRST;
-	      RestoreCrosshair (True);
+	      RestoreCrosshair (true);
 	      return 0;
 	    }
 	  if (Crosshair.AttachedBox.State == STATE_THIRD)
@@ -6228,8 +6228,8 @@ ActionUndo (int argc, char **argv, int x, int y)
 	    }
 	}
       /* undo the last destructive operation */
-      if (Undo (True))
-	SetChangedFlag (True);
+      if (Undo (true))
+	SetChangedFlag (true);
     }
   else if (function)
     {
@@ -6237,11 +6237,11 @@ ActionUndo (int argc, char **argv, int x, int y)
 	{
 	  /* clear 'undo objects' list */
 	case F_ClearList:
-	  ClearUndoList (False);
+	  ClearUndoList (false);
 	  break;
 	}
     }
-  RestoreCrosshair (True);
+  RestoreCrosshair (true);
   return 0;
 }
 
@@ -6273,10 +6273,10 @@ ActionRedo (int argc, char **argv, int x, int y)
        Crosshair.AttachedPolygon.PointN) ||
       Crosshair.AttachedLine.State == STATE_SECOND)
     return 1;
-  HideCrosshair (True);
-  if (Redo (True))
+  HideCrosshair (true);
+  if (Redo (true))
     {
-      SetChangedFlag (True);
+      SetChangedFlag (true);
       if (Settings.Mode == LINE_MODE &&
 	  Crosshair.AttachedLine.State != STATE_FIRST)
 	{
@@ -6288,7 +6288,7 @@ ActionRedo (int argc, char **argv, int x, int y)
 	  addedLines++;
 	}
     }
-  RestoreCrosshair (True);
+  RestoreCrosshair (true);
   return 0;
 }
 
@@ -6322,7 +6322,7 @@ ActionPolygon (int argc, char **argv, int x, int y)
   char *function = ARG (0);
   if (function && Settings.Mode == POLYGON_MODE)
     {
-      HideCrosshair (True);
+      HideCrosshair (true);
       switch (GetFunctionID (function))
 	{
 	  /* close open polygon if possible */
@@ -6335,7 +6335,7 @@ ActionPolygon (int argc, char **argv, int x, int y)
 	  GoToPreviousPoint ();
 	  break;
 	}
-      RestoreCrosshair (True);
+      RestoreCrosshair (true);
     }
   return 0;
 }
@@ -6365,8 +6365,8 @@ ActionRouteStyle (int argc, char **argv, int x, int y)
 	{
 	  rts = &PCB->RouteStyle[number - 1];
 	  SetLineSize (rts->Thick);
-	  SetViaSize (rts->Diameter, True);
-	  SetViaDrillingHole (rts->Hole, True);
+	  SetViaSize (rts->Diameter, true);
+	  SetViaDrillingHole (rts->Hole, true);
 	  SetKeepawayWidth (rts->Keepaway);
 	  hid_action("RouteStylesChanged");
 	}
@@ -6398,7 +6398,7 @@ ActionMoveObject (int argc, char **argv, int x, int y)
   char *y_str = ARG (1);
   char *units = ARG (2);
   LocationType nx, ny;
-  Boolean r1, r2;
+  bool r1, r2;
   void *ptr1, *ptr2, *ptr3;
   int type;
 
@@ -6421,7 +6421,7 @@ ActionMoveObject (int argc, char **argv, int x, int y)
   if (type == ELEMENT_TYPE)
     LookupRatLines (type, ptr1, ptr2, ptr3);
   MoveObjectAndRubberband (type, ptr1, ptr2, ptr3, nx, ny);
-  SetChangedFlag (True);
+  SetChangedFlag (true);
   return 0;
 }
 
@@ -6447,7 +6447,7 @@ ActionMoveToCurrentLayer (int argc, char **argv, int x, int y)
   char *function = ARG (0);
   if (function)
     {
-      HideCrosshair (True);
+      HideCrosshair (true);
       switch (GetFunctionID (function))
 	{
 	case F_Object:
@@ -6459,18 +6459,18 @@ ActionMoveToCurrentLayer (int argc, char **argv, int x, int y)
 	    if ((type =
 		 SearchScreen (x, y, MOVETOLAYER_TYPES,
 			       &ptr1, &ptr2, &ptr3)) != NO_TYPE)
-	      if (MoveObjectToLayer (type, ptr1, ptr2, ptr3, CURRENT, False))
-		SetChangedFlag (True);
+	      if (MoveObjectToLayer (type, ptr1, ptr2, ptr3, CURRENT, false))
+		SetChangedFlag (true);
 	    break;
 	  }
 
 	case F_SelectedObjects:
 	case F_Selected:
 	  if (MoveSelectedObjectsToLayer (CURRENT))
-	    SetChangedFlag (True);
+	    SetChangedFlag (true);
 	  break;
 	}
-      RestoreCrosshair (True);
+      RestoreCrosshair (true);
     }
   return 0;
 }
@@ -6501,24 +6501,24 @@ ActionSetSame (int argc, char **argv, int x, int y)
   switch (type)
     {
     case LINE_TYPE:
-      HideCrosshair (True);
+      HideCrosshair (true);
       Settings.LineThickness = ((LineTypePtr) ptr2)->Thickness;
       Settings.Keepaway = ((LineTypePtr) ptr2)->Clearance / 2;
       layer = (LayerTypePtr) ptr1;
       if (Settings.Mode != LINE_MODE)
 	SetMode (LINE_MODE);
-      RestoreCrosshair (True);
+      RestoreCrosshair (true);
       hid_action ("RouteStylesChanged");
       break;
 
     case ARC_TYPE:
-      HideCrosshair (True);
+      HideCrosshair (true);
       Settings.LineThickness = ((ArcTypePtr) ptr2)->Thickness;
       Settings.Keepaway = ((ArcTypePtr) ptr2)->Clearance / 2;
       layer = (LayerTypePtr) ptr1;
       if (Settings.Mode != ARC_MODE)
 	SetMode (ARC_MODE);
-      RestoreCrosshair (True);
+      RestoreCrosshair (true);
       hid_action ("RouteStylesChanged");
       break;
 
@@ -6527,13 +6527,13 @@ ActionSetSame (int argc, char **argv, int x, int y)
       break;
 
     case VIA_TYPE:
-      HideCrosshair (True);
+      HideCrosshair (true);
       Settings.ViaThickness = ((PinTypePtr) ptr2)->Thickness;
       Settings.ViaDrillingHole = ((PinTypePtr) ptr2)->DrillingHole;
       Settings.Keepaway = ((PinTypePtr) ptr2)->Clearance / 2;
       if (Settings.Mode != VIA_MODE)
 	SetMode (VIA_MODE);
-      RestoreCrosshair (True);
+      RestoreCrosshair (true);
       hid_action ("RouteStylesChanged");
       break;
 
@@ -6542,7 +6542,7 @@ ActionSetSame (int argc, char **argv, int x, int y)
     }
   if (layer != CURRENT)
     {
-      ChangeGroupVisibility (GetLayerNumber (PCB->Data, layer), True, True);
+      ChangeGroupVisibility (GetLayerNumber (PCB->Data, layer), true, true);
       ClearAndRedrawOutput ();
     }
   return 0;
@@ -6648,8 +6648,8 @@ ActionChangeFlag (int argc, char **argv, int x, int y)
 static void
 ChangeFlag (char *what, char *flag_name, int value, char *cmd_name)
 {
-  Boolean (*set_object) (int, void *, void *, void *);
-  Boolean (*set_selected) (int);
+  bool (*set_object) (int, void *, void *, void *);
+  bool (*set_selected) (int);
 
   if (NSTRCMP (flag_name, "square") == 0)
     {
@@ -6674,7 +6674,7 @@ ChangeFlag (char *what, char *flag_name, int value, char *cmd_name)
       return;
     }
 
-  HideCrosshair (True);
+  HideCrosshair (true);
   switch (GetFunctionID (what))
     {
     case F_Object:
@@ -6688,52 +6688,52 @@ ChangeFlag (char *what, char *flag_name, int value, char *cmd_name)
 	  if (TEST_FLAG (LOCKFLAG, (PinTypePtr) ptr2))
 	    Message (_("Sorry, the object is locked\n"));
 	if (set_object (type, ptr1, ptr2, ptr3))
-	  SetChangedFlag (True);
+	  SetChangedFlag (true);
 	break;
       }
 
     case F_SelectedVias:
       if (set_selected (VIA_TYPE))
-	SetChangedFlag (True);
+	SetChangedFlag (true);
       break;
 
     case F_SelectedPins:
       if (set_selected (PIN_TYPE))
-	SetChangedFlag (True);
+	SetChangedFlag (true);
       break;
 
     case F_SelectedPads:
       if (set_selected (PAD_TYPE))
-	SetChangedFlag (True);
+	SetChangedFlag (true);
       break;
 
     case F_SelectedLines:
       if (set_selected (LINE_TYPE))
-	SetChangedFlag (True);
+	SetChangedFlag (true);
       break;
 
     case F_SelectedTexts:
       if (set_selected (TEXT_TYPE))
-	SetChangedFlag (True);
+	SetChangedFlag (true);
       break;
 
     case F_SelectedNames:
       if (set_selected (ELEMENTNAME_TYPE))
-	SetChangedFlag (True);
+	SetChangedFlag (true);
       break;
 
     case F_SelectedElements:
       if (set_selected (ELEMENT_TYPE))
-	SetChangedFlag (True);
+	SetChangedFlag (true);
       break;
 
     case F_Selected:
     case F_SelectedObjects:
       if (set_selected (CHANGESIZE_TYPES))
-	SetChangedFlag (True);
+	SetChangedFlag (true);
       break;
     }
-  RestoreCrosshair (True);
+  RestoreCrosshair (true);
 
 }
 
@@ -6970,7 +6970,7 @@ ActionElementList (int argc, char **argv, int x, int y)
 	return 1;
       /* Place components onto center of board. */
       if (CopyPastebufferToLayout (PCB->MaxWidth/2, PCB->MaxHeight/2))
-	SetChangedFlag (True);
+	SetChangedFlag (true);
     }
 
   else if (e && strcmp (DESCRIPTION_NAME(e), footprint) != 0)
@@ -7007,7 +7007,7 @@ ActionElementList (int argc, char **argv, int x, int y)
       RemoveElement (e);
 
       if (CopyPastebufferToLayout (mx, my))
-	SetChangedFlag (True);
+	SetChangedFlag (true);
     }
 
   /* Now reload footprint */
@@ -7592,8 +7592,8 @@ ActionImport (int argc, char **argv, int x, int y)
       return 1;
     }
 
-  DeleteRats (False);
-  AddAllRats (False, NULL);
+  DeleteRats (false);
+  AddAllRats (false, NULL);
 
 #ifdef DEBUG
       printf("ActionImport:  ===========  Leaving ActionImport  ============\n");
diff --git a/src/action.h b/src/action.h
index 8ce4a15..ee116e8 100644
--- a/src/action.h
+++ b/src/action.h
@@ -44,6 +44,6 @@ void AdjustAttachedObjects (void);
 void warpNoWhere (void);
 
 /* In gui-misc.c */
-Boolean ActionGetLocation (char *);
+bool ActionGetLocation (char *);
 void ActionGetXY (char *);
 #endif
diff --git a/src/autoplace.c b/src/autoplace.c
index 2c85739..2572755 100644
--- a/src/autoplace.c
+++ b/src/autoplace.c
@@ -101,7 +101,7 @@ const struct
   float m;			/* annealing stage cutoff constant */
   float gamma;			/* annealing schedule constant */
   int good_ratio;		/* ratio of moves to good moves for halting */
-  Boolean fast;			/* ignore SMD/pin conflicts */
+  bool fast;			/* ignore SMD/pin conflicts */
   int large_grid_size;		/*snap perturbations to this grid when T is high */
   int small_grid_size;		/* snap to this grid when T is small. */
 }
@@ -120,7 +120,7 @@ CostParameter =
     20,				/* move on when each module has been profitably moved 20 times */
     0.75,			/* annealing schedule constant: 0.85 */
     40,				/* halt when there are 60 times as many moves as good moves */
-    False,			/* don't ignore SMD/pin conflicts */
+    false,			/* don't ignore SMD/pin conflicts */
     100,			/* coarse grid is 100 mils */
     10,				/* fine grid is 10 mils */
 };
@@ -336,7 +336,7 @@ ComputeCost (NetListTypePtr Nets, double T0, double T)
   double delta5 = 0;		/* total area penalty */
   Cardinal i, j;
   LocationType minx, maxx, miny, maxy;
-  Boolean allpads, allsameside;
+  bool allpads, allsameside;
   Cardinal thegroup;
   BoxListType bounds = { 0, 0, NULL };	/* save bounding rectangles here */
   BoxListType solderside = { 0, 0, NULL };	/* solder side component bounds */
@@ -356,7 +356,7 @@ ComputeCost (NetListTypePtr Nets, double T0, double T)
       miny = maxy = n->Connection[0].Y;
       thegroup = n->Connection[0].group;
       allpads = (n->Connection[0].type == PAD_TYPE);
-      allsameside = True;
+      allsameside = true;
       for (j = 1; j < n->ConnectionN; j++)
 	{
 	  ConnectionTypePtr c = &(n->Connection[j]);
@@ -365,9 +365,9 @@ ComputeCost (NetListTypePtr Nets, double T0, double T)
 	  MAKEMIN (miny, c->Y);
 	  MAKEMAX (maxy, c->Y);
 	  if (c->type != PAD_TYPE)
-	    allpads = False;
+	    allpads = false;
 	  if (c->group != thegroup)
-	    allsameside = False;
+	    allsameside = false;
 	}
       /* save bounding rectangle */
       {
@@ -656,7 +656,7 @@ createPerturbation (PointerListTypePtr selected, double T)
     case 1:
       {				/* flip/rotate! */
 	/* only flip if it's an SMD component */
-	Boolean isSMD = pt.element->PadN != 0;
+	bool isSMD = pt.element->PadN != 0;
 	pt.which = ROTATE;
 	pt.rotate = isSMD ? (random () & 3) : (1 + (random () % 3));
 	/* 0 - flip; 1-3, rotate. */
@@ -685,7 +685,7 @@ createPerturbation (PointerListTypePtr selected, double T)
 }
 
 void
-doPerturb (PerturbationType * pt, Boolean undo)
+doPerturb (PerturbationType * pt, bool undo)
 {
   LocationType bbcx, bbcy;
   /* compute center of element bounding box */
@@ -755,14 +755,14 @@ doPerturb (PerturbationType * pt, Boolean undo)
 /* ---------------------------------------------------------------------------
  * Auto-place selected components.
  */
-Boolean
+bool
 AutoPlaceSelected (void)
 {
   NetListTypePtr Nets;
   PointerListType Selected = { 0, 0, NULL };
   PerturbationType pt;
   double C0, T0;
-  Boolean changed = False;
+  bool changed = false;
 
   /* (initial netlist processing copied from AddAllRats) */
   /* the netlist library has the text form
@@ -794,9 +794,9 @@ AutoPlaceSelected (void)
     for (i = 0; i < TRIALS; i++)
       {
 	pt = createPerturbation (&Selected, 1e6);
-	doPerturb (&pt, False);
+	doPerturb (&pt, false);
 	Cs += fabs (ComputeCost (Nets, Tx, Tx) - C0);
-	doPerturb (&pt, True);
+	doPerturb (&pt, true);
       }
     T0 = -(Cs / TRIALS) / log (P);
     printf ("Initial T: %f\n", T0);
@@ -814,7 +814,7 @@ AutoPlaceSelected (void)
       {
 	double Cprime;
 	pt = createPerturbation (&Selected, T);
-	doPerturb (&pt, False);
+	doPerturb (&pt, false);
 	Cprime = ComputeCost (Nets, T0, T);
 	if (Cprime < C0)
 	  {			/* good move! */
@@ -830,7 +830,7 @@ AutoPlaceSelected (void)
 	    steps++;
 	  }
 	else
-	  doPerturb (&pt, True);	/* undo last change */
+	  doPerturb (&pt, true);	/* undo last change */
 	moves++;
 	/* are we at the end of a stage? */
 	if (good_moves >= good_move_cutoff || moves >= move_cutoff)
@@ -853,8 +853,8 @@ AutoPlaceSelected (void)
 done:
   if (changed)
     {
-      DeleteRats (False);
-      AddAllRats (False, NULL);
+      DeleteRats (false);
+      AddAllRats (false, NULL);
       ClearAndRedrawOutput ();
     }
   FreePointerListMemory (&Selected);
diff --git a/src/autoplace.h b/src/autoplace.h
index 66b1869..ffb15df 100644
--- a/src/autoplace.h
+++ b/src/autoplace.h
@@ -40,6 +40,6 @@
 
 #include "global.h"
 
-Boolean AutoPlaceSelected (void);
+bool AutoPlaceSelected (void);
 
 #endif
diff --git a/src/autoroute.c b/src/autoroute.c
index b9f1fdd..b6bf91d 100644
--- a/src/autoroute.c
+++ b/src/autoroute.c
@@ -333,16 +333,16 @@ static struct
   /* maximum conflict incidence before calling it "no path found" */
   int hi_conflict;
   /* are vias allowed? */
-  Boolean use_vias;
+  bool use_vias;
   /* is this an odd or even pass? */
-  Boolean is_odd;
+  bool is_odd;
   /* permit conflicts? */
-  Boolean with_conflicts;
+  bool with_conflicts;
   /* is this a final "smoothing" pass? */
-  Boolean is_smoothing;
+  bool is_smoothing;
   /* rip up nets regardless of conflicts? */
-  Boolean rip_always;
-  Boolean last_smooth;
+  bool rip_always;
+  bool last_smooth;
   unsigned char pass;
 }
 AutoRouteParameters;
@@ -362,7 +362,7 @@ struct routeone_state
  */
 static routebox_t *CreateExpansionArea (const BoxType * area, Cardinal group,
 					routebox_t * parent,
-					Boolean relax_edge_requirements,
+					bool relax_edge_requirements,
 					edge_t * edge);
 
 static cost_t edge_cost (const edge_t * e, const cost_t too_big);
@@ -376,7 +376,7 @@ static void add_or_destroy_edge (struct routeone_state *s, edge_t * e);
 static void
 RD_DrawThermal (routedata_t * rd, LocationType X, LocationType Y,
 		Cardinal group, Cardinal layer, routebox_t * subnet,
-		Boolean is_bad);
+		bool is_bad);
 static void ResetSubnet (routebox_t * net);
 #ifdef ROUTE_DEBUG
 static int showboxen = -2;
@@ -389,9 +389,9 @@ static void showroutebox (routebox_t * rb);
  */
 /* group number of groups that hold surface mount pads */
 static Cardinal front, back;
-static Boolean usedGroup[MAX_LAYER];
+static bool usedGroup[MAX_LAYER];
 static int x_cost[MAX_LAYER], y_cost[MAX_LAYER];
-static Boolean is_layer_group_active[MAX_LAYER];
+static bool is_layer_group_active[MAX_LAYER];
 static int ro = 0;
 static int smoothes = 1;
 static int passes = 12;
@@ -588,7 +588,7 @@ closest_point_in_routebox (const CheapPointType * from, const routebox_t * rb)
   return closest_point_in_box (from, &rb->sbox);
 }
 
-static inline Boolean
+static inline bool
 point_in_shrunk_box (const routebox_t * box, LocationType X, LocationType Y)
 {
   BoxType b = shrink_routebox (box);
@@ -600,7 +600,7 @@ point_in_shrunk_box (const routebox_t * box, LocationType X, LocationType Y)
  */
 
 static routebox_t *
-AddPin (PointerListType layergroupboxes[], PinTypePtr pin, Boolean is_via,
+AddPin (PointerListType layergroupboxes[], PinTypePtr pin, bool is_via,
 	RouteStyleType * style)
 {
   routebox_t **rbpp, *lastrb = NULL;
@@ -911,11 +911,11 @@ CreateRouteData ()
 	    PCB->Data->Layer[PCB->LayerGroups.Entries[group][i]].On)
 	  {
 	    routing_layers++;
-	    is_layer_group_active[group] = True;
+	    is_layer_group_active[group] = true;
 	    break;
 	  }
 	else
-	  is_layer_group_active[group] = False;
+	  is_layer_group_active[group] = false;
     }
   /* if via visibility is turned off, don't use them */
   AutoRouteParameters.use_vias = routing_layers > 1 && PCB->ViaOn;
@@ -970,23 +970,23 @@ CreateRouteData ()
       GROUP_LOOP (PCB->Data, i);
       {
 	if (layer->LineN || layer->ArcN)
-	  usedGroup[i] = True;
+	  usedGroup[i] = true;
 	else
-	  usedGroup[i] = False;
+	  usedGroup[i] = false;
       }
       END_LOOP;
     }
-  usedGroup[front] = True;
-  usedGroup[back] = True;
+  usedGroup[front] = true;
+  usedGroup[back] = true;
   /* add the objects in the netlist first.
    * then go and add all other objects that weren't already added
    *
    * this saves on searching the trees to find the nets
    */
   /* use the DRCFLAG to mark objects as they are entered */
-  ResetFoundPinsViasAndPads (False);
-  ResetFoundLinesAndPolygons (False);
-  Nets = CollectSubnets (False);
+  ResetFoundPinsViasAndPads (false);
+  ResetFoundLinesAndPolygons (false);
+  Nets = CollectSubnets (false);
   {
     routebox_t *last_net = NULL;
     NETLIST_LOOP (&Nets);
@@ -1064,12 +1064,12 @@ CreateRouteData ()
 		break;
 	      case PIN_TYPE:
 		rb =
-		  AddPin (layergroupboxes, connection->ptr2, False,
+		  AddPin (layergroupboxes, connection->ptr2, false,
 			  rd->styles[j]);
 		break;
 	      case VIA_TYPE:
 		rb =
-		  AddPin (layergroupboxes, connection->ptr2, True,
+		  AddPin (layergroupboxes, connection->ptr2, true,
 			  rd->styles[j]);
 		break;
 	      case POLYGON_TYPE:
@@ -1115,7 +1115,7 @@ CreateRouteData ()
     if (TEST_FLAG (DRCFLAG, pin))
       CLEAR_FLAG (DRCFLAG, pin);
     else
-      AddPin (layergroupboxes, pin, False, rd->styles[NUM_STYLES]);
+      AddPin (layergroupboxes, pin, false, rd->styles[NUM_STYLES]);
   }
   ENDALL_LOOP;
   ALLPAD_LOOP (PCB->Data);
@@ -1132,7 +1132,7 @@ CreateRouteData ()
     if (TEST_FLAG (DRCFLAG, via))
       CLEAR_FLAG (DRCFLAG, via);
     else
-      AddPin (layergroupboxes, via, True, rd->styles[NUM_STYLES]);
+      AddPin (layergroupboxes, via, true, rd->styles[NUM_STYLES]);
   }
   END_LOOP;
 
@@ -1338,14 +1338,14 @@ cost_to_layerless_box (const CheapPointType * p, Cardinal point_layer,
 }
 
 /* get to actual pins/pad target coordinates */
-Boolean
+bool
 TargetPoint (CheapPointType * nextpoint, const routebox_t * target)
 {
   if (target->type == PIN)
     {
       nextpoint->X = target->parent.pin->X;
       nextpoint->Y = target->parent.pin->Y;
-      return True;
+      return true;
     }
   else if (target->type == PAD)
     {
@@ -1359,14 +1359,14 @@ TargetPoint (CheapPointType * nextpoint, const routebox_t * target)
 	nextpoint->Y = target->parent.pad->Point1.Y;
       else
 	nextpoint->Y = target->parent.pad->Point2.Y;
-      return True;
+      return true;
     }
   else
     {
       nextpoint->X = CENTER_X (target->sbox);
       nextpoint->Y = CENTER_Y (target->sbox);
     }
-  return False;
+  return false;
 }
 
 /* return the *minimum cost* from a point to a route box, including possible
@@ -1563,7 +1563,7 @@ route_parent (routebox_t * rb)
 }
 
 static vector_t *
-path_conflicts (routebox_t * rb, routebox_t * conflictor, Boolean branch)
+path_conflicts (routebox_t * rb, routebox_t * conflictor, bool branch)
 {
   if (branch)
     rb->conflicts_with = vector_duplicate (rb->conflicts_with);
@@ -1793,7 +1793,7 @@ CreateViaEdge (const BoxType * area, Cardinal group,
   assert (AutoRouteParameters.with_conflicts ||
 	  (to_site_conflict == NO_CONFLICT &&
 	   through_site_conflict == NO_CONFLICT));
-  rb = CreateExpansionArea (area, group, parent, True, previous_edge);
+  rb = CreateExpansionArea (area, group, parent, true, previous_edge);
   rb->flags.is_via = 1;
   rb->came_from = ALL;
 #if defined(ROUTE_DEBUG) && defined(DEBUG_SHOW_VIA_BOXES)
@@ -1874,8 +1874,8 @@ CreateEdgeWithConflicts (const BoxType * interior_edge,
   /* use the caller's idea of what this box should be */
   rb =
     CreateExpansionArea (interior_edge, previous_edge->rb->group,
-			 previous_edge->rb, True, previous_edge);
-  path_conflicts (rb, container, True);	/* crucial! */
+			 previous_edge->rb, true, previous_edge);
+  path_conflicts (rb, container, true);	/* crucial! */
   costpoint =
     closest_point_in_box (&previous_edge->cost_point, interior_edge);
   d =
@@ -1956,7 +1956,7 @@ edge_to_box (const routebox_t * rb, direction_t expand_dir)
 struct broken_boxes
 {
   BoxType left, center, right;
-  Boolean is_valid_left, is_valid_center, is_valid_right;
+  bool is_valid_left, is_valid_center, is_valid_right;
 };
 
 static struct broken_boxes
@@ -2023,7 +2023,7 @@ edge_intersect (const BoxType * child, const BoxType * parent)
 static routebox_t *
 CreateExpansionArea (const BoxType * area, Cardinal group,
 		     routebox_t * parent,
-		     Boolean relax_edge_requirements, edge_t * src_edge)
+		     bool relax_edge_requirements, edge_t * src_edge)
 {
   routebox_t *rb = (routebox_t *) malloc (sizeof (*rb));
   memset ((void *) rb, 0, sizeof (*rb));
@@ -2192,7 +2192,7 @@ __Expand_this_rect (const BoxType * box, void *cl)
   return 1;
 }
 
-static Boolean
+static bool
 boink_box (routebox_t * rb, struct E_result *res, direction_t dir)
 {
   LocationType bloat;
@@ -2208,19 +2208,19 @@ boink_box (routebox_t * rb, struct E_result *res, direction_t dir)
     case SOUTH:
       if (rb->sbox.X2 <= res->inflated.X1 + bloat
 	  || rb->sbox.X1 >= res->inflated.X2 - bloat)
-	return False;
-      return True;
+	return false;
+      return true;
     case EAST:
     case WEST:
       if (rb->sbox.Y1 >= res->inflated.Y2 - bloat
 	  || rb->sbox.Y2 <= res->inflated.Y1 + bloat)
-	return False;
-      return True;
+	return false;
+      return true;
       break;
     default:
       assert (0);
     }
-  return False;
+  return false;
 }
 
 /* main Expand routine.
@@ -2590,7 +2590,7 @@ moveable_edge (vector_t * result, const BoxType * box, direction_t dir,
       vector_append (area_vec, nrb);
       nrb->flags.homeless = 0;	/* not homeless any more */
       /* mark this one as conflicted */
-      path_conflicts (nrb, blocker, True);
+      path_conflicts (nrb, blocker, true);
       /* and make an expansion edge */
       nrb->cost_point =
 	closest_point_in_box (&nrb->cost_point, &blocker->sbox);
@@ -2666,7 +2666,7 @@ struct break_info
   routebox_t *parent;
   BoxType box;
   direction_t dir;
-  Boolean ignore_source;
+  bool ignore_source;
 };
 
 static int
@@ -3163,7 +3163,7 @@ FindThermable (rtree_t * rtree, routebox_t * rb)
 static void
 RD_DrawThermal (routedata_t * rd, LocationType X, LocationType Y,
 		Cardinal group, Cardinal layer, routebox_t * subnet,
-		Boolean is_bad)
+		bool is_bad)
 {
   routebox_t *rb;
   rb = (routebox_t *) malloc (sizeof (*rb));
@@ -3187,7 +3187,7 @@ RD_DrawThermal (routedata_t * rd, LocationType X, LocationType Y,
 
 static void
 RD_DrawVia (routedata_t * rd, LocationType X, LocationType Y,
-	    BDimension radius, routebox_t * subnet, Boolean is_bad)
+	    BDimension radius, routebox_t * subnet, bool is_bad)
 {
   routebox_t *rb, *first_via = NULL;
   int i;
@@ -3208,7 +3208,7 @@ RD_DrawVia (routedata_t * rd, LocationType X, LocationType Y,
       rb->flags.is_odd = AutoRouteParameters.is_odd;
       rb->flags.is_bad = is_bad;
       rb->came_from = ALL;
-      rb->flags.circular = True;
+      rb->flags.circular = true;
       rb->style = AutoRouteParameters.style;
       rb->pass = AutoRouteParameters.pass;
       if (first_via == NULL)
@@ -3245,7 +3245,7 @@ static void
 RD_DrawLine (routedata_t * rd,
 	     LocationType X1, LocationType Y1, LocationType X2,
 	     LocationType Y2, BDimension halfthick, Cardinal group,
-	     routebox_t * subnet, Boolean is_bad, Boolean is_45)
+	     routebox_t * subnet, bool is_bad, bool is_45)
 {
   /* we hold the line in a queue to concatenate segments that
    * ajoin one another. That reduces the number of things in
@@ -3255,7 +3255,7 @@ RD_DrawLine (routedata_t * rd,
   static LocationType qX1 = -1, qY1, qX2, qY2;
   static BDimension qhthick;
   static Cardinal qgroup;
-  static Boolean qis_45, qis_bad;
+  static bool qis_45, qis_bad;
   static routebox_t *qsn;
 
   routebox_t *rb;
@@ -3339,7 +3339,7 @@ RD_DrawLine (routedata_t * rd,
   if (AutoRouteParameters.use_vias)
     mtspace_add (rd->mtspace, &rb->box, rb->flags.is_odd ? ODD : EVEN,
 		 rb->style->Keepaway);
-  usedGroup[rb->group] = True;
+  usedGroup[rb->group] = true;
   /* and queue this one */
   qX1 = X1;
   qY1 = Y1;
@@ -3352,25 +3352,25 @@ RD_DrawLine (routedata_t * rd,
   qsn = subnet;
 }
 
-static Boolean
+static bool
 RD_DrawManhattanLine (routedata_t * rd,
 		      const BoxType * box1, const BoxType * box2,
 		      CheapPointType start, CheapPointType end,
 		      BDimension halfthick, Cardinal group,
-		      routebox_t * subnet, Boolean is_bad, Boolean last_was_x)
+		      routebox_t * subnet, bool is_bad, bool last_was_x)
 {
   CheapPointType knee = start;
   if (end.X == start.X)
     {
       RD_DrawLine (rd, start.X, start.Y, end.X, end.Y, halfthick, group,
-		   subnet, is_bad, False);
-      return False;
+		   subnet, is_bad, false);
+      return false;
     }
   else if (end.Y == start.Y)
     {
       RD_DrawLine (rd, start.X, start.Y, end.X, end.Y, halfthick, group,
-		   subnet, is_bad, False);
-      return True;
+		   subnet, is_bad, false);
+      return true;
     }
   /* find where knee belongs */
   if (point_in_box (box1, end.X, start.Y)
@@ -3399,9 +3399,9 @@ RD_DrawManhattanLine (routedata_t * rd,
     {
       /* draw standard manhattan paths */
       RD_DrawLine (rd, start.X, start.Y, knee.X, knee.Y, halfthick, group,
-		   subnet, is_bad, False);
+		   subnet, is_bad, false);
       RD_DrawLine (rd, knee.X, knee.Y, end.X, end.Y, halfthick, group,
-		   subnet, is_bad, False);
+		   subnet, is_bad, false);
     }
   else
     {
@@ -3417,11 +3417,11 @@ RD_DrawManhattanLine (routedata_t * rd,
       else
 	kneeend.X += (kneeend.X > end.X) ? -len45 : len45;
       RD_DrawLine (rd, start.X, start.Y, kneestart.X, kneestart.Y, halfthick,
-		   group, subnet, is_bad, False);
+		   group, subnet, is_bad, false);
       RD_DrawLine (rd, kneestart.X, kneestart.Y, kneeend.X, kneeend.Y,
-		   halfthick, group, subnet, is_bad, True);
+		   halfthick, group, subnet, is_bad, true);
       RD_DrawLine (rd, kneeend.X, kneeend.Y, end.X, end.Y, halfthick, group,
-		   subnet, is_bad, False);
+		   subnet, is_bad, false);
     }
   return (knee.X != end.X);
 }
@@ -3478,9 +3478,9 @@ add_clearance (CheapPointType * nextpoint, const BoxType * b)
 
 static void
 TracePath (routedata_t * rd, routebox_t * path, const routebox_t * target,
-	   routebox_t * subnet, Boolean is_bad)
+	   routebox_t * subnet, bool is_bad)
 {
-  Boolean last_x = False;
+  bool last_x = false;
   BDimension halfwidth = HALF_THICK (AutoRouteParameters.style->Thick);
   BDimension radius = HALF_THICK (AutoRouteParameters.style->Diameter);
   CheapPointType lastpoint, nextpoint;
@@ -3648,7 +3648,7 @@ TracePath (routedata_t * rd, routebox_t * path, const routebox_t * target,
     }
   while (!path->flags.source);
   /* flush the line queue */
-  RD_DrawLine (rd, -1, 0, 0, 0, 0, 0, NULL, False, False);
+  RD_DrawLine (rd, -1, 0, 0, 0, 0, 0, NULL, false, false);
   if (TEST_FLAG (LIVEROUTEFLAG, PCB))
     gui->use_mask (HID_FLUSH_DRAW_Q);
 }
@@ -3657,7 +3657,7 @@ TracePath (routedata_t * rd, routebox_t * path, const routebox_t * target,
 static void
 CreateSearchEdge (struct routeone_state *s, vetting_t * work, edge_t * parent,
 		  routebox_t * rb, conflict_t conflict, rtree_t * targets,
-		  Boolean in_plane)
+		  bool in_plane)
 {
   routebox_t *target;
   BoxType b;
@@ -3749,7 +3749,7 @@ add_via_sites (struct routeone_state *s,
 	       struct routeone_via_site_state *vss,
 	       mtspace_t * mtspace, routebox_t * within,
 	       conflict_t within_conflict_level, edge_t * parent_edge,
-	       rtree_t * targets, BDimension shrink, Boolean in_plane)
+	       rtree_t * targets, BDimension shrink, bool in_plane)
 {
   int radius, keepaway;
   vetting_t *work;
@@ -3876,15 +3876,15 @@ show_area_vec (int lay)
   showboxen = save;
 }
 
-static Boolean
+static bool
 net_id (routebox_t * rb, long int id)
 {
   routebox_t *p;
   LIST_LOOP (rb, same_net, p);
   if (p->flags.source && p->parent.pad->ID == id)
-    return True;
+    return true;
   END_LOOP;
-  return False;
+  return false;
 }
 
 static void
@@ -3964,7 +3964,7 @@ __conflict_source (const BoxType * box, void *cl)
   else
     {
       routebox_t *this = (routebox_t *) cl;
-      path_conflicts (this, rb, False);
+      path_conflicts (this, rb, false);
       touch_conflicts (this->conflicts_with, 1);
     }
   return 1;
@@ -3981,10 +3981,10 @@ source_conflicts (rtree_t * tree, routebox_t * rb)
 
 struct routeone_status
 {
-  Boolean found_route;
+  bool found_route;
   int route_had_conflicts;
   cost_t best_route_cost;
-  Boolean net_completely_routed;
+  bool net_completely_routed;
 };
 
 
@@ -4065,14 +4065,14 @@ RouteOne (routedata_t * rd, routebox_t * from, routebox_t * to, int max_edges)
       LIST_LOOP (from, same_net, p);
       p->flags.source = p->flags.target = p->flags.nobloat = 0;
       END_LOOP;
-      result.found_route = False;
-      result.net_completely_routed = True;
+      result.found_route = false;
+      result.net_completely_routed = true;
       result.best_route_cost = 0;
       result.route_had_conflicts = 0;
 
       return result;
     }
-  result.net_completely_routed = False;
+  result.net_completely_routed = false;
 
   /* okay, there's stuff to route */
   assert (!from->flags.target);
@@ -4199,7 +4199,7 @@ RouteOne (routedata_t * rd, routebox_t * from, routebox_t * to, int max_edges)
 	      edge_t *ne;
 	      routebox_t *nrb;
 	      assert (pin->flags.target);
-	      nrb = CreateExpansionArea (&b, e->rb->group, e->rb, True, e);
+	      nrb = CreateExpansionArea (&b, e->rb->group, e->rb, true, e);
 	      nrb->flags.is_thermal = 1;
 	      /* moving through the plane is free */
 	      e->cost_point.X = b.X1;
@@ -4217,12 +4217,12 @@ RouteOne (routedata_t * rd, routebox_t * from, routebox_t * to, int max_edges)
 		  /* we need a giant thermal */
 		  routebox_t *nrb =
 		    CreateExpansionArea (&e->rb->sbox, e->rb->group, e->rb,
-					 True, e);
+					 true, e);
 		  edge_t *ne = CreateEdge2 (nrb, e->expand_dir, e, NULL,
 					    e->mincost_target);
 		  nrb->flags.is_thermal = 1;
 		  add_via_sites (&s, &vss, rd->mtspace, nrb, NO_CONFLICT, ne,
-				 targets, e->rb->style->Diameter, True);
+				 targets, e->rb->style->Diameter, true);
 		}
 	    }
 	  goto dontexpand;	/* planes only connect via thermals */
@@ -4250,7 +4250,7 @@ RouteOne (routedata_t * rd, routebox_t * from, routebox_t * to, int max_edges)
 	      BoxType b = shrink_routebox (e->rb);
 	      /* limit via region to that inside the plane */
 	      clip_box (&b, &intersecting->sbox);
-	      nrb = CreateExpansionArea (&b, e->rb->group, e->rb, True, e);
+	      nrb = CreateExpansionArea (&b, e->rb->group, e->rb, true, e);
 	      nrb->flags.is_thermal = 1;
 	      ne = CreateEdge2 (nrb, e->expand_dir, e, NULL, intersecting);
 	      best_path_candidate (&s, ne, intersecting);
@@ -4420,7 +4420,7 @@ RouteOne (routedata_t * rd, routebox_t * from, routebox_t * to, int max_edges)
 	  if (!box_is_good (&ans->inflated))
 	    goto dontexpand;
 	  nrb = CreateExpansionArea (&ans->inflated, e->rb->group, e->rb,
-				     True, e);
+				     true, e);
 	  r_insert_entry (rd->layergrouptree[nrb->group], &nrb->box, 1);
 	  vector_append (area_vec, nrb);
 	  nrb->flags.homeless = 0;	/* not homeless any more */
@@ -4439,7 +4439,7 @@ RouteOne (routedata_t * rd, routebox_t * from, routebox_t * to, int max_edges)
 	      e->cost + AutoRouteParameters.ViaCost < s.best_cost)
 	    add_via_sites (&s, &vss,
 			   rd->mtspace, nrb, NO_CONFLICT, e, targets, 0,
-			   False);
+			   false);
 	  goto dontexpand;
 	}
     dontexpand:
@@ -4458,7 +4458,7 @@ RouteOne (routedata_t * rd, routebox_t * from, routebox_t * to, int max_edges)
 #ifdef ROUTE_VERBOSE
       printf ("%d:%d RC %.0f", ro++, seen, s.best_cost);
 #endif
-      result.found_route = True;
+      result.found_route = true;
       result.best_route_cost = s.best_cost;
       /* determine if the best path had conflicts */
       result.route_had_conflicts = 0;
@@ -4487,7 +4487,7 @@ RouteOne (routedata_t * rd, routebox_t * from, routebox_t * to, int max_edges)
 #ifdef ROUTE_VERBOSE
 	  printf (" (too many in fact)");
 #endif
-	  result.found_route = False;
+	  result.found_route = false;
 	}
 #ifdef ROUTE_VERBOSE
       printf ("\n");
@@ -4499,7 +4499,7 @@ RouteOne (routedata_t * rd, routebox_t * from, routebox_t * to, int max_edges)
       printf ("%d:%d NO PATH FOUND.\n", ro++, seen);
 #endif
       result.best_route_cost = s.best_cost;
-      result.found_route = False;
+      result.found_route = false;
     }
   /* now remove all expansion areas from the r-tree. */
   while (!vector_is_empty (area_vec))
@@ -4529,8 +4529,8 @@ RouteOne (routedata_t * rd, routebox_t * from, routebox_t * to, int max_edges)
 static void
 InitAutoRouteParameters (int pass,
 			 RouteStyleType * style,
-			 Boolean with_conflicts, Boolean is_smoothing,
-			 Boolean lastpass)
+			 bool with_conflicts, bool is_smoothing,
+			 bool lastpass)
 {
   int i;
   /* routing style */
@@ -4579,7 +4579,7 @@ bad_boy (const BoxType * b, void *cl)
   return 0;
 }
 
-Boolean
+bool
 no_expansion_boxes (routedata_t * rd)
 {
   int i;
@@ -4591,9 +4591,9 @@ no_expansion_boxes (routedata_t * rd)
   for (i = 0; i < max_layer; i++)
     {
       if (r_search (rd->layergrouptree[i], &big, NULL, bad_boy, NULL))
-	return False;
+	return false;
     }
-  return True;
+  return true;
 }
 #endif
 
@@ -4616,7 +4616,7 @@ RouteAll (routedata_t * rd)
 {
   struct routeall_status ras;
   struct routeone_status ros;
-  Boolean rip;
+  bool rip;
 #ifdef NET_HEAP
   heap_t *net_heap;
 #endif
@@ -4678,14 +4678,14 @@ RouteAll (routedata_t * rd)
 	    {
 	      /* rip up all unfixed traces in this net ? */
 	      if (AutoRouteParameters.rip_always)
-		rip = True;
+		rip = true;
 	      else
 		{
-		  rip = False;
+		  rip = false;
 		  LIST_LOOP (net, same_net, p);
 		  if (p->flags.is_bad)
 		    {
-		      rip = True;
+		      rip = true;
 		      break;
 		    }
 		  END_LOOP;
@@ -4695,7 +4695,7 @@ RouteAll (routedata_t * rd)
 	      p->flags.is_bad = 0;
 	      if (!p->flags.fixed)
 		{
-		  Boolean del;
+		  bool del;
 		  assert (!p->flags.homeless);
 		  if (rip)
 		    {
@@ -4936,11 +4936,11 @@ FindPin (const BoxType * box, PinTypePtr * pin)
 
 
 /* paths go on first 'on' layer in group */
-/* returns 'True' if any paths were added. */
-Boolean
+/* returns 'true' if any paths were added. */
+bool
 IronDownAllUnfixedPaths (routedata_t * rd)
 {
-  Boolean changed = False;
+  bool changed = false;
   LayerTypePtr layer;
   routebox_t *net, *p;
   int i;
@@ -4999,7 +4999,7 @@ IronDownAllUnfixedPaths (routedata_t * rd)
 		{
 		  AddObjectToCreateUndoList (LINE_TYPE, layer,
 					     p->parent.line, p->parent.line);
-		  changed = True;
+		  changed = true;
 		}
 	    }
 	  else if (p->type == VIA || p->type == VIA_SHADOW)
@@ -5028,7 +5028,7 @@ IronDownAllUnfixedPaths (routedata_t * rd)
 						 pp->parent.via,
 						 pp->parent.via,
 						 pp->parent.via);
-		      changed = True;
+		      changed = true;
 		    }
 		}
 	      assert (pp->parent.via);
@@ -5057,7 +5057,7 @@ IronDownAllUnfixedPaths (routedata_t * rd)
 	    {
 	      AddObjectToClearPolyUndoList (type,
 					    pin->Element ? pin->Element : pin,
-					    pin, pin, False);
+					    pin, pin, false);
 	      RestoreToPolygon (PCB->Data, VIA_TYPE, LAYER_PTR (p->layer),
 				pin);
 	      AddObjectToFlagUndoList (type,
@@ -5066,10 +5066,10 @@ IronDownAllUnfixedPaths (routedata_t * rd)
 	      ASSIGN_THERM (p->layer, PCB->ThermStyle, pin);
 	      AddObjectToClearPolyUndoList (type,
 					    pin->Element ? pin->Element : pin,
-					    pin, pin, True);
+					    pin, pin, true);
 	      ClearFromPolygon (PCB->Data, VIA_TYPE, LAYER_PTR (p->layer),
 				pin);
-	      changed = True;
+	      changed = true;
 	    }
 	}
     }
@@ -5079,10 +5079,10 @@ IronDownAllUnfixedPaths (routedata_t * rd)
   return changed;
 }
 
-Boolean
-AutoRoute (Boolean selected)
+bool
+AutoRoute (bool selected)
 {
-  Boolean changed = False;
+  bool changed = false;
   routedata_t *rd;
   int i;
 
@@ -5107,11 +5107,11 @@ AutoRoute (Boolean selected)
 	{
 	  Message ("You must define proper routing styles\n"
 		   "before auto-routing.\n");
-	  return (False);
+	  return (false);
 	}
     }
   if (PCB->Data->RatN == 0)
-    return (False);
+    return (false);
   SaveFindFlag (DRCFLAG);
   rd = CreateRouteData ();
 
@@ -5157,7 +5157,7 @@ AutoRoute (Boolean selected)
 	        }
 */
 	      /* route exactly one net, without allowing conflicts */
-	      InitAutoRouteParameters (0, a->style, False, True, True);
+	      InitAutoRouteParameters (0, a->style, false, true, true);
 	      /* hace planes work better as sources than targets */
 	      changed = RouteOne (rd, a, b, 150000).found_route || changed;
 	      goto donerouting;
@@ -5213,7 +5213,7 @@ AutoRoute (Boolean selected)
 	    {
 #ifdef DEBUG_STALE_RATS
 	      AddObjectToFlagUndoList (RATLINE_TYPE, line, line, line);
-	      ASSIGN_FLAG (SELECTEDFLAG, True, line);
+	      ASSIGN_FLAG (SELECTEDFLAG, true, line);
 	      DrawRat (line, 0);
 #endif /* DEBUG_STALE_RATS */
 	      Message ("The rats nest is stale! Aborting autoroute...\n");
@@ -5266,9 +5266,9 @@ donerouting:
       SaveUndoSerialNumber ();
 
       /* optimize rats, we've changed connectivity a lot. */
-      DeleteRats (False /*all rats */ );
+      DeleteRats (false /*all rats */ );
       RestoreUndoSerialNumber ();
-      AddAllRats (False /*all rats */ , NULL);
+      AddAllRats (false /*all rats */ , NULL);
       RestoreUndoSerialNumber ();
 
       IncrementUndoSerialNumber ();
diff --git a/src/autoroute.h b/src/autoroute.h
index 960043d..59f75ad 100644
--- a/src/autoroute.h
+++ b/src/autoroute.h
@@ -39,6 +39,6 @@
 
 #include "global.h"
 
-Boolean AutoRoute (Boolean);
+bool AutoRoute (bool);
 
 #endif
diff --git a/src/box.h b/src/box.h
index 291c6d7..bedb6ab 100644
--- a/src/box.h
+++ b/src/box.h
@@ -95,25 +95,25 @@ typedef struct cheap_point
 /* note that boxes are closed on top and left and open on bottom and right. */
 /* this means that top-left corner is in box, *but bottom-right corner is
  * not*.  */
-static inline Boolean
+static inline bool
 point_in_box (const BoxType * box, LocationType X, LocationType Y)
 {
   return (X >= box->X1) && (Y >= box->Y1) && (X < box->X2) && (Y < box->Y2);
 }
 
-static inline Boolean
+static inline bool
 point_in_closed_box (const BoxType * box, LocationType X, LocationType Y)
 {
   return (X >= box->X1) && (Y >= box->Y1) && (X <= box->X2) && (Y <= box->Y2);
 }
 
-static inline Boolean
+static inline bool
 box_is_good (const BoxType * b)
 {
   return (b->X1 < b->X2) && (b->Y1 < b->Y2);
 }
 
-static inline Boolean
+static inline bool
 box_intersect (const BoxType * a, const BoxType * b)
 {
   return
@@ -135,7 +135,7 @@ closest_point_in_box (const CheapPointType * from, const BoxType * box)
   return r;
 }
 
-static inline Boolean
+static inline bool
 box_in_box (const BoxType * outer, const BoxType * inner)
 {
   return
diff --git a/src/buffer.c b/src/buffer.c
index fbd1735..e04ae2a 100644
--- a/src/buffer.c
+++ b/src/buffer.c
@@ -209,7 +209,7 @@ AddElementToBuffer (ElementTypePtr Element)
   ElementTypePtr element;
 
   element = GetElementMemory (Dest);
-  CopyElementLowLevel (Dest, element, Element, False, 0, 0);
+  CopyElementLowLevel (Dest, element, Element, false, 0, 0);
   CLEAR_FLAG (ExtraFlag, element);
   if (ExtraFlag)
     {
@@ -515,21 +515,21 @@ ClearBuffer (BufferTypePtr Buffer)
 
 /* ----------------------------------------------------------------------
  * copies all selected and visible objects to the paste buffer
- * returns True if any objects have been removed
+ * returns true if any objects have been removed
  */
 void
 AddSelectedToBuffer (BufferTypePtr Buffer, LocationType X, LocationType Y,
-		     Boolean LeaveSelected)
+		     bool LeaveSelected)
 {
   /* switch crosshair off because adding objects to the pastebuffer
    * may change the 'valid' area for the cursor
    */
   if (!LeaveSelected)
     ExtraFlag = SELECTEDFLAG;
-  HideCrosshair (True);
+  HideCrosshair (true);
   Source = PCB->Data;
   Dest = Buffer->Data;
-  SelectedOperation (&AddBufferFunctions, False, ALL_TYPES);
+  SelectedOperation (&AddBufferFunctions, false, ALL_TYPES);
 
   /* set origin to passed or current position */
   if (X || Y)
@@ -542,18 +542,18 @@ AddSelectedToBuffer (BufferTypePtr Buffer, LocationType X, LocationType Y,
       Buffer->X = Crosshair.X;
       Buffer->Y = Crosshair.Y;
     }
-  RestoreCrosshair (True);
+  RestoreCrosshair (true);
   ExtraFlag = 0;
 }
 
 /* ---------------------------------------------------------------------------
  * loads element data from file/library into buffer
  * parse the file with disabled 'PCB mode' (see parser)
- * returns False on error
+ * returns false on error
  * if successful, update some other stuff and reposition the pastebuffer
  */
-Boolean
-LoadElementToBuffer (BufferTypePtr Buffer, char *Name, Boolean FromFile)
+bool
+LoadElementToBuffer (BufferTypePtr Buffer, char *Name, bool FromFile)
 {
   ElementTypePtr element;
 
@@ -576,7 +576,7 @@ LoadElementToBuffer (BufferTypePtr Buffer, char *Name, Boolean FromFile)
 	      Buffer->X = 0;
 	      Buffer->Y = 0;
 	    }
-	  return (True);
+	  return (true);
 	}
     }
   else
@@ -595,12 +595,12 @@ LoadElementToBuffer (BufferTypePtr Buffer, char *Name, Boolean FromFile)
 	  Buffer->X = element->MarkX;
 	  Buffer->Y = element->MarkY;
 	  SetBufferBoundingBox (Buffer);
-	  return (True);
+	  return (true);
 	}
     }
   /* release memory which might have been acquired */
   ClearBuffer (Buffer);
-  return (False);
+  return (false);
 }
 
 
@@ -811,7 +811,7 @@ LoadFootprintByName (BufferTypePtr Buffer, char *Footprint)
 
   if (entry->Template == (char *) -1)
     {
-      i = LoadElementToBuffer (Buffer, entry->AllocatedMemory, True);
+      i = LoadElementToBuffer (Buffer, entry->AllocatedMemory, true);
       if (with_fp)
 	free (with_fp);
       return i ? 0 : 1;
@@ -822,7 +822,7 @@ LoadFootprintByName (BufferTypePtr Buffer, char *Footprint)
 
       args = Concat("'", EMPTY (entry->Template), "' '",
 		    EMPTY (entry->Value), "' '", EMPTY (entry->Package), "'", NULL);
-      i = LoadElementToBuffer (Buffer, args, False);
+      i = LoadElementToBuffer (Buffer, args, false);
 
       free (args);
       if (with_fp)
@@ -921,7 +921,7 @@ LoadFootprint (int argc, char **argv, int x, int y)
  *
  * break buffer element into pieces
  */
-Boolean
+bool
 SmashBufferElement (BufferTypePtr Buffer)
 {
   ElementTypePtr element;
@@ -931,7 +931,7 @@ SmashBufferElement (BufferTypePtr Buffer)
   if (Buffer->Data->ElementN != 1)
     {
       Message (_("Error!  Buffer doesn't contain a single element\n"));
-      return (False);
+      return (false);
     }
   element = &Buffer->Data->Element[0];
   Buffer->Data->ElementN = 0;
@@ -988,7 +988,7 @@ SmashBufferElement (BufferTypePtr Buffer)
   END_LOOP;
   FreeElementMemory (element);
   SaveFree (element);
-  return (True);
+  return (true);
 }
 
 /*---------------------------------------------------------------------------
@@ -1032,13 +1032,13 @@ polygon_is_rectangle (PolygonTypePtr poly)
  *
  * convert buffer contents into an element
  */
-Boolean
+bool
 ConvertBufferToElement (BufferTypePtr Buffer)
 {
   ElementTypePtr Element;
   Cardinal group;
   Cardinal pin_n = 1;
-  Boolean hasParts = False, crooked = False;
+  bool hasParts = false, crooked = false;
 
   if (Buffer->Data->pcb == 0)
     Buffer->Data->pcb = PCB;
@@ -1047,9 +1047,9 @@ ConvertBufferToElement (BufferTypePtr Buffer)
 			      NULL, NULL, NULL, PASTEBUFFER->X,
 			      PASTEBUFFER->Y, 0, 100,
 			      MakeFlags (SWAP_IDENT ? ONSOLDERFLAG : NOFLAG),
-			      False);
+			      false);
   if (!Element)
-    return (False);
+    return (false);
   VIA_LOOP (Buffer->Data);
   {
     char num[8];
@@ -1070,7 +1070,7 @@ ConvertBufferToElement (BufferTypePtr Buffer)
 					    VIAFLAG | FOUNDFLAG | SELECTEDFLAG
 					    | WARNFLAG));
       }
-    hasParts = True;
+    hasParts = true;
   }
   END_LOOP;
   /* get the component-side SM pads */
@@ -1090,7 +1090,7 @@ ConvertBufferToElement (BufferTypePtr Buffer)
 		    line->Thickness + line->Clearance, NULL,
 		    line->Number ? line->Number : num,
 		    MakeFlags (SWAP_IDENT ? ONSOLDERFLAG : NOFLAG));
-      hasParts = True;
+      hasParts = true;
     }
     END_LOOP;
     POLYGON_LOOP (layer);
@@ -1099,7 +1099,7 @@ ConvertBufferToElement (BufferTypePtr Buffer)
 
       if (! polygon_is_rectangle (polygon))
         {
-          crooked = True;
+          crooked = true;
 	  continue;
         }
 
@@ -1118,7 +1118,7 @@ ConvertBufferToElement (BufferTypePtr Buffer)
 		    t + Settings.Keepaway,
 		    NULL, num,
 		    MakeFlags (SQUAREFLAG | (SWAP_IDENT ? ONSOLDERFLAG : NOFLAG)));
-      hasParts = True;
+      hasParts = true;
     }
     END_LOOP;
   }
@@ -1129,7 +1129,7 @@ ConvertBufferToElement (BufferTypePtr Buffer)
 					SOLDER_LAYER));
   GROUP_LOOP (Buffer->Data, group);
   {
-    Boolean warned = False;
+    bool warned = false;
     char num[8];
     LINE_LOOP (layer);
     {
@@ -1143,13 +1143,13 @@ ConvertBufferToElement (BufferTypePtr Buffer)
 		    MakeFlags (SWAP_IDENT ? NOFLAG : ONSOLDERFLAG));
       if (!hasParts && !warned)
 	{
-	  warned = True;
+	  warned = true;
 	  Message
 	    (_("Warning: All of the pads are on the opposite\n"
 	       "side from the component - that's probably not what\n"
 	       "you wanted\n"));
 	}
-      hasParts = True;
+      hasParts = true;
     }
     END_LOOP;
   }
@@ -1163,7 +1163,7 @@ ConvertBufferToElement (BufferTypePtr Buffer)
     CreateNewLineInElement (Element, line->Point1.X,
 			    line->Point1.Y, line->Point2.X,
 			    line->Point2.Y, line->Thickness);
-    hasParts = True;
+    hasParts = true;
   }
   END_LOOP;
   ARC_LOOP (&Buffer->Data->SILKLAYER);
@@ -1171,7 +1171,7 @@ ConvertBufferToElement (BufferTypePtr Buffer)
     CreateNewArcInElement (Element, arc->X, arc->Y, arc->Width,
 			   arc->Height, arc->StartAngle, arc->Delta,
 			   arc->Thickness);
-    hasParts = True;
+    hasParts = true;
   }
   END_LOOP;
   if (!hasParts)
@@ -1179,7 +1179,7 @@ ConvertBufferToElement (BufferTypePtr Buffer)
       DestroyObject (PCB->Data, ELEMENT_TYPE, Element, Element, Element);
       Message (_("There was nothing to convert!\n"
 		 "Elements must have some silk, pads or pins.\n"));
-      return (False);
+      return (false);
     }
   if (crooked)
      Message (_("There were polygons that can't be made into pins!\n"
@@ -1193,7 +1193,7 @@ ConvertBufferToElement (BufferTypePtr Buffer)
   MoveObjectToBuffer (Buffer->Data, PCB->Data, ELEMENT_TYPE, Element, Element,
 		      Element);
   SetBufferBoundingBox (Buffer);
-  return (True);
+  return (true);
 }
 
 /* ---------------------------------------------------------------------------
@@ -1201,10 +1201,10 @@ ConvertBufferToElement (BufferTypePtr Buffer)
  * parse the file with enabled 'PCB mode' (see parser)
  * if successful, update some other stuff
  */
-Boolean
+bool
 LoadLayoutToBuffer (BufferTypePtr Buffer, char *Filename)
 {
-  PCBTypePtr newPCB = CreateNewPCB (False);
+  PCBTypePtr newPCB = CreateNewPCB (false);
 
   /* new data isn't added to the undo list */
   if (!ParsePCB (newPCB, Filename))
@@ -1218,13 +1218,13 @@ LoadLayoutToBuffer (BufferTypePtr Buffer, char *Filename)
       Buffer->Y = newPCB->CursorY;
       RemovePCB (newPCB);
       Buffer->Data->pcb = PCB;
-      return (True);
+      return (true);
     }
 
   /* release unused memory */
   RemovePCB (newPCB);
       Buffer->Data->pcb = PCB;
-  return (False);
+  return (false);
 }
 
 /* ---------------------------------------------------------------------------
@@ -1440,9 +1440,9 @@ Rotates the contents of the pastebuffer by an arbitrary angle.
 int
 ActionFreeRotateBuffer(int argc, char **argv, int x, int y)
 {
-  HideCrosshair(False);
+  HideCrosshair(false);
   FreeRotateBuffer(PASTEBUFFER, strtod(argv[0], 0));
-  RestoreCrosshair(False);
+  RestoreCrosshair(false);
   return 0;
 }
 
diff --git a/src/buffer.h b/src/buffer.h
index 07c21c1..98da959 100644
--- a/src/buffer.h
+++ b/src/buffer.h
@@ -38,11 +38,11 @@
  */
 void SetBufferBoundingBox (BufferTypePtr);
 void ClearBuffer (BufferTypePtr);
-void AddSelectedToBuffer (BufferTypePtr, LocationType, LocationType, Boolean);
-Boolean LoadElementToBuffer (BufferTypePtr, char *, Boolean);
-Boolean ConvertBufferToElement (BufferTypePtr);
-Boolean SmashBufferElement (BufferTypePtr);
-Boolean LoadLayoutToBuffer (BufferTypePtr, char *);
+void AddSelectedToBuffer (BufferTypePtr, LocationType, LocationType, bool);
+bool LoadElementToBuffer (BufferTypePtr, char *, bool);
+bool ConvertBufferToElement (BufferTypePtr);
+bool SmashBufferElement (BufferTypePtr);
+bool LoadLayoutToBuffer (BufferTypePtr, char *);
 void RotateBuffer (BufferTypePtr, BYTE);
 void SelectPasteBuffer (int);
 void SwapBuffers (void);
diff --git a/src/change.c b/src/change.c
index 2fedc52..5546f1f 100644
--- a/src/change.c
+++ b/src/change.c
@@ -353,14 +353,14 @@ static ObjectFunctionType ClrOctagonFunctions = {
 static void *
 ChangeViaThermal (PinTypePtr Via)
 {
-  AddObjectToClearPolyUndoList (VIA_TYPE, Via, Via, Via, False);
+  AddObjectToClearPolyUndoList (VIA_TYPE, Via, Via, Via, false);
   RestoreToPolygon (PCB->Data, VIA_TYPE, CURRENT, Via);
   AddObjectToFlagUndoList (VIA_TYPE, Via, Via, Via);
   if (!Delta)			/* remove the thermals */
     CLEAR_THERM (INDEXOFCURRENT, Via);
   else
     ASSIGN_THERM (INDEXOFCURRENT, Delta, Via);
-  AddObjectToClearPolyUndoList (VIA_TYPE, Via, Via, Via, True);
+  AddObjectToClearPolyUndoList (VIA_TYPE, Via, Via, Via, true);
   ClearFromPolygon (PCB->Data, VIA_TYPE, CURRENT, Via);
   DrawVia (Via, 0);
   return Via;
@@ -373,14 +373,14 @@ ChangeViaThermal (PinTypePtr Via)
 static void *
 ChangePinThermal (ElementTypePtr element, PinTypePtr Pin)
 {
-  AddObjectToClearPolyUndoList (PIN_TYPE, element, Pin, Pin, False);
+  AddObjectToClearPolyUndoList (PIN_TYPE, element, Pin, Pin, false);
   RestoreToPolygon (PCB->Data, VIA_TYPE, CURRENT, Pin);
   AddObjectToFlagUndoList (PIN_TYPE, element, Pin, Pin);
   if (!Delta)			/* remove the thermals */
     CLEAR_THERM (INDEXOFCURRENT, Pin);
   else
     ASSIGN_THERM (INDEXOFCURRENT, Delta, Pin);
-  AddObjectToClearPolyUndoList (PIN_TYPE, element, Pin, Pin, True);
+  AddObjectToClearPolyUndoList (PIN_TYPE, element, Pin, Pin, true);
   ClearFromPolygon (PCB->Data, VIA_TYPE, CURRENT, Pin);
   DrawPin (Pin, 0);
   return Pin;
@@ -611,7 +611,7 @@ ChangePadClearSize (ElementTypePtr Element, PadTypePtr Pad)
 static void *
 ChangeElement2ndSize (ElementTypePtr Element)
 {
-  Boolean changed = False;
+  bool changed = false;
   BDimension value;
 
   if (TEST_FLAG (LOCKFLAG, Element))
@@ -626,7 +626,7 @@ ChangeElement2ndSize (ElementTypePtr Element)
 				      MIN_PINORVIACOPPER)
 	&& value != pin->DrillingHole)
       {
-	changed = True;
+	changed = true;
 	AddObjectTo2ndSizeUndoList (PIN_TYPE, Element, pin, pin);
 	ErasePin (pin);
 	pin->DrillingHole = value;
@@ -858,7 +858,7 @@ static void *
 ChangeElementSize (ElementTypePtr Element)
 {
   BDimension value;
-  Boolean changed = False;
+  bool changed = false;
 
   if (TEST_FLAG (LOCKFLAG, Element))
     return (NULL);
@@ -872,7 +872,7 @@ ChangeElementSize (ElementTypePtr Element)
       {
 	AddObjectToSizeUndoList (ELEMENTLINE_TYPE, Element, line, line);
 	line->Thickness = value;
-	changed = True;
+	changed = true;
       }
   }
   END_LOOP;
@@ -884,7 +884,7 @@ ChangeElementSize (ElementTypePtr Element)
       {
 	AddObjectToSizeUndoList (ELEMENTARC_TYPE, Element, arc, arc);
 	arc->Thickness = value;
-	changed = True;
+	changed = true;
       }
   }
   END_LOOP;
@@ -1055,7 +1055,7 @@ ChangeElementName (ElementTypePtr Element)
  * sets data of a text object and calculates bounding box
  * memory must have already been allocated
  * the one for the new string is allocated
- * returns True if the string has been changed
+ * returns true if the string has been changed
  */
 static void *
 ChangeTextName (LayerTypePtr Layer, TextTypePtr Text)
@@ -1078,39 +1078,39 @@ ChangeTextName (LayerTypePtr Layer, TextTypePtr Text)
 /* ---------------------------------------------------------------------------
  * changes the name of a layout; memory has to be already allocated
  */
-Boolean
+bool
 ChangeLayoutName (char *Name)
 {
   PCB->Name = Name;
   hid_action ("PCBChanged");
-  return (True);
+  return (true);
 }
 
 /* ---------------------------------------------------------------------------
  * changes the side of the board an element is on
  * returns TRUE if done
  */
-Boolean
+bool
 ChangeElementSide (ElementTypePtr Element, LocationType yoff)
 {
   if (TEST_FLAG (LOCKFLAG, Element))
-    return (False);
+    return (false);
   EraseElement (Element);
   AddObjectToMirrorUndoList (ELEMENT_TYPE, Element, Element, Element, yoff);
   MirrorElementCoordinates (PCB->Data, Element, yoff);
   DrawElement (Element, 0);
-  return (True);
+  return (true);
 }
 
 /* ---------------------------------------------------------------------------
  * changes the name of a layer; memory has to be already allocated
  */
-Boolean
+bool
 ChangeLayerName (LayerTypePtr Layer, char *Name)
 {
   CURRENT->Name = Name;
   hid_action ("LayersChanged");
-  return (True);
+  return (true);
 }
 
 /* ---------------------------------------------------------------------------
@@ -1124,14 +1124,14 @@ ChangeLineJoin (LayerTypePtr Layer, LineTypePtr Line)
   EraseLine (Line);
   if (TEST_FLAG(CLEARLINEFLAG, Line))
   {
-  AddObjectToClearPolyUndoList (LINE_TYPE, Layer, Line, Line, False);
+  AddObjectToClearPolyUndoList (LINE_TYPE, Layer, Line, Line, false);
   RestoreToPolygon (PCB->Data, LINE_TYPE, Layer, Line);
   }
   AddObjectToFlagUndoList (LINE_TYPE, Layer, Line, Line);
   TOGGLE_FLAG (CLEARLINEFLAG, Line);
   if (TEST_FLAG(CLEARLINEFLAG, Line))
   {
-  AddObjectToClearPolyUndoList (LINE_TYPE, Layer, Line, Line, True);
+  AddObjectToClearPolyUndoList (LINE_TYPE, Layer, Line, Line, true);
   ClearFromPolygon (PCB->Data, LINE_TYPE, Layer, Line);
   }
   DrawLine (Layer, Line, 0);
@@ -1172,14 +1172,14 @@ ChangeArcJoin (LayerTypePtr Layer, ArcTypePtr Arc)
   if (TEST_FLAG (CLEARLINEFLAG, Arc))
   {
     RestoreToPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
-    AddObjectToClearPolyUndoList (ARC_TYPE, Layer, Arc, Arc, False);
+    AddObjectToClearPolyUndoList (ARC_TYPE, Layer, Arc, Arc, false);
     }
   AddObjectToFlagUndoList (ARC_TYPE, Layer, Arc, Arc);
   TOGGLE_FLAG (CLEARLINEFLAG, Arc);
   if (TEST_FLAG (CLEARLINEFLAG, Arc))
   {
     ClearFromPolygon (PCB->Data, ARC_TYPE, Layer, Arc);
-  AddObjectToClearPolyUndoList (ARC_TYPE, Layer, Arc, Arc, True);
+  AddObjectToClearPolyUndoList (ARC_TYPE, Layer, Arc, Arc, true);
   }
   DrawArc (Layer, Arc, 0);
   return (Arc);
@@ -1218,14 +1218,14 @@ ChangeTextJoin (LayerTypePtr Layer, TextTypePtr Text)
   EraseText (Layer, Text);
   if (TEST_FLAG(CLEARLINEFLAG, Text))
   {
-  AddObjectToClearPolyUndoList (TEXT_TYPE, Layer, Text, Text, False);
+  AddObjectToClearPolyUndoList (TEXT_TYPE, Layer, Text, Text, false);
   RestoreToPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
   }
   AddObjectToFlagUndoList (LINE_TYPE, Layer, Text, Text);
   TOGGLE_FLAG (CLEARLINEFLAG, Text);
   if (TEST_FLAG(CLEARLINEFLAG, Text))
   {
-  AddObjectToClearPolyUndoList (TEXT_TYPE, Layer, Text, Text, True);
+  AddObjectToClearPolyUndoList (TEXT_TYPE, Layer, Text, Text, true);
   ClearFromPolygon (PCB->Data, TEXT_TYPE, Layer, Text);
   }
   DrawText (Layer, Text, 0);
@@ -1389,11 +1389,11 @@ ChangePadSquare (ElementTypePtr Element, PadTypePtr Pad)
   if (TEST_FLAG (LOCKFLAG, Pad))
     return (NULL);
   ErasePad (Pad);
-  AddObjectToClearPolyUndoList (PAD_TYPE, Element, Pad, Pad, False);
+  AddObjectToClearPolyUndoList (PAD_TYPE, Element, Pad, Pad, false);
   RestoreToPolygon (PCB->Data, PAD_TYPE, Element, Pad);
   AddObjectToFlagUndoList (PAD_TYPE, Element, Pad, Pad);
   TOGGLE_FLAG (SQUAREFLAG, Pad);
-  AddObjectToClearPolyUndoList (PAD_TYPE, Element, Pad, Pad, True);
+  AddObjectToClearPolyUndoList (PAD_TYPE, Element, Pad, Pad, true);
   ClearFromPolygon (PCB->Data, PAD_TYPE, Element, Pad);
   DrawPad (Pad, 0);
   return (Pad);
@@ -1436,11 +1436,11 @@ ChangePinSquare (ElementTypePtr Element, PinTypePtr Pin)
   if (TEST_FLAG (LOCKFLAG, Pin))
     return (NULL);
   ErasePin (Pin);
-  AddObjectToClearPolyUndoList (PIN_TYPE, Element, Pin, Pin, False);
+  AddObjectToClearPolyUndoList (PIN_TYPE, Element, Pin, Pin, false);
   RestoreToPolygon (PCB->Data, PIN_TYPE, Element, Pin);
   AddObjectToFlagUndoList (PIN_TYPE, Element, Pin, Pin);
   TOGGLE_FLAG (SQUAREFLAG, Pin);
-  AddObjectToClearPolyUndoList (PIN_TYPE, Element, Pin, Pin, True);
+  AddObjectToClearPolyUndoList (PIN_TYPE, Element, Pin, Pin, true);
   ClearFromPolygon (PCB->Data, PIN_TYPE, Element, Pin);
   DrawPin (Pin, 0);
   return (Pin);
@@ -1479,11 +1479,11 @@ ChangeViaOctagon (PinTypePtr Via)
   if (TEST_FLAG (LOCKFLAG, Via))
     return (NULL);
   EraseVia (Via);
-  AddObjectToClearPolyUndoList (VIA_TYPE, Via, Via, Via, False);
+  AddObjectToClearPolyUndoList (VIA_TYPE, Via, Via, Via, false);
   RestoreToPolygon (PCB->Data, VIA_TYPE, Via, Via);
   AddObjectToFlagUndoList (VIA_TYPE, Via, Via, Via);
   TOGGLE_FLAG (OCTAGONFLAG, Via);
-  AddObjectToClearPolyUndoList (VIA_TYPE, Via, Via, Via, True);
+  AddObjectToClearPolyUndoList (VIA_TYPE, Via, Via, Via, true);
   ClearFromPolygon (PCB->Data, VIA_TYPE, Via, Via);
   DrawVia (Via, 0);
   return (Via);
@@ -1522,11 +1522,11 @@ ChangePinOctagon (ElementTypePtr Element, PinTypePtr Pin)
   if (TEST_FLAG (LOCKFLAG, Pin))
     return (NULL);
   ErasePin (Pin);
-  AddObjectToClearPolyUndoList (PIN_TYPE, Element, Pin, Pin, False);
+  AddObjectToClearPolyUndoList (PIN_TYPE, Element, Pin, Pin, false);
   RestoreToPolygon (PCB->Data, PIN_TYPE, Element, Pin);
   AddObjectToFlagUndoList (PIN_TYPE, Element, Pin, Pin);
   TOGGLE_FLAG (OCTAGONFLAG, Pin);
-  AddObjectToClearPolyUndoList (PIN_TYPE, Element, Pin, Pin, True);
+  AddObjectToClearPolyUndoList (PIN_TYPE, Element, Pin, Pin, true);
   ClearFromPolygon (PCB->Data, PIN_TYPE, Element, Pin);
   DrawPin (Pin, 0);
   return (Pin);
@@ -1559,11 +1559,11 @@ ClrPinOctagon (ElementTypePtr Element, PinTypePtr Pin)
 /* ---------------------------------------------------------------------------
  * changes the hole flag of a via
  */
-Boolean
+bool
 ChangeHole (PinTypePtr Via)
 {
   if (TEST_FLAG (LOCKFLAG, Via))
-    return (False);
+    return (false);
   EraseVia (Via);
   AddObjectToFlagUndoList (VIA_TYPE, Via, Via, Via);
   TOGGLE_FLAG (HOLEFLAG, Via);
@@ -1581,23 +1581,23 @@ ChangeHole (PinTypePtr Via)
     }
   DrawVia (Via, 0);
   Draw ();
-  return (True);
+  return (true);
 }
 
 /* ---------------------------------------------------------------------------
  * changes the nopaste flag of a pad
  */
-Boolean
+bool
 ChangePaste (PadTypePtr Pad)
 {
   if (TEST_FLAG (LOCKFLAG, Pad))
-    return (False);
+    return (false);
   ErasePad (Pad);
   AddObjectToFlagUndoList (PAD_TYPE, Pad, Pad, Pad);
   TOGGLE_FLAG (NOPASTEFLAG, Pad);
   DrawPad (Pad, 0);
   Draw ();
-  return (True);
+  return (true);
 }
 
 /* ---------------------------------------------------------------------------
@@ -1608,7 +1608,7 @@ ChangePolyClear (LayerTypePtr Layer, PolygonTypePtr Polygon)
 {
   if (TEST_FLAG (LOCKFLAG, Polygon))
     return (NULL);
-  AddObjectToClearPolyUndoList (POLYGON_TYPE, Layer, Polygon, Polygon, True);
+  AddObjectToClearPolyUndoList (POLYGON_TYPE, Layer, Polygon, Polygon, true);
   AddObjectToFlagUndoList (POLYGON_TYPE, Layer, Polygon, Polygon);
   TOGGLE_FLAG (CLEARPOLYFLAG, Polygon);
   InitClip (PCB->Data, Layer, Polygon);
@@ -1618,12 +1618,12 @@ ChangePolyClear (LayerTypePtr Layer, PolygonTypePtr Polygon)
 
 /* ----------------------------------------------------------------------
  * changes the side of all selected and visible elements 
- * returns True if anything has changed
+ * returns true if anything has changed
  */
-Boolean
+bool
 ChangeSelectedElementSide (void)
 {
-  Boolean change = False;
+  bool change = false;
 
   /* setup identifiers */
   if (PCB->PinOn && PCB->ElementOn)
@@ -1645,15 +1645,15 @@ ChangeSelectedElementSide (void)
 
 /* ----------------------------------------------------------------------
  * changes the thermals on all selected and visible pins
- * and/or vias. Returns True if anything has changed
+ * and/or vias. Returns true if anything has changed
  */
-Boolean
+bool
 ChangeSelectedThermals (int types, int therm_style)
 {
-  Boolean change = False;
+  bool change = false;
 
   Delta = therm_style;
-  change = SelectedOperation (&ChangeThermalFunctions, False, types);
+  change = SelectedOperation (&ChangeThermalFunctions, false, types);
   if (change)
     {
       Draw ();
@@ -1664,18 +1664,18 @@ ChangeSelectedThermals (int types, int therm_style)
 
 /* ----------------------------------------------------------------------
  * changes the size of all selected and visible object types 
- * returns True if anything has changed
+ * returns true if anything has changed
  */
-Boolean
-ChangeSelectedSize (int types, LocationType Difference, Boolean fixIt)
+bool
+ChangeSelectedSize (int types, LocationType Difference, bool fixIt)
 {
-  Boolean change = False;
+  bool change = false;
 
   /* setup identifiers */
   Absolute = (fixIt) ? Difference : 0;
   Delta = Difference;
 
-  change = SelectedOperation (&ChangeSizeFunctions, False, types);
+  change = SelectedOperation (&ChangeSizeFunctions, false, types);
   if (change)
     {
       Draw ();
@@ -1686,20 +1686,20 @@ ChangeSelectedSize (int types, LocationType Difference, Boolean fixIt)
 
 /* ----------------------------------------------------------------------
  * changes the clearance size of all selected and visible objects
- * returns True if anything has changed
+ * returns true if anything has changed
  */
-Boolean
-ChangeSelectedClearSize (int types, LocationType Difference, Boolean fixIt)
+bool
+ChangeSelectedClearSize (int types, LocationType Difference, bool fixIt)
 {
-  Boolean change = False;
+  bool change = false;
 
   /* setup identifiers */
   Absolute = (fixIt) ? Difference : 0;
   Delta = Difference;
   if (TEST_FLAG (SHOWMASKFLAG, PCB))
-    change = SelectedOperation (&ChangeMaskSizeFunctions, False, types);
+    change = SelectedOperation (&ChangeMaskSizeFunctions, false, types);
   else
-    change = SelectedOperation (&ChangeClearSizeFunctions, False, types);
+    change = SelectedOperation (&ChangeClearSizeFunctions, false, types);
   if (change)
     {
       Draw ();
@@ -1710,17 +1710,17 @@ ChangeSelectedClearSize (int types, LocationType Difference, Boolean fixIt)
 
 /* --------------------------------------------------------------------------
  * changes the 2nd size (drilling hole) of all selected and visible objects
- * returns True if anything has changed
+ * returns true if anything has changed
  */
-Boolean
-ChangeSelected2ndSize (int types, LocationType Difference, Boolean fixIt)
+bool
+ChangeSelected2ndSize (int types, LocationType Difference, bool fixIt)
 {
-  Boolean change = False;
+  bool change = false;
 
   /* setup identifiers */
   Absolute = (fixIt) ? Difference : 0;
   Delta = Difference;
-  change = SelectedOperation (&Change2ndSizeFunctions, False, types);
+  change = SelectedOperation (&Change2ndSizeFunctions, false, types);
   if (change)
     {
       Draw ();
@@ -1731,14 +1731,14 @@ ChangeSelected2ndSize (int types, LocationType Difference, Boolean fixIt)
 
 /* ----------------------------------------------------------------------
  * changes the clearance flag (join) of all selected and visible lines
- * and/or arcs. Returns True if anything has changed
+ * and/or arcs. Returns true if anything has changed
  */
-Boolean
+bool
 ChangeSelectedJoin (int types)
 {
-  Boolean change = False;
+  bool change = false;
 
-  change = SelectedOperation (&ChangeJoinFunctions, False, types);
+  change = SelectedOperation (&ChangeJoinFunctions, false, types);
   if (change)
     {
       Draw ();
@@ -1749,14 +1749,14 @@ ChangeSelectedJoin (int types)
 
 /* ----------------------------------------------------------------------
  * changes the clearance flag (join) of all selected and visible lines
- * and/or arcs. Returns True if anything has changed
+ * and/or arcs. Returns true if anything has changed
  */
-Boolean
+bool
 SetSelectedJoin (int types)
 {
-  Boolean change = False;
+  bool change = false;
 
-  change = SelectedOperation (&SetJoinFunctions, False, types);
+  change = SelectedOperation (&SetJoinFunctions, false, types);
   if (change)
     {
       Draw ();
@@ -1767,14 +1767,14 @@ SetSelectedJoin (int types)
 
 /* ----------------------------------------------------------------------
  * changes the clearance flag (join) of all selected and visible lines
- * and/or arcs. Returns True if anything has changed
+ * and/or arcs. Returns true if anything has changed
  */
-Boolean
+bool
 ClrSelectedJoin (int types)
 {
-  Boolean change = False;
+  bool change = false;
 
-  change = SelectedOperation (&ClrJoinFunctions, False, types);
+  change = SelectedOperation (&ClrJoinFunctions, false, types);
   if (change)
     {
       Draw ();
@@ -1785,14 +1785,14 @@ ClrSelectedJoin (int types)
 
 /* ----------------------------------------------------------------------
  * changes the square-flag of all selected and visible pins or pads
- * returns True if anything has changed
+ * returns true if anything has changed
  */
-Boolean
+bool
 ChangeSelectedSquare (int types)
 {
-  Boolean change = False;
+  bool change = false;
 
-  change = SelectedOperation (&ChangeSquareFunctions, False, types);
+  change = SelectedOperation (&ChangeSquareFunctions, false, types);
   if (change)
     {
       Draw ();
@@ -1803,14 +1803,14 @@ ChangeSelectedSquare (int types)
 
 /* ----------------------------------------------------------------------
  * sets the square-flag of all selected and visible pins or pads
- * returns True if anything has changed
+ * returns true if anything has changed
  */
-Boolean
+bool
 SetSelectedSquare (int types)
 {
-  Boolean change = False;
+  bool change = false;
 
-  change = SelectedOperation (&SetSquareFunctions, False, types);
+  change = SelectedOperation (&SetSquareFunctions, false, types);
   if (change)
     {
       Draw ();
@@ -1821,14 +1821,14 @@ SetSelectedSquare (int types)
 
 /* ----------------------------------------------------------------------
  * clears the square-flag of all selected and visible pins or pads
- * returns True if anything has changed
+ * returns true if anything has changed
  */
-Boolean
+bool
 ClrSelectedSquare (int types)
 {
-  Boolean change = False;
+  bool change = false;
 
-  change = SelectedOperation (&ClrSquareFunctions, False, types);
+  change = SelectedOperation (&ClrSquareFunctions, false, types);
   if (change)
     {
       Draw ();
@@ -1839,14 +1839,14 @@ ClrSelectedSquare (int types)
 
 /* ----------------------------------------------------------------------
  * changes the octagon-flag of all selected and visible pins and vias
- * returns True if anything has changed
+ * returns true if anything has changed
  */
-Boolean
+bool
 ChangeSelectedOctagon (int types)
 {
-  Boolean change = False;
+  bool change = false;
 
-  change = SelectedOperation (&ChangeOctagonFunctions, False, types);
+  change = SelectedOperation (&ChangeOctagonFunctions, false, types);
   if (change)
     {
       Draw ();
@@ -1857,14 +1857,14 @@ ChangeSelectedOctagon (int types)
 
 /* ----------------------------------------------------------------------
  * sets the octagon-flag of all selected and visible pins and vias
- * returns True if anything has changed
+ * returns true if anything has changed
  */
-Boolean
+bool
 SetSelectedOctagon (int types)
 {
-  Boolean change = False;
+  bool change = false;
 
-  change = SelectedOperation (&SetOctagonFunctions, False, types);
+  change = SelectedOperation (&SetOctagonFunctions, false, types);
   if (change)
     {
       Draw ();
@@ -1875,14 +1875,14 @@ SetSelectedOctagon (int types)
 
 /* ----------------------------------------------------------------------
  * clears the octagon-flag of all selected and visible pins and vias
- * returns True if anything has changed
+ * returns true if anything has changed
  */
-Boolean
+bool
 ClrSelectedOctagon (int types)
 {
-  Boolean change = False;
+  bool change = false;
 
-  change = SelectedOperation (&ClrOctagonFunctions, False, types);
+  change = SelectedOperation (&ClrOctagonFunctions, false, types);
   if (change)
     {
       Draw ();
@@ -1893,12 +1893,12 @@ ClrSelectedOctagon (int types)
 
 /* ----------------------------------------------------------------------
  * changes the hole-flag of all selected and visible vias 
- * returns True if anything has changed
+ * returns true if anything has changed
  */
-Boolean
+bool
 ChangeSelectedHole (void)
 {
-  Boolean change = False;
+  bool change = false;
 
   if (PCB->ViaOn)
     VIA_LOOP (PCB->Data);
@@ -1917,12 +1917,12 @@ ChangeSelectedHole (void)
 
 /* ----------------------------------------------------------------------
  * changes the no paste-flag of all selected and visible pads
- * returns True if anything has changed
+ * returns true if anything has changed
  */
-Boolean
+bool
 ChangeSelectedPaste (void)
 {
-  Boolean change = False;
+  bool change = false;
 
   ALLPAD_LOOP (PCB->Data);
   {
@@ -1941,13 +1941,13 @@ ChangeSelectedPaste (void)
 
 /* ---------------------------------------------------------------------------
  * changes the size of the passed object
- * Returns True if anything is changed
+ * Returns true if anything is changed
  */
-Boolean
+bool
 ChangeObjectSize (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
-		  LocationType Difference, Boolean fixIt)
+		  LocationType Difference, bool fixIt)
 {
-  Boolean change;
+  bool change;
 
   /* setup identifier */
   Absolute = (fixIt) ? Difference : 0;
@@ -1964,13 +1964,13 @@ ChangeObjectSize (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
 
 /* ---------------------------------------------------------------------------
  * changes the clearance size of the passed object
- * Returns True if anything is changed
+ * Returns true if anything is changed
  */
-Boolean
+bool
 ChangeObjectClearSize (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
-		       LocationType Difference, Boolean fixIt)
+		       LocationType Difference, bool fixIt)
 {
-  Boolean change;
+  bool change;
 
   /* setup identifier */
   Absolute = (fixIt) ? Difference : 0;
@@ -1993,14 +1993,14 @@ ChangeObjectClearSize (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
 
 /* ---------------------------------------------------------------------------
  * changes the thermal of the passed object
- * Returns True if anything is changed
+ * Returns true if anything is changed
  *
  */
-Boolean
+bool
 ChangeObjectThermal (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
 		     int therm_type)
 {
-  Boolean change;
+  bool change;
 
   Delta = Absolute = therm_type;
   change =
@@ -2016,13 +2016,13 @@ ChangeObjectThermal (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
 
 /* ---------------------------------------------------------------------------
  * changes the 2nd size of the passed object
- * Returns True if anything is changed
+ * Returns true if anything is changed
  */
-Boolean
+bool
 ChangeObject2ndSize (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
-		     LocationType Difference, Boolean fixIt, Boolean incundo)
+		     LocationType Difference, bool fixIt, bool incundo)
 {
-  Boolean change;
+  bool change;
 
   /* setup identifier */
   Absolute = (fixIt) ? Difference : 0;
@@ -2041,13 +2041,13 @@ ChangeObject2ndSize (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
 
 /* ---------------------------------------------------------------------------
  * changes the mask size of the passed object
- * Returns True if anything is changed
+ * Returns true if anything is changed
  */
-Boolean
+bool
 ChangeObjectMaskSize (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
-		      LocationType Difference, Boolean fixIt)
+		      LocationType Difference, bool fixIt)
 {
-  Boolean change;
+  bool change;
 
   /* setup identifier */
   Absolute = (fixIt) ? Difference : 0;
@@ -2084,57 +2084,57 @@ ChangeObjectName (int Type, void *Ptr1, void *Ptr2, void *Ptr3, char *Name)
 
 /* ---------------------------------------------------------------------------
  * changes the clearance-flag of the passed object
- * Returns True if anything is changed
+ * Returns true if anything is changed
  */
-Boolean
+bool
 ChangeObjectJoin (int Type, void *Ptr1, void *Ptr2, void *Ptr3)
 {
   if (ObjectOperation (&ChangeJoinFunctions, Type, Ptr1, Ptr2, Ptr3) != NULL)
     {
       Draw ();
       IncrementUndoSerialNumber ();
-      return (True);
+      return (true);
     }
-  return (False);
+  return (false);
 }
 
 /* ---------------------------------------------------------------------------
  * sets the clearance-flag of the passed object
- * Returns True if anything is changed
+ * Returns true if anything is changed
  */
-Boolean
+bool
 SetObjectJoin (int Type, void *Ptr1, void *Ptr2, void *Ptr3)
 {
   if (ObjectOperation (&SetJoinFunctions, Type, Ptr1, Ptr2, Ptr3) != NULL)
     {
       Draw ();
       IncrementUndoSerialNumber ();
-      return (True);
+      return (true);
     }
-  return (False);
+  return (false);
 }
 
 /* ---------------------------------------------------------------------------
  * clears the clearance-flag of the passed object
- * Returns True if anything is changed
+ * Returns true if anything is changed
  */
-Boolean
+bool
 ClrObjectJoin (int Type, void *Ptr1, void *Ptr2, void *Ptr3)
 {
   if (ObjectOperation (&ClrJoinFunctions, Type, Ptr1, Ptr2, Ptr3) != NULL)
     {
       Draw ();
       IncrementUndoSerialNumber ();
-      return (True);
+      return (true);
     }
-  return (False);
+  return (false);
 }
 
 /* ---------------------------------------------------------------------------
  * changes the square-flag of the passed object
- * Returns True if anything is changed
+ * Returns true if anything is changed
  */
-Boolean
+bool
 ChangeObjectSquare (int Type, void *Ptr1, void *Ptr2, void *Ptr3)
 {
   if (ObjectOperation (&ChangeSquareFunctions, Type, Ptr1, Ptr2, Ptr3) !=
@@ -2142,48 +2142,48 @@ ChangeObjectSquare (int Type, void *Ptr1, void *Ptr2, void *Ptr3)
     {
       Draw ();
       IncrementUndoSerialNumber ();
-      return (True);
+      return (true);
     }
-  return (False);
+  return (false);
 }
 
 /* ---------------------------------------------------------------------------
  * sets the square-flag of the passed object
- * Returns True if anything is changed
+ * Returns true if anything is changed
  */
-Boolean
+bool
 SetObjectSquare (int Type, void *Ptr1, void *Ptr2, void *Ptr3)
 {
   if (ObjectOperation (&SetSquareFunctions, Type, Ptr1, Ptr2, Ptr3) != NULL)
     {
       Draw ();
       IncrementUndoSerialNumber ();
-      return (True);
+      return (true);
     }
-  return (False);
+  return (false);
 }
 
 /* ---------------------------------------------------------------------------
  * clears the square-flag of the passed object
- * Returns True if anything is changed
+ * Returns true if anything is changed
  */
-Boolean
+bool
 ClrObjectSquare (int Type, void *Ptr1, void *Ptr2, void *Ptr3)
 {
   if (ObjectOperation (&ClrSquareFunctions, Type, Ptr1, Ptr2, Ptr3) != NULL)
     {
       Draw ();
       IncrementUndoSerialNumber ();
-      return (True);
+      return (true);
     }
-  return (False);
+  return (false);
 }
 
 /* ---------------------------------------------------------------------------
  * changes the octagon-flag of the passed object
- * Returns True if anything is changed
+ * Returns true if anything is changed
  */
-Boolean
+bool
 ChangeObjectOctagon (int Type, void *Ptr1, void *Ptr2, void *Ptr3)
 {
   if (ObjectOperation (&ChangeOctagonFunctions, Type, Ptr1, Ptr2, Ptr3) !=
@@ -2191,41 +2191,41 @@ ChangeObjectOctagon (int Type, void *Ptr1, void *Ptr2, void *Ptr3)
     {
       Draw ();
       IncrementUndoSerialNumber ();
-      return (True);
+      return (true);
     }
-  return (False);
+  return (false);
 }
 
 /* ---------------------------------------------------------------------------
  * sets the octagon-flag of the passed object
- * Returns True if anything is changed
+ * Returns true if anything is changed
  */
-Boolean
+bool
 SetObjectOctagon (int Type, void *Ptr1, void *Ptr2, void *Ptr3)
 {
   if (ObjectOperation (&SetOctagonFunctions, Type, Ptr1, Ptr2, Ptr3) != NULL)
     {
       Draw ();
       IncrementUndoSerialNumber ();
-      return (True);
+      return (true);
     }
-  return (False);
+  return (false);
 }
 
 /* ---------------------------------------------------------------------------
  * clears the octagon-flag of the passed object
- * Returns True if anything is changed
+ * Returns true if anything is changed
  */
-Boolean
+bool
 ClrObjectOctagon (int Type, void *Ptr1, void *Ptr2, void *Ptr3)
 {
   if (ObjectOperation (&ClrOctagonFunctions, Type, Ptr1, Ptr2, Ptr3) != NULL)
     {
       Draw ();
       IncrementUndoSerialNumber ();
-      return (True);
+      return (true);
     }
-  return (False);
+  return (false);
 }
 
 /* ---------------------------------------------------------------------------
diff --git a/src/change.h b/src/change.h
index fc577a0..7bae706 100644
--- a/src/change.h
+++ b/src/change.h
@@ -65,45 +65,45 @@
 #define CHANGEMASKSIZE_TYPES    \
         (PIN_TYPE | VIA_TYPE | PAD_TYPE)
 
-Boolean ChangeLayoutName (char *);
-Boolean ChangeLayerName (LayerTypePtr, char *);
-Boolean ChangeSelectedSize (int, LocationType, Boolean);
-Boolean ChangeSelectedClearSize (int, LocationType, Boolean);
-Boolean ChangeSelected2ndSize (int, LocationType, Boolean);
-Boolean ChangeSelectedMaskSize (int, LocationType, Boolean);
-Boolean ChangeSelectedJoin (int);
-Boolean SetSelectedJoin (int);
-Boolean ClrSelectedJoin (int);
-Boolean ChangeSelectedSquare (int);
-Boolean SetSelectedSquare (int);
-Boolean ClrSelectedSquare (int);
-Boolean ChangeSelectedThermals (int, int);
-Boolean ChangeSelectedHole (void);
-Boolean ChangeSelectedPaste (void);
-Boolean ChangeSelectedOctagon (int);
-Boolean SetSelectedOctagon (int);
-Boolean ClrSelectedOctagon (int);
-Boolean ChangeSelectedElementSide (void);
-Boolean ChangeElementSide (ElementTypePtr, LocationType);
-Boolean ChangeHole (PinTypePtr);
-Boolean ChangePaste (PadTypePtr);
-Boolean ChangeObjectSize (int, void *, void *, void *, LocationType, Boolean);
-Boolean ChangeObjectThermal (int, void *, void *, void *, int);
-Boolean ChangeObjectClearSize (int, void *, void *, void *, LocationType,
-			       Boolean);
-Boolean ChangeObject2ndSize (int, void *, void *, void *, LocationType,
-			     Boolean, Boolean);
-Boolean ChangeObjectMaskSize (int, void *, void *, void *, LocationType,
-			      Boolean);
-Boolean ChangeObjectJoin (int, void *, void *, void *);
-Boolean SetObjectJoin (int, void *, void *, void *);
-Boolean ClrObjectJoin (int, void *, void *, void *);
-Boolean ChangeObjectSquare (int, void *, void *, void *);
-Boolean SetObjectSquare (int, void *, void *, void *);
-Boolean ClrObjectSquare (int, void *, void *, void *);
-Boolean ChangeObjectOctagon (int, void *, void *, void *);
-Boolean SetObjectOctagon (int, void *, void *, void *);
-Boolean ClrObjectOctagon (int, void *, void *, void *);
+bool ChangeLayoutName (char *);
+bool ChangeLayerName (LayerTypePtr, char *);
+bool ChangeSelectedSize (int, LocationType, bool);
+bool ChangeSelectedClearSize (int, LocationType, bool);
+bool ChangeSelected2ndSize (int, LocationType, bool);
+bool ChangeSelectedMaskSize (int, LocationType, bool);
+bool ChangeSelectedJoin (int);
+bool SetSelectedJoin (int);
+bool ClrSelectedJoin (int);
+bool ChangeSelectedSquare (int);
+bool SetSelectedSquare (int);
+bool ClrSelectedSquare (int);
+bool ChangeSelectedThermals (int, int);
+bool ChangeSelectedHole (void);
+bool ChangeSelectedPaste (void);
+bool ChangeSelectedOctagon (int);
+bool SetSelectedOctagon (int);
+bool ClrSelectedOctagon (int);
+bool ChangeSelectedElementSide (void);
+bool ChangeElementSide (ElementTypePtr, LocationType);
+bool ChangeHole (PinTypePtr);
+bool ChangePaste (PadTypePtr);
+bool ChangeObjectSize (int, void *, void *, void *, LocationType, bool);
+bool ChangeObjectThermal (int, void *, void *, void *, int);
+bool ChangeObjectClearSize (int, void *, void *, void *, LocationType,
+			       bool);
+bool ChangeObject2ndSize (int, void *, void *, void *, LocationType,
+			     bool, bool);
+bool ChangeObjectMaskSize (int, void *, void *, void *, LocationType,
+			      bool);
+bool ChangeObjectJoin (int, void *, void *, void *);
+bool SetObjectJoin (int, void *, void *, void *);
+bool ClrObjectJoin (int, void *, void *, void *);
+bool ChangeObjectSquare (int, void *, void *, void *);
+bool SetObjectSquare (int, void *, void *, void *);
+bool ClrObjectSquare (int, void *, void *, void *);
+bool ChangeObjectOctagon (int, void *, void *, void *);
+bool SetObjectOctagon (int, void *, void *, void *);
+bool ClrObjectOctagon (int, void *, void *, void *);
 void *ChangeObjectName (int, void *, void *, void *, char *);
 void *QueryInputAndChangeObjectName (int, void *, void *, void *);
 void ChangePCBSize (BDimension, BDimension);
diff --git a/src/clip.c b/src/clip.c
index f24f442..f38c660 100644
--- a/src/clip.c
+++ b/src/clip.c
@@ -48,10 +48,10 @@
 RCSID ("$Id$");
 
 /* Clip the line to the clipBox
- * return True if something to be drawn
+ * return true if something to be drawn
  * false if the whole thing is clipped
  */
-Boolean
+bool
 ClipLine (double minx, double miny, double maxx, double maxy,
 	  double *x1, double *y1,
 	  double *x2, double *y2,
@@ -68,7 +68,7 @@ ClipLine (double minx, double miny, double maxx, double maxy,
   if (*x1 < minx)
     {
       if (*x2 < minx)
-	return False;
+	return false;
       d = *x2 - *x1;
       r = (minx - *x1) / d;
       *x1 = minx;
@@ -86,7 +86,7 @@ ClipLine (double minx, double miny, double maxx, double maxy,
   if (*x1 > maxx)
     {
       if (*x2 > maxx)
-	return False;
+	return false;
       d = *x2 - *x1;
       r = (maxx - *x1) / d;
       *x1 = maxx;
@@ -105,7 +105,7 @@ ClipLine (double minx, double miny, double maxx, double maxy,
   if (*y1 < miny)
     {
       if (*y2 < miny)
-	return False;
+	return false;
       d = *y2 - *y1;
       r = (miny - *y1) / d;
       *y1 = miny;
@@ -123,7 +123,7 @@ ClipLine (double minx, double miny, double maxx, double maxy,
   if (*y1 > maxy)
     {
       if (*y2 > maxy)
-	return False;
+	return false;
       d = *y2 - *y1;
       r = (maxy - *y1) / d;
       *y1 = maxy;
@@ -137,5 +137,5 @@ ClipLine (double minx, double miny, double maxx, double maxy,
       *y2 = maxy;
       *x2 += r * (*x1 - *x2);
     }
-  return True;
+  return true;
 }
diff --git a/src/clip.h b/src/clip.h
index f4633d4..fcc5f2e 100644
--- a/src/clip.h
+++ b/src/clip.h
@@ -40,7 +40,7 @@
 
 /* Clip X,Y to the given bounding box, plus a margin.  Returns TRUE if
    there is something left to be drawn.  */
-Boolean ClipLine (double minx, double miny, double maxx, double maxy,
+bool ClipLine (double minx, double miny, double maxx, double maxy,
 		  double *x1, double *y1,
 		  double *x2, double *y2,
 		  double margin);
diff --git a/src/command.c b/src/command.c
index 9404ac4..b41263b 100644
--- a/src/command.c
+++ b/src/command.c
@@ -170,12 +170,12 @@ CommandLoadElementToBuffer (int argc, char **argv, int x, int y)
     {
     case 1:			/* filename is passed in commandline */
       filename = argv[0];
-      if (filename && LoadElementToBuffer (PASTEBUFFER, filename, True))
+      if (filename && LoadElementToBuffer (PASTEBUFFER, filename, true))
 	SetMode (PASTEBUFFER_MODE);
       break;
 
     default:			/* usage */
-      Message (False, "Usage: le [name]\n  loads element data to buffer\n");
+      Message (false, "Usage: le [name]\n  loads element data to buffer\n");
       return (1);
     }
   return (0);
diff --git a/src/copy.c b/src/copy.c
index 583feb8..ffa0ed3 100644
--- a/src/copy.c
+++ b/src/copy.c
@@ -113,7 +113,7 @@ CopyPolygonLowLevel (PolygonTypePtr Dest, PolygonTypePtr Src)
  */
 ElementTypePtr
 CopyElementLowLevel (DataTypePtr Data, ElementTypePtr Dest,
-		     ElementTypePtr Src, Boolean uniqueName, LocationType dx,
+		     ElementTypePtr Src, bool uniqueName, LocationType dx,
 		     LocationType dy)
 {
   int i;
@@ -288,7 +288,7 @@ CopyElement (ElementTypePtr Element)
 	 Element->Name[1].TextString);
 #endif
 
-  Boolean didDraw = False;
+  bool didDraw = false;
   ElementTypePtr element = CopyElementLowLevel (PCB->Data,
 						NULL, Element,
 						TEST_FLAG (UNIQUENAMEFLAG,
@@ -301,12 +301,12 @@ CopyElement (ElementTypePtr Element)
     {
       DrawElementName (element, 0);
       DrawElementPackage (element, 0);
-      didDraw = True;
+      didDraw = true;
     }
   if (PCB->PinOn)
     {
       DrawElementPinsAndPads (element, 0);
-      didDraw = True;
+      didDraw = true;
     }
 #ifdef DEBUG
   printf(" ... Leaving CopyElement.\n");
@@ -318,11 +318,11 @@ CopyElement (ElementTypePtr Element)
  * pastes the contents of the buffer to the layout. Only visible objects
  * are handled by the routine.
  */
-Boolean
+bool
 CopyPastebufferToLayout (LocationType X, LocationType Y)
 {
   Cardinal i;
-  Boolean changed = False;
+  bool changed = false;
 
 #ifdef DEBUG
   printf("Entering CopyPastebufferToLayout.....\n");
@@ -378,7 +378,7 @@ CopyPastebufferToLayout (LocationType X, LocationType Y)
 	if (FRONT (element) || PCB->InvisibleObjectsOn)
 	  {
 	    CopyElement (element);
-	    changed = True;
+	    changed = true;
 	  }
       }
       END_LOOP;
diff --git a/src/copy.h b/src/copy.h
index 472fc75..ac50e2c 100644
--- a/src/copy.h
+++ b/src/copy.h
@@ -43,8 +43,8 @@
 
 PolygonTypePtr CopyPolygonLowLevel (PolygonTypePtr, PolygonTypePtr);
 ElementTypePtr CopyElementLowLevel (DataTypePtr, ElementTypePtr,
-				    ElementTypePtr, Boolean, LocationType, LocationType);
-Boolean CopyPastebufferToLayout (LocationType, LocationType);
+				    ElementTypePtr, bool, LocationType, LocationType);
+bool CopyPastebufferToLayout (LocationType, LocationType);
 void *CopyObject (int, void *, void *, void *, LocationType, LocationType);
 
 #endif
diff --git a/src/create.c b/src/create.c
index 1a79ae6..0c5abe1 100644
--- a/src/create.c
+++ b/src/create.c
@@ -130,7 +130,7 @@ pcb_colors_from_settings (PCBTypePtr ptr)
  * creates a new PCB
  */
 PCBTypePtr
-CreateNewPCB (Boolean SetDefaultNames)
+CreateNewPCB (bool SetDefaultNames)
 {
   PCBTypePtr ptr;
   int i;
@@ -142,8 +142,8 @@ CreateNewPCB (Boolean SetDefaultNames)
 
   ptr->ThermStyle = 4;
   ptr->IsleArea = 2.e8;
-  ptr->SilkActive = False;
-  ptr->RatDraw = False;
+  ptr->SilkActive = false;
+  ptr->RatDraw = false;
   SET_FLAG (NAMEONPCBFLAG, ptr);
   if (Settings.ShowNumber)
     SET_FLAG (SHOWNUMBERFLAG, ptr);
@@ -644,7 +644,7 @@ CreateNewElement (DataTypePtr Data, ElementTypePtr Element,
 		  FlagType Flags,
 		  char *Description, char *NameOnPCB, char *Value,
 		  LocationType TextX, LocationType TextY, BYTE Direction,
-		  int TextScale, FlagType TextFlags, Boolean uniqueName)
+		  int TextScale, FlagType TextFlags, bool uniqueName)
 {
 #ifdef DEBUG
   printf("Entered CreateNewElement.....\n");
diff --git a/src/create.h b/src/create.h
index a994c84..b9f418c 100644
--- a/src/create.h
+++ b/src/create.h
@@ -35,7 +35,7 @@
 
 DataTypePtr CreateNewBuffer (void);
 void pcb_colors_from_settings (PCBTypePtr);
-PCBTypePtr CreateNewPCB (Boolean);
+PCBTypePtr CreateNewPCB (bool);
 /* Called after PCB->Data->LayerN is set.  Returns zero if no errors,
    else nonzero.  */
 int CreateNewPCBPost (PCBTypePtr, int /* set defaults */);
@@ -65,7 +65,7 @@ PointTypePtr CreateNewPointInPolygon (PolygonTypePtr,
 ElementTypePtr CreateNewElement (DataTypePtr, ElementTypePtr,
 				 FontTypePtr, FlagType, char *, char *,
 				 char *, LocationType, LocationType, BYTE,
-				 int, FlagType, Boolean);
+				 int, FlagType, bool);
 LineTypePtr CreateNewLineInElement (ElementTypePtr, LocationType,
 				    LocationType, LocationType, LocationType,
 				    BDimension);
diff --git a/src/crosshair.c b/src/crosshair.c
index 367922e..88b9cc0 100644
--- a/src/crosshair.c
+++ b/src/crosshair.c
@@ -70,7 +70,7 @@ typedef struct
 
 /* This is a stack for HideCrosshair() and RestoreCrosshair() calls. They
  * must always be matched. */
-static Boolean CrosshairStack[MAX_CROSSHAIRSTACK_DEPTH];
+static bool CrosshairStack[MAX_CROSSHAIRSTACK_DEPTH];
 static int CrosshairStackLocation = 0;
 
 /* ---------------------------------------------------------------------------
@@ -84,7 +84,7 @@ static void XORDrawMoveOrCopyObject (void);
 static void XORDrawAttachedLine (LocationType, LocationType, LocationType,
 				 LocationType, BDimension);
 static void XORDrawAttachedArc (BDimension);
-static void DrawAttached (Boolean);
+static void DrawAttached (bool);
 
 /* ---------------------------------------------------------------------------
  * creates a tmp polygon with coordinates converted to screen system
@@ -577,7 +577,7 @@ XORDrawMoveOrCopyObject (void)
  * draws additional stuff that follows the crosshair
  */
 static void
-DrawAttached (Boolean BlockToo)
+DrawAttached (bool BlockToo)
 {
   BDimension s;
   switch (Settings.Mode)
@@ -698,13 +698,13 @@ DrawAttached (Boolean BlockToo)
  * switches crosshair on
  */
 void
-CrosshairOn (Boolean BlockToo)
+CrosshairOn (bool BlockToo)
 {
   if (!Crosshair.On)
     {
-      Crosshair.On = True;
+      Crosshair.On = true;
       DrawAttached (BlockToo);
-      DrawMark (True);
+      DrawMark (true);
     }
 }
 
@@ -712,13 +712,13 @@ CrosshairOn (Boolean BlockToo)
  * switches crosshair off
  */
 void
-CrosshairOff (Boolean BlockToo)
+CrosshairOff (bool BlockToo)
 {
   if (Crosshair.On)
     {
-      Crosshair.On = False;
+      Crosshair.On = false;
       DrawAttached (BlockToo);
-      DrawMark (True);
+      DrawMark (true);
     }
 }
 
@@ -735,7 +735,7 @@ CrosshairOff (Boolean BlockToo)
  * saves crosshair state (on/off) and hides him
  */
 void
-HideCrosshair (Boolean BlockToo)
+HideCrosshair (bool BlockToo)
 {
   /* fprintf(stderr, "HideCrosshair %d stack %d\n", BlockToo ? 1 : 0, CrosshairStackLocation); */
   if (CrosshairStackLocation >= MAX_CROSSHAIRSTACK_DEPTH)
@@ -754,7 +754,7 @@ HideCrosshair (Boolean BlockToo)
  * restores last crosshair state
  */
 void
-RestoreCrosshair (Boolean BlockToo)
+RestoreCrosshair (bool BlockToo)
 {
   /* fprintf(stderr, "RestoreCrosshair %d stack %d\n", BlockToo ? 1 : 0, CrosshairStackLocation); */
   if (CrosshairStackLocation <= 0)
@@ -940,7 +940,7 @@ FitCrosshairIntoGrid (LocationType X, LocationType Y)
 	if (ans == NO_TYPE)
 	  hid_action("PointCursor");
 	else if (!TEST_FLAG(SELECTEDFLAG, (LineType *)ptr2))
-	  hid_actionl("PointCursor","True", NULL);
+	  hid_actionl("PointCursor","true", NULL);
     }
   if (Settings.Mode == LINE_MODE
       && Crosshair.AttachedLine.State != STATE_FIRST
@@ -961,9 +961,9 @@ MoveCrosshairRelative (LocationType DeltaX, LocationType DeltaY)
 
 /* ---------------------------------------------------------------------------
  * move crosshair absolute switched off if it moved
- * return True if it switched off
+ * return true if it switched off
  */
-Boolean
+bool
 MoveCrosshairAbsolute (LocationType X, LocationType Y)
 {
   LocationType x, y, z;
@@ -978,13 +978,13 @@ MoveCrosshairAbsolute (LocationType X, LocationType Y)
       x = z;
       z = Crosshair.Y;
       Crosshair.Y = y;
-      HideCrosshair (False);
+      HideCrosshair (false);
       /* now move forward again */
       Crosshair.X = x;
       Crosshair.Y = z;
-      return (True);
+      return (true);
     }
-  return (False);
+  return (false);
 }
 
 /* ---------------------------------------------------------------------------
@@ -1005,10 +1005,10 @@ SetCrosshairRange (LocationType MinX, LocationType MinY, LocationType MaxX,
 
 /* --------------------------------------------------------------------------
  * draw the marker position
- * if argument is True, draw only if it is visible, otherwise draw it regardless
+ * if argument is true, draw only if it is visible, otherwise draw it regardless
  */
 void
-DrawMark (Boolean ifvis)
+DrawMark (bool ifvis)
 {
   if (Marked.status || !ifvis)
     {
@@ -1040,8 +1040,8 @@ InitCrosshair (void)
 
   /* fake a crosshair off entry on stack */
   CrosshairStackLocation = 0;
-  CrosshairStack[CrosshairStackLocation++] = True;
-  Crosshair.On = False;
+  CrosshairStack[CrosshairStackLocation++] = true;
+  Crosshair.On = false;
 
   /* set initial shape */
   Crosshair.shape = Basic_Crosshair_Shape;
@@ -1052,7 +1052,7 @@ InitCrosshair (void)
   Crosshair.MaxY = PCB->MaxHeight;
 
   /* clear the mark */
-  Marked.status = False;
+  Marked.status = false;
 }
 
 /* ---------------------------------------------------------------------------
@@ -1061,7 +1061,7 @@ InitCrosshair (void)
 void
 DestroyCrosshair (void)
 {
-  CrosshairOff (True);
+  CrosshairOff (true);
   FreePolygonMemory (&Crosshair.AttachedPolygon);
   gui->destroy_gc (Crosshair.GC);
 }
diff --git a/src/crosshair.h b/src/crosshair.h
index 2e1fe7c..8299778 100644
--- a/src/crosshair.h
+++ b/src/crosshair.h
@@ -47,17 +47,17 @@
 #define	STATE_THIRD		2
 
 
-void CrosshairOn (Boolean);
-void CrosshairOff (Boolean);
-void HideCrosshair (Boolean);
-void RestoreCrosshair (Boolean);
+void CrosshairOn (bool);
+void CrosshairOff (bool);
+void HideCrosshair (bool);
+void RestoreCrosshair (bool);
 void MoveCrosshairRelative (LocationType, LocationType);
-Boolean MoveCrosshairAbsolute (LocationType, LocationType);
+bool MoveCrosshairAbsolute (LocationType, LocationType);
 void SetCrosshairRange (LocationType, LocationType, LocationType,
 			LocationType);
 void InitCrosshair (void);
 void DestroyCrosshair (void);
-void DrawMark (Boolean);
+void DrawMark (bool);
 void FitCrosshairIntoGrid (LocationType, LocationType);
 
 #endif
diff --git a/src/data.c b/src/data.c
index c938389..d07413f 100644
--- a/src/data.c
+++ b/src/data.c
@@ -55,8 +55,8 @@ int LayerStack[MAX_LAYER];	/* determines the layer draw order */
 
 BufferType Buffers[MAX_BUFFER];	/* my buffers */
 LibraryType Library;		/* the library */
-Boolean Bumped;			/* if the undo serial number has changed */
-Boolean render;			/* whether or not to re-render the pixmap */
+bool Bumped;			/* if the undo serial number has changed */
+bool render;			/* whether or not to re-render the pixmap */
 
 LocationType Xorig, Yorig;	/* origin offset for drawing in pixmap */
 
diff --git a/src/data.h b/src/data.h
index 53618c4..101e3db 100644
--- a/src/data.h
+++ b/src/data.h
@@ -68,9 +68,9 @@ extern char *InputTranslations;
 extern int addedLines;
 extern int LayerStack[MAX_LAYER];
 
-extern Boolean RedrawOnEnter;
-extern Boolean render;
-extern Boolean Bumped;
+extern bool RedrawOnEnter;
+extern bool render;
+extern bool Bumped;
 
 extern FlagType no_flags;
 
diff --git a/src/djopt.c b/src/djopt.c
index c8ae961..92fd2b8 100644
--- a/src/djopt.c
+++ b/src/djopt.c
@@ -2978,7 +2978,7 @@ ActionDJopt (int argc, char **argv, int x, int y)
 
 #ifdef ENDIF
   SwitchDrawingWindow (PCB->Zoom, Output.drawing_area->window,
-		       Settings.ShowSolderSide, False);
+		       Settings.ShowSolderSide, false);
 #endif
 
   hid_action("Busy");
diff --git a/src/draw.c b/src/draw.c
index d06813d..1bbbaa1 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -76,28 +76,28 @@ FloatPolyType, *FloatPolyTypePtr;
  * some local identifiers
  */
 static BoxType Block;
-static Boolean Gathering = True;
-static int Erasing = False;
+static bool Gathering = true;
+static int Erasing = false;
 
-static int doing_pinout = False;
-static int doing_assy = False;
+static int doing_pinout = false;
+static int doing_assy = false;
 static const BoxType *clip_box = NULL;
 
 /* ---------------------------------------------------------------------------
  * some local prototypes
  */
-static void Redraw (Boolean, BoxTypePtr);
+static void Redraw (bool, BoxTypePtr);
 static void DrawEverything (BoxTypePtr);
 static void DrawTop (const BoxType *);
 static int DrawLayerGroup (int, const BoxType *);
-static void DrawPinOrViaLowLevel (PinTypePtr, Boolean);
-static void ClearOnlyPin (PinTypePtr, Boolean);
-static void DrawPlainPin (PinTypePtr, Boolean);
-static void DrawPlainVia (PinTypePtr, Boolean);
+static void DrawPinOrViaLowLevel (PinTypePtr, bool);
+static void ClearOnlyPin (PinTypePtr, bool);
+static void DrawPlainPin (PinTypePtr, bool);
+static void DrawPlainVia (PinTypePtr, bool);
 static void DrawPinOrViaNameLowLevel (PinTypePtr);
-static void DrawPadLowLevel (hidGC, PadTypePtr, Boolean, Boolean);
+static void DrawPadLowLevel (hidGC, PadTypePtr, bool, bool);
 static void DrawPadNameLowLevel (PadTypePtr);
-static void DrawLineLowLevel (LineTypePtr, Boolean);
+static void DrawLineLowLevel (LineTypePtr, bool);
 static void DrawRegularText (LayerTypePtr, TextTypePtr, int);
 static void DrawPolygonLowLevel (PolygonTypePtr);
 static void DrawArcLowLevel (ArcTypePtr);
@@ -105,8 +105,8 @@ static void DrawElementPackageLowLevel (ElementTypePtr Element, int);
 static void DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon);
 static void AddPart (void *);
 static void SetPVColor (PinTypePtr, int);
-static void DrawEMark (ElementTypePtr, LocationType, LocationType, Boolean);
-static void ClearPad (PadTypePtr, Boolean);
+static void DrawEMark (ElementTypePtr, LocationType, LocationType, bool);
+static void ClearPad (PadTypePtr, bool);
 static void DrawHole (PinTypePtr);
 static void DrawMask (BoxType *);
 static void DrawRats (BoxType *);
@@ -188,15 +188,15 @@ void
 Draw (void)
 {
 
-  render = True;
+  render = true;
 
-  HideCrosshair (True);
+  HideCrosshair (true);
 
   /* clear and create event if not drawing to a pixmap
    */
   gui->invalidate_lr (Block.X1, Block.X2, Block.Y1, Block.Y2);
 
-  RestoreCrosshair (True);
+  RestoreCrosshair (true);
 
   /* shrink the update block */
   Block.X1 = Block.Y1 = Block.X2 = Block.Y2 = 0;
@@ -208,7 +208,7 @@ Draw (void)
 void
 RedrawOutput (BoxTypePtr area)
 {
-  Redraw (True, area);
+  Redraw (true, area);
 }
 
 /* ---------------------------------------------------------------------------
@@ -217,8 +217,8 @@ RedrawOutput (BoxTypePtr area)
 void
 ClearAndRedrawOutput (void)
 {
-  render = True;
-  Gathering = False;
+  render = true;
+  Gathering = false;
   UpdateAll ();
 }
 
@@ -231,11 +231,11 @@ ClearAndRedrawOutput (void)
  * by the event handlers
  */
 static void
-Redraw (Boolean ClearWindow, BoxTypePtr screen_area)
+Redraw (bool ClearWindow, BoxTypePtr screen_area)
 {
   gui->invalidate_all ();
-  Gathering = True;
-  render = False;
+  Gathering = true;
+  render = false;
 }
 
 static int
@@ -525,13 +525,13 @@ DrawEverything (BoxTypePtr drawn_area)
   for (side = 0; side <= 1; side++)
     {
       int doit;
-      Boolean NoData = True;
+      bool NoData = true;
       ALLPAD_LOOP (PCB->Data);
       {
 	if ((TEST_FLAG (ONSOLDERFLAG, pad) && side == SOLDER_LAYER)
 	    || (!TEST_FLAG (ONSOLDERFLAG, pad) && side == COMPONENT_LAYER))
 	  {
-	    NoData = False;
+	    NoData = false;
 	    break;
 	  }
       }
@@ -550,19 +550,19 @@ DrawEverything (BoxTypePtr drawn_area)
 		|| (!TEST_FLAG (ONSOLDERFLAG, pad)
 		    && side == COMPONENT_LAYER))
 	      if (!TEST_FLAG (NOPASTEFLAG, pad))
-		DrawPadLowLevel (Output.fgGC, pad, False, False);
+		DrawPadLowLevel (Output.fgGC, pad, false, false);
 	  }
 	  ENDALL_LOOP;
 	}
     }
 
-  doing_assy = True;
+  doing_assy = true;
   if (gui->set_layer ("topassembly", SL (ASSY, TOP), 0))
     PrintAssembly (drawn_area, component, 0);
 
   if (gui->set_layer ("bottomassembly", SL (ASSY, BOTTOM), 0))
     PrintAssembly (drawn_area, solder, 1);
-  doing_assy = False;
+  doing_assy = false;
 
   if (gui->set_layer ("fab", SL (FAB, 0), 0))
     PrintFab ();
@@ -570,7 +570,7 @@ DrawEverything (BoxTypePtr drawn_area)
 
 static void
 DrawEMark (ElementTypePtr e, LocationType X, LocationType Y,
-	   Boolean invisible)
+	   bool invisible)
 {
   int mark_size = EMARK_SIZE;
   if (!PCB->InvisibleObjectsOn && invisible)
@@ -607,14 +607,14 @@ static int
 via_callback (const BoxType * b, void *cl)
 {
   PinTypePtr via = (PinTypePtr) b;
-  DrawPlainVia (via, False);
+  DrawPlainVia (via, false);
   return 1;
 }
 
 static int
 pin_callback (const BoxType * b, void *cl)
 {
-  DrawPlainPin ((PinTypePtr) b, False);
+  DrawPlainPin ((PinTypePtr) b, false);
   return 1;
 }
 
@@ -652,7 +652,7 @@ DrawTop (const BoxType * screen)
 
 struct pin_info
 {
-  Boolean arg;
+  bool arg;
   LayerTypePtr Layer;
 };
 
@@ -662,7 +662,7 @@ clearPin_callback (const BoxType * b, void *cl)
   PinTypePtr pin = (PinTypePtr) b;
   struct pin_info *i = (struct pin_info *) cl;
   if (i->arg)
-    ClearOnlyPin (pin, True);
+    ClearOnlyPin (pin, true);
   return 1;
 }
 static int
@@ -679,7 +679,7 @@ clearPad_callback (const BoxType * b, void *cl)
 {
   PadTypePtr pad = (PadTypePtr) b;
   if (!XOR (TEST_FLAG (ONSOLDERFLAG, pad), SWAP_IDENT))
-    ClearPad (pad, True);
+    ClearPad (pad, true);
   return 1;
 }
 
@@ -714,7 +714,7 @@ DrawSilk (int new_swap, int layer, const BoxType * drawn_area)
     }
 
   gui->use_mask (HID_MASK_CLEAR);
-  info.arg = True;
+  info.arg = true;
   r_search (PCB->Data->pin_tree, drawn_area, NULL, clearPin_callback, &info);
   r_search (PCB->Data->via_tree, drawn_area, NULL, clearPin_callback, &info);
   r_search (PCB->Data->pad_tree, drawn_area, NULL, clearPad_callback, &info);
@@ -745,7 +745,7 @@ DrawMask (BoxType * screen)
 
   OutputType *out = &Output;
 
-  info.arg = True;
+  info.arg = true;
 
   if (thin)
     gui->set_color (Output.pmGC, PCB->MaskColor);
@@ -843,7 +843,7 @@ DrawLayer (LayerTypePtr Layer, const BoxType * screen)
 
   /* print the non-clearing polys */
   info.Layer = Layer;
-  info.arg = False;
+  info.arg = false;
   clip_box = screen;
   r_search (Layer->polygon_tree, screen, NULL, poly_callback, &info);
 
@@ -886,10 +886,10 @@ DrawLayerGroup (int group, const BoxType * screen)
 	  if (Layer->PolygonN)
 	    {
 	      info.Layer = Layer;
-	      info.arg = True;
+	      info.arg = true;
 	      r_search (Layer->polygon_tree, screen, NULL, poly_callback,
 			&info);
-	      info.arg = False;
+	      info.arg = false;
 	    }
 
 	  if (TEST_FLAG (CHECKPLANESFLAG, PCB))
@@ -989,7 +989,7 @@ DrawSpecialPolygon (hidGC DrawGC,
  * lowlevel drawing routine for pins and vias
  */
 static void
-DrawPinOrViaLowLevel (PinTypePtr Ptr, Boolean drawHole)
+DrawPinOrViaLowLevel (PinTypePtr Ptr, bool drawHole)
 {
   if (Gathering)
     {
@@ -1111,7 +1111,7 @@ DrawHole (PinTypePtr Ptr)
  * draw clearance in pixmask around pins and vias that pierce polygons
  */
 static void
-ClearOnlyPin (PinTypePtr Pin, Boolean mask)
+ClearOnlyPin (PinTypePtr Pin, bool mask)
 {
   BDimension half =
     (mask ? Pin->Mask / 2 : (Pin->Thickness + Pin->Clearance) / 2);
@@ -1211,7 +1211,7 @@ DrawPinOrViaNameLowLevel (PinTypePtr Ptr)
 {
   char *name;
   BoxType box;
-  Boolean vert;
+  bool vert;
   TextType text;
 
   if (!Ptr->Name || !Ptr->Name[0])
@@ -1271,7 +1271,7 @@ DrawPinOrViaNameLowLevel (PinTypePtr Ptr)
  */
 
 static void
-DrawPadLowLevel (hidGC gc, PadTypePtr Pad, Boolean clear, Boolean mask)
+DrawPadLowLevel (hidGC gc, PadTypePtr Pad, bool clear, bool mask)
 {
   int w = clear ? (mask ? Pad->Mask : Pad->Thickness + Pad->Clearance)
 		: Pad->Thickness;
@@ -1427,7 +1427,7 @@ DrawPadNameLowLevel (PadTypePtr Pad)
 {
   BoxType box;
   char *name;
-  Boolean vert;
+  bool vert;
   TextType text;
 
   if (!Pad->Name || !Pad->Name[0])
@@ -1493,16 +1493,16 @@ DrawPadNameLowLevel (PadTypePtr Pad)
  * clearance for pads
  */
 static void
-ClearPad (PadTypePtr Pad, Boolean mask)
+ClearPad (PadTypePtr Pad, bool mask)
 {
-  DrawPadLowLevel(Output.pmGC, Pad, True, mask);
+  DrawPadLowLevel(Output.pmGC, Pad, true, mask);
 }
 
 /* ---------------------------------------------------------------------------
  * lowlevel drawing routine for lines
  */
 static void
-DrawLineLowLevel (LineTypePtr Line, Boolean HaveGathered)
+DrawLineLowLevel (LineTypePtr Line, bool HaveGathered)
 {
   if (Gathering && !HaveGathered)
     {
@@ -1575,7 +1575,7 @@ DrawTextLowLevel (TextTypePtr Text, int min_line_width)
 	      newline.Point1.Y += Text->Y;
 	      newline.Point2.X += Text->X;
 	      newline.Point2.Y += Text->Y;
-	      DrawLineLowLevel (&newline, True);
+	      DrawLineLowLevel (&newline, true);
 	    }
 
 	  /* move on to next cursor position */
@@ -1661,7 +1661,7 @@ DrawElementPackageLowLevel (ElementTypePtr Element, int unused)
   /* draw lines, arcs, text and pins */
   ELEMENTLINE_LOOP (Element);
   {
-    DrawLineLowLevel (line, False);
+    DrawLineLowLevel (line, false);
   }
   END_LOOP;
   ARC_LOOP (Element);
@@ -1679,7 +1679,7 @@ DrawVia (PinTypePtr Via, int unused)
 {
   if (!Gathering)
     SetPVColor (Via, VIA_TYPE);
-  DrawPinOrViaLowLevel (Via, True);
+  DrawPinOrViaLowLevel (Via, true);
   if (!TEST_FLAG (HOLEFLAG, Via) && TEST_FLAG (DISPLAYNAMEFLAG, Via))
     DrawPinOrViaNameLowLevel (Via);
 }
@@ -1688,7 +1688,7 @@ DrawVia (PinTypePtr Via, int unused)
  * draw a via without dealing with polygon clearance 
  */
 static void
-DrawPlainVia (PinTypePtr Via, Boolean holeToo)
+DrawPlainVia (PinTypePtr Via, bool holeToo)
 {
   if (!Gathering)
     SetPVColor (Via, VIA_TYPE);
@@ -1722,7 +1722,7 @@ DrawPin (PinTypePtr Pin, int unused)
   {
     if (!Gathering)
       SetPVColor (Pin, PIN_TYPE);
-    DrawPinOrViaLowLevel (Pin, True);
+    DrawPinOrViaLowLevel (Pin, true);
   }
   if ((!TEST_FLAG (HOLEFLAG, Pin) && TEST_FLAG (DISPLAYNAMEFLAG, Pin))
       || doing_pinout)
@@ -1733,7 +1733,7 @@ DrawPin (PinTypePtr Pin, int unused)
  * draw a pin without clearing around polygons 
  */
 static void
-DrawPlainPin (PinTypePtr Pin, Boolean holeToo)
+DrawPlainPin (PinTypePtr Pin, bool holeToo)
 {
   if (!Gathering)
     SetPVColor (Pin, PIN_TYPE);
@@ -1782,7 +1782,7 @@ DrawPad (PadTypePtr Pad, int unused)
       else
 	gui->set_color (Output.fgGC, PCB->InvisibleObjectsColor);
     }
-  DrawPadLowLevel (Output.fgGC, Pad, False, False);
+  DrawPadLowLevel (Output.fgGC, Pad, false, false);
   if (doing_pinout || TEST_FLAG (DISPLAYNAMEFLAG, Pad))
     DrawPadNameLowLevel (Pad);
 }
@@ -1823,7 +1823,7 @@ DrawLine (LayerTypePtr Layer, LineTypePtr Line, int unused)
       else
 	gui->set_color (Output.fgGC, Layer->Color);
     }
-  DrawLineLowLevel (Line, False);
+  DrawLineLowLevel (Line, false);
 }
 
 /* ---------------------------------------------------------------------------
@@ -1872,7 +1872,7 @@ DrawRat (RatTypePtr Line, int unused)
 	}
     }
   else
-    DrawLineLowLevel ((LineTypePtr) Line, False);
+    DrawLineLowLevel ((LineTypePtr) Line, false);
 }
 
 /* ---------------------------------------------------------------------------
@@ -2099,7 +2099,7 @@ EraseVia (PinTypePtr Via)
 {
   Erasing++;
   gui->set_color (Output.fgGC, Settings.BackgroundColor);
-  DrawPinOrViaLowLevel (Via, False);
+  DrawPinOrViaLowLevel (Via, false);
   if (TEST_FLAG (DISPLAYNAMEFLAG, Via))
     DrawPinOrViaNameLowLevel (Via);
   Erasing--;
@@ -2125,7 +2125,7 @@ EraseRat (RatTypePtr Rat)
 		     w * 2, w * 2, 0, 360);
     }
   else
-    DrawLineLowLevel ((LineTypePtr) Rat, False);
+    DrawLineLowLevel ((LineTypePtr) Rat, false);
   Erasing--;
 }
 
@@ -2150,7 +2150,7 @@ ErasePad (PadTypePtr Pad)
 {
   Erasing++;
   gui->set_color (Output.fgGC, Settings.BackgroundColor);
-  DrawPadLowLevel (Output.fgGC, Pad, False, False);
+  DrawPadLowLevel (Output.fgGC, Pad, false, false);
   if (TEST_FLAG (DISPLAYNAMEFLAG, Pad))
     DrawPadNameLowLevel (Pad);
   Erasing--;
@@ -2176,7 +2176,7 @@ ErasePin (PinTypePtr Pin)
 {
   Erasing++;
   gui->set_color (Output.fgGC, Settings.BackgroundColor);
-  DrawPinOrViaLowLevel (Pin, False);
+  DrawPinOrViaLowLevel (Pin, false);
   if (TEST_FLAG (DISPLAYNAMEFLAG, Pin))
     DrawPinOrViaNameLowLevel (Pin);
   Erasing--;
@@ -2202,7 +2202,7 @@ EraseLine (LineTypePtr Line)
 {
   Erasing++;
   gui->set_color (Output.fgGC, Settings.BackgroundColor);
-  DrawLineLowLevel (Line, False);
+  DrawLineLowLevel (Line, false);
   Erasing--;
 }
 
@@ -2261,7 +2261,7 @@ EraseElement (ElementTypePtr Element)
   gui->set_color (Output.fgGC, Settings.BackgroundColor);
   ELEMENTLINE_LOOP (Element);
   {
-    DrawLineLowLevel (line, False);
+    DrawLineLowLevel (line, false);
   }
   END_LOOP;
   ARC_LOOP (Element);
@@ -2285,14 +2285,14 @@ EraseElementPinsAndPads (ElementTypePtr Element)
   gui->set_color (Output.fgGC, Settings.BackgroundColor);
   PIN_LOOP (Element);
   {
-    DrawPinOrViaLowLevel (pin, False);
+    DrawPinOrViaLowLevel (pin, false);
     if (TEST_FLAG (DISPLAYNAMEFLAG, pin))
       DrawPinOrViaNameLowLevel (pin);
   }
   END_LOOP;
   PAD_LOOP (Element);
   {
-    DrawPadLowLevel (Output.fgGC, pad, False, False);
+    DrawPadLowLevel (Output.fgGC, pad, false, false);
     if (TEST_FLAG (DISPLAYNAMEFLAG, pad))
       DrawPadNameLowLevel (pad);
   }
@@ -2420,8 +2420,8 @@ hid_expose_callback (HID * hid, BoxType * region, void *item)
   Output.bgGC = gui->make_gc ();
   Output.pmGC = gui->make_gc ();
 
-  render = True;
-  Gathering = False;
+  render = true;
+  Gathering = false;
 
   /*printf("\033[32mhid_expose_callback, s=%p %d\033[0m\n", &(SWAP_IDENT), SWAP_IDENT); */
 
@@ -2430,9 +2430,9 @@ hid_expose_callback (HID * hid, BoxType * region, void *item)
 
   if (item)
     {
-      doing_pinout = True;
+      doing_pinout = true;
       DrawElement (item, 0);
-      doing_pinout = False;
+      doing_pinout = false;
     }
   else
     DrawEverything (region);
@@ -2445,5 +2445,5 @@ hid_expose_callback (HID * hid, BoxType * region, void *item)
   Output.bgGC = savebg;
   Output.pmGC = savepm;
 
-  Gathering = True;
+  Gathering = true;
 }
diff --git a/src/draw.h b/src/draw.h
index 5d7c874..c0e23a3 100644
--- a/src/draw.h
+++ b/src/draw.h
@@ -33,7 +33,7 @@
 
 #include "global.h"
 
-/*Boolean	SwitchDrawingWindow(double, GdkDrawable *, gboolean, gboolean);*/
+/*bool	SwitchDrawingWindow(double, GdkDrawable *, gboolean, gboolean);*/
 
 void Draw (void);
 void RedrawOutput (BoxTypePtr area);
diff --git a/src/drill.c b/src/drill.c
index 455c524..738ed18 100644
--- a/src/drill.c
+++ b/src/drill.c
@@ -123,15 +123,15 @@ GetDrillInfo (DataTypePtr top)
   DrillInfoTypePtr AllDrills;
   DrillTypePtr Drill = NULL;
   DrillType savedrill, swapdrill;
-  Boolean DrillFound = False;
-  Boolean NewDrill;
+  bool DrillFound = false;
+  bool NewDrill;
 
   AllDrills = MyCalloc (1, sizeof (DrillInfoType), "GetAllDrillInfo()");
   ALLPIN_LOOP (top);
   {
     if (!DrillFound)
       {
-	DrillFound = True;
+	DrillFound = true;
 	Drill = GetDrillInfoDrillMemory (AllDrills);
 	InitializeDrill (Drill, pin, element);
       }
@@ -141,7 +141,7 @@ GetDrillInfo (DataTypePtr top)
 	  FillDrill (Drill, element, pin);
 	else
 	  {
-	    NewDrill = False;
+	    NewDrill = false;
 	    DRILL_LOOP (AllDrills);
 	    {
 	      if (drill->DrillSize == pin->DrillingHole)
@@ -154,7 +154,7 @@ GetDrillInfo (DataTypePtr top)
 		{
 		  if (!NewDrill)
 		    {
-		      NewDrill = True;
+		      NewDrill = true;
 		      InitializeDrill (&swapdrill, pin, element);
 		      Drill = GetDrillInfoDrillMemory (AllDrills);
 		      Drill->DrillSize = pin->DrillingHole + 1;
@@ -180,7 +180,7 @@ GetDrillInfo (DataTypePtr top)
   {
     if (!DrillFound)
       {
-	DrillFound = True;
+	DrillFound = true;
 	Drill = GetDrillInfoDrillMemory (AllDrills);
 	Drill->DrillSize = via->DrillingHole;
 	FillDrill (Drill, NULL, via);
diff --git a/src/file.c b/src/file.c
index 2704ede..3129601 100644
--- a/src/file.c
+++ b/src/file.c
@@ -122,7 +122,7 @@ static void WriteElementData (FILE *, DataTypePtr);
 static void WriteLayerData (FILE *, Cardinal, LayerTypePtr);
 static int WritePCB (FILE *);
 static int WritePCBFile (char *);
-static int WritePipe (char *, Boolean);
+static int WritePipe (char *, bool);
 static int ParseLibraryTree (void);
 static int LoadNewlibFootprintsFromDir(char *path, char *toppath);
 static char *pcb_basename (char *p);
@@ -211,8 +211,8 @@ sort_netlist ()
  * opens a file and check if it exists
  */
 FILE *
-CheckAndOpenFile (char *Filename, Boolean Confirm, Boolean AllButton,
-		  Boolean * WasAllButton, Boolean * WasCancelButton)
+CheckAndOpenFile (char *Filename, bool Confirm, bool AllButton,
+		  bool * WasAllButton, bool * WasCancelButton)
 {
   FILE *fp = NULL;
   struct stat buffer;
@@ -225,9 +225,9 @@ CheckAndOpenFile (char *Filename, Boolean Confirm, Boolean AllButton,
 	{
 	  sprintf (message, _("File '%s' exists, use anyway?"), Filename);
 	  if (WasAllButton)
-	    *WasAllButton = False;
+	    *WasAllButton = false;
 	  if (WasCancelButton)
-	    *WasCancelButton = False;
+	    *WasCancelButton = false;
 	  if (AllButton)
 	    response =
 	      gui->confirm_dialog (message, "Cancel", "Ok",
@@ -240,11 +240,11 @@ CheckAndOpenFile (char *Filename, Boolean Confirm, Boolean AllButton,
 	    {
 	    case 2:
 	      if (WasAllButton)
-		*WasAllButton = True;
+		*WasAllButton = true;
 	      break;
 	    case 0:
 	      if (WasCancelButton)
-		*WasCancelButton = True;
+		*WasCancelButton = true;
 	    }
 	}
       if ((fp = fopen (Filename, "w")) == NULL)
@@ -262,7 +262,7 @@ OpenConnectionDataFile (void)
   char *fname;
   FILE *fp;
   static char * default_file = NULL;
-  Boolean result;		/* not used */
+  bool result;		/* not used */
 
   /* CheckAndOpenFile deals with the case where fname already exists */
   fname = gui->fileselect (_("Save Connection Data As ..."),
@@ -281,7 +281,7 @@ OpenConnectionDataFile (void)
   if (fname && *fname)
     default_file = strdup (fname);
 
-  fp = CheckAndOpenFile (fname, True, False, &result, NULL);
+  fp = CheckAndOpenFile (fname, true, false, &result, NULL);
   free (fname);
 
   return fp;
@@ -297,7 +297,7 @@ SaveBufferElements (char *Filename)
 
   if (SWAP_IDENT)
     SwapBuffers ();
-  result = WritePipe (Filename, False);
+  result = WritePipe (Filename, false);
   if (SWAP_IDENT)
     SwapBuffers ();
   return (result);
@@ -312,7 +312,7 @@ SavePCB (char *Filename)
   int retcode;
   char *copy;
 
-  if (!(retcode = WritePipe (Filename, True)))
+  if (!(retcode = WritePipe (Filename, true)))
     {
       /* thanks to Nick Bailey for the bug-fix;
        * first of all make a copy of the passed filename because
@@ -321,7 +321,7 @@ SavePCB (char *Filename)
       copy = MyStrdup (Filename, "SavePCB()");
       SaveFree (PCB->Filename);
       PCB->Filename = copy;
-      SetChangedFlag (False);
+      SetChangedFlag (false);
     }
   return (retcode);
 }
@@ -337,8 +337,8 @@ set_some_route_style ()
   if (hid_get_flag ("style"))
     return;
   SetLineSize (PCB->RouteStyle[0].Thick);
-  SetViaSize (PCB->RouteStyle[0].Diameter, True);
-  SetViaDrillingHole (PCB->RouteStyle[0].Hole, True);
+  SetViaSize (PCB->RouteStyle[0].Diameter, true);
+  SetViaDrillingHole (PCB->RouteStyle[0].Hole, true);
   SetKeepawayWidth (PCB->RouteStyle[0].Keepaway);
 }
 
@@ -350,8 +350,8 @@ set_some_route_style ()
 int
 LoadPCB (char *Filename)
 {
-  PCBTypePtr newPCB = CreateNewPCB (False);
-  Boolean units_mm;
+  PCBTypePtr newPCB = CreateNewPCB (false);
+  bool units_mm;
   clock_t start, end;
   double elapsed;
 
@@ -387,11 +387,11 @@ LoadPCB (char *Filename)
 	}
 
       /* clear 'changed flag' */
-      SetChangedFlag (False);
+      SetChangedFlag (false);
       PCB->Filename = MyStrdup (Filename, "LoadPCB()");
       /* just in case a bad file saved file is loaded */
 
-      units_mm = (PCB->Grid != (int) PCB->Grid) ? True : False;
+      units_mm = (PCB->Grid != (int) PCB->Grid) ? true : false;
 
       Settings.grid_units_mm = units_mm;
 
@@ -900,7 +900,7 @@ WritePCBFile (char *Filename)
  * %f are replaced by the passed filename
  */
 static int
-WritePipe (char *Filename, Boolean thePcb)
+WritePipe (char *Filename, bool thePcb)
 {
   FILE *fp;
   int result;
@@ -976,7 +976,7 @@ SaveInTMP (void)
  * front-end for 'SaveInTMP()'
  * just makes sure that the routine is only called once
  */
-static Boolean dont_save_any_more = False;
+static bool dont_save_any_more = false;
 void
 EmergencySave (void)
 {
@@ -984,14 +984,14 @@ EmergencySave (void)
   if (!dont_save_any_more)
     {
       SaveInTMP ();
-      dont_save_any_more = True;
+      dont_save_any_more = true;
     }
 }
 
  void 
 DisableEmergencySave (void)
 {
-  dont_save_any_more = True;
+  dont_save_any_more = true;
 }
 
 /* ----------------------------------------------------------------------
@@ -1429,7 +1429,7 @@ ReadNetlist (char *filename)
   LibraryMenuTypePtr menu = NULL;
   LibraryEntryTypePtr entry;
   int i, j, lines, kind;
-  Boolean continued;
+  bool continued;
   int used_popen = 0;
 
   if (!filename)
@@ -1479,7 +1479,7 @@ ReadNetlist (char *filename)
 	  else
 	    inputline[len] = '\0';
 	}
-      continued = (inputline[len - 1] == '\\') ? True : False;
+      continued = (inputline[len - 1] == '\\') ? true : false;
       if (continued)
 	inputline[len - 1] = '\0';
       lines++;
diff --git a/src/file.h b/src/file.h
index 64eba23..5791dda 100644
--- a/src/file.h
+++ b/src/file.h
@@ -33,7 +33,7 @@
 #include <stdio.h>		/* needed to define 'FILE *' */
 #include "global.h"
 
-FILE *CheckAndOpenFile (char *, Boolean, Boolean, Boolean *, Boolean *);
+FILE *CheckAndOpenFile (char *, bool, bool, bool *, bool *);
 FILE *OpenConnectionDataFile (void);
 int SavePCB (char *);
 int LoadPCB (char *);
diff --git a/src/find.c b/src/find.c
index 6fb62b6..593be70 100644
--- a/src/find.c
+++ b/src/find.c
@@ -310,9 +310,9 @@ static int TheFlag = FOUNDFLAG;
 static int OldFlag = FOUNDFLAG;
 static void *thing_ptr1, *thing_ptr2, *thing_ptr3;
 static int thing_type;
-static Boolean User = False;    /* user action causing this */
-static Boolean drc = False;     /* whether to stop if finding something not found */
-static Boolean IsBad = False;
+static bool User = false;    /* user action causing this */
+static bool drc = false;     /* whether to stop if finding something not found */
+static bool IsBad = false;
 static Cardinal drcerr_count;   /* count of drc errors */
 static Cardinal TotalP, TotalV, NumberOfPads[2];
 static ListType LineList[MAX_LAYER],    /* list of objects to */
@@ -321,58 +321,58 @@ static ListType LineList[MAX_LAYER],    /* list of objects to */
 /* ---------------------------------------------------------------------------
  * some local prototypes
  */
-static Boolean LookupLOConnectionsToPVList (Boolean);
-static Boolean LookupLOConnectionsToLOList (Boolean);
-static Boolean LookupPVConnectionsToLOList (Boolean);
-static Boolean LookupPVConnectionsToPVList (void);
-static Boolean LookupLOConnectionsToLine (LineTypePtr, Cardinal, Boolean);
-static Boolean LookupLOConnectionsToPad (PadTypePtr, Cardinal);
-static Boolean LookupLOConnectionsToPolygon (PolygonTypePtr, Cardinal);
-static Boolean LookupLOConnectionsToArc (ArcTypePtr, Cardinal);
-static Boolean LookupLOConnectionsToRatEnd (PointTypePtr, Cardinal);
-static Boolean IsRatPointOnLineEnd (PointTypePtr, LineTypePtr);
-static Boolean ArcArcIntersect (ArcTypePtr, ArcTypePtr);
-static Boolean PrepareNextLoop (FILE *);
-static Boolean PrintElementConnections (ElementTypePtr, FILE *, Boolean);
-static Boolean ListsEmpty (Boolean);
-static Boolean DoIt (Boolean, Boolean);
+static bool LookupLOConnectionsToPVList (bool);
+static bool LookupLOConnectionsToLOList (bool);
+static bool LookupPVConnectionsToLOList (bool);
+static bool LookupPVConnectionsToPVList (void);
+static bool LookupLOConnectionsToLine (LineTypePtr, Cardinal, bool);
+static bool LookupLOConnectionsToPad (PadTypePtr, Cardinal);
+static bool LookupLOConnectionsToPolygon (PolygonTypePtr, Cardinal);
+static bool LookupLOConnectionsToArc (ArcTypePtr, Cardinal);
+static bool LookupLOConnectionsToRatEnd (PointTypePtr, Cardinal);
+static bool IsRatPointOnLineEnd (PointTypePtr, LineTypePtr);
+static bool ArcArcIntersect (ArcTypePtr, ArcTypePtr);
+static bool PrepareNextLoop (FILE *);
+static bool PrintElementConnections (ElementTypePtr, FILE *, bool);
+static bool ListsEmpty (bool);
+static bool DoIt (bool, bool);
 static void PrintElementNameList (ElementTypePtr, FILE *);
 static void PrintConnectionElementName (ElementTypePtr, FILE *);
 static void PrintConnectionListEntry (char *, ElementTypePtr,
-                                      Boolean, FILE *);
-static void PrintPadConnections (Cardinal, FILE *, Boolean);
-static void PrintPinConnections (FILE *, Boolean);
-static Boolean PrintAndSelectUnusedPinsAndPadsOfElement (ElementTypePtr,
+                                      bool, FILE *);
+static void PrintPadConnections (Cardinal, FILE *, bool);
+static void PrintPinConnections (FILE *, bool);
+static bool PrintAndSelectUnusedPinsAndPadsOfElement (ElementTypePtr,
                                                          FILE *);
 static void DrawNewConnections (void);
-static void ResetConnections (Boolean);
+static void ResetConnections (bool);
 static void DumpList (void);
 static void LocateError (LocationType *, LocationType *);
 static void BuildObjectList (int *, long int **, int **);
 static void GotoError (void);
-static Boolean DRCFind (int, void *, void *, void *);
-static Boolean ListStart (int, void *, void *, void *);
-static Boolean LOTouchesLine (LineTypePtr Line, Cardinal LayerGroup);
-static Boolean PVTouchesLine (LineTypePtr line);
-static Boolean SetThing (int, void *, void *, void *);
+static bool DRCFind (int, void *, void *, void *);
+static bool ListStart (int, void *, void *, void *);
+static bool LOTouchesLine (LineTypePtr Line, Cardinal LayerGroup);
+static bool PVTouchesLine (LineTypePtr line);
+static bool SetThing (int, void *, void *, void *);
 
 /* ---------------------------------------------------------------------------
  * some of the 'pad' routines are the same as for lines because the 'pad'
  * struct starts with a line struct. See global.h for details
  */
-Boolean
+bool
 LinePadIntersect (LineTypePtr Line, PadTypePtr Pad)
 {
   return LineLineIntersect ((Line), (LineTypePtr)Pad);
 }
 
-Boolean
+bool
 ArcPadIntersect (ArcTypePtr Arc, PadTypePtr Pad)
 {
   return LineArcIntersect ((LineTypePtr) (Pad), (Arc));
 }
 
-static Boolean
+static bool
 ADD_PV_TO_LIST (PinTypePtr Pin)
 {
   if (User)
@@ -388,10 +388,10 @@ ADD_PV_TO_LIST (PinTypePtr Pin)
 #endif
   if (drc && !TEST_FLAG (SELECTEDFLAG, Pin))
     return (SetThing (PIN_TYPE, Pin->Element, Pin, Pin));
-  return False;
+  return false;
 }
 
-static Boolean
+static bool
 ADD_PAD_TO_LIST (Cardinal L, PadTypePtr Pad)
 {
   if (User)
@@ -406,10 +406,10 @@ ADD_PAD_TO_LIST (Cardinal L, PadTypePtr Pad)
 #endif
   if (drc && !TEST_FLAG (SELECTEDFLAG, Pad))
     return (SetThing (PAD_TYPE, Pad->Element, Pad, Pad));
-  return False;
+  return false;
 }
 
-static Boolean
+static bool
 ADD_LINE_TO_LIST (Cardinal L, LineTypePtr Ptr)
 {
   if (User)
@@ -424,10 +424,10 @@ ADD_LINE_TO_LIST (Cardinal L, LineTypePtr Ptr)
 #endif
   if (drc && !TEST_FLAG (SELECTEDFLAG, (Ptr)))
     return (SetThing (LINE_TYPE, LAYER_PTR (L), (Ptr), (Ptr)));
-  return False;
+  return false;
 }
 
-static Boolean
+static bool
 ADD_ARC_TO_LIST (Cardinal L, ArcTypePtr Ptr)
 {
   if (User)
@@ -442,10 +442,10 @@ ADD_ARC_TO_LIST (Cardinal L, ArcTypePtr Ptr)
 #endif
   if (drc && !TEST_FLAG (SELECTEDFLAG, (Ptr)))
     return (SetThing (ARC_TYPE, LAYER_PTR (L), (Ptr), (Ptr)));
-  return False;
+  return false;
 }
 
-static Boolean
+static bool
 ADD_RAT_TO_LIST (RatTypePtr Ptr)
 {
   if (User)
@@ -460,10 +460,10 @@ ADD_RAT_TO_LIST (RatTypePtr Ptr)
 #endif
   if (drc && !TEST_FLAG (SELECTEDFLAG, (Ptr)))
     return (SetThing (RATLINE_TYPE, (Ptr), (Ptr), (Ptr)));
-  return False;
+  return false;
 }
 
-static Boolean
+static bool
 ADD_POLYGON_TO_LIST (Cardinal L, PolygonTypePtr Ptr)
 {
   if (User)
@@ -478,10 +478,10 @@ ADD_POLYGON_TO_LIST (Cardinal L, PolygonTypePtr Ptr)
 #endif
   if (drc && !TEST_FLAG (SELECTEDFLAG, (Ptr)))
     return (SetThing (POLYGON_TYPE, LAYER_PTR (L), (Ptr), (Ptr)));
-  return False;
+  return false;
 }
 
-Boolean
+bool
 PinLineIntersect (PinTypePtr PV, LineTypePtr Line)
 {
   /* IsLineInRectangle already has Bloat factor */
@@ -502,7 +502,7 @@ PinLineIntersect (PinTypePtr PV, LineTypePtr Line)
 }
 
 
-Boolean
+bool
 SetThing (int type, void *ptr1, void *ptr2, void *ptr3)
 {
   thing_ptr1 = ptr1;
@@ -514,26 +514,26 @@ SetThing (int type, void *ptr1, void *ptr2, void *ptr3)
       thing_ptr1 = ptr3;
       thing_type = VIA_TYPE;
     }
-  return True;
+  return true;
 }
 
-Boolean
+bool
 BoxBoxIntersection (BoxTypePtr b1, BoxTypePtr b2)
 {
   if (b2->X2 < b1->X1 || b2->X1 > b1->X2)
-    return False;
+    return false;
   if (b2->Y2 < b1->Y1 || b2->Y1 > b1->Y2)
-    return False;
-  return True;
+    return false;
+  return true;
 }
 
-static Boolean
+static bool
 PadPadIntersect (PadTypePtr p1, PadTypePtr p2)
 {
   return LinePadIntersect ((LineTypePtr) p1, p2);
 }
       
-static inline Boolean
+static inline bool
 PV_TOUCH_PV (PinTypePtr PV1, PinTypePtr PV2)
 {
   float t1, t2;
@@ -543,9 +543,9 @@ PV_TOUCH_PV (PinTypePtr PV1, PinTypePtr PV2)
   t2 = MAX (PV2->Thickness / 2.0 + fBloat, 0);
   if (IsPointOnPin (PV1->X, PV1->Y, t1, PV2)
       || IsPointOnPin (PV2->X, PV2->Y, t2, PV1))
-    return True;
+    return true;
   if (!TEST_FLAG (SQUAREFLAG, PV1) || !TEST_FLAG (SQUAREFLAG, PV2))
-    return False;
+    return false;
   /* check for square/square overlap */
   b1.X1 = PV1->X - t1;
   b1.X2 = PV1->X + t1;
@@ -787,7 +787,7 @@ LOCtoPVpoly_callback (const BoxType * b, void *cl)
       else if (TEST_FLAG (OCTAGONFLAG, &i->pv))
         {
           POLYAREA *oct = OctagonPoly (i->pv.X, i->pv.Y, i->pv.Thickness / 2);
-          if (isects (oct, polygon, True)
+          if (isects (oct, polygon, true)
               && ADD_POLYGON_TO_LIST (i->layer, polygon))
             longjmp (i->env, 1);
         }
@@ -803,8 +803,8 @@ LOCtoPVpoly_callback (const BoxType * b, void *cl)
  * checks if a PV is connected to LOs, if it is, the LO is added to
  * the appropriate list and the 'used' flag is set
  */
-static Boolean
-LookupLOConnectionsToPVList (Boolean AndRats)
+static bool
+LookupLOConnectionsToPVList (bool AndRats)
 {
   Cardinal layer;
   struct pv_info info;
@@ -821,7 +821,7 @@ LookupLOConnectionsToPVList (Boolean AndRats)
         r_search (PCB->Data->pad_tree, (BoxType *) & info.pv, NULL,
                   LOCtoPVpad_callback, &info);
       else
-        return True;
+        return true;
 
       /* now all lines, arcs and polygons of the several layers */
       for (layer = 0; layer < max_layer; layer++)
@@ -832,19 +832,19 @@ LookupLOConnectionsToPVList (Boolean AndRats)
             r_search (LAYER_PTR (layer)->line_tree, (BoxType *) & info.pv,
                       NULL, LOCtoPVline_callback, &info);
           else
-            return True;
+            return true;
           /* add touching arcs */
           if (setjmp (info.env) == 0)
             r_search (LAYER_PTR (layer)->arc_tree, (BoxType *) & info.pv,
                       NULL, LOCtoPVarc_callback, &info);
           else
-            return True;
+            return true;
           /* check all polygons */
           if (setjmp (info.env) == 0)
             r_search (LAYER_PTR (layer)->polygon_tree, (BoxType *) & info.pv,
                       NULL, LOCtoPVpoly_callback, &info);
           else
-            return True;
+            return true;
         }
       /* Check for rat-lines that may intersect the PV */
       if (AndRats)
@@ -853,20 +853,20 @@ LookupLOConnectionsToPVList (Boolean AndRats)
             r_search (PCB->Data->rat_tree, (BoxType *) & info.pv, NULL,
                       LOCtoPVrat_callback, &info);
           else
-            return True;
+            return true;
         }
       PVList.Location++;
     }
-  return False;
+  return false;
 }
 
 /* ---------------------------------------------------------------------------
  * find all connections between LO at the current list position and new LOs
  */
-static Boolean
-LookupLOConnectionsToLOList (Boolean AndRats)
+static bool
+LookupLOConnectionsToLOList (bool AndRats)
 {
-  Boolean done;
+  bool done;
   Cardinal i, group, layer, ratposition,
     lineposition[MAX_LAYER],
     polyposition[MAX_LAYER], arcposition[MAX_LAYER], padposition[2];
@@ -900,11 +900,11 @@ LookupLOConnectionsToLOList (Boolean AndRats)
               group = RATLIST_ENTRY (*position)->group1;
               if (LookupLOConnectionsToRatEnd
                   (&(RATLIST_ENTRY (*position)->Point1), group))
-                return (True);
+                return (true);
               group = RATLIST_ENTRY (*position)->group2;
               if (LookupLOConnectionsToRatEnd
                   (&(RATLIST_ENTRY (*position)->Point2), group))
-                return (True);
+                return (true);
             }
         }
       /* loop over all layergroups */
@@ -925,22 +925,22 @@ LookupLOConnectionsToLOList (Boolean AndRats)
                   position = &lineposition[layer];
                   for (; *position < LineList[layer].Number; (*position)++)
                     if (LookupLOConnectionsToLine
-                        (LINELIST_ENTRY (layer, *position), group, True))
-                      return (True);
+                        (LINELIST_ENTRY (layer, *position), group, true))
+                      return (true);
 
                   /* try all new arcs */
                   position = &arcposition[layer];
                   for (; *position < ArcList[layer].Number; (*position)++)
                     if (LookupLOConnectionsToArc
                         (ARCLIST_ENTRY (layer, *position), group))
-                      return (True);
+                      return (true);
 
                   /* try all new polygons */
                   position = &polyposition[layer];
                   for (; *position < PolygonList[layer].Number; (*position)++)
                     if (LookupLOConnectionsToPolygon
                         (POLYGONLIST_ENTRY (layer, *position), group))
-                      return (True);
+                      return (true);
                 }
               else
                 {
@@ -950,13 +950,13 @@ LookupLOConnectionsToLOList (Boolean AndRats)
                     {
                       Message (_("bad layer number %d max_layer=%d in find.c\n"),
                                layer, max_layer);
-                      return False;
+                      return false;
                     }
                   position = &padposition[layer];
                   for (; *position < PadList[layer].Number; (*position)++)
                     if (LookupLOConnectionsToPad
                         (PADLIST_ENTRY (layer, *position), group))
-                      return (True);
+                      return (true);
                 }
             }
         }
@@ -979,7 +979,7 @@ LookupLOConnectionsToLOList (Boolean AndRats)
         }
     }
   while (!done);
-  return (False);
+  return (false);
 }
 
 static int
@@ -993,7 +993,7 @@ pv_pv_callback (const BoxType * b, void *cl)
       if (TEST_FLAG (HOLEFLAG, pin))
         {
           SET_FLAG (WARNFLAG, pin);
-          Settings.RatWarn = True;
+          Settings.RatWarn = true;
           if (pin->Element)
             Message (_("WARNING: Hole too close to pin.\n"));
           else
@@ -1008,7 +1008,7 @@ pv_pv_callback (const BoxType * b, void *cl)
 /* ---------------------------------------------------------------------------
  * searches for new PVs that are connected to PVs on the list
  */
-static Boolean
+static bool
 LookupPVConnectionsToPVList (void)
 {
   Cardinal save_place;
@@ -1026,16 +1026,16 @@ LookupPVConnectionsToPVList (void)
         r_search (PCB->Data->via_tree, (BoxType *) & info.pv, NULL,
                   pv_pv_callback, &info);
       else
-        return True;
+        return true;
       if (setjmp (info.env) == 0)
         r_search (PCB->Data->pin_tree, (BoxType *) & info.pv, NULL,
                   pv_pv_callback, &info);
       else
-        return True;
+        return true;
       PVList.Location++;
     }
   PVList.Location = save_place;
-  return (False);
+  return (false);
 }
 
 struct lo_info
@@ -1060,7 +1060,7 @@ pv_line_callback (const BoxType * b, void *cl)
       if (TEST_FLAG (HOLEFLAG, pv))
         {
           SET_FLAG (WARNFLAG, pv);
-          Settings.RatWarn = True;
+          Settings.RatWarn = true;
           Message (_("WARNING: Hole too close to line.\n"));
         }
       if (ADD_PV_TO_LIST (pv))
@@ -1080,7 +1080,7 @@ pv_pad_callback (const BoxType * b, void *cl)
       if (TEST_FLAG (HOLEFLAG, pv))
         {
           SET_FLAG (WARNFLAG, pv);
-          Settings.RatWarn = True;
+          Settings.RatWarn = true;
           Message (_("WARNING: Hole too close to pad.\n"));
         }
       if (ADD_PV_TO_LIST (pv))
@@ -1100,7 +1100,7 @@ pv_arc_callback (const BoxType * b, void *cl)
       if (TEST_FLAG (HOLEFLAG, pv))
         {
           SET_FLAG (WARNFLAG, pv);
-          Settings.RatWarn = True;
+          Settings.RatWarn = true;
           Message (_("WARNING: Hole touches arc.\n"));
         }
       if (ADD_PV_TO_LIST (pv))
@@ -1134,7 +1134,7 @@ pv_poly_callback (const BoxType * b, void *cl)
       else if (TEST_FLAG (OCTAGONFLAG, pv))
         {
           POLYAREA *oct = OctagonPoly (pv->X, pv->Y, pv->Thickness / 2);
-          if (isects (oct, &i->polygon, True) && ADD_PV_TO_LIST (pv))
+          if (isects (oct, &i->polygon, true) && ADD_PV_TO_LIST (pv))
             longjmp (i->env, 1);
         }
       else
@@ -1164,8 +1164,8 @@ pv_rat_callback (const BoxType * b, void *cl)
  * searches for new PVs that are connected to NEW LOs on the list
  * This routine updates the position counter of the lists too.
  */
-static Boolean
-LookupPVConnectionsToLOList (Boolean AndRats)
+static bool
+LookupPVConnectionsToLOList (bool AndRats)
 {
   Cardinal layer;
   struct lo_info info;
@@ -1191,12 +1191,12 @@ LookupPVConnectionsToLOList (Boolean AndRats)
             r_search (PCB->Data->via_tree, (BoxType *) & info.line, NULL,
                       pv_line_callback, &info);
           else
-            return True;
+            return true;
           if (setjmp (info.env) == 0)
             r_search (PCB->Data->pin_tree, (BoxType *) & info.line, NULL,
                       pv_line_callback, &info);
           else
-            return True;
+            return true;
           LineList[layer].Location++;
         }
 
@@ -1209,12 +1209,12 @@ LookupPVConnectionsToLOList (Boolean AndRats)
             r_search (PCB->Data->via_tree, (BoxType *) & info.arc, NULL,
                       pv_arc_callback, &info);
           else
-            return True;
+            return true;
           if (setjmp (info.env) == 0)
             r_search (PCB->Data->pin_tree, (BoxType *) & info.arc, NULL,
                       pv_arc_callback, &info);
           else
-            return True;
+            return true;
           ArcList[layer].Location++;
         }
 
@@ -1229,12 +1229,12 @@ LookupPVConnectionsToLOList (Boolean AndRats)
             r_search (PCB->Data->via_tree, (BoxType *) & info.polygon, NULL,
                       pv_poly_callback, &info);
           else
-            return True;
+            return true;
           if (setjmp (info.env) == 0)
             r_search (PCB->Data->pin_tree, (BoxType *) & info.polygon, NULL,
                       pv_poly_callback, &info);
           else
-            return True;
+            return true;
           PolygonList[layer].Location++;
         }
     }
@@ -1260,12 +1260,12 @@ LookupPVConnectionsToLOList (Boolean AndRats)
             r_search (PCB->Data->via_tree, (BoxType *) & info.pad, NULL,
                       pv_pad_callback, &info);
           else
-            return True;
+            return true;
           if (setjmp (info.env) == 0)
             r_search (PCB->Data->pin_tree, (BoxType *) & info.pad, NULL,
                       pv_pad_callback, &info);
           else
-            return True;
+            return true;
           PadList[layer].Location++;
         }
     }
@@ -1292,7 +1292,7 @@ LookupPVConnectionsToLOList (Boolean AndRats)
           RatList.Location++;
         }
     }
-  return (False);
+  return (false);
 }
 
 int
@@ -1306,7 +1306,7 @@ pv_touch_callback (const BoxType * b, void *cl)
   return 0;
 }
 
-static Boolean
+static bool
 PVTouchesLine (LineTypePtr line)
 {
   struct lo_info info;
@@ -1317,14 +1317,14 @@ PVTouchesLine (LineTypePtr line)
     r_search (PCB->Data->via_tree, (BoxType *) & info.line, NULL,
               pv_touch_callback, &info);
   else
-    return True;
+    return true;
   if (setjmp (info.env) == 0)
     r_search (PCB->Data->pin_tree, (BoxType *) & info.line, NULL,
               pv_touch_callback, &info);
   else
-    return True;
+    return true;
 
-  return (False);
+  return (false);
 }
 
 /* reduce arc start angle and delta to 0..360 */
@@ -1402,7 +1402,7 @@ get_arc_ends (double *box, ArcTypePtr arc)
  *
  *
  */
-static Boolean
+static bool
 ArcArcIntersect (ArcTypePtr Arc1, ArcTypePtr Arc2)
 {
   double x, y, dx, dy, r1, r2, a, d, l, t, t1, t2, dl;
@@ -1411,21 +1411,21 @@ ArcArcIntersect (ArcTypePtr Arc1, ArcTypePtr Arc2)
 
   t = 0.5 * Arc1->Thickness + fBloat;
   if (t < 0) /* too thin arc */
-    return (False);
+    return (false);
   t2 = 0.5 * Arc2->Thickness;
   t1 = t2 + fBloat;
   if (t1 < 0) /* too thin arc */
-    return (False);
+    return (false);
   /* try the end points first */
   get_arc_ends (box, Arc1);
   if (IsPointOnArc ((float) box[0], (float) box[1], (float)t, Arc2)
       || IsPointOnArc ((float) box[2], (float) box[3], (float)t, Arc2))
-    return (True);
+    return (true);
 
   get_arc_ends (box, Arc2);
   if (IsPointOnArc ((float) box[0], (float) box[1], (float)t1, Arc1)
       || IsPointOnArc ((float) box[2], (float) box[3], (float)t1, Arc1))
-    return (True);
+    return (true);
   pdx = Arc2->X - Arc1->X;
   pdy = Arc2->Y - Arc1->Y;
   l = pdx * pdx + pdy * pdy;
@@ -1449,19 +1449,19 @@ ArcArcIntersect (ArcTypePtr Arc1, ArcTypePtr Arc2)
 	  if (sa1 > sa2)
 	    {
 	      if (sa1 < sa2 + d2)
-		return (True);
+		return (true);
 	      if (sa1 + d1 > 360 && sa1 + d1 - 360 > sa2)
-		return (True);
+		return (true);
 	    }
 	  if (sa2 > sa1)
 	    {
 	      if (sa2 < sa1 + d1)
-		return (True);
+		return (true);
 	      if (sa2 + d2 > 360 && sa2 + d2 - 360 > sa1)
-		return (True);
+		return (true);
 	    }
         }
-      return (False);
+      return (false);
     }
   r1 = Arc1->Width;
   r2 = Arc2->Width;
@@ -1481,7 +1481,7 @@ ArcArcIntersect (ArcTypePtr Arc1, ArcTypePtr Arc2)
       if (radius_crosses_arc (Arc1->X + dx, Arc1->Y + dy, Arc1)
 	  && IsPointOnArc ((float)(Arc1->X + dx), (float)(Arc1->Y + dy),
 			   (float)t, Arc2))
-	return (True);
+	return (true);
 
       dx = - pdx * r2 / dl;
       dy = - pdy * r2 / dl;
@@ -1494,8 +1494,8 @@ ArcArcIntersect (ArcTypePtr Arc1, ArcTypePtr Arc2)
       if (radius_crosses_arc (Arc2->X + dx, Arc2->Y + dy, Arc2)
 	  && IsPointOnArc ((float)(Arc2->X + dx), (float)(Arc2->Y + dy),
 			   (float)t1, Arc1))
-	return (True);
-      return (False);
+	return (true);
+      return (false);
     }
 
   r1 *= r1;
@@ -1515,31 +1515,31 @@ ArcArcIntersect (ArcTypePtr Arc1, ArcTypePtr Arc2)
   dy = d * pdy;
   if (radius_crosses_arc (x + dy, y - dx, Arc1)
       && IsPointOnArc ((float)(x + dy), (float)(y - dx), (float)t, Arc2))
-    return (True);
+    return (true);
   if (radius_crosses_arc (x + dy, y - dx, Arc2)
       && IsPointOnArc ((float)(x + dy), (float)(y - dx), (float)t1, Arc1))
-    return (True);
+    return (true);
 
   if (radius_crosses_arc (x - dy, y + dx, Arc1)
       && IsPointOnArc ((float)(x - dy), (float)(y + dx), (float)t, Arc2))
-    return (True);
+    return (true);
   if (radius_crosses_arc (x - dy, y + dx, Arc2)
       && IsPointOnArc ((float)(x - dy), (float)(y + dx), (float)t1, Arc1))
-    return (True);
-  return (False);
+    return (true);
+  return (false);
 }
 
 /* ---------------------------------------------------------------------------
  * Tests if point is same as line end point
  */
-static Boolean
+static bool
 IsRatPointOnLineEnd (PointTypePtr Point, LineTypePtr Line)
 {
   if ((Point->X == Line->Point1.X
        && Point->Y == Line->Point1.Y)
       || (Point->X == Line->Point2.X && Point->Y == Line->Point2.Y))
-    return (True);
-  return (False);
+    return (true);
+  return (false);
 }
 
 static void 
@@ -1621,7 +1621,7 @@ form_slanted_rectangle(PointType p[4],LineTypePtr l)
  *  Also note that the denominators of eqn 1 & 2 are identical.
  *
  */
-Boolean
+bool
 LineLineIntersect (LineTypePtr Line1, LineTypePtr Line2)
 {
   register float dx, dy, dx1, dy1, s, r;
@@ -1644,7 +1644,7 @@ LineLineIntersect (LineTypePtr Line1, LineTypePtr Line2)
       || Line1->BoundingBox.X2 + Bloat < Line2->BoundingBox.X1
       || Line1->BoundingBox.Y1 - Bloat < Line2->BoundingBox.Y2
       || Line1->BoundingBox.Y2 + Bloat < Line2->BoundingBox.Y1)
-    return False;
+    return false;
 #endif
 
   /* setup some constants */
@@ -1686,7 +1686,7 @@ LineLineIntersect (LineTypePtr Line1, LineTypePtr Line2)
              (Line1->Thickness + Line2->Thickness) + fBloat, 0.0);
       distance *= distance;
       if (s > distance)
-        return (False);
+        return (false);
       if (IsPointInPad (Line2->Point1.
                                X,
                                Line2->Point1.
@@ -1704,7 +1704,7 @@ LineLineIntersect (LineTypePtr Line1, LineTypePtr Line2)
                                   MAX (Line2->
                                        Thickness
                                        / 2 + Bloat, 0), (PadTypePtr) Line1))
-        return (True);
+        return (true);
       return ((IsPointInPad (Line1->Point1.
                                X,
                                Line1->Point1.
@@ -1736,7 +1736,7 @@ LineLineIntersect (LineTypePtr Line1, LineTypePtr Line2)
       if (r >= 0.0 && r <= 1.0)
         {
           if (s >= 0.0 && s <= 1.0)
-            return (True);
+            return (true);
 
           /* intersection on AB and extension of CD */
           return (s < 0.0 ?
@@ -1775,13 +1775,13 @@ LineLineIntersect (LineTypePtr Line1, LineTypePtr Line2)
        */
       if (IsPointInPad (Line1->Point1.X, Line1->Point1.Y,
                          Line1->Thickness / 2.0 + fBloat, (PadTypePtr)Line2))
-        return True;
+        return true;
       if (IsPointInPad (Line1->Point2.X, Line1->Point2.Y,
                          Line1->Thickness / 2.0 + fBloat, (PadTypePtr)Line2))
-        return True;
+        return true;
       if (IsPointInPad (Line2->Point1.X, Line2->Point1.Y,
                          Line2->Thickness / 2.0 + fBloat, (PadTypePtr)Line1))
-        return True;
+        return true;
       return IsPointInPad (Line2->Point2.X, Line2->Point2.Y,
                             Line2->Thickness / 2.0 + fBloat, (PadTypePtr)Line1);
     }
@@ -1816,7 +1816,7 @@ LineLineIntersect (LineTypePtr Line1, LineTypePtr Line2)
  *
  * The end points are hell so they are checked individually
  */
-Boolean
+bool
 LineArcIntersect (LineTypePtr Line, ArcTypePtr Arc)
 {
   register float dx, dy, dx1, dy1, l, d, r, r2, Radius;
@@ -1837,19 +1837,19 @@ LineArcIntersect (LineTypePtr Line, ArcTypePtr Arc)
   r2 = Radius * l - d;
   /* projection doesn't even intersect circle when r2 < 0 */
   if (r2 < 0)
-    return (False);
+    return (false);
   /* check the ends of the line in case the projected point */
   /* of intersection is beyond the line end */
   if (IsPointOnArc
       (Line->Point1.X, Line->Point1.Y,
        MAX (0.5 * Line->Thickness + fBloat, 0.0), Arc))
-    return (True);
+    return (true);
   if (IsPointOnArc
       (Line->Point2.X, Line->Point2.Y,
        MAX (0.5 * Line->Thickness + fBloat, 0.0), Arc))
-    return (True);
+    return (true);
   if (l == 0.0)
-    return (False);
+    return (false);
   r2 = sqrt (r2);
   Radius = -(dx * dx1 + dy * dy1);
   r = (Radius + r2) / l;
@@ -1857,20 +1857,20 @@ LineArcIntersect (LineTypePtr Line, ArcTypePtr Arc)
       && IsPointOnArc (Line->Point1.X + r * dx,
                        Line->Point1.Y + r * dy,
                        MAX (0.5 * Line->Thickness + fBloat, 0.0), Arc))
-    return (True);
+    return (true);
   r = (Radius - r2) / l;
   if (r >= 0 && r <= 1
       && IsPointOnArc (Line->Point1.X + r * dx,
                        Line->Point1.Y + r * dy,
                        MAX (0.5 * Line->Thickness + fBloat, 0.0), Arc))
-    return (True);
+    return (true);
   /* check arc end points */
   box = GetArcEnds (Arc);
   if (IsPointInPad (box->X1, box->Y1, Arc->Thickness * 0.5 + fBloat, (PadTypePtr)Line))
-    return True;
+    return true;
   if (IsPointInPad (box->X2, box->Y2, Arc->Thickness * 0.5 + fBloat, (PadTypePtr)Line))
-    return True;
-  return False;
+    return true;
+  return false;
 }
 
 static int
@@ -1923,7 +1923,7 @@ LOCtoArcPad_callback (const BoxType * b, void *cl)
  * the notation that is used is:
  * Xij means Xj at arc i
  */
-static Boolean
+static bool
 LookupLOConnectionsToArc (ArcTypePtr Arc, Cardinal LayerGroup)
 {
   Cardinal entry;
@@ -1954,13 +1954,13 @@ LookupLOConnectionsToArc (ArcTypePtr Arc, Cardinal LayerGroup)
             r_search (LAYER_PTR (layer)->line_tree, &info.arc.BoundingBox,
                       NULL, LOCtoArcLine_callback, &info);
           else
-            return True;
+            return true;
 
           if (setjmp (info.env) == 0)
             r_search (LAYER_PTR (layer)->arc_tree, &info.arc.BoundingBox,
                       NULL, LOCtoArcArc_callback, &info);
           else
-            return True;
+            return true;
 
           /* now check all polygons */
           i = 0;
@@ -1968,7 +1968,7 @@ LookupLOConnectionsToArc (ArcTypePtr Arc, Cardinal LayerGroup)
           for (; i < PCB->Data->Layer[layer].PolygonN; i++, polygon++)
             if (!TEST_FLAG (TheFlag, polygon) && IsArcInPolygon (Arc, polygon)
                 && ADD_POLYGON_TO_LIST (layer, polygon))
-              return True;
+              return true;
         }
       else
         {
@@ -1977,10 +1977,10 @@ LookupLOConnectionsToArc (ArcTypePtr Arc, Cardinal LayerGroup)
             r_search (PCB->Data->pad_tree, &info.arc.BoundingBox, NULL,
                       LOCtoArcPad_callback, &info);
           else
-            return True;
+            return true;
         }
     }
-  return (False);
+  return (false);
 }
 
 static int
@@ -2057,9 +2057,9 @@ LOCtoLinePad_callback (const BoxType * b, void *cl)
  * the notation that is used is:
  * Xij means Xj at line i
  */
-static Boolean
+static bool
 LookupLOConnectionsToLine (LineTypePtr Line, Cardinal LayerGroup,
-                           Boolean PolysTo)
+                           bool PolysTo)
 {
   Cardinal entry;
   struct lo_info info;
@@ -2072,7 +2072,7 @@ LookupLOConnectionsToLine (LineTypePtr Line, Cardinal LayerGroup,
     r_search (PCB->Data->rat_tree, &info.line.BoundingBox, NULL,
               LOCtoLineRat_callback, &info);
   else
-    return True;
+    return true;
 
   /* loop over all layers of the group */
   for (entry = 0; entry < PCB->LayerGroups.Number[LayerGroup]; entry++)
@@ -2092,13 +2092,13 @@ LookupLOConnectionsToLine (LineTypePtr Line, Cardinal LayerGroup,
             r_search (LAYER_PTR (layer)->line_tree, (BoxType *) & info.line,
                       NULL, LOCtoLineLine_callback, &info);
           else
-            return True;
+            return true;
           /* add arcs */
           if (setjmp (info.env) == 0)
             r_search (LAYER_PTR (layer)->arc_tree, (BoxType *) & info.line,
                       NULL, LOCtoLineArc_callback, &info);
           else
-            return True;
+            return true;
           /* now check all polygons */
           if (PolysTo)
             {
@@ -2108,7 +2108,7 @@ LookupLOConnectionsToLine (LineTypePtr Line, Cardinal LayerGroup,
                 if (!TEST_FLAG
                     (TheFlag, polygon) && IsLineInPolygon (Line, polygon)
                     && ADD_POLYGON_TO_LIST (layer, polygon))
-                  return True;
+                  return true;
             }
         }
       else
@@ -2119,10 +2119,10 @@ LookupLOConnectionsToLine (LineTypePtr Line, Cardinal LayerGroup,
             r_search (PCB->Data->pad_tree, &info.line.BoundingBox, NULL,
                       LOCtoLinePad_callback, &info);
           else
-            return True;
+            return true;
         }
     }
-  return (False);
+  return (false);
 }
 
 static int
@@ -2162,7 +2162,7 @@ LOT_Padcallback (const BoxType * b, void *cl)
   return 0;
 }
 
-static Boolean
+static bool
 LOTouchesLine (LineTypePtr Line, Cardinal LayerGroup)
 {
   Cardinal entry;
@@ -2191,12 +2191,12 @@ LOTouchesLine (LineTypePtr Line, Cardinal LayerGroup)
             r_search (LAYER_PTR (layer)->line_tree, (BoxType *) & info.line,
                       NULL, LOT_Linecallback, &info);
           else
-            return (True);
+            return (true);
           if (setjmp (info.env) == 0)
             r_search (LAYER_PTR (layer)->arc_tree, (BoxType *) & info.line,
                       NULL, LOT_Arccallback, &info);
           else
-            return (True);
+            return (true);
 
           /* now check all polygons */
           i = 0;
@@ -2204,7 +2204,7 @@ LOTouchesLine (LineTypePtr Line, Cardinal LayerGroup)
           for (; i < PCB->Data->Layer[layer].PolygonN; i++, polygon++)
             if (!TEST_FLAG (TheFlag, polygon)
                 && IsLineInPolygon (Line, polygon))
-              return (True);
+              return (true);
         }
       else
         {
@@ -2214,10 +2214,10 @@ LOTouchesLine (LineTypePtr Line, Cardinal LayerGroup)
             r_search (PCB->Data->pad_tree, &info.line.BoundingBox, NULL,
                       LOT_Padcallback, &info);
           else
-            return True;
+            return true;
         }
     }
-  return (False);
+  return (false);
 }
 
 struct rat_info
@@ -2283,7 +2283,7 @@ LOCtoPad_callback (const BoxType * b, void *cl)
  * the notation that is used is:
  * Xij means Xj at line i
  */
-static Boolean
+static bool
 LookupLOConnectionsToRatEnd (PointTypePtr Point, Cardinal LayerGroup)
 {
   Cardinal entry;
@@ -2308,7 +2308,7 @@ LookupLOConnectionsToRatEnd (PointTypePtr Point, Cardinal LayerGroup)
             r_search_pt (LAYER_PTR (layer)->line_tree, Point, 1, NULL,
                       LOCtoRat_callback, &info);
           else
-            return True;
+            return true;
           if (setjmp (info.env) == 0)
             r_search_pt (LAYER_PTR (layer)->polygon_tree, Point, 1,
                       NULL, PolygonToRat_callback, &info);
@@ -2321,10 +2321,10 @@ LookupLOConnectionsToRatEnd (PointTypePtr Point, Cardinal LayerGroup)
             r_search_pt (PCB->Data->pad_tree, Point, 1, NULL,
                       LOCtoPad_callback, &info);
           else
-            return True;
+            return true;
         }
     }
-  return (False);
+  return (false);
 }
 
 static int
@@ -2421,14 +2421,14 @@ LOCtoPadPad_callback (const BoxType * b, void *cl)
  * searches all LOs that are connected to the given pad on the given
  * layergroup. All found connections are added to the list
  */
-static Boolean
+static bool
 LookupLOConnectionsToPad (PadTypePtr Pad, Cardinal LayerGroup)
 {
   Cardinal entry;
   struct lo_info info;
 
   if (!TEST_FLAG (SQUAREFLAG, Pad))
-    return (LookupLOConnectionsToLine ((LineTypePtr) Pad, LayerGroup, False));
+    return (LookupLOConnectionsToLine ((LineTypePtr) Pad, LayerGroup, false));
 
   info.pad = *Pad;
   EXPAND_BOUNDS (&info.pad);
@@ -2438,7 +2438,7 @@ LookupLOConnectionsToPad (PadTypePtr Pad, Cardinal LayerGroup)
     r_search (PCB->Data->rat_tree, &info.pad.BoundingBox, NULL,
               LOCtoPadRat_callback, &info);
   else
-    return True;
+    return true;
 
   /* loop over all layers of the group */
   for (entry = 0; entry < PCB->LayerGroups.Number[LayerGroup]; entry++)
@@ -2455,19 +2455,19 @@ LookupLOConnectionsToPad (PadTypePtr Pad, Cardinal LayerGroup)
             r_search (LAYER_PTR (layer)->line_tree, &info.pad.BoundingBox,
                       NULL, LOCtoPadLine_callback, &info);
           else
-            return True;
+            return true;
           /* add arcs */
           if (setjmp (info.env) == 0)
             r_search (LAYER_PTR (layer)->arc_tree, &info.pad.BoundingBox,
                       NULL, LOCtoPadArc_callback, &info);
           else
-            return True;
+            return true;
           /* add polygons */
           if (setjmp (info.env) == 0)
             r_search (LAYER_PTR (layer)->polygon_tree, &info.pad.BoundingBox,
                       NULL, LOCtoPadPoly_callback, &info);
           else
-            return True;
+            return true;
         }
       else
         {
@@ -2477,11 +2477,11 @@ LookupLOConnectionsToPad (PadTypePtr Pad, Cardinal LayerGroup)
             r_search (PCB->Data->pad_tree, (BoxType *) & info.pad, NULL,
                       LOCtoPadPad_callback, &info);
           else
-            return True;
+            return true;
         }
 
     }
-  return (False);
+  return (false);
 }
 
 static int
@@ -2555,14 +2555,14 @@ LOCtoPolyRat_callback (const BoxType * b, void *cl)
  * looks up LOs that are connected to the given polygon
  * on the given layergroup. All found connections are added to the list
  */
-static Boolean
+static bool
 LookupLOConnectionsToPolygon (PolygonTypePtr Polygon, Cardinal LayerGroup)
 {
   Cardinal entry;
   struct lo_info info;
 
   if (!Polygon->Clipped)
-    return False;
+    return false;
   info.polygon = *Polygon;
   EXPAND_BOUNDS (&info.polygon);
   info.layer = LayerGroup;
@@ -2571,7 +2571,7 @@ LookupLOConnectionsToPolygon (PolygonTypePtr Polygon, Cardinal LayerGroup)
     r_search (PCB->Data->rat_tree, (BoxType *) & info.polygon, NULL,
               LOCtoPolyRat_callback, &info);
   else
-    return True;
+    return true;
 /* loop over all layers of the group */
   for (entry = 0; entry < PCB->LayerGroups.Number[LayerGroup]; entry++)
     {
@@ -2591,7 +2591,7 @@ LookupLOConnectionsToPolygon (PolygonTypePtr Polygon, Cardinal LayerGroup)
             if (!TEST_FLAG (TheFlag, polygon)
                 && IsPolygonInPolygon (polygon, Polygon)
                 && ADD_POLYGON_TO_LIST (layer, polygon))
-              return True;
+              return true;
 
           info.layer = layer;
           /* check all lines */
@@ -2600,13 +2600,13 @@ LookupLOConnectionsToPolygon (PolygonTypePtr Polygon, Cardinal LayerGroup)
                       (BoxType *) & info.polygon, NULL,
                       LOCtoPolyLine_callback, &info);
           else
-            return True;
+            return true;
           /* check all arcs */
           if (setjmp (info.env) == 0)
             r_search (LAYER_PTR (layer)->arc_tree, (BoxType *) & info.polygon,
                       NULL, LOCtoPolyArc_callback, &info);
           else
-            return True;
+            return true;
         }
       else
         {
@@ -2615,10 +2615,10 @@ LookupLOConnectionsToPolygon (PolygonTypePtr Polygon, Cardinal LayerGroup)
             r_search (PCB->Data->pad_tree, (BoxType *) & info.polygon,
                       NULL, LOCtoPolyPad_callback, &info);
           else
-            return True;
+            return true;
         }
     }
-  return (False);
+  return (false);
 }
 
 /* ---------------------------------------------------------------------------
@@ -2629,16 +2629,16 @@ LookupLOConnectionsToPolygon (PolygonTypePtr Polygon, Cardinal LayerGroup)
  * - check the two end points of the arc. If none of them matches
  * - check all segments of the polygon against the arc.
  */
-Boolean
+bool
 IsArcInPolygon (ArcTypePtr Arc, PolygonTypePtr Polygon)
 {
   BoxTypePtr Box = (BoxType *) Arc;
 
   /* arcs with clearance never touch polys */
   if (TEST_FLAG (CLEARPOLYFLAG, Polygon) && TEST_FLAG (CLEARLINEFLAG, Arc))
-    return False;
+    return false;
   if (!Polygon->Clipped)
-    return False;
+    return false;
   if (Box->X1 <= Polygon->Clipped->contours->xmax + Bloat
       && Box->X2 >= Polygon->Clipped->contours->xmin - Bloat
       && Box->Y1 <= Polygon->Clipped->contours->ymax + Bloat
@@ -2647,10 +2647,10 @@ IsArcInPolygon (ArcTypePtr Arc, PolygonTypePtr Polygon)
       POLYAREA *ap;
 
       if (!(ap = ArcPoly (Arc, Arc->Thickness + Bloat)))
-        return False;           /* error */
-      return isects (ap, Polygon, True);
+        return false;           /* error */
+      return isects (ap, Polygon, true);
     }
-  return False;
+  return false;
 }
 
 /* ---------------------------------------------------------------------------
@@ -2661,7 +2661,7 @@ IsArcInPolygon (ArcTypePtr Arc, PolygonTypePtr Polygon)
  * - check the two end points of the line. If none of them matches
  * - check all segments of the polygon against the line.
  */
-Boolean
+bool
 IsLineInPolygon (LineTypePtr Line, PolygonTypePtr Polygon)
 {
   BoxTypePtr Box = (BoxType *) Line;
@@ -2669,9 +2669,9 @@ IsLineInPolygon (LineTypePtr Line, PolygonTypePtr Polygon)
 
   /* lines with clearance never touch polygons */
   if (TEST_FLAG (CLEARPOLYFLAG, Polygon) && TEST_FLAG (CLEARLINEFLAG, Line))
-    return False;
+    return false;
   if (!Polygon->Clipped)
-    return False;
+    return false;
   if (TEST_FLAG(SQUAREFLAG,Line)&&(Line->Point1.X==Line->Point2.X||Line->Point1.Y==Line->Point2.Y))
      {
        BDimension wid = (Line->Thickness + Bloat + 1) / 2;
@@ -2690,9 +2690,9 @@ IsLineInPolygon (LineTypePtr Line, PolygonTypePtr Polygon)
     {
       if (!(lp = LinePoly (Line, Line->Thickness + Bloat)))
         return FALSE;           /* error */
-      return isects (lp, Polygon, True);
+      return isects (lp, Polygon, true);
     }
-  return False;
+  return false;
 }
 
 /* ---------------------------------------------------------------------------
@@ -2700,7 +2700,7 @@ IsLineInPolygon (LineTypePtr Line, PolygonTypePtr Polygon)
  *
  * The polygon is assumed to already have been proven non-clearing
  */
-Boolean
+bool
 IsPadInPolygon (PadTypePtr pad, PolygonTypePtr polygon)
 {
     return IsLineInPolygon ((LineTypePtr) pad, polygon);
@@ -2712,11 +2712,11 @@ IsPadInPolygon (PadTypePtr pad, PolygonTypePtr polygon)
  * First check all points out of P1 against P2 and vice versa.
  * If both fail check all lines of P1 against the ones of P2
  */
-Boolean
+bool
 IsPolygonInPolygon (PolygonTypePtr P1, PolygonTypePtr P2)
 {
   if (!P1->Clipped || !P2->Clipped)
-    return False;
+    return false;
   assert (P1->Clipped->contours);
   assert (P2->Clipped->contours);
 
@@ -2725,10 +2725,10 @@ IsPolygonInPolygon (PolygonTypePtr P1, PolygonTypePtr P2)
       P1->Clipped->contours->xmax + Bloat < P2->Clipped->contours->xmin ||
       P1->Clipped->contours->ymin - Bloat > P2->Clipped->contours->ymax ||
       P1->Clipped->contours->ymax + Bloat < P2->Clipped->contours->ymin)
-    return False;
+    return false;
 
   /* first check un-bloated case */
-  if (isects (P1->Clipped, P2, False))
+  if (isects (P1->Clipped, P2, false))
     return TRUE;
 
   /* now the difficult case of bloated */
@@ -2756,7 +2756,7 @@ IsPolygonInPolygon (PolygonTypePtr P1, PolygonTypePtr P2)
                   line.Point2.Y = v->point[1];
                   SetLineBoundingBox (&line);
                   if (IsLineInPolygon (&line, P2))
-                    return (True);
+                    return (true);
                   line.Point1.X = line.Point2.X;
                   line.Point1.Y = line.Point2.Y;
                 }
@@ -2764,7 +2764,7 @@ IsPolygonInPolygon (PolygonTypePtr P1, PolygonTypePtr P2)
         }
     }
 
-  return (False);
+  return (false);
 }
 
 /* ---------------------------------------------------------------------------
@@ -2797,7 +2797,7 @@ PrintConnectionElementName (ElementTypePtr Element, FILE * FP)
  */
 static void
 PrintConnectionListEntry (char *ObjName, ElementTypePtr Element,
-                          Boolean FirstOne, FILE * FP)
+                          bool FirstOne, FILE * FP)
 {
   static DynamicStringType oname;
 
@@ -2819,7 +2819,7 @@ PrintConnectionListEntry (char *ObjName, ElementTypePtr Element,
  * the connections are stacked in 'PadList'
  */
 static void
-PrintPadConnections (Cardinal Layer, FILE * FP, Boolean IsFirst)
+PrintPadConnections (Cardinal Layer, FILE * FP, bool IsFirst)
 {
   Cardinal i;
   PadTypePtr ptr;
@@ -2832,7 +2832,7 @@ PrintPadConnections (Cardinal Layer, FILE * FP, Boolean IsFirst)
     {
       ptr = PADLIST_ENTRY (Layer, 0);
       if (ptr != NULL)
-        PrintConnectionListEntry (UNKNOWN (ptr->Name), NULL, True, FP);
+        PrintConnectionListEntry (UNKNOWN (ptr->Name), NULL, true, FP);
       else
         printf ("Skipping NULL ptr in 1st part of PrintPadConnections\n");
     }
@@ -2844,7 +2844,7 @@ PrintPadConnections (Cardinal Layer, FILE * FP, Boolean IsFirst)
     {
       ptr = PADLIST_ENTRY (Layer, i);
       if (ptr != NULL)
-        PrintConnectionListEntry (EMPTY (ptr->Name), ptr->Element, False, FP);
+        PrintConnectionListEntry (EMPTY (ptr->Name), ptr->Element, false, FP);
       else
         printf ("Skipping NULL ptr in 2nd part of PrintPadConnections\n");
     }
@@ -2855,7 +2855,7 @@ PrintPadConnections (Cardinal Layer, FILE * FP, Boolean IsFirst)
  * the connections are stacked in 'PVList'
  */
 static void
-PrintPinConnections (FILE * FP, Boolean IsFirst)
+PrintPinConnections (FILE * FP, bool IsFirst)
 {
   Cardinal i;
   PinTypePtr pv;
@@ -2867,7 +2867,7 @@ PrintPinConnections (FILE * FP, Boolean IsFirst)
     {
       /* the starting pin */
       pv = PVLIST_ENTRY (0);
-      PrintConnectionListEntry (EMPTY (pv->Name), NULL, True, FP);
+      PrintConnectionListEntry (EMPTY (pv->Name), NULL, true, FP);
     }
 
   /* we maybe have to start with i=1 if we are handling the
@@ -2877,17 +2877,17 @@ PrintPinConnections (FILE * FP, Boolean IsFirst)
     {
       /* get the elements name or assume that its a via */
       pv = PVLIST_ENTRY (i);
-      PrintConnectionListEntry (EMPTY (pv->Name), pv->Element, False, FP);
+      PrintConnectionListEntry (EMPTY (pv->Name), pv->Element, false, FP);
     }
 }
 
 /* ---------------------------------------------------------------------------
  * checks if all lists of new objects are handled
  */
-static Boolean
-ListsEmpty (Boolean AndRats)
+static bool
+ListsEmpty (bool AndRats)
 {
-  Boolean empty;
+  bool empty;
   int i;
 
   empty = (PVList.Location >= PVList.Number);
@@ -2903,10 +2903,10 @@ ListsEmpty (Boolean AndRats)
 /* ---------------------------------------------------------------------------
  * loops till no more connections are found 
  */
-static Boolean
-DoIt (Boolean AndRats, Boolean AndDraw)
+static bool
+DoIt (bool AndRats, bool AndDraw)
 {
-  Boolean new = False;
+  bool new = false;
   do
     {
       /* lookup connections; these are the steps (2) to (4)
@@ -2928,28 +2928,28 @@ DoIt (Boolean AndRats, Boolean AndDraw)
   return (new);
 }
 
-/* returns True if nothing un-found touches the passed line
- * returns False if it would touch something not yet found
+/* returns true if nothing un-found touches the passed line
+ * returns false if it would touch something not yet found
  * doesn't include rat-lines in the search
  */
 
-Boolean
+bool
 lineClear (LineTypePtr line, Cardinal group)
 {
   if (LOTouchesLine (line, group))
-    return (False);
+    return (false);
   if (PVTouchesLine (line))
-    return (False);
-  return (True);
+    return (false);
+  return (true);
 }
 
 /* ---------------------------------------------------------------------------
  * prints all unused pins of an element to file FP
  */
-static Boolean
+static bool
 PrintAndSelectUnusedPinsAndPadsOfElement (ElementTypePtr Element, FILE * FP)
 {
-  Boolean first = True;
+  bool first = true;
   Cardinal number;
   static DynamicStringType oname;
 
@@ -2964,8 +2964,8 @@ PrintAndSelectUnusedPinsAndPadsOfElement (ElementTypePtr Element, FILE * FP)
           {
             int i;
             if (ADD_PV_TO_LIST (pin))
-              return True;
-            DoIt (True, True);
+              return true;
+            DoIt (true, true);
             number = PadList[COMPONENT_LAYER].Number
               + PadList[SOLDER_LAYER].Number + PVList.Number;
             /* the pin has no connection if it's the only
@@ -2980,7 +2980,7 @@ PrintAndSelectUnusedPinsAndPadsOfElement (ElementTypePtr Element, FILE * FP)
                 if (first)
                   {
                     PrintConnectionElementName (Element, FP);
-                    first = False;
+                    first = false;
                   }
 
                 /* write name to list and draw selected object */
@@ -2992,7 +2992,7 @@ PrintAndSelectUnusedPinsAndPadsOfElement (ElementTypePtr Element, FILE * FP)
 
             /* reset found objects for the next pin */
             if (PrepareNextLoop (FP))
-              return (True);
+              return (true);
           }
       }
   }
@@ -3008,8 +3008,8 @@ PrintAndSelectUnusedPinsAndPadsOfElement (ElementTypePtr Element, FILE * FP)
         int i;
         if (ADD_PAD_TO_LIST (TEST_FLAG (ONSOLDERFLAG, pad)
                              ? SOLDER_LAYER : COMPONENT_LAYER, pad))
-          return True;
-        DoIt (True, True);
+          return true;
+        DoIt (true, true);
         number = PadList[COMPONENT_LAYER].Number
           + PadList[SOLDER_LAYER].Number + PVList.Number;
         /* the pin has no connection if it's the only
@@ -3024,7 +3024,7 @@ PrintAndSelectUnusedPinsAndPadsOfElement (ElementTypePtr Element, FILE * FP)
             if (first)
               {
                 PrintConnectionElementName (Element, FP);
-                first = False;
+                first = false;
               }
 
             /* write name to list and draw selected object */
@@ -3036,7 +3036,7 @@ PrintAndSelectUnusedPinsAndPadsOfElement (ElementTypePtr Element, FILE * FP)
 
         /* reset found objects for the next pin */
         if (PrepareNextLoop (FP))
-          return (True);
+          return (true);
       }
   }
   END_LOOP;
@@ -3047,13 +3047,13 @@ PrintAndSelectUnusedPinsAndPadsOfElement (ElementTypePtr Element, FILE * FP)
       fputs ("}\n\n", FP);
       SEPARATE (FP);
     }
-  return (False);
+  return (false);
 }
 
 /* ---------------------------------------------------------------------------
  * resets some flags for looking up the next pin/pad
  */
-static Boolean
+static bool
 PrepareNextLoop (FILE * FP)
 {
   Cardinal layer;
@@ -3074,16 +3074,16 @@ PrepareNextLoop (FILE * FP)
   PVList.Number = PVList.Location = 0;
   RatList.Number = RatList.Location = 0;
 
-  return (False);
+  return (false);
 }
 
 /* ---------------------------------------------------------------------------
  * finds all connections to the pins of the passed element.
  * The result is written to file FP
- * Returns True if operation was aborted
+ * Returns true if operation was aborted
  */
-static Boolean
-PrintElementConnections (ElementTypePtr Element, FILE * FP, Boolean AndDraw)
+static bool
+PrintElementConnections (ElementTypePtr Element, FILE * FP, bool AndDraw)
 {
   PrintConnectionElementName (Element, FP);
 
@@ -3093,20 +3093,20 @@ PrintElementConnections (ElementTypePtr Element, FILE * FP, Boolean AndDraw)
     /* pin might have been checked before, add to list if not */
     if (TEST_FLAG (TheFlag, pin))
       {
-        PrintConnectionListEntry (EMPTY (pin->Name), NULL, True, FP);
+        PrintConnectionListEntry (EMPTY (pin->Name), NULL, true, FP);
         fputs ("\t\t__CHECKED_BEFORE__\n\t}\n", FP);
         continue;
       }
     if (ADD_PV_TO_LIST (pin))
-      return True;
-    DoIt (True, AndDraw);
+      return true;
+    DoIt (true, AndDraw);
     /* printout all found connections */
-    PrintPinConnections (FP, True);
-    PrintPadConnections (COMPONENT_LAYER, FP, False);
-    PrintPadConnections (SOLDER_LAYER, FP, False);
+    PrintPinConnections (FP, true);
+    PrintPadConnections (COMPONENT_LAYER, FP, false);
+    PrintPadConnections (SOLDER_LAYER, FP, false);
     fputs ("\t}\n", FP);
     if (PrepareNextLoop (FP))
-      return (True);
+      return (true);
   }
   END_LOOP;
 
@@ -3117,27 +3117,27 @@ PrintElementConnections (ElementTypePtr Element, FILE * FP, Boolean AndDraw)
     /* pad might have been checked before, add to list if not */
     if (TEST_FLAG (TheFlag, pad))
       {
-        PrintConnectionListEntry (EMPTY (pad->Name), NULL, True, FP);
+        PrintConnectionListEntry (EMPTY (pad->Name), NULL, true, FP);
         fputs ("\t\t__CHECKED_BEFORE__\n\t}\n", FP);
         continue;
       }
     layer = TEST_FLAG (ONSOLDERFLAG, pad) ? SOLDER_LAYER : COMPONENT_LAYER;
     if (ADD_PAD_TO_LIST (layer, pad))
-      return True;
-    DoIt (True, AndDraw);
+      return true;
+    DoIt (true, AndDraw);
     /* print all found connections */
-    PrintPadConnections (layer, FP, True);
+    PrintPadConnections (layer, FP, true);
     PrintPadConnections (layer ==
                          (COMPONENT_LAYER ? SOLDER_LAYER : COMPONENT_LAYER),
-                         FP, False);
-    PrintPinConnections (FP, False);
+                         FP, false);
+    PrintPinConnections (FP, false);
     fputs ("\t}\n", FP);
     if (PrepareNextLoop (FP))
-      return (True);
+      return (true);
   }
   END_LOOP;
   fputs ("}\n\n", FP);
-  return (False);
+  return (false);
 }
 
 /* ---------------------------------------------------------------------------
@@ -3222,17 +3222,17 @@ void
 LookupElementConnections (ElementTypePtr Element, FILE * FP)
 {
   /* reset all currently marked connections */
-  User = True;
+  User = true;
   TheFlag = FOUNDFLAG;
-  ResetConnections (True);
+  ResetConnections (true);
   InitConnectionLookup ();
-  PrintElementConnections (Element, FP, True);
-  SetChangedFlag (True);
+  PrintElementConnections (Element, FP, true);
+  SetChangedFlag (true);
   if (Settings.RingBellWhenFinished)
     gui->beep ();
   FreeConnectionLookupMemory ();
   IncrementUndoSerialNumber ();
-  User = False;
+  User = false;
   Draw ();
 }
 
@@ -3243,24 +3243,24 @@ void
 LookupConnectionsToAllElements (FILE * FP)
 {
   /* reset all currently marked connections */
-  User = False;
+  User = false;
   TheFlag = FOUNDFLAG;
-  ResetConnections (False);
+  ResetConnections (false);
   InitConnectionLookup ();
 
   ELEMENT_LOOP (PCB->Data);
   {
-    /* break if abort dialog returned True */
-    if (PrintElementConnections (element, FP, False))
+    /* break if abort dialog returned true */
+    if (PrintElementConnections (element, FP, false))
       break;
     SEPARATE (FP);
     if (Settings.ResetAfterElement && n != 1)
-      ResetConnections (False);
+      ResetConnections (false);
   }
   END_LOOP;
   if (Settings.RingBellWhenFinished)
     gui->beep ();
-  ResetConnections (False);
+  ResetConnections (false);
   FreeConnectionLookupMemory ();
   ClearAndRedrawOutput ();
 }
@@ -3268,7 +3268,7 @@ LookupConnectionsToAllElements (FILE * FP)
 /*---------------------------------------------------------------------------
  * add the starting object to the list of found objects
  */
-static Boolean
+static bool
 ListStart (int type, void *ptr1, void *ptr2, void *ptr3)
 {
   DumpList ();
@@ -3278,14 +3278,14 @@ ListStart (int type, void *ptr1, void *ptr2, void *ptr3)
     case VIA_TYPE:
       {
         if (ADD_PV_TO_LIST ((PinTypePtr) ptr2))
-          return True;
+          return true;
         break;
       }
 
     case RATLINE_TYPE:
       {
         if (ADD_RAT_TO_LIST ((RatTypePtr) ptr1))
-          return True;
+          return true;
         break;
       }
 
@@ -3295,7 +3295,7 @@ ListStart (int type, void *ptr1, void *ptr2, void *ptr3)
                                     (LayerTypePtr) ptr1);
 
         if (ADD_LINE_TO_LIST (layer, (LineTypePtr) ptr2))
-          return True;
+          return true;
         break;
       }
 
@@ -3305,7 +3305,7 @@ ListStart (int type, void *ptr1, void *ptr2, void *ptr3)
                                     (LayerTypePtr) ptr1);
 
         if (ADD_ARC_TO_LIST (layer, (ArcTypePtr) ptr2))
-          return True;
+          return true;
         break;
       }
 
@@ -3315,7 +3315,7 @@ ListStart (int type, void *ptr1, void *ptr2, void *ptr3)
                                     (LayerTypePtr) ptr1);
 
         if (ADD_POLYGON_TO_LIST (layer, (PolygonTypePtr) ptr2))
-          return True;
+          return true;
         break;
       }
 
@@ -3325,11 +3325,11 @@ ListStart (int type, void *ptr1, void *ptr2, void *ptr3)
         if (ADD_PAD_TO_LIST
             (TEST_FLAG
              (ONSOLDERFLAG, pad) ? SOLDER_LAYER : COMPONENT_LAYER, pad))
-          return True;
+          return true;
         break;
       }
     }
-  return (False);
+  return (false);
 }
 
 
@@ -3340,7 +3340,7 @@ ListStart (int type, void *ptr1, void *ptr2, void *ptr3)
  * also the action is marked as undoable if AndDraw is true
  */
 void
-LookupConnection (LocationType X, LocationType Y, Boolean AndDraw,
+LookupConnection (LocationType X, LocationType Y, bool AndDraw,
                   BDimension Range, int which_flag)
 {
   void *ptr1, *ptr2, *ptr3;
@@ -3384,10 +3384,10 @@ LookupConnection (LocationType X, LocationType Y, Boolean AndDraw,
    * This is step (1) from the description
    */
   ListStart (type, ptr1, ptr2, ptr3);
-  DoIt (True, AndDraw);
+  DoIt (true, AndDraw);
   if (User)
     IncrementUndoSerialNumber ();
-  User = False;
+  User = false;
 
   /* we are done */
   if (AndDraw)
@@ -3403,14 +3403,14 @@ LookupConnection (LocationType X, LocationType Y, Boolean AndDraw,
  */
 void
   RatFindHook
-  (int type, void *ptr1, void *ptr2, void *ptr3, Boolean undo,
-   Boolean AndRats)
+  (int type, void *ptr1, void *ptr2, void *ptr3, bool undo,
+   bool AndRats)
 {
   User = undo;
   DumpList ();
   ListStart (type, ptr1, ptr2, ptr3);
-  DoIt (AndRats, False);
-  User = False;
+  DoIt (AndRats, false);
+  User = false;
 }
 
 /* ---------------------------------------------------------------------------
@@ -3420,15 +3420,15 @@ void
 LookupUnusedPins (FILE * FP)
 {
   /* reset all currently marked connections */
-  User = True;
+  User = true;
   SaveUndoSerialNumber ();
-  ResetConnections (True);
+  ResetConnections (true);
   RestoreUndoSerialNumber ();
   InitConnectionLookup ();
 
   ELEMENT_LOOP (PCB->Data);
   {
-    /* break if abort dialog returned True;
+    /* break if abort dialog returned true;
      * passing NULL as filedescriptor discards the normal output
      */
     if (PrintAndSelectUnusedPinsAndPadsOfElement (element, FP))
@@ -3440,7 +3440,7 @@ LookupUnusedPins (FILE * FP)
     gui->beep ();
   FreeConnectionLookupMemory ();
   IncrementUndoSerialNumber ();
-  User = False;
+  User = false;
   Draw ();
 }
 
@@ -3448,9 +3448,9 @@ LookupUnusedPins (FILE * FP)
  * resets all used flags of pins and vias
  */
 void
-ResetFoundPinsViasAndPads (Boolean AndDraw)
+ResetFoundPinsViasAndPads (bool AndDraw)
 {
-  Boolean change = False;
+  bool change = false;
 
 
   VIA_LOOP (PCB->Data);
@@ -3462,7 +3462,7 @@ ResetFoundPinsViasAndPads (Boolean AndDraw)
         CLEAR_FLAG (TheFlag, via);
         if (AndDraw)
           DrawVia (via, 0);
-        change = True;
+        change = true;
       }
   }
   END_LOOP;
@@ -3477,7 +3477,7 @@ ResetFoundPinsViasAndPads (Boolean AndDraw)
           CLEAR_FLAG (TheFlag, pin);
           if (AndDraw)
             DrawPin (pin, 0);
-          change = True;
+          change = true;
         }
     }
     END_LOOP;
@@ -3490,7 +3490,7 @@ ResetFoundPinsViasAndPads (Boolean AndDraw)
           CLEAR_FLAG (TheFlag, pad);
           if (AndDraw)
             DrawPad (pad, 0);
-          change = True;
+          change = true;
         }
     }
     END_LOOP;
@@ -3498,7 +3498,7 @@ ResetFoundPinsViasAndPads (Boolean AndDraw)
   END_LOOP;
   if (change)
     {
-      SetChangedFlag (True);
+      SetChangedFlag (true);
       if (AndDraw)
         {
           IncrementUndoSerialNumber ();
@@ -3511,9 +3511,9 @@ ResetFoundPinsViasAndPads (Boolean AndDraw)
  * resets all used flags of LOs
  */
 void
-ResetFoundLinesAndPolygons (Boolean AndDraw)
+ResetFoundLinesAndPolygons (bool AndDraw)
 {
-  Boolean change = False;
+  bool change = false;
 
 
   RAT_LOOP (PCB->Data);
@@ -3525,7 +3525,7 @@ ResetFoundLinesAndPolygons (Boolean AndDraw)
         CLEAR_FLAG (TheFlag, line);
         if (AndDraw)
           DrawRat (line, 0);
-        change = True;
+        change = true;
       }
   }
   END_LOOP;
@@ -3538,7 +3538,7 @@ ResetFoundLinesAndPolygons (Boolean AndDraw)
         CLEAR_FLAG (TheFlag, line);
         if (AndDraw)
           DrawLine (layer, line, 0);
-        change = True;
+        change = true;
       }
   }
   ENDALL_LOOP;
@@ -3551,7 +3551,7 @@ ResetFoundLinesAndPolygons (Boolean AndDraw)
         CLEAR_FLAG (TheFlag, arc);
         if (AndDraw)
           DrawArc (layer, arc, 0);
-        change = True;
+        change = true;
       }
   }
   ENDALL_LOOP;
@@ -3564,13 +3564,13 @@ ResetFoundLinesAndPolygons (Boolean AndDraw)
         CLEAR_FLAG (TheFlag, polygon);
         if (AndDraw)
           DrawPolygon (layer, polygon, 0);
-        change = True;
+        change = true;
       }
   }
   ENDALL_LOOP;
   if (change)
     {
-      SetChangedFlag (True);
+      SetChangedFlag (true);
       if (AndDraw)
         {
           IncrementUndoSerialNumber ();
@@ -3583,7 +3583,7 @@ ResetFoundLinesAndPolygons (Boolean AndDraw)
  * resets all found connections
  */
 static void
-ResetConnections (Boolean AndDraw)
+ResetConnections (bool AndDraw)
 {
   if (AndDraw)
     SaveUndoSerialNumber ();
@@ -3632,7 +3632,7 @@ DumpList (void)
  * Check for DRC violations on a single net starting from the pad or pin
  * sees if the connectivity changes when everything is bloated, or shrunk
  */
-static Boolean
+static bool
 DRCFind (int What, void *ptr1, void *ptr2, void *ptr3)
 {
   LocationType x, y;
@@ -3647,38 +3647,38 @@ DRCFind (int What, void *ptr1, void *ptr2, void *ptr3)
       fBloat = (float) -PCB->Shrink;
       TheFlag = DRCFLAG | SELECTEDFLAG;
       ListStart (What, ptr1, ptr2, ptr3);
-      DoIt (True, False);
+      DoIt (true, false);
       /* ok now the shrunk net has the SELECTEDFLAG set */
       DumpList ();
       TheFlag = FOUNDFLAG;
       ListStart (What, ptr1, ptr2, ptr3);
       Bloat = 0;
       fBloat = 0.0;
-      drc = True;               /* abort the search if we find anything not already found */
-      if (DoIt (True, False))
+      drc = true;               /* abort the search if we find anything not already found */
+      if (DoIt (true, false))
         {
           DumpList ();
           /* make the flag changes undoable */
           TheFlag = FOUNDFLAG | SELECTEDFLAG;
-          ResetConnections (False);
-          User = True;
-          drc = False;
+          ResetConnections (false);
+          User = true;
+          drc = false;
           Bloat = -PCB->Shrink;
           fBloat = (float) -PCB->Shrink;
           TheFlag = SELECTEDFLAG;
           RestoreUndoSerialNumber ();
           ListStart (What, ptr1, ptr2, ptr3);
-          DoIt (True, True);
+          DoIt (true, true);
           DumpList ();
           ListStart (What, ptr1, ptr2, ptr3);
           TheFlag = FOUNDFLAG;
           Bloat = 0;
           fBloat = 0.0;
-          drc = True;
-          DoIt (True, True);
+          drc = true;
+          DoIt (true, true);
           DumpList ();
-          User = False;
-          drc = False;
+          User = false;
+          drc = false;
           drcerr_count++;
           LocateError (&x, &y);
           BuildObjectList (&object_count, &object_id_list, &object_type_list);
@@ -3701,41 +3701,41 @@ DRCFind (int What, void *ptr1, void *ptr2, void *ptr3)
           free (object_type_list);
 
           if (!throw_drc_dialog())
-            return (True);
+            return (true);
           IncrementUndoSerialNumber ();
-          Undo (True);
+          Undo (true);
         }
       DumpList ();
     }
   /* now check the bloated condition */
-  drc = False;
-  ResetConnections (False);
+  drc = false;
+  ResetConnections (false);
   TheFlag = FOUNDFLAG;
   ListStart (What, ptr1, ptr2, ptr3);
   Bloat = PCB->Bloat;
   fBloat = (float) PCB->Bloat;
-  drc = True;
-  while (DoIt (True, False))
+  drc = true;
+  while (DoIt (true, false))
     {
       DumpList ();
       /* make the flag changes undoable */
       TheFlag = FOUNDFLAG | SELECTEDFLAG;
-      ResetConnections (False);
-      User = True;
-      drc = False;
+      ResetConnections (false);
+      User = true;
+      drc = false;
       Bloat = 0;
       fBloat = 0.0;
       RestoreUndoSerialNumber ();
       TheFlag = SELECTEDFLAG;
       ListStart (What, ptr1, ptr2, ptr3);
-      DoIt (True, True);
+      DoIt (true, true);
       DumpList ();
       TheFlag = FOUNDFLAG;
       ListStart (What, ptr1, ptr2, ptr3);
       Bloat = PCB->Bloat;
       fBloat = (float) PCB->Bloat;
-      drc = True;
-      DoIt (True, True);
+      drc = true;
+      DoIt (true, true);
       DumpList ();
       drcerr_count++;
       LocateError (&x, &y);
@@ -3757,29 +3757,29 @@ DRCFind (int What, void *ptr1, void *ptr2, void *ptr3)
       pcb_drc_violation_free (violation);
       free (object_id_list);
       free (object_type_list);
-      User = False;
-      drc = False;
+      User = false;
+      drc = false;
       if (!throw_drc_dialog())
-        return (True);
+        return (true);
       IncrementUndoSerialNumber ();
-      Undo (True);
+      Undo (true);
       /* highlight the rest of the encroaching net so it's not reported again */
       TheFlag |= SELECTEDFLAG;
       Bloat = 0;
       fBloat = 0.0;
       ListStart (thing_type, thing_ptr1, thing_ptr2, thing_ptr3);
-      DoIt (True, True);
+      DoIt (true, true);
       DumpList ();
-      drc = True;
+      drc = true;
       Bloat = PCB->Bloat;
       fBloat = (float) PCB->Bloat;
       ListStart (What, ptr1, ptr2, ptr3);
     }
-  drc = False;
+  drc = false;
   DumpList ();
   TheFlag = FOUNDFLAG | SELECTEDFLAG;
-  ResetConnections (False);
-  return (False);
+  ResetConnections (false);
+  return (false);
 }
 
 /*----------------------------------------------------------------------------
@@ -3903,11 +3903,11 @@ doIsBad:
   free (object_type_list);
   if (!throw_drc_dialog())
     {
-      IsBad = True;
+      IsBad = true;
       return 1;
     }
   IncrementUndoSerialNumber ();
-  Undo (True);
+  Undo (true);
   return 0;
 }
 
@@ -3928,7 +3928,7 @@ DRCAll (void)
 
   reset_drc_dialog_message();
 
-  IsBad = False;
+  IsBad = false;
   drcerr_count = 0;
   SaveStackAndVisibility ();
   ResetStackAndVisibility ();
@@ -3937,9 +3937,9 @@ DRCAll (void)
 
   TheFlag = FOUNDFLAG | DRCFLAG | SELECTEDFLAG;
 
-  ResetConnections (True);
+  ResetConnections (true);
 
-  User = False;
+  User = false;
 
   ELEMENT_LOOP (PCB->Data);
   {
@@ -3948,7 +3948,7 @@ DRCAll (void)
       if (!TEST_FLAG (DRCFLAG, pin)
           && DRCFind (PIN_TYPE, (void *) element, (void *) pin, (void *) pin))
         {
-          IsBad = True;
+          IsBad = true;
           break;
         }
     }
@@ -3965,7 +3965,7 @@ DRCAll (void)
       if (!TEST_FLAG (DRCFLAG, pad)
           && DRCFind (PAD_TYPE, (void *) element, (void *) pad, (void *) pad))
         {
-          IsBad = True;
+          IsBad = true;
           break;
         }
     }
@@ -3980,14 +3980,14 @@ DRCAll (void)
     if (!TEST_FLAG (DRCFLAG, via)
         && DRCFind (VIA_TYPE, (void *) via, (void *) via, (void *) via))
       {
-        IsBad = True;
+        IsBad = true;
         break;
       }
   }
   END_LOOP;
 
   TheFlag = (IsBad) ? DRCFLAG : (FOUNDFLAG | DRCFLAG | SELECTEDFLAG);
-  ResetConnections (False);
+  ResetConnections (false);
   TheFlag = SELECTEDFLAG;
   /* check minimum widths and polygon clearances */
   if (!IsBad)
@@ -4026,11 +4026,11 @@ DRCAll (void)
             free (object_type_list);
             if (!throw_drc_dialog())
               {
-                IsBad = True;
+                IsBad = true;
                 break;
               }
             IncrementUndoSerialNumber ();
-            Undo (False);
+            Undo (false);
           }
       }
       ENDALL_LOOP;
@@ -4070,11 +4070,11 @@ DRCAll (void)
             free (object_type_list);
             if (!throw_drc_dialog())
               {
-                IsBad = True;
+                IsBad = true;
                 break;
               }
             IncrementUndoSerialNumber ();
-            Undo (False);
+            Undo (false);
           }
       }
       ENDALL_LOOP;
@@ -4115,11 +4115,11 @@ DRCAll (void)
             free (object_type_list);
             if (!throw_drc_dialog())
               {
-                IsBad = True;
+                IsBad = true;
                 break;
               }
             IncrementUndoSerialNumber ();
-            Undo (False);
+            Undo (false);
           }
         if (pin->DrillingHole < PCB->minDrill)
           {
@@ -4148,11 +4148,11 @@ DRCAll (void)
             free (object_type_list);
             if (!throw_drc_dialog())
               {
-                IsBad = True;
+                IsBad = true;
                 break;
               }
             IncrementUndoSerialNumber ();
-            Undo (False);
+            Undo (false);
           }
       }
       ENDALL_LOOP;
@@ -4192,11 +4192,11 @@ DRCAll (void)
             free (object_type_list);
             if (!throw_drc_dialog())
               {
-                IsBad = True;
+                IsBad = true;
                 break;
               }
             IncrementUndoSerialNumber ();
-            Undo (False);
+            Undo (false);
           }
       }
       ENDALL_LOOP;
@@ -4237,11 +4237,11 @@ DRCAll (void)
             free (object_type_list);
             if (!throw_drc_dialog())
               {
-                IsBad = True;
+                IsBad = true;
                 break;
               }
             IncrementUndoSerialNumber ();
-            Undo (False);
+            Undo (false);
           }
         if (via->DrillingHole < PCB->minDrill)
           {
@@ -4270,11 +4270,11 @@ DRCAll (void)
             free (object_type_list);
             if (!throw_drc_dialog())
               {
-                IsBad = True;
+                IsBad = true;
                 break;
               }
             IncrementUndoSerialNumber ();
-            Undo (False);
+            Undo (false);
           }
       }
       END_LOOP;
@@ -4319,7 +4319,7 @@ DRCAll (void)
             free (object_type_list);
             if (!throw_drc_dialog())
               {
-                IsBad = True;
+                IsBad = true;
                 break;
               }
           }
@@ -4385,7 +4385,7 @@ DRCAll (void)
             free (object_type_list);
             if (!throw_drc_dialog())
               {
-                IsBad = True;
+                IsBad = true;
                 break;
               }
           }
@@ -4521,10 +4521,10 @@ GotoError (void)
     case ARC_TYPE:
     case POLYGON_TYPE:
       ChangeGroupVisibility (GetLayerNumber
-                             (PCB->Data, (LayerTypePtr) thing_ptr1), True,
-                             True);
+                             (PCB->Data, (LayerTypePtr) thing_ptr1), true,
+                             true);
     }
-  CenterDisplay (X, Y, False);
+  CenterDisplay (X, Y, false);
 }
 
 void
diff --git a/src/find.h b/src/find.h
index c6e6eef..5b04980 100644
--- a/src/find.h
+++ b/src/find.h
@@ -44,31 +44,31 @@
 #define SILK_TYPE	\
 	(LINE_TYPE | ARC_TYPE | POLYGON_TYPE)
 
-Boolean LineLineIntersect (LineTypePtr, LineTypePtr);
-Boolean LineArcIntersect (LineTypePtr, ArcTypePtr);
-Boolean PinLineIntersect (PinTypePtr, LineTypePtr);
-Boolean LinePadIntersect (LineTypePtr, PadTypePtr);
-Boolean ArcPadIntersect (ArcTypePtr, PadTypePtr);
-Boolean IsPolygonInPolygon (PolygonTypePtr, PolygonTypePtr);
+bool LineLineIntersect (LineTypePtr, LineTypePtr);
+bool LineArcIntersect (LineTypePtr, ArcTypePtr);
+bool PinLineIntersect (PinTypePtr, LineTypePtr);
+bool LinePadIntersect (LineTypePtr, PadTypePtr);
+bool ArcPadIntersect (ArcTypePtr, PadTypePtr);
+bool IsPolygonInPolygon (PolygonTypePtr, PolygonTypePtr);
 void LookupElementConnections (ElementTypePtr, FILE *);
 void LookupConnectionsToAllElements (FILE *);
-void LookupConnection (LocationType, LocationType, Boolean, BDimension, int);
+void LookupConnection (LocationType, LocationType, bool, BDimension, int);
 void LookupUnusedPins (FILE *);
-void ResetFoundLinesAndPolygons (Boolean);
-void ResetFoundPinsViasAndPads (Boolean);
+void ResetFoundLinesAndPolygons (bool);
+void ResetFoundPinsViasAndPads (bool);
 void InitConnectionLookup (void);
 void InitComponentLookup (void);
 void InitLayoutLookup (void);
 void FreeConnectionLookupMemory (void);
 void FreeComponentLookupMemory (void);
 void FreeLayoutLookupMemory (void);
-void RatFindHook (int, void *, void *, void *, Boolean, Boolean);
+void RatFindHook (int, void *, void *, void *, bool, bool);
 void SaveFindFlag (int);
 void RestoreFindFlag (void);
 int DRCAll (void);
-Boolean lineClear (LineTypePtr, Cardinal);
-Boolean IsLineInPolygon (LineTypePtr, PolygonTypePtr);
-Boolean IsArcInPolygon (ArcTypePtr, PolygonTypePtr);
-Boolean IsPadInPolygon (PadTypePtr, PolygonTypePtr);
+bool lineClear (LineTypePtr, Cardinal);
+bool IsLineInPolygon (LineTypePtr, PolygonTypePtr);
+bool IsArcInPolygon (ArcTypePtr, PolygonTypePtr);
+bool IsPadInPolygon (PadTypePtr, PolygonTypePtr);
 
 #endif
diff --git a/src/flags.c b/src/flags.c
index c6c7458..41e0b55 100644
--- a/src/flags.c
+++ b/src/flags.c
@@ -95,7 +95,7 @@ FlagTESTFLAG (int bit)
 static int
 FlagSETTINGS (int ofs)
 {
-  return *(Boolean *) ((char *) (&Settings) + ofs);
+  return *(bool *) ((char *) (&Settings) + ofs);
 }
 
 static int
diff --git a/src/global.h b/src/global.h
index b7c9d0f..62be07f 100644
--- a/src/global.h
+++ b/src/global.h
@@ -49,6 +49,7 @@
 #include <math.h>
 #include <ctype.h>
 #include <sys/types.h>
+#include <stdbool.h>
 
 /* Forward declarations for structures the HIDs need.  */
 typedef struct BoxType BoxType, *BoxTypePtr;
@@ -85,7 +86,6 @@ typedef int BDimension;		/* big dimension */
 
 #ifndef XtSpecificationRelease
 typedef unsigned int Cardinal;
-typedef char Boolean;
 /*typedef unsigned int	Pixel;*/
 typedef char *String;
 typedef short Position;
@@ -93,9 +93,6 @@ typedef short Dimension;
 #endif
 typedef unsigned char BYTE;
 
-#define True	1
-#define False	0
-
 /* Nobody should know about the internals of this except the macros in
    macros.h that access it.  This structure must be simple-assignable
    for now.  */
@@ -296,7 +293,7 @@ typedef struct			/* holds information about one layer */
   PolygonTypePtr Polygon;
   ArcTypePtr Arc;
   rtree_t *line_tree, *text_tree, *polygon_tree, *arc_tree;
-  Boolean On;			/* visible flag */
+  bool On;			/* visible flag */
   char *Color,			/* color */
    *SelectedColor;
   AttributeListType Attributes;
@@ -355,7 +352,7 @@ typedef struct
 typedef struct			/* a single symbol */
 {
   LineTypePtr Line;
-  Boolean Valid;
+  bool Valid;
   Cardinal LineN,		/* number of lines */
     LineMax;
   BDimension Width,		/* size of cell */
@@ -368,7 +365,7 @@ typedef struct			/* complete set of symbols */
     MaxWidth;
   BoxType DefaultSymbol;	/* the default symbol is a filled box */
   SymbolType Symbol[MAX_FONTPOSITION + 1];
-  Boolean Valid;
+  bool Valid;
 } FontType, *FontTypePtr;
 
 typedef struct			/* holds all objects */
@@ -475,7 +472,7 @@ typedef struct PCBType
    *PrintFilename,		/* from print dialog */
    *Netlistname,		/* name of netlist file */
     ThermStyle;			/* type of thermal to place with thermal tool */
-  Boolean Changed,		/* layout has been changed */
+  bool Changed,		/* layout has been changed */
     ViaOn,			/* visibility flags */
     ElementOn, RatOn, InvisibleObjectsOn, PinOn, SilkActive,	/* active layer is actually silk */
     RatDraw;			 /* we're drawing rats */
@@ -536,7 +533,7 @@ typedef struct			/* current marked line */
   PointType Point1,		/* start- and end-position */
     Point2;
   long int State;
-  Boolean draw;
+  bool draw;
 } AttachedLineType, *AttachedLineTypePtr;
 
 typedef struct			/* currently marked block */
@@ -544,7 +541,7 @@ typedef struct			/* currently marked block */
   PointType Point1,		/* start- and end-position */
     Point2;
   long int State;
-  Boolean otherway;
+  bool otherway;
 } AttachedBoxType, *AttachedBoxTypePtr;
 
 typedef struct			/* currently attached object */
@@ -577,7 +574,7 @@ typedef struct			/* holds cursor information */
   LocationType X,		/* position in PCB coordinates */
     Y, MinX,			/* lowest and highest coordinates */
     MinY, MaxX, MaxY;
-  Boolean On;			/* flag for 'is visible' */
+  bool On;			/* flag for 'is visible' */
   AttachedLineType AttachedLine;	/* data of new lines... */
   AttachedBoxType AttachedBox;
   PolygonType AttachedPolygon;
@@ -587,7 +584,7 @@ typedef struct			/* holds cursor information */
 
 typedef struct
 {
-  Boolean status;
+  bool status;
   long int X, Y;
 } MarkType, *MarkTypePtr;
 
@@ -597,7 +594,7 @@ typedef struct
  */
 typedef struct			/* some resources... */
 {
-  Boolean grid_units_mm;
+  bool grid_units_mm;
 
   int verbose;
 
@@ -654,14 +651,14 @@ typedef struct			/* some resources... */
    *GnetlistProgram,		/* gnetlist program name */
    *MakeProgram,		/* make program name */
    *InitialLayerStack;		/* If set, the initial layer stack is set to this */
-  Boolean DumpMenuFile;		/* dump internal menu definitions */
+  bool DumpMenuFile;		/* dump internal menu definitions */
   LocationType PinoutOffsetX,	/* offset of origin */
     PinoutOffsetY;
   int PinoutTextOffsetX,	/* offset of text from pin center */
     PinoutTextOffsetY;
   RouteStyleType RouteStyle[NUM_STYLES];	/* default routing styles */
   LayerGroupType LayerGroups;	/* default layer groups */
-  Boolean ClearLine, FullPoly,
+  bool ClearLine, FullPoly,
     UniqueNames,		/* force unique names */
     SnapPin,			/* snap to pins and pads */
     ShowSolderSide,		/* mirror output */
diff --git a/src/gts/gts.h b/src/gts/gts.h
index 99a92b7..9397230 100644
--- a/src/gts/gts.h
+++ b/src/gts/gts.h
@@ -1218,7 +1218,7 @@ GtsVertex *  gts_volume_optimized_vertex   (GtsEdge * edge,
 gdouble      gts_volume_optimized_cost     (GtsEdge * e,
 					    GtsVolumeOptimizedParams * params);
 
-/* Boolean operations: boolean.c */
+/* bool operations: boolean.c */
 
 GSList *     gts_surface_intersection      (GtsSurface * s1,
 					    GtsSurface * s2,
diff --git a/src/hid/gerber/gerber.c b/src/hid/gerber/gerber.c
index dee7d06..fa908ce 100644
--- a/src/hid/gerber/gerber.c
+++ b/src/hid/gerber/gerber.c
@@ -801,7 +801,7 @@ gerber_draw_rect (hidGC gc, int x1, int y1, int x2, int y2)
 static void
 gerber_draw_line (hidGC gc, int x1, int y1, int x2, int y2)
 {
-  Boolean m = False;
+  bool m = false;
 
   if (x1 != x2 && y1 != y2 && gc->cap == Square_Cap)
     {
@@ -831,13 +831,13 @@ gerber_draw_line (hidGC gc, int x1, int y1, int x2, int y2)
 
   if (x1 != lastX)
     {
-      m = True;
+      m = true;
       lastX = x1;
       fprintf (f, "X%ld", gerberX (PCB, lastX));
     }
   if (y1 != lastY)
     {
-      m = True;
+      m = true;
       lastY = y1;
       fprintf (f, "Y%ld", gerberY (PCB, lastY));
     }
@@ -867,7 +867,7 @@ static void
 gerber_draw_arc (hidGC gc, int cx, int cy, int width, int height,
 		 int start_angle, int delta_angle)
 {
-  Boolean m = False;
+  bool m = false;
   float arcStartX, arcStopX, arcStartY, arcStopY;
 
   /* we never draw zero-width lines */
@@ -922,13 +922,13 @@ gerber_draw_arc (hidGC gc, int cx, int cy, int width, int height,
   arcStopY = cy + height * sin (TO_RADIANS (start_angle + delta_angle));
   if (arcStartX != lastX)
     {
-      m = True;
+      m = true;
       lastX = arcStartX;
       fprintf (f, "X%ld", gerberX (PCB, lastX));
     }
   if (arcStartY != lastY)
     {
-      m = True;
+      m = true;
       lastY = arcStartY;
       fprintf (f, "Y%ld", gerberY (PCB, lastY));
     }
@@ -989,7 +989,7 @@ gerber_fill_circle (hidGC gc, int cx, int cy, int radius)
 static void
 gerber_fill_polygon (hidGC gc, int n_coords, int *x, int *y)
 {
-  Boolean m = False;
+  bool m = false;
   int i;
   int firstTime = 1;
   LocationType startX = 0, startY = 0;
@@ -1005,13 +1005,13 @@ gerber_fill_polygon (hidGC gc, int n_coords, int *x, int *y)
     {
       if (x[i] != lastX)
 	{
-	  m = True;
+	  m = true;
 	  lastX = x[i];
 	  fprintf (f, "X%ld", gerberX (PCB, lastX));
 	}
       if (y[i] != lastY)
 	{
-	  m = True;
+	  m = true;
 	  lastY = y[i];
 	  fprintf (f, "Y%ld", gerberY (PCB, lastY));
 	}
@@ -1025,17 +1025,17 @@ gerber_fill_polygon (hidGC gc, int n_coords, int *x, int *y)
 	}
       else if (m)
 	fprintf (f, "D01*\015\012");
-      m = False;
+      m = false;
     }
   if (startX != lastX)
     {
-      m = True;
+      m = true;
       lastX = startX;
       fprintf (f, "X%ld", gerberX (PCB, startX));
     }
   if (startY != lastY)
     {
-      m = True;
+      m = true;
       lastY = startY;
       fprintf (f, "Y%ld", gerberY (PCB, lastY));
     }
diff --git a/src/hid/gtk/gui-command-window.c b/src/hid/gtk/gui-command-window.c
index 15dd6db..ef2f637 100644
--- a/src/hid/gtk/gui-command-window.c
+++ b/src/hid/gtk/gui-command-window.c
@@ -211,9 +211,9 @@ command_entry_activate_cb (GtkWidget * widget, gpointer data)
 
   if (ghidgui->use_command_window)
     {
-      HideCrosshair (True);
+      HideCrosshair (true);
       hid_parse_command (command);
-      RestoreCrosshair (True);
+      RestoreCrosshair (true);
       g_free (command);
     }
   else
@@ -462,7 +462,7 @@ ghid_handle_user_command (gboolean raise)
     ghid_command_window_show (raise);
   else
     {
-      HideCrosshair (True);
+      HideCrosshair (true);
       command = ghid_command_entry_get (_("Enter command:"),
 		      (Settings.SaveLastCommand && previous) ? previous : "");
       if (command != NULL)
@@ -479,7 +479,7 @@ ghid_handle_user_command (gboolean raise)
 	  hid_parse_command (command);
 	  g_free (command);
 	}
-      RestoreCrosshair (True);
+      RestoreCrosshair (true);
     }
   ghid_set_status_line_label ();
 }
diff --git a/src/hid/gtk/gui-dialog-size.c b/src/hid/gtk/gui-dialog-size.c
index 90d2cd4..2f49f06 100644
--- a/src/hid/gtk/gui-dialog-size.c
+++ b/src/hid/gtk/gui-dialog-size.c
@@ -218,7 +218,7 @@ ghid_route_style_dialog (gint index, RouteStyleType * temp_rst)
 			  FROM_PCB_UNITS (rst->Keepaway),
 			  FROM_PCB_UNITS (MIN_LINESIZE),
 			  FROM_PCB_UNITS (MAX_LINESIZE), STEP0_SIZE,
-			  STEP1_SIZE, SPIN_DIGITS, 0, NULL, sd, True,
+			  STEP1_SIZE, SPIN_DIGITS, 0, NULL, sd, true,
 			  _("Clearance"));
   gtk_box_pack_start (GTK_BOX (vbox1), table, FALSE, FALSE, 0);
 
@@ -311,7 +311,7 @@ ghid_route_style_dialog (gint index, RouteStyleType * temp_rst)
 	  SaveFree (rst->Name);
 	  rst->Name = StripWhiteSpaceAndDup (string);
 	  pcb_use_route_style (rst);
-	  SetChangedFlag (True);
+	  SetChangedFlag (true);
 	  ghid_route_style_set_button_label (rst->Name, index);
 	}
       else
diff --git a/src/hid/gtk/gui-drc-window.c b/src/hid/gtk/gui-drc-window.c
index fa2ec86..e2fa201 100644
--- a/src/hid/gtk/gui-drc-window.c
+++ b/src/hid/gtk/gui-drc-window.c
@@ -103,7 +103,7 @@ unset_found_flags (int AndDraw)
 	AddObjectToFlagUndoList (VIA_TYPE, via, via, via);
 	CLEAR_FLAG (flag, via);
 	DrawVia (via, 0);
-	change = True;
+	change = true;
       }
   }
   END_LOOP;
@@ -116,7 +116,7 @@ unset_found_flags (int AndDraw)
 	  AddObjectToFlagUndoList (PIN_TYPE, element, pin, pin);
 	  CLEAR_FLAG (flag, pin);
 	  DrawPin (pin, 0);
-	  change = True;
+	  change = true;
 	}
     }
     END_LOOP;
@@ -127,7 +127,7 @@ unset_found_flags (int AndDraw)
 	  AddObjectToFlagUndoList (PAD_TYPE, element, pad, pad);
 	  CLEAR_FLAG (flag, pad);
 	  DrawPad (pad, 0);
-	  change = True;
+	  change = true;
 	}
     }
     END_LOOP;
@@ -140,7 +140,7 @@ unset_found_flags (int AndDraw)
 	AddObjectToFlagUndoList (RATLINE_TYPE, line, line, line);
 	CLEAR_FLAG (flag, line);
 	DrawRat (line, 0);
-	change = True;
+	change = true;
       }
   }
   END_LOOP;
@@ -151,7 +151,7 @@ unset_found_flags (int AndDraw)
 	AddObjectToFlagUndoList (LINE_TYPE, layer, line, line);
 	CLEAR_FLAG (flag, line);
 	DrawLine (layer, line, 0);
-	change = True;
+	change = true;
       }
   }
   ENDALL_LOOP;
@@ -162,7 +162,7 @@ unset_found_flags (int AndDraw)
 	AddObjectToFlagUndoList (ARC_TYPE, layer, arc, arc);
 	CLEAR_FLAG (flag, arc);
 	DrawArc (layer, arc, 0);
-	change = True;
+	change = true;
       }
   }
   ENDALL_LOOP;
@@ -173,13 +173,13 @@ unset_found_flags (int AndDraw)
 	AddObjectToFlagUndoList (POLYGON_TYPE, layer, polygon, polygon);
 	CLEAR_FLAG (flag, polygon);
 	DrawPolygon (layer, polygon, 0);
-	change = True;
+	change = true;
       }
   }
   ENDALL_LOOP;
   if (change)
     {
-      SetChangedFlag (True);
+      SetChangedFlag (true);
       if (AndDraw)
 	{
 	  IncrementUndoSerialNumber ();
@@ -198,7 +198,7 @@ selection_changed_cb (GtkTreeSelection *selection, gpointer user_data)
 
   if (!gtk_tree_selection_get_selected (selection, &model, &iter))
     {
-      unset_found_flags (True);
+      unset_found_flags (true);
       return;
     }
 
@@ -208,7 +208,7 @@ selection_changed_cb (GtkTreeSelection *selection, gpointer user_data)
 
   gtk_tree_model_get (model, &iter, DRC_VIOLATION_OBJ_COL, &violation, -1);
 
-  unset_found_flags (False);
+  unset_found_flags (false);
 
   if (violation == NULL)
     return;
@@ -236,11 +236,11 @@ selection_changed_cb (GtkTreeSelection *selection, gpointer user_data)
 	case LINE_TYPE:
 	case ARC_TYPE:
 	case POLYGON_TYPE:
-	  ChangeGroupVisibility (GetLayerNumber (PCB->Data, (LayerTypePtr) ptr1), True, True);
+	  ChangeGroupVisibility (GetLayerNumber (PCB->Data, (LayerTypePtr) ptr1), true, true);
 	}
       DrawObject (object_type, ptr1, ptr2, 0);
     }
-  SetChangedFlag (True);
+  SetChangedFlag (true);
   IncrementUndoSerialNumber ();
   Draw();
 }
@@ -260,7 +260,7 @@ row_activated_cb (GtkTreeView *view, GtkTreePath *path,
   if (violation == NULL)
     return;
 
-  CenterDisplay (violation->x_coord, violation->y_coord, False);
+  CenterDisplay (violation->x_coord, violation->y_coord, false);
 }
 
 
diff --git a/src/hid/gtk/gui-library-window.c b/src/hid/gtk/gui-library-window.c
index 8bd0d7b..f54d914 100644
--- a/src/hid/gtk/gui-library-window.c
+++ b/src/hid/gtk/gui-library-window.c
@@ -341,7 +341,7 @@ library_window_callback_tree_selection_changed (GtkTreeSelection * selection,
    */
   if (entry->Template == (char *) -1)
     {
-      if (LoadElementToBuffer (PASTEBUFFER, entry->AllocatedMemory, True))
+      if (LoadElementToBuffer (PASTEBUFFER, entry->AllocatedMemory, true))
 	SetMode (PASTEBUFFER_MODE);
       goto out;
     }
@@ -353,7 +353,7 @@ library_window_callback_tree_selection_changed (GtkTreeSelection * selection,
   m4_args = g_strdup_printf ("'%s' '%s' '%s'", EMPTY (entry->Template),
 			     EMPTY (entry->Value), EMPTY (entry->Package));
 
-  if (LoadElementToBuffer (PASTEBUFFER, m4_args, False))
+  if (LoadElementToBuffer (PASTEBUFFER, m4_args, false))
     SetMode (PASTEBUFFER_MODE);
   g_free (m4_args);
 
diff --git a/src/hid/gtk/gui-misc.c b/src/hid/gtk/gui-misc.c
index e8ad916..32ca1c9 100644
--- a/src/hid/gtk/gui-misc.c
+++ b/src/hid/gtk/gui-misc.c
@@ -402,12 +402,12 @@ run_get_location_loop (const gchar * message)
   oldObjState = Crosshair.AttachedObject.State;
   oldLineState = Crosshair.AttachedLine.State;
   oldBoxState = Crosshair.AttachedBox.State;
-  HideCrosshair (True);
+  HideCrosshair (true);
   Crosshair.AttachedObject.State = STATE_FIRST;
   Crosshair.AttachedLine.State = STATE_FIRST;
   Crosshair.AttachedBox.State = STATE_FIRST;
   ghid_hand_cursor ();
-  RestoreCrosshair (True);
+  RestoreCrosshair (true);
 
   /* Stop the top level GMainLoop from getting user input from keyboard
      |  and mouse so we can install our own handlers here.  Also set the
@@ -438,11 +438,11 @@ run_get_location_loop (const gchar * message)
   ghid_interface_input_signals_connect ();	/* return to normal */
   ghid_interface_set_sensitive (TRUE);
 
-  HideCrosshair (True);
+  HideCrosshair (true);
   Crosshair.AttachedObject.State = oldObjState;
   Crosshair.AttachedLine.State = oldLineState;
   Crosshair.AttachedBox.State = oldBoxState;
-  RestoreCrosshair (True);
+  RestoreCrosshair (true);
   ghid_restore_cursor ();
 
   ghid_set_status_line_label ();
diff --git a/src/hid/gtk/gui-netlist-window.c b/src/hid/gtk/gui-netlist-window.c
index 0cfe51d..1d8e939 100644
--- a/src/hid/gtk/gui-netlist-window.c
+++ b/src/hid/gtk/gui-netlist-window.c
@@ -516,17 +516,17 @@ netlist_select_cb (GtkWidget * widget, gpointer data)
     node_selected_net = NULL;
 
   InitConnectionLookup ();
-  ResetFoundPinsViasAndPads (False);
-  ResetFoundLinesAndPolygons (False);
+  ResetFoundPinsViasAndPads (false);
+  ResetFoundLinesAndPolygons (false);
   SaveUndoSerialNumber ();
 
   for (i = selected_net->EntryN, entry = selected_net->Entry; i; i--, entry++)
-    if (SeekPad (entry, &conn, False))
-      RatFindHook (conn.type, conn.ptr1, conn.ptr2, conn.ptr2, True, True);
+    if (SeekPad (entry, &conn, false))
+      RatFindHook (conn.type, conn.ptr1, conn.ptr2, conn.ptr2, true, true);
   RestoreUndoSerialNumber ();
   SelectConnection (select_flag);
-  ResetFoundPinsViasAndPads (False);
-  ResetFoundLinesAndPolygons (False);
+  ResetFoundPinsViasAndPads (false);
+  ResetFoundLinesAndPolygons (false);
   FreeConnectionLookupMemory ();
   IncrementUndoSerialNumber ();
   ghid_invalidate_all ();
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index 3912aa3..c82e067 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -60,7 +60,7 @@ static gint x_pan_speed, y_pan_speed;
 
 /* Set to true if cursor is currently in viewport. This is a hack to prevent
  * Crosshair stack corruption due to unmatching window enter / leave events */
-gboolean cursor_in_viewport = False;
+gboolean cursor_in_viewport = false;
 
 void
 ghid_port_ranges_changed (void)
@@ -253,7 +253,7 @@ ghid_note_event_location (GdkEventButton * ev)
   if (moved)
     {
       AdjustAttachedObjects ();
-      RestoreCrosshair (False);
+      RestoreCrosshair (false);
     }
   ghid_set_cursor_position_labels ();
   return moved;
diff --git a/src/hid/gtk/gui-top-window.c b/src/hid/gtk/gui-top-window.c
index 09a29c1..4d4ba7c 100644
--- a/src/hid/gtk/gui-top-window.c
+++ b/src/hid/gtk/gui-top-window.c
@@ -1350,7 +1350,7 @@ layer_select_button_cb (GtkWidget * widget, LayerButtonSet * lb)
   PCB->RatDraw = (lb->index == LAYER_BUTTON_RATS);
 
   if (lb->index < max_layer)
-    ChangeGroupVisibility (lb->index, True, True);
+    ChangeGroupVisibility (lb->index, true, true);
 
   layer_select_button_index = lb->index;
 
@@ -1425,12 +1425,12 @@ layer_enable_button_cb (GtkWidget * widget, gpointer data)
 	{
 	  for (i = (layer + 1) % (max_layer + 1); i != layer;
 	       i = (i + 1) % (max_layer + 1))
-	    if (PCB->Data->Layer[i].On == True &&
+	    if (PCB->Data->Layer[i].On == true &&
 		GetGroupOfLayer (i) != group)
 	      break;
 	  if (i != layer)
 	    {
-	      ChangeGroupVisibility ((int) i, True, True);
+	      ChangeGroupVisibility ((int) i, true, true);
 	    }
 	  else
 	    {
@@ -1440,7 +1440,7 @@ layer_enable_button_cb (GtkWidget * widget, gpointer data)
 	    }
 	}
       /* switch layer group on/off */
-      ChangeGroupVisibility (layer, active, False);
+      ChangeGroupVisibility (layer, active, false);
       redraw = TRUE;
       break;
     }
diff --git a/src/hid/lesstif/dialogs.c b/src/hid/lesstif/dialogs.c
index ac61c7c..6ab4b78 100644
--- a/src/hid/lesstif/dialogs.c
+++ b/src/hid/lesstif/dialogs.c
@@ -135,7 +135,7 @@ Load (int argc, char **argv, int x, int y)
 
   n = 0;
   stdarg (XmNpattern, pattern);
-  stdarg (XmNmustMatch, True);
+  stdarg (XmNmustMatch, true);
   stdarg (XmNselectionLabelString, xms_load);
   XtSetValues (fsb, args, n);
 
@@ -188,7 +188,7 @@ LoadVendor (int argc, char **argv, int x, int y)
 
   n = 0;
   stdarg (XmNpattern, pattern);
-  stdarg (XmNmustMatch, True);
+  stdarg (XmNmustMatch, true);
   stdarg (XmNselectionLabelString, xms_loadv);
   XtSetValues (fsb, args, n);
 
@@ -255,7 +255,7 @@ Save (int argc, char **argv, int x, int y)
 
   n = 0;
   stdarg (XmNpattern, pattern);
-  stdarg (XmNmustMatch, False);
+  stdarg (XmNmustMatch, false);
   stdarg (XmNselectionLabelString, xms_save);
   XtSetValues (fsb, args, n);
 
@@ -325,7 +325,7 @@ lesstif_logv (const char *fmt, va_list ap)
       Widget clear_button, dismiss_button;
 
       n = 0;
-      stdarg (XmNautoUnmanage, False);
+      stdarg (XmNautoUnmanage, false);
       stdarg (XmNwidth, 600);
       stdarg (XmNheight, 200);
       stdarg (XmNtitle, "PCB Log");
@@ -349,9 +349,9 @@ lesstif_logv (const char *fmt, va_list ap)
 		     (XtCallbackProc) log_dismiss, 0);
 
       n = 0;
-      stdarg (XmNeditable, False);
+      stdarg (XmNeditable, false);
       stdarg (XmNeditMode, XmMULTI_LINE_EDIT);
-      stdarg (XmNcursorPositionVisible, True);
+      stdarg (XmNcursorPositionVisible, true);
       stdarg (XmNtopAttachment, XmATTACH_FORM);
       stdarg (XmNleftAttachment, XmATTACH_FORM);
       stdarg (XmNrightAttachment, XmATTACH_FORM);
@@ -474,7 +474,7 @@ lesstif_confirm_dialog (char *msg, ...)
   wait_for_dialog (confirm_dialog);
 
   n = 0;
-  stdarg (XmNdefaultPosition, False);
+  stdarg (XmNdefaultPosition, false);
   XtSetValues (confirm_dialog, args, n);
 
   return ok;
@@ -511,16 +511,16 @@ lesstif_report_dialog (char *title, char *msg)
 	return;
 
       n = 0;
-      stdarg (XmNautoUnmanage, False);
+      stdarg (XmNautoUnmanage, false);
       stdarg (XmNwidth, 600);
       stdarg (XmNheight, 200);
       stdarg (XmNtitle, title);
       report_form = XmCreateFormDialog (mainwind, "report", args, n);
 
       n = 0;
-      stdarg (XmNeditable, False);
+      stdarg (XmNeditable, false);
       stdarg (XmNeditMode, XmMULTI_LINE_EDIT);
-      stdarg (XmNcursorPositionVisible, False);
+      stdarg (XmNcursorPositionVisible, false);
       stdarg (XmNtopAttachment, XmATTACH_FORM);
       stdarg (XmNleftAttachment, XmATTACH_FORM);
       stdarg (XmNrightAttachment, XmATTACH_FORM);
@@ -560,7 +560,7 @@ lesstif_prompt_for (char *msg, char *default_string)
   if (prompt_dialog == 0)
     {
       n = 0;
-      stdarg (XmNautoUnmanage, False);
+      stdarg (XmNautoUnmanage, false);
       stdarg (XmNtitle, "PCB Prompt");
       prompt_dialog = XmCreateFormDialog (mainwind, "prompt", args, n);
 
@@ -578,7 +578,7 @@ lesstif_prompt_for (char *msg, char *default_string)
       stdarg (XmNbottomAttachment, XmATTACH_WIDGET);
       stdarg (XmNleftAttachment, XmATTACH_FORM);
       stdarg (XmNrightAttachment, XmATTACH_FORM);
-      stdarg (XmNeditable, True);
+      stdarg (XmNeditable, true);
       prompt_text = XmCreateText (prompt_dialog, "text", args, n);
       XtManageChild (prompt_text);
       XtAddCallback (prompt_text, XmNactivateCallback,
@@ -752,20 +752,20 @@ lesstif_attribute_dialog (HID_Attribute * attrs,
 	  break;
 	case HID_String:
 	  stdarg (XmNcolumns, 40);
-	  stdarg (XmNresizeWidth, True);
+	  stdarg (XmNresizeWidth, true);
 	  stdarg (XmNvalue, results[i].str_value);
 	  wl[i] = XmCreateTextField (form, attrs[i].name, args, n);
 	  break;
 	case HID_Integer:
 	  stdarg (XmNcolumns, 13);
-	  stdarg (XmNresizeWidth, True);
+	  stdarg (XmNresizeWidth, true);
 	  sprintf (buf, "%d", results[i].int_value);
 	  stdarg (XmNvalue, buf);
 	  wl[i] = XmCreateTextField (form, attrs[i].name, args, n);
 	  break;
 	case HID_Real:
 	  stdarg (XmNcolumns, 16);
-	  stdarg (XmNresizeWidth, True);
+	  stdarg (XmNresizeWidth, true);
 	  sprintf (buf, "%g", results[i].real_value);
 	  stdarg (XmNvalue, buf);
 	  wl[i] = XmCreateTextField (form, attrs[i].name, args, n);
@@ -1269,7 +1269,7 @@ AdjustSizes (int argc, char **argv, int x, int y)
       stdarg (XmNmarginHeight, 3);
       stdarg (XmNhorizontalSpacing, 3);
       stdarg (XmNverticalSpacing, 3);
-      stdarg (XmNautoUnmanage, False);
+      stdarg (XmNautoUnmanage, false);
       stdarg (XmNtitle, "Board Sizes");
       sizes_dialog = XmCreateFormDialog (mainwind, "sizes", args, n);
 
@@ -1640,8 +1640,8 @@ EditLayerGroups (int argc, char **argv, int x, int y)
 	      stdarg (XmNbottomPosition, (i + 1) * MAX_LAYER);
 	      stdarg (XmNlabelString, XmStringCreateLocalized (" "));
 	      stdarg (XmNspacing, 0);
-	      stdarg (XmNvisibleWhenOff, True);
-	      stdarg (XmNfillOnSelect, True);
+	      stdarg (XmNvisibleWhenOff, true);
+	      stdarg (XmNfillOnSelect, true);
 	      stdarg (XmNshadowThickness, 0);
 	      stdarg (XmNmarginWidth, 0);
 	      stdarg (XmNmarginHeight, 0);
@@ -1794,14 +1794,14 @@ lesstif_attributes_need_rows (int new_max)
 		     (XtPointer) attr_max_rows);
 
       n = 0;
-      stdarg (XmNresizeWidth, True);
+      stdarg (XmNresizeWidth, true);
       attr_row[attr_max_rows].w_name = XmCreateTextField (f_top, "name", args, n);
       XtManageChild (attr_row[attr_max_rows].w_name);
       XtAddCallback (attr_row[attr_max_rows].w_name, XmNvalueChangedCallback,
 		     (XtCallbackProc) fiddle_with_bb_layout, NULL);
 
       n = 0;
-      stdarg (XmNresizeWidth, True);
+      stdarg (XmNresizeWidth, true);
       attr_row[attr_max_rows].w_value = XmCreateTextField (f_top, "value", args, n);
       XtManageChild (attr_row[attr_max_rows].w_value);
       XtAddCallback (attr_row[attr_max_rows].w_value, XmNvalueChangedCallback,
@@ -1897,7 +1897,7 @@ lesstif_attributes_dialog (char *owner, AttributeListType *attrs_list)
   if (attr_dialog == NULL)
     {
       n = 0;
-      stdarg (XmNautoUnmanage, False);
+      stdarg (XmNautoUnmanage, false);
       stdarg (XmNtitle, owner);
       stdarg (XmNwidth, 400);
       stdarg (XmNheight, 300);
@@ -2049,7 +2049,7 @@ ImportGUI (int argc, char **argv, int x, int y)
 
   n = 0;
   stdarg (XmNpattern, xms_sch);
-  stdarg (XmNmustMatch, True);
+  stdarg (XmNmustMatch, true);
   stdarg (XmNselectionLabelString, xms_import);
   XtSetValues (fsb, args, n);
 
diff --git a/src/hid/lesstif/library.c b/src/hid/lesstif/library.c
index cc6c7cc..f818fe5 100644
--- a/src/hid/lesstif/library.c
+++ b/src/hid/lesstif/library.c
@@ -75,13 +75,13 @@ libnode_select (Widget w, void *v, XmListCallbackStruct * cbs)
 
   if (e->Template == (char *) -1)
     {
-      if (LoadElementToBuffer (PASTEBUFFER, e->AllocatedMemory, True))
+      if (LoadElementToBuffer (PASTEBUFFER, e->AllocatedMemory, true))
 	SetMode (PASTEBUFFER_MODE);
       return;
     }
   args = Concat("'", EMPTY (e->Template), "' '",
 		EMPTY (e->Value), "' '", EMPTY (e->Package), "'", NULL);
-  if (LoadElementToBuffer (PASTEBUFFER, args, False))
+  if (LoadElementToBuffer (PASTEBUFFER, args, false))
     SetMode (PASTEBUFFER_MODE);
 }
 
diff --git a/src/hid/lesstif/main.c b/src/hid/lesstif/main.c
index 1613547..bc8f17c 100644
--- a/src/hid/lesstif/main.c
+++ b/src/hid/lesstif/main.c
@@ -646,7 +646,7 @@ command_callback (Widget w, XtPointer uptr, XmTextVerifyCallbackStruct * cbs)
 }
 
 static void
-command_event_handler (Widget w, XtPointer p, XEvent * e, Boolean * cont)
+command_event_handler (Widget w, XtPointer p, XEvent * e, bool * cont)
 {
   char buf[10];
   KeySym sym;
@@ -662,7 +662,7 @@ command_event_handler (Widget w, XtPointer p, XEvent * e, Boolean * cont)
 	  XtUnmanageChild (m_cmd);
 	  XtUnmanageChild (m_cmd_label);
 	  XmTextSetString (w, "");
-	  *cont = False;
+	  *cont = false;
 	  break;
 	}
       break;
@@ -1275,7 +1275,7 @@ mod_changed (XKeyEvent * e, int set)
 }
 
 static void
-work_area_input (Widget w, XtPointer v, XEvent * e, Boolean * ctd)
+work_area_input (Widget w, XtPointer v, XEvent * e, bool * ctd)
 {
   static int pressed_button = 0;
   static int ignore_release = 0;
@@ -1306,7 +1306,7 @@ work_area_input (Widget w, XtPointer v, XEvent * e, Boolean * ctd)
 	}
         ignore_release = 0;
 
-        HideCrosshair (True);
+        HideCrosshair (true);
         pressed_button = e->xbutton.button;
         mods = ((e->xbutton.state & ShiftMask) ? M_Shift : 0)
           + ((e->xbutton.state & ControlMask) ? M_Ctrl : 0)
@@ -1316,7 +1316,7 @@ work_area_input (Widget w, XtPointer v, XEvent * e, Boolean * ctd)
           + ((e->xbutton.state & Mod1Mask) ? M_Alt : 0);
 #endif
         do_mouse_action(e->xbutton.button, mods);
-        RestoreCrosshair (True);
+        RestoreCrosshair (true);
         break;
       }
 
@@ -1326,7 +1326,7 @@ work_area_input (Widget w, XtPointer v, XEvent * e, Boolean * ctd)
         if (e->xbutton.button != pressed_button)
           return;
         lesstif_button_event (w, e);
-        HideCrosshair (True);
+        HideCrosshair (true);
         pressed_button = 0;
         mods = ((e->xbutton.state & ShiftMask) ? M_Shift : 0)
           + ((e->xbutton.state & ControlMask) ? M_Ctrl : 0)
@@ -1337,7 +1337,7 @@ work_area_input (Widget w, XtPointer v, XEvent * e, Boolean * ctd)
 #endif
           + M_Release;
         do_mouse_action (e->xbutton.button, mods);
-        RestoreCrosshair (True);
+        RestoreCrosshair (true);
         break;
       }
 
@@ -1654,7 +1654,7 @@ work_area_first_expose (Widget work_area, void *me,
       XRenderColor a = {0, 0, 0, 0x8000};
 
       pale_pixmap = XCreatePixmap (display, window, 1, 1, 8);
-      pa.repeat = True;
+      pa.repeat = true;
       pale_picture = XRenderCreatePicture (display, pale_pixmap,
 			    XRenderFindStandardFormat(display, PictStandardA8),
 			    CPRepeat, &pa);
@@ -1794,7 +1794,7 @@ lesstif_do_export (HID_Attr_Val * options)
   XtManageChild (hscroll);
 
   n = 0;
-  stdarg (XmNresize, True);
+  stdarg (XmNresize, true);
   stdarg (XmNresizePolicy, XmRESIZE_ANY);
   messages = XmCreateForm (mainwind, "messages", args, n);
   XtManageChild (messages);
@@ -1889,7 +1889,7 @@ typedef union
   char *s;
 } val_union;
 
-static Boolean
+static bool
 cvtres_string_to_double (Display * d, XrmValue * args, Cardinal * num_args,
 			 XrmValue * from, XrmValue * to,
 			 XtPointer * converter_data)
@@ -1901,7 +1901,7 @@ cvtres_string_to_double (Display * d, XrmValue * args, Cardinal * num_args,
   else
     to->addr = (XPointer) & rv;
   to->size = sizeof (rv);
-  return True;
+  return true;
 }
 
 static void
@@ -2020,7 +2020,7 @@ lesstif_parse_arguments (int *argc, char ***argv)
 	    break;
 	  case HID_Boolean:
 	    o->argKind = XrmoptionNoArg;
-	    o->value = "True";
+	    o->value = "true";
 	    acount++;
 	    break;
 	  default:
@@ -2091,7 +2091,7 @@ lesstif_parse_arguments (int *argc, char ***argv)
   XmAddWMProtocolCallback (appwidget, close_atom,
 			   (XtCallbackProc) mainwind_delete_cb, 0);
 
-  /*  XSynchronize(display, True); */
+  /*  XSynchronize(display, true); */
 
   XtGetApplicationResources (appwidget, new_values, new_resources,
 			     rmax, 0, 0);
@@ -2381,7 +2381,7 @@ lesstif_update_status_line ()
 static int idle_proc_set = 0;
 static int need_redraw = 0;
 
-static Boolean
+static bool
 idle_proc (XtPointer dummy)
 {
   if (need_redraw)
@@ -2771,7 +2771,7 @@ idle_proc (XtPointer dummy)
 
   show_crosshair (1);
   idle_proc_set = 0;
-  return True;
+  return true;
 }
 
 void
diff --git a/src/hid/lesstif/menu.c b/src/hid/lesstif/menu.c
index f88664d..59ab80b 100644
--- a/src/hid/lesstif/menu.c
+++ b/src/hid/lesstif/menu.c
@@ -271,7 +271,7 @@ LayersChanged (int argc, char **argv, int x, int y)
 	    {
 	      stdarg (XmNforeground, bg_color);
 	      stdarg (XmNbackground, fg_colors[i]);
-	      stdarg (XmNset, current_layer == i ? True : False);
+	      stdarg (XmNset, current_layer == i ? true : false);
 	    }
 	  XtSetValues (lb->w[i], args, n);
 
@@ -398,7 +398,7 @@ layerpick_button_callback (Widget w, int layer,
       if (!lb->is_pick)
 	continue;
       for (i = 0; i < LB_NUMPICK; i++)
-	XmToggleButtonSetState (lb->w[i], layer == i, False);
+	XmToggleButtonSetState (lb->w[i], layer == i, false);
     }
   switch (layer)
     {
@@ -1305,7 +1305,7 @@ add_resource_to_menu (Widget menu, Resource * node, XtCallbackProc callback)
 
 		if (resource_value (node->v[i].subres, "set"))
 		  {
-		    stdarg (XmNset, True);
+		    stdarg (XmNset, true);
 		  }
 		stdarg (XmNindicatorType, XmONE_OF_MANY);
 		btn = XmCreateToggleButton (menu, "menubutton", args, n);
diff --git a/src/hid/lesstif/netlist.c b/src/hid/lesstif/netlist.c
index ba4415c..7d31197 100644
--- a/src/hid/lesstif/netlist.c
+++ b/src/hid/lesstif/netlist.c
@@ -89,7 +89,7 @@ netlist_select (Widget w, void *v, XmListCallbackStruct * cbs)
   str = XmStringCreateLocalized (name);
   XmListReplaceItemsPos (netlist_list, &str, 1, pos);
   XmStringFree (str);
-  XmListSelectPos (netlist_list, pos, False);
+  XmListSelectPos (netlist_list, pos, false);
 }
 
 static void
@@ -136,17 +136,17 @@ nbcb_select_common (LibraryMenuTypePtr net, int pos, int select_flag)
   int i;
 
   InitConnectionLookup ();
-  ResetFoundPinsViasAndPads (False);
-  ResetFoundLinesAndPolygons (False);
+  ResetFoundPinsViasAndPads (false);
+  ResetFoundLinesAndPolygons (false);
   SaveUndoSerialNumber ();
 
   for (i = net->EntryN, entry = net->Entry; i; i--, entry++)
-    if (SeekPad (entry, &conn, False))
-      RatFindHook (conn.type, conn.ptr1, conn.ptr2, conn.ptr2, True, True);
+    if (SeekPad (entry, &conn, false))
+      RatFindHook (conn.type, conn.ptr1, conn.ptr2, conn.ptr2, true, true);
   RestoreUndoSerialNumber ();
   SelectConnection (select_flag);
-  ResetFoundPinsViasAndPads (False);
-  ResetFoundLinesAndPolygons (False);
+  ResetFoundPinsViasAndPads (false);
+  ResetFoundLinesAndPolygons (false);
   FreeConnectionLookupMemory ();
   IncrementUndoSerialNumber ();
 }
@@ -175,7 +175,7 @@ nbcb_std_callback (Widget w, Std_Nbcb_Func v, XmPushButtonCallbackStruct * cbs)
 {
   int *posl, posc, i;
   XmString **items, **selected;
-  if (XmListGetSelectedPos (netlist_list, &posl, &posc) == False)
+  if (XmListGetSelectedPos (netlist_list, &posl, &posc) == false)
     return;
   if (v == nbcb_find)
     hid_actionl ("connection", "reset", NULL);
@@ -314,7 +314,7 @@ build_netlist_dialog ()
   n = 0;
   stdarg (XmNresizePolicy, XmRESIZE_GROW);
   stdarg (XmNtitle, "Netlists");
-  stdarg (XmNautoUnmanage, False);
+  stdarg (XmNautoUnmanage, false);
   netlist_dialog = XmCreateFormDialog (mainwind, "netlist", args, n);
 
   n = 0;
@@ -435,15 +435,15 @@ LesstifNetlistShow (int argc, char **argv, int x, int y)
 	  XmString item;
 	  int vis = 0;
 
-	  /* Select net first, 'True' causes pick_net() to be invoked */
+	  /* Select net first, 'true' causes pick_net() to be invoked */
 	  item = XmStringCreateLocalized (net->Name);
-	  XmListSelectItem (netlist_list, item, True);
+	  XmListSelectItem (netlist_list, item, true);
 	  XmListSetItem (netlist_list, item);
 	  XmStringFree (item);
 
 	  /* Now the netnode_list has the right contents */
 	  item = XmStringCreateLocalized (argv[0]);
-	  XmListSelectItem (netnode_list, item, False);
+	  XmListSelectItem (netnode_list, item, false);
 
 	  /*
 	   * Only force the item to the top if there are enough to scroll.
@@ -470,7 +470,7 @@ LesstifNetlistShow (int argc, char **argv, int x, int y)
 
 	      item = XmStringCreateLocalized (net->Name);
 	      XmListSetItem (netlist_list, item);
-	      XmListSelectItem (netlist_list, item, True);
+	      XmListSelectItem (netlist_list, item, true);
 	      XmStringFree (item);
 	    }
 	}
diff --git a/src/hid/lesstif/styles.c b/src/hid/lesstif/styles.c
index ec4e019..fb9d3b3 100644
--- a/src/hid/lesstif/styles.c
+++ b/src/hid/lesstif/styles.c
@@ -275,8 +275,8 @@ style_selected (Widget w, int i, XmToggleButtonCallbackStruct * cbs)
     }
   style = PCB->RouteStyle + i;
   SetLineSize (style->Thick);
-  SetViaSize (style->Diameter, True);
-  SetViaDrillingHole (style->Hole, True);
+  SetViaSize (style->Diameter, true);
+  SetViaDrillingHole (style->Hole, true);
   SetKeepawayWidth (style->Keepaway);
   if (style_dialog)
     {
@@ -364,7 +364,7 @@ AdjustStyle (int argc, char **argv, int x, int y)
       xms_mil = XmStringCreateLocalized ("mil");
 
       n = 0;
-      stdarg (XmNautoUnmanage, False);
+      stdarg (XmNautoUnmanage, false);
       stdarg (XmNtitle, "Route Styles");
       style_dialog = XmCreateFormDialog (mainwind, "style", args, n);
 
diff --git a/src/hid/nelma/nelma.c b/src/hid/nelma/nelma.c
index 8e5ff0c..68d7d5b 100644
--- a/src/hid/nelma/nelma.c
+++ b/src/hid/nelma/nelma.c
@@ -208,7 +208,7 @@ static int
 pin_name_to_xy(LibraryEntryType * pin, int *x, int *y)
 {
 	ConnectionType  conn;
-	if (!SeekPad(pin, &conn, False))
+	if (!SeekPad(pin, &conn, false))
 		return 1;
 	switch (conn.type) {
 	case PIN_TYPE:
diff --git a/src/insert.c b/src/insert.c
index 3d4a2f5..b4bcfe7 100644
--- a/src/insert.c
+++ b/src/insert.c
@@ -74,7 +74,7 @@ static void *InsertPointIntoRat (RatTypePtr);
 static LocationType InsertX,	/* used by local routines as offset */
   InsertY;
 static Cardinal InsertAt;
-static Boolean Forcible;
+static bool Forcible;
 static ObjectFunctionType InsertFunctions = {
   InsertPointIntoLine,
   NULL,
@@ -191,7 +191,7 @@ InsertPointIntoPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
   for (n = Polygon->PointN - 1; n > InsertAt; n--)
     Polygon->Points[n] = Polygon->Points[n - 1];
   Polygon->Points[InsertAt] = save;
-  SetChangedFlag (True);
+  SetChangedFlag (true);
   AddObjectToInsertPointUndoList (POLYGONPOINT_TYPE, Layer, Polygon,
 				  &Polygon->Points[InsertAt]);
   SetPolygonBoundingBox (Polygon);
@@ -210,7 +210,7 @@ InsertPointIntoPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
  */
 void *
 InsertPointIntoObject (int Type, void *Ptr1, void *Ptr2, Cardinal * Ptr3,
-		       LocationType DX, LocationType DY, Boolean Force)
+		       LocationType DX, LocationType DY, bool Force)
 {
   void *ptr;
 
diff --git a/src/insert.h b/src/insert.h
index bbe99d5..87b6cbb 100644
--- a/src/insert.h
+++ b/src/insert.h
@@ -39,7 +39,7 @@
  * prototypes
  */
 void *InsertPointIntoObject (int, void *, void *, Cardinal *, LocationType,
-			     LocationType, Boolean);
+			     LocationType, bool);
 PointTypePtr AdjustInsertPoint (void);
 
 #endif
diff --git a/src/line.c b/src/line.c
index ff2c884..943660a 100644
--- a/src/line.c
+++ b/src/line.c
@@ -52,7 +52,7 @@
 
 RCSID ("$Id$");
 
-static float drc_lines (PointTypePtr end, Boolean way);
+static float drc_lines (PointTypePtr end, bool way);
 
 /* ---------------------------------------------------------------------------
  * Adjust the attached line to 45 degrees if necessary
@@ -68,11 +68,11 @@ AdjustAttachedLine (void)
   /* don't draw outline when ctrl key is pressed */
   if (Settings.Mode == LINE_MODE && gui->control_is_pressed ())
     {
-      line->draw = False;
+      line->draw = false;
       return;
     }
   else
-    line->draw = True;
+    line->draw = true;
   /* no 45 degree lines required */
   if (PCB->RatDraw || TEST_FLAG (ALLDIRECTIONFLAG, PCB))
     {
@@ -180,11 +180,11 @@ AdjustTwoLine (int way)
   /* don't draw outline when ctrl key is pressed */
   if (gui->control_is_pressed ())
     {
-      line->draw = False;
+      line->draw = false;
       return;
     }
   else
-    line->draw = True;
+    line->draw = true;
   if (TEST_FLAG (ALLDIRECTIONFLAG, PCB))
     {
       line->Point2.X = Crosshair.X;
@@ -227,7 +227,7 @@ AdjustTwoLine (int way)
 struct drc_info
 {
   LineTypePtr line;
-  Boolean solder;
+  bool solder;
   jmp_buf env;
 };
 
@@ -287,7 +287,7 @@ drcArc_callback (const BoxType * b, void *cl)
  */
 
 static float
-drc_lines (PointTypePtr end, Boolean way)
+drc_lines (PointTypePtr end, bool way)
 {
   float f, s, f2, s2, len, best;
   LocationType dx, dy, temp, last, length;
@@ -295,7 +295,7 @@ drc_lines (PointTypePtr end, Boolean way)
   LineType line1, line2;
   Cardinal group, comp;
   struct drc_info info;
-  Boolean two_lines, x_is_long, blocker;
+  bool two_lines, x_is_long, blocker;
   PointType ans;
 
   f = 1.0;
@@ -311,21 +311,21 @@ drc_lines (PointTypePtr end, Boolean way)
   dx = end->X - line1.Point1.X;
   if (abs (dx) > abs (dy))
     {
-      x_is_long = True;
+      x_is_long = true;
       length = abs (dx);
     }
   else
     {
-      x_is_long = False;
+      x_is_long = false;
       length = abs (dy);
     }
   group = GetGroupOfLayer (INDEXOFCURRENT);
   comp = max_layer + 10;	/* this out-of-range group might save a call */
   if (GetLayerGroupNumberByNumber (max_layer + SOLDER_LAYER) == group)
-    info.solder = True;
+    info.solder = true;
   else
     {
-      info.solder = False;
+      info.solder = false;
       comp = GetLayerGroupNumberByNumber (max_layer + COMPONENT_LAYER);
     }
   temp = length;
@@ -352,14 +352,14 @@ drc_lines (PointTypePtr end, Boolean way)
       f2 = 1.0;
       s2 = 0.5;
       last2 = -1;
-      blocker = True;
+      blocker = true;
       while (length2 != last2)
 	{
 	  if (x_is_long)
 	    dy = SGN (dy) * length2;
 	  else
 	    dx = SGN (dx) * length2;
-	  two_lines = True;
+	  two_lines = true;
 	  if (abs (dx) > abs (dy) && x_is_long)
 	    {
 	      line1.Point2.X = line1.Point1.X +
@@ -378,7 +378,7 @@ drc_lines (PointTypePtr end, Boolean way)
 	      line1.Point2.X = line1.Point1.X + dx;
 	      line1.Point2.Y =
 		line1.Point1.Y + (way ? SGN (dy) * abs (dx) : 0);
-	      two_lines = False;
+	      two_lines = false;
 	    }
 	  else
 	    {
@@ -386,7 +386,7 @@ drc_lines (PointTypePtr end, Boolean way)
 	      line1.Point2.Y = line1.Point1.Y + dy;
 	      line1.Point2.X =
 		line1.Point1.X + (way ? SGN (dx) * abs (dy) : 0);
-	      two_lines = False;
+	      two_lines = false;
 	    }
 	  line2.Point1.X = line1.Point2.X;
 	  line2.Point1.Y = line1.Point2.Y;
@@ -442,7 +442,7 @@ drc_lines (PointTypePtr end, Boolean way)
 	      }
 	      END_LOOP;
 	      /* no intersector! */
-	      blocker = False;
+	      blocker = false;
 	      f2 += s2;
 	      len = (line2.Point2.X - line1.Point1.X);
 	      len *= len;
@@ -486,7 +486,7 @@ void
 EnforceLineDRC (void)
 {
   PointType r45, rs;
-  Boolean shift;
+  bool shift;
   float r1, r2;
 
   if ( gui->mod1_is_pressed() || gui->control_is_pressed () || PCB->RatDraw
@@ -495,9 +495,9 @@ EnforceLineDRC (void)
   rs.X = r45.X = Crosshair.X;
   rs.Y = r45.Y = Crosshair.Y;
   /* first try starting straight */
-  r1 = drc_lines (&rs, False);
+  r1 = drc_lines (&rs, false);
   /* then try starting at 45 */
-  r2 = drc_lines (&r45, True);
+  r2 = drc_lines (&r45, true);
   shift = gui->shift_is_pressed ();
   if (XOR (r1 > r2, shift))
     {
diff --git a/src/main.c b/src/main.c
index 8b80afe..3340c7f 100644
--- a/src/main.c
+++ b/src/main.c
@@ -966,7 +966,7 @@ main (int argc, char *argv[])
     }
 
   /* Create a new PCB object in memory */
-  PCB = CreateNewPCB (True);
+  PCB = CreateNewPCB (true);
   PCB->Data->LayerN = DEF_LAYER;
   ParseGroupString (Settings.Groups, &PCB->LayerGroups, DEF_LAYER);
   /* Add silk layers to newly created PCB */
diff --git a/src/misc.c b/src/misc.c
index 20048db..dfbb1d7 100644
--- a/src/misc.c
+++ b/src/misc.c
@@ -98,17 +98,17 @@ static void GetGridLockCoordinates (int, void *, void *, void *,
 
 static struct
 {
-  Boolean ElementOn, InvisibleObjectsOn, PinOn, ViaOn, RatOn;
+  bool ElementOn, InvisibleObjectsOn, PinOn, ViaOn, RatOn;
   int LayerStack[MAX_LAYER];
-  Boolean LayerOn[MAX_LAYER];
+  bool LayerOn[MAX_LAYER];
   int cnt;
 } SavedStack;
 
 /* Get Value returns a numeric value passed from the string and sets the
- * Boolean variable absolute to False if it leads with a +/- character
+ * bool variable absolute to false if it leads with a +/- character
  */
 float
-GetValue (char *val, char *units, Boolean * absolute)
+GetValue (char *val, char *units, bool * absolute)
 {
   float value;
 
@@ -117,15 +117,15 @@ GetValue (char *val, char *units, Boolean * absolute)
    */
   if (*val == '=')
     {
-      *absolute = True;
+      *absolute = true;
       value = atof (val + 1);
     }
   else
     {
       if (isdigit ((int) *val))
-        *absolute = True;
+        *absolute = true;
       else
-        *absolute = False;
+        *absolute = false;
       value = atof (val);
     }
   if (units && *units)
@@ -485,12 +485,12 @@ SetTextBoundingBox (FontTypePtr FontPtr, TextTypePtr Text)
 }
 
 /* ---------------------------------------------------------------------------
- * returns True if data area is empty
+ * returns true if data area is empty
  */
-Boolean
+bool
 IsDataEmpty (DataTypePtr Data)
 {
-  Boolean hasNoObjects;
+  bool hasNoObjects;
   Cardinal i;
 
   hasNoObjects = (Data->ViaN == 0);
@@ -597,7 +597,7 @@ GetDataBoundingBox (DataTypePtr Data)
  * coordinates
  */
 void
-CenterDisplay (LocationType X, LocationType Y, Boolean Delta)
+CenterDisplay (LocationType X, LocationType Y, bool Delta)
 {
   double save_grid = PCB->Grid;
   PCB->Grid = 1;
@@ -609,7 +609,7 @@ CenterDisplay (LocationType X, LocationType Y, Boolean Delta)
     {
       if (MoveCrosshairAbsolute (X, Y))
         {
-          RestoreCrosshair(False);
+          RestoreCrosshair(false);
         }
     }
   gui->set_crosshair (Crosshair.X, Crosshair.Y, HID_SC_WARP_POINTER);
@@ -778,8 +778,8 @@ int
 ParseGroupString (char *s, LayerGroupTypePtr LayerGroup, int LayerN)
 {
   int group, member, layer;
-  Boolean c_set = False,        /* flags for the two special layers to */
-    s_set = False;              /* provide a default setting for old formats */
+  bool c_set = false,        /* flags for the two special layers to */
+    s_set = false;              /* provide a default setting for old formats */
   int groupnum[MAX_LAYER + 2];
 
   /* clear struct */
@@ -806,13 +806,13 @@ ParseGroupString (char *s, LayerGroupTypePtr LayerGroup, int LayerN)
             case 'c':
             case 'C':
               layer = LayerN + COMPONENT_LAYER;
-              c_set = True;
+              c_set = true;
               break;
 
             case 's':
             case 'S':
               layer = LayerN + SOLDER_LAYER;
-              s_set = True;
+              s_set = true;
               break;
 
             default:
@@ -1023,7 +1023,7 @@ PushOnTopOfLayerStack (int NewTop)
  * returns the number of changed layers
  */
 int
-ChangeGroupVisibility (int Layer, Boolean On, Boolean ChangeStackOrder)
+ChangeGroupVisibility (int Layer, bool On, bool ChangeStackOrder)
 {
   int group, i, changed = 1;    /* at least the current layer changes */
 
@@ -1105,29 +1105,29 @@ LayerStringToLayerStack (char *s)
     {
       if (i < max_layer)
         LayerStack[i] = i;
-      PCB->Data->Layer[i].On = False;
+      PCB->Data->Layer[i].On = false;
     }
-  PCB->ElementOn = False;
-  PCB->InvisibleObjectsOn = False;
-  PCB->PinOn = False;
-  PCB->ViaOn = False;
-  PCB->RatOn = False;
+  PCB->ElementOn = false;
+  PCB->InvisibleObjectsOn = false;
+  PCB->PinOn = false;
+  PCB->ViaOn = false;
+  PCB->RatOn = false;
   CLEAR_FLAG (SHOWMASKFLAG, PCB);
   Settings.ShowSolderSide = 0;
 
   for (i=argn-1; i>=0; i--)
     {
       if (strcasecmp (args[i], "rats") == 0)
-	PCB->RatOn = True;
+	PCB->RatOn = true;
       else if (strcasecmp (args[i], "invisible") == 0)
-	PCB->InvisibleObjectsOn = True;
+	PCB->InvisibleObjectsOn = true;
       else if (strcasecmp (args[i], "pins") == 0)
-	PCB->PinOn = True;
+	PCB->PinOn = true;
       else if (strcasecmp (args[i], "vias") == 0)
-	PCB->ViaOn = True;
+	PCB->ViaOn = true;
       else if (strcasecmp (args[i], "elements") == 0
 	       || strcasecmp (args[i], "silk") == 0)
-	PCB->ElementOn = True;
+	PCB->ElementOn = true;
       else if (strcasecmp (args[i], "mask") == 0)
 	SET_FLAG (SHOWMASKFLAG, PCB);
       else if (strcasecmp (args[i], "solderside") == 0)
@@ -1135,7 +1135,7 @@ LayerStringToLayerStack (char *s)
       else if (isdigit ((int) args[i][0]))
 	{
 	  lno = atoi (args[i]);
-	  ChangeGroupVisibility (lno, True, True);
+	  ChangeGroupVisibility (lno, true, true);
 	}
       else
 	{
@@ -1143,7 +1143,7 @@ LayerStringToLayerStack (char *s)
 	  for (lno = 0; lno < max_layer; lno++)
 	    if (strcasecmp (args[i], PCB->Data->Layer[lno].Name) == 0)
 	      {
-		ChangeGroupVisibility (lno, True, True);
+		ChangeGroupVisibility (lno, true, true);
 		found = 1;
 		break;
 	      }
@@ -1347,13 +1347,13 @@ ResetStackAndVisibility (void)
     {
       if (i < max_layer)
         LayerStack[i] = i;
-      PCB->Data->Layer[i].On = True;
+      PCB->Data->Layer[i].On = true;
     }
-  PCB->ElementOn = True;
-  PCB->InvisibleObjectsOn = True;
-  PCB->PinOn = True;
-  PCB->ViaOn = True;
-  PCB->RatOn = True;
+  PCB->ElementOn = true;
+  PCB->InvisibleObjectsOn = true;
+  PCB->PinOn = true;
+  PCB->ViaOn = true;
+  PCB->RatOn = true;
 
   /* Bring the component group to the front and make it active.  */
   comp_group = GetLayerGroupNumberByNumber (max_layer + COMPONENT_LAYER);
@@ -1367,12 +1367,12 @@ void
 SaveStackAndVisibility (void)
 {
   Cardinal i;
-  static Boolean run = False;
+  static bool run = false;
 
-  if (run == False)
+  if (run == false)
     {
       SavedStack.cnt = 0;
-      run = True;
+      run = true;
     }
 
   if (SavedStack.cnt != 0)
@@ -1544,7 +1544,7 @@ BumpName (char *Name)
 char *
 UniqueElementName (DataTypePtr Data, char *Name)
 {
-  Boolean unique = True;
+  bool unique = true;
   /* null strings are ok */
   if (!Name || !*Name)
     return (Name);
@@ -1557,14 +1557,14 @@ UniqueElementName (DataTypePtr Data, char *Name)
             NSTRCMP (NAMEONPCB_NAME (element), Name) == 0)
           {
             Name = BumpName (Name);
-            unique = False;
+            unique = false;
             break;
           }
       }
       END_LOOP;
       if (unique)
         return (Name);
-      unique = True;
+      unique = true;
     }
 }
 
@@ -1636,7 +1636,7 @@ AttachForCopy (LocationType PlaceX, LocationType PlaceY)
   Crosshair.AttachedObject.X = PlaceX - mx;
   Crosshair.AttachedObject.Y = PlaceY - my;
   if (!Marked.status || TEST_FLAG (LOCALREFFLAG, PCB))
-    SetLocalRef (PlaceX - mx, PlaceY - my, True);
+    SetLocalRef (PlaceX - mx, PlaceY - my, true);
   Crosshair.AttachedObject.State = STATE_SECOND;
 
   /* get boundingbox of object and set cursor range */
diff --git a/src/misc.h b/src/misc.h
index 3634f9b..d58e12e 100644
--- a/src/misc.h
+++ b/src/misc.h
@@ -43,9 +43,9 @@ void SetPinBoundingBox (PinTypePtr);
 void SetPadBoundingBox (PadTypePtr);
 void SetPolygonBoundingBox (PolygonTypePtr);
 void SetElementBoundingBox (DataTypePtr, ElementTypePtr, FontTypePtr);
-Boolean IsDataEmpty (DataTypePtr);
+bool IsDataEmpty (DataTypePtr);
 BoxTypePtr GetDataBoundingBox (DataTypePtr);
-void CenterDisplay (LocationType, LocationType, Boolean);
+void CenterDisplay (LocationType, LocationType, bool);
 void SetFontInfo (FontTypePtr);
 int ParseGroupString (char *, LayerGroupTypePtr, int /* LayerN */);
 int ParseRouteString (char *, RouteStyleTypePtr, int);
@@ -59,7 +59,7 @@ int GetLayerNumber (DataTypePtr, LayerTypePtr);
 int GetLayerGroupNumberByPointer (LayerTypePtr);
 int GetLayerGroupNumberByNumber (Cardinal);
 int GetGroupOfLayer (int);
-int ChangeGroupVisibility (int, Boolean, Boolean);
+int ChangeGroupVisibility (int, bool, bool);
 void LayerStringToLayerStack (char *);
 
 
@@ -74,7 +74,7 @@ BoxTypePtr GetArcEnds (ArcTypePtr);
 void ChangeArcAngles (LayerTypePtr, ArcTypePtr, long int, long int);
 char *UniqueElementName (DataTypePtr, char *);
 void AttachForCopy (LocationType, LocationType);
-float GetValue (char *, char *, Boolean *);
+float GetValue (char *, char *, bool *);
 int FileExists (const char *);
 char *Concat (const char *, ...);	/* end with NULL */
 
diff --git a/src/move.c b/src/move.c
index 6f0c82f..cd23253 100644
--- a/src/move.c
+++ b/src/move.c
@@ -87,7 +87,7 @@ static void *MovePolygonToLayer (LayerTypePtr, PolygonTypePtr);
 static LocationType DeltaX,	/* used by local routines as offset */
   DeltaY;
 static LayerTypePtr Dest;
-static Boolean MoreToCome;
+static bool MoreToCome;
 static ObjectFunctionType MoveFunctions = {
   MoveLine,
   MoveText,
@@ -216,7 +216,7 @@ MoveElementName (ElementTypePtr Element)
 static void *
 MoveElement (ElementTypePtr Element)
 {
-  Boolean didDraw = False;
+  bool didDraw = false;
 
   if (PCB->ElementOn && (FRONT (Element) || PCB->InvisibleObjectsOn))
     {
@@ -224,7 +224,7 @@ MoveElement (ElementTypePtr Element)
       MoveElementLowLevel (PCB->Data, Element, DeltaX, DeltaY);
       DrawElementName (Element, 0);
       DrawElementPackage (Element, 0);
-      didDraw = True;
+      didDraw = true;
     }
   else
     {
@@ -235,7 +235,7 @@ MoveElement (ElementTypePtr Element)
   if (PCB->PinOn)
     {
       DrawElementPinsAndPads (Element, 0);
-      didDraw = True;
+      didDraw = true;
     }
   if (didDraw)
     Draw ();
@@ -841,7 +841,7 @@ MoveObjectAndRubberband (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
  */
 void *
 MoveObjectToLayer (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
-		   LayerTypePtr Target, Boolean enmasse)
+		   LayerTypePtr Target, bool enmasse)
 {
   void *result;
 
@@ -857,16 +857,16 @@ MoveObjectToLayer (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
  * moves the selected objects to a new layer without changing their
  * positions
  */
-Boolean
+bool
 MoveSelectedObjectsToLayer (LayerTypePtr Target)
 {
-  Boolean changed;
+  bool changed;
 
   /* setup global identifiers */
   Dest = Target;
-  MoreToCome = True;
-  changed = SelectedOperation (&MoveToLayerFunctions, True, ALL_TYPES);
-  /* passing True to above operation causes Undoserial to auto-increment */
+  MoreToCome = true;
+  changed = SelectedOperation (&MoveToLayerFunctions, true, ALL_TYPES);
+  /* passing true to above operation causes Undoserial to auto-increment */
   return (changed);
 }
 
diff --git a/src/move.h b/src/move.h
index f060ff5..c4a844b 100644
--- a/src/move.h
+++ b/src/move.h
@@ -97,13 +97,13 @@ void MovePolygonLowLevel (PolygonTypePtr, LocationType, LocationType);
 void MoveElementLowLevel (DataTypePtr, ElementTypePtr, LocationType,
 			  LocationType);
 void *MoveObject (int, void *, void *, void *, LocationType, LocationType);
-void *MoveObjectToLayer (int, void *, void *, void *, LayerTypePtr, Boolean);
+void *MoveObjectToLayer (int, void *, void *, void *, LayerTypePtr, bool);
 void *MoveObjectAndRubberband (int, void *, void *, void *,
 			       LocationType, LocationType);
 void *MoveLineToLayerLowLevel (LayerTypePtr, LineTypePtr, LayerTypePtr);
 void *MoveTextToLayerLowLevel (LayerTypePtr, TextTypePtr, LayerTypePtr);
 void *MovePolygonToLayerLowLevel (LayerTypePtr, PolygonTypePtr, LayerTypePtr);
-Boolean MoveSelectedObjectsToLayer (LayerTypePtr);
+bool MoveSelectedObjectsToLayer (LayerTypePtr);
 
 /* index is 0..MAX_LAYER-1.  If old_index is -1, a new layer is
    inserted at that index.  If new_index is -1, the specified layer is
diff --git a/src/mtspace.c b/src/mtspace.c
index f5ce554..3640f5c 100644
--- a/src/mtspace.c
+++ b/src/mtspace.c
@@ -216,7 +216,7 @@ struct query_closure
   CheapPointType *desired;
   BDimension radius, keepaway;
   jmp_buf env;
-  Boolean touch_is_vec;
+  bool touch_is_vec;
 };
 
 static inline void
@@ -339,12 +339,12 @@ query_one (const BoxType * box, void *cl)
  * anything. If a region does intersect something, it is broken into
  * pieces that don't intersect that thing (if possible) which are
  * put back into the vector/heap of regions to check.
- * qloop returns False when it finds the first empty region
- * it returns True if it has exhausted the region vector/heap and never
+ * qloop returns false when it finds the first empty region
+ * it returns true if it has exhausted the region vector/heap and never
  * found an empty area.
  */
 static void
-qloop (struct query_closure *qc, rtree_t * tree, heap_or_vector res, Boolean is_vec)
+qloop (struct query_closure *qc, rtree_t * tree, heap_or_vector res, bool is_vec)
 {
   BoxType *cbox;
 #ifndef NDEBUG
@@ -435,7 +435,7 @@ mtspace_query_rect (mtspace_t * mtspace, const BoxType * region,
 		    vector_t * free_space_vec,
 		    vector_t * lo_conflict_space_vec,
 		    vector_t * hi_conflict_space_vec,
-		    Boolean is_odd, Boolean with_conflicts, CheapPointType *desired)
+		    bool is_odd, bool with_conflicts, CheapPointType *desired)
 {
   struct query_closure qc;
 
@@ -495,15 +495,15 @@ mtspace_query_rect (mtspace_t * mtspace, const BoxType * region,
        */
       qc.checking = work->untested;
       qc.touching.v = NULL;
-      qloop (&qc, mtspace->ftree, work->no_fix, False);
+      qloop (&qc, mtspace->ftree, work->no_fix, false);
       /* search the hi-conflict tree placing intersectors in the
        * hi_candidate vector (if conflicts are allowed) and
        * placing empty regions in the no_hi vector.
        */
       qc.checking.v = work->no_fix.v;
       qc.touching.v = with_conflicts ? work->hi_candidate.v : NULL;
-      qc.touch_is_vec = False;
-      qloop (&qc, is_odd ? mtspace->otree : mtspace->etree, work->no_hi, False);
+      qc.touch_is_vec = false;
+      qloop (&qc, is_odd ? mtspace->otree : mtspace->etree, work->no_hi, false);
       /* search the lo-conflict tree placing intersectors in the
        * lo-conflict answer vector (if conflicts allowed) and
        * placing emptry regions in the free-space answer vector.
@@ -511,8 +511,8 @@ mtspace_query_rect (mtspace_t * mtspace, const BoxType * region,
       qc.checking = work->no_hi;
 /* XXX lo_conflict_space_vec will be treated like a heap! */
       qc.touching.v = (with_conflicts ? lo_conflict_space_vec : NULL);
-      qc.touch_is_vec = True;
-      qloop (&qc, is_odd ? mtspace->etree : mtspace->otree, (heap_or_vector)free_space_vec, True);
+      qc.touch_is_vec = true;
+      qloop (&qc, is_odd ? mtspace->etree : mtspace->otree, (heap_or_vector)free_space_vec, true);
       if (!vector_is_empty (free_space_vec))
 	{
 	  if (qc.desired)
@@ -536,7 +536,7 @@ mtspace_query_rect (mtspace_t * mtspace, const BoxType * region,
 	  qc.checking = work->hi_candidate;
 	  qc.touching.v = NULL;
 	  qloop (&qc, is_odd ? mtspace->etree : mtspace->otree,
-		 (heap_or_vector)hi_conflict_space_vec, True);
+		 (heap_or_vector)hi_conflict_space_vec, true);
 	}
     }
   while (!(qc.desired ? heap_is_empty(work->untested.h) : vector_is_empty (work->untested.v)));
diff --git a/src/mtspace.h b/src/mtspace.h
index 4e6eb8e..4bbbbbf 100644
--- a/src/mtspace.h
+++ b/src/mtspace.h
@@ -76,7 +76,7 @@ vetting_t *mtspace_query_rect (mtspace_t * mtspace, const BoxType * region,
                                vector_t * free_space_vec,
                                vector_t * lo_conflict_space_vec,
                                vector_t * hi_conflict_space_vec,
-                               Boolean is_odd, Boolean with_conflicts,
+                               bool is_odd, bool with_conflicts,
                                CheapPointType *desired);
 
 void mtsFreeWork (vetting_t **);
diff --git a/src/mymem.c b/src/mymem.c
index 4118cf0..46714bb 100644
--- a/src/mymem.c
+++ b/src/mymem.c
@@ -196,7 +196,7 @@ PinTypePtr
 GetPinMemory (ElementTypePtr Element)
 {
   PinTypePtr pin = Element->Pin;
-  Boolean onBoard = False;
+  bool onBoard = false;
 
   /* realloc new memory if necessary and clear it */
   if (Element->PinN >= Element->PinMax)
@@ -206,7 +206,7 @@ GetPinMemory (ElementTypePtr Element)
 	  PIN_LOOP (Element);
 	  {
 	    if (r_delete_entry (PCB->Data->pin_tree, (BoxType *) pin))
-	      onBoard = True;
+	      onBoard = true;
 	  }
 	  END_LOOP;
 	}
@@ -234,7 +234,7 @@ PadTypePtr
 GetPadMemory (ElementTypePtr Element)
 {
   PadTypePtr pad = Element->Pad;
-  Boolean onBoard = False;
+  bool onBoard = false;
 
   /* realloc new memory if necessary and clear it */
   if (Element->PadN >= Element->PadMax)
@@ -244,7 +244,7 @@ GetPadMemory (ElementTypePtr Element)
 	  PAD_LOOP (Element);
 	  {
 	    if (r_delete_entry (PCB->Data->pad_tree, (BoxType *) pad))
-	      onBoard = True;
+	      onBoard = true;
 	  }
 	  END_LOOP;
 	}
diff --git a/src/netlist.c b/src/netlist.c
index be81e4e..ade8326 100644
--- a/src/netlist.c
+++ b/src/netlist.c
@@ -146,7 +146,7 @@ static int
 pin_name_to_xy (LibraryEntryType * pin, int *x, int *y)
 {
   ConnectionType conn;
-  if (!SeekPad (pin, &conn, False))
+  if (!SeekPad (pin, &conn, false))
     return 1;
   switch (conn.type)
     {
@@ -460,7 +460,7 @@ Netlist (int argc, char **argv, int x, int y)
 	  if ((elt_pattern = re_comp (argv[1])) != NULL)
 	    {
 	      Message (_("re_comp error: %s\n"), elt_pattern);
-	      return (False);
+	      return (false);
 	    }
 #endif
 	}
diff --git a/src/parse_l.l b/src/parse_l.l
index 2a9d589..0f3b72e 100644
--- a/src/parse_l.l
+++ b/src/parse_l.l
@@ -208,7 +208,7 @@ static int Parse(char *Executable, char *Path, char *Filename, char *Parameter)
 	char *tmps;
 	size_t l;
 #ifdef FLEX_SCANNER
-	static	Boolean	firsttime = True;
+	static	bool	firsttime = true;
 #endif
 
 	if (EMPTY_STRING_P (Executable))
@@ -258,7 +258,7 @@ static int Parse(char *Executable, char *Path, char *Filename, char *Parameter)
 		/* reset parser if not called the first time */
 	if (!firsttime)
 		yyrestart(yyin);
-	firsttime = False;
+	firsttime = false;
 #endif
 
 		/* init linenumber and filename for yyerror() */
diff --git a/src/parse_y.y b/src/parse_y.y
index b76e689..1d64fe8 100644
--- a/src/parse_y.y
+++ b/src/parse_y.y
@@ -68,7 +68,7 @@ static	PolygonTypePtr	Polygon;
 static	SymbolTypePtr	Symbol;
 static	int		pin_num;
 static	LibraryMenuTypePtr	Menu;
-static	Boolean			LayerFlag[MAX_LAYER + 2];
+static	bool			LayerFlag[MAX_LAYER + 2];
 
 extern	char			*yytext;		/* defined by LEX */
 extern	PCBTypePtr		yyPCB;
@@ -151,7 +151,7 @@ parsepcb
 					YYABORT;
 				}
 				for (i = 0; i < MAX_LAYER + 2; i++)
-					LayerFlag[i] = False;
+					LayerFlag[i] = false;
 				yyFont = &yyPCB->Font;
 				yyData = yyPCB->Data;
 				yyData->pcb = (void *)yyPCB;
@@ -196,8 +196,8 @@ parsepcb
 		| { PreLoadElementPCB ();
 		    layer_group_string = NULL; }
 		  element
-		  { LayerFlag[0] = True;
-		    LayerFlag[1] = True;
+		  { LayerFlag[0] = true;
+		    LayerFlag[1] = true;
 		    yyData->LayerN = 2;
 		    PostLoadElementPCB ();
 		  }
@@ -216,7 +216,7 @@ parsedata
 					YYABORT;
 				}
 				for (i = 0; i < MAX_LAYER + 2; i++)
-					LayerFlag[i] = False;
+					LayerFlag[i] = false;
 				yyData->LayerN = 0;
 			}
 		 pcbdata
@@ -238,13 +238,13 @@ parsefont
 					Message("illegal fileformat\n");
 					YYABORT;
 				}
-				yyFont->Valid = False;
+				yyFont->Valid = false;
 				for (i = 0; i <= MAX_FONTPOSITION; i++)
-					yyFont->Symbol[i].Valid = False;
+					yyFont->Symbol[i].Valid = false;
 			}
 		  symbols
 			{
-				yyFont->Valid = True;
+				yyFont->Valid = true;
 		  		SetFontInfo(yyFont);
 			}
 		;
@@ -363,9 +363,9 @@ pcbgridnew
 				yyPCB->GridOffsetX = $4*100;
 				yyPCB->GridOffsetY = $5*100;
 				if ($6)
-					Settings.DrawGrid = True;
+					Settings.DrawGrid = true;
 				else
-					Settings.DrawGrid = False;
+					Settings.DrawGrid = false;
 			}
 		;
 
@@ -376,9 +376,9 @@ pcb2grid
 				yyPCB->GridOffsetX = $4*100;
 				yyPCB->GridOffsetY = $5*100;
 				if ($6)
-					Settings.DrawGrid = True;
+					Settings.DrawGrid = true;
 				else
-					Settings.DrawGrid = False;
+					Settings.DrawGrid = false;
 			}
 		;
 pcbhigrid
@@ -388,9 +388,9 @@ pcbhigrid
 				yyPCB->GridOffsetX = $4;
 				yyPCB->GridOffsetY = $5;
 				if ($6)
-					Settings.DrawGrid = True;
+					Settings.DrawGrid = true;
 				else
-					Settings.DrawGrid = False;
+					Settings.DrawGrid = false;
 			}
 		;
 
@@ -861,7 +861,7 @@ layer
 
 					/* memory for name is already allocated */
 				Layer->Name = $4;
-				LayerFlag[$3-1] = True;
+				LayerFlag[$3-1] = true;
 				if (yyData->LayerN + 2 < $3)
 				  yyData->LayerN = $3 - 2;
 			}
@@ -1222,7 +1222,7 @@ element_oldformat
 		: T_ELEMENT '(' STRING STRING NUMBER NUMBER NUMBER ')' '('
 			{
 				yyElement = CreateNewElement(yyData, yyElement, yyFont, NoFlags(),
-					$3, $4, NULL, $5*100, $6*100, $7, 100, NoFlags(), False);
+					$3, $4, NULL, $5*100, $6*100, $7, 100, NoFlags(), false);
 				SaveFree($3);
 				SaveFree($4);
 				pin_num = 1;
@@ -1240,7 +1240,7 @@ element_1.3.4_format
 		: T_ELEMENT '(' NUMBER STRING STRING NUMBER NUMBER NUMBER NUMBER NUMBER ')' '('
 			{
 				yyElement = CreateNewElement(yyData, yyElement, yyFont, OldFlags($3),
-					$4, $5, NULL, $6*100, $7*100, $8, $9, OldFlags($10), False);
+					$4, $5, NULL, $6*100, $7*100, $8, $9, OldFlags($10), false);
 				SaveFree($4);
 				SaveFree($5);
 				pin_num = 1;
@@ -1258,7 +1258,7 @@ element_newformat
 		: T_ELEMENT '(' NUMBER STRING STRING STRING NUMBER NUMBER NUMBER NUMBER NUMBER ')' '('
 			{
 				yyElement = CreateNewElement(yyData, yyElement, yyFont, OldFlags($3),
-					$4, $5, $6, $7*100, $8*100, $9, $10, OldFlags($11), False);
+					$4, $5, $6, $7*100, $8*100, $9, $10, OldFlags($11), false);
 				SaveFree($4);
 				SaveFree($5);
 				SaveFree($6);
@@ -1278,7 +1278,7 @@ element_1.7_format
 			NUMBER NUMBER NUMBER NUMBER NUMBER ')' '('
 			{
 				yyElement = CreateNewElement(yyData, yyElement, yyFont, OldFlags($3),
-					$4, $5, $6, ($7+$9)*100, ($8+$10)*100, $11, $12, OldFlags($13), False);
+					$4, $5, $6, ($7+$9)*100, ($8+$10)*100, $11, $12, OldFlags($13), false);
 				yyElement->MarkX = $7*100;
 				yyElement->MarkY = $8*100;
 				SaveFree($4);
@@ -1299,7 +1299,7 @@ element_hi_format
 			NUMBER NUMBER NUMBER NUMBER flags ']' '('
 			{
 				yyElement = CreateNewElement(yyData, yyElement, yyFont, $3,
-					$4, $5, $6, ($7+$9), ($8+$10), $11, $12, $13, False);
+					$4, $5, $6, ($7+$9), ($8+$10), $11, $12, $13, false);
 				yyElement->MarkX = $7;
 				yyElement->MarkY = $8;
 				SaveFree($4);
@@ -1690,7 +1690,7 @@ symbol
 					yyerror("symbol ID used twice");
 					YYABORT;
 				}
-				Symbol->Valid = True;
+				Symbol->Valid = true;
 				Symbol->Delta = $4;
 			}
 		  symboldata ')'
@@ -1707,7 +1707,7 @@ symbol
 					yyerror("symbol ID used twice");
 					YYABORT;
 				}
-				Symbol->Valid = True;
+				Symbol->Valid = true;
 				Symbol->Delta = $4*100;
 			}
 		  symboldata ')'
diff --git a/src/polygon.c b/src/polygon.c
index 365539a..97164ab 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -609,7 +609,7 @@ SquarePadPoly (PadType * pad, BDimension clear)
 
 /* clear np1 from the polygon */
 static int
-Subtract (POLYAREA * np1, PolygonType * p, Boolean fnp)
+Subtract (POLYAREA * np1, PolygonType * p, bool fnp)
 {
   POLYAREA *merged = NULL, *np = np1;
   int x;
@@ -713,7 +713,7 @@ SubtractLine (LineType * line, PolygonType * p)
     return 0;
   if (!(np = LinePoly (line, line->Thickness + line->Clearance)))
     return -1;
-  return Subtract (np, p, True);
+  return Subtract (np, p, true);
 }
 
 static int
@@ -725,7 +725,7 @@ SubtractArc (ArcType * arc, PolygonType * p)
     return 0;
   if (!(np = ArcPoly (arc, arc->Thickness + arc->Clearance)))
     return -1;
-  return Subtract (np, p, True);
+  return Subtract (np, p, true);
 }
 
 static int
@@ -739,7 +739,7 @@ SubtractText (TextType * text, PolygonType * p)
   if (!(np = RoundRect (b->X1 + PCB->Bloat, b->X2 - PCB->Bloat,
                         b->Y1 + PCB->Bloat, b->Y2 - PCB->Bloat, PCB->Bloat)))
     return -1;
-  return Subtract (np, p, True);
+  return Subtract (np, p, true);
 }
 
 static int
@@ -761,7 +761,7 @@ SubtractPad (PadType * pad, PolygonType * p)
           (np = LinePoly ((LineType *) pad, pad->Thickness + pad->Clearance)))
         return -1;
     }
-  return Subtract (np, p, True);
+  return Subtract (np, p, true);
 }
 
 struct cpInfo
@@ -770,7 +770,7 @@ struct cpInfo
   DataType *data;
   LayerType *layer;
   PolygonType *polygon;
-  Boolean solder;
+  bool solder;
   jmp_buf env;
 };
 
@@ -1049,7 +1049,7 @@ UnsubtractPad (PadType * pad, LayerType * l, PolygonType * p)
   return 1;
 }
 
-static Boolean inhibit = False;
+static bool inhibit = false;
 
 int
 InitClip (DataTypePtr Data, LayerTypePtr layer, PolygonType * p)
@@ -1075,16 +1075,16 @@ InitClip (DataTypePtr Data, LayerTypePtr layer, PolygonType * p)
  * line between the points on either side of it is redundant.
  * returns true if any points are removed
  */
-Boolean
+bool
 RemoveExcessPolygonPoints (LayerTypePtr Layer, PolygonTypePtr Polygon)
 {
   PointTypePtr pt1, pt2, pt3;
   Cardinal n;
   LineType line;
-  Boolean changed = False;
+  bool changed = false;
 
   if (Undoing ())
-    return (False);
+    return (false);
   /* there are always at least three points in a polygon */
   pt1 = &Polygon->Points[Polygon->PointN - 1];
   pt2 = &Polygon->Points[0];
@@ -1103,7 +1103,7 @@ RemoveExcessPolygonPoints (LayerTypePtr Layer, PolygonTypePtr Polygon)
         {
           RemoveObject (POLYGONPOINT_TYPE, (void *) Layer, (void *) Polygon,
                         (void *) pt2);
-          changed = True;
+          changed = true;
         }
     }
   return (changed);
@@ -1258,7 +1258,7 @@ CopyAttachedPolygonToLayer (void)
   r_insert_entry (CURRENT->polygon_tree, (BoxType *) polygon, 0);
   InitClip (PCB->Data, CURRENT, polygon);
   DrawPolygon (CURRENT, polygon, 0);
-  SetChangedFlag (True);
+  SetChangedFlag (true);
 
   /* reset state of attached line */
   Crosshair.AttachedLine.State = STATE_FIRST;
@@ -1490,11 +1490,11 @@ ClearFromPolygon (DataType * Data, int type, void *ptr1, void *ptr2)
     PlowsPolygon (Data, type, ptr1, ptr2, subtract_plow);
 }
 
-Boolean
-isects (POLYAREA * a, PolygonTypePtr p, Boolean fr)
+bool
+isects (POLYAREA * a, PolygonTypePtr p, bool fr)
 {
   POLYAREA *x;
-  Boolean ans;
+  bool ans;
   ans = Touching (a, p->Clipped);
   /* argument may be register, so we must copy it */
   x = a;
@@ -1504,7 +1504,7 @@ isects (POLYAREA * a, PolygonTypePtr p, Boolean fr)
 }
 
 
-Boolean
+bool
 IsPointInPolygon (LocationType X, LocationType Y, BDimension r,
                   PolygonTypePtr p)
 {
@@ -1513,16 +1513,16 @@ IsPointInPolygon (LocationType X, LocationType Y, BDimension r,
   v[0] = X;
   v[1] = Y;
   if (poly_CheckInside (p->Clipped, v))
-    return True;
+    return true;
   if (r < 1)
-    return False;
+    return false;
   if (!(c = CirclePoly (X, Y, r)))
-    return False;
-  return isects (c, p, True);
+    return false;
+  return isects (c, p, true);
 }
 
 
-Boolean
+bool
 IsPointInPolygonIgnoreHoles (LocationType X, LocationType Y, PolygonTypePtr p)
 {
   Vector v;
@@ -1531,15 +1531,15 @@ IsPointInPolygonIgnoreHoles (LocationType X, LocationType Y, PolygonTypePtr p)
   return poly_InsideContour (p->Clipped->contours, v);
 }
 
-Boolean
+bool
 IsRectangleInPolygon (LocationType X1, LocationType Y1, LocationType X2,
                       LocationType Y2, PolygonTypePtr p)
 {
   POLYAREA *s;
   if (!
       (s = RectPoly (min (X1, X2), max (X1, X2), min (Y1, Y2), max (Y1, Y2))))
-    return False;
-  return isects (s, p, True);
+    return false;
+  return isects (s, p, true);
 }
 
 /* NB: This function will free the passed POLYAREA.
@@ -1633,17 +1633,17 @@ NoHolesPolygonDicer (PolygonTypePtr p, const BoxType * clip,
 }
 
 /* make a polygon split into multiple parts into multiple polygons */
-Boolean
+bool
 MorphPolygon (LayerTypePtr layer, PolygonTypePtr poly)
 {
   POLYAREA *p, *start;
-  Boolean many = False;
+  bool many = false;
   FlagType flags;
 
   if (!poly->Clipped || TEST_FLAG (LOCKFLAG, poly))
-    return False;
+    return false;
   if (poly->Clipped->f == poly->Clipped)
-    return False;
+    return false;
   ErasePolygon (poly);
   start = p = poly->Clipped;
   /* This is ugly. The creation of the new polygons can cause
@@ -1659,7 +1659,7 @@ MorphPolygon (LayerTypePtr layer, PolygonTypePtr poly)
   poly->NoHoles = NULL;
   flags = poly->Flags;
   RemovePolygon (layer, poly);
-  inhibit = True;
+  inhibit = true;
   do
     {
       VNODE *v;
@@ -1669,8 +1669,8 @@ MorphPolygon (LayerTypePtr layer, PolygonTypePtr poly)
         {
           new = CreateNewPolygon (layer, flags);
           if (!new)
-            return False;
-          many = True;
+            return false;
+          many = true;
           v = &p->contours->head;
           CreateNewPointInPolygon (new, v->point[0], v->point[1]);
           for (v = v->next; v != &p->contours->head; v = v->next)
@@ -1696,7 +1696,7 @@ MorphPolygon (LayerTypePtr layer, PolygonTypePtr poly)
         }
     }
   while (p != start);
-  inhibit = False;
+  inhibit = false;
   IncrementUndoSerialNumber ();
   return many;
 }
diff --git a/src/polygon.h b/src/polygon.h
index 2faaa20..1eb5757 100644
--- a/src/polygon.h
+++ b/src/polygon.h
@@ -35,7 +35,7 @@
 
 Cardinal GetLowestDistancePolygonPoint (PolygonTypePtr,
 					LocationType, LocationType);
-Boolean RemoveExcessPolygonPoints (LayerTypePtr, PolygonTypePtr);
+bool RemoveExcessPolygonPoints (LayerTypePtr, PolygonTypePtr);
 void GoToPreviousPoint (void);
 void ClosePolygon (void);
 void CopyAttachedPolygonToLayer (void);
@@ -58,12 +58,12 @@ int InitClip(DataType *d, LayerType *l, PolygonType *p);
 void RestoreToPolygon(DataType *, int, void *, void *);
 void ClearFromPolygon(DataType *, int, void *, void *);
 
-Boolean IsPointInPolygon (LocationType, LocationType, BDimension, PolygonTypePtr);
-Boolean IsPointInPolygonIgnoreHoles (LocationType, LocationType, PolygonTypePtr);
-Boolean IsRectangleInPolygon (LocationType, LocationType, LocationType,
+bool IsPointInPolygon (LocationType, LocationType, BDimension, PolygonTypePtr);
+bool IsPointInPolygonIgnoreHoles (LocationType, LocationType, PolygonTypePtr);
+bool IsRectangleInPolygon (LocationType, LocationType, LocationType,
 			      LocationType, PolygonTypePtr);
-Boolean isects (POLYAREA *, PolygonTypePtr, Boolean);
-Boolean MorphPolygon (LayerTypePtr, PolygonTypePtr);
+bool isects (POLYAREA *, PolygonTypePtr, bool);
+bool MorphPolygon (LayerTypePtr, PolygonTypePtr);
 void NoHolesPolygonDicer (PolygonType *p, const BoxType *clip,
                           void (*emit) (PLINE *, void *), void *user_data);
 #endif
diff --git a/src/polygon1.c b/src/polygon1.c
index a8a8b89..329058e 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -1000,7 +1000,7 @@ cntr_label_POLYAREA (PLINE * poly, POLYAREA * ppl, BOOLp test)
   else
     {
       if (test)
-	return False;
+	return false;
       poly->Flags.status = OUTSIDE;
     }
   return FALSE;
@@ -1606,7 +1606,7 @@ Touching (POLYAREA * a, POLYAREA * b)
       if (!poly_Valid (b))
 	return -1;
 #endif
-      M_POLYAREA_intersect (&e, a, b, False);
+      M_POLYAREA_intersect (&e, a, b, false);
 
       if (M_POLYAREA_label (a, b, TRUE))
 	return TRUE;
diff --git a/src/rats.c b/src/rats.c
index 0e2a068..29e9831 100644
--- a/src/rats.c
+++ b/src/rats.c
@@ -70,17 +70,17 @@ RCSID ("$Id$");
 /* ---------------------------------------------------------------------------
  * some forward declarations
  */
-static Boolean FindPad (char *, char *, ConnectionType *, Boolean);
-static Boolean ParseConnection (char *, char *, char *);
-static Boolean DrawShortestRats (NetListTypePtr, void (*)());
-static Boolean GatherSubnets (NetListTypePtr, Boolean, Boolean);
-static Boolean CheckShorts (LibraryMenuTypePtr);
+static bool FindPad (char *, char *, ConnectionType *, bool);
+static bool ParseConnection (char *, char *, char *);
+static bool DrawShortestRats (NetListTypePtr, void (*)());
+static bool GatherSubnets (NetListTypePtr, bool, bool);
+static bool CheckShorts (LibraryMenuTypePtr);
 static void TransferNet (NetListTypePtr, NetTypePtr, NetTypePtr);
 
 /* ---------------------------------------------------------------------------
  * some local identifiers
  */
-static Boolean badnet = False;
+static bool badnet = false;
 static Cardinal SLayer, CLayer;	/* layer group holding solder/component side */
 
 /* ---------------------------------------------------------------------------
@@ -90,7 +90,7 @@ static Cardinal SLayer, CLayer;	/* layer group holding solder/component side */
  * number of characters processed from the string, otherwise
  * it returns 0
  */
-static Boolean
+static bool
 ParseConnection (char *InString, char *ElementName, char *PinNum)
 {
   int i, j;
@@ -105,22 +105,22 @@ ParseConnection (char *InString, char *ElementName, char *PinNum)
       for (i = 0, j++; InString[j] != '\0'; i++, j++)
 	PinNum[i] = InString[j];
       PinNum[i] = '\0';
-      return (False);
+      return (false);
     }
   else
     {
       ElementName[j] = '\0';
       Message (_("Bad net-list format encountered near: \"%s\"\n"),
 	       ElementName);
-      return (True);
+      return (true);
     }
 }
 
 /* ---------------------------------------------------------------------------
  * Find a particular pad from an element name and pin number
  */
-static Boolean
-FindPad (char *ElementName, char *PinNum, ConnectionType * conn, Boolean Same)
+static bool
+FindPad (char *ElementName, char *PinNum, ConnectionType * conn, bool Same)
 {
   ElementTypePtr element;
   Cardinal i;
@@ -167,40 +167,40 @@ FindPad (char *ElementName, char *PinNum, ConnectionType * conn, Boolean Same)
 		break;
 	      }
 	  if (i == element->PinN)
-	    return (False);
+	    return (false);
 	}
       conn->ptr1 = element;
-      return (True);
+      return (true);
     }
-  return (False);
+  return (false);
 }
 
 /*--------------------------------------------------------------------------
  * parse a netlist menu entry and locate the corresponding pad
- * returns True if found, and fills in Connection information
+ * returns true if found, and fills in Connection information
  */
-Boolean
-SeekPad (LibraryEntryType * entry, ConnectionType * conn, Boolean Same)
+bool
+SeekPad (LibraryEntryType * entry, ConnectionType * conn, bool Same)
 {
   int j;
   char ElementName[256];
   char PinNum[256];
 
   if (ParseConnection (entry->ListEntry, ElementName, PinNum))
-    return (False);
+    return (false);
   for (j = 0; PinNum[j] != '\0'; j++);
   if (j == 0)
     {
       Message (_("Error! Netlist file is missing pin!\n"
 		 "white space after \"%s-\"\n"), ElementName);
-      badnet = True;
+      badnet = true;
     }
   else
     {
       if (FindPad (ElementName, PinNum, conn, Same))
-	return (True);
+	return (true);
       if (Same)
-	return (False);
+	return (false);
       if (PinNum[j - 1] < '0' || PinNum[j - 1] > '9')
 	{
 	  Message ("WARNING! Pin number ending with '%c'"
@@ -210,7 +210,7 @@ SeekPad (LibraryEntryType * entry, ConnectionType * conn, Boolean Same)
     }
   Message (_("Can't find %s pin %s called for in netlist.\n"),
 	   ElementName, PinNum);
-  return (False);
+  return (false);
 }
 
 /* ---------------------------------------------------------------------------
@@ -230,7 +230,7 @@ ProcNetlist (LibraryTypePtr net_menu)
   FreeNetListMemory (Wantlist);
   SaveFree (Wantlist);
   /*  MYFREE (Wantlist); *//* awkward */
-  badnet = False;
+  badnet = false;
 
   /* find layer groups of the component side and solder side */
   SLayer = GetLayerGroupNumberByNumber (max_layer + SOLDER_LAYER);
@@ -255,7 +255,7 @@ ProcNetlist (LibraryTypePtr net_menu)
       {
 	if (menu->Name[0] == '*' || menu->flag == 0)
 	  {
-	    badnet = True;
+	    badnet = true;
 	    continue;
 	  }
 	net = GetNetMemory (Wantlist);
@@ -275,7 +275,7 @@ ProcNetlist (LibraryTypePtr net_menu)
 	  net->Style = NULL;
 	ENTRY_LOOP (menu);
 	{
-	  if (SeekPad (entry, &LastPoint, False))
+	  if (SeekPad (entry, &LastPoint, false))
 	    {
 	      if (TEST_FLAG (DRCFLAG, (PinTypePtr) LastPoint.ptr2))
 		Message (_
@@ -299,9 +299,9 @@ ProcNetlist (LibraryTypePtr net_menu)
 		}
 	    }
 	  else
-	    badnet = True;
+	    badnet = true;
 	  /* check for more pins with the same number */
-	  for (; SeekPad (entry, &LastPoint, True);)
+	  for (; SeekPad (entry, &LastPoint, true);)
 	    {
 	      connection = GetConnectionMemory (net);
 	      *connection = LastPoint;
@@ -357,10 +357,10 @@ TransferNet (NetListTypePtr Netl, NetTypePtr SourceNet, NetTypePtr DestNet)
   memset (&Netl->Net[Netl->NetN], 0, sizeof (NetType));
 }
 
-static Boolean
+static bool
 CheckShorts (LibraryMenuTypePtr theNet)
 {
-  Boolean new, warn = False;
+  bool new, warn = false;
   PointerListTypePtr generic = MyCalloc (1, sizeof (PointerListType),
 					 "CheckShorts");
   /* the first connection was starting point so
@@ -373,7 +373,7 @@ CheckShorts (LibraryMenuTypePtr theNet)
   {
     if (TEST_FLAG (DRCFLAG, pin))
       {
-	warn = True;
+	warn = true;
 	if (!pin->Spare)
 	  {
 	    Message (_("Warning! Net \"%s\" is shorted to %s pin %s\n"),
@@ -383,12 +383,12 @@ CheckShorts (LibraryMenuTypePtr theNet)
 	    SET_FLAG (WARNFLAG, pin);
 	    continue;
 	  }
-	new = True;
+	new = true;
 	POINTER_LOOP (generic);
 	{
 	  if (*ptr == pin->Spare)
 	    {
-	      new = False;
+	      new = false;
 	      break;
 	    }
 	}
@@ -409,7 +409,7 @@ CheckShorts (LibraryMenuTypePtr theNet)
   {
     if (TEST_FLAG (DRCFLAG, pad))
       {
-	warn = True;
+	warn = true;
 	if (!pad->Spare)
 	  {
 	    Message (_("Warning! Net \"%s\" is shorted  to %s pad %s\n"),
@@ -419,12 +419,12 @@ CheckShorts (LibraryMenuTypePtr theNet)
 	    SET_FLAG (WARNFLAG, pad);
 	    continue;
 	  }
-	new = True;
+	new = true;
 	POINTER_LOOP (generic);
 	{
 	  if (*ptr == pad->Spare)
 	    {
-	      new = False;
+	      new = false;
 	      break;
 	    }
 	}
@@ -453,21 +453,21 @@ CheckShorts (LibraryMenuTypePtr theNet)
  * initially the netlist has each connection in its own individual net
  * afterwards there can be many fewer nets with multiple connections each
  */
-static Boolean
-GatherSubnets (NetListTypePtr Netl, Boolean NoWarn, Boolean AndRats)
+static bool
+GatherSubnets (NetListTypePtr Netl, bool NoWarn, bool AndRats)
 {
   NetTypePtr a, b;
   ConnectionTypePtr conn;
   Cardinal m, n;
-  Boolean Warned = False;
+  bool Warned = false;
 
   for (m = 0; Netl->NetN > 0 && m < Netl->NetN; m++)
     {
       a = &Netl->Net[m];
-      ResetFoundPinsViasAndPads (False);
-      ResetFoundLinesAndPolygons (False);
+      ResetFoundPinsViasAndPads (false);
+      ResetFoundLinesAndPolygons (false);
       RatFindHook (a->Connection[0].type, a->Connection[0].ptr1,
-		   a->Connection[0].ptr2, a->Connection[0].ptr2, False,
+		   a->Connection[0].ptr2, a->Connection[0].ptr2, false,
 		   AndRats);
       /* now anybody connected to the first point has DRCFLAG set */
       /* so move those to this subnet */
@@ -546,8 +546,8 @@ GatherSubnets (NetListTypePtr Netl, Boolean NoWarn, Boolean AndRats)
       if (!NoWarn)
 	Warned |= CheckShorts (a->Connection[0].menu);
     }
-  ResetFoundPinsViasAndPads (False);
-  ResetFoundLinesAndPolygons (False);
+  ResetFoundPinsViasAndPads (false);
+  ResetFoundLinesAndPolygons (false);
   return (Warned);
 }
 
@@ -556,14 +556,14 @@ GatherSubnets (NetListTypePtr Netl, Boolean NoWarn, Boolean AndRats)
  * this also frees the subnet memory as they are consumed
  */
 
-static Boolean
+static bool
 DrawShortestRats (NetListTypePtr Netl, void (*funcp) ())
 {
   RatTypePtr line;
   register float distance, temp;
   register ConnectionTypePtr conn1, conn2, firstpoint, secondpoint;
   PolygonTypePtr polygon;
-  Boolean changed = False;
+  bool changed = false;
   Cardinal n, m, j;
   NetTypePtr next, subnet, theSubnet = NULL;
 
@@ -647,7 +647,7 @@ DrawShortestRats (NetListTypePtr Netl, void (*funcp) ())
 		SET_FLAG (VIAFLAG, line);
 	      AddObjectToCreateUndoList (RATLINE_TYPE, line, line, line);
 	      DrawRat (line, 0);
-	      changed = True;
+	      changed = true;
 	    }
 	}
 
@@ -672,13 +672,13 @@ DrawShortestRats (NetListTypePtr Netl, void (*funcp) ())
  *  AddAllRats puts the rats nest into the layout from the loaded netlist
  *  if SelectedOnly is true, it will only draw rats to selected pins and pads
  */
-Boolean
-AddAllRats (Boolean SelectedOnly, void (*funcp) ())
+bool
+AddAllRats (bool SelectedOnly, void (*funcp) ())
 {
   NetListTypePtr Nets, Wantlist;
   NetTypePtr lonesome;
   ConnectionTypePtr onepin;
-  Boolean changed, Warned = False;
+  bool changed, Warned = false;
 
   /* the netlist library has the text form
    * ProcNetlist fills in the Netlist
@@ -689,9 +689,9 @@ AddAllRats (Boolean SelectedOnly, void (*funcp) ())
   if (!Wantlist)
     {
       Message (_("Can't add rat lines because no netlist is loaded.\n"));
-      return (False);
+      return (false);
     }
-  changed = False;
+  changed = false;
   /* initialize finding engine */
   InitConnectionLookup ();
   SaveFindFlag (DRCFLAG);
@@ -722,7 +722,7 @@ AddAllRats (Boolean SelectedOnly, void (*funcp) ())
 	}
     }
     END_LOOP;
-    Warned |= GatherSubnets (Nets, SelectedOnly, True);
+    Warned |= GatherSubnets (Nets, SelectedOnly, true);
     if (Nets->NetN > 0)
       changed |= DrawShortestRats (Nets, funcp);
   }
@@ -732,13 +732,13 @@ AddAllRats (Boolean SelectedOnly, void (*funcp) ())
   FreeConnectionLookupMemory ();
   RestoreFindFlag ();
   if (funcp)
-    return (True);
+    return (true);
 
   if (Warned || changed)
     Draw ();
 
   if (Warned)
-    Settings.RatWarn = True;
+    Settings.RatWarn = true;
 
   if (changed)
     {
@@ -748,7 +748,7 @@ AddAllRats (Boolean SelectedOnly, void (*funcp) ())
 	  Message ("%d rat line%s remaining\n", PCB->Data->RatN,
 		   PCB->Data->RatN > 1 ? "s" : "");
 	}
-      return (True);
+      return (true);
     }
   if (!SelectedOnly && !Warned)
     {
@@ -760,14 +760,14 @@ AddAllRats (Boolean SelectedOnly, void (*funcp) ())
 		   "either rat-lines in the layout, disabled nets\n"
 		   "in the net-list, or missing components\n"));
     }
-  return (False);
+  return (false);
 }
 
 /* XXX: This is copied in large part from AddAllRats above; for
  * maintainability, AddAllRats probably wants to be tweaked to use this
  * version of the code so that we don't have duplication. */
 NetListListType
-CollectSubnets (Boolean SelectedOnly)
+CollectSubnets (bool SelectedOnly)
 {
   NetListListType result = { 0, 0, NULL };
   NetListTypePtr Nets, Wantlist;
@@ -816,7 +816,7 @@ CollectSubnets (Boolean SelectedOnly)
     }
     END_LOOP;
     /* Note that AndRats is *FALSE* here! */
-    GatherSubnets (Nets, SelectedOnly, False);
+    GatherSubnets (Nets, SelectedOnly, false);
   }
   END_LOOP;
   FreeConnectionLookupMemory ();
diff --git a/src/rats.h b/src/rats.h
index 7a4dace..eb928d4 100644
--- a/src/rats.h
+++ b/src/rats.h
@@ -42,9 +42,9 @@ LibraryMenuTypePtr netname_to_netname (char *netname);
 RatTypePtr AddNet (void);
 char *ConnectionName (int, void *, void *);
 
-Boolean AddAllRats (Boolean, void (*)());
-Boolean SeekPad (LibraryEntryTypePtr, ConnectionTypePtr, Boolean);
+bool AddAllRats (bool, void (*)());
+bool SeekPad (LibraryEntryTypePtr, ConnectionTypePtr, bool);
 
 NetListTypePtr ProcNetlist (LibraryTypePtr);
-NetListListType CollectSubnets (Boolean);
+NetListListType CollectSubnets (bool);
 #endif
diff --git a/src/remove.c b/src/remove.c
index a82b478..a537bc0 100644
--- a/src/remove.c
+++ b/src/remove.c
@@ -109,7 +109,7 @@ static ObjectFunctionType DestroyFunctions = {
   DestroyRat
 };
 static DataTypePtr DestroyTarget;
-static Boolean Bulk = False;
+static bool Bulk = false;
 
 /* ---------------------------------------------------------------------------
  * remove PCB
@@ -117,7 +117,7 @@ static Boolean Bulk = False;
 void
 RemovePCB (PCBTypePtr Ptr)
 {
-  ClearUndoList (True);
+  ClearUndoList (true);
   FreePCBMemory (Ptr);
   SaveFree (Ptr);
 }
@@ -546,21 +546,21 @@ RemoveElement (ElementTypePtr Element)
 
 /* ----------------------------------------------------------------------
  * removes all selected and visible objects
- * returns True if any objects have been removed
+ * returns true if any objects have been removed
  */
-Boolean
+bool
 RemoveSelected (void)
 {
-  Bulk = True;
-  if (SelectedOperation (&RemoveFunctions, False, ALL_TYPES))
+  Bulk = true;
+  if (SelectedOperation (&RemoveFunctions, false, ALL_TYPES))
     {
       IncrementUndoSerialNumber ();
       Draw ();
-      Bulk = False;
-      return (True);
+      Bulk = false;
+      return (true);
     }
-  Bulk = False;
-  return (False);
+  Bulk = false;
+  return (false);
 }
 
 /* ---------------------------------------------------------------------------
@@ -579,21 +579,21 @@ RemoveObject (int Type, void *Ptr1, void *Ptr2, void *Ptr3)
  * can delete all rat lines, or only selected one
  */
 
-Boolean
-DeleteRats (Boolean selected)
+bool
+DeleteRats (bool selected)
 {
-  Boolean changed = False;
-  Bulk = True;
+  bool changed = false;
+  Bulk = true;
   RAT_LOOP (PCB->Data);
   {
     if ((!selected) || TEST_FLAG (SELECTEDFLAG, line))
       {
-	changed = True;
+	changed = true;
 	RemoveRat (line);
       }
   }
   END_LOOP;
-  Bulk = False;
+  Bulk = false;
   if (changed)
     {
       Draw ();
diff --git a/src/remove.h b/src/remove.h
index 8b7c166..9fd4625 100644
--- a/src/remove.h
+++ b/src/remove.h
@@ -47,8 +47,8 @@ void *RemoveText (LayerTypePtr, TextTypePtr);
 void *RemoveElement (ElementTypePtr);
 void ClearRemoveList (void);
 void RemovePCB (PCBTypePtr);
-Boolean RemoveSelected (void);
-Boolean DeleteRats (Boolean);
+bool RemoveSelected (void);
+bool DeleteRats (bool);
 void *RemoveObject (int, void *, void *, void *);
 void *DestroyObject (DataTypePtr, int, void *, void *, void *);
 
diff --git a/src/report.c b/src/report.c
index 2e80e66..6a1c47b 100644
--- a/src/report.c
+++ b/src/report.c
@@ -490,11 +490,11 @@ ReportDialog (int argc, char **argv, int x, int y)
       Message (_("Nothing found to report on\n"));
       return 1;
     }
-  HideCrosshair (False);
+  HideCrosshair (false);
   /* create dialog box */
   gui->report_dialog ("Report", &report[0]);
 
-  RestoreCrosshair (False);
+  RestoreCrosshair (false);
   return 0;
 }
 
@@ -535,9 +535,9 @@ ReportFoundPins (int argc, char **argv, int x, int y)
   }
   END_LOOP;
 
-  HideCrosshair (False);
+  HideCrosshair (false);
   gui->report_dialog ("Report", list.Data);
-  RestoreCrosshair (False);
+  RestoreCrosshair (false);
   return 0;
 }
 
@@ -548,7 +548,7 @@ XYtoNetLength (int x, int y, int *found)
 
   length = 0;
   *found = 0;
-  LookupConnection (x, y, True, PCB->Grid, FOUNDFLAG);
+  LookupConnection (x, y, true, PCB->Grid, FOUNDFLAG);
 
   ALLLINE_LOOP (PCB->Data);
   {
@@ -652,9 +652,9 @@ ReportAllNetLengths (int argc, char **argv, int x, int y)
 
     got_one:
       SaveUndoSerialNumber ();
-      ResetFoundPinsViasAndPads (True);
+      ResetFoundPinsViasAndPads (true);
       RestoreUndoSerialNumber ();
-      ResetFoundLinesAndPolygons (True);
+      ResetFoundLinesAndPolygons (true);
       RestoreUndoSerialNumber ();
       length = XYtoNetLength (x, y, &found);
 
@@ -688,9 +688,9 @@ ReportNetLength (int argc, char **argv, int x, int y)
   int found = 0;
 
   SaveUndoSerialNumber ();
-  ResetFoundPinsViasAndPads (True);
+  ResetFoundPinsViasAndPads (true);
   RestoreUndoSerialNumber ();
-  ResetFoundLinesAndPolygons (True);
+  ResetFoundLinesAndPolygons (true);
   RestoreUndoSerialNumber ();
   gui->get_coords ("Click on a connection", &x, &y);
 
@@ -758,12 +758,12 @@ ReportNetLength (int argc, char **argv, int x, int y)
   END_LOOP;
  got_net_name:
 
-  HideCrosshair (False);
+  HideCrosshair (false);
   if (netname)
     gui->log ("Net %s length: %0.2f %s\n", netname, UNIT (length));
   else
     gui->log ("Net length: %0.2f %s\n", UNIT (length));
-  RestoreCrosshair (False);
+  RestoreCrosshair (false);
   return 0;
 }
 /* ---------------------------------------------------------------------------
diff --git a/src/rotate.c b/src/rotate.c
index 247a1a9..9e19581 100644
--- a/src/rotate.c
+++ b/src/rotate.c
@@ -370,7 +370,7 @@ RotateObject (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
 {
   RubberbandTypePtr ptr;
   void *ptr2;
-  Boolean changed = False;
+  bool changed = false;
 
   /* setup default  global identifiers */
   Number = Steps;
@@ -381,7 +381,7 @@ RotateObject (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
   ptr = Crosshair.AttachedObject.Rubberband;
   while (Crosshair.AttachedObject.RubberbandN)
     {
-      changed = True;
+      changed = true;
       CLEAR_FLAG (RUBBERENDFLAG, ptr->Line);
       AddObjectToRotateUndoList (LINEPOINT_TYPE, ptr->Layer, ptr->Line,
 				 ptr->MovedPoint, CenterX, CenterY, Steps);
@@ -440,6 +440,6 @@ RotateScreenObject (LocationType X, LocationType Y, BYTE Steps)
       if (type == ELEMENT_TYPE)
 	LookupRatLines (type, ptr1, ptr2, ptr3);
       RotateObject (type, ptr1, ptr2, ptr3, X, Y, Steps);
-      SetChangedFlag (True);
+      SetChangedFlag (true);
     }
 }
diff --git a/src/rtree.c b/src/rtree.c
index f7ffe4d..0d5bf51 100644
--- a/src/rtree.c
+++ b/src/rtree.c
@@ -110,7 +110,7 @@ __r_node_is_good (struct rtree_node *node)
 {
   int i, flag = 1;
   int kind = -1;
-  Boolean last = False;
+  bool last = false;
 
   if (node == NULL)
     return 1;
@@ -120,7 +120,7 @@ __r_node_is_good (struct rtree_node *node)
         {
           if (!node->u.rects[i].bptr)
             {
-              last = True;
+              last = true;
               continue;
             }
           /* check that once one entry is empty, all the rest are too */
@@ -154,7 +154,7 @@ __r_node_is_good (struct rtree_node *node)
         {
           if (!node->u.kids[i])
             {
-              last = True;
+              last = true;
               continue;
             }
           /* make sure all children are the same type */
@@ -199,7 +199,7 @@ __r_node_is_good (struct rtree_node *node)
 
 
 /* check the whole tree from this node down for consistency */
-static Boolean
+static bool
 __r_tree_is_good (struct rtree_node *node)
 {
   int i;
@@ -672,7 +672,7 @@ find_clusters (struct rtree_node *node)
 {
   float total_a, total_b;
   float a_X, a_Y, b_X, b_Y;
-  Boolean belong[M_SIZE + 1];
+  bool belong[M_SIZE + 1];
   struct centroid center[M_SIZE + 1];
   int clust_a, clust_b, tries;
   int a_manage = 0, b_manage = 0;
@@ -718,20 +718,20 @@ find_clusters (struct rtree_node *node)
           dist2 = SQUARE (b_X - center[i].x) + SQUARE (b_Y - center[i].y);
           if (dist1 * (clust_a + M_SIZE / 2) < dist2 * (clust_b + M_SIZE / 2))
             {
-              belong[i] = True;
+              belong[i] = true;
               clust_a++;
             }
           else
             {
-              belong[i] = False;
+              belong[i] = false;
               clust_b++;
             }
         }
       /* kludge to fix degenerate cases */
       if (clust_a == M_SIZE + 1)
-        belong[M_SIZE / 2] = False;
+        belong[M_SIZE / 2] = false;
       else if (clust_b == M_SIZE + 1)
-        belong[M_SIZE / 2] = True;
+        belong[M_SIZE / 2] = true;
       /* compute new center of gravity of clusters */
       total_a = total_b = 0;
       a_X = a_Y = b_X = b_Y = 0;
@@ -900,7 +900,7 @@ penalty (struct rtree_node *node, const BoxType * query)
 
 static void
 __r_insert_node (struct rtree_node *node, const BoxType * query,
-                 int manage, Boolean force)
+                 int manage, bool force)
 {
 
 #ifdef SLOW_ASSERTS
@@ -979,7 +979,7 @@ __r_insert_node (struct rtree_node *node, const BoxType * query,
             break;
           if (contained (node->u.kids[i], query))
             {
-              __r_insert_node (node->u.kids[i], query, manage, False);
+              __r_insert_node (node->u.kids[i], query, manage, false);
               sort_node (node);
               return;
             }
@@ -991,7 +991,7 @@ __r_insert_node (struct rtree_node *node, const BoxType * query,
           struct rtree_node *new_node;
           new_node = calloc (1, sizeof (*new_node));
           new_node->parent = node;
-          new_node->flags.is_leaf = True;
+          new_node->flags.is_leaf = true;
           node->u.kids[i] = new_node;
           new_node->u.rects[0].bptr = query;
           new_node->u.rects[0].bounds = *query;
@@ -1016,7 +1016,7 @@ __r_insert_node (struct rtree_node *node, const BoxType * query,
               best_node = node->u.kids[i];
             }
         }
-      __r_insert_node (best_node, query, manage, True);
+      __r_insert_node (best_node, query, manage, true);
       sort_node (node);
       return;
     }
@@ -1038,7 +1038,7 @@ r_insert_entry (rtree_t * rtree, const BoxType * which, int man)
   rtree->size++;
 }
 
-Boolean
+bool
 __r_delete (struct rtree_node *node, const BoxType * query)
 {
   int i, flag, mask, a;
@@ -1046,7 +1046,7 @@ __r_delete (struct rtree_node *node, const BoxType * query)
   /* the tree might be inconsistent during delete */
   if (query->X1 < node->box.X1 || query->Y1 < node->box.Y1
       || query->X2 > node->box.X2 || query->Y2 > node->box.Y2)
-    return False;
+    return false;
   if (!node->flags.is_leaf)
     {
       for (i = 0; i < M_SIZE; i++)
@@ -1071,7 +1071,7 @@ __r_delete (struct rtree_node *node, const BoxType * query)
                       /* changing type of node, be sure it's all zero */
                       for (i = 1; i < M_SIZE + 1; i++)
                         node->u.rects[i].bptr = NULL;
-                      return True;
+                      return true;
                     }
                   return (__r_delete (node->parent, &node->box));
                 }
@@ -1082,17 +1082,17 @@ __r_delete (struct rtree_node *node, const BoxType * query)
                     adjust_bounds (node);
                     node = node->parent;
                   }
-              return True;
+              return true;
             }
           if (node->u.kids[i])
             {
               if (__r_delete (node->u.kids[i], query))
-                return True;
+                return true;
             }
           else
             break;
         }
-      return False;
+      return false;
     }
   /* leaf node here */
   mask = 0;
@@ -1112,7 +1112,7 @@ __r_delete (struct rtree_node *node, const BoxType * query)
       a <<= 1;
     }
   if (!node->u.rects[i].bptr)
-    return False;               /* not at this leaf */
+    return false;               /* not at this leaf */
   if (node->flags.manage & a)
     {
       free ((void *) node->u.rects[i].bptr);
@@ -1133,7 +1133,7 @@ __r_delete (struct rtree_node *node, const BoxType * query)
     {
       if (node->parent)
         __r_delete (node->parent, &node->box);
-      return True;
+      return true;
     }
   else
     /* propagate boundary adjustment upward */
@@ -1142,13 +1142,13 @@ __r_delete (struct rtree_node *node, const BoxType * query)
         adjust_bounds (node);
         node = node->parent;
       }
-  return True;
+  return true;
 }
 
-Boolean
+bool
 r_delete_entry (rtree_t * rtree, const BoxType * box)
 {
-  Boolean r;
+  bool r;
 
   assert (box);
   assert (rtree);
diff --git a/src/rtree.h b/src/rtree.h
index 254d64a..3e91297 100644
--- a/src/rtree.h
+++ b/src/rtree.h
@@ -47,7 +47,7 @@ rtree_t *r_create_tree (const BoxType * boxlist[], int N, int manage);
 /* destroy an rtree */
 void r_destroy_tree (rtree_t ** rtree);
 
-Boolean r_delete_entry (rtree_t * rtree, const BoxType * which);
+bool r_delete_entry (rtree_t * rtree, const BoxType * which);
 void r_insert_entry (rtree_t * rtree, const BoxType * which, int manage);
 void r_substitute (rtree_t * rtree, const BoxType * before,
 		   const BoxType * after);
diff --git a/src/rubberband.c b/src/rubberband.c
index ec4920f..e5fb797 100644
--- a/src/rubberband.c
+++ b/src/rubberband.c
@@ -70,7 +70,7 @@ static void CheckPinForRubberbandConnection (PinTypePtr);
 static void CheckLinePointForRubberbandConnection (LayerTypePtr,
 						   LineTypePtr,
 						   PointTypePtr,
-						   Boolean);
+						   bool);
 static void CheckPolygonForRubberbandConnection (LayerTypePtr,
 						 PolygonTypePtr);
 static void CheckLinePointForRat (LayerTypePtr, PointTypePtr);
@@ -404,7 +404,7 @@ static void
 CheckLinePointForRubberbandConnection (LayerTypePtr Layer,
 				       LineTypePtr Line,
 				       PointTypePtr LinePoint,
-				       Boolean Exact)
+				       bool Exact)
 {
   Cardinal group;
   struct rubber_info info;
@@ -518,9 +518,9 @@ LookupRubberbandLines (int Type, void *Ptr1, void *Ptr2, void *Ptr3)
 	if (GetLayerNumber (PCB->Data, layer) < max_layer)
 	  {
 	    CheckLinePointForRubberbandConnection (layer, line,
-						   &line->Point1, False);
+						   &line->Point1, false);
 	    CheckLinePointForRubberbandConnection (layer, line,
-						   &line->Point2, False);
+						   &line->Point2, false);
 	  }
 	break;
       }
@@ -529,7 +529,7 @@ LookupRubberbandLines (int Type, void *Ptr1, void *Ptr2, void *Ptr3)
       if (GetLayerNumber (PCB->Data, (LayerTypePtr) Ptr1) < max_layer)
 	CheckLinePointForRubberbandConnection ((LayerTypePtr) Ptr1,
 					       (LineTypePtr) Ptr2,
-					       (PointTypePtr) Ptr3, True);
+					       (PointTypePtr) Ptr3, true);
       break;
 
     case VIA_TYPE:
diff --git a/src/search.c b/src/search.c
index 4d450d3..3f23ff4 100644
--- a/src/search.c
+++ b/src/search.c
@@ -70,32 +70,32 @@ static LayerTypePtr SearchLayer;
  * some local prototypes.  The first parameter includes LOCKED_TYPE if we
  * want to include locked types in the search.
  */
-static Boolean SearchLineByLocation (int, LayerTypePtr *, LineTypePtr *,
+static bool SearchLineByLocation (int, LayerTypePtr *, LineTypePtr *,
 				     LineTypePtr *);
-static Boolean SearchArcByLocation (int, LayerTypePtr *, ArcTypePtr *,
+static bool SearchArcByLocation (int, LayerTypePtr *, ArcTypePtr *,
 				    ArcTypePtr *);
-static Boolean SearchRatLineByLocation (int, RatTypePtr *, RatTypePtr *,
+static bool SearchRatLineByLocation (int, RatTypePtr *, RatTypePtr *,
 					RatTypePtr *);
-static Boolean SearchTextByLocation (int, LayerTypePtr *, TextTypePtr *,
+static bool SearchTextByLocation (int, LayerTypePtr *, TextTypePtr *,
 				     TextTypePtr *);
-static Boolean SearchPolygonByLocation (int, LayerTypePtr *, PolygonTypePtr *,
+static bool SearchPolygonByLocation (int, LayerTypePtr *, PolygonTypePtr *,
 					PolygonTypePtr *);
-static Boolean SearchPinByLocation (int, ElementTypePtr *, PinTypePtr *,
+static bool SearchPinByLocation (int, ElementTypePtr *, PinTypePtr *,
 				    PinTypePtr *);
-static Boolean SearchPadByLocation (int, ElementTypePtr *, PadTypePtr *,
-				    PadTypePtr *, Boolean);
-static Boolean SearchViaByLocation (int, PinTypePtr *, PinTypePtr *,
+static bool SearchPadByLocation (int, ElementTypePtr *, PadTypePtr *,
+				    PadTypePtr *, bool);
+static bool SearchViaByLocation (int, PinTypePtr *, PinTypePtr *,
 				    PinTypePtr *);
-static Boolean SearchElementNameByLocation (int, ElementTypePtr *,
+static bool SearchElementNameByLocation (int, ElementTypePtr *,
 					    TextTypePtr *, TextTypePtr *,
-					    Boolean);
-static Boolean SearchLinePointByLocation (int, LayerTypePtr *, LineTypePtr *,
+					    bool);
+static bool SearchLinePointByLocation (int, LayerTypePtr *, LineTypePtr *,
 					  PointTypePtr *);
-static Boolean SearchPointByLocation (int, LayerTypePtr *, PolygonTypePtr *,
+static bool SearchPointByLocation (int, LayerTypePtr *, PolygonTypePtr *,
 				      PointTypePtr *);
-static Boolean SearchElementByLocation (int, ElementTypePtr *,
+static bool SearchElementByLocation (int, ElementTypePtr *,
 					ElementTypePtr *, ElementTypePtr *,
-					Boolean);
+					bool);
 
 /* ---------------------------------------------------------------------------
  * searches a via
@@ -103,7 +103,7 @@ static Boolean SearchElementByLocation (int, ElementTypePtr *,
 struct ans_info
 {
   void **ptr1, **ptr2, **ptr3;
-  Boolean BackToo;
+  bool BackToo;
   float area;
   jmp_buf env;
   int locked;			/* This will be zero or LOCKFLAG */
@@ -126,7 +126,7 @@ pinorvia_callback (const BoxType * box, void *cl)
   return 1;			/* never reached */
 }
 
-static Boolean
+static bool
 SearchViaByLocation (int locked, PinTypePtr * Via, PinTypePtr * Dummy1,
 		     PinTypePtr * Dummy2)
 {
@@ -134,7 +134,7 @@ SearchViaByLocation (int locked, PinTypePtr * Via, PinTypePtr * Dummy1,
 
   /* search only if via-layer is visible */
   if (!PCB->ViaOn)
-    return False;
+    return false;
 
   info.ptr1 = (void **) Via;
   info.ptr2 = (void **) Dummy1;
@@ -145,16 +145,16 @@ SearchViaByLocation (int locked, PinTypePtr * Via, PinTypePtr * Dummy1,
     {
       r_search (PCB->Data->via_tree, &SearchBox, NULL, pinorvia_callback,
 		&info);
-      return False;
+      return false;
     }
-  return True;
+  return true;
 }
 
 /* ---------------------------------------------------------------------------
  * searches a pin
  * starts with the newest element
  */
-static Boolean
+static bool
 SearchPinByLocation (int locked, ElementTypePtr * Element, PinTypePtr * Pin,
 		     PinTypePtr * Dummy)
 {
@@ -162,7 +162,7 @@ SearchPinByLocation (int locked, ElementTypePtr * Element, PinTypePtr * Pin,
 
   /* search only if pin-layer is visible */
   if (!PCB->PinOn)
-    return False;
+    return false;
   info.ptr1 = (void **) Element;
   info.ptr2 = (void **) Pin;
   info.ptr3 = (void **) Dummy;
@@ -172,8 +172,8 @@ SearchPinByLocation (int locked, ElementTypePtr * Element, PinTypePtr * Pin,
     r_search (PCB->Data->pin_tree, &SearchBox, NULL, pinorvia_callback,
 	      &info);
   else
-    return True;
-  return False;
+    return true;
+  return false;
 }
 
 static int
@@ -201,15 +201,15 @@ pad_callback (const BoxType * b, void *cl)
  * searches a pad
  * starts with the newest element
  */
-static Boolean
+static bool
 SearchPadByLocation (int locked, ElementTypePtr * Element, PadTypePtr * Pad,
-		     PadTypePtr * Dummy, Boolean BackToo)
+		     PadTypePtr * Dummy, bool BackToo)
 {
   struct ans_info info;
 
   /* search only if pin-layer is visible */
   if (!PCB->PinOn)
-    return (False);
+    return (false);
   info.ptr1 = (void **) Element;
   info.ptr2 = (void **) Pad;
   info.ptr3 = (void **) Dummy;
@@ -218,8 +218,8 @@ SearchPadByLocation (int locked, ElementTypePtr * Element, PadTypePtr * Pad,
   if (setjmp (info.env) == 0)
     r_search (PCB->Data->pad_tree, &SearchBox, NULL, pad_callback, &info);
   else
-    return True;
-  return False;
+    return true;
+  return false;
 }
 
 /* ---------------------------------------------------------------------------
@@ -253,7 +253,7 @@ line_callback (const BoxType * box, void *cl)
 }
 
 
-static Boolean
+static bool
 SearchLineByLocation (int locked, LayerTypePtr * Layer, LineTypePtr * Line,
 		      LineTypePtr * Dummy)
 {
@@ -268,9 +268,9 @@ SearchLineByLocation (int locked, LayerTypePtr * Layer, LineTypePtr * Line,
     {
       r_search (SearchLayer->line_tree, &SearchBox, NULL, line_callback,
 		&info);
-      return False;
+      return false;
     }
-  return (True);
+  return (true);
 }
 
 static int
@@ -296,7 +296,7 @@ rat_callback (const BoxType * box, void *cl)
 /* ---------------------------------------------------------------------------
  * searches rat lines if they are visible
  */
-static Boolean
+static bool
 SearchRatLineByLocation (int locked, RatTypePtr * Line, RatTypePtr * Dummy1,
 			 RatTypePtr * Dummy2)
 {
@@ -310,9 +310,9 @@ SearchRatLineByLocation (int locked, RatTypePtr * Line, RatTypePtr * Dummy1,
   if (setjmp (info.env) == 0)
     {
       r_search (PCB->Data->rat_tree, &SearchBox, NULL, rat_callback, &info);
-      return False;
+      return false;
     }
-  return (True);
+  return (true);
 }
 
 /* ---------------------------------------------------------------------------
@@ -343,7 +343,7 @@ arc_callback (const BoxType * box, void *cl)
 }
 
 
-static Boolean
+static bool
 SearchArcByLocation (int locked, LayerTypePtr * Layer, ArcTypePtr * Arc,
 		     ArcTypePtr * Dummy)
 {
@@ -357,9 +357,9 @@ SearchArcByLocation (int locked, LayerTypePtr * Layer, ArcTypePtr * Arc,
   if (setjmp (info.env) == 0)
     {
       r_search (SearchLayer->arc_tree, &SearchBox, NULL, arc_callback, &info);
-      return False;
+      return false;
     }
-  return (True);
+  return (true);
 }
 
 static int
@@ -382,7 +382,7 @@ text_callback (const BoxType * box, void *cl)
 /* ---------------------------------------------------------------------------
  * searches text on the SearchLayer
  */
-static Boolean
+static bool
 SearchTextByLocation (int locked, LayerTypePtr * Layer, TextTypePtr * Text,
 		      TextTypePtr * Dummy)
 {
@@ -397,9 +397,9 @@ SearchTextByLocation (int locked, LayerTypePtr * Layer, TextTypePtr * Text,
     {
       r_search (SearchLayer->text_tree, &SearchBox, NULL, text_callback,
 		&info);
-      return False;
+      return false;
     }
-  return (True);
+  return (true);
 }
 
 static int
@@ -423,7 +423,7 @@ polygon_callback (const BoxType * box, void *cl)
 /* ---------------------------------------------------------------------------
  * searches a polygon on the SearchLayer 
  */
-static Boolean
+static bool
 SearchPolygonByLocation (int locked, LayerTypePtr * Layer,
 			 PolygonTypePtr * Polygon, PolygonTypePtr * Dummy)
 {
@@ -438,9 +438,9 @@ SearchPolygonByLocation (int locked, LayerTypePtr * Layer,
     {
       r_search (SearchLayer->polygon_tree, &SearchBox, NULL, polygon_callback,
 		&info);
-      return False;
+      return false;
     }
-  return (True);
+  return (true);
 }
 
 static int
@@ -478,7 +478,7 @@ linepoint_callback (const BoxType * b, void *cl)
 /* ---------------------------------------------------------------------------
  * searches a line-point on all the search layer
  */
-static Boolean
+static bool
 SearchLinePointByLocation (int locked, LayerTypePtr * Layer,
 			   LineTypePtr * Line, PointTypePtr * Point)
 {
@@ -493,20 +493,20 @@ SearchLinePointByLocation (int locked, LayerTypePtr * Layer,
   info.locked = (locked & LOCKED_TYPE) ? 0 : LOCKFLAG;
   if (r_search
       (SearchLayer->line_tree, &SearchBox, NULL, linepoint_callback, &info))
-    return True;
-  return False;
+    return true;
+  return false;
 }
 
 /* ---------------------------------------------------------------------------
  * searches a polygon-point on all layers that are switched on
  * in layerstack order
  */
-static Boolean
+static bool
 SearchPointByLocation (int locked, LayerTypePtr * Layer,
 		       PolygonTypePtr * Polygon, PointTypePtr * Point)
 {
   float d, least;
-  Boolean found = False;
+  bool found = false;
 
   least = SQUARE (SearchRadius + MAX_POLYGON_POINT_DISTANCE);
   *Layer = SearchLayer;
@@ -520,15 +520,15 @@ SearchPointByLocation (int locked, LayerTypePtr * Layer,
 	  least = d;
 	  *Polygon = polygon;
 	  *Point = point;
-	  found = True;
+	  found = true;
 	}
     }
     END_LOOP;
   }
   END_LOOP;
   if (found)
-    return (True);
-  return (False);
+    return (true);
+  return (false);
 }
 
 static int
@@ -563,10 +563,10 @@ name_callback (const BoxType * box, void *cl)
  * searches the name of an element
  * the search starts with the last element and goes back to the beginning
  */
-static Boolean
+static bool
 SearchElementNameByLocation (int locked, ElementTypePtr * Element,
 			     TextTypePtr * Text, TextTypePtr * Dummy,
-			     Boolean BackToo)
+			     bool BackToo)
 {
   struct ans_info info;
 
@@ -581,9 +581,9 @@ SearchElementNameByLocation (int locked, ElementTypePtr * Element,
       info.locked = (locked & LOCKED_TYPE) ? 0 : LOCKFLAG;
       if (r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], &SearchBox, NULL,
 		    name_callback, &info))
-	return True;
+	return true;
     }
-  return (False);
+  return (false);
 }
 
 static int
@@ -617,11 +617,11 @@ element_callback (const BoxType * box, void *cl)
  * the search starts with the last element and goes back to the beginning
  * if more than one element matches, the smallest one is taken
  */
-static Boolean
+static bool
 SearchElementByLocation (int locked,
 			 ElementTypePtr * Element,
 			 ElementTypePtr * Dummy1, ElementTypePtr * Dummy2,
-			 Boolean BackToo)
+			 bool BackToo)
 {
   struct ans_info info;
 
@@ -637,15 +637,15 @@ SearchElementByLocation (int locked,
       if (r_search
 	  (PCB->Data->element_tree, &SearchBox, NULL, element_callback,
 	   &info))
-	return True;
+	return true;
     }
-  return False;
+  return false;
 }
 
 /* ---------------------------------------------------------------------------
  * checks if a point is on a pin
  */
-Boolean
+bool
 IsPointOnPin (float X, float Y, float Radius, PinTypePtr pin)
 {
   if (TEST_FLAG (SQUAREFLAG, pin))
@@ -658,24 +658,24 @@ IsPointOnPin (float X, float Y, float Radius, PinTypePtr pin)
       b.Y1 = pin->Y - t;
       b.Y2 = pin->Y + t;
       if (IsPointInBox (X, Y, &b, Radius))
-	return (True);
+	return (true);
     }
   else if (SQUARE (pin->X - X) + SQUARE (pin->Y - Y) <=
 	   SQUARE (pin->Thickness / 2 + Radius))
-    return (True);
-  return (False);
+    return (true);
+  return (false);
 }
 
 /* ---------------------------------------------------------------------------
  * checks if a rat-line end is on a PV
  */
-Boolean
+bool
 IsPointOnLineEnd (LocationType X, LocationType Y, RatTypePtr Line)
 {
   if (((X == Line->Point1.X) && (Y == Line->Point1.Y)) ||
       ((X == Line->Point2.X) && (Y == Line->Point2.Y)))
-    return (True);
-  return (False);
+    return (true);
+  return (false);
 }
 
 /* ---------------------------------------------------------------------------
@@ -708,14 +708,14 @@ IsPointOnLineEnd (LocationType X, LocationType Y, RatTypePtr Line)
  *   d = ----------------------------
  *                    l
  */
-Boolean
+bool
 IsPointOnLine (float X, float Y, float Radius, LineTypePtr Line)
 {
   register float dx, dy, dx1, dy1, l, d, r;
   Radius += ((float) Line->Thickness + 1.) / 2.0;
   if (Y + Radius < MIN (Line->Point1.Y, Line->Point2.Y) ||
       Y - Radius > MAX (Line->Point1.Y, Line->Point2.Y))
-    return False;
+    return false;
   dx = (float) (Line->Point2.X - Line->Point1.X);
   dy = (float) (Line->Point2.Y - Line->Point1.Y);
   dx1 = (float) (Line->Point1.X - X);
@@ -727,15 +727,15 @@ IsPointOnLine (float X, float Y, float Radius, LineTypePtr Line)
   if ((l = dx * dx + dy * dy) == 0.0)
     {
       l = SQUARE (Line->Point1.X - X) + SQUARE (Line->Point1.Y - Y);
-      return ((l <= Radius) ? True : False);
+      return ((l <= Radius) ? true : false);
     }
   if (d * d > Radius * l)
-    return (False);
+    return (false);
 
   /* they intersect if Q is on line */
   r = -(dx * dx1 + dy * dy1);
   if (r >= 0 && r <= l)
-    return (True);
+    return (true);
 
   /* we have to check P1 or P2 depending on the sign of r */
   if (r < 0.0)
@@ -748,7 +748,7 @@ IsPointOnLine (float X, float Y, float Radius, LineTypePtr Line)
 /* ---------------------------------------------------------------------------
  * checks if a line crosses a rectangle
  */
-Boolean
+bool
 IsLineInRectangle (LocationType X1, LocationType Y1,
 		   LocationType X2, LocationType Y2, LineTypePtr Line)
 {
@@ -758,7 +758,7 @@ IsLineInRectangle (LocationType X1, LocationType Y1,
   /* in case the whole line is inside the rectangle */
   if (X1 < Line->Point1.X && X2 > Line->Point1.X &&
       Y1 < Line->Point1.Y && Y2 > Line->Point1.Y)
-    return (True);
+    return (true);
   /* construct a set of dummy lines and check each of them */
   line.Thickness = 0;
   line.Flags = NoFlags ();
@@ -768,30 +768,30 @@ IsLineInRectangle (LocationType X1, LocationType Y1,
   line.Point1.X = X1;
   line.Point2.X = X2;
   if (LineLineIntersect (&line, Line))
-    return (True);
+    return (true);
 
   /* upper-right to lower-right corner */
   line.Point1.X = X2;
   line.Point1.Y = Y1;
   line.Point2.Y = Y2;
   if (LineLineIntersect (&line, Line))
-    return (True);
+    return (true);
 
   /* lower-right to lower-left corner */
   line.Point1.Y = Y2;
   line.Point1.X = X1;
   line.Point2.X = X2;
   if (LineLineIntersect (&line, Line))
-    return (True);
+    return (true);
 
   /* lower-left to upper-left corner */
   line.Point2.X = X1;
   line.Point1.Y = Y1;
   line.Point2.Y = Y2;
   if (LineLineIntersect (&line, Line))
-    return (True);
+    return (true);
 
-  return (False);
+  return (false);
 }
 static int 
 sign(float x){return x<0?-1:x>0?1:0;}
@@ -818,15 +818,15 @@ IsPointInQuadrangle(PointType p[4],PointTypePtr l)
       y = l->Y - p[2].Y;
       prod1 = (float)x * dx + (float)y * dy;
       if (sign (prod0) * sign (prod1) <= 0)
-	return True;
+	return true;
     }
-  return False;
+  return false;
 }
 /* ---------------------------------------------------------------------------
  * checks if a line crosses a quadrangle: almost copied from IsLineInRectangle()
  * Note: actually this quadrangle is a slanted rectangle
  */
-Boolean
+bool
 IsLineInQuadrangle (PointType p[4], LineTypePtr Line)
 {
   LineType line;
@@ -834,9 +834,9 @@ IsLineInQuadrangle (PointType p[4], LineTypePtr Line)
   /* first, see if point 1 is inside the rectangle */
   /* in case the whole line is inside the rectangle */
   if (IsPointInQuadrangle(p,&(Line->Point1)))
-    return True;
+    return true;
   if (IsPointInQuadrangle(p,&(Line->Point2)))
-    return True;
+    return true;
   /* construct a set of dummy lines and check each of them */
   line.Thickness = 0;
   line.Flags = NoFlags ();
@@ -845,29 +845,29 @@ IsLineInQuadrangle (PointType p[4], LineTypePtr Line)
   line.Point1.X = p[0].X; line.Point1.Y = p[0].Y;
   line.Point2.X = p[1].X; line.Point2.Y = p[1].Y;
   if (LineLineIntersect (&line, Line))
-    return (True);
+    return (true);
 
   /* upper-right to lower-right corner */
   line.Point1.X = p[2].X; line.Point1.Y = p[2].Y;
   if (LineLineIntersect (&line, Line))
-    return (True);
+    return (true);
 
   /* lower-right to lower-left corner */
   line.Point2.X = p[3].X; line.Point2.Y = p[3].Y;
   if (LineLineIntersect (&line, Line))
-    return (True);
+    return (true);
 
   /* lower-left to upper-left corner */
   line.Point1.X = p[0].X; line.Point1.Y = p[0].Y;
   if (LineLineIntersect (&line, Line))
-    return (True);
+    return (true);
 
-  return (False);
+  return (false);
 }
 /* ---------------------------------------------------------------------------
  * checks if an arc crosses a square
  */
-Boolean
+bool
 IsArcInRectangle (LocationType X1, LocationType Y1,
 		  LocationType X2, LocationType Y2, ArcTypePtr Arc)
 {
@@ -882,37 +882,37 @@ IsArcInRectangle (LocationType X1, LocationType Y1,
   line.Point1.X = X1;
   line.Point2.X = X2;
   if (LineArcIntersect (&line, Arc))
-    return (True);
+    return (true);
 
   /* upper-right to lower-right corner */
   line.Point1.X = line.Point2.X = X2;
   line.Point1.Y = Y1;
   line.Point2.Y = Y2;
   if (LineArcIntersect (&line, Arc))
-    return (True);
+    return (true);
 
   /* lower-right to lower-left corner */
   line.Point1.Y = line.Point2.Y = Y2;
   line.Point1.X = X1;
   line.Point2.X = X2;
   if (LineArcIntersect (&line, Arc))
-    return (True);
+    return (true);
 
   /* lower-left to upper-left corner */
   line.Point1.X = line.Point2.X = X1;
   line.Point1.Y = Y1;
   line.Point2.Y = Y2;
   if (LineArcIntersect (&line, Arc))
-    return (True);
+    return (true);
 
-  return (False);
+  return (false);
 }
 
 /* ---------------------------------------------------------------------------
  * Check if a circle of Radius with center at (X, Y) intersects a Pad.
  * Written to enable arbitrary pad directions; for rounded pads, too.
  */
-Boolean
+bool
 IsPointInPad (LocationType X, LocationType Y, BDimension Radius,
 	      PadTypePtr Pad)
 {
@@ -988,7 +988,7 @@ IsPointInPad (LocationType X, LocationType Y, BDimension Radius,
   return range < Radius;
 }
 
-Boolean
+bool
 IsPointInBox (LocationType X, LocationType Y, BoxTypePtr box, BDimension Radius)
 {
   BDimension width, height, range;
@@ -1031,13 +1031,13 @@ IsPointInBox (LocationType X, LocationType Y, BoxTypePtr box, BDimension Radius)
       else if (Y > height)
         range = Y - height;
       else
-        return True;
+        return true;
     }
 
   return range < Radius;
 }
 
-Boolean
+bool
 IsPointOnArc (float X, float Y, float Radius, ArcTypePtr Arc)
 {
   double x, y, dx, dy, r1, r2, a, d, l;
@@ -1050,19 +1050,19 @@ IsPointOnArc (float X, float Y, float Radius, ArcTypePtr Arc)
   l = pdx * pdx + pdy * pdy;
   Radius += 0.5 * Arc->Thickness;
   if (Radius < 0) /* thin arc: trivial condition */
-    return (False);
+    return (false);
   /* concentric arcs, simpler intersection conditions */
   if (l < 0.5)
     {
       if (Arc->Width <= Radius)
-	return (True);
+	return (true);
       else
-	return (False);
+	return (false);
     }
   r1 = Arc->Width;
   r2 = Radius;
   if (sqrt (l) < r2 - r1) /* the arc merged in the circle */
-    return (True);
+    return (true);
   r1 *= r1;
   r2 *= r2;
   a = 0.5 * (r1 - r2 + l) / l;
@@ -1070,7 +1070,7 @@ IsPointOnArc (float X, float Y, float Radius, ArcTypePtr Arc)
   d = r1 - a * a;
   /* the circles are too far apart to touch or probably just touch */
   if (d < 0)
-    return (False);
+    return (false);
   /* project the points of intersection */
   d = sqrt (d);
   x = a * pdx;
@@ -1114,14 +1114,14 @@ IsPointOnArc (float X, float Y, float Radius, ArcTypePtr Arc)
       delta = 360 - delta;
     }
   if (ang1 >= startAngle && ang1 <= startAngle + arcDelta)
-    return (True);
+    return (true);
   if (startAngle >= ang1 && startAngle <= ang1 + delta)
-    return (True);
+    return (true);
   if (startAngle + arcDelta >= 360 && ang1 <= startAngle + arcDelta - 360)
-    return (True);
+    return (true);
   if (ang1 + delta >= 360 && startAngle <= ang1 + delta - 360)
-    return (True);
-  return (False);
+    return (true);
+  return (false);
 }
 
 /* ---------------------------------------------------------------------------
@@ -1201,14 +1201,14 @@ SearchObjectByLocation (int Type,
   if (!HigherAvail && Type & PAD_TYPE &&
       SearchPadByLocation (locked,
 			   (ElementTypePtr *) pr1,
-			   (PadTypePtr *) pr2, (PadTypePtr *) pr3, False))
+			   (PadTypePtr *) pr2, (PadTypePtr *) pr3, false))
     HigherAvail = PAD_TYPE;
 
   if (!HigherAvail && Type & ELEMENTNAME_TYPE &&
       SearchElementNameByLocation (locked,
 				   (ElementTypePtr *) pr1,
 				   (TextTypePtr *) pr2, (TextTypePtr *) pr3,
-				   False))
+				   false))
     {
       BoxTypePtr box = &((TextTypePtr) r2)->BoundingBox;
       HigherBound = (float) (box->X2 - box->X1) * (float) (box->Y2 - box->Y1);
@@ -1219,7 +1219,7 @@ SearchObjectByLocation (int Type,
       SearchElementByLocation (locked,
 			       (ElementTypePtr *) pr1,
 			       (ElementTypePtr *) pr2,
-			       (ElementTypePtr *) pr3, False))
+			       (ElementTypePtr *) pr3, false))
     {
       BoxTypePtr box = &((ElementTypePtr) r1)->BoundingBox;
       HigherBound = (float) (box->X2 - box->X1) * (float) (box->Y2 - box->Y1);
@@ -1340,21 +1340,21 @@ SearchObjectByLocation (int Type,
       SearchPadByLocation (locked,
 			   (ElementTypePtr *) Result1,
 			   (PadTypePtr *) Result2, (PadTypePtr *) Result3,
-			   True))
+			   true))
     return (PAD_TYPE);
 
   if (Type & ELEMENTNAME_TYPE &&
       SearchElementNameByLocation (locked,
 				   (ElementTypePtr *) Result1,
 				   (TextTypePtr *) Result2,
-				   (TextTypePtr *) Result3, True))
+				   (TextTypePtr *) Result3, true))
     return (ELEMENTNAME_TYPE);
 
   if (Type & ELEMENT_TYPE &&
       SearchElementByLocation (locked,
 			       (ElementTypePtr *) Result1,
 			       (ElementTypePtr *) Result2,
-			       (ElementTypePtr *) Result3, True))
+			       (ElementTypePtr *) Result3, true))
     return (ELEMENT_TYPE);
 
   return (NO_TYPE);
diff --git a/src/search.h b/src/search.h
index 11d7d03..ae71967 100644
--- a/src/search.h
+++ b/src/search.h
@@ -71,17 +71,17 @@
 /* ---------------------------------------------------------------------------
  * prototypes
  */
-Boolean IsPointOnLine (float, float, float, LineTypePtr);
-Boolean IsPointOnPin (float, float, float, PinTypePtr);
-Boolean IsPointOnArc (float, float, float, ArcTypePtr);
-Boolean IsPointOnLineEnd (LocationType, LocationType, RatTypePtr);
-Boolean IsLineInRectangle (LocationType, LocationType, LocationType,
+bool IsPointOnLine (float, float, float, LineTypePtr);
+bool IsPointOnPin (float, float, float, PinTypePtr);
+bool IsPointOnArc (float, float, float, ArcTypePtr);
+bool IsPointOnLineEnd (LocationType, LocationType, RatTypePtr);
+bool IsLineInRectangle (LocationType, LocationType, LocationType,
 			   LocationType, LineTypePtr);
-Boolean IsLineInQuadrangle (PointType p[4], LineTypePtr Line);
-Boolean IsArcInRectangle (LocationType, LocationType, LocationType,
+bool IsLineInQuadrangle (PointType p[4], LineTypePtr Line);
+bool IsArcInRectangle (LocationType, LocationType, LocationType,
 			  LocationType, ArcTypePtr);
-Boolean IsPointInPad (LocationType, LocationType, BDimension, PadTypePtr);
-Boolean IsPointInBox (LocationType, LocationType, BoxTypePtr, BDimension);
+bool IsPointInPad (LocationType, LocationType, BDimension, PadTypePtr);
+bool IsPointInBox (LocationType, LocationType, BoxTypePtr, BDimension);
 int SearchObjectByLocation (int, void **, void **, void **, LocationType,
 			    LocationType, BDimension);
 int SearchScreen (LocationType, LocationType, int, void **, void **, void **);
diff --git a/src/select.c b/src/select.c
index 7b96fec..5240837 100644
--- a/src/select.c
+++ b/src/select.c
@@ -69,11 +69,11 @@ RCSID ("$Id$");
  * written by and is Copyright (C) 1998, 1999, 2000, 2001 harry eaton
  */
 void
-SelectPin (LibraryEntryTypePtr entry, Boolean toggle)
+SelectPin (LibraryEntryTypePtr entry, bool toggle)
 {
   ConnectionType conn;
 
-  if (SeekPad (entry, &conn, False))
+  if (SeekPad (entry, &conn, false))
     {
       switch (conn.type)
 	{
@@ -86,7 +86,7 @@ SelectPin (LibraryEntryTypePtr entry, Boolean toggle)
 	    if (toggle)
 	      {
 		TOGGLE_FLAG (SELECTEDFLAG, pin);
-		CenterDisplay (pin->X, pin->Y, False);
+		CenterDisplay (pin->X, pin->Y, false);
 	      }
 	    else
 	      SET_FLAG (SELECTEDFLAG, pin);
@@ -102,7 +102,7 @@ SelectPin (LibraryEntryTypePtr entry, Boolean toggle)
 	    if (toggle)
 	      {
 		TOGGLE_FLAG (SELECTEDFLAG, pad);
-		CenterDisplay (pad->Point1.X, pad->Point1.Y, False);
+		CenterDisplay (pad->Point1.X, pad->Point1.Y, false);
 	      }
 	    else
 	      SET_FLAG (SELECTEDFLAG, pad);
@@ -118,19 +118,19 @@ SelectPin (LibraryEntryTypePtr entry, Boolean toggle)
  * toggles the selection of any kind of object
  * the different types are defined by search.h
  */
-Boolean
+bool
 SelectObject (void)
 {
   void *ptr1, *ptr2, *ptr3;
   LayerTypePtr layer;
   int type;
 
-  Boolean changed = True;
+  bool changed = true;
 
   type = SearchScreen (Crosshair.X, Crosshair.Y, SELECT_TYPES,
 		       &ptr1, &ptr2, &ptr3);
   if (type == NO_TYPE || TEST_FLAG (LOCKFLAG, (PinTypePtr) ptr2))
-    return (False);
+    return (false);
   switch (type)
     {
     case VIA_TYPE:
@@ -267,12 +267,12 @@ SelectObject (void)
 /* ----------------------------------------------------------------------
  * selects/unselects all visible objects within the passed box
  * Flag determines if the block is to be selected or unselected
- * returns True if the state of any object has changed
+ * returns true if the state of any object has changed
  */
-Boolean
-SelectBlock (BoxTypePtr Box, Boolean Flag)
+bool
+SelectBlock (BoxTypePtr Box, bool Flag)
 {
-  Boolean changed = False;
+  bool changed = false;
 
   if (PCB->RatOn || !Flag)
     RAT_LOOP (PCB->Data);
@@ -284,7 +284,7 @@ SelectBlock (BoxTypePtr Box, Boolean Flag)
 	ASSIGN_FLAG (SELECTEDFLAG, Flag, line);
 	if (PCB->RatOn)
 	  DrawRat (line, 0);
-	changed = True;
+	changed = true;
       }
   }
   END_LOOP;
@@ -305,7 +305,7 @@ SelectBlock (BoxTypePtr Box, Boolean Flag)
 	  ASSIGN_FLAG (SELECTEDFLAG, Flag, line);
 	  if (layer->On)
 	    DrawLine (layer, line, 0);
-	  changed = True;
+	  changed = true;
 	}
     }
     END_LOOP;
@@ -319,7 +319,7 @@ SelectBlock (BoxTypePtr Box, Boolean Flag)
 	  ASSIGN_FLAG (SELECTEDFLAG, Flag, arc);
 	  if (layer->On)
 	    DrawArc (layer, arc, 0);
-	  changed = True;
+	  changed = true;
 	}
     }
     END_LOOP;
@@ -335,7 +335,7 @@ SelectBlock (BoxTypePtr Box, Boolean Flag)
 	      ASSIGN_FLAG (SELECTEDFLAG, Flag, text);
 	      if (TEXT_IS_VISIBLE(PCB, layer, text))
 		DrawText (layer, text, 0);
-	      changed = True;
+	      changed = true;
 	    }
 	}
     }
@@ -350,7 +350,7 @@ SelectBlock (BoxTypePtr Box, Boolean Flag)
 	  ASSIGN_FLAG (SELECTEDFLAG, Flag, polygon);
 	  if (layer->On)
 	    DrawPolygon (layer, polygon, 0);
-	  changed = True;
+	  changed = true;
 	}
     }
     END_LOOP;
@@ -361,7 +361,7 @@ SelectBlock (BoxTypePtr Box, Boolean Flag)
   ELEMENT_LOOP (PCB->Data);
   {
     {
-      Boolean gotElement = False;
+      bool gotElement = false;
       if ((PCB->ElementOn || !Flag)
 	  && !TEST_FLAG (LOCKFLAG, element)
 	  && ((TEST_FLAG (ONSOLDERFLAG, element) != 0) == SWAP_IDENT
@@ -383,7 +383,7 @@ SelectBlock (BoxTypePtr Box, Boolean Flag)
 	      END_LOOP;
 	      if (PCB->ElementOn)
 		DrawElementName (element, 0);
-	      changed = True;
+	      changed = true;
 	    }
 	  if ((PCB->PinOn || !Flag) && ELEMENT_IN_BOX (element, Box))
 	    if (TEST_FLAG (SELECTEDFLAG, element) != Flag)
@@ -399,7 +399,7 @@ SelectBlock (BoxTypePtr Box, Boolean Flag)
 		      ASSIGN_FLAG (SELECTEDFLAG, Flag, pin);
 		      if (PCB->PinOn)
 			DrawPin (pin, 0);
-		      changed = True;
+		      changed = true;
 		    }
 		}
 		END_LOOP;
@@ -411,14 +411,14 @@ SelectBlock (BoxTypePtr Box, Boolean Flag)
 		      ASSIGN_FLAG (SELECTEDFLAG, Flag, pad);
 		      if (PCB->PinOn)
 			DrawPad (pad, 0);
-		      changed = True;
+		      changed = true;
 		    }
 		}
 		END_LOOP;
 		if (PCB->PinOn)
 		  DrawElement (element, 0);
-		changed = True;
-		gotElement = True;
+		changed = true;
+		gotElement = true;
 	      }
 	}
       if ((PCB->PinOn || !Flag) && !TEST_FLAG (LOCKFLAG, element) && !gotElement)
@@ -432,7 +432,7 @@ SelectBlock (BoxTypePtr Box, Boolean Flag)
 		ASSIGN_FLAG (SELECTEDFLAG, Flag, pin);
 		if (PCB->PinOn)
 		  DrawPin (pin, 0);
-		changed = True;
+		changed = true;
 	      }
 	  }
 	  END_LOOP;
@@ -445,7 +445,7 @@ SelectBlock (BoxTypePtr Box, Boolean Flag)
 		ASSIGN_FLAG (SELECTEDFLAG, Flag, pad);
 		if (PCB->PinOn)
 		  DrawPad (pad, 0);
-		changed = True;
+		changed = true;
 	      }
 	  }
 	  END_LOOP;
@@ -465,7 +465,7 @@ SelectBlock (BoxTypePtr Box, Boolean Flag)
 	ASSIGN_FLAG (SELECTEDFLAG, Flag, via);
 	if (PCB->ViaOn)
 	  DrawVia (via, 0);
-	changed = True;
+	changed = true;
       }
   }
   END_LOOP;
@@ -555,12 +555,12 @@ ObjectOperation (ObjectFunctionTypePtr F,
  * performs several operations on selected objects which are also visible
  * The lowlevel procedures are passed together with additional information
  * resets the selected flag if requested
- * returns True if anything has changed
+ * returns true if anything has changed
  */
-Boolean
-SelectedOperation (ObjectFunctionTypePtr F, Boolean Reset, int type)
+bool
+SelectedOperation (ObjectFunctionTypePtr F, bool Reset, int type)
 {
-  Boolean changed = False;
+  bool changed = false;
 
   /* check lines */
   if (type & LINE_TYPE && F->Line)
@@ -574,7 +574,7 @@ SelectedOperation (ObjectFunctionTypePtr F, Boolean Reset, int type)
 	    CLEAR_FLAG (SELECTEDFLAG, line);
 	  }
 	F->Line (layer, line);
-	changed = True;
+	changed = true;
       }
   }
   ENDALL_LOOP;
@@ -591,7 +591,7 @@ SelectedOperation (ObjectFunctionTypePtr F, Boolean Reset, int type)
 	    CLEAR_FLAG (SELECTEDFLAG, arc);
 	  }
 	F->Arc (layer, arc);
-	changed = True;
+	changed = true;
       }
   }
   ENDALL_LOOP;
@@ -608,7 +608,7 @@ SelectedOperation (ObjectFunctionTypePtr F, Boolean Reset, int type)
 	    CLEAR_FLAG (SELECTEDFLAG, text);
 	  }
 	F->Text (layer, text);
-	changed = True;
+	changed = true;
       }
   }
   ENDALL_LOOP;
@@ -625,7 +625,7 @@ SelectedOperation (ObjectFunctionTypePtr F, Boolean Reset, int type)
 	    CLEAR_FLAG (SELECTEDFLAG, polygon);
 	  }
 	F->Polygon (layer, polygon);
-	changed = True;
+	changed = true;
       }
   }
   ENDALL_LOOP;
@@ -642,7 +642,7 @@ SelectedOperation (ObjectFunctionTypePtr F, Boolean Reset, int type)
 	    CLEAR_FLAG (SELECTEDFLAG, element);
 	  }
 	F->Element (element);
-	changed = True;
+	changed = true;
       }
   }
   END_LOOP;
@@ -660,7 +660,7 @@ SelectedOperation (ObjectFunctionTypePtr F, Boolean Reset, int type)
 	    CLEAR_FLAG (SELECTEDFLAG, &ELEMENT_TEXT (PCB, element));
 	  }
 	F->ElementName (element);
-	changed = True;
+	changed = true;
       }
   }
   END_LOOP;
@@ -678,7 +678,7 @@ SelectedOperation (ObjectFunctionTypePtr F, Boolean Reset, int type)
 	      CLEAR_FLAG (SELECTEDFLAG, pin);
 	    }
 	  F->Pin (element, pin);
-	  changed = True;
+	  changed = true;
 	}
     }
     END_LOOP;
@@ -698,7 +698,7 @@ SelectedOperation (ObjectFunctionTypePtr F, Boolean Reset, int type)
 	      CLEAR_FLAG (SELECTEDFLAG, pad);
 	    }
 	  F->Pad (element, pad);
-	  changed = True;
+	  changed = true;
 	}
     }
     END_LOOP;
@@ -717,7 +717,7 @@ SelectedOperation (ObjectFunctionTypePtr F, Boolean Reset, int type)
 	    CLEAR_FLAG (SELECTEDFLAG, via);
 	  }
 	F->Via (via);
-	changed = True;
+	changed = true;
       }
   }
   END_LOOP;
@@ -733,7 +733,7 @@ SelectedOperation (ObjectFunctionTypePtr F, Boolean Reset, int type)
 	    CLEAR_FLAG (SELECTEDFLAG, line);
 	  }
 	F->Rat (line);
-	changed = True;
+	changed = true;
       }
   }
   END_LOOP;
@@ -745,14 +745,14 @@ SelectedOperation (ObjectFunctionTypePtr F, Boolean Reset, int type)
 /* ----------------------------------------------------------------------
  * selects/unselects all objects which were found during a connection scan
  * Flag determines if they are to be selected or unselected
- * returns True if the state of any object has changed
+ * returns true if the state of any object has changed
  *
  * text objects and elements cannot be selected by this routine
  */
-Boolean
-SelectConnection (Boolean Flag)
+bool
+SelectConnection (bool Flag)
 {
-  Boolean changed = False;
+  bool changed = false;
 
   if (PCB->RatOn)
     RAT_LOOP (PCB->Data);
@@ -762,7 +762,7 @@ SelectConnection (Boolean Flag)
 	AddObjectToFlagUndoList (RATLINE_TYPE, line, line, line);
 	ASSIGN_FLAG (SELECTEDFLAG, Flag, line);
 	DrawRat (line, 0);
-	changed = True;
+	changed = true;
       }
   }
   END_LOOP;
@@ -774,7 +774,7 @@ SelectConnection (Boolean Flag)
 	AddObjectToFlagUndoList (LINE_TYPE, layer, line, line);
 	ASSIGN_FLAG (SELECTEDFLAG, Flag, line);
 	DrawLine (layer, line, 0);
-	changed = True;
+	changed = true;
       }
   }
   ENDALL_LOOP;
@@ -785,7 +785,7 @@ SelectConnection (Boolean Flag)
 	AddObjectToFlagUndoList (ARC_TYPE, layer, arc, arc);
 	ASSIGN_FLAG (SELECTEDFLAG, Flag, arc);
 	DrawArc (layer, arc, 0);
-	changed = True;
+	changed = true;
       }
   }
   ENDALL_LOOP;
@@ -796,7 +796,7 @@ SelectConnection (Boolean Flag)
 	AddObjectToFlagUndoList (POLYGON_TYPE, layer, polygon, polygon);
 	ASSIGN_FLAG (SELECTEDFLAG, Flag, polygon);
 	DrawPolygon (layer, polygon, 0);
-	changed = True;
+	changed = true;
       }
   }
   ENDALL_LOOP;
@@ -810,7 +810,7 @@ SelectConnection (Boolean Flag)
 	    AddObjectToFlagUndoList (PIN_TYPE, element, pin, pin);
 	    ASSIGN_FLAG (SELECTEDFLAG, Flag, pin);
 	    DrawPin (pin, 0);
-	    changed = True;
+	    changed = true;
 	  }
       }
       ENDALL_LOOP;
@@ -821,7 +821,7 @@ SelectConnection (Boolean Flag)
 	    AddObjectToFlagUndoList (PAD_TYPE, element, pad, pad);
 	    ASSIGN_FLAG (SELECTEDFLAG, Flag, pad);
 	    DrawPad (pad, 0);
-	    changed = True;
+	    changed = true;
 	  }
       }
       ENDALL_LOOP;
@@ -835,7 +835,7 @@ SelectConnection (Boolean Flag)
 	AddObjectToFlagUndoList (VIA_TYPE, via, via, via);
 	ASSIGN_FLAG (SELECTEDFLAG, Flag, via);
 	DrawVia (via, 0);
-	changed = True;
+	changed = true;
       }
   }
   END_LOOP;
@@ -847,7 +847,7 @@ SelectConnection (Boolean Flag)
 /* ---------------------------------------------------------------------------
  * selects objects as defined by Type by name;
  * it's a case insensitive match
- * returns True if any object has been selected
+ * returns true if any object has been selected
  */
 
 #if defined (HAVE_REGCOMP)
@@ -866,10 +866,10 @@ regexec_match_all (const  regex_t  *preg,  const  char  *string)
 }
 #endif
 
-Boolean
-SelectObjectByName (int Type, char *Pattern, Boolean Flag)
+bool
+SelectObjectByName (int Type, char *Pattern, bool Flag)
 {
-  Boolean changed = False;
+  bool changed = false;
 
 #if defined(HAVE_REGCOMP)
 #define	REGEXEC(arg)	(regexec_match_all(&compiled, (arg)))
@@ -886,7 +886,7 @@ SelectObjectByName (int Type, char *Pattern, Boolean Flag)
       regerror (result, &compiled, errorstring, 128);
       Message (_("regexp error: %s\n"), errorstring);
       regfree (&compiled);
-      return (False);
+      return (false);
     }
 #else
 #define	REGEXEC(arg)	(re_exec((arg)) == 1)
@@ -897,7 +897,7 @@ SelectObjectByName (int Type, char *Pattern, Boolean Flag)
   if ((compiled = re_comp (Pattern)) != NULL)
     {
       Message (_("re_comp error: %s\n"), compiled);
-      return (False);
+      return (false);
     }
 #endif
 
@@ -914,7 +914,7 @@ SelectObjectByName (int Type, char *Pattern, Boolean Flag)
 	AddObjectToFlagUndoList (TEXT_TYPE, layer, text, text);
 	ASSIGN_FLAG (SELECTEDFLAG, Flag, text);
 	DrawText (layer, text, 0);
-	changed = True;
+	changed = true;
       }
   }
   ENDALL_LOOP;
@@ -952,7 +952,7 @@ SelectObjectByName (int Type, char *Pattern, Boolean Flag)
 	    END_LOOP;
 	    DrawElementName (element, 0);
 	    DrawElement (element, 0);
-	    changed = True;
+	    changed = true;
 	  }
       }
   }
@@ -967,7 +967,7 @@ SelectObjectByName (int Type, char *Pattern, Boolean Flag)
 	AddObjectToFlagUndoList (PIN_TYPE, element, pin, pin);
 	ASSIGN_FLAG (SELECTEDFLAG, Flag, pin);
 	DrawPin (pin, 0);
-	changed = True;
+	changed = true;
       }
   }
   ENDALL_LOOP;
@@ -983,7 +983,7 @@ SelectObjectByName (int Type, char *Pattern, Boolean Flag)
 	  AddObjectToFlagUndoList (PAD_TYPE, element, pad, pad);
 	  ASSIGN_FLAG (SELECTEDFLAG, Flag, pad);
 	  DrawPad (pad, 0);
-	  changed = True;
+	  changed = true;
 	}
   }
   ENDALL_LOOP;
@@ -997,7 +997,7 @@ SelectObjectByName (int Type, char *Pattern, Boolean Flag)
 	AddObjectToFlagUndoList (VIA_TYPE, via, via, via);
 	ASSIGN_FLAG (SELECTEDFLAG, Flag, via);
 	DrawVia (via, 0);
-	changed = True;
+	changed = true;
       }
   }
   END_LOOP;
diff --git a/src/select.h b/src/select.h
index 7a48dae..e24ab82 100644
--- a/src/select.h
+++ b/src/select.h
@@ -37,15 +37,15 @@
 	(VIA_TYPE | LINE_TYPE | TEXT_TYPE | POLYGON_TYPE | ELEMENT_TYPE |	\
 	 PIN_TYPE | PAD_TYPE | ELEMENTNAME_TYPE | RATLINE_TYPE | ARC_TYPE)
 
-void SelectPin (LibraryEntryTypePtr entry, Boolean toggle);
-Boolean SelectObject (void);
-Boolean SelectBlock (BoxTypePtr, Boolean);
-Boolean SelectedOperation (ObjectFunctionTypePtr, Boolean, int);
+void SelectPin (LibraryEntryTypePtr entry, bool toggle);
+bool SelectObject (void);
+bool SelectBlock (BoxTypePtr, bool);
+bool SelectedOperation (ObjectFunctionTypePtr, bool, int);
 void *ObjectOperation (ObjectFunctionTypePtr, int, void *, void *, void *);
-Boolean SelectConnection (Boolean);
+bool SelectConnection (bool);
 
 #if defined(HAVE_REGCOMP) || defined(HAVE_RE_COMP)
-Boolean SelectObjectByName (int, char *, Boolean);
+bool SelectObjectByName (int, char *, bool);
 #endif
 
 #endif
diff --git a/src/set.c b/src/set.c
index 912db04..48d704d 100644
--- a/src/set.c
+++ b/src/set.c
@@ -69,7 +69,7 @@ static int mode_stack[MAX_MODESTACK_DEPTH];
  * sets cursor grid with respect to grid offset values
  */
 void
-SetGrid (float Grid, Boolean align)
+SetGrid (float Grid, bool align)
 {
   if (Grid >= 1 && Grid <= MAX_GRID)
     {
@@ -104,7 +104,7 @@ SetLineSize (BDimension Size)
  * sets a new via thickness
  */
 void
-SetViaSize (BDimension Size, Boolean Force)
+SetViaSize (BDimension Size, bool Force)
 {
   if (Force || (Size <= MAX_PINORVIASIZE &&
 		Size >= MIN_PINORVIASIZE &&
@@ -118,7 +118,7 @@ SetViaSize (BDimension Size, Boolean Force)
  * sets a new via drilling hole
  */
 void
-SetViaDrillingHole (BDimension Size, Boolean Force)
+SetViaDrillingHole (BDimension Size, bool Force)
 {
   if (Force || (Size <= MAX_PINORVIASIZE &&
 		Size >= MIN_PINORVIAHOLE &&
@@ -165,7 +165,7 @@ SetTextScale (Dimension Scale)
  * sets or resets changed flag and redraws status
  */
 void
-SetChangedFlag (Boolean New)
+SetChangedFlag (bool New)
 {
   if (PCB->Changed != New)
     {
@@ -236,15 +236,15 @@ RestoreMode (void)
 void
 SetMode (int Mode)
 {
-  static Boolean recursing = False;
+  static bool recursing = false;
   /* protect the cursor while changing the mode
    * perform some additional stuff depending on the new mode
    * reset 'state' of attached objects
    */
   if (recursing)
     return;
-  recursing = True;
-  HideCrosshair (True);
+  recursing = true;
+  HideCrosshair (true);
   addedLines = 0;
   Crosshair.AttachedObject.Type = NO_TYPE;
   Crosshair.AttachedObject.State = STATE_FIRST;
@@ -286,15 +286,15 @@ SetMode (int Mode)
   else
     {
       if (Settings.Mode == ARC_MODE || Settings.Mode == LINE_MODE)
-	SetLocalRef (0, 0, False);
+	SetLocalRef (0, 0, false);
       Crosshair.AttachedBox.State = STATE_FIRST;
       Crosshair.AttachedLine.State = STATE_FIRST;
       if (Mode == LINE_MODE && TEST_FLAG (AUTODRCFLAG, PCB))
 	{
 	  SaveUndoSerialNumber ();
-	  ResetFoundPinsViasAndPads (True);
+	  ResetFoundPinsViasAndPads (true);
 	  RestoreUndoSerialNumber ();
-	  ResetFoundLinesAndPolygons (True);
+	  ResetFoundLinesAndPolygons (true);
 	  IncrementUndoSerialNumber ();
 	}
     }
@@ -307,13 +307,13 @@ SetMode (int Mode)
   else
     SetCrosshairRange (0, 0, PCB->MaxWidth, PCB->MaxHeight);
 
-  recursing = False;
+  recursing = false;
 
   /* force a crosshair grid update because the valid range
    * may have changed
    */
   MoveCrosshairRelative (0, 0);
-  RestoreCrosshair (True);
+  RestoreCrosshair (true);
 }
 
 void
@@ -334,27 +334,27 @@ SetRouteStyle (char *name)
 }
 
 void
-SetLocalRef (LocationType X, LocationType Y, Boolean Showing)
+SetLocalRef (LocationType X, LocationType Y, bool Showing)
 {
   static MarkType old;
   static int count = 0;
 
   if (Showing)
     {
-      HideCrosshair (True);
+      HideCrosshair (true);
       if (count == 0)
 	old = Marked;
       Marked.X = X;
       Marked.Y = Y;
-      Marked.status = True;
+      Marked.status = true;
       count++;
-      RestoreCrosshair (False);
+      RestoreCrosshair (false);
     }
   else if (count > 0)
     {
-      HideCrosshair (False);
+      HideCrosshair (false);
       count = 0;
       Marked = old;
-      RestoreCrosshair (False);
+      RestoreCrosshair (false);
     }
 }
diff --git a/src/set.h b/src/set.h
index 319bdce..e139766 100644
--- a/src/set.h
+++ b/src/set.h
@@ -34,18 +34,18 @@
 #include "global.h"
 
 void SetTextScale (Dimension);
-void SetGrid (float, Boolean);
+void SetGrid (float, bool);
 void SetZoom (float);
 void SetLineSize (BDimension);
-void SetViaSize (BDimension, Boolean);
-void SetViaDrillingHole (BDimension, Boolean);
+void SetViaSize (BDimension, bool);
+void SetViaDrillingHole (BDimension, bool);
 void SetKeepawayWidth (BDimension);
-void SetChangedFlag (Boolean);
+void SetChangedFlag (bool);
 void SetBufferNumber (int);
 void SetMode (int);
 void SetCrosshairRangeToBuffer (void);
 void SetRouteStyle (char *);
-void SetLocalRef (LocationType, LocationType, Boolean);
+void SetLocalRef (LocationType, LocationType, bool);
 void RedrawZoom (Position, Position);
 void SaveMode (void);
 void RestoreMode (void);
diff --git a/src/thermal.c b/src/thermal.c
index 445b97d..4fdcb1c 100644
--- a/src/thermal.c
+++ b/src/thermal.c
@@ -89,7 +89,7 @@ struct cent
 
 static POLYAREA *
 diag_line (LocationType X, LocationType Y, BDimension l, BDimension w,
-           Boolean rt)
+           bool rt)
 {
   PLINE *c;
   Vector v;
@@ -374,9 +374,9 @@ oct_therm (PinTypePtr pin, Cardinal style)
     {
     default:
     case 1:
-      p = diag_line (pin->X, pin->Y, w, t, True);
+      p = diag_line (pin->X, pin->Y, w, t, true);
       poly_Boolean_free (m, p, &p2, PBO_SUB);
-      p = diag_line (pin->X, pin->Y, w, t, False);
+      p = diag_line (pin->X, pin->Y, w, t, false);
       poly_Boolean_free (p2, p, &m, PBO_SUB);
       return m;
     case 2:
@@ -441,9 +441,9 @@ ThermPoly (PCBTypePtr p, PinTypePtr pin, Cardinal laynum)
           }
         else
           {
-            pa = diag_line (pin->X, pin->Y, t, w, True);
+            pa = diag_line (pin->X, pin->Y, t, w, true);
             poly_Boolean_free (m, pa, &arc, PBO_SUB);
-            pa = diag_line (pin->X, pin->Y, t, w, False);
+            pa = diag_line (pin->X, pin->Y, t, w, false);
           }
         poly_Boolean_free (arc, pa, &m, PBO_SUB);
         return m;
diff --git a/src/toporouter.c b/src/toporouter.c
index e820677..fa57635 100644
--- a/src/toporouter.c
+++ b/src/toporouter.c
@@ -2798,9 +2798,9 @@ void
 import_clusters(toporouter_t *r)
 {
   NetListListType nets;
-  ResetFoundPinsViasAndPads (False);
-  ResetFoundLinesAndPolygons (False);
-  nets = CollectSubnets(False);
+  ResetFoundPinsViasAndPads (false);
+  ResetFoundLinesAndPolygons (false);
+  nets = CollectSubnets(false);
   NETLIST_LOOP(&nets);
   {
     if(netlist->NetN > 0) {
@@ -7960,9 +7960,9 @@ toporouter (int argc, char **argv, int x, int y)
   toporouter_free(r);
   
   SaveUndoSerialNumber ();
-  DeleteRats (False);
+  DeleteRats (false);
   RestoreUndoSerialNumber ();
-  AddAllRats (False, NULL);
+  AddAllRats (false, NULL);
   RestoreUndoSerialNumber ();
   IncrementUndoSerialNumber ();
   ClearAndRedrawOutput ();
diff --git a/src/undo.c b/src/undo.c
index cb8d180..50c6de5 100644
--- a/src/undo.c
+++ b/src/undo.c
@@ -123,7 +123,7 @@ LayerChangeType, *LayerChangeTypePtr;
 
 typedef struct			/* information about poly clear/restore */
 {
-  Boolean Clear;		/* true was clear, false was restore */
+  bool Clear;		/* true was clear, false was restore */
   LayerTypePtr Layer;
 }
 ClearPolyType, *ClearPolyTypePtr;
@@ -167,8 +167,8 @@ static int Serial = 1,		/* serial number */
   SavedSerial;
 static size_t UndoN, RedoN,	/* number of entries */
   UndoMax;
-static Boolean Locked = False;	/* do not add entries if */
-static Boolean andDraw = True;
+static bool Locked = false;	/* do not add entries if */
+static bool andDraw = true;
 										/* flag is set; prevents from */
 										/* infinite loops */
 
@@ -177,22 +177,22 @@ static Boolean andDraw = True;
  */
 static UndoListTypePtr GetUndoSlot (int, int, int);
 static void DrawRecoveredObject (int, void *, void *, void *);
-static Boolean UndoRotate (UndoListTypePtr);
-static Boolean UndoChangeName (UndoListTypePtr);
-static Boolean UndoCopyOrCreate (UndoListTypePtr);
-static Boolean UndoMove (UndoListTypePtr);
-static Boolean UndoRemove (UndoListTypePtr);
-static Boolean UndoRemovePoint (UndoListTypePtr);
-static Boolean UndoInsertPoint (UndoListTypePtr);
-static Boolean UndoMoveToLayer (UndoListTypePtr);
-static Boolean UndoFlag (UndoListTypePtr);
-static Boolean UndoMirror (UndoListTypePtr);
-static Boolean UndoChangeSize (UndoListTypePtr);
-static Boolean UndoChange2ndSize (UndoListTypePtr);
-static Boolean UndoChangeAngles (UndoListTypePtr);
-static Boolean UndoChangeClearSize (UndoListTypePtr);
-static Boolean UndoChangeMaskSize (UndoListTypePtr);
-static Boolean UndoClearPoly (UndoListTypePtr);
+static bool UndoRotate (UndoListTypePtr);
+static bool UndoChangeName (UndoListTypePtr);
+static bool UndoCopyOrCreate (UndoListTypePtr);
+static bool UndoMove (UndoListTypePtr);
+static bool UndoRemove (UndoListTypePtr);
+static bool UndoRemovePoint (UndoListTypePtr);
+static bool UndoInsertPoint (UndoListTypePtr);
+static bool UndoMoveToLayer (UndoListTypePtr);
+static bool UndoFlag (UndoListTypePtr);
+static bool UndoMirror (UndoListTypePtr);
+static bool UndoChangeSize (UndoListTypePtr);
+static bool UndoChange2ndSize (UndoListTypePtr);
+static bool UndoChangeAngles (UndoListTypePtr);
+static bool UndoChangeClearSize (UndoListTypePtr);
+static bool UndoChangeMaskSize (UndoListTypePtr);
+static bool UndoClearPoly (UndoListTypePtr);
 static int PerformUndo (UndoListTypePtr);
 
 /* ---------------------------------------------------------------------------
@@ -281,9 +281,9 @@ DrawRecoveredObject (int Type, void *Ptr1, void *Ptr2, void *Ptr3)
 
 /* ---------------------------------------------------------------------------
  * recovers an object from a 'rotate' operation
- * returns True if anything has been recovered
+ * returns true if anything has been recovered
  */
-static Boolean
+static bool
 UndoRotate (UndoListTypePtr Entry)
 {
   void *ptr1, *ptr2, *ptr3;
@@ -295,21 +295,21 @@ UndoRotate (UndoListTypePtr Entry)
   if (type != NO_TYPE)
     {
       if (TEST_FLAG (LOCKFLAG, (ArcTypePtr) ptr2))
-	return (False);
+	return (false);
       RotateObject (type, ptr1, ptr2, ptr3,
 		    Entry->Data.Rotate.CenterX, Entry->Data.Rotate.CenterY,
 		    (4 - Entry->Data.Rotate.Steps) & 0x03);
       Entry->Data.Rotate.Steps = (4 - Entry->Data.Rotate.Steps) & 0x03;
-      return (True);
+      return (true);
     }
-  return (False);
+  return (false);
 }
 
 /* ---------------------------------------------------------------------------
  * recovers an object from a clear/restore poly operation
- * returns True if anything has been recovered
+ * returns true if anything has been recovered
  */
-static Boolean
+static bool
 UndoClearPoly (UndoListTypePtr Entry)
 {
   void *ptr1, *ptr2, *ptr3;
@@ -324,16 +324,16 @@ UndoClearPoly (UndoListTypePtr Entry)
       else
 	ClearFromPolygon (PCB->Data, type, Entry->Data.ClearPoly.Layer, ptr3);
       Entry->Data.ClearPoly.Clear = !Entry->Data.ClearPoly.Clear;
-      return True;
+      return true;
     }
-  return False;
+  return false;
 }
 
 /* ---------------------------------------------------------------------------
  * recovers an object from a 'change name' operation
- * returns True if anything has been recovered
+ * returns true if anything has been recovered
  */
-static Boolean
+static bool
 UndoChangeName (UndoListTypePtr Entry)
 {
   void *ptr1, *ptr2, *ptr3;
@@ -345,19 +345,19 @@ UndoChangeName (UndoListTypePtr Entry)
   if (type != NO_TYPE)
     {
       if (TEST_FLAG (LOCKFLAG, (TextTypePtr) ptr3))
-	return (False);
+	return (false);
       Entry->Data.ChangeName.Name =
 	(ChangeObjectName (type, ptr1, ptr2, ptr3,
 			   Entry->Data.ChangeName.Name));
-      return (True);
+      return (true);
     }
-  return (False);
+  return (false);
 }
 
 /* ---------------------------------------------------------------------------
  * recovers an object from a 2ndSize change operation
  */
-static Boolean
+static bool
 UndoChange2ndSize (UndoListTypePtr Entry)
 {
   void *ptr1, *ptr2, *ptr3;
@@ -370,22 +370,22 @@ UndoChange2ndSize (UndoListTypePtr Entry)
   if (type != NO_TYPE)
     {
       if (TEST_FLAG (LOCKFLAG, (PinTypePtr) ptr2))
-	return (False);
+	return (false);
       swap = ((PinTypePtr) ptr2)->DrillingHole;
       if (andDraw)
 	EraseObject (type, ptr1, ptr2);
       ((PinTypePtr) ptr2)->DrillingHole = Entry->Data.Size;
       Entry->Data.Size = swap;
       DrawObject (type, ptr1, ptr2, 0);
-      return (True);
+      return (true);
     }
-  return (False);
+  return (false);
 }
 
 /* ---------------------------------------------------------------------------
  * recovers an object from a ChangeAngles change operation
  */
-static Boolean
+static bool
 UndoChangeAngles (UndoListTypePtr Entry)
 {
   void *ptr1, *ptr2, *ptr3;
@@ -400,7 +400,7 @@ UndoChangeAngles (UndoListTypePtr Entry)
       LayerTypePtr Layer = (LayerTypePtr) ptr1;
       ArcTypePtr a = (ArcTypePtr) ptr2;
       if (TEST_FLAG (LOCKFLAG, a))
-	return (False);
+	return (false);
       r_delete_entry (Layer->arc_tree, (BoxTypePtr) a);
       old_sa = a->StartAngle;
       old_da = a->Delta;
@@ -413,15 +413,15 @@ UndoChangeAngles (UndoListTypePtr Entry)
       Entry->Data.Move.DX = old_sa;
       Entry->Data.Move.DY = old_da;;
       DrawObject (type, ptr1, a, 0);
-      return (True);
+      return (true);
     }
-  return (False);
+  return (false);
 }
 
 /* ---------------------------------------------------------------------------
  * recovers an object from a clearance size change operation
  */
-static Boolean
+static bool
 UndoChangeClearSize (UndoListTypePtr Entry)
 {
   void *ptr1, *ptr2, *ptr3;
@@ -434,7 +434,7 @@ UndoChangeClearSize (UndoListTypePtr Entry)
   if (type != NO_TYPE)
     {
       if (TEST_FLAG (LOCKFLAG, (LineTypePtr) ptr2))
-	return (False);
+	return (false);
       swap = ((PinTypePtr) ptr2)->Clearance;
       RestoreToPolygon (PCB->Data, type, ptr1, ptr2);
       if (andDraw)
@@ -444,15 +444,15 @@ UndoChangeClearSize (UndoListTypePtr Entry)
       Entry->Data.Size = swap;
       if (andDraw)
 	DrawObject (type, ptr1, ptr2, 0);
-      return (True);
+      return (true);
     }
-  return (False);
+  return (false);
 }
 
 /* ---------------------------------------------------------------------------
  * recovers an object from a mask size change operation
  */
-static Boolean
+static bool
 UndoChangeMaskSize (UndoListTypePtr Entry)
 {
   void *ptr1, *ptr2, *ptr3;
@@ -465,7 +465,7 @@ UndoChangeMaskSize (UndoListTypePtr Entry)
   if (type & (VIA_TYPE | PIN_TYPE | PAD_TYPE))
     {
       if (TEST_FLAG (LOCKFLAG, (PinTypePtr) ptr2))
-	return (False);
+	return (false);
       swap =
 	(type ==
 	 PAD_TYPE ? ((PadTypePtr) ptr2)->Mask : ((PinTypePtr) ptr2)->Mask);
@@ -478,16 +478,16 @@ UndoChangeMaskSize (UndoListTypePtr Entry)
       Entry->Data.Size = swap;
       if (andDraw)
 	DrawObject (type, ptr1, ptr2, 0);
-      return (True);
+      return (true);
     }
-  return (False);
+  return (false);
 }
 
 
 /* ---------------------------------------------------------------------------
  * recovers an object from a Size change operation
  */
-static Boolean
+static bool
 UndoChangeSize (UndoListTypePtr Entry)
 {
   void *ptr1, *ptr2, *ptr3;
@@ -500,7 +500,7 @@ UndoChangeSize (UndoListTypePtr Entry)
   if (type != NO_TYPE)
     {
       if (TEST_FLAG (LOCKFLAG, (PinTypePtr) ptr2))
-	return (False);
+	return (false);
       /* Wow! can any object be treated as a pin type for size change?? */
       /* pins, vias, lines, and arcs can. Text can't but it has it's own mechanism */
       swap = ((PinTypePtr) ptr2)->Thickness;
@@ -512,15 +512,15 @@ UndoChangeSize (UndoListTypePtr Entry)
       ClearFromPolygon (PCB->Data, type, ptr1, ptr2);
       if (andDraw)
 	DrawObject (type, ptr1, ptr2, 0);
-      return (True);
+      return (true);
     }
-  return (False);
+  return (false);
 }
 
 /* ---------------------------------------------------------------------------
  * recovers an object from a FLAG change operation
  */
-static Boolean
+static bool
 UndoFlag (UndoListTypePtr Entry)
 {
   void *ptr1, *ptr2, *ptr3;
@@ -537,7 +537,7 @@ UndoFlag (UndoListTypePtr Entry)
       PinTypePtr pin = (PinTypePtr) ptr2;
 
       if (TEST_FLAG (LOCKFLAG, pin))
-	return (False);
+	return (false);
 
       swap = pin->Flags;
 
@@ -557,20 +557,20 @@ UndoFlag (UndoListTypePtr Entry)
 
       if (andDraw && must_redraw)
 	DrawObject (type, ptr1, ptr2, 0);
-      return (True);
+      return (true);
     }
   Message ("hace Internal error: Can't find ID %d type %08x\n", Entry->ID,
 	   Entry->Kind);
   Message ("for UndoFlag Operation. Previous flags: %s\n",
 	   flags_to_string (Entry->Data.Flags, 0));
-  return (False);
+  return (false);
 }
 
 /* ---------------------------------------------------------------------------
  * recovers an object from a mirror operation
- * returns True if anything has been recovered
+ * returns true if anything has been recovered
  */
-static Boolean
+static bool
 UndoMirror (UndoListTypePtr Entry)
 {
   void *ptr1, *ptr2, *ptr3;
@@ -583,23 +583,23 @@ UndoMirror (UndoListTypePtr Entry)
     {
       ElementTypePtr element = (ElementTypePtr) ptr3;
       if (TEST_FLAG (LOCKFLAG, element))
-	return (False);
+	return (false);
       if (andDraw)
 	EraseElement (element);
       MirrorElementCoordinates (PCB->Data, element, Entry->Data.Move.DY);
       if (andDraw)
 	DrawElement (element, 0);
-      return (True);
+      return (true);
     }
   Message ("hace Internal error: UndoMirror on object type %d\n", type);
-  return (False);
+  return (false);
 }
 
 /* ---------------------------------------------------------------------------
  * recovers an object from a 'copy' or 'create' operation
- * returns True if anything has been recovered
+ * returns true if anything has been recovered
  */
-static Boolean
+static bool
 UndoCopyOrCreate (UndoListTypePtr Entry)
 {
   void *ptr1, *ptr2, *ptr3;
@@ -611,7 +611,7 @@ UndoCopyOrCreate (UndoListTypePtr Entry)
   if (type != NO_TYPE)
     {
       if (TEST_FLAG (LOCKFLAG, (PinTypePtr) ptr2))
-	return (False);
+	return (false);
       if (!RemoveList)
 	RemoveList = CreateNewBuffer ();
       if (andDraw)
@@ -619,16 +619,16 @@ UndoCopyOrCreate (UndoListTypePtr Entry)
       /* in order to make this re-doable we move it to the RemoveList */
       MoveObjectToBuffer (RemoveList, PCB->Data, type, ptr1, ptr2, ptr3);
       Entry->Type = UNDO_REMOVE;
-      return (True);
+      return (true);
     }
-  return (False);
+  return (false);
 }
 
 /* ---------------------------------------------------------------------------
  * recovers an object from a 'move' operation
- * returns True if anything has been recovered
+ * returns true if anything has been recovered
  */
-static Boolean
+static bool
 UndoMove (UndoListTypePtr Entry)
 {
   void *ptr1, *ptr2, *ptr3;
@@ -640,21 +640,21 @@ UndoMove (UndoListTypePtr Entry)
   if (type != NO_TYPE)
     {
       if (TEST_FLAG (LOCKFLAG, (LineTypePtr) ptr2))
-	return (False);
+	return (false);
       MoveObject (type, ptr1, ptr2, ptr3,
 		  -Entry->Data.Move.DX, -Entry->Data.Move.DY);
       Entry->Data.Move.DX *= -1;
       Entry->Data.Move.DY *= -1;
-      return (True);
+      return (true);
     }
-  return (False);
+  return (false);
 }
 
 /* ----------------------------------------------------------------------
  * recovers an object from a 'remove' operation
- * returns True if anything has been recovered
+ * returns true if anything has been recovered
  */
-static Boolean
+static bool
 UndoRemove (UndoListTypePtr Entry)
 {
   void *ptr1, *ptr2, *ptr3;
@@ -670,16 +670,16 @@ UndoRemove (UndoListTypePtr Entry)
 	DrawRecoveredObject (type, ptr1, ptr2, ptr3);
       MoveObjectToBuffer (PCB->Data, RemoveList, type, ptr1, ptr2, ptr3);
       Entry->Type = UNDO_CREATE;
-      return (True);
+      return (true);
     }
-  return (False);
+  return (false);
 }
 
 /* ----------------------------------------------------------------------
  * recovers an object from a 'move to another layer' operation
- * returns True if anything has been recovered
+ * returns true if anything has been recovered
  */
-static Boolean
+static bool
 UndoMoveToLayer (UndoListTypePtr Entry)
 {
   void *ptr1, *ptr2, *ptr3;
@@ -691,22 +691,22 @@ UndoMoveToLayer (UndoListTypePtr Entry)
   if (type != NO_TYPE)
     {
       if (TEST_FLAG (LOCKFLAG, (LineTypePtr) ptr2))
-	return (False);
+	return (false);
       swap = GetLayerNumber (PCB->Data, (LayerTypePtr) ptr1);
       MoveObjectToLayer (type, ptr1, ptr2, ptr3,
 			 LAYER_PTR (Entry->Data.
-				    MoveToLayer.OriginalLayer), True);
+				    MoveToLayer.OriginalLayer), true);
       Entry->Data.MoveToLayer.OriginalLayer = swap;
-      return (True);
+      return (true);
     }
-  return (False);
+  return (false);
 }
 
 /* ---------------------------------------------------------------------------
  * recovers a removed polygon point
  * returns true on success
  */
-static Boolean
+static bool
 UndoRemovePoint (UndoListTypePtr Entry)
 {
   LayerTypePtr layer;
@@ -724,14 +724,14 @@ UndoRemovePoint (UndoListTypePtr Entry)
     case POLYGON_TYPE:		/* restore the removed point */
       {
 	if (TEST_FLAG (LOCKFLAG, polygon))
-	  return (False);
+	  return (false);
 	/* recover the point */
 	if (andDraw && layer->On)
 	  ErasePolygon (polygon);
 	InsertPointIntoObject (POLYGON_TYPE, layer, polygon,
 			       &Entry->Data.RemovedPoint.Index,
 			       Entry->Data.RemovedPoint.X,
-			       Entry->Data.RemovedPoint.Y, True);
+			       Entry->Data.RemovedPoint.Y, true);
 	polygon->Points[Entry->Data.RemovedPoint.Index].ID =
 	  Entry->Data.RemovedPoint.ID;
 	if (andDraw && layer->On)
@@ -739,11 +739,11 @@ UndoRemovePoint (UndoListTypePtr Entry)
 	Entry->Type = UNDO_INSERT_POINT;
 	Entry->ID = Entry->Data.RemovedPoint.ID;
 	Entry->Kind = POLYGONPOINT_TYPE;
-	return (True);
+	return (true);
       }
 
     default:
-      return (False);
+      return (false);
     }
 }
 
@@ -751,7 +751,7 @@ UndoRemovePoint (UndoListTypePtr Entry)
  * recovers an inserted polygon point
  * returns true on success
  */
-static Boolean
+static bool
 UndoInsertPoint (UndoListTypePtr Entry)
 {
   LayerTypePtr layer;
@@ -769,7 +769,7 @@ UndoInsertPoint (UndoListTypePtr Entry)
     case POLYGONPOINT_TYPE:	/* removes an inserted polygon point */
       {
 	if (TEST_FLAG (LOCKFLAG, polygon))
-	  return (False);
+	  return (false);
 	if (andDraw && layer->On)
 	  ErasePolygon (polygon);
 	Entry->Data.RemovedPoint.X = pnt->X;
@@ -790,11 +790,11 @@ UndoInsertPoint (UndoListTypePtr Entry)
 	DestroyObject (PCB->Data, POLYGONPOINT_TYPE, layer, polygon, pnt);
 	if (andDraw && layer->On)
 	  DrawPolygon (layer, polygon, 0);
-	return (True);
+	return (true);
       }
 
     default:
-      return (False);
+      return (false);
     }
 }
 
@@ -802,7 +802,7 @@ UndoInsertPoint (UndoListTypePtr Entry)
  * undo a layer change
  * returns true on success
  */
-static Boolean
+static bool
 UndoLayerChange (UndoListTypePtr Entry)
 {
   LayerChangeTypePtr l = &Entry->Data.LayerChange;
@@ -813,16 +813,16 @@ UndoLayerChange (UndoListTypePtr Entry)
   l->old_index = tmp;
 
   if (MoveLayer (l->old_index, l->new_index))
-    return False;
+    return false;
   else
-    return True;
+    return true;
 }
 
 /* ---------------------------------------------------------------------------
  * undo a netlist change
  * returns true on success
  */
-static Boolean
+static bool
 UndoNetlistChange (UndoListTypePtr Entry)
 {
   NetlistChangeTypePtr l = & Entry->Data.NetlistChange;
@@ -874,7 +874,7 @@ UndoNetlistChange (UndoListTypePtr Entry)
   *lib = *saved;
 
   NetlistChanged (0);
-  return True;
+  return true;
 }
 
 /* ---------------------------------------------------------------------------
@@ -883,7 +883,7 @@ UndoNetlistChange (UndoListTypePtr Entry)
  * returns the bitfield for the types of operations that were undone
  */
 int
-Undo (Boolean draw)
+Undo (bool draw)
 {
   UndoListTypePtr ptr;
   int Types = 0;
@@ -902,7 +902,7 @@ Undo (Boolean draw)
 	    Message (_("Nothing to undo - buffer is empty\n"));
 	  else
 	    Serial--;
-	  return (False);
+	  return (false);
 	}
 
       /* lock undo module to prevent from loops
@@ -914,7 +914,7 @@ Undo (Boolean draw)
 	  Message (_("Undo bad serial number %d expecting %d\n"),
 		   ptr->Serial, Serial - 1);
 	  Serial = ptr->Serial + 1;
-	  return (False);
+	  return (false);
 	}
       LockUndo ();
       Serial = ptr->Serial;
@@ -1038,7 +1038,7 @@ PerformUndo (UndoListTypePtr ptr)
  * returns the number of operations redone
  */
 int
-Redo (Boolean draw)
+Redo (bool draw)
 {
   UndoListTypePtr ptr;
   int Types = 0;
@@ -1051,7 +1051,7 @@ Redo (Boolean draw)
 	  Message
 	    (_
 	     ("Nothing to redo. Perhaps changes have been made since last undo\n"));
-	  return (False);
+	  return (false);
 	}
 
       /* lock undo module to prevent from loops
@@ -1087,7 +1087,7 @@ RestoreUndoSerialNumber (void)
 void
 SaveUndoSerialNumber (void)
 {
-  Bumped = False;
+  Bumped = false;
   SavedSerial = Serial;
 }
 
@@ -1105,8 +1105,8 @@ IncrementUndoSerialNumber (void)
       if (UndoN == 0 || UndoList[UndoN - 1].Serial != Serial)
 	return;
       Serial++;
-      Bumped = True;
-      SetChangedFlag (True);
+      Bumped = true;
+      SetChangedFlag (true);
     }
 }
 
@@ -1114,7 +1114,7 @@ IncrementUndoSerialNumber (void)
  * releases memory of the undo- and remove list
  */
 void
-ClearUndoList (Boolean Force)
+ClearUndoList (bool Force)
 {
   UndoListTypePtr undo;
 
@@ -1148,7 +1148,7 @@ ClearUndoList (Boolean Force)
  */
 void
 AddObjectToClearPolyUndoList (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
-			      Boolean clear)
+			      bool clear)
 {
   UndoListTypePtr undo;
 
@@ -1573,7 +1573,7 @@ AddNetlistLibToUndoList (LibraryTypePtr lib)
 void
 LockUndo (void)
 {
-  Locked = True;
+  Locked = true;
 }
 
 /* ---------------------------------------------------------------------------
@@ -1582,13 +1582,13 @@ LockUndo (void)
 void
 UnlockUndo (void)
 {
-  Locked = False;
+  Locked = false;
 }
 
 /* ---------------------------------------------------------------------------
  * return undo lock state
  */
-Boolean
+bool
 Undoing (void)
 {
   return (Locked);
diff --git a/src/undo.h b/src/undo.h
index a138927..c7a0288 100644
--- a/src/undo.h
+++ b/src/undo.h
@@ -38,12 +38,12 @@
 
 											/* different layers */
 
-int Undo (Boolean);
-int Redo (Boolean);
+int Undo (bool);
+int Redo (bool);
 void IncrementUndoSerialNumber (void);
 void SaveUndoSerialNumber (void);
 void RestoreUndoSerialNumber (void);
-void ClearUndoList (Boolean);
+void ClearUndoList (bool);
 void MoveObjectToRemoveUndoList (int, void *, void *, void *);
 void AddObjectToRemovePointUndoList (int, void *, void *, Cardinal);
 void AddObjectToInsertPointUndoList (int, void *, void *, void *);
@@ -61,11 +61,11 @@ void AddObjectTo2ndSizeUndoList (int, void *, void *, void *);
 void AddObjectToClearSizeUndoList (int, void *, void *, void *);
 void AddObjectToMaskSizeUndoList (int, void *, void *, void *);
 void AddObjectToChangeAnglesUndoList (int, void *, void *, void *);
-void AddObjectToClearPolyUndoList (int, void *, void *, void *, Boolean);
+void AddObjectToClearPolyUndoList (int, void *, void *, void *, bool);
 void AddLayerChangeToUndoList (int, int);
 void AddNetlistLibToUndoList (LibraryTypePtr);
 void LockUndo (void);
 void UnlockUndo (void);
-Boolean Undoing (void);
+bool Undoing (void);
 
 #endif
diff --git a/src/vendor.c b/src/vendor.c
index 7d4de5d..39359cc 100644
--- a/src/vendor.c
+++ b/src/vendor.c
@@ -69,7 +69,7 @@ RCSID ("$Id$");
 static void add_to_drills (char *);
 static void apply_vendor_map (void);
 static void process_skips (Resource *);
-static Boolean rematch (const char *, const char *);
+static bool rematch (const char *, const char *);
 
 /* list of vendor drills and a count of them */
 static int *vendor_drills = NULL;
@@ -94,7 +94,7 @@ static double sf;
 
 
 /* enable/disable mapping */
-static Boolean vendorMapEnable = False;
+static bool vendorMapEnable = false;
 
 /* type of drill mapping */
 #define CLOSEST 1
@@ -152,9 +152,9 @@ int
 ActionToggleVendor (int argc, char **argv, int x, int y)
 {
   if (vendorMapEnable)
-    vendorMapEnable = False;
+    vendorMapEnable = false;
   else
-    vendorMapEnable = True;
+    vendorMapEnable = true;
   return 0;
 }
 
@@ -182,7 +182,7 @@ loaded first.
 int
 ActionEnableVendor (int argc, char **argv, int x, int y)
 {
-  vendorMapEnable = True;
+  vendorMapEnable = true;
   return 0;
 }
 
@@ -208,7 +208,7 @@ specified in the currently loaded vendor drill table.
 int
 ActionDisableVendor (int argc, char **argv, int x, int y)
 {
-  vendorMapEnable = False;
+  vendorMapEnable = false;
   return 0;
 }
 
@@ -457,7 +457,7 @@ ActionLoadVendorFrom (int argc, char **argv, int x, int y)
   Message (_("Loaded %d RefDes skips, %d Value skips, %d Descr skips\n"),
 	   n_refdes, n_value, n_descr);
 
-  vendorMapEnable = True;
+  vendorMapEnable = true;
   apply_vendor_map ();
   free (name);
   return 0;
@@ -468,12 +468,12 @@ apply_vendor_map (void)
 {
   int i;
   int changed, tot;
-  Boolean state;
+  bool state;
 
   state = vendorMapEnable;
 
   /* enable mapping */
-  vendorMapEnable = True;
+  vendorMapEnable = true;
 
   /* reset our counts */
   changed = 0;
@@ -494,7 +494,7 @@ apply_vendor_map (void)
 	      {
 		if (ChangeObject2ndSize (VIA_TYPE, via, NULL, NULL,
 					 vendorDrillMap (via->DrillingHole),
-					 True, False))
+					 true, false))
 		  changed++;
 		else
 		  {
@@ -534,7 +534,7 @@ apply_vendor_map (void)
 		      if (ChangeObject2ndSize (PIN_TYPE, element, pin, NULL,
 					       vendorDrillMap (pin->
 							       DrillingHole),
-					       True, False))
+					       true, false))
 			changed++;
 		      else
 			{
@@ -608,7 +608,7 @@ apply_vendor_map (void)
        */
       if (changed)
 	{
-	  SetChangedFlag (True);
+	  SetChangedFlag (true);
 	  ClearAndRedrawOutput ();
 	  IncrementUndoSerialNumber ();
 	}
@@ -630,7 +630,7 @@ vendorDrillMap (int in)
 
   /* skip the mapping if we don't have a vendor drill table */
   if ((n_vendor_drills == 0) || (vendor_drills == NULL)
-      || (vendorMapEnable == False))
+      || (vendorMapEnable == false))
     {
       cached_map = in;
       return in;
@@ -817,14 +817,14 @@ process_skips (Resource * res)
 
 }
 
-Boolean
+bool
 vendorIsElementMappable (ElementTypePtr element)
 {
   int i;
   int noskip;
 
-  if (vendorMapEnable == False)
-    return False;
+  if (vendorMapEnable == false)
+    return false;
 
   noskip = 1;
   for (i = 0; i < n_refdes; i++)
@@ -875,12 +875,12 @@ vendorIsElementMappable (ElementTypePtr element)
     }
 
   if (noskip)
-    return True;
+    return true;
   else
-    return False;
+    return false;
 }
 
-static Boolean
+static bool
 rematch (const char *re, const char *s)
 {
   /*
@@ -903,16 +903,16 @@ rematch (const char *re, const char *s)
       regerror (result, &compiled, errorstring, sizeof (errorstring));
       Message ("regexp error: %s\n", errorstring);
       regfree (&compiled);
-      return (False);
+      return (false);
     }
 
   result = regexec (&compiled, s, 1, &match, 0);
   regfree (&compiled);
 
   if (result == 0)
-    return (True);
+    return (true);
   else
-    return (False);
+    return (false);
 
 #elif defined(HAVE_RE_COMP)
   int m;
@@ -922,7 +922,7 @@ rematch (const char *re, const char *s)
   if ((rslt = re_comp (re)) != NULL)
     {
       Message ("re_comp error: %s\n", rslt);
-      return (False);
+      return (false);
     }
 
   m = re_exec (s);
@@ -930,11 +930,11 @@ rematch (const char *re, const char *s)
   switch m
     {
     case 1:
-      return (True);
+      return (true);
       break;
 
     case 0:
-      return (False);
+      return (false);
       break;
 
     default:
@@ -943,7 +943,7 @@ rematch (const char *re, const char *s)
     }
 
 #else
-  return (False);
+  return (false);
 #endif
 
 }
diff --git a/src/vendor.h b/src/vendor.h
index 8d7ef6f..3b4d2d4 100644
--- a/src/vendor.h
+++ b/src/vendor.h
@@ -26,6 +26,6 @@
 #define __VENDOR_H__
 
 int vendorDrillMap (int);
-Boolean vendorIsElementMappable (ElementTypePtr);
+bool vendorIsElementMappable (ElementTypePtr);
 
 #endif /* __VENDOR_H__ */

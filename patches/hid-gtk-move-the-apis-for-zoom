Bottom: 23f0f74ef7a2c14751c8237d1b8784fd0af7bcd0
Top:    8d1c63ebf590e71e54b474cad53a18c80a5f0589
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-08-27 13:35:23 +0100

hid/gtk: Move the APIs for zooming / panning into the renderers

This is the first step towards making the view parameters private to
each renderer. Unfortunately, it does mean duplicating a bit of code.


---

diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index 963b5d4..1710000 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -1265,6 +1265,127 @@ ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y)
   return true;
 }
 
+static void
+pan_common (GHidPort *port)
+{
+  int event_x, event_y;
+
+  /* We need to fix up the PCB coordinates corresponding to the last
+  * event so convert it back to event coordinates temporarily. */
+  ghid_pcb_to_event_coords (gport->pcb_x, gport->pcb_y, &event_x, &event_y);
+
+  /* Don't pan so far the board is completely off the screen */
+  port->view.x0 = MAX (-port->view.width,  port->view.x0);
+  port->view.y0 = MAX (-port->view.height, port->view.y0);
+  port->view.x0 = MIN ( port->view.x0, PCB->MaxWidth);
+  port->view.y0 = MIN ( port->view.y0, PCB->MaxHeight);
+
+  /* Fix up noted event coordinates to match where we clamped. Alternatively
+   * we could call ghid_note_event_location (NULL); to get a new pointer
+   * location, but this costs us an xserver round-trip (on X11 platforms)
+   */
+  ghid_event_to_pcb_coords (event_x, event_y, &gport->pcb_x, &gport->pcb_y);
+
+  ghidgui->adjustment_changed_holdoff = TRUE;
+  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view.x0);
+  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view.y0);
+  ghidgui->adjustment_changed_holdoff = FALSE;
+
+  ghid_port_ranges_changed();
+}
+
+void
+ghid_pan_view_abs (Coord pcb_x, Coord pcb_y, int widget_x, int widget_y)
+{
+  gport->view.x0 = SIDE_X (pcb_x) - widget_x * gport->view.coord_per_px;
+  gport->view.y0 = SIDE_Y (pcb_y) - widget_y * gport->view.coord_per_px;
+
+  pan_common (gport);
+}
+
+void
+ghid_pan_view_rel (Coord dx, Coord dy)
+{
+  gport->view.x0 += dx;
+  gport->view.y0 += dy;
+
+  pan_common (gport);
+}
+
+
+/* gport->view.coord_per_px:
+ * zoom value is PCB units per screen pixel.  Larger numbers mean zooming
+ * out - the largest value means you are looking at the whole board.
+ *
+ * gport->view_width and gport->view_height are in PCB coordinates
+ */
+
+#define ALLOW_ZOOM_OUT_BY 10 /* Arbitrary, and same as the lesstif HID */
+void
+ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
+{
+  double min_zoom, max_zoom;
+  double xtmp, ytmp;
+
+  /* Limit the "minimum" zoom constant (maximum zoom), at 1 pixel per PCB
+   * unit, and set the "maximum" zoom constant (minimum zoom), such that
+   * the entire board just fits inside the viewport
+   */
+  min_zoom = 1;
+  max_zoom = MAX (PCB->MaxWidth  / gport->width,
+                  PCB->MaxHeight / gport->height) * ALLOW_ZOOM_OUT_BY;
+  new_zoom = MIN (MAX (min_zoom, new_zoom), max_zoom);
+
+  if (gport->view.coord_per_px == new_zoom)
+    return;
+
+  xtmp = (SIDE_X (center_x) - gport->view.x0) / (double)gport->view.width;
+  ytmp = (SIDE_Y (center_y) - gport->view.y0) / (double)gport->view.height;
+
+  gport->view.coord_per_px = new_zoom;
+  pixel_slop = new_zoom;
+  ghid_port_ranges_scale ();
+
+  gport->view.x0 = SIDE_X (center_x) - xtmp * gport->view.width;
+  gport->view.y0 = SIDE_Y (center_y) - ytmp * gport->view.height;
+
+  pan_common (gport);
+
+  ghid_set_status_line_label ();
+}
+
+void
+ghid_zoom_view_rel (Coord center_x, Coord center_y, double factor)
+{
+  ghid_zoom_view_abs (center_x, center_y, gport->view.coord_per_px * factor);
+}
+
+void
+ghid_zoom_view_fit (void)
+{
+  ghid_pan_view_abs (SIDE_X (0), SIDE_Y (0), 0, 0);
+  ghid_zoom_view_abs (SIDE_X (0), SIDE_Y (0),
+                      MAX (PCB->MaxWidth  / gport->width,
+                           PCB->MaxHeight / gport->height));
+}
+
+void
+ghid_flip_view (Coord center_x, Coord center_y, bool flip_x, bool flip_y)
+{
+  int widget_x, widget_y;
+
+  /* Work out where on the screen the flip point is */
+  ghid_pcb_to_event_coords (center_x, center_y, &widget_x, &widget_y);
+
+  gport->view.flip_x = gport->view.flip_x != flip_x;
+  gport->view.flip_y = gport->view.flip_y != flip_y;
+
+  /* Pan the board so the center location remains in the same place */
+  ghid_pan_view_abs (center_x, center_y, widget_x, widget_y);
+
+  ghid_invalidate_all ();
+}
+
 
 #define LEAD_USER_WIDTH           0.2          /* millimeters */
 #define LEAD_USER_PERIOD          (1000 / 5)   /* 5fps (in ms) */
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index a324708..e192725 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -1302,6 +1302,127 @@ ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y)
   return true;
 }
 
+static void
+pan_common (GHidPort *port)
+{
+  int event_x, event_y;
+
+  /* We need to fix up the PCB coordinates corresponding to the last
+  * event so convert it back to event coordinates temporarily. */
+  ghid_pcb_to_event_coords (gport->pcb_x, gport->pcb_y, &event_x, &event_y);
+
+  /* Don't pan so far the board is completely off the screen */
+  port->view.x0 = MAX (-port->view.width,  port->view.x0);
+  port->view.y0 = MAX (-port->view.height, port->view.y0);
+  port->view.x0 = MIN ( port->view.x0, PCB->MaxWidth);
+  port->view.y0 = MIN ( port->view.y0, PCB->MaxHeight);
+
+  /* Fix up noted event coordinates to match where we clamped. Alternatively
+   * we could call ghid_note_event_location (NULL); to get a new pointer
+   * location, but this costs us an xserver round-trip (on X11 platforms)
+   */
+  ghid_event_to_pcb_coords (event_x, event_y, &gport->pcb_x, &gport->pcb_y);
+
+  ghidgui->adjustment_changed_holdoff = TRUE;
+  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view.x0);
+  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view.y0);
+  ghidgui->adjustment_changed_holdoff = FALSE;
+
+  ghid_port_ranges_changed();
+}
+
+void
+ghid_pan_view_abs (Coord pcb_x, Coord pcb_y, int widget_x, int widget_y)
+{
+  gport->view.x0 = SIDE_X (pcb_x) - widget_x * gport->view.coord_per_px;
+  gport->view.y0 = SIDE_Y (pcb_y) - widget_y * gport->view.coord_per_px;
+
+  pan_common (gport);
+}
+
+void
+ghid_pan_view_rel (Coord dx, Coord dy)
+{
+  gport->view.x0 += dx;
+  gport->view.y0 += dy;
+
+  pan_common (gport);
+}
+
+
+/* gport->view.coord_per_px:
+ * zoom value is PCB units per screen pixel.  Larger numbers mean zooming
+ * out - the largest value means you are looking at the whole board.
+ *
+ * gport->view_width and gport->view_height are in PCB coordinates
+ */
+
+#define ALLOW_ZOOM_OUT_BY 10 /* Arbitrary, and same as the lesstif HID */
+void
+ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
+{
+  double min_zoom, max_zoom;
+  double xtmp, ytmp;
+
+  /* Limit the "minimum" zoom constant (maximum zoom), at 1 pixel per PCB
+   * unit, and set the "maximum" zoom constant (minimum zoom), such that
+   * the entire board just fits inside the viewport
+   */
+  min_zoom = 1;
+  max_zoom = MAX (PCB->MaxWidth  / gport->width,
+                  PCB->MaxHeight / gport->height) * ALLOW_ZOOM_OUT_BY;
+  new_zoom = MIN (MAX (min_zoom, new_zoom), max_zoom);
+
+  if (gport->view.coord_per_px == new_zoom)
+    return;
+
+  xtmp = (SIDE_X (center_x) - gport->view.x0) / (double)gport->view.width;
+  ytmp = (SIDE_Y (center_y) - gport->view.y0) / (double)gport->view.height;
+
+  gport->view.coord_per_px = new_zoom;
+  pixel_slop = new_zoom;
+  ghid_port_ranges_scale ();
+
+  gport->view.x0 = SIDE_X (center_x) - xtmp * gport->view.width;
+  gport->view.y0 = SIDE_Y (center_y) - ytmp * gport->view.height;
+
+  pan_common (gport);
+
+  ghid_set_status_line_label ();
+}
+
+void
+ghid_zoom_view_rel (Coord center_x, Coord center_y, double factor)
+{
+  ghid_zoom_view_abs (center_x, center_y, gport->view.coord_per_px * factor);
+}
+
+void
+ghid_zoom_view_fit (void)
+{
+  ghid_pan_view_abs (SIDE_X (0), SIDE_Y (0), 0, 0);
+  ghid_zoom_view_abs (SIDE_X (0), SIDE_Y (0),
+                      MAX (PCB->MaxWidth  / gport->width,
+                           PCB->MaxHeight / gport->height));
+}
+
+void
+ghid_flip_view (Coord center_x, Coord center_y, bool flip_x, bool flip_y)
+{
+  int widget_x, widget_y;
+
+  /* Work out where on the screen the flip point is */
+  ghid_pcb_to_event_coords (center_x, center_y, &widget_x, &widget_y);
+
+  gport->view.flip_x = gport->view.flip_x != flip_x;
+  gport->view.flip_y = gport->view.flip_y != flip_y;
+
+  /* Pan the board so the center location remains in the same place */
+  ghid_pan_view_abs (center_x, center_y, widget_x, widget_y);
+
+  ghid_invalidate_all ();
+}
+
 
 #define LEAD_USER_WIDTH           0.2          /* millimeters */
 #define LEAD_USER_PERIOD          (1000 / 20)  /* 20fps (in ms) */
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index edc7c79..c20fff7 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -30,127 +30,6 @@
 RCSID ("$Id$");
 
 
-static void
-pan_common (GHidPort *port)
-{
-  int event_x, event_y;
-
-  /* We need to fix up the PCB coordinates corresponding to the last
-  * event so convert it back to event coordinates temporarily. */
-  ghid_pcb_to_event_coords (gport->pcb_x, gport->pcb_y, &event_x, &event_y);
-
-  /* Don't pan so far the board is completely off the screen */
-  port->view.x0 = MAX (-port->view.width,  port->view.x0);
-  port->view.y0 = MAX (-port->view.height, port->view.y0);
-  port->view.x0 = MIN ( port->view.x0, PCB->MaxWidth);
-  port->view.y0 = MIN ( port->view.y0, PCB->MaxHeight);
-
-  /* Fix up noted event coordinates to match where we clamped. Alternatively
-   * we could call ghid_note_event_location (NULL); to get a new pointer
-   * location, but this costs us an xserver round-trip (on X11 platforms)
-   */
-  ghid_event_to_pcb_coords (event_x, event_y, &gport->pcb_x, &gport->pcb_y);
-
-  ghidgui->adjustment_changed_holdoff = TRUE;
-  gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view.x0);
-  gtk_range_set_value (GTK_RANGE (ghidgui->v_range), gport->view.y0);
-  ghidgui->adjustment_changed_holdoff = FALSE;
-
-  ghid_port_ranges_changed();
-}
-
-static void
-ghid_pan_view_abs (Coord pcb_x, Coord pcb_y, int widget_x, int widget_y)
-{
-  gport->view.x0 = SIDE_X (pcb_x) - widget_x * gport->view.coord_per_px;
-  gport->view.y0 = SIDE_Y (pcb_y) - widget_y * gport->view.coord_per_px;
-
-  pan_common (gport);
-}
-
-void
-ghid_pan_view_rel (Coord dx, Coord dy)
-{
-  gport->view.x0 += dx;
-  gport->view.y0 += dy;
-
-  pan_common (gport);
-}
-
-
-/* gport->view.coord_per_px:
- * zoom value is PCB units per screen pixel.  Larger numbers mean zooming
- * out - the largest value means you are looking at the whole board.
- *
- * gport->view_width and gport->view_height are in PCB coordinates
- */
-
-#define ALLOW_ZOOM_OUT_BY 10 /* Arbitrary, and same as the lesstif HID */
-static void
-ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom)
-{
-  double min_zoom, max_zoom;
-  double xtmp, ytmp;
-
-  /* Limit the "minimum" zoom constant (maximum zoom), at 1 pixel per PCB
-   * unit, and set the "maximum" zoom constant (minimum zoom), such that
-   * the entire board just fits inside the viewport
-   */
-  min_zoom = 1;
-  max_zoom = MAX (PCB->MaxWidth  / gport->width,
-                  PCB->MaxHeight / gport->height) * ALLOW_ZOOM_OUT_BY;
-  new_zoom = MIN (MAX (min_zoom, new_zoom), max_zoom);
-
-  if (gport->view.coord_per_px == new_zoom)
-    return;
-
-  xtmp = (SIDE_X (center_x) - gport->view.x0) / (double)gport->view.width;
-  ytmp = (SIDE_Y (center_y) - gport->view.y0) / (double)gport->view.height;
-
-  gport->view.coord_per_px = new_zoom;
-  pixel_slop = new_zoom;
-  ghid_port_ranges_scale ();
-
-  gport->view.x0 = SIDE_X (center_x) - xtmp * gport->view.width;
-  gport->view.y0 = SIDE_Y (center_y) - ytmp * gport->view.height;
-
-  pan_common (gport);
-
-  ghid_set_status_line_label ();
-}
-
-static void
-ghid_zoom_view_rel (Coord center_x, Coord center_y, double factor)
-{
-  ghid_zoom_view_abs (center_x, center_y, gport->view.coord_per_px * factor);
-}
-
-static void
-ghid_zoom_view_fit (void)
-{
-  ghid_pan_view_abs (SIDE_X (0), SIDE_Y (0), 0, 0);
-  ghid_zoom_view_abs (SIDE_X (0), SIDE_Y (0),
-                      MAX (PCB->MaxWidth  / gport->width,
-                           PCB->MaxHeight / gport->height));
-}
-
-static void
-ghid_flip_view (Coord center_x, Coord center_y, bool flip_x, bool flip_y)
-{
-  int widget_x, widget_y;
-
-  /* Work out where on the screen the flip point is */
-  ghid_pcb_to_event_coords (center_x, center_y, &widget_x, &widget_y);
-
-  gport->view.flip_x = gport->view.flip_x != flip_x;
-  gport->view.flip_y = gport->view.flip_y != flip_y;
-
-  /* Pan the board so the center location remains in the same place */
-  ghid_pan_view_abs (center_x, center_y, widget_x, widget_y);
-
-  ghid_invalidate_all ();
-}
-
 /* ------------------------------------------------------------ */
 
 static const char zoom_syntax[] =
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index ea49bee..7caa515 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -503,6 +503,11 @@ void ghid_flush_debug_draw (void);
 void ghid_finish_debug_draw (void);
 bool ghid_event_to_pcb_coords (int event_x, int event_y, Coord *pcb_x, Coord *pcb_y);
 bool ghid_pcb_to_event_coords (Coord pcb_x, Coord pcb_y, int *event_x, int *event_y);
+void ghid_pan_view_abs (Coord pcb_x, Coord pcb_y, int widget_x, int widget_y);
+void ghid_zoom_view_abs (Coord center_x, Coord center_y, double new_zoom);
+void ghid_zoom_view_rel (Coord center_x, Coord center_y, double factor);
+void ghid_zoom_view_fit (void);
+void ghid_flip_view (Coord center_x, Coord center_y, bool flip_x, bool flip_y);
 
 void ghid_lead_user_to_location (Coord x, Coord y);
 void ghid_cancel_lead_user (void);

Bottom: 0476adecbfd9bb34e595321ae3dc46e3414cc617
Top:    9fddb69173a0a10d4cd7464edc4d87623f9c2d01
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-02-10 13:19:56 +0000

Nearly working






---

diff --git a/src/polygon1.c b/src/polygon1.c
index 4b3bd57..d9f0f0b 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -1000,12 +1000,22 @@ cntr_in_M_PLINE (PLINE * poly, PLINE * outfst, BOOLp test)
   return FALSE;
 }				/* cntr_in_M_PLINE */
 
+static int
+count_contours_i_am_inside (const BoxType *b, void *cl)
+{
+  PLINE *me = cl;
+  PLINE *check = (PLINE *) b;
+
+  if (poly_ContourInContour (check, me))
+    return 1;
+  return 0;
+}
+
 /* cntr_in_M_POLYAREA
 returns poly is inside outfst ? TRUE : FALSE */
 static int
 cntr_in_M_POLYAREA (PLINE * poly, POLYAREA * outfst, BOOLp test)
 {
-  PLINE *curc;
   POLYAREA *outer = outfst;
   heap_t *heap;
 
@@ -1015,9 +1025,7 @@ cntr_in_M_POLYAREA (PLINE * poly, POLYAREA * outfst, BOOLp test)
   heap = heap_create ();
   do
     {
-      if (outer->contours == NULL) {
-        printf ("cntr_in_M_POLYAREA: outer->contours was NULL\n");
-      } else if (cntrbox_inside (poly, outer->contours))
+      if (cntrbox_inside (poly, outer->contours))
 	heap_insert (heap, outer->contours->area, (void *) outer);
     }
   /* if checking touching, use only the first polygon */
@@ -1030,19 +1038,20 @@ cntr_in_M_POLYAREA (PLINE * poly, POLYAREA * outfst, BOOLp test)
       if (heap_is_empty (heap))
 	break;
       outer = (POLYAREA *) heap_remove_smallest (heap);
-      if (poly_ContourInContour (outer->contours, poly))
-	{
-	  for (curc = outer->contours->next; curc != NULL; curc = curc->next)
-	    if (poly_ContourInContour (curc, poly))
-	      {
-		/* it's inside a hole in the smallest polygon 
-		 * no need to check the other polygons */
-		heap_destroy (&heap);
-		return FALSE;
-	      }
-	  heap_destroy (&heap);
-	  return TRUE;
-	}
+
+      switch (r_search (outer->contour_tree, (BoxType *)poly, NULL, count_contours_i_am_inside, poly)) {
+        case 0: /* Didn't find anything in this piece, Keep looking */
+          break;
+        case 1: /* Found we are inside this piece, and not any of its holes */
+          heap_destroy (&heap);
+          return TRUE;
+        case 2: /* Found inside a hole in the smallest polygon so far. No need to check the other polygons */
+          heap_destroy (&heap);
+          return FALSE;
+        default:
+          printf ("Something strange here\n");
+          break;
+      }
     }
   while (1);
   heap_destroy (&heap);
@@ -1214,10 +1223,9 @@ static BOOLp
 M_POLYAREA_label_separated (PLINE * afst, POLYAREA * b, BOOLp touch)
 {
   PLINE *curc = afst;
-  int i = 0;
 
   for (curc = afst; curc != NULL; curc = curc->next) {
-    printf ("Testing separated contour %i\n", ++i);
+//    printf ("Labelling separated contour\n");
     if (cntr_label_POLYAREA (curc, b, touch) && touch)
       return TRUE;
   }
@@ -1366,7 +1374,23 @@ PutContour (jmp_buf * e, PLINE * cntr, POLYAREA ** contours, PLINE ** holes,
     }
 }				/* PutContour */
 
-static int
+static inline void
+remove_contour (POLYAREA *piece, PLINE *prev_contour, PLINE *contour,
+                int remove_rtree_entry)
+{
+  if (piece->contours == contour)
+    piece->contours = contour->next;
+
+  if (prev_contour != NULL)
+    prev_contour->next = contour->next;
+
+  contour->next = NULL;
+
+  if (remove_rtree_entry)
+    r_delete_entry (piece->contour_tree, (BoxType *)contour);
+}
+
+  static int
 heap_it (const BoxType * b, void *cl)
 {
   heap_t *heap = (heap_t *) cl;
@@ -1377,6 +1401,32 @@ heap_it (const BoxType * b, void *cl)
   return 1;
 }
 
+struct find_inside_info {
+  jmp_buf jb;
+  PLINE *want_inside;
+  PLINE *result;
+};
+
+static int
+find_inside (const BoxType *b, void *cl)
+{
+  struct find_inside_info *info = cl;
+  PLINE *check = (PLINE *) b;
+  /* Do test on check to see if it inside info->want_inside */
+  /* If it is: */
+//  printf ("find_inside: Checking a possible hole\n");
+  if (check->Flags.orient == PLF_DIR) {
+//    printf ("Think we just got the main contour?\n");
+    return 0;
+  }
+  if (poly_ContourInContour (info->want_inside, check)) {
+//    printf ("find_inside: Found a hole inside the one we're checking\n");
+    info->result = check;
+    longjmp (info->jb, 1);
+  }
+  return 0;
+}
+
 static void
 InsertHoles (jmp_buf * e, POLYAREA * dest, PLINE ** src)
 {
@@ -1462,25 +1512,59 @@ InsertHoles (jmp_buf * e, POLYAREA * dest, PLINE ** src)
 	}
       else
 	{
+#warning WHICH POLYAREA GOT THIS - STUPID LONG SEARCH - STORE IN HEAP STRUCTURE INSTEAD!!
+          curc = dest;
+          do {
+            if (curc->contours == container)
+              break;
+          } while ((curc = curc->f) != dest);
+          if (curc->contours != container) {
+            curc = NULL;
+            printf ("Badness\n");
+          }
+
+          /* Need to check if this new hole means we need to kick out any old ones for reprocessing */
+          while (1) {
+            struct find_inside_info info;
+            PLINE *prev;
+
+            info.want_inside = curh;
+
+            /* Set jump return */
+            if (setjmp (info.jb)) {
+              /* Returned here! */
+            } else {
+              info.result = NULL;
+              /* Rtree search, calling back a routine to longjmp back with data about any hole inside the added one */
+              /*   Be sure not to bother jumping back to report the main contour! */
+              r_search (curc->contour_tree, (BoxType *)curh, NULL, find_inside, &info);
+
+              /* Nothing found? */
+              break;
+            }
+
+            /* We need to find the contour before it, so we can update its next pointer */
+            prev = container;
+            while (prev->next != info.result) {
+              prev = prev->next;
+            }
+
+            /* Remove hole from the contour */
+            remove_contour (curc, prev, info.result, TRUE);
+
+            /* Add hole as the next on the list to be processed in this very function */
+            info.result->next = *src;
+            *src = info.result;
+          }
+          /* End check for kicked out holes */
+
 	  /* link at front of hole list */
 	  tmp = container->next;
 	  container->next = curh;
 	  curh->next = tmp;
+          if (curc != NULL)
+            r_insert_entry (curc->contour_tree, (BoxTypePtr) curh, 0);
 
-#warning WHICH POLYAREA GOT THIS - STUPID LONG SEARCH - STORE IN HEAP STRUCTURE INSTEAD!!
-          curc = dest;
-          do
-            {
-              if (curc->contours == container)
-                break;
-            }
-          while ((curc = curc->f) != dest);
-          if (curc->contours == container)
-            {
-              r_insert_entry (curc->contour_tree, (BoxTypePtr) curh, 0);
-            }
-          else
-            printf ("Badness\n");
 	}
     }
   r_destroy_tree (&tree);
@@ -1777,7 +1861,6 @@ cntr_Collect (jmp_buf * e, PLINE ** A, POLYAREA ** contours, PLINE ** holes,
     }
   else
     {
-      printf ("Got non ISECTED contour in cntr_Collect!\n");
       switch (action)
 	{
 	case PBO_ISECT:
@@ -1913,26 +1996,324 @@ remove_polyarea (POLYAREA **list, POLYAREA *piece)
   piece->f = piece->b = piece;
 }
 
-
-static inline void
-remove_contour (POLYAREA *piece, PLINE *prev_contour, PLINE *contour,
-                int remove_rtree_entry)
+static void
+M_POLYAREA_separate_isected (jmp_buf * e, POLYAREA ** pieces,
+                             PLINE ** holes, PLINE ** isected)
 {
-  if (piece->contours == contour)
-    piece->contours = contour->next;
+  POLYAREA *a = *pieces;
+  POLYAREA *anext;
+  PLINE *curc, *next, *prev;
+  int finished;
 
-  if (prev_contour != NULL)
-    prev_contour->next = contour->next;
+  if (a == NULL) {
+//    printf ("M_POLYAREA_separate_isected: No polygon pieces to play with\n");
+    return;
+  }
 
-  contour->next = NULL;
+  /* TODO: STASH ENOUGH INFORMATION EARLIER ON, SO WE CAN REMOVE THE INTERSECTED
+           CONTOURS WITHOUT HAVING TO WALK THE FULL DATA-STRUCTURE LOOKING FOR THEM. */
 
-  if (remove_rtree_entry)
-    r_delete_entry (piece->contour_tree, (BoxType *)contour);
+  do {
+    int hole_contour = 0;
+    int is_outline = 1;
+
+    anext = a->f;
+    finished = (anext == *pieces);
+
+    prev = NULL;
+    for (curc = a->contours; curc != NULL; curc = next, is_outline = 0) {
+      int is_first = contour_is_first (a, curc);
+      int is_last = contour_is_last (curc);
+      int isect_contour = (curc->Flags.status == ISECTED);
+
+      next = curc->next;
+
+      if (isect_contour || hole_contour) {
+
+        /* Reset the intersection flags, since we keep these pieces */
+        if (curc->Flags.status != ISECTED)
+          curc->Flags.status = UNKNWN;
+
+        remove_contour (a, prev, curc, !(is_first && is_last));
+
+        if (isect_contour) {
+          /* Link into the list of intersected contours */
+          curc->next = *isected;
+          *isected = curc;
+        } else if (hole_contour) {
+//          printf ("Hole contour, perhaps would have been saved the trouble if we mass-evicted children\n");
+          /* Link into the list of holes */
+          curc->next = *holes;
+          *holes = curc;
+        }
+
+        if (is_first && is_last) {
+//          printf ("M_POLYAREA_separate_isected: Deleted / removed the whole polygon piece\n");
+          remove_polyarea (pieces, a);
+          poly_Free (&a); /* NB: Sets a to NULL */
+        }
+
+      } else {
+        /* Note the item we just didn't delete as the next
+           candidate for having its "next" pointer adjusted.
+           Saves walking the contour list when we delete one. */
+        prev = curc;
+      }
+
+      /* If we move or delete an outer contour, we need to move any holes
+         we wish to keep within that contour to the holes list. */
+      if (is_outline && isect_contour)
+        hole_contour = 1;
+
+    }
+
+    /* If we deleted all the pieces of the polyarea, *pieces is NULL */
+  } while ((a = anext), *pieces !=NULL && !finished);
+}
+
+
+struct find_inside_m_pa_info {
+  jmp_buf jb;
+  POLYAREA *want_inside;
+  PLINE *result;
+};
+
+static int
+find_inside_m_pa (const BoxType *b, void *cl)
+{
+  struct find_inside_m_pa_info *info = cl;
+  PLINE *check = (PLINE *) b;
+  /* Don't report for the main contour */
+  if (check->Flags.orient == PLF_DIR)
+    return 0;
+  /* Don't look at contours marked as being intersected */
+  if (check->Flags.status == ISECTED)
+    return 0;
+  if (cntr_in_M_POLYAREA (check, info->want_inside, FALSE)) {
+//    printf ("find_inside_m_pa: Found a hole inside the one we're checking\n");
+    info->result = check;
+    longjmp (info->jb, 1);
+  }
+  return 0;
 }
 
 
 static void
 M_POLYAREA_update_primary (jmp_buf * e, POLYAREA ** pieces,
+                           PLINE ** holes, int action, POLYAREA *bpa)
+{
+  POLYAREA *a = *pieces;
+  POLYAREA *b;
+  POLYAREA *anext;
+  PLINE *curc, *next, *prev;
+  BoxType box;
+  int inv_inside = 0;
+  int del_inside = 0;
+  int del_outside = 0;
+  int finished;
+
+//  printf ("M_POLYAREA_update_primary %p, %p, %i\n", pieces, holes, action);
+
+  if (a == NULL) {
+//    printf ("M_POLYAREA_update_primary: No polygon pieces to play with\n");
+    return;
+  }
+
+  switch (action) {
+    case PBO_ISECT:
+      del_outside = 1;
+      break;
+    case PBO_UNITE:
+      del_inside = 1;
+      break;
+    case PBO_SUB:
+      del_inside = 1;
+      break;
+    case PBO_XOR: /* NOT IMPLEMENTED OR USED */
+      inv_inside = 1;
+      break;
+  }
+
+  box = *((BoxType *)bpa->contours);
+  b = bpa;
+  while ((b = b->f) != bpa) {
+    BoxType *b_box = (BoxType *)b->contours;
+    MAKEMIN (box.X1, b_box->X1);
+    MAKEMIN (box.Y1, b_box->Y1);
+    MAKEMAX (box.X2, b_box->X2);
+    MAKEMAX (box.Y2, b_box->Y2);
+  }
+
+#if 1
+  if (del_inside) {
+
+    do {
+      anext = a->f;
+      finished = (anext == *pieces);
+
+      /* Test the outer contour first, as we may need to remove all children */
+
+      /* We've not yet split intersected contours out, just ignore them */
+      if (a->contours->Flags.status != ISECTED &&
+          /* Pre-filter on bounding box */
+          ((a->contours->xmin >= box.X1) && (a->contours->ymin >= box.Y1) &&
+           (a->contours->xmax <= box.X2) && (a->contours->ymax <= box.Y2)) &&
+          /* Then test properly */
+          cntr_in_M_POLYAREA (a->contours, bpa, FALSE)) {
+
+        /* Delete this contour, all children -> holes queue */
+//        printf ("Outer contour needs to be deleted, and children moved to hole queue\n");
+
+        /* Delete the outer contour */
+        curc = a->contours;
+        remove_contour (a, NULL, curc, FALSE); /* Rtree deleted in poly_Free below */
+        /* a->contours now points to the remaining holes */
+        poly_DelContour (&curc);
+
+        if (a->contours != NULL) {
+          /* Find the end of the list of holes */
+          curc = a->contours;
+          while (curc->next != NULL)
+            curc = curc->next;
+
+          /* Take the holes and prepend to the holes queue */
+          curc->next = *holes;
+          *holes = a->contours;
+          a->contours = NULL;
+        }
+
+        remove_polyarea (pieces, a);
+        poly_Free (&a); /* NB: Sets a to NULL */
+
+        continue;
+      }
+
+      /* Loop whilst we find INSIDE contours to delete */
+      while (1) {
+        struct find_inside_m_pa_info info;
+        PLINE *prev;
+
+        info.want_inside = bpa;
+
+        /* Set jump return */
+        if (setjmp (info.jb)) {
+          /* Returned here! */
+        } else {
+          info.result = NULL;
+          /* Rtree search, calling back a routine to longjmp back with data about any hole inside the B polygon */
+          /*   Be sure not to bother jumping back to report the main contour! */
+          r_search (a->contour_tree, &box, NULL, find_inside_m_pa, &info);
+
+          /* Nothing found? */
+          break;
+        }
+
+        /* We need to find the contour before it, so we can update its next pointer */
+        prev = a->contours;
+        while (prev->next != info.result) {
+          prev = prev->next;
+        }
+
+        /* Remove hole from the contour */
+        remove_contour (a, prev, info.result, TRUE);
+        poly_DelContour (&info.result);
+      }
+      /* End check for deleted holes */
+
+    /* If we deleted all the pieces of the polyarea, *pieces is NULL */
+    } while ((a = anext), *pieces != NULL && !finished);
+
+    return;
+  } else {
+    printf ("Sorry, this isn't optimised for speed.....\n");
+  }
+#endif
+
+  do {
+    int hole_contour = 0;
+    int is_outline = 1;
+
+    anext = a->f;
+    finished = (anext == *pieces);
+
+    prev = NULL;
+    for (curc = a->contours; curc != NULL; curc = next, is_outline = 0) {
+      int is_first = contour_is_first (a, curc);
+      int is_last = contour_is_last (curc);
+
+      int del_contour = 0;
+//      int inv_contour = 0;
+
+      next = curc->next;
+
+#if 0
+      switch (curc->Flags.status) {
+        case ISECTED:
+          printf ("Found intersected contour!! BADNESS\n");
+          break;
+        case INSIDE:
+          if (del_inside) del_contour = 1;
+          if (inv_inside) inv_contour = 1;
+          break;
+        case OUTSIDE:
+          if (del_outside) del_contour = 1;
+          break;
+      }
+#endif
+
+      if (del_outside)
+        del_contour = curc->Flags.status != ISECTED &&
+                     !cntr_in_M_POLYAREA (curc, bpa, FALSE);
+
+      /* Reset the intersection flags, since we keep these pieces */
+      if (curc->Flags.status != ISECTED)
+        curc->Flags.status = UNKNWN;
+
+      if (del_contour || hole_contour) {
+
+        remove_contour (a, prev, curc, !(is_first && is_last));
+
+        if (del_contour) {
+          /* Delete the contour */
+          poly_DelContour (&curc); /* NB: Sets curc to NULL */
+//          printf ("Deleting contour we don't want in the result\n");
+        } else if (hole_contour) {
+          /* Link into the list of holes */
+          curc->next = *holes;
+          *holes = curc;
+//          printf ("Separating a hole (belonging to a moved contour)\n");
+        } else {
+          assert (0);
+        }
+
+        if (is_first && is_last) {
+//          printf ("M_POLYAREA_update_primary: Deleted / removed the whole polygon piece\n");
+          remove_polyarea (pieces, a);
+          poly_Free (&a); /* NB: Sets a to NULL */
+        }
+
+      } else {
+        /* Note the item we just didn't delete as the next
+           candidate for having its "next" pointer adjusted.
+           Saves walking the contour list when we delete one. */
+        prev = curc;
+      }
+
+      /* If we move or delete an outer contour, we need to move any holes
+         we wish to keep within that contour to the holes list. */
+      if (is_outline && del_contour)
+        hole_contour = 1;
+
+    }
+
+  /* If we deleted all the pieces of the polyarea, *pieces is NULL */
+  } while ((a = anext), *pieces != NULL && !finished);
+}
+
+
+
+static void
+M_POLYAREA_update_primary_old (jmp_buf * e, POLYAREA ** pieces,
                            PLINE ** holes, PLINE ** isected, int action)
 {
   POLYAREA *a = *pieces;
@@ -1972,6 +2353,7 @@ M_POLYAREA_update_primary (jmp_buf * e, POLYAREA ** pieces,
   /* now the non-intersect parts are collected in temp/holes */
   do {
     int hole_contour = 0;
+    int is_outline = 1;
 
     anext = a->f;
     finished = (anext == *pieces);
@@ -1979,7 +2361,7 @@ M_POLYAREA_update_primary (jmp_buf * e, POLYAREA ** pieces,
 //    printf ("Inspecting a piece of polygon\n");
 
     prev = NULL;
-    for (curc = a->contours; curc != NULL; curc = next) {
+    for (curc = a->contours; curc != NULL; curc = next, is_outline = 0) {
       int is_first = contour_is_first (a, curc);
       int is_last = contour_is_last (curc);
 
@@ -2044,10 +2426,9 @@ M_POLYAREA_update_primary (jmp_buf * e, POLYAREA ** pieces,
 
       /* If we move or delete an outer contour, we need to move any holes
          we wish to keep within that contour to the holes list. */
-      if (is_first && (del_contour || isect_contour))
+      if (is_outline && (del_contour || isect_contour))
         hole_contour = 1;
 
-      hole_contour = 1;
     }
 
     /* If we deleted all the pieces of the polyarea, *pieces is NULL and
@@ -2223,42 +2604,45 @@ poly_Boolean_free (POLYAREA * ai, POLYAREA * bi, POLYAREA ** res, int action)
       assert (poly_Valid (b));
 #endif
 
+#if 0
+/* SANITY CHECK */
+  {
+  POLYAREA *apa;
+  PLINE *curc;
+
+  apa = a;
+  do {
+    for (curc = apa->contours; curc != NULL; curc = curc->next) {
+      if (curc->Flags.status != UNKNWN) {
+        curc->Flags.status = UNKNWN;
+        printf ("SOMETHING DIDN'T CLEAR THE FLAGS\n");
+      }
+    }
+    /* If we deleted all the pieces of the polyarea, *pieces is NULL */
+  } while ((apa = apa->f) != a);
+  }
+/* END SANITY CHECK */
+#endif
+
       /* intersect needs to make a list of the contours in a and b which are intersected */
       M_POLYAREA_intersect (&e, a, b, TRUE);
 
       /* We could speed things up a lot here if we only processed the relevant contours */
-      M_POLYAREA_label (a, b, FALSE);
+//      M_POLYAREA_label (a, b, FALSE);
       M_POLYAREA_label (b, a, FALSE);
-#if 0
-      M_POLYAREA_label_separated (a_isected, b, FALSE);
-      M_POLYAREA_label_isected (b, a_isected, FALSE);
-#endif
 
-/* New faster method */
-#if 1
       *res = a;
-      M_POLYAREA_update_primary (&e, res, &holes, &a_isected, action);
-      M_POLYAREA_Collect_separated (&e, a_isected, res, &holes, action, FALSE);
-#endif
-
-/* First attempt at go-faster stripes */
-#if 0
-      /* And speed things up _A LOT_ here by only processing the relevant
-         contours, specifically keeping the source "a" as a starting point
-         for the output polygon */
+      M_POLYAREA_update_primary (&e, res, &holes, action, b);
+//      M_POLYAREA_update_primary_old (&e, res, &holes, &a_isected, action);
+      M_POLYAREA_separate_isected (&e, res, &holes, &a_isected);
+      M_POLYAREA_label_separated (a_isected, b, FALSE);
       M_POLYAREA_Collect_separated (&e, a_isected, res, &holes, action, FALSE);
-      M_POLYAREA_Collect (&e, a, res, &holes, action, FALSE);
-      poly_Free (&a);
-#endif
-
-/* Old slow way */
-#if 0
-      M_POLYAREA_Collect (&e, a, res, &holes, action, b->f == b
-			  && !b->contours->next
-			  && b->contours->Flags.status != ISECTED);
-      poly_Free (&a);
-#endif
-
+      /* delete of a_isected which is left */
+      while ((p = a_isected) != NULL)
+      {
+        a_isected = p->next;
+        poly_DelContour (&p);
+      }
       M_B_AREA_Collect (&e, b, res, &holes, action);
       poly_Free (&b);

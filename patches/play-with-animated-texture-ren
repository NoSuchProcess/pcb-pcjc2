Bottom: 9cf7b203d23bc7ff5af8b8cfcca25063eae788b7
Top:    3ced26a6a86a89fb1e36b902fe77065ed8ac582f
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-09-11 23:40:08 +0100

Play with animated texture rendering


---

diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 81c684f..e5ab4af 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -5,6 +5,8 @@
 #endif
 
 #include <stdio.h>
+#include <cairo.h>
+#include <GL/glu.h>
 
 #include "crosshair.h"
 #include "clip.h"
@@ -66,6 +68,9 @@ static int global_view_2d = 1;
 typedef struct render_priv {
   GdkGLConfig *glconfig;
   bool trans_lines;
+  unsigned char *tex_data;
+  GLuint texture;
+  int phase;
 } render_priv;
 
 
@@ -670,7 +675,11 @@ ghid_draw_line (hidGC gc, int x1, int y1, int x2, int y2)
 {
   USE_GC (gc);
 
+  hidgl_flush_triangles (&buffer);
+  glEnable (GL_TEXTURE_2D);
   hidgl_draw_line (gc->cap, gc->width, x1, y1, x2, y2, gport->zoom);
+  hidgl_flush_triangles (&buffer);
+  glDisable (GL_TEXTURE_2D);
 }
 
 void
@@ -966,6 +975,17 @@ ghid_show_crosshair (gboolean show)
   glDisable (GL_COLOR_LOGIC_OP);
 }
 
+gboolean
+animate_timer_cb (gpointer data)
+{
+  render_priv *priv = data;
+
+  priv->phase = (priv->phase + 10) % 64;
+  ghid_invalidate_all ();
+
+  return TRUE;
+}
+
 void
 ghid_init_renderer (int *argc, char ***argv, GHidPort *port)
 {
@@ -985,6 +1005,9 @@ ghid_init_renderer (int *argc, char ***argv, GHidPort *port)
       printf ("Could not setup GL-context!\n");
       return; /* Should we abort? */
     }
+
+  /* Setup a timer to queue refresh when drawing textures */
+  g_timeout_add (200 /*milliseconds*/, animate_timer_cb, priv);
 }
 
 void
@@ -1771,6 +1794,132 @@ ghid_draw_everything (BoxTypePtr drawn_area)
   Settings.ShowSolderSide = save_show_solder;
 }
 
+
+static void render_keepout_texture (render_priv *priv)
+{
+  unsigned int tex_stride;
+  unsigned int tex_width = 64;
+  unsigned int tex_height = 64;
+  unsigned char *cairo_data;
+  int phase = priv->phase;
+  int x, y;
+  cairo_format_t format = CAIRO_FORMAT_RGB24;
+  cairo_surface_t *surface;
+  cairo_t *cr;
+
+  GLfloat tex_matrix[2][4] = {
+    {0.001, 0., 0., 0.},
+    {0., 0.001, 0., 0.}
+  };
+
+  tex_matrix[0][0] = 0.075 / gport->zoom;
+  tex_matrix[1][1] = 0.075 / gport->zoom;
+
+  tex_stride = cairo_format_stride_for_width (format, tex_width);
+  cairo_data = malloc (tex_stride * tex_height);
+  memset (cairo_data, 0, tex_stride * tex_height);
+
+  surface = cairo_image_surface_create_for_data (cairo_data, format,
+                                                 tex_width, tex_height,
+                                                 tex_stride);
+  cr = cairo_create (surface);
+
+//  cairo_set_source_rgb (cr, 1., 1., 1.);
+  cairo_set_source_rgb (cr, 0., 0., 0.);
+  cairo_paint (cr);
+
+//  cairo_set_antialias (cr, CAIRO_ANTIALIAS_NONE);
+
+  cairo_move_to (cr, tex_width, 0);
+  cairo_line_to (cr, 0, tex_height);
+  cairo_move_to (cr, tex_width, 0);
+  cairo_line_to (cr, -tex_width, 2 * tex_height);
+  cairo_move_to (cr, 2 * tex_width, -tex_height);
+  cairo_line_to (cr, 0, tex_height);
+
+  cairo_set_line_cap (cr, CAIRO_LINE_CAP_SQUARE);
+  cairo_set_line_width (cr, 5.0);
+  cairo_set_source_rgb (cr, 1.0, 1.0, 0.);
+  cairo_stroke (cr);
+
+  cairo_move_to (cr, 0 + phase, 0);
+  cairo_line_to (cr, tex_width + phase, tex_height);
+  cairo_move_to (cr, -tex_width + phase, 0);
+  cairo_line_to (cr, tex_width + phase, 2 * tex_height);
+  cairo_move_to (cr, 0 + phase, -tex_height);
+  cairo_line_to (cr, 2 * tex_width + phase, tex_height);
+
+  cairo_set_line_cap (cr, CAIRO_LINE_CAP_SQUARE);
+  cairo_set_line_width (cr, 5.0);
+  cairo_set_source_rgb (cr, 1., 1., 0.);
+  cairo_stroke (cr);
+
+  cairo_destroy (cr);
+  cairo_surface_flush (surface);
+
+  /* Copy out the memory to GL */
+
+  if (priv->tex_data != NULL)
+    free (priv->tex_data);
+  priv->tex_data = malloc (tex_width * tex_height * 3);
+
+  for (y = 0; y < tex_height; y++) {
+    for (x = 0; x < tex_width; x++) {
+      unsigned char *dest = priv->tex_data + 3 * (y * tex_width + x);
+      unsigned char *src = cairo_data + y * tex_stride + 4 * x;
+      dest[0] = src[2]; /* R */
+      dest[1] = src[1]; /* G */
+      dest[2] = src[0]; /* B */
+    }
+  }
+
+  cairo_surface_finish (surface);
+  free (cairo_data);
+
+  /* allocate a texture name */
+  if (priv->texture == 0)
+    glGenTextures (1, &priv->texture);
+
+  /* bind the texture */
+  glBindTexture(GL_TEXTURE_2D, priv->texture);
+
+  /* select modulate to mix texture with color for shading */
+  glTexEnvf (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+  glTexEnvf (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);
+
+  /* when texture area is small, bilinear filter the closest mipmap */
+  glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
+                   GL_LINEAR_MIPMAP_NEAREST);
+  /* when texture area is large, bilinear filter the original */
+  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+
+  /* the texture wraps over at the edges (repeat) */
+  glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
+  glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
+
+#if 0
+  glTexImage2D (GL_TEXTURE_2D, 0, GL_RGB,
+                tex_width, tex_height, 0,
+                GL_RGB, GL_UNSIGNED_BYTE, priv->tex_data);
+#endif
+  gluBuild2DMipmaps (GL_TEXTURE_2D, GL_RGB, tex_width, tex_height,
+                     GL_RGB, GL_UNSIGNED_BYTE, priv->tex_data);
+
+  /* I'm not sure if I can free priv->tex_data or not! */
+  /* free (priv->tex_data); */
+  /* priv->tex_data = NULL; */
+
+  glTexGenf (GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
+  glTexGenf (GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
+
+  glTexGenfv (GL_S, GL_OBJECT_PLANE, tex_matrix[0]);
+  glTexGenfv (GL_T, GL_OBJECT_PLANE, tex_matrix[1]);
+
+  glEnable (GL_TEXTURE_GEN_S);
+  glEnable (GL_TEXTURE_GEN_T);
+//  glEnable (GL_TEXTURE_2D);
+}
+
 #define Z_NEAR 3.0
 gboolean
 ghid_drawing_area_expose_cb (GtkWidget *widget,
@@ -1786,6 +1935,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   int new_x, new_y;
   int min_depth;
   int max_depth;
+  render_priv *priv = port->render_priv;
 
   ghid_start_drawing (port);
 
@@ -1966,10 +2116,12 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
     glEnd ();
   }
 
+  render_keepout_texture (priv);
   // hid_expose_callback (&ghid_hid, &region, 0);
   ghid_draw_everything (&region);
   hidgl_flush_triangles (&buffer);
   glPopMatrix ();
+//  glDisable (GL_TEXTURE_2D);
 
   /* Just prod the drawing code so the current depth gets set to
      the right value for the layer we are editing */

Bottom: fe86731ab91c4ce2fb0ba9d30f33184540508d4e
Top:    1048e4c6bc3ab356fd4762b86a8de39f6dd848dd
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2014-07-04 04:24:35 +0100

Attempt at supporting arc-arc intersections in polygons


---

diff --git a/src/Makefile.am b/src/Makefile.am
index 2947e6e..96a0f66 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -56,6 +56,10 @@ PCB_SRCS = \
 	borast/borast-wideint-type-private.h \
 	change.c \
 	change.h \
+	circle_circle_intersection.c \
+	circle_circle_intersection.h \
+	circle_line_intersection.c \
+	circle_line_intersection.h \
 	clip.c \
 	clip.h \
 	command.c \
diff --git a/src/circle_circle_intersection.c b/src/circle_circle_intersection.c
new file mode 100644
index 0000000..e559bd7
--- /dev/null
+++ b/src/circle_circle_intersection.c
@@ -0,0 +1,118 @@
+/* circle_circle_intersection() *
+ * Determine the points where 2 circles in a common plane intersect.
+ *
+ * int circle_circle_intersection(
+ *                                // center and radius of 1st circle
+ *                                double x0, double y0, double r0,
+ *                                // center and radius of 2nd circle
+ *                                double x1, double y1, double r1,
+ *                                // 1st intersection point
+ *                                double *xi, double *yi,
+ *                                // 2nd intersection point
+ *                                double *xi_prime, double *yi_prime)
+ *
+ * This is a public domain work. 3/26/2005 Tim Voght
+ *
+ * Distinct return code for the single intersection case added by Peter Clifton 2014-07-05
+ *
+ */
+#include <stdio.h>
+#include <math.h>
+
+#define EPSILON (1e-8)
+
+
+int circle_circle_intersection(double x0, double y0, double r0,
+                               double x1, double y1, double r1,
+                               double *xi, double *yi,
+                               double *xi_prime, double *yi_prime)
+{
+  double a, dx, dy, d, h, rx, ry;
+  double x2, y2;
+
+  /* dx and dy are the vertical and horizontal distances between
+   * the circle centers.
+   */
+  dx = x1 - x0;
+  dy = y1 - y0;
+
+  /* Determine the straight-line distance between the centers. */
+  //d = sqrt((dy*dy) + (dx*dx));
+  d = hypot(dx,dy); // Suggested by Keith Briggs
+
+  /* Check for solvability. */
+  if (d > (r0 + r1))
+  {
+    /* no solution. circles do not intersect. */
+    return 0;
+  }
+  if (d < fabs(r0 - r1))
+  {
+    /* no solution. one circle is contained in the other */
+    return 0;
+  }
+
+  /* 'point 2' is the point where the line through the circle
+   * intersection points crosses the line between the circle
+   * centers.
+   */
+
+  /* Determine the distance from point 0 to point 2. */
+  a = ((r0*r0) - (r1*r1) + (d*d)) / (2.0 * d) ;
+
+  /* Determine the coordinates of point 2. */
+  x2 = x0 + (dx * a/d);
+  y2 = y0 + (dy * a/d);
+
+  /* Determine the distance from point 2 to either of the
+   * intersection points.
+   */
+  h = sqrt((r0*r0) - (a*a));
+
+  /* Now determine the offsets of the intersection points from
+   * point 2.
+   */
+  rx = -dy * (h/d);
+  ry = dx * (h/d);
+
+  /* Determine the absolute intersection points. */
+  *xi = x2 + rx;
+  *yi = y2 + ry;
+
+  if (fabs(h) < EPSILON)
+    return 1;
+
+  *xi_prime = x2 - rx;
+  *yi_prime = y2 - ry;
+
+  return 2;
+}
+
+#undef TEST
+
+#ifdef TEST
+
+void run_test(double x0, double y0, double r0,
+              double x1, double y1, double r1)
+{
+  double x3, y3, x3_prime, y3_prime;
+
+  printf("x0=%F, y0=%F, r0=%F, x1=%F, y1=%F, r1=%F :\n",
+          x0, y0, r0, x1, y1, r1);
+  circle_circle_intersection(x0, y0, r0, x1, y1, r1,
+                             &x3, &y3, &x3_prime, &y3_prime);
+  printf("  x3=%F, y3=%F, x3_prime=%F, y3_prime=%F\n",
+            x3, y3, x3_prime, y3_prime);
+}
+
+int main(void)
+{
+  /* Add more! */
+  run_test(-1.0, -1.0, 1.5, 1.0, 1.0, 2.0);
+  run_test(1.0, -1.0, 1.5, -1.0, 1.0, 2.0);
+  run_test(-1.0, 1.0, 1.5, 1.0, -1.0, 2.0);
+  run_test(1.0, 1.0, 1.5, -1.0, -1.0, 2.0);
+  exit(0);
+}
+#endif
+
diff --git a/src/circle_circle_intersection.h b/src/circle_circle_intersection.h
new file mode 100644
index 0000000..2ca064c
--- /dev/null
+++ b/src/circle_circle_intersection.h
@@ -0,0 +1,4 @@
+int circle_circle_intersection(double x0, double y0, double r0,
+                               double x1, double y1, double r1,
+                               double *xi, double *yi,
+                               double *xi_prime, double *yi_prime);
diff --git a/src/circle_line_intersection.c b/src/circle_line_intersection.c
new file mode 100644
index 0000000..d934594
--- /dev/null
+++ b/src/circle_line_intersection.c
@@ -0,0 +1,51 @@
+/* Based on raysphere.c from:
+ * http://paulbourke.net/geometry/circlesphere/index.html#linesphere
+ *
+ * Converted to PCB coordinate types, and line/circle intersection in 2D
+ * by Peter Clifton 2014-07-05
+ */
+
+
+/*
+ * Calculate the intersection of a ray and a sphere
+ * The line segment is defined from p1 to p2
+ * The sphere is of radius r and centered at sc
+ * There are potentially two points of intersection given by
+ * p = p1 + mu1 (p2 - p1)
+ * p = p1 + mu2 (p2 - p1)
+ *
+ * Return 0 if the ray doesn't intersect the circle.
+ * Return 1 if the ray touches the circle at a single point.
+ * Return 2 if the ray intersects the circle.
+ */
+int
+circle_line_intersect (double cx, double cy, double r, double p1x, double p1y, double p2x, double p2y,
+                       double *mu1, double *mu2)
+{
+   double a,b,c;
+   double bb4ac;
+   double dpx;
+   double dpy;
+   double dpz;
+
+   dpx = p2x - p1x;
+   dpy = p2y - p1y;
+   dpz = p2.z - p1.z;
+   a = dp.x * dp.x + dp.y * dp.y + dp.z * dp.z;
+   b = 2 * (dp.x * (p1x - sc.x) + dp.y * (p1y - sc.y) + dp.z * (p1.z - sc.z));
+   c = sc.x * sc.x + sc.y * sc.y + sc.z * sc.z;
+   c += p1x * p1x + p1y * p1y + p1.z * p1.z;
+   c -= 2 * (sc.x * p1x + sc.y * p1y + sc.z * p1.z);
+   c -= r * r;
+   bb4ac = b * b - 4 * a * c;
+   if (ABS(a) < EPS || bb4ac < 0) {
+      *mu1 = 0;
+      *mu2 = 0;
+      return(FALSE);
+   }
+
+   *mu1 = (-b + sqrt(bb4ac)) / (2 * a);
+   *mu2 = (-b - sqrt(bb4ac)) / (2 * a);
+
+   return 2;
+}
diff --git a/src/circle_line_intersection.h b/src/circle_line_intersection.h
new file mode 100644
index 0000000..c7920d2
--- /dev/null
+++ b/src/circle_line_intersection.h
@@ -0,0 +1,3 @@
+int circle_line_intersect (double cx, double cy, double r,
+                           double p1x, double p1y, double p2x, double p2y,
+                           double *mu1, double *mu2);
diff --git a/src/polygon1.c b/src/polygon1.c
index 9157eb4..3500c2f 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -50,6 +50,7 @@
 #include "rtree.h"
 #include "heap.h"
 #include "pcb-printf.h"
+#include "misc.h"
 
 #define ROUND(a) (long)((a) > 0 ? ((a) + 0.5) : ((a) - 0.5))
 
@@ -218,12 +219,11 @@ node_add_single (VNODE * dest, Vector po)
 {
   VNODE *p;
 
-/* XXX: MAY NOT BE CORRECT IF WE NEED TO SEPARATE STRAIGHT AND CURVED SEGMENTS */
   if (vect_equal (po, dest->point))
     return dest;
   if (vect_equal (po, dest->next->point))
     return dest->next;
-  p = poly_CreateNode (po);
+  p = poly_CreateNodeFull (po, dest->is_round, dest->cx, dest->cy, dest->radius);
   if (p == NULL)
     return NULL;
   p->cvc_prev = p->cvc_next = NULL;
@@ -635,6 +635,83 @@ prepend_insert_node_task (insert_node_task *list, seg *seg, VNODE *new_node)
   return task;
 }
 
+static bool
+insert_vertex_in_seg (struct info *i, struct seg *s, Vector v)
+{
+  VNODE *new_node = node_add_single_point (s->v, v);
+  if (new_node == NULL)
+    return false;
+
+#ifdef DEBUG_INTERSECT
+  DEBUGP ("new intersection on segment \"i\" at %#mD\n", v[0], v[1]);
+#endif
+  i->node_insert_list = prepend_insert_node_task (i->node_insert_list, s, new_node);
+  s->intersected = 1;
+  return true;
+}
+
+static int
+seg_in_seg_line_line (struct info *i, struct seg *s1, struct seg *s2)
+{
+  Vector v1, v2;
+  int cnt;
+
+  cnt = vect_inters2 (s1->v->point, s1->v->next->point,
+                      s2->v->point, s2->v->next->point, v1, v2);
+  if (!cnt)
+    return 0;
+
+  if (i->touch)  /* if checking touches one find and we're done */
+    longjmp (*i->touch, TOUCHES);
+
+  /* Mark the contour PLINEs as intersected */
+  s1->p->Flags.status = ISECTED;
+  s2->p->Flags.status = ISECTED;
+
+  for (; cnt; cnt--)
+    {
+      bool done_insert_on_s1 = insert_vertex_in_seg (i, s2, cnt > 1 ? v2 : v1);
+      bool done_insert_on_s2 = insert_vertex_in_seg (i, s1, cnt > 1 ? v2 : v1);
+
+      /* Skip any remaining r_search hits against segment i, as any futher
+       * intersections will be rejected until the next pass anyway.
+       */
+      if ((done_insert_on_s1 && s1 == i->s) ||
+          (done_insert_on_s2 && s2 == i->s))
+        longjmp (*i->env, 1);
+
+      /* If we inserted on s (but not i), skip return now, as we can't continue with
+       * the for-loop iteration if we modified geoemtry
+       */
+      if (done_insert_on_s1 || done_insert_on_s2)
+        return 0;
+    }
+
+  return 0;
+}
+
+static int
+seg_in_seg_arc_line (struct info *i, struct seg *s1, struct seg *s2)
+{
+  assert (s1->v->is_round);
+  assert (!s2->v->is_round);
+
+//  printf ("Querying arc-line intersection\n");
+  /* COP OUT */
+  return seg_in_seg_line_line (i, s1, s2);
+}
+
+static int
+seg_in_seg_arc_arc (struct info *i, struct seg *s1, struct seg *s2)
+{
+  assert (s1->v->is_round);
+  assert (s2->v->is_round);
+
+//  printf ("Querying arc-arc intersection\n");
+  /* COP OUT */
+  return seg_in_seg_line_line (i, s1, s2);
+}
+
 /*
  * seg_in_seg()
  * (C) 2006 harry eaton
@@ -650,60 +727,24 @@ static int
 seg_in_seg (const BoxType * b, void *cl)
 {
   struct info *i = (struct info *) cl;
-  struct seg *s = (struct seg *) b;
-  Vector s1, s2;
-  int cnt;
-  VNODE *new_node;
+  struct seg *s1 = (struct seg *) b;
+  struct seg *s2 = i->s;
 
   /* When new nodes are added at the end of a pass due to an intersection
    * the segments may be altered. If either segment we're looking at has
    * already been intersected this pass, skip it until the next pass.
    */
-  if (s->intersected || i->s->intersected)
+  if (s1->intersected || s2->intersected)
     return 0;
 
-  cnt = vect_inters2 (s->v->point, s->v->next->point,
-		      i->v->point, i->v->next->point, s1, s2);
-  if (!cnt)
-    return 0;
-  if (i->touch)			/* if checking touches one find and we're done */
-    longjmp (*i->touch, TOUCHES);
-  i->s->p->Flags.status = ISECTED;
-  s->p->Flags.status = ISECTED;
-  for (; cnt; cnt--)
-    {
-      bool done_insert_on_i = false;
-      new_node = node_add_single_point (i->v, cnt > 1 ? s2 : s1);
-      if (new_node != NULL)
-	{
-#ifdef DEBUG_INTERSECT
-	  DEBUGP ("new intersection on segment \"i\" at %#mD\n",
-	          cnt > 1 ? s2[0] : s1[0], cnt > 1 ? s2[1] : s1[1]);
-#endif
-	  i->node_insert_list =
-	    prepend_insert_node_task (i->node_insert_list, i->s, new_node);
-	  i->s->intersected = 1;
-	  done_insert_on_i = true;
-	}
-      new_node = node_add_single_point (s->v, cnt > 1 ? s2 : s1);
-      if (new_node != NULL)
-	{
-#ifdef DEBUG_INTERSECT
-	  DEBUGP ("new intersection on segment \"s\" at %#mD\n",
-	          cnt > 1 ? s2[0] : s1[0], cnt > 1 ? s2[1] : s1[1]);
-#endif
-	  i->node_insert_list =
-	    prepend_insert_node_task (i->node_insert_list, s, new_node);
-	  s->intersected = 1;
-	  return 0; /* Keep looking for intersections with segment "i" */
-	}
-      /* Skip any remaining r_search hits against segment i, as any futher
-       * intersections will be rejected until the next pass anyway.
-       */
-      if (done_insert_on_i)
-	longjmp (*i->env, 1);
-    }
-  return 0;
+  if (s1->v->is_round && s2->v->is_round)
+    return seg_in_seg_arc_arc (i, s1, s2);
+  else if (s1->v->is_round)
+    return seg_in_seg_arc_line (i, s1, s2);
+  else if (s2->v->is_round)
+    return seg_in_seg_arc_line (i, s2, s1);
+  else
+    return seg_in_seg_line_line (i, s1, s2);
 }
 
 static void *
@@ -717,26 +758,36 @@ make_edge_tree (PLINE * pb)
     {
       s = (seg *)malloc (sizeof (struct seg));
       s->intersected = 0;
-      if (bv->point[0] < bv->next->point[0])
-	{
-	  s->box.X1 = bv->point[0];
-	  s->box.X2 = bv->next->point[0] + 1;
-	}
-      else
-	{
-	  s->box.X2 = bv->point[0] + 1;
-	  s->box.X1 = bv->next->point[0];
-	}
-      if (bv->point[1] < bv->next->point[1])
-	{
-	  s->box.Y1 = bv->point[1];
-	  s->box.Y2 = bv->next->point[1] + 1;
-	}
-      else
-	{
-	  s->box.Y2 = bv->point[1] + 1;
-	  s->box.Y1 = bv->next->point[1];
-	}
+
+      s->box.X1 = MIN (bv->point[0], bv->next->point[0]);
+      s->box.X2 = MAX (bv->point[0], bv->next->point[0]) + 1;
+      s->box.Y1 = MIN (bv->point[1], bv->next->point[1]);
+      s->box.Y2 = MAX (bv->point[1], bv->next->point[1]) + 1;
+
+      if (bv->is_round)
+        {
+          Angle start_angle;
+          Angle end_angle;
+          Angle delta_angle;
+          BoxType arc_bound;
+
+          start_angle = atan2 ((      bv->point[1] -       bv->cy), -(      bv->point[0] -       bv->cx)) / M180;
+          end_angle   = atan2 ((bv->next->point[1] - bv->next->cy), -(bv->next->point[0] - bv->next->cx)) / M180;
+
+#warning delta angle calculation looks rather suspect - wont work for arcs > 180 degrees span
+          delta_angle = end_angle - start_angle;
+
+          if (delta_angle > 180.) delta_angle -= 360.;
+          if (delta_angle < -180.) delta_angle += 360.;
+
+          arc_bound = calc_thin_arc_bounds (bv->cx, bv->cy, bv->radius, bv->radius, start_angle, delta_angle);
+
+          MAKEMIN (s->box.X1, arc_bound.X1);
+          MAKEMIN (s->box.Y1, arc_bound.Y1);
+          MAKEMAX (s->box.X2, arc_bound.X2);
+          MAKEMAX (s->box.Y2, arc_bound.Y2);
+        }
+
       s->v = bv;
       s->p = pb;
       r_insert_entry (ans, (const BoxType *) s, 1);
@@ -915,10 +966,6 @@ intersect_impl (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
     {
       insert_node_task *next = task->next;
 
-      /* XXX: If a node was inserted due to an intersection, don't assume we're on the a round contour any more */
-      task->node_seg->v->is_round = false;
-//      task->node_seg->v->next->is_round = false;
-
       /* Do insersion */
       task->new_node->prev = task->node_seg->v;
       task->new_node->next = task->node_seg->v->next;
@@ -2656,7 +2703,7 @@ poly_PreContour (PLINE * C, BOOLp optimize)
 {
   double area = 0;
   VNODE *p, *c;
-  Vector p1, p2;
+//  Vector p1, p2;
 
   assert (C != NULL);
 
@@ -2665,15 +2712,17 @@ poly_PreContour (PLINE * C, BOOLp optimize)
       for (c = (p = &C->head)->next; c != &C->head; c = (p = c)->next)
 	{
 	  /* if the previous node is on the same line with this one, we should remove it */
-	  Vsub2 (p1, c->point, p->point);
-	  Vsub2 (p2, c->next->point, c->point);
+//	  Vsub2 (p1, c->point, p->point);
+//	  Vsub2 (p2, c->next->point, c->point);
 	  /* If the product below is zero then
 	   * the points on either side of c 
 	   * are on the same line!
 	   * So, remove the point c
 	   */
 
-	  if (vect_det2 (p1, p2) == 0)
+#warning BROKEN FOR CIRCULAR CONTOURS
+//	  if (vect_det2 (p1, p2) == 0)
+          if (0)
 	    {
 	      poly_ExclVertex (c);
 	      free (c);
@@ -3364,6 +3413,7 @@ poly_ChkContour (PLINE * a)
       a2 = a1;
       do
 	{
+#warning THIS DOES NOT TAKE INTO ACCOUNT arc-arc and arc-line segments
 	  if (!node_neighbours (a1, a2) &&
 	      (icnt = vect_inters2 (a1->point, a1->next->point,
 				    a2->point, a2->next->point, i1, i2)) > 0)

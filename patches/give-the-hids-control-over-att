Bottom: 74343b0d47e95e96d812434a2074a779487bae94
Top:    1bdbe7cb0935905c2370f7a095564b4943734058
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-04-06 01:47:11 +0100

Give the HIDs control over "attached" object redrawing (crosshair etc..)

This is required if the HID doesn't want to follow the current drawing
model where it is assumed the core can call the HID's drawing APIs at
any arbitrary point in time.

Expose some API from crosshair.c to perform the actual drawing on
demand, and add a hook to the HID structure to notify the GUI when
it would previously have called the drawing routines directly.

This allows GUIs which have defined setup and tear-down requirements
around drawing to execute them before the objects are drawn.


---

diff --git a/src/action.c b/src/action.c
index e5a463f..a0577e4 100644
--- a/src/action.c
+++ b/src/action.c
@@ -607,7 +607,7 @@ click_cb (hidval hv)
 {
   if (Note.Click)
     {
-      HideCrosshair ();
+      notify_crosshair_change (false);
       Note.Click = false;
       if (Note.Moving && !gui->shift_is_pressed ())
 	{
@@ -650,7 +650,7 @@ click_cb (hidval hv)
 	  Crosshair.AttachedBox.Point1.X = Note.X;
 	  Crosshair.AttachedBox.Point1.Y = Note.Y;
 	}
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
     }
 }
 
@@ -945,7 +945,7 @@ NotifyLine (void)
 static void
 NotifyBlock (void)
 {
-  HideCrosshair ();
+  notify_crosshair_change (false);
   switch (Crosshair.AttachedBox.State)
     {
     case STATE_FIRST:		/* setup first point */
@@ -960,7 +960,7 @@ NotifyBlock (void)
       Crosshair.AttachedBox.State = STATE_THIRD;
       break;
     }
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
 }
 
 
@@ -2122,11 +2122,11 @@ ActionMovePointer (char *deltax, char *deltay)
   /* restore crosshair for erasure */
   Crosshair.X = x;
   Crosshair.Y = y;
-  HideCrosshair ();
+  notify_crosshair_change (false);
   MoveCrosshairRelative (TO_SCREEN_SIGN_X (dx), TO_SCREEN_SIGN_Y (dy));
   /* update object position and cursor location */
   AdjustAttachedObjects ();
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
 }
 
 /* ---------------------------------------------------------------------------
@@ -2152,10 +2152,9 @@ EventMoveCrosshair (int ev_x, int ev_y)
     {
       if (MoveCrosshairAbsolute (ev_x, ev_y))
 	{
-
 	  /* update object position and cursor location */
 	  AdjustAttachedObjects ();
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	}
     }
   else
@@ -2731,7 +2730,7 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 	  break;
 
 	case F_CycleClip:
-	  HideCrosshair ();
+	  notify_crosshair_change (false);
 	  if TEST_FLAG
 	    (ALLDIRECTIONFLAG, PCB)
 	    {
@@ -2741,27 +2740,27 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 	  else
 	    PCB->Clipping = (PCB->Clipping + 1) % 3;
 	  AdjustAttachedObjects ();
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  break;
 
 	case F_CycleCrosshair:
-	  HideCrosshair ();
+	  notify_crosshair_change (false);
 	  Crosshair.shape = CrosshairShapeIncrement(Crosshair.shape);
 	  if (Crosshair_Shapes_Number == Crosshair.shape)
 	    Crosshair.shape = Basic_Crosshair_Shape;
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  break;
 
 	case F_ToggleRubberBandMode:
-	  HideCrosshair ();
+	  notify_crosshair_change (false);
 	  TOGGLE_FLAG (RUBBERBANDFLAG, PCB);
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  break;
 
 	case F_ToggleStartDirection:
-	  HideCrosshair ();
+	  notify_crosshair_change (false);
 	  TOGGLE_FLAG (SWAPSTARTDIRFLAG, PCB);
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  break;
 
 	case F_ToggleUniqueNames:
@@ -2769,9 +2768,9 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 	  break;
 
 	case F_ToggleSnapPin:
-	  HideCrosshair ();
+	  notify_crosshair_change (false);
 	  TOGGLE_FLAG (SNAPPINFLAG, PCB);
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  break;
 
 	case F_ToggleLocalRef:
@@ -2812,7 +2811,7 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 	  break;
 
 	case F_ToggleAutoDRC:
-	  HideCrosshair ();
+	  notify_crosshair_change (false);
 	  TOGGLE_FLAG (AUTODRCFLAG, PCB);
 	  if (TEST_FLAG (AUTODRCFLAG, PCB) && Settings.Mode == LINE_MODE)
 	    {
@@ -2826,7 +2825,7 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 				  Crosshair.AttachedLine.Point1.Y, true, 1,
 				  FOUNDFLAG);
 	    }
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  break;
 
 	case F_ToggleCheckPlanes:
@@ -2864,7 +2863,7 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 	    oldGrid = PCB->Grid;
 	    PCB->Grid = 1.0;
 	    if (MoveCrosshairAbsolute (Crosshair.X, Crosshair.Y))
-	      RestoreCrosshair ();	/* was hidden by MoveCrosshairAbs */
+	      notify_crosshair_change (true);	/* first notify was in MoveCrosshairAbs */
 	    SetGrid (oldGrid, true);
 	  }
 	  break;
@@ -3068,7 +3067,7 @@ ActionMode (int argc, char **argv, int x, int y)
     {
       Note.X = Crosshair.X;
       Note.Y = Crosshair.Y;
-      HideCrosshair ();
+      notify_crosshair_change (false);
       switch (GetFunctionID (function))
 	{
 	case F_Arc:
@@ -3264,7 +3263,7 @@ ActionMode (int argc, char **argv, int x, int y)
 	  SaveMode ();
 	  break;
 	}
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
       return 0;
     }
 
@@ -4039,24 +4038,27 @@ ActionMarkCrosshair (int argc, char **argv, int x, int y)
     {
       if (Marked.status)
 	{
-	  DrawMark ();
+	  notify_mark_change (false);
 	  Marked.status = false;
+	  notify_mark_change (true);
 	}
       else
 	{
+	  notify_mark_change (false);
+	  Marked.status = false;
 	  Marked.status = true;
 	  Marked.X = Crosshair.X;
 	  Marked.Y = Crosshair.Y;
-	  DrawMark ();
+	  notify_mark_change (true);
 	}
     }
   else if (GetFunctionID (function) == F_Center)
     {
-      DrawMark ();
+      notify_mark_change (false);
       Marked.status = true;
       Marked.X = Crosshair.X;
       Marked.Y = Crosshair.Y;
-      DrawMark ();
+      notify_mark_change (true);
     }
   return 0;
 }
@@ -5450,7 +5452,7 @@ ActionSelect (int argc, char **argv, int x, int y)
 			  Crosshair.AttachedBox.Point2.X);
 	    box.Y2 = MAX (Crosshair.AttachedBox.Point1.Y,
 			  Crosshair.AttachedBox.Point2.Y);
-	    HideCrosshair ();
+	    notify_crosshair_change (false);
 	    NotifyBlock ();
 	    if (Crosshair.AttachedBox.State == STATE_THIRD &&
 		SelectBlock (&box, true))
@@ -5458,7 +5460,7 @@ ActionSelect (int argc, char **argv, int x, int y)
 		SetChangedFlag (true);
 		Crosshair.AttachedBox.State = STATE_FIRST;
 	      }
-	    RestoreCrosshair ();
+	    notify_crosshair_change (true);
 	    break;
 	  }
 
@@ -5629,7 +5631,7 @@ ActionUnselect (int argc, char **argv, int x, int y)
 			  Crosshair.AttachedBox.Point2.X);
 	    box.Y2 = MAX (Crosshair.AttachedBox.Point1.Y,
 			  Crosshair.AttachedBox.Point2.Y);
-	    HideCrosshair ();
+	    notify_crosshair_change (false);
 	    NotifyBlock ();
 	    if (Crosshair.AttachedBox.State == STATE_THIRD &&
 		SelectBlock (&box, false))
@@ -5637,7 +5639,7 @@ ActionUnselect (int argc, char **argv, int x, int y)
 		SetChangedFlag (true);
 		Crosshair.AttachedBox.State = STATE_FIRST;
 	      }
-	    RestoreCrosshair ();
+	    notify_crosshair_change (true);
 	    break;
 	  }
 
@@ -5868,18 +5870,18 @@ ActionLoadFrom (int argc, char **argv, int x, int y)
 
   if (strcasecmp (function, "ElementToBuffer") == 0)
     {
-      HideCrosshair ();
+      notify_crosshair_change (false);
       if (LoadElementToBuffer (PASTEBUFFER, name, true))
 	SetMode (PASTEBUFFER_MODE);
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
     }
 
   else if (strcasecmp (function, "LayoutToBuffer") == 0)
     {
-      HideCrosshair ();
+      notify_crosshair_change (false);
       if (LoadLayoutToBuffer (PASTEBUFFER, name))
 	SetMode (PASTEBUFFER_MODE);
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
     }
 
   else if (strcasecmp (function, "Layout") == 0)
@@ -5936,7 +5938,7 @@ ActionNew (int argc, char **argv, int x, int y)
       if (!name)
         return 1;
 
-      HideCrosshair ();
+      notify_crosshair_change (false);
       /* do emergency saving
        * clear the old struct and allocate memory for the new one
        */
@@ -5958,7 +5960,7 @@ ActionNew (int argc, char **argv, int x, int y)
       ClearAndRedrawOutput ();
 
       hid_action ("PCBChanged");
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
       return 0;
     }
   return 1;
@@ -6045,7 +6047,7 @@ ActionPasteBuffer (int argc, char **argv, int x, int y)
   static char *default_file = NULL;
   int free_name = 0;
 
-  HideCrosshair ();
+  notify_crosshair_change (true);
   if (function)
     {
       switch (GetFunctionID (function))
@@ -6152,7 +6154,7 @@ ActionPasteBuffer (int argc, char **argv, int x, int y)
 	      }
 	    else
 	      {
-		RestoreCrosshair ();
+		notify_crosshair_change (false);
 		AFAIL (pastebuffer);
 	      }
 
@@ -6175,7 +6177,7 @@ ActionPasteBuffer (int argc, char **argv, int x, int y)
 	}
     }
 
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   return 0;
 }
 
@@ -6216,13 +6218,13 @@ ActionUndo (int argc, char **argv, int x, int y)
 	return 1;
       /* undo the last operation */
 
-      HideCrosshair ();
+      notify_crosshair_change (false);
       if ((Settings.Mode == POLYGON_MODE ||
            Settings.Mode == POLYGONHOLE_MODE) &&
           Crosshair.AttachedPolygon.PointN)
 	{
 	  GoToPreviousPoint ();
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  return 0;
 	}
       /* move anchor point if undoing during line creation */
@@ -6234,7 +6236,7 @@ ActionUndo (int argc, char **argv, int x, int y)
 		Undo (true);	/* undo the connection find */
 	      Crosshair.AttachedLine.State = STATE_FIRST;
 	      SetLocalRef (0, 0, false);
-	      RestoreCrosshair ();
+	      notify_crosshair_change (true);
 	      return 0;
 	    }
 	  if (Crosshair.AttachedLine.State == STATE_THIRD)
@@ -6262,7 +6264,7 @@ ActionUndo (int argc, char **argv, int x, int y)
 		    Crosshair.AttachedLine.Point1.X;
 		  Crosshair.AttachedLine.Point2.Y =
 		    Crosshair.AttachedLine.Point1.Y;
-		  RestoreCrosshair ();
+		  notify_crosshair_change (true);
 		  return 0;
 		}
 	      /* move to new anchor */
@@ -6309,7 +6311,7 @@ ActionUndo (int argc, char **argv, int x, int y)
 		  ptr2 = (LineTypePtr) ptrtmp;
 		  lastLayer = (LayerTypePtr) ptr1;
 		}
-	      RestoreCrosshair ();
+	      notify_crosshair_change (true);
 	      return 0;
 	    }
 	}
@@ -6318,7 +6320,7 @@ ActionUndo (int argc, char **argv, int x, int y)
 	  if (Crosshair.AttachedBox.State == STATE_SECOND)
 	    {
 	      Crosshair.AttachedBox.State = STATE_FIRST;
-	      RestoreCrosshair ();
+	      notify_crosshair_change (true);
 	      return 0;
 	    }
 	  if (Crosshair.AttachedBox.State == STATE_THIRD)
@@ -6353,7 +6355,7 @@ ActionUndo (int argc, char **argv, int x, int y)
 	  break;
 	}
     }
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   return 0;
 }
 
@@ -6386,7 +6388,7 @@ ActionRedo (int argc, char **argv, int x, int y)
        Crosshair.AttachedPolygon.PointN) ||
       Crosshair.AttachedLine.State == STATE_SECOND)
     return 1;
-  HideCrosshair ();
+  notify_crosshair_change (false);
   if (Redo (true))
     {
       SetChangedFlag (true);
@@ -6401,7 +6403,7 @@ ActionRedo (int argc, char **argv, int x, int y)
 	  addedLines++;
 	}
     }
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   return 0;
 }
 
@@ -6435,7 +6437,7 @@ ActionPolygon (int argc, char **argv, int x, int y)
   char *function = ARG (0);
   if (function && Settings.Mode == POLYGON_MODE)
     {
-      HideCrosshair ();
+      notify_crosshair_change (false);
       switch (GetFunctionID (function))
 	{
 	  /* close open polygon if possible */
@@ -6448,7 +6450,7 @@ ActionPolygon (int argc, char **argv, int x, int y)
 	  GoToPreviousPoint ();
 	  break;
 	}
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
     }
   return 0;
 }
@@ -6612,24 +6614,24 @@ ActionSetSame (int argc, char **argv, int x, int y)
   switch (type)
     {
     case LINE_TYPE:
-      HideCrosshair ();
+      notify_crosshair_change (false);
       Settings.LineThickness = ((LineTypePtr) ptr2)->Thickness;
       Settings.Keepaway = ((LineTypePtr) ptr2)->Clearance / 2;
       layer = (LayerTypePtr) ptr1;
       if (Settings.Mode != LINE_MODE)
 	SetMode (LINE_MODE);
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
       hid_action ("RouteStylesChanged");
       break;
 
     case ARC_TYPE:
-      HideCrosshair ();
+      notify_crosshair_change (false);
       Settings.LineThickness = ((ArcTypePtr) ptr2)->Thickness;
       Settings.Keepaway = ((ArcTypePtr) ptr2)->Clearance / 2;
       layer = (LayerTypePtr) ptr1;
       if (Settings.Mode != ARC_MODE)
 	SetMode (ARC_MODE);
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
       hid_action ("RouteStylesChanged");
       break;
 
@@ -6638,13 +6640,13 @@ ActionSetSame (int argc, char **argv, int x, int y)
       break;
 
     case VIA_TYPE:
-      HideCrosshair ();
+      notify_crosshair_change (false);
       Settings.ViaThickness = ((PinTypePtr) ptr2)->Thickness;
       Settings.ViaDrillingHole = ((PinTypePtr) ptr2)->DrillingHole;
       Settings.Keepaway = ((PinTypePtr) ptr2)->Clearance / 2;
       if (Settings.Mode != VIA_MODE)
 	SetMode (VIA_MODE);
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
       hid_action ("RouteStylesChanged");
       break;
 
diff --git a/src/buffer.c b/src/buffer.c
index 43d5c2b..75ab94a 100644
--- a/src/buffer.c
+++ b/src/buffer.c
@@ -521,12 +521,9 @@ void
 AddSelectedToBuffer (BufferTypePtr Buffer, LocationType X, LocationType Y,
 		     bool LeaveSelected)
 {
-  /* switch crosshair off because adding objects to the pastebuffer
-   * may change the 'valid' area for the cursor
-   */
   if (!LeaveSelected)
     ExtraFlag = SELECTEDFLAG;
-  HideCrosshair ();
+  notify_crosshair_change (false);
   Source = PCB->Data;
   Dest = Buffer->Data;
   SelectedOperation (&AddBufferFunctions, false, ALL_TYPES);
@@ -542,7 +539,7 @@ AddSelectedToBuffer (BufferTypePtr Buffer, LocationType X, LocationType Y,
       Buffer->X = Crosshair.X;
       Buffer->Y = Crosshair.Y;
     }
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   ExtraFlag = 0;
 }
 
@@ -1457,9 +1454,9 @@ ActionFreeRotateBuffer(int argc, char **argv, int x, int y)
   else
     angle_s = argv[0];
 
-  HideCrosshair ();
+  notify_crosshair_change (false);
   FreeRotateBuffer(PASTEBUFFER, strtod(angle_s, 0));
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   return 0;
 }
 
diff --git a/src/crosshair.c b/src/crosshair.c
index 7df5299..76f7434 100644
--- a/src/crosshair.c
+++ b/src/crosshair.c
@@ -66,15 +66,6 @@ typedef struct
 } point;
 
 /* ---------------------------------------------------------------------------
- * some local identifiers
- */
-
-/* This is a stack for HideCrosshair() and RestoreCrosshair() calls. They
- * must always be matched. */
-static bool CrosshairStack[MAX_CROSSHAIRSTACK_DEPTH];
-static int CrosshairStackLocation = 0;
-
-/* ---------------------------------------------------------------------------
  * some local prototypes
  */
 static void XORPolygon (PolygonTypePtr, LocationType, LocationType);
@@ -565,7 +556,7 @@ XORDrawMoveOrCopyObject (void)
 /* ---------------------------------------------------------------------------
  * draws additional stuff that follows the crosshair
  */
-static void
+void
 DrawAttached (void)
 {
   BDimension s;
@@ -684,6 +675,23 @@ DrawAttached (void)
     }
 }
 
+
+void
+notify_crosshair_change (bool changes_complete)
+{
+  if (gui->notify_crosshair_change)
+    gui->notify_crosshair_change (changes_complete);
+}
+
+
+void
+notify_mark_change (bool changes_complete)
+{
+  if (gui->notify_mark_change)
+    gui->notify_mark_change (changes_complete);
+}
+
+
 /* ---------------------------------------------------------------------------
  * switches crosshair on
  */
@@ -712,46 +720,6 @@ CrosshairOff (void)
     }
 }
 
-/* ---------------------------------------------------------------------------
- * saves crosshair state (on/off) and hides him
- */
-void
-HideCrosshair ()
-{
-  /* fprintf(stderr, "HideCrosshair stack %d\n", CrosshairStackLocation); */
-  if (CrosshairStackLocation >= MAX_CROSSHAIRSTACK_DEPTH)
-    {
-      fprintf(stderr, "Error: CrosshairStackLocation overflow\n");
-      return;
-    }
-
-  CrosshairStack[CrosshairStackLocation] = Crosshair.On;
-  CrosshairStackLocation++;
-
-  CrosshairOff ();
-}
-
-/* ---------------------------------------------------------------------------
- * restores last crosshair state
- */
-void
-RestoreCrosshair (void)
-{
-  /* fprintf(stderr, "RestoreCrosshair stack %d\n", CrosshairStackLocation); */
-  if (CrosshairStackLocation <= 0)
-    {
-      fprintf(stderr, "Error: CrosshairStackLocation underflow\n");
-      return;
-    }
-
-  CrosshairStackLocation--;
-
-  if (CrosshairStack[CrosshairStackLocation])
-    CrosshairOn ();
-  else
-    CrosshairOff ();
-}
-
 static double
 square (double x)
 {
@@ -1043,8 +1011,8 @@ MoveCrosshairRelative (LocationType DeltaX, LocationType DeltaY)
 }
 
 /* ---------------------------------------------------------------------------
- * move crosshair absolute switched off if it moved
- * return true if it switched off
+ * move crosshair absolute
+ * return true if the crosshair was moved from its existing position
  */
 bool
 MoveCrosshairAbsolute (LocationType X, LocationType Y)
@@ -1055,13 +1023,14 @@ MoveCrosshairAbsolute (LocationType X, LocationType Y)
   FitCrosshairIntoGrid (X, Y);
   if (Crosshair.X != x || Crosshair.Y != y)
     {
-      /* back up to old position and erase crosshair */
+      /* back up to old position to notify the GUI
+       * (which might want to erase the old crosshair) */
       z = Crosshair.X;
       Crosshair.X = x;
       x = z;
       z = Crosshair.Y;
       Crosshair.Y = y;
-      HideCrosshair ();
+      notify_crosshair_change (false); /* Our caller notifies when it has done */
       /* now move forward again */
       Crosshair.X = x;
       Crosshair.Y = z;
@@ -1108,8 +1077,7 @@ DrawMark (void)
 
 /* ---------------------------------------------------------------------------
  * initializes crosshair stuff
- * clears the struct, allocates to graphical contexts and
- * initializes the stack
+ * clears the struct, allocates to graphical contexts
  */
 void
 InitCrosshair (void)
@@ -1121,9 +1089,6 @@ InitCrosshair (void)
   gui->set_line_cap (Crosshair.GC, Trace_Cap);
   gui->set_line_width (Crosshair.GC, 1);
 
-  /* fake a crosshair off entry on stack */
-  CrosshairStackLocation = 0;
-  CrosshairStack[CrosshairStackLocation++] = true;
   Crosshair.On = false;
 
   /* set initial shape */
diff --git a/src/crosshair.h b/src/crosshair.h
index 4573e98..1135f0e 100644
--- a/src/crosshair.h
+++ b/src/crosshair.h
@@ -46,11 +46,11 @@
 #define	STATE_SECOND	1
 #define	STATE_THIRD		2
 
-
+void notify_crosshair_change (bool changes_complete);
+void notify_mark_change (bool changes_complete);
+void DrawAttached (void);
 void CrosshairOn (void);
 void CrosshairOff (void);
-void HideCrosshair (void);
-void RestoreCrosshair (void);
 void MoveCrosshairRelative (LocationType, LocationType);
 bool MoveCrosshairAbsolute (LocationType, LocationType);
 void SetCrosshairRange (LocationType, LocationType, LocationType,
diff --git a/src/draw.c b/src/draw.c
index 6091ef3..815ac5e 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -186,14 +186,10 @@ UpdateAll (void)
 void
 Draw (void)
 {
-  HideCrosshair ();
-
   /* clear and create event if not drawing to a pixmap
    */
   gui->invalidate_lr (Block.X1, Block.X2, Block.Y1, Block.Y2);
 
-  RestoreCrosshair ();
-
   /* shrink the update block */
   Block.X1 = Block.Y1 = Block.X2 = Block.Y2 = 0;
 }
diff --git a/src/hid.h b/src/hid.h
index b13e75b..7779f84 100644
--- a/src/hid.h
+++ b/src/hid.h
@@ -298,6 +298,8 @@ typedef enum
     /* This may be called to ask the GUI to force a redraw of a given area */
     void (*invalidate_lr) (int left_, int right_, int top_, int bottom_);
     void (*invalidate_all) (void);
+    void (*notify_crosshair_change) (bool changes_complete);
+    void (*notify_mark_change) (bool changes_complete);
 
     /* During redraw or print/export cycles, this is called once per
        layer (or layer group, for copper layers).  If it returns false
diff --git a/src/hid/batch/batch.c b/src/hid/batch/batch.c
index ea75d99..1fa7ac1 100644
--- a/src/hid/batch/batch.c
+++ b/src/hid/batch/batch.c
@@ -355,6 +355,8 @@ HID batch_gui = {
   batch_parse_arguments,
   batch_invalidate_lr,
   batch_invalidate_all,
+  0 /* batch_notify_crosshair_change */,
+  0 /* batch_notify_mark_change */,
   batch_set_layer,
   batch_make_gc,
   batch_destroy_gc,
diff --git a/src/hid/bom/bom.c b/src/hid/bom/bom.c
index 661b592..847eed0 100644
--- a/src/hid/bom/bom.c
+++ b/src/hid/bom/bom.c
@@ -546,6 +546,8 @@ HID bom_hid = {
   bom_parse_arguments,
   0,				/* bom_invalidate_lr */
   0,				/* bom_invalidate_all */
+  0,				/* bom_notify_crosshair_change */
+  0,				/* bom_notify_mark_change */
   0,				/* bom_set_layer */
   0,				/* bom_make_gc */
   0,				/* bom_destroy_gc */
diff --git a/src/hid/common/extents.c b/src/hid/common/extents.c
index 0f51b47..743c81d 100644
--- a/src/hid/common/extents.c
+++ b/src/hid/common/extents.c
@@ -186,6 +186,8 @@ static HID extents_hid = {
   0 /* extents_parse_arguments */ ,
   0 /* extents_invalidate_lr */ ,
   0 /* extents_invalidate_all */ ,
+  0 /* extents_notify_crosshair_changed */ ,
+  0 /* extents_notify_mark_changed */ ,
   extents_set_layer,
   extents_make_gc,
   extents_destroy_gc,
diff --git a/src/hid/common/hidnogui.c b/src/hid/common/hidnogui.c
index fd86b6a..cd1c0d2 100644
--- a/src/hid/common/hidnogui.c
+++ b/src/hid/common/hidnogui.c
@@ -420,6 +420,8 @@ HID hid_nogui = {
   nogui_parse_arguments,
   nogui_invalidate_lr,
   nogui_invalidate_all,
+  0 /* nogui_notify_crosshair_change */ ,
+  0 /* nogui_notify_mark_change */ ,
   nogui_set_layer,
   nogui_make_gc,
   nogui_destroy_gc,
@@ -477,6 +479,8 @@ apply_default_hid (HID * d, HID * s)
   AD (parse_arguments);
   AD (invalidate_lr);
   AD (invalidate_all);
+  AD (notify_crosshair_change);
+  AD (notify_mark_change);
   AD (set_layer);
   AD (make_gc);
   AD (destroy_gc);
diff --git a/src/hid/gcode/gcode.c b/src/hid/gcode/gcode.c
index d2dd717..a2cae9f 100644
--- a/src/hid/gcode/gcode.c
+++ b/src/hid/gcode/gcode.c
@@ -1043,6 +1043,8 @@ HID gcode_hid = {
   gcode_parse_arguments,
   0 /* gcode_invalidate_lr */ ,
   0 /* gcode_invalidate_all */ ,
+  0 /* gcode_notify_crosshair_change */ ,
+  0 /* gcode_notify_mark_change */ ,
   gcode_set_layer,
   gcode_make_gc,
   gcode_destroy_gc,
diff --git a/src/hid/gerber/gerber.c b/src/hid/gerber/gerber.c
index 8f04180..94d73e3 100644
--- a/src/hid/gerber/gerber.c
+++ b/src/hid/gerber/gerber.c
@@ -287,6 +287,8 @@ static HID gerber_hid = {
   gerber_parse_arguments,
   0 /* gerber_invalidate_lr */ ,
   0 /* gerber_invalidate_all */ ,
+  0 /* gerber_notify_crosshair_change */ ,
+  0 /* gerber_notify_mark_change */ ,
   gerber_set_layer,
   gerber_make_gc,
   gerber_destroy_gc,
diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index 2ebb1a2..31888c8 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -770,12 +770,41 @@ ghid_invalidate_all ()
 
   hid_expose_callback (&ghid_hid, &region, 0);
   ghid_draw_grid ();
-  if (ghidgui->need_restore_crosshair)
-    RestoreCrosshair ();
-  ghidgui->need_restore_crosshair = FALSE;
+
+  Crosshair.On = false;
+  CrosshairOn ();
+
   ghid_screen_update ();
 }
 
+void
+ghid_notify_crosshair_change (bool changes_complete)
+{
+  /* FIXME: This is because we sometimes get called before the GUI up */
+  if (gport->drawing_area == NULL)
+    return;
+
+  if (changes_complete)
+    CrosshairOn ();
+  else
+    CrosshairOff ();
+  ghid_draw_area_update (gport, NULL);
+}
+
+void
+ghid_notify_mark_change (bool changes_complete)
+{
+  /* FIXME: This is because we sometimes get called before the GUI up */
+  if (gport->drawing_area == NULL)
+    return;
+
+  if (!Marked.status)
+    return;
+
+  DrawMark (); /* NB: This is an XOR drawing operation */
+  ghid_draw_area_update (gport, NULL);
+}
+
 static void
 draw_right_cross (GdkGC *xor_gc, gint x, gint y)
 {
@@ -873,7 +902,7 @@ draw_crosshair (GdkGC *xor_gc, gint x, gint y)
 #define VCD 8
 
 void
-ghid_show_crosshair (gboolean show)
+ghid_show_crosshair (gboolean paint_new_location)
 {
   gint x, y;
   static gint x_prev = -1, y_prev = -1;
@@ -897,7 +926,7 @@ ghid_show_crosshair (gboolean show)
 
   gdk_gc_set_foreground (xor_gc, &cross_color);
 
-  if (x_prev >= 0)
+  if (x_prev >= 0 && !paint_new_location)
     {
       draw_crosshair (xor_gc, x_prev, y_prev);
       if (draw_markers_prev)
@@ -913,7 +942,7 @@ ghid_show_crosshair (gboolean show)
 	}
     }
 
-  if (x >= 0 && show)
+  if (x >= 0 && paint_new_location)
     {
       draw_crosshair (xor_gc, x, y);
       draw_markers = ghidgui->auto_pan_on && have_crosshair_attachments ();
@@ -990,7 +1019,6 @@ ghid_screen_update (void)
 {
   render_priv *priv = gport->render_priv;
 
-  ghid_show_crosshair (FALSE);
   gdk_draw_drawable (gport->drawing_area->window, priv->bg_gc, gport->pixmap,
 		     0, 0, 0, 0, gport->width, gport->height);
   ghid_show_crosshair (TRUE);
@@ -1003,7 +1031,6 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 {
   render_priv *priv = port->render_priv;
 
-  ghid_show_crosshair (FALSE);
   gdk_draw_drawable (widget->window, priv->bg_gc, port->pixmap,
                     ev->area.x, ev->area.y, ev->area.x, ev->area.y,
                     ev->area.width, ev->area.height);
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 266cf06..25ea1c3 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -988,6 +988,8 @@ HID ghid_hid = {
   ghid_parse_arguments,
   ghid_invalidate_lr,
   ghid_invalidate_all,
+  ghid_notify_crosshair_change,
+  ghid_notify_mark_change,
   ghid_set_layer,
   ghid_make_gc,
   ghid_destroy_gc,
@@ -1900,11 +1902,11 @@ ScrollAction (int argc, char **argv, int x, int y)
   else
     AFAIL (scroll);
 
-  HideCrosshair ();
+  notify_crosshair_change (false);
   ghid_port_ranges_pan (dx, dy, TRUE);
   MoveCrosshairRelative (dx, dy);
   AdjustAttachedObjects ();
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
 
   return 0;
 }
diff --git a/src/hid/gtk/gui-misc.c b/src/hid/gtk/gui-misc.c
index 8bda96d..75ba763 100644
--- a/src/hid/gtk/gui-misc.c
+++ b/src/hid/gtk/gui-misc.c
@@ -403,12 +403,12 @@ run_get_location_loop (const gchar * message)
   oldObjState = Crosshair.AttachedObject.State;
   oldLineState = Crosshair.AttachedLine.State;
   oldBoxState = Crosshair.AttachedBox.State;
-  HideCrosshair ();
+  notify_crosshair_change (false);
   Crosshair.AttachedObject.State = STATE_FIRST;
   Crosshair.AttachedLine.State = STATE_FIRST;
   Crosshair.AttachedBox.State = STATE_FIRST;
   ghid_hand_cursor ();
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
 
   /* Stop the top level GMainLoop from getting user input from keyboard
      |  and mouse so we can install our own handlers here.  Also set the
@@ -439,11 +439,11 @@ run_get_location_loop (const gchar * message)
   ghid_interface_input_signals_connect ();	/* return to normal */
   ghid_interface_set_sensitive (TRUE);
 
-  HideCrosshair ();
+  notify_crosshair_change (false);
   Crosshair.AttachedObject.State = oldObjState;
   Crosshair.AttachedLine.State = oldLineState;
   Crosshair.AttachedBox.State = oldBoxState;
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   ghid_restore_cursor ();
 
   ghid_set_status_line_label ();
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index c71af06..55f8c74 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -58,16 +58,12 @@ ghid_port_ranges_changed (void)
 {
   GtkAdjustment *h_adj, *v_adj;
 
-  if (!ghidgui->combine_adjustments)
-    HideCrosshair ();
   if (ghidgui->combine_adjustments)
     {
       ghidgui->combine_adjustments = FALSE;
       return;
     }
 
-  ghidgui->need_restore_crosshair = TRUE;
-
   h_adj = gtk_range_get_adjustment (GTK_RANGE (ghidgui->h_range));
   v_adj = gtk_range_get_adjustment (GTK_RANGE (ghidgui->v_range));
   gport->view_x0 = h_adj->value;
@@ -241,7 +237,7 @@ ghid_note_event_location (GdkEventButton * ev)
   if (moved)
     {
       AdjustAttachedObjects ();
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
     }
   ghid_set_cursor_position_labels ();
   return moved;
@@ -311,10 +307,10 @@ ghid_port_key_release_cb (GtkWidget * drawing_area, GdkEventKey * kev,
   if (ghid_is_modifier_key_sym (ksym))
     ghid_note_event_location (NULL);
 
-  HideCrosshair ();
+  notify_crosshair_change (false);
   AdjustAttachedObjects ();
   ghid_invalidate_all ();
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   ghid_screen_update ();
   g_idle_add (ghid_idle_cb, NULL);
   return FALSE;
@@ -453,12 +449,12 @@ ghid_port_button_press_cb (GtkWidget * drawing_area,
   state = (GdkModifierType) (ev->state);
   mk = ghid_modifier_keys_state (&state);
   ghid_show_crosshair (FALSE);
-  HideCrosshair ();
+  notify_crosshair_change (false);
 
   do_mouse_action(ev->button, mk);
 
   ghid_invalidate_all ();
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   ghid_window_set_name_label (PCB->Name);
   ghid_set_status_line_label ();
   ghid_show_crosshair (TRUE);
@@ -479,13 +475,13 @@ ghid_port_button_release_cb (GtkWidget * drawing_area,
   state = (GdkModifierType) (ev->state);
   mk = ghid_modifier_keys_state (&state);
 
-  HideCrosshair ();
+  notify_crosshair_change (false);
 
   do_mouse_action(ev->button, mk + M_Release);
 
   AdjustAttachedObjects ();
   ghid_invalidate_all ();
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   ghid_screen_update ();
 
   ghid_window_set_name_label (PCB->Name);
@@ -502,7 +498,6 @@ ghid_port_drawing_area_configure_event_cb (GtkWidget * widget,
 {
   static gboolean first_time_done;
 
-  HideCrosshair ();
   gport->width = ev->width;
   gport->height = ev->height;
 
@@ -536,7 +531,6 @@ ghid_port_drawing_area_configure_event_cb (GtkWidget * widget,
 
   ghid_port_ranges_scale (FALSE);
   ghid_invalidate_all ();
-  RestoreCrosshair ();
   return 0;
 }
 
@@ -695,6 +689,7 @@ ghid_port_window_motion_cb (GtkWidget * widget,
   queue_tooltip_update (out);
 #endif
 
+  ghid_show_crosshair (FALSE);
   ghid_show_crosshair (TRUE);
   if (moved && have_crosshair_attachments ())
     ghid_draw_area_update (gport, NULL);
diff --git a/src/hid/gtk/gui-top-window.c b/src/hid/gtk/gui-top-window.c
index 074ef9b..0a0e757 100644
--- a/src/hid/gtk/gui-top-window.c
+++ b/src/hid/gtk/gui-top-window.c
@@ -656,10 +656,10 @@ ghid_menu_cb (GtkAction * action, gpointer data)
    */
   if (ghidgui->toggle_holdoff == FALSE) 
     {
-      HideCrosshair ();
+      notify_crosshair_change (false);
       AdjustAttachedObjects ();
       ghid_invalidate_all ();
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
       ghid_screen_update ();
       ghid_window_set_name_label (PCB->Name);
       ghid_set_status_line_label ();
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index 97ebb1c..651a746 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -132,7 +132,7 @@ typedef struct
     small_label_markup,
     compact_horizontal,
     compact_vertical,
-    ghid_title_window, use_command_window, need_restore_crosshair, creating;
+    ghid_title_window, use_command_window, creating;
 
   gint n_mode_button_columns,
     top_window_width,
@@ -494,6 +494,8 @@ void ghid_fill_polygon (hidGC gc, int n_coords, int *x, int *y);
 void ghid_fill_rect (hidGC gc, int x1, int y1, int x2, int y2);
 void ghid_invalidate_lr (int left, int right, int top, int bottom);
 void ghid_invalidate_all ();
+void ghid_notify_crosshair_change (bool changes_complete);
+void ghid_notify_mark_change (bool changes_complete);
 void ghid_show_crosshair (gboolean show);
 void ghid_init_renderer (int *, char ***, GHidPort *);
 void ghid_init_drawing_widget (GtkWidget *widget, GHidPort *);
diff --git a/src/hid/lesstif/main.c b/src/hid/lesstif/main.c
index 2f00577..422e83b 100644
--- a/src/hid/lesstif/main.c
+++ b/src/hid/lesstif/main.c
@@ -1311,12 +1311,12 @@ mod_changed (XKeyEvent * e, int set)
       return;
     }
   in_move_event = 1;
-  HideCrosshair ();
+  notify_crosshair_change (false);
   if (panning)
     Pan (2, e->x, e->y);
   EventMoveCrosshair (Px (e->x), Py (e->y));
   AdjustAttachedObjects ();
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   in_move_event = 0;
 }
 
@@ -1352,7 +1352,7 @@ work_area_input (Widget w, XtPointer v, XEvent * e, Boolean * ctd)
 	}
         ignore_release = 0;
 
-        HideCrosshair ();
+        notify_crosshair_change (false);
         pressed_button = e->xbutton.button;
         mods = ((e->xbutton.state & ShiftMask) ? M_Shift : 0)
           + ((e->xbutton.state & ControlMask) ? M_Ctrl : 0)
@@ -1362,7 +1362,7 @@ work_area_input (Widget w, XtPointer v, XEvent * e, Boolean * ctd)
           + ((e->xbutton.state & Mod1Mask) ? M_Alt : 0);
 #endif
         do_mouse_action(e->xbutton.button, mods);
-        RestoreCrosshair ();
+        notify_crosshair_change (true);
         break;
       }
 
@@ -1372,7 +1372,7 @@ work_area_input (Widget w, XtPointer v, XEvent * e, Boolean * ctd)
         if (e->xbutton.button != pressed_button)
           return;
         lesstif_button_event (w, e);
-        HideCrosshair ();
+        notify_crosshair_change (false);
         pressed_button = 0;
         mods = ((e->xbutton.state & ShiftMask) ? M_Shift : 0)
           + ((e->xbutton.state & ControlMask) ? M_Ctrl : 0)
@@ -1383,7 +1383,7 @@ work_area_input (Widget w, XtPointer v, XEvent * e, Boolean * ctd)
 #endif
           + M_Release;
         do_mouse_action (e->xbutton.button, mods);
-        RestoreCrosshair ();
+        notify_crosshair_change (true);
         break;
       }
 
@@ -2879,6 +2879,39 @@ lesstif_invalidate_all (void)
   lesstif_invalidate_lr (0, PCB->MaxWidth, 0, PCB->MaxHeight);
 }
 
+static void
+lesstif_notify_crosshair_change (bool changes_complete)
+{
+  static int invalidate_depth = 0;
+
+  if (changes_complete)
+    {
+      invalidate_depth --;
+      if (invalidate_depth < 0)
+        {
+          fprintf (stderr, "ERROR: Unmatched notify crosshair calls\n");
+          invalidate_depth = 0;
+        }
+      if (invalidate_depth == 0)
+        CrosshairOn ();
+    }
+  else
+    {
+      if (invalidate_depth == 0)
+        CrosshairOff ();
+      invalidate_depth ++;
+    }
+}
+
+static void
+lesstif_notify_mark_change (bool changes_complete)
+{
+  if (!Marked.status)
+    return;
+
+  DrawMark ();
+}
+
 static int
 lesstif_set_layer (const char *name, int group, int empty)
 {
@@ -3812,6 +3845,8 @@ HID lesstif_gui = {
   lesstif_parse_arguments,
   lesstif_invalidate_lr,
   lesstif_invalidate_all,
+  lesstif_notify_crosshair_change,
+  lesstif_notify_mark_change,
   lesstif_set_layer,
   lesstif_make_gc,
   lesstif_destroy_gc,
diff --git a/src/hid/lpr/lpr.c b/src/hid/lpr/lpr.c
index a79af0a..c932047 100644
--- a/src/hid/lpr/lpr.c
+++ b/src/hid/lpr/lpr.c
@@ -121,6 +121,8 @@ HID lpr_hid = {
   lpr_parse_arguments,
   0 /* lpr_invalidate_lr */ ,
   0 /* lpr_invalidate_all */ ,
+  0 /* lpr_notify_crosshair_change */ ,
+  0 /* lpr_notify_mark_change */ ,
   0 /* lpr_set_layer */ ,
   0 /* lpr_make_gc */ ,
   0 /* lpr_destroy_gc */ ,
diff --git a/src/hid/nelma/nelma.c b/src/hid/nelma/nelma.c
index 0a1efef..6b131ad 100644
--- a/src/hid/nelma/nelma.c
+++ b/src/hid/nelma/nelma.c
@@ -1059,6 +1059,8 @@ HID             nelma_hid = {
 	nelma_parse_arguments,
 	0 /* nelma_invalidate_lr */ ,
 	0 /* nelma_invalidate_all */ ,
+	0 /* nelma_notify_crosshair_change */ ,
+	0 /* nelma_notify_mark_change */ ,
 	nelma_set_layer,
 	nelma_make_gc,
 	nelma_destroy_gc,
diff --git a/src/hid/png/png.c b/src/hid/png/png.c
index 022da9c..8817431 100644
--- a/src/hid/png/png.c
+++ b/src/hid/png/png.c
@@ -1527,6 +1527,8 @@ HID png_hid = {
   png_parse_arguments,
   0 /* png_invalidate_lr */ ,
   0 /* png_invalidate_all */ ,
+  0 /* png_notify_crosshair_change */ ,
+  0 /* png_notify_mark_change */ ,
   png_set_layer,
   png_make_gc,
   png_destroy_gc,
diff --git a/src/hid/ps/eps.c b/src/hid/ps/eps.c
index 49a19c7..97f9d41 100644
--- a/src/hid/ps/eps.c
+++ b/src/hid/ps/eps.c
@@ -64,6 +64,8 @@ static HID eps_hid = {
   eps_parse_arguments,
   0 /* eps_invalidate_lr */ ,
   0 /* eps_invalidate_all */ ,
+  0 /* eps_notify_crosshair_change */ ,
+  0 /* eps_notify_mark_change */ ,
   eps_set_layer,
   eps_make_gc,
   eps_destroy_gc,
diff --git a/src/hid/ps/ps.c b/src/hid/ps/ps.c
index 7c286cc..822f5bd 100644
--- a/src/hid/ps/ps.c
+++ b/src/hid/ps/ps.c
@@ -1353,6 +1353,8 @@ HID ps_hid = {
   ps_parse_arguments,
   0 /* ps_invalidate_lr */ ,
   0 /* ps_invalidate_all */ ,
+  0 /* ps_notify_crosshair_change */ ,
+  0 /* ps_notify_mark_change */ ,
   ps_set_layer,
   ps_make_gc,
   ps_destroy_gc,
diff --git a/src/misc.c b/src/misc.c
index a7704f4..1603e7f 100644
--- a/src/misc.c
+++ b/src/misc.c
@@ -654,15 +654,11 @@ CenterDisplay (LocationType X, LocationType Y, bool Delta)
   double save_grid = PCB->Grid;
   PCB->Grid = 1;
   if (Delta)
-    {
-      MoveCrosshairRelative (X, Y);
-    }
+    MoveCrosshairRelative (X, Y);
   else
     {
       if (MoveCrosshairAbsolute (X, Y))
-        {
-          RestoreCrosshair ();
-        }
+        notify_crosshair_change (true);
     }
   gui->set_crosshair (Crosshair.X, Crosshair.Y, HID_SC_WARP_POINTER);
   PCB->Grid = save_grid;
diff --git a/src/set.c b/src/set.c
index 17f7583..228b4c2 100644
--- a/src/set.c
+++ b/src/set.c
@@ -244,7 +244,7 @@ SetMode (int Mode)
   if (recursing)
     return;
   recursing = true;
-  HideCrosshair ();
+  notify_crosshair_change (false);
   addedLines = 0;
   Crosshair.AttachedObject.Type = NO_TYPE;
   Crosshair.AttachedObject.State = STATE_FIRST;
@@ -314,7 +314,7 @@ SetMode (int Mode)
    * may have changed
    */
   MoveCrosshairRelative (0, 0);
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
 }
 
 void
@@ -342,20 +342,20 @@ SetLocalRef (LocationType X, LocationType Y, bool Showing)
 
   if (Showing)
     {
-      HideCrosshair ();
+      notify_crosshair_change (false);
       if (count == 0)
 	old = Marked;
       Marked.X = X;
       Marked.Y = Y;
       Marked.status = true;
       count++;
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
     }
   else if (count > 0)
     {
-      HideCrosshair ();
+      notify_crosshair_change (false);
       count = 0;
       Marked = old;
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
     }
 }

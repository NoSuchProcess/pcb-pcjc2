Bottom: b1cc1e0693ef0bc07f26c8f7fa9449dea037e5c0
Top:    4bd219d3eae193abfef2eacc8d4a573e7d6b7fd6
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2011-12-25 01:10:57 +0000

gts: Avoid performing computations with side-effects in g_assert statements

g_assert (like assert), can be disabled at build time, so assertions
should therefore not contain any expressions which have side-effects.

Coverity caught a number of these in the copy gts library we have embedded,
fix them by separating the computation and the assertion test.

Coverity-cid: 56
Coverity-cid: 57
Coverity-cid: 57
Coverity-cid: 58
Coverity-cid: 59


---

diff --git a/gts/matrix.c b/gts/matrix.c
index 7ada15d..eb0b1f8 100644
--- a/gts/matrix.c
+++ b/gts/matrix.c
@@ -126,11 +126,14 @@ GtsMatrix * gts_matrix_projection (GtsTriangle * t)
   x3 = y1*z2 - z1*y2; y3 = z1*x2 - x1*z2; z3 = x1*y2 - y1*x2;
   x2 = y3*z1 - z3*y1; y2 = z3*x1 - x3*z1; z2 = x3*y1 - y3*x1;
 
-  g_assert ((l = sqrt (x1*x1 + y1*y1 + z1*z1)) > 0.0);
+  l = sqrt (x1*x1 + y1*y1 + z1*z1);
+  g_assert (l > 0.0);
   m[0][0] = x1/l; m[1][0] = y1/l; m[2][0] = z1/l; m[3][0] = 0.;
-  g_assert ((l = sqrt (x2*x2 + y2*y2 + z2*z2)) > 0.0);
+  l = sqrt (x2*x2 + y2*y2 + z2*z2);
+  g_assert (l > 0.0);
   m[0][1] = x2/l; m[1][1] = y2/l; m[2][1] = z2/l; m[3][1] = 0.;
-  g_assert ((l = sqrt (x3*x3 + y3*y3 + z3*z3)) > 0.0);
+  l = sqrt (x3*x3 + y3*y3 + z3*z3);
+  g_assert (l > 0.0);
   m[0][2] = x3/l; m[1][2] = y3/l; m[2][2] = z3/l; m[3][2] = 0.;
   m[0][3] = 0; m[1][3] = 0.; m[2][3] = 0.; m[3][3] = 1.;
 
diff --git a/gts/refine.c b/gts/refine.c
index 293eb11..eab585d 100644
--- a/gts/refine.c
+++ b/gts/refine.c
@@ -191,6 +191,7 @@ static gint split_encroached (GtsSurface * surface,
   GtsSegment * s;
 
   while (steiner_max-- != 0 && (s = gts_fifo_pop (encroached))) {
+    GtsVertex *add_vertex_returned;
     GtsVertex * v = split_edge (GTS_EDGE (s), surface);
     GtsFace * boundary = gts_edge_is_boundary (GTS_EDGE (s), surface);
     GtsFace * f = boundary;
@@ -217,8 +218,10 @@ static gint split_encroached (GtsSurface * surface,
     GTS_OBJECT (s)->klass = GTS_OBJECT_CLASS (surface->edge_class);
 
     if (f == NULL)
-      g_assert ((f = gts_edge_has_parent_surface (GTS_EDGE (s), surface)));
-    g_assert (gts_delaunay_add_vertex_to_face (surface, v, f) == NULL);
+      f = gts_edge_has_parent_surface (GTS_EDGE (s), surface);
+    g_assert (f != NULL);
+    add_vertex_returned = gts_delaunay_add_vertex_to_face (surface, v, f);
+    g_assert (add_vertex_returned == NULL);
 
     if (boundary)
       gts_object_destroy (GTS_OBJECT (s));
@@ -385,12 +388,14 @@ guint gts_delaunay_refine (GtsSurface * surface,
   GTS_OBJECT (surface)->reserved = heap;
 
   while (steiner_max-- != 0 && (f = gts_eheap_remove_top (heap, NULL))) {
+    GtsVertex *add_vertex_returned;
     GtsVertex * c = 
       GTS_VERTEX (gts_triangle_circumcircle_center (GTS_TRIANGLE (f),
 		  GTS_POINT_CLASS (surface->vertex_class)));
     EHEAP_PAIR (f) = NULL;
     g_assert (c != NULL);
-    g_assert (gts_delaunay_add_vertex (surface, c, f) == NULL);
+    add_vertex_returned = gts_delaunay_add_vertex (surface, c, f);
+    g_assert (add_vertex_returned == NULL);
 
     vertex_encroaches (c, surface, encroached, encroaches, encroach_data);
     if (!gts_fifo_is_empty (encroached)) {
diff --git a/gts/split.c b/gts/split.c
index 43fea3a..b7bee77 100644
--- a/gts/split.c
+++ b/gts/split.c
@@ -253,9 +253,10 @@ static CFace * cface_new (GtsFace * f,
   v = GTS_SEGMENT (e1)->v1 == v1 ?
     GTS_SEGMENT (e1)->v2 : GTS_SEGMENT (e1)->v1;
 #ifdef NEW
-  if ((cf->flags & CFACE_E1) || (cf->flags & CFACE_E2))
-    g_assert ((vvs = GTS_EDGE (gts_vertices_are_connected (vs->v, v))));
-  else
+  if ((cf->flags & CFACE_E1) || (cf->flags & CFACE_E2)) {
+    vvs = GTS_EDGE (gts_vertices_are_connected (vs->v, v));
+    g_assert (vvs != NULL);
+  } else
 #endif
   vvs = gts_edge_new (klass, v, vs->v);
 
@@ -591,7 +592,8 @@ void gts_split_collapse (GtsSplit * vs,
 
   v1 = GTS_SPLIT_V1 (vs);
   v2 = GTS_SPLIT_V2 (vs);
-  g_assert ((e = GTS_EDGE (gts_vertices_are_connected (v1, v2))));
+  e = GTS_EDGE (gts_vertices_are_connected (v1, v2));
+  g_assert (e != NULL);
 
 #ifdef DEBUG
   fprintf (stderr, "collapsing %p: v1: %p v2: %p v: %p\n", vs, v1, v2, v);
@@ -945,7 +947,8 @@ GtsSplit * gts_split_new (GtsSplitClass * klass,
 #else
   v1 = GTS_SPLIT_V1 (vs);
   v2 = GTS_SPLIT_V2 (vs);
-  g_assert ((e = GTS_EDGE (gts_vertices_are_connected (v1, v2))));
+  e = GTS_EDGE (gts_vertices_are_connected (v1, v2));
+  g_assert (e != NULL);
   i = e->triangles;
   vs->ncf = g_slist_length (i);
   g_assert (vs->ncf > 0);
diff --git a/gts/vopt.c b/gts/vopt.c
index d772af9..4bc448e 100644
--- a/gts/vopt.c
+++ b/gts/vopt.c
@@ -475,7 +475,8 @@ GtsVertex * gts_volume_optimized_vertex (GtsEdge * edge,
 #endif /* Weighted average of volume, boundary and shape optimization */
 
   g_assert (n == 3);
-  g_assert ((Ai = gts_matrix3_inverse (A)));
+  Ai = gts_matrix3_inverse (A);
+  g_assert (Ai != NULL);
 
   v = gts_vertex_new (klass,
 		      Ai[0][0]*b[0] + Ai[0][1]*b[1] + Ai[0][2]*b[2],

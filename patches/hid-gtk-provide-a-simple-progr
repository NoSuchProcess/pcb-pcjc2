Bottom: 9a6fcc3160ceee211472b7aaee9215b040985bd1
Top:    d3fda885994bd9155df20501e8e47467ccacbffb
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-05-03 23:08:45 +0100

hid/gtk: Provide a simple progress dialog implementation

Known issues:

Since the GUI mainloop is not running, the dialog will not currently
resize its widgets whilst a task is running and periodically calling
to update progress.

Width of the label is hard-coded to force a sensible dialogue box
size - this due the the above issue.

As the GUI mainloop is not running, it is not possible to add a button
to cancel the action in progress.


---

diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index fd092c6..f65f401 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -739,10 +739,216 @@ ghid_beep ()
   gdk_beep ();
 }
 
+struct progress_dialog
+{
+  GtkWidget *dialog;
+  GtkWidget *message;
+  GtkWidget *progress;
+  gint response_id;
+  GMainLoop *loop;
+  gboolean destroyed;
+  gboolean stop_loop;
+  gboolean started;
+  GTimer *timer;
+
+  gulong response_handler;
+  gulong unmap_handler;
+  gulong destroy_handler;
+  gulong delete_handler;
+};
+
+static void
+run_unmap_handler (GtkDialog *dialog, gpointer data)
+{
+  struct progress_dialog *pd = data;
+
+  pd->stop_loop = TRUE;
+}
+
+static void
+run_response_handler (GtkDialog *dialog,
+                      gint response_id,
+                      gpointer data)
+{
+  struct progress_dialog *pd = data;
+
+  pd->response_id = response_id;
+  pd->stop_loop = TRUE;
+}
+
+static gint
+run_delete_handler (GtkDialog *dialog,
+                    GdkEventAny *event,
+                    gpointer data)
+{
+  struct progress_dialog *pd = data;
+
+  pd->stop_loop = TRUE;
+
+  return TRUE; /* Do not destroy */
+}
+
+static void
+run_destroy_handler (GtkDialog *dialog, gpointer data)
+{
+  struct progress_dialog *pd = data;
+
+  /* stop_loop will be set by run_unmap_handler */
+
+  pd->destroyed = TRUE;
+}
+
+static struct progress_dialog *
+make_progress_dialog (void)
+{
+  struct progress_dialog *pd;
+  GtkWidget *alignment;
+  GtkWidget *vbox;
+
+  pd = g_new0 (struct progress_dialog, 1);
+  pd->response_id = GTK_RESPONSE_NONE;
+
+  pd->dialog = gtk_dialog_new_with_buttons (_("Progress"),
+                                            GTK_WINDOW (gport->top_window),
+                                            /* Modal so nothing else can get events whilst
+                                               the main mainloop isn't running */
+                                            GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT,
+                                            GTK_STOCK_CANCEL,
+                                            GTK_RESPONSE_CANCEL,
+                                            NULL);
+
+  gtk_window_set_deletable (GTK_WINDOW (pd->dialog), FALSE);
+  gtk_window_set_skip_pager_hint (GTK_WINDOW (pd->dialog), TRUE);
+  gtk_window_set_skip_taskbar_hint (GTK_WINDOW (pd->dialog), TRUE);
+  gtk_widget_set_size_request (pd->dialog, 300, -1);
+
+  pd->message = gtk_label_new (NULL);
+  gtk_misc_set_alignment (GTK_MISC (pd->message), 0., 0.);
+
+  pd->progress = gtk_progress_bar_new ();
+  gtk_widget_set_size_request (pd->progress, -1, 26);
+
+  vbox = gtk_vbox_new (false, 0);
+  gtk_box_pack_start (GTK_BOX (vbox), pd->message, true, true, 8);
+  gtk_box_pack_start (GTK_BOX (vbox), pd->progress, false, true, 8);
+
+  alignment = gtk_alignment_new (0., 0., 1., 1.);
+  gtk_alignment_set_padding (GTK_ALIGNMENT (alignment), 8, 8, 8, 8);
+  gtk_container_add (GTK_CONTAINER (alignment), vbox);
+
+  gtk_box_pack_start (GTK_BOX (GTK_DIALOG (pd->dialog)->vbox),
+                      alignment, true, true, 0);
+
+  gtk_widget_show_all (alignment);
+
+  g_object_ref (pd->dialog);
+  gtk_window_present (GTK_WINDOW (pd->dialog));
+
+  pd->response_handler =
+    g_signal_connect (pd->dialog, "response",
+                      G_CALLBACK (run_response_handler), pd);
+  pd->unmap_handler =
+    g_signal_connect (pd->dialog, "unmap",
+                      G_CALLBACK (run_unmap_handler), pd);
+  pd->delete_handler =
+    g_signal_connect (pd->dialog, "delete-event",
+                      G_CALLBACK (run_delete_handler), pd);
+  pd->destroy_handler =
+    g_signal_connect (pd->dialog, "destroy",
+                      G_CALLBACK (run_destroy_handler), pd);
+
+  pd->loop = g_main_loop_new (NULL, FALSE);
+  pd->timer = g_timer_new ();
+
+  return pd;
+}
+
+static void
+destroy_progress_dialog (struct progress_dialog *pd)
+{
+  if (pd == NULL)
+    return;
+
+  if (!pd->destroyed)
+    {
+      g_signal_handler_disconnect (pd->dialog, pd->response_handler);
+      g_signal_handler_disconnect (pd->dialog, pd->unmap_handler);
+      g_signal_handler_disconnect (pd->dialog, pd->delete_handler);
+      g_signal_handler_disconnect (pd->dialog, pd->destroy_handler);
+    }
+
+  g_timer_destroy (pd->timer);
+  g_object_unref (pd->dialog);
+  g_main_loop_unref (pd->loop);
+
+  gtk_widget_destroy (pd->dialog);
+
+  pd->loop = NULL;
+  g_free (pd);
+}
+
+#define MAX_EVENT_LATENCY (100./1000.) /* 100us */
+static void
+handle_progress_dialog_events (struct progress_dialog *pd)
+{
+  GMainContext * context = g_main_loop_get_context (pd->loop);
+
+  /* We don't want to keep the underlying process too busy whilst we
+   * process events. If we get called quickly after the last progress
+   * update, wait a little bit before we respond - perhaps the next
+   * time progress is reported.
+
+   * The exception here is that we always want to process the first
+   * batch of events after having shown the dialog for the first time
+   */
+  if (pd->started && g_timer_elapsed (pd->timer, NULL) < MAX_EVENT_LATENCY)
+    return;
+
+  /* Process events */
+  while (g_main_context_pending (context))
+    {
+      g_main_context_iteration (context, FALSE);
+    }
+
+  pd->started = TRUE;
+  g_timer_start (pd->timer);
+}
+
 static int
 ghid_progress (int so_far, int total, const char *message)
 {
-  return 0;
+  static struct progress_dialog *pd = NULL;
+  int retval = 0;
+
+  /* If we are finished, destroy any dialog */
+  if (so_far == 0 && total == 0 && message == NULL)
+    {
+      destroy_progress_dialog (pd);
+      pd = NULL;
+      return retval;
+    }
+
+  if (pd == NULL)
+    {
+      pd = make_progress_dialog ();
+    }
+
+  gtk_label_set_text (GTK_LABEL (pd->message), message);
+  gtk_progress_bar_set_fraction (GTK_PROGRESS_BAR (pd->progress),
+                                 (double)so_far / (double)total);
+
+  handle_progress_dialog_events (pd);
+
+  if (pd->stop_loop)
+    {
+      retval = (pd->response_id == GTK_RESPONSE_CANCEL ||
+                pd->response_id == GTK_RESPONSE_DELETE_EVENT ||
+                pd->response_id == GTK_RESPONSE_NONE);
+      destroy_progress_dialog (pd);
+      pd = NULL;
+    }
+
+  return retval;
 }
 
 /* ---------------------------------------------------------------------- */

Bottom: a1930ec6a6f906f740fff5a8157920ad277dd33d
Top:    a3ae7e652257d1f2da0138764d6b47a9e9df792f
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-12-16 00:03:43 +0000

hid/common/hidgl: Add API to initialise a rendering pass

Serves as a place to perform any necessary initialisation within hidgl.c,
saving lots of separate calls being made by its callers.


---

diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index 9f10b8c..bda04d2 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -71,7 +71,7 @@
 triangle_buffer buffer;
 float global_depth = 0;
 
-void
+static void
 hidgl_init_triangle_array (triangle_buffer *buffer)
 {
   buffer->triangle_count = 0;
@@ -703,6 +703,18 @@ hidgl_init (void)
     }
 }
 
+void
+hidgl_start_render (void)
+{
+  hidgl_init ();
+  hidgl_init_triangle_array (&buffer);
+}
+
+void
+hidgl_finish_render (void)
+{
+}
+
 int
 hidgl_stencil_bits (void)
 {
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index 858270a..8d2c78c 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -33,7 +33,6 @@ typedef struct {
 extern triangle_buffer buffer;
 extern float global_depth;
 
-void hidgl_init_triangle_array (triangle_buffer *buffer);
 void hidgl_flush_triangles (triangle_buffer *buffer);
 void hidgl_ensure_triangle_space (triangle_buffer *buffer, int count);
 
@@ -77,6 +76,8 @@ void hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double
 void hidgl_fill_rect (Coord x1, Coord y1, Coord x2, Coord y2);
 
 void hidgl_init (void);
+void hidgl_start_render (void);
+void hidgl_finish_render (void);
 int hidgl_stencil_bits (void);
 int hidgl_assign_clear_stencil_bit (void);
 void hidgl_return_stencil_bit (int bit);
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index ba87527..25c4bf7 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -1911,8 +1911,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   gtk_widget_get_allocation (widget, &allocation);
 
   ghid_start_drawing (port);
-
-  hidgl_init ();
+  hidgl_start_render ();
 
   /* If we don't have any stencil bits available,
      we can't use the hidgl polygon drawing routine */
@@ -2030,7 +2029,6 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
              port->bg_color.green / 65535.,
              port->bg_color.blue / 65535.);
 
-  hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
 
   /* Setup stenciling */
@@ -2092,6 +2090,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   draw_lead_user (priv);
 
+  hidgl_finish_render ();
   ghid_end_drawing (port);
 
   g_timer_start (priv->time_since_expose);
@@ -2160,6 +2159,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   if (!gdk_gl_drawable_gl_begin (pGlDrawable, pGlContext)) {
     return FALSE;
   }
+  hidgl_start_render ();
   gport->render_priv->in_context = true;
 
   glEnable (GL_BLEND);
@@ -2186,11 +2186,9 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   glStencilMask (~0);
   glClearStencil (0);
   glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
-
   hidgl_reset_stencil_usage ();
 
   /* call the drawing routine */
-  hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
   glPushMatrix ();
   glScalef ((gport->view.flip_x ? -1. : 1.) / gport->view.coord_per_px,
@@ -2211,6 +2209,8 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   else
     glFlush ();
 
+  hidgl_finish_render ();
+
   /* end drawing to current GL-context */
   gport->render_priv->in_context = false;
   gdk_gl_drawable_gl_end (pGlDrawable);
@@ -2269,6 +2269,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   if (!gdk_gl_drawable_gl_begin (gldrawable, glcontext)) {
     return NULL;
   }
+  hidgl_start_render ();
   gport->render_priv->in_context = true;
 
   glEnable (GL_BLEND);
@@ -2296,7 +2297,6 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   hidgl_reset_stencil_usage ();
 
   /* call the drawing routine */
-  hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
   glPushMatrix ();
   glScalef ((gport->view.flip_x ? -1. : 1.) / gport->view.coord_per_px,
@@ -2323,6 +2323,8 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
 
   glFlush ();
 
+  hidgl_finish_render ();
+
   /* end drawing to current GL-context */
   gport->render_priv->in_context = false;
   gdk_gl_drawable_gl_end (gldrawable);
@@ -2349,6 +2351,7 @@ ghid_request_debug_draw (void)
   gtk_widget_get_allocation (widget, &allocation);
 
   ghid_start_drawing (port);
+  hidgl_start_render ();
 
   glViewport (0, 0, allocation.width, allocation.height);
 
@@ -2359,7 +2362,6 @@ ghid_request_debug_draw (void)
   glLoadIdentity ();
   glTranslatef (0.0f, 0.0f, -Z_NEAR);
 
-  hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
 
   /* Setup stenciling */
@@ -2397,6 +2399,7 @@ ghid_finish_debug_draw (void)
   hidgl_flush_triangles (&buffer);
   glPopMatrix ();
 
+  hidgl_finish_render ();
   ghid_end_drawing (gport);
 }

Bottom: b3c566975806bf9d6bec1c0217e607ac95e343a0
Top:    04b216b314e9c7707d914394ed8827d0e6857345
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2012-01-12 22:30:37 +0000

hid/common/hidgl: Add API to initialise a rendering pass

Serves as a place to perform any necessary initialisation within hidgl.c,
saving lots of separate calls being made by its callers.


---

diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index e7435e7..9111373 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -71,7 +71,7 @@
 triangle_buffer buffer;
 float global_depth = 0;
 
-void
+static void
 hidgl_init_triangle_array (triangle_buffer *buffer)
 {
   buffer->triangle_count = 0;
@@ -696,6 +696,18 @@ hidgl_init (void)
     }
 }
 
+void
+hidgl_start_render (void)
+{
+  hidgl_init ();
+  hidgl_init_triangle_array (&buffer);
+}
+
+void
+hidgl_finish_render (void)
+{
+}
+
 int
 hidgl_stencil_bits (void)
 {
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index 858270a..8d2c78c 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -33,7 +33,6 @@ typedef struct {
 extern triangle_buffer buffer;
 extern float global_depth;
 
-void hidgl_init_triangle_array (triangle_buffer *buffer);
 void hidgl_flush_triangles (triangle_buffer *buffer);
 void hidgl_ensure_triangle_space (triangle_buffer *buffer, int count);
 
@@ -77,6 +76,8 @@ void hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double
 void hidgl_fill_rect (Coord x1, Coord y1, Coord x2, Coord y2);
 
 void hidgl_init (void);
+void hidgl_start_render (void);
+void hidgl_finish_render (void);
 int hidgl_stencil_bits (void);
 int hidgl_assign_clear_stencil_bit (void);
 void hidgl_return_stencil_bit (int bit);
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index d205fc2..5831b4b 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -1907,8 +1907,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   gtk_widget_get_allocation (widget, &allocation);
 
   ghid_start_drawing (port);
-
-  hidgl_init ();
+  hidgl_start_render ();
 
   /* If we don't have any stencil bits available,
      we can't use the hidgl polygon drawing routine */
@@ -2026,7 +2025,6 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
              port->bg_color.green / 65535.,
              port->bg_color.blue / 65535.);
 
-  hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
 
   /* Setup stenciling */
@@ -2088,6 +2086,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   draw_lead_user (priv);
 
+  hidgl_finish_render ();
   ghid_end_drawing (port);
 
   g_timer_start (priv->time_since_expose);
@@ -2156,6 +2155,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   if (!gdk_gl_drawable_gl_begin (pGlDrawable, pGlContext)) {
     return FALSE;
   }
+  hidgl_start_render ();
   gport->render_priv->in_context = true;
 
   glEnable (GL_BLEND);
@@ -2182,11 +2182,9 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   glStencilMask (~0);
   glClearStencil (0);
   glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
-
   hidgl_reset_stencil_usage ();
 
   /* call the drawing routine */
-  hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
   glPushMatrix ();
   glScalef ((gport->view.flip_x ? -1. : 1.) / gport->view.coord_per_px,
@@ -2207,6 +2205,8 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   else
     glFlush ();
 
+  hidgl_finish_render ();
+
   /* end drawing to current GL-context */
   gport->render_priv->in_context = false;
   gdk_gl_drawable_gl_end (pGlDrawable);
@@ -2265,6 +2265,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   if (!gdk_gl_drawable_gl_begin (gldrawable, glcontext)) {
     return NULL;
   }
+  hidgl_start_render ();
   gport->render_priv->in_context = true;
 
   glEnable (GL_BLEND);
@@ -2292,7 +2293,6 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   hidgl_reset_stencil_usage ();
 
   /* call the drawing routine */
-  hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
   glPushMatrix ();
   glScalef ((gport->view.flip_x ? -1. : 1.) / gport->view.coord_per_px,
@@ -2319,6 +2319,8 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
 
   glFlush ();
 
+  hidgl_finish_render ();
+
   /* end drawing to current GL-context */
   gport->render_priv->in_context = false;
   gdk_gl_drawable_gl_end (gldrawable);
@@ -2345,6 +2347,7 @@ ghid_request_debug_draw (void)
   gtk_widget_get_allocation (widget, &allocation);
 
   ghid_start_drawing (port);
+  hidgl_start_render ();
 
   glViewport (0, 0, allocation.width, allocation.height);
 
@@ -2355,7 +2358,6 @@ ghid_request_debug_draw (void)
   glLoadIdentity ();
   glTranslatef (0.0f, 0.0f, -Z_NEAR);
 
-  hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
 
   /* Setup stenciling */
@@ -2393,6 +2395,7 @@ ghid_finish_debug_draw (void)
   hidgl_flush_triangles (&buffer);
   glPopMatrix ();
 
+  hidgl_finish_render ();
   ghid_end_drawing (gport);
 }

Bottom: c5882c19beacfd53f5ad72082476dde4ab6a0093
Top:    8a75bbeda3d5d1f046c437ac479b908f19c94a96
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-11-17 04:05:08 +0000

Play with shaders


---

diff --git a/src/board_texture.png b/src/board_texture.png
new file mode 100644
index 0000000000000000000000000000000000000000..0fcaa283f53f316008ff58166cd677bf098e839e
GIT binary patch
literal 8630
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

literal 0
HcmV?d00001

diff --git a/src/bumps.png b/src/bumps.png
new file mode 120000
index 0000000..c0b7227
--- /dev/null
+++ b/src/bumps.png
@@ -0,0 +1 @@
+smooth.png
\ No newline at end of file
diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index d8cae7f..46b7b78 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -1033,23 +1033,22 @@ hidgl_load_frag_shader (void)
                     "\n"
                     "void main()\n"
                     "{\n"
+                    "  vec3 bumpNormal = texture2D (bump_tex, gl_TexCoord[1].st).rgb;\n"
                     "  vec3 detailColor = texture1D (detail_tex, gl_TexCoord[0].s).rgb;\n"
-                    "  vec3 bumpHeight = texture2D (bump_tex, gl_TexCoord[1].st).rgb;\n"
                     "\n"
                     "  /* Uncompress vectors ([0, 1] -> [-1, 1]) */\n"
-                    "  vec3 lightVectorFinal = 2.0 * (gl_Color.rgb - 0.5);\n"
-                    "  vec3 bumpNormalVectorFinal = 2.0 * (bumpHeight - 0.5);\n"
+                    "  vec3 lightVectorFinal = -1.0 + 2.0 * gl_Color.rgb;\n"
+                    "  vec3 bumpNormalVectorFinal = -1.0 + 2.0 * bumpNormal;\n"
+//                    "vec3 bumpNormalVectorFinal = vec3(0., 0., 1.);\n"
                     "\n"
                     "  /* Compute diffuse factor */\n"
 //                    "  float diffuse = clamp(dot(bumpNormalVectorFinal, lightVectorFinal),0.0, 1.0);\n"
-                    "  float diffuse = pow(clamp(dot(bumpNormalVectorFinal, lightVectorFinal),0.0, 1.0), 70);\n"
-                    "\n"
-//                    "  vec3 eye_light = vec3 (0.0, -0.5, 1.0);\n"
-//                    "  vec3 
-//                    ""
+                    "  float diffuse = pow(clamp(dot(bumpNormalVectorFinal, lightVectorFinal), 0.0, 1.0), 100.0);\n"
                     "\n"
 //                    "  gl_FragColor = vec4(clamp((diffuse * 1.0 + 0.0) * detailColor, 0.0, 1.0), 1.0);\n"
-                    "   gl_FragColor = vec4(detailColor + vec3(diffuse, diffuse, diffuse), 1.0);\n"
+                    "  gl_FragColor = vec4(detailColor + vec3(diffuse, diffuse, diffuse), 1.0);\n"
+//                    "   gl_FragColor = vec4(detailColor * (0.6 + 0.4 * diffuse), 1.0);\n"
+//                    "   gl_FragColor =vec4(gl_Color.rgb, 1);\n"
                     "}\n";
 
   /* Compile and load the program */
@@ -1067,6 +1066,8 @@ hidgl_load_frag_shader (void)
 #endif
 
 //  fs_source = file2string ("circular.frag");
+
+#if 1
   if (fs_source == NULL)
     return;
   fs = glCreateShader (GL_FRAGMENT_SHADER);
@@ -1082,7 +1083,7 @@ hidgl_load_frag_shader (void)
   printLog (sp);
 
   glUseProgram (sp);
-
+#endif
   {
   GLfloat waveTime = 0,
           waveWidth = 0.00001,
@@ -1104,8 +1105,6 @@ hidgl_load_frag_shader (void)
   sp2 = glCreateProgram ();
   glAttachShader (sp2, fs);
   glLinkProgram (sp2);
-  glUseProgram (sp2);
-
 }
 
 void
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index c14d33d..f3ca4d5 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -334,7 +334,7 @@ compute_offset (int x, int y, int width, int height)
 }
 
 static void
-load_texture_from_png (char *filename)
+load_texture_from_png (char *filename, bool bumpmap)
 {
   GError *error = NULL;
   GdkPixbuf *pixbuf;
@@ -372,37 +372,44 @@ load_texture_from_png (char *filename)
   new_pixels = malloc (width * height * 4);
 
   /* XXX: Move computing bump map out of the texture loading function */
-  for (y = 0; y < height; y++)
-    for (x = 0; x < width; x++) {
-      float r, g, b;
-      float lenvec;
-
-      float dx = (pixels[compute_offset (x + 1, y, width, height)] - pixels[compute_offset (x - 1, y, width, height)]) / 255.;
-      float dy = (pixels[compute_offset (x, y + 1, width, height)] - pixels[compute_offset (x, y - 1, width, height)]) / 255.;
-
-      r = -dx;
-      g = -dy;
-      b = 1.;
-      lenvec = sqrt (r * r + g * g + b * b);
-
-      r /= lenvec;
-      g /= lenvec;
-      b /= lenvec;
-
-      new_pixels [compute_offset (x, y, width, height) + 0] =
-        (unsigned char)((r / 2. + 0.5) * 255.);
-      new_pixels [compute_offset (x, y, width, height) + 1] =
-        (unsigned char)((g / 2. + 0.5) * 255.);
-      new_pixels [compute_offset (x, y, width, height) + 2] =
-        (unsigned char)((b / 2. + 0.5) * 255.);
-      new_pixels [compute_offset (x, y, width, height) + 3] = 255;
-    }
+  if (bumpmap) {
+    for (y = 0; y < height; y++)
+      for (x = 0; x < width; x++) {
+        float r, g, b;
+        float lenvec;
+
+        float dx = (pixels[compute_offset (x + 1, y, width, height)] - pixels[compute_offset (x - 1, y, width, height)]) / 255.;
+        float dy = (pixels[compute_offset (x, y + 1, width, height)] - pixels[compute_offset (x, y - 1, width, height)]) / 255.;
+
+#if 0
+        dx *= 10.;
+        dy *= 10.;
+#endif
+
+        r = -dx;
+        g = -dy;
+        b = 1.;
+        lenvec = sqrt (r * r + g * g + b * b);
+
+        r /= lenvec;
+        g /= lenvec;
+        b /= lenvec;
+
+        new_pixels [compute_offset (x, y, width, height) + 0] =
+          (unsigned char)((r / 2. + 0.5) * 255.);
+        new_pixels [compute_offset (x, y, width, height) + 1] =
+          (unsigned char)((g / 2. + 0.5) * 255.);
+        new_pixels [compute_offset (x, y, width, height) + 2] =
+          (unsigned char)((b / 2. + 0.5) * 255.);
+        new_pixels [compute_offset (x, y, width, height) + 3] = 255;
+      }
 
-  memcpy (pixels, new_pixels, width * height * 4);
-  gdk_pixbuf_save (pixbuf, "debug_bumps.png", "png", NULL, NULL);
+    memcpy (pixels, new_pixels, width * height * 4);
+    gdk_pixbuf_save (pixbuf, "debug_bumps.png", "png", NULL, NULL);
+  }
 
   glTexImage2D (GL_TEXTURE_2D, 0, GL_RGB, width, height, 0,
-                (n_channels == 4) ? GL_RGBA : GL_RGB, GL_UNSIGNED_BYTE, new_pixels);
+                (n_channels == 4) ? GL_RGBA : GL_RGB, GL_UNSIGNED_BYTE, pixels);
 
   free (new_pixels);
   g_object_unref (pixbuf);
@@ -426,27 +433,133 @@ setup_resistor_texture (GLfloat *body_color, float value)
 
 //  glGenTextures (1, &texture);
 //  glBindTexture (GL_TEXTURE_1D, texture);
-  glTexImage1D (GL_TEXTURE_1D, 0, GL_RGB, 10, 1, GL_RGB, GL_FLOAT, tex_data);
+  glTexImage1D (GL_TEXTURE_1D, 0, GL_RGB, 10, 0, GL_RGB, GL_FLOAT, tex_data);
 }
 
 static void invert_4x4 (float m[4][4], float out[4][4]);
 
+static GLfloat *debug_lines = NULL;
+static int no_debug_lines = 0;
+static int max_debug_lines = 0;
+
+#define LENG 1000
+#define STRIDE_FLOATS 6
+static void
+debug_basis_vector (float x,   float y,   float z,
+                    float b1x, float b1y, float b1z,
+                    float b2x, float b2y, float b2z,
+                    float b3x, float b3y, float b3z)
+{
+  int comp_count;
+  float lenb1, lenb2, lenb3;
+
+  if (no_debug_lines + 3 > max_debug_lines) {
+    max_debug_lines += 10;
+    debug_lines = realloc (debug_lines, max_debug_lines * sizeof (GLfloat) * 2 * STRIDE_FLOATS);
+  }
+
+  b3x = -b1y * b2z + b1z * b2y;
+  b3y = -b1z * b2x + b1x * b2z;
+  b3z = -b1x * b2y + b1y * b2x;
+
+  lenb1 = sqrt (b1x * b1x + b1y * b1y + b1z * b1z);
+  lenb2 = sqrt (b2x * b2x + b2y * b2y + b2z * b2z);
+  lenb3 = sqrt (b3x * b3x + b3y * b3y + b3z * b3z);
+  b1x /= lenb1;  b1y /= lenb1;  b1z /= lenb1;
+  b2x /= lenb2;  b2y /= lenb2;  b2z /= lenb2;
+  b3x /= lenb3;  b3y /= lenb3;  b3z /= lenb3;
+
+  comp_count = 0;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = x;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = y;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = z;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 1.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = x + b1x * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = y + b1y * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = z + b1z * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 1.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  no_debug_lines++;
+
+  comp_count = 0;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = x;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = y;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = z;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 1.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = x + b2x * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = y + b2y * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = z + b2z * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 1.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  no_debug_lines++;
+
+  comp_count = 0;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = x;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = y;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = z;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 1.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = x + b3x * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = y + b3y * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = z + b3z * LENG;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 0.;
+  debug_lines [no_debug_lines * 2 * STRIDE_FLOATS + comp_count++] = 1.;
+  no_debug_lines++;
+}
+
+static void
+debug_basis_display ()
+{
+  if (no_debug_lines == 0)
+    return;
+
+#if 0
+  glPushAttrib (GL_CURRENT_BIT);
+  glColor4f (1., 1., 1., 1.);
+  glVertexPointer (3, GL_FLOAT, STRIDE_FLOATS * sizeof (GLfloat), &debug_lines[0]);
+  glColorPointer (3, GL_FLOAT, STRIDE_FLOATS * sizeof (GLfloat), &debug_lines[3]);
+  glEnableClientState (GL_VERTEX_ARRAY);
+  glEnableClientState (GL_COLOR_ARRAY);
+  glDrawArrays (GL_LINES, 0, no_debug_lines * 2);
+  glDisableClientState (GL_COLOR_ARRAY);
+  glDisableClientState (GL_VERTEX_ARRAY);
+  glPopAttrib ();
+#endif
+
+  free (debug_lines);
+  debug_lines = NULL;
+  no_debug_lines = 0;
+  max_debug_lines = 0;
+}
+
 /* b1{x,y,z} is the basis vector along "s" texture space */
 /* b2{x,y,z} is the basis vector along "t" texture space */
 static void
 compute_light_vector (float b1x, float b1y, float b1z,
                       float b2x, float b2y, float b2z,
-                      float *lx, float *ly, float *lz)
+                      float *lx, float *ly, float *lz,
+                      float x,   float y,   float z)
 {
   float tb1x, tb1y, tb1z;
   float tb2x, tb2y, tb2z;
   float tb3x, tb3y, tb3z;
   float mvm[16]; /* NB: TRANSPOSED IN MEMORY */
-  float light_direction[] = {0., 0.5, -1. /* + 1.0 */}; /* XXX: HARDCODEED! */
+//  float light_direction[] = {-0.5, 1., -1.}; /* XXX: HARDCODEED! */
+  float light_direction[] = {0., 0.5, -1.}; /* XXX: HARDCODEED! */
   float texspace_to_eye[4][4];
   float eye_to_texspace[4][4];
-  float lenb1, lenb2;
+  float lenb1, lenb2, lenb3;
 
+  debug_basis_vector (x, y, z, b1x, b1y, b1z, b2x, b2y, b2z, 0., 0., 0.);
+#if 1
   float len_light;
   len_light = sqrt (light_direction[0] * light_direction[0] + light_direction[1] * light_direction[1] + light_direction[2] * light_direction[2]);
   light_direction[0] /= len_light;
@@ -460,32 +573,35 @@ compute_light_vector (float b1x, float b1y, float b1z,
   light_direction[0] += 0. / 2.;
   light_direction[1] += 0. / 2.;
   light_direction[2] += -1. / 2.;
+#endif
 
   /* XXX: Should cache this ourselves */
   glGetFloatv (GL_MODELVIEW_MATRIX, (GLfloat *)mvm);
 
   /* Transform the S, T texture space bases into eye coordinates */
-  tb1x = mvm[0] * b1x + mvm[4] * b1y + mvm[ 8] * b1z;// + mvm[12] * 1;
-  tb1y = mvm[1] * b1x + mvm[5] * b1y + mvm[ 9] * b1z;// + mvm[13] * 1;
-  tb1z = mvm[2] * b1x + mvm[6] * b1y + mvm[10] * b1z;// + mvm[14] * 1;
+  tb1x = mvm[0] * b1x + mvm[4] * b1y + mvm[ 8] * b1z; // + mvm[12] * 1;
+  tb1y = mvm[1] * b1x + mvm[5] * b1y + mvm[ 9] * b1z; // + mvm[13] * 1;
+  tb1z = mvm[2] * b1x + mvm[6] * b1y + mvm[10] * b1z; // + mvm[14] * 1;
   // tb1w = mvm[3] * b1x + mvm[7] * b1y + mvm[11] * b1z + mvm[15] * 1;
 
-  tb2x = mvm[0] * b2x + mvm[4] * b2y + mvm[ 8] * b2z;// + mvm[12] * 1;
-  tb2y = mvm[1] * b2x + mvm[5] * b2y + mvm[ 9] * b2z;// + mvm[13] * 1;
-  tb2z = mvm[2] * b2x + mvm[6] * b2y + mvm[10] * b2z;// + mvm[14] * 1;
+  tb2x = mvm[0] * b2x + mvm[4] * b2y + mvm[ 8] * b2z; // + mvm[12] * 1;
+  tb2y = mvm[1] * b2x + mvm[5] * b2y + mvm[ 9] * b2z; // + mvm[13] * 1;
+  tb2z = mvm[2] * b2x + mvm[6] * b2y + mvm[10] * b2z; // + mvm[14] * 1;
   // tb2w = mvm[3] * b2x + mvm[7] * b2y + mvm[11] * b2z + mvm[15] * 1;
 
-  /* Normalise tb1 and tb2 */
-  lenb1 = sqrt (tb1x * tb1x + tb1y * tb1y + tb1z * tb1z);
-  lenb2 = sqrt (tb2x * tb2x + tb2y * tb2y + tb2z * tb2z);
-  tb1x /= lenb1;  tb1y /= lenb1;  tb1z /= lenb1;
-  tb2x /= lenb2;  tb2y /= lenb2;  tb2z /= lenb2;
-
   /* Third basis vector is the cross product of tb1 and tb2 */
   tb3x = tb1y * tb2z - tb1z * tb2y;
   tb3y = tb1z * tb2x - tb1x * tb2z;
   tb3z = tb1x * tb2y - tb1y * tb2x;
 
+  /* Normalise tb1, tb2 and tb3 */
+  lenb1 = sqrt (tb1x * tb1x + tb1y * tb1y + tb1z * tb1z);
+  lenb2 = sqrt (tb2x * tb2x + tb2y * tb2y + tb2z * tb2z);
+  lenb3 = sqrt (tb3x * tb3x + tb3y * tb3y + tb3z * tb3z);
+  tb1x /= lenb1;  tb1y /= lenb1;  tb1z /= lenb1;
+  tb2x /= lenb2;  tb2y /= lenb2;  tb2z /= lenb2;
+  tb3x /= lenb3;  tb3y /= lenb3;  tb3z /= lenb3;
+
   texspace_to_eye[0][0] = tb1x; texspace_to_eye[0][1] = tb2x; texspace_to_eye[0][2] = tb3x;  texspace_to_eye[0][3] = 0.0;
   texspace_to_eye[1][0] = tb1y; texspace_to_eye[1][1] = tb2y; texspace_to_eye[1][2] = tb3y;  texspace_to_eye[1][3] = 0.0;
   texspace_to_eye[2][0] = tb1z; texspace_to_eye[2][1] = tb2z; texspace_to_eye[2][2] = tb3z;  texspace_to_eye[2][3] = 0.0;
@@ -526,12 +642,57 @@ compute_light_vector (float b1x, float b1y, float b1z,
   }
 }
 
+static void
+emit_vertex (float x,   float y,   float z,
+             float b1x, float b1y, float b1z,
+             float b2x, float b2y, float b2z,
+             float tex0_s, float tex1_s, float tex1_t)
+{
+  GLfloat lx, ly, lz;
+  compute_light_vector (b1x, b1y, b1z, b2x, b2y, b2z, &lx, &ly, &lz, x, y, z);
+  glColor3f (lx, ly, lz);
+  glMultiTexCoord1f (GL_TEXTURE0, tex0_s);
+  glMultiTexCoord2f (GL_TEXTURE1, tex1_s, tex1_t);
+  glVertex3f (x, y, z);
+}
+
+enum geom_pos {
+  FIRST,
+  MIDDLE,
+  LAST
+};
+
+#define REPS 4.
+#define REPT 4.
+
+static void
+emit_pair (float ang_edge1, float cos_edge1, float sin_edge1,
+           float ang_edge2, float cos_edge2, float sin_edge2,
+           float prev_r, float prev_z,
+           float      r, float      z,
+           float next_r, float next_z,
+           float tex0_s, float resistor_width,
+           enum geom_pos pos)
+{
+  int repeat;
+
+  for (repeat = 0; repeat < ((pos == FIRST) ? 2 : 1); repeat++)
+    emit_vertex (r * cos_edge1, r * sin_edge1, z,
+                 sin_edge1, -cos_edge1, 0,
+                 cos_edge1 * (next_r - prev_r) / 2., sin_edge1 * (next_r - prev_r) / 2., (next_z - prev_z) / 2.,
+                 tex0_s, (z / resistor_width + 0.5) * REPS, (ang_edge1 / 2. / M_PI) * REPT);
+
+  for (repeat = 0; repeat < ((pos == LAST) ? 2 : 1); repeat++)
+    emit_vertex (r * cos_edge2, r * sin_edge2, z,
+                 sin_edge2, -cos_edge2, 0,
+                 cos_edge2 * (next_r - prev_r) / 2., sin_edge2 * (next_r - prev_r) / 2., (next_z - prev_z) / 2.,
+                 tex0_s, (z / resistor_width + 0.5) * REPS, (ang_edge2 / 2. / M_PI) * REPT);
+}
+
 
 #define NUM_RESISTOR_STRIPS 100
 #define NUM_PIN_RINGS 15
 #define MIL_TO_INTERNAL 100.
-#define REPS 4.
-#define REPT 4.
 
 static void
 ghid_draw_acy_resistor (ElementType *element)
@@ -550,8 +711,8 @@ ghid_draw_acy_resistor (ElementType *element)
 //  float lx, ly, lz;
 
   static bool first_run = true;
-  static int texture1;
-  static int texture2;
+  static GLuint texture1;
+  static GLuint texture2;
 
   extern GLuint sp;
   extern GLuint sp2;
@@ -615,7 +776,7 @@ ghid_draw_acy_resistor (ElementType *element)
   if (first_run) {
     glGenTextures (1, &texture2);
     glBindTexture (GL_TEXTURE_2D, texture2);
-    load_texture_from_png ("bumps.png");
+    load_texture_from_png ("bumps.png", true);
   } else {
     glBindTexture (GL_TEXTURE_2D, texture2);
   }
@@ -624,6 +785,7 @@ ghid_draw_acy_resistor (ElementType *element)
   glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
   glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
   glEnable (GL_TEXTURE_2D);
+  glActiveTextureARB (GL_TEXTURE0_ARB);
 
   /* COLOR / MATERIAL SETUP */
 //  glColorMaterial (GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
@@ -644,305 +806,55 @@ ghid_draw_acy_resistor (ElementType *element)
     glMaterialfv (GL_FRONT_AND_BACK, GL_SHININESS, &shininess);
   }
 
-#if 0
-#define WIDTH 4000
-#define LENGTH 10000
-
-  glBegin (GL_TRIANGLE_STRIP);
-    compute_light_vector (1, 0, 0, 0, 0, 1, &lx, &ly, &lz);
-    glColor3f (lx, ly, lz);
-    glMultiTexCoord1f (GL_TEXTURE0, 0.);
-    glMultiTexCoord2f (GL_TEXTURE1, REPS, -REPT);
-    glVertex3f (WIDTH, 0., -LENGTH);
-
-    compute_light_vector (1, 0, 0, 0, 0, 1, &lx, &ly, &lz);
-    glColor3f (lx, ly, lz);
-    glMultiTexCoord1f (GL_TEXTURE0, 1.);
-    glMultiTexCoord2f (GL_TEXTURE1, REPS, REPT);
-    glVertex3f (WIDTH, 0., LENGTH);
-
-    compute_light_vector (1, 0, 0, 0, 0, 1, &lx, &ly, &lz);
-    glColor3f (lx, ly, lz);
-    glMultiTexCoord1f (GL_TEXTURE0, 0.);
-    glMultiTexCoord2f (GL_TEXTURE1, -REPS, -REPT);
-    glVertex3f (-WIDTH, 0., -LENGTH);
-
-    compute_light_vector (1, 0, 0, 0, 0, 1, &lx, &ly, &lz);
-    glColor3f (lx, ly, lz);
-    glMultiTexCoord1f (GL_TEXTURE0, 1.);
-    glMultiTexCoord2f (GL_TEXTURE1, -REPS, REPT);
-    glVertex3f (-WIDTH, 0., LENGTH);
-#endif
-
 #if 1
   glBegin (GL_TRIANGLE_STRIP);
 
   for (strip = 0; strip < no_strips; strip++) {
 
-    float angle_strip_edge1 = strip * 2. * M_PI / no_strips;
-    float angle_strip_edge2 = (strip + 1) * 2. * M_PI / no_strips;
-
-    float x_strip_edge1 = cosf (angle_strip_edge1);
-    float y_strip_edge1 = sinf (angle_strip_edge1);
-    float x_strip_edge2 = cosf (angle_strip_edge2);
-    float y_strip_edge2 = sinf (angle_strip_edge2);
-    float z;
-    float r;
-
-    float lx, ly, lz;
-
-    z = -resistor_width / 2.;
-    r = resistor_pin_radius;
-    /* repeat first vertex */
-    compute_light_vector (y_strip_edge1, -x_strip_edge1, 0,
-                          y_strip_edge1 * (resistor_barrel_radius - resistor_pin_radius), -x_strip_edge1 * (resistor_barrel_radius - resistor_pin_radius), resistor_bulge_offset,
-                          &lx, &ly, &lz);
-    glColor3f (lx, ly, lz);
-    glMultiTexCoord1f (GL_TEXTURE0, 0.);
-    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
-                                    (angle_strip_edge1 / 2. / M_PI) * REPT);
-    glNormal3f (0., 0., -1.);
-    glVertex3f (r * x_strip_edge1, r * y_strip_edge1, z);
-    compute_light_vector (y_strip_edge1, -x_strip_edge1, 0,
-                          y_strip_edge1 * (resistor_barrel_radius - resistor_pin_radius), -x_strip_edge1 * (resistor_barrel_radius - resistor_pin_radius), resistor_bulge_offset,
-                          &lx, &ly, &lz);
-    glColor3f (lx, ly, lz);
-    glMultiTexCoord1f (GL_TEXTURE0, 0.);
-    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
-                                    (angle_strip_edge1 / 2. / M_PI) * REPT);
-    glNormal3f (0., 0., -1.);
-    glVertex3f (r * x_strip_edge1, r * y_strip_edge1, z);
-    compute_light_vector (y_strip_edge2, -x_strip_edge2, 0,
-                          y_strip_edge2 * (resistor_barrel_radius - resistor_pin_radius), -x_strip_edge2 * (resistor_barrel_radius - resistor_pin_radius), resistor_bulge_offset,
-                          &lx, &ly, &lz);
-    glColor3f (lx, ly, lz);
-    glMultiTexCoord1f (GL_TEXTURE0, 0.);
-    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
-                                    (angle_strip_edge2 / 2. / M_PI) * REPT);
-    glNormal3f (0., 0., -1.);
-    glVertex3f (r * x_strip_edge2, r * y_strip_edge2, z);
-
-
-
-    z = -resistor_width / 2. + resistor_bulge_offset;
-    r = resistor_barrel_radius;
-    compute_light_vector (y_strip_edge1, -x_strip_edge1, 0,
-                          y_strip_edge1 * (resistor_bulge_radius - resistor_barrel_radius), -x_strip_edge1 * (resistor_bulge_radius - resistor_barrel_radius), resistor_bulge_width * 1. / 4.,
-                          &lx, &ly, &lz);
-    glColor3f (lx, ly, lz);
-    glMultiTexCoord1f (GL_TEXTURE0, 0.);
-    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
-                                    (angle_strip_edge1 / 2. / M_PI) * REPT);
-    glNormal3f (x_strip_edge1, y_strip_edge1, 0.);
-    glVertex3f (r * x_strip_edge1, r * y_strip_edge1, z);
-    compute_light_vector (y_strip_edge2, -x_strip_edge2, 0,
-                          y_strip_edge2 * (resistor_bulge_radius - resistor_barrel_radius), -x_strip_edge2 * (resistor_bulge_radius - resistor_barrel_radius), resistor_bulge_width * 1. / 4.,
-                          &lx, &ly, &lz);
-    glColor3f (lx, ly, lz);
-    glMultiTexCoord1f (GL_TEXTURE0, 0.);
-    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
-                                    (angle_strip_edge2 / 2. / M_PI) * REPT);
-    glNormal3f (x_strip_edge2, y_strip_edge2, 0.);
-    glVertex3f (r * x_strip_edge2, r * y_strip_edge2, z);
-
-
-
-    z = -resistor_width / 2. + resistor_bulge_offset + resistor_bulge_width * 1. / 4.;
-    r = resistor_bulge_radius;
-    compute_light_vector (y_strip_edge1, -x_strip_edge1, 0,
-                          0, 0, 1,
-                          &lx, &ly, &lz);
-    glColor3f (lx, ly, lz);
-    glMultiTexCoord1f (GL_TEXTURE0, 0.);
-    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
-                                    (angle_strip_edge1 / 2. / M_PI) * REPT);
-    glNormal3f (x_strip_edge1, y_strip_edge1, 0.);
-    glVertex3f (r * x_strip_edge1, r * y_strip_edge1, z);
-    compute_light_vector (y_strip_edge2, -x_strip_edge2, 0,
-                          0, 0, 1,
-                          &lx, &ly, &lz);
-    glColor3f (lx, ly, lz);
-    glMultiTexCoord1f (GL_TEXTURE0, 0.);
-    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
-                                    (angle_strip_edge2 / 2. / M_PI) * REPT);
-    glNormal3f (x_strip_edge2, y_strip_edge2, 0.);
-    glVertex3f (r * x_strip_edge2, r * y_strip_edge2, z);
-
-
-
-    z = -resistor_width / 2. + resistor_bulge_offset + resistor_bulge_width * 3. / 4.;
-    r = resistor_bulge_radius;
-    compute_light_vector (y_strip_edge1, -x_strip_edge1, 0,
-                          y_strip_edge1 * (resistor_barrel_radius - resistor_bulge_radius), -x_strip_edge2 * (resistor_barrel_radius - resistor_bulge_radius), resistor_bulge_width * 1. / 4.,
-                          &lx, &ly, &lz);
-    glColor3f (lx, ly, lz);
-    glMultiTexCoord1f (GL_TEXTURE0, 0.);
-    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
-                                    (angle_strip_edge1 / 2. / M_PI) * REPT);
-//    glNormal3f (x_strip_edge1, y_strip_edge1, 0.);
-    glNormal3f (0., 0., 1.);
-    glVertex3f (r * x_strip_edge1, r * y_strip_edge1, z);
-    compute_light_vector (y_strip_edge2, -x_strip_edge2, 0,
-                          y_strip_edge2 * (resistor_barrel_radius - resistor_bulge_radius), -x_strip_edge2 * (resistor_barrel_radius - resistor_bulge_radius), resistor_bulge_width * 1. / 4.,
-                          &lx, &ly, &lz);
-    glColor3f (lx, ly, lz);
-    glMultiTexCoord1f (GL_TEXTURE0, 0.);
-    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
-                                    (angle_strip_edge2 / 2. / M_PI) * REPT);
-//    glNormal3f (x_strip_edge2, y_strip_edge2, 0.);
-    glNormal3f (0., 0., 1.);
-    glVertex3f (r * x_strip_edge2, r * y_strip_edge2, z);
-
-
-
-    z = -resistor_width / 2. + resistor_bulge_offset + resistor_bulge_width;
-    r = resistor_barrel_radius;
-    compute_light_vector (y_strip_edge1, -x_strip_edge1, 0,
-                          0, 0, 1,
-                          &lx, &ly, &lz);
-    glColor3f (lx, ly, lz);
-    glMultiTexCoord1f (GL_TEXTURE0, 0.);
-    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
-                                    (angle_strip_edge1 / 2. / M_PI) * REPT);
-    glNormal3f (x_strip_edge1, y_strip_edge1, 0.);
-    glVertex3f (r * x_strip_edge1, r * y_strip_edge1, z);
-    compute_light_vector (y_strip_edge2, -x_strip_edge2, 0,
-                          0, 0, 1,
-                          &lx, &ly, &lz);
-    glColor3f (lx, ly, lz);
-    glMultiTexCoord1f (GL_TEXTURE0, 0.);
-    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
-                                    (angle_strip_edge2 / 2. / M_PI) * REPT);
-    glNormal3f (x_strip_edge2, y_strip_edge2, 0.);
-    glVertex3f (r * x_strip_edge2, r * y_strip_edge2, z);
-
-
-
-    z = resistor_width / 2. - resistor_bulge_offset - resistor_bulge_width;
-    r = resistor_barrel_radius;
-    compute_light_vector (y_strip_edge1, -x_strip_edge1, 0,
-                          y_strip_edge1 * (resistor_bulge_radius - resistor_barrel_radius), -x_strip_edge1 * (resistor_bulge_radius - resistor_barrel_radius), resistor_bulge_width * 1. / 4.,
-                          &lx, &ly, &lz);
-    glColor3f (lx, ly, lz);
-    glMultiTexCoord1f (GL_TEXTURE0, 1.);
-    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
-                                    (angle_strip_edge1 / 2. / M_PI) * REPT);
-    glNormal3f (x_strip_edge1, y_strip_edge1, 0.);
-    glVertex3f (r * x_strip_edge1, r * y_strip_edge1, z);
-    compute_light_vector (y_strip_edge2, -x_strip_edge2, 0,
-                          y_strip_edge2 * (resistor_bulge_radius - resistor_barrel_radius), -x_strip_edge2 * (resistor_bulge_radius - resistor_barrel_radius), resistor_bulge_width * 1. / 4.,
-                          &lx, &ly, &lz);
-    glColor3f (lx, ly, lz);
-    glMultiTexCoord1f (GL_TEXTURE0, 1.);
-    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
-                                    (angle_strip_edge2 / 2. / M_PI) * REPT);
-    glNormal3f (x_strip_edge2, y_strip_edge2, 0.);
-    glVertex3f (r * x_strip_edge2, r * y_strip_edge2, z);
-
-
-
-    z = resistor_width / 2. - resistor_bulge_offset - resistor_bulge_width * 3. / 4.;
-    r = resistor_bulge_radius;
-    compute_light_vector (y_strip_edge1, -x_strip_edge1, 0,
-                          0, 0, 1,
-                          &lx, &ly, &lz);
-    glColor3f (lx, ly, lz);
-    glMultiTexCoord1f (GL_TEXTURE0, 1.);
-    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
-                                    (angle_strip_edge1 / 2. / M_PI) * REPT);
-//    glNormal3f (x_strip_edge1, y_strip_edge1, 0.);
-    glNormal3f (0., 0., -1.);
-    glVertex3f (r * x_strip_edge1, r * y_strip_edge1, z);
-    compute_light_vector (y_strip_edge2, -x_strip_edge2, 0,
-                          0, 0, 1,
-                          &lx, &ly, &lz);
-    glColor3f (lx, ly, lz);
-    glMultiTexCoord1f (GL_TEXTURE0, 1.);
-    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
-                                    (angle_strip_edge2 / 2. / M_PI) * REPT);
-//    glNormal3f (x_strip_edge2, y_strip_edge2, 0.);
-    glNormal3f (0., 0., -1.);
-    glVertex3f (r * x_strip_edge2, r * y_strip_edge2, z);
-
-
-
-    z = resistor_width / 2. - resistor_bulge_offset - resistor_bulge_width * 1. / 4.;
-    r = resistor_bulge_radius;
-    compute_light_vector (y_strip_edge1, -x_strip_edge1, 0,
-                          y_strip_edge1 * (resistor_barrel_radius - resistor_bulge_radius), -x_strip_edge1 * (resistor_barrel_radius - resistor_bulge_radius), resistor_bulge_width * 1. / 4.,
-                          &lx, &ly, &lz);
-    glColor3f (lx, ly, lz);
-    glMultiTexCoord1f (GL_TEXTURE0, 1.);
-    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
-                                    (angle_strip_edge1 / 2. / M_PI) * REPT);
-    glNormal3f (x_strip_edge1, y_strip_edge1, 0.);
-    glVertex3f (r * x_strip_edge1, r * y_strip_edge1, z);
-    compute_light_vector (y_strip_edge2, -x_strip_edge2, 0,
-                          y_strip_edge2 * (resistor_barrel_radius - resistor_bulge_radius), -x_strip_edge2 * (resistor_barrel_radius - resistor_bulge_radius), resistor_bulge_width * 1. / 4.,
-                          &lx, &ly, &lz);
-    glColor3f (lx, ly, lz);
-    glMultiTexCoord1f (GL_TEXTURE0, 1.);
-    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
-                                    (angle_strip_edge2 / 2. / M_PI) * REPT);
-    glNormal3f (x_strip_edge2, y_strip_edge2, 0.);
-    glVertex3f (r * x_strip_edge2, r * y_strip_edge2, z);
-
-
-
-    z = resistor_width / 2. - resistor_bulge_offset;
-    r = resistor_barrel_radius;
-    compute_light_vector (y_strip_edge1, -x_strip_edge1, 0,
-                          y_strip_edge1 * (resistor_pin_radius - resistor_barrel_radius), -x_strip_edge1 * (resistor_pin_radius - resistor_barrel_radius), resistor_bulge_offset,
-                          &lx, &ly, &lz);
-    glColor3f (lx, ly, lz);
-    glMultiTexCoord1f (GL_TEXTURE0, 1.);
-    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
-                                    (angle_strip_edge1 / 2. / M_PI) * REPT);
-    glNormal3f (x_strip_edge1, y_strip_edge1, 0.);
-    glVertex3f (r * x_strip_edge1, r * y_strip_edge1, z);
-    compute_light_vector (y_strip_edge2, -x_strip_edge2, 0,
-                          y_strip_edge2 * (resistor_pin_radius - resistor_barrel_radius), -x_strip_edge2 * (resistor_pin_radius - resistor_barrel_radius), resistor_bulge_offset,
-                          &lx, &ly, &lz);
-    glColor3f (lx, ly, lz);
-    glMultiTexCoord1f (GL_TEXTURE0, 1.);
-    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
-                                    (angle_strip_edge2 / 2. / M_PI) * REPT);
-    glNormal3f (x_strip_edge2, y_strip_edge2, 0.);
-    glVertex3f (r * x_strip_edge2, r * y_strip_edge2, z);
-
-
-
-    z = resistor_width / 2.;
-    r = resistor_pin_radius;
-    compute_light_vector (y_strip_edge1, -x_strip_edge1, 0,
-                          y_strip_edge1 * (resistor_pin_radius - resistor_barrel_radius), -x_strip_edge1 * (resistor_pin_radius - resistor_barrel_radius), resistor_bulge_offset,
-                          &lx, &ly, &lz);
-    glColor3f (lx, ly, lz);
-    glMultiTexCoord1f (GL_TEXTURE0, 1.);
-    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
-                                    (angle_strip_edge1 / 2. / M_PI) * REPT);
-    glNormal3f (0., 0., 1.);
-    glVertex3f (r * x_strip_edge1, r * y_strip_edge1, z);
-    compute_light_vector (y_strip_edge2, -x_strip_edge2, 0,
-                          y_strip_edge2 * (resistor_pin_radius - resistor_barrel_radius), -x_strip_edge2 * (resistor_pin_radius - resistor_barrel_radius), resistor_bulge_offset,
-                          &lx, &ly, &lz);
-    glColor3f (lx, ly, lz);
-    glMultiTexCoord1f (GL_TEXTURE0, 1.);
-    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
-                                    (angle_strip_edge2 / 2. / M_PI) * REPT);
-    glNormal3f (0., 0., 1.);
-    glVertex3f (r * x_strip_edge2, r * y_strip_edge2, z);
-    /* repeat last vertex */
-    compute_light_vector (y_strip_edge2, -x_strip_edge2, 0,
-                          y_strip_edge2 * (resistor_pin_radius - resistor_barrel_radius), -x_strip_edge2 * (resistor_pin_radius - resistor_barrel_radius), resistor_bulge_offset,
-                          &lx, &ly, &lz);
-    glColor3f (lx, ly, lz);
-    glMultiTexCoord1f (GL_TEXTURE0, 1.);
-    glMultiTexCoord2f (GL_TEXTURE1, (z / resistor_width + 0.5) * REPS,
-                                    (angle_strip_edge2 / 2. / M_PI) * REPT);
-    glNormal3f (0., 0., 1.);
-    glVertex3f (r * x_strip_edge2, r * y_strip_edge2, z);
-
+    int ring;
+    int no_rings;
+    float angle_edge1 = strip * 2. * M_PI / no_strips;
+    float angle_edge2 = (strip + 1) * 2. * M_PI / no_strips;
+
+    float cos_edge1 = cosf (angle_edge1);
+    float sin_edge1 = sinf (angle_edge1);
+    float cos_edge2 = cosf (angle_edge2);
+    float sin_edge2 = sinf (angle_edge2);
+
+    struct strip_item {
+      GLfloat z;
+      GLfloat r;
+      GLfloat tex0_s;
+    } strip_data[] = {
+      {-resistor_width / 2. - 1.,                                                     resistor_pin_radius,     0.}, /* DUMMY */
+      {-resistor_width / 2.,                                                          resistor_pin_radius,     0.},
+      {-resistor_width / 2. + resistor_bulge_offset,                                  resistor_barrel_radius,  0.},
+      {-resistor_width / 2. + resistor_bulge_offset + resistor_bulge_width * 1. / 4.,   resistor_bulge_radius, 0.},
+      {-resistor_width / 2. + resistor_bulge_offset + resistor_bulge_width * 3. / 4.,   resistor_bulge_radius, 0.},
+      {-resistor_width / 2. + resistor_bulge_offset + resistor_bulge_width,           resistor_barrel_radius,  0.},
+                                                                                      /*********************/
+                                                                                      /*********************/
+      { resistor_width / 2. - resistor_bulge_offset - resistor_bulge_width,           resistor_barrel_radius,  1.},
+      { resistor_width / 2. - resistor_bulge_offset - resistor_bulge_width * 3. / 4.,   resistor_bulge_radius, 1.},
+      { resistor_width / 2. - resistor_bulge_offset - resistor_bulge_width * 1. / 4.,   resistor_bulge_radius, 1.},
+      { resistor_width / 2. - resistor_bulge_offset,                                  resistor_barrel_radius,  1.},
+      { resistor_width / 2.,                                                          resistor_pin_radius,     1.},
+      { resistor_width / 2. + 1.,                                                     resistor_pin_radius,     1.}, /* DUMMY */
+    };
+
+    no_rings = sizeof (strip_data) / sizeof (struct strip_item);
+    for (ring = 1; ring < no_rings - 1; ring++) {
+      enum geom_pos pos = MIDDLE;
+      if (ring == 1)            pos = FIRST;
+      if (ring == no_rings - 2) pos = LAST;
+
+      emit_pair (angle_edge1, cos_edge1, sin_edge1,
+                 angle_edge2, cos_edge2, sin_edge2,
+                 strip_data[ring - 1].r, strip_data[ring - 1].z,
+                 strip_data[ring    ].r, strip_data[ring    ].z,
+                 strip_data[ring + 1].r, strip_data[ring + 1].z,
+                 strip_data[ring    ].tex0_s, resistor_width, pos);
+    }
   }
 #endif
 
@@ -958,13 +870,18 @@ ghid_draw_acy_resistor (ElementType *element)
 
   glUseProgram (0);
 
-  glColor3f (resistor_pin_color[0],
-             resistor_pin_color[1],
-             resistor_pin_color[2]);
+  glColor3f (resistor_pin_color[0] / 1.3,
+             resistor_pin_color[1] / 1.3,
+             resistor_pin_color[2] / 1.3);
+
+  /* COLOR / MATERIAL SETUP */
+  glColorMaterial (GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
+  glEnable (GL_COLOR_MATERIAL);
 
   if (1) {
+//    GLfloat ambient[] = {0.0, 0.0, 0.0, 1.0};
     GLfloat specular[] = {0.5, 0.5, 0.5, 1.0};
-    GLfloat shininess = 5.;
+    GLfloat shininess = 20.;
     glMaterialfv (GL_FRONT_AND_BACK, GL_SPECULAR, specular);
     glMaterialfv (GL_FRONT_AND_BACK, GL_SHININESS, &shininess);
   }
@@ -1056,11 +973,17 @@ ghid_draw_acy_resistor (ElementType *element)
     }
   }
 
+  glDisable (GL_COLOR_MATERIAL);
   glPopAttrib ();
+
+  glDisable (GL_LIGHTING);
+//  glDisable (GL_DEPTH_TEST);
+  debug_basis_display ();
+//  glEnable (GL_DEPTH_TEST);
+
   glPopMatrix ();
   glUseProgram (sp);
 
-  glDisable (GL_COLOR_MATERIAL);
 
   first_run = false;
 }
@@ -2125,6 +2048,10 @@ int clearPad_callback (const BoxType * b, void *cl);
 static void
 DrawMask (BoxType * screen)
 {
+  static bool first_run = true;
+  static GLuint texture;
+  extern GLuint sp;
+
   struct pin_info info;
   int thin = TEST_FLAG(THINDRAWFLAG, PCB) || TEST_FLAG(THINDRAWPOLYFLAG, PCB);
   PolygonType polygon;
@@ -2157,6 +2084,34 @@ DrawMask (BoxType * screen)
   gui->set_color (out->fgGC, PCB->MaskColor);
   ghid_global_alpha_mult (out->fgGC, thin ? 0.35 : 1.0);
 
+  if (first_run) {
+    glGenTextures (1, &texture);
+    glBindTexture (GL_TEXTURE_2D, texture);
+    load_texture_from_png ("board_texture.png", false);
+  } else {
+    glBindTexture (GL_TEXTURE_2D, texture);
+  }
+  glUseProgram (0);
+
+  if (1) {
+    GLfloat s_params[] = {0.0001, 0., 0., 0.};
+    GLfloat t_params[] = {0., 0.0001, 0., 0.};
+    GLint obj_lin = GL_OBJECT_LINEAR;
+    glTexGeniv (GL_S, GL_TEXTURE_GEN_MODE, &obj_lin);
+    glTexGeniv (GL_T, GL_TEXTURE_GEN_MODE, &obj_lin);
+    glTexGenfv (GL_S, GL_OBJECT_PLANE, s_params);
+    glTexGenfv (GL_T, GL_OBJECT_PLANE, t_params);
+    glEnable (GL_TEXTURE_GEN_S);
+    glEnable (GL_TEXTURE_GEN_T);
+  }
+
+  glTexEnvf (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
+  glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+  glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+  glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
+  glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
+  glEnable (GL_TEXTURE_2D);
+
   polygon.Clipped = board_outline_poly ();
   polygon.NoHoles = NULL;
   polygon.NoHolesValid = 0;
@@ -2170,8 +2125,16 @@ DrawMask (BoxType * screen)
 //  gui->fill_pcb_polygon (out->fgGC, &polygon, screen);
 //  gui->fill_rect (out->fgGC, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
   ghid_global_alpha_mult (out->fgGC, 1.0);
+  hidgl_flush_triangles (&buffer);
+  glDisable (GL_TEXTURE_GEN_S);
+  glDisable (GL_TEXTURE_GEN_T);
+  glBindTexture (GL_TEXTURE_2D, 0);
+  glDisable (GL_TEXTURE_2D);
+  glUseProgram (sp);
 
   gui->use_mask (HID_MASK_OFF);
+
+  first_run = false;
 }
 
 static int
@@ -2873,7 +2836,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glEnable (GL_LIGHT0);
 
   /* XXX: FIX OUR NORMALS */
-//  glEnable (GL_NORMALIZE);
+  glEnable (GL_NORMALIZE);
 //  glEnable (GL_RESCALE_NORMAL);
 
   glDepthFunc (GL_LESS);
@@ -2899,7 +2862,9 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   if (1) {
 //    GLfloat position[] = {1., -1., 1., 0.};
 //    GLfloat position[] = {1., -0.5, 1., 0.};
-    GLfloat position[] = {0., -0.5, 1., 0.};
+//    GLfloat position[] = {0., -1., 1., 0.};
+//    GLfloat position[] = {0.5, -1., 1., 0.};
+    GLfloat position[] = {0.0, -0.5, 1., 0.};
     GLfloat abspos = sqrt (position[0] * position[0] +
                            position[1] * position[1] +
                            position[2] * position[2]);
diff --git a/src/smooth.png b/src/smooth.png
new file mode 100644
index 0000000000000000000000000000000000000000..1df3e9c22b29e7fe691bce1c9203d63f9ead2028
GIT binary patch
literal 1919
zcmeAS@N?(olHy`uVBq!ia0y~yU;;9k7&zE~)R&4Yzkn2Dage(c!@6@aFM%AkByV>Y
zhW{YAVDIwDKoQOYkH}&M25w;xW@MN(M*=9wUgGKN%6^Mmh=rH=ru?4cKq1Kz*N775
z{M_8syb=cIqSVBa)D(sC%#sWRcTeAd@J2pypy{_fT^vIyZoR!`$jHFJaoFI%{^yBJ
z{Vq=H%O;61d^qI+RKmbuz`)P|l;&YzNC2A4%)kJ&@c@v8Uy4NK2up}E9ibfICTwDa
z-3io%FoG!Mh`>0&Fd9Pm18+2h2qmx45E>03Xi<tkE8!`5N7E2`8Y&m-vt<9Xv;X@>
P1|aZs^>bP0l+XkKg@3xI

literal 0
HcmV?d00001

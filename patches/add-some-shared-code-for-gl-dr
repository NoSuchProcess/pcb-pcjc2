Bottom: 5317d734747ab485224f309d80e317aa9791ebb5
Top:    d7122ab3aeb2abef2386a23dc468a7909e2bf56c
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-01-24 02:07:21 +0000

Add some shared code for GL drawing



---

diff --git a/configure.ac b/configure.ac
index 18ab959..0908316 100644
--- a/configure.ac
+++ b/configure.ac
@@ -261,6 +261,43 @@ $DBUS_PKG_ERRORS])]
 
 fi
 
+
+AC_MSG_CHECKING([for whether to use GL drawing])
+AC_ARG_ENABLE([gl],
+[  --enable-gl           Enable GL drawing (with GTK HID)],
+[],[enable_gl=no])
+
+AC_MSG_RESULT([$enable_gl])
+AM_CONDITIONAL(USE_GL, test x$enable_gl = xyes)
+
+if test "x$enable_gl" = "xyes"; then
+	case " $with_gui " in
+		*\ gtk\ *) ;;
+		* ) AC_MSG_ERROR([GL drawing enabled but only works with the GTK HID.
+Either do not use --enable-gl or enable the gtk HID.])
+	;;
+	esac
+
+# FIXME... what do we need to check for determining we have GL? Is it headers, API ?
+
+	AC_CHECK_HEADERS(GL/gl.h)
+	case $ac_cv_header_GL_glut_h in
+	  no )
+	    AC_MSG_ERROR([You don't seem to have the GL library headers installed.])
+	    ;;
+	  * ) ;;
+	esac
+
+	AC_CHECK_HEADERS(GL/glut.h)
+	case $ac_cv_header_GL_glut_h in
+	  no )
+	    AC_MSG_ERROR([You don't seem to have the GL glut library headers installed.])
+	    ;;
+	  * ) ;;
+	esac
+
+fi
+
 AC_MSG_CHECKING([for which printer to use])
 AC_ARG_WITH([printer],
 [  --with-printer= 	  Specify the printer: lpr [[default=lpr]]],
@@ -505,23 +542,16 @@ $GLIB_PKG_ERRORS])]
 	)
 	GLIB_VERSION=`$PKG_CONFIG glib-2.0 --modversion`
 
-
-	# Check for GtkGLExt
-	PKG_CHECK_MODULES(GTKGLEXT, gtkglext-1.0 >= 1.0.0, , [AC_MSG_ERROR([
+	if test "x$enable_gl" = "xyes"; then
+		# Check for GtkGLExt
+		PKG_CHECK_MODULES(GTKGLEXT, gtkglext-1.0 >= 1.0.0, , [AC_MSG_ERROR([
 *** Required version of gtkglext is not installed - please install first ***
 Please review the following errors:
 $GTKGLEXT_PKG_ERRORS])]
-	)
-
+		)
 	GTKGLEXT_VER=`$PKG_CONFIG gtkglext-1.0 --modversion`
+	fi
 
-	AC_CHECK_HEADERS(GL/glut.h)
-	case $ac_cv_header_GL_glut_h in
-	  no )
-	    AC_MSG_ERROR([You don't seem to have the GL glut library headers installed.])
-	    ;;
-	  * ) ;;
-	esac
 	;;
 
       nelma|png )
diff --git a/doc/actions.texi b/doc/actions.texi
index f8c4261..0a22627 100644
--- a/doc/actions.texi
+++ b/doc/actions.texi
@@ -1,5 +1,5 @@
 @c key actions
-@c ./../src/action.c 211
+@c ./../src/action.c 212
 
 Many actions take a @code{delta} parameter as the last parameter,
 which is an amount to change something.  That @code{delta} may include
@@ -18,7 +18,7 @@ Action(Object,-1)
 Actions which take a @code{delta} parameter which do not accept all
 these options will specify what they do take.
 
-@c ./../src/action.c 215
+@c ./../src/action.c 216
 
 @macro pinshapes
 
@@ -46,7 +46,7 @@ is documented for that purpose.
 
 @end macro
 
-@c ./../src/action.c 213
+@c ./../src/action.c 214
 
 Many actions act on indicated objects on the board.  They will have
 parameters like @code{ToggleObject} or @code{SelectedVias} to indicate
@@ -128,6 +128,7 @@ Affects all objects which are both selected and of the @var{Type} specified.
 * m Action:: Loads a layout into the current buffer.
 * MarkCrosshair Action:: Set/Reset the Crosshair mark
 * Message Action:: Writes a message to the log window.
+* MinClearGap Action:: Ensures that polygons are a minimum distance from objects.
 * MinMaskGap Action:: Ensures the mask is a minimum distance from pins and pads.
 * Mode Action:: Change or use the tool mode.
 * MorphPolygon Action:: Converts dead polygon islands into separate polygons.
@@ -185,7 +186,7 @@ AddRats(AllRats|SelectedRats|Close)@end format
 @end cartouche
 
 Add one or more rat lines to the board.
-@c ./../src/action.c 3194
+@c ./../src/action.c 3203
 
 @table @code
 
@@ -229,7 +230,7 @@ Atomic(Save|Restore|Close|Block)@end format
 @end cartouche
 
 Save or restore the undo serial number.
-@c ./../src/action.c 1605
+@c ./../src/action.c 1607
 
 This action allows making multiple-action bindings into an atomic
 operation that will be undone by a single Undo command.  For example,
@@ -269,7 +270,7 @@ AutoPlaceSelected()@end format
 @end cartouche
 
 Auto-place selected components.
-@c ./../src/action.c 3341
+@c ./../src/action.c 3350
 
 Attempts to re-arrange the selected components such that the nets
 connecting them are minimized.  Note that you cannot undo this.
@@ -284,7 +285,7 @@ AutoRoute(AllRats|SelectedRats)@end format
 @end cartouche
 
 Auto-route some or all rat lines.
-@c ./../src/action.c 3364
+@c ./../src/action.c 3373
 
 @table @code
 
@@ -318,7 +319,7 @@ ChangeClearSize(Selected|SelectedObjects, delta)@end format
 @end cartouche
 
 Changes the clearance size of objects.
-@c ./../src/action.c 3582
+@c ./../src/action.c 3591
 
 If the solder mask is currently showing, this action changes the
 solder mask clearance.  If the mask is not showing, this action
@@ -335,7 +336,7 @@ ChangeDrillSize(SelectedPins|SelectedVias|Selected|SelectedObjects, delta)@end f
 @end cartouche
 
 Changes the drilling hole size of objects.
-@c ./../src/action.c 3524
+@c ./../src/action.c 3533
 
 
 @node ChangeFlag Action
@@ -352,7 +353,7 @@ flag = square | octagon | thermal | join
 @end cartouche
 
 Sets or clears flags on objects.
-@c ./../src/action.c 5561
+@c ./../src/action.c 5668
 
 Toggles the given flag on the indicated object(s).  The flag may be
 one of the flags listed above (square, octagon, thermal, join).  The
@@ -369,7 +370,7 @@ ChangeHole(ToggleObject|Object|SelectedVias|Selected)@end format
 @end cartouche
 
 Changes the hole flag of objects.
-@c ./../src/action.c 4385
+@c ./../src/action.c 4492
 
 The "hole flag" of a via determines whether the via is a
 plated-through hole (not set), or an unplated hole (set).
@@ -384,7 +385,7 @@ ChangeJoin(ToggleObject|SelectedLines|SelectedArcs|Selected)@end format
 @end cartouche
 
 Changes the join (clearance through polygons) of objects.
-@c ./../src/action.c 3999
+@c ./../src/action.c 4106
 
 The join flag determines whether a line or arc, drawn to intersect a
 polygon, electrically connects to the polygon or not.  When joined,
@@ -403,7 +404,7 @@ ChangeName(Object)
 @end cartouche
 
 Sets the name of objects.
-@c ./../src/action.c 3802
+@c ./../src/action.c 3909
 
 @table @code
 
@@ -429,7 +430,7 @@ ChangeOctagon(SelectedElements|SelectedPins|SelectedVias)@end format
 @end cartouche
 
 Changes the octagon-flag of pins and vias.
-@c ./../src/action.c 4211
+@c ./../src/action.c 4318
 
 @pinshapes
 
@@ -443,7 +444,7 @@ ChangePaste(ToggleObject|Object|SelectedPads|Selected)@end format
 @end cartouche
 
 Changes the no paste flag of objects.
-@c ./../src/action.c 4427
+@c ./../src/action.c 4534
 
 The "no paste flag" of a pad determines whether the solderpaste
  stencil will have an opening for the pad (no set) or if there wil be
@@ -460,7 +461,7 @@ ChangePinName(ElementName,PinNumber,PinName)@end format
 @end cartouche
 
 Sets the name of a specific pin on a specific element.
-@c ./../src/action.c 3726
+@c ./../src/action.c 3833
 
 This can be especially useful for annotating pin names from a
 schematic to the layout without requiring knowledge of the pcb file
@@ -484,7 +485,7 @@ ChangeSize(SelectedElements, delta)@end format
 @end cartouche
 
 Changes the size of objects.
-@c ./../src/action.c 3435
+@c ./../src/action.c 3444
 
 For lines and arcs, this changes the width.  For pins and vias, this
 changes the overall diameter of the copper annulus.  For pads, this
@@ -504,7 +505,7 @@ ChangeSquare(Selected|SelectedObjects)@end format
 @end cartouche
 
 Changes the square flag of pins and pads.
-@c ./../src/action.c 4052
+@c ./../src/action.c 4159
 
 Note that @code{Pins} means both pins and pads.
 
@@ -521,7 +522,7 @@ ClearOctagon(SelectedElements|SelectedPins|SelectedVias)@end format
 @end cartouche
 
 Clears the octagon-flag of pins and vias.
-@c ./../src/action.c 4327
+@c ./../src/action.c 4434
 
 @pinshapes
 
@@ -535,7 +536,7 @@ ClearSquare(ToggleObject|SelectedElements|SelectedPins)@end format
 @end cartouche
 
 Clears the square-flag of pins and pads.
-@c ./../src/action.c 4158
+@c ./../src/action.c 4265
 
 Note that @code{Pins} means pins and pads.
 
@@ -555,7 +556,7 @@ flag = square | octagon | thermal | join@end format
 @end cartouche
 
 Clears flags on objects.
-@c ./../src/action.c 5544
+@c ./../src/action.c 5651
 
 Turns the given flag off, regardless of its previous setting.  See
 @code{ChangeFlag}.
@@ -574,7 +575,7 @@ Connection(Find|ResetLinesAndPolygons|ResetPinsAndVias|Reset)@end format
 @end cartouche
 
 Searches connections of the object at the cursor position.
-@c ./../src/action.c 2025
+@c ./../src/action.c 2027
 
 Connections found with this action will be highlighted in the
 ``connected-color'' color and will have the ``found'' flag set.
@@ -610,7 +611,7 @@ Delete(AllRats|SelectedRats)  ;@end format
 @end cartouche
 
 Delete stuff.
-@c ./../src/action.c 3258
+@c ./../src/action.c 3267
 
 
 @node DeleteRats Action
@@ -622,7 +623,7 @@ DeleteRats(AllRats|Selected|SelectedRats)@end format
 @end cartouche
 
 Delete rat lines.
-@c ./../src/action.c 3307
+@c ./../src/action.c 3316
 
 
 @node DisableVendor Action
@@ -654,7 +655,7 @@ DisperseElements(All|Selected)@end format
 @end cartouche
 
 Disperses elements.
-@c ./../src/action.c 2071
+@c ./../src/action.c 2073
 
 Normally this is used when starting a board, by selecting all elements
 and then dispersing them.  This scatters the elements around the board
@@ -681,7 +682,7 @@ Display(Pinout|PinOrPadName)
 @end cartouche
 
 Several display-related actions.
-@c ./../src/action.c 2189
+@c ./../src/action.c 2191
 
 @table @code
 
@@ -867,7 +868,7 @@ DRC()@end format
 @end cartouche
 
 Invoke the DRC check.
-@c ./../src/action.c 1640
+@c ./../src/action.c 1642
 
 Note that the design rule check uses the current board rule settings,
 not the current style settings.
@@ -882,7 +883,7 @@ DumpLibrary()@end format
 @end cartouche
 
 Display the entire contents of the libraries.
-@c ./../src/action.c 1674
+@c ./../src/action.c 1676
 
 
 
@@ -917,7 +918,7 @@ ExecuteFile(filename)@end format
 @end cartouche
 
 Run actions from the given file.
-@c ./../src/action.c 5675
+@c ./../src/action.c 5782
 
 Lines starting with @code{#} are ignored.
 
@@ -931,7 +932,7 @@ Flip(Object|Selected|SelectedElements)@end format
 @end cartouche
 
 Flip an element to the opposite side of the board.
-@c ./../src/action.c 1724
+@c ./../src/action.c 1726
 
 Note that the location of the element will be symmetric about the
 cursor location; i.e. if the part you are pointing at will still be at
@@ -1037,7 +1038,7 @@ LoadFrom(Layout|LayoutToBuffer|ElementToBuffer|Netlist|Revert,filename)@end form
 @end cartouche
 
 Load layout data from a file.
-@c ./../src/action.c 4839
+@c ./../src/action.c 4946
 
 This action assumes you know what the filename is.  The various GUIs
 should have a similar @code{Load} action where the filename is
@@ -1117,7 +1118,7 @@ MarkCrosshair()
 @end cartouche
 
 Set/Reset the Crosshair mark
-@c ./../src/action.c 3397
+@c ./../src/action.c 3406
 
 The ``mark'' is a small X-shaped target on the display which is
 treated like a second origin (the normal origin is the upper let
@@ -1139,7 +1140,7 @@ Message(message)@end format
 @end cartouche
 
 Writes a message to the log window.
-@c ./../src/action.c 1771
+@c ./../src/action.c 1773
 
 This action displays a message to the log window.  This action is primarily
 provided for use by other programs which may interface with PCB.  If
@@ -1147,6 +1148,23 @@ multiple arguments are given, each one is sent to the log window
 followed by a newline.
 
 
+@node MinClearGap Action
+@subsection MinClearGap
+@c key MinClearGap in hid 
+@cartouche
+@format
+MinClearGap(delta)
+"``MinClearGap(Selected, delta)@end format
+@end cartouche
+
+Ensures that polygons are a minimum distance from objects.
+@c ./../src/action.c 3735
+
+Checks all specified objects, and increases the polygon clearance if
+needed to ensure a minimum distance between their edges and the
+polygon edges.
+
+
 @node MinMaskGap Action
 @subsection MinMaskGap
 @c key MinMaskGap in hid 
@@ -1157,7 +1175,7 @@ MinMaskGap(delta)
 @end cartouche
 
 Ensures the mask is a minimum distance from pins and pads.
-@c ./../src/action.c 3650
+@c ./../src/action.c 3659
 
 Checks all specified pins and/or pads, and increases the mask if
 needed to ensure a minimum distance between the pin or pad edge and
@@ -1176,7 +1194,7 @@ Mode(Notify|Release|Cancel|Stroke)
 @end cartouche
 
 Change or use the tool mode.
-@c ./../src/action.c 2513
+@c ./../src/action.c 2522
 
 @table @code
 
@@ -1236,7 +1254,7 @@ MorphPolygon(Object|Selected)@end format
 @end cartouche
 
 Converts dead polygon islands into separate polygons.
-@c ./../src/action.c 3884
+@c ./../src/action.c 3991
 
 If a polygon is divided into unconnected "islands", you can use
 this command to convert the otherwise disappeared islands into
@@ -1304,7 +1322,7 @@ MoveObject(X,Y,dim)@end format
 @end cartouche
 
 Moves the object under the crosshair.
-@c ./../src/action.c 5376
+@c ./../src/action.c 5483
 
 The @code{X} and @code{Y} are treated like @code{delta} is for many
 other objects.  For each, if it's prefixed by @code{+} or @code{-},
@@ -1322,7 +1340,7 @@ MoveToCurrentLayer(Object|SelectedObjects)@end format
 @end cartouche
 
 Moves objects to the current layer.
-@c ./../src/action.c 5418
+@c ./../src/action.c 5525
 
 Note that moving an element from a component layer to a solder layer,
 or from solder to component, won't automatically flip it.  Use the
@@ -1378,7 +1396,7 @@ New([name])@end format
 @end cartouche
 
 Starts a new layout.
-@c ./../src/action.c 4902
+@c ./../src/action.c 5009
 
 If a name is not given, one is prompted for.
 
@@ -1415,7 +1433,7 @@ PasteBuffer(ToLayout, X, Y, units)@end format
 @end cartouche
 
 Various operations on the paste buffer.
-@c ./../src/action.c 4966
+@c ./../src/action.c 5073
 
 There are a number of paste buffers; the actual limit is a
 compile-time constant @code{MAX_BUFFER} in @file{globalconst.h}.  It
@@ -1474,7 +1492,7 @@ Polygon(Close|PreviousPoint)@end format
 @end cartouche
 
 Some polygon related stuff.
-@c ./../src/action.c 5312
+@c ./../src/action.c 5419
 
 Polygons need a special action routine to make life easier.
 
@@ -1558,7 +1576,7 @@ Quit()@end format
 @end cartouche
 
 Quits the application after confirming.
-@c ./../src/action.c 2003
+@c ./../src/action.c 2005
 
 If you have unsaved changes, you will be prompted to confirm (or
 save) before quitting.
@@ -1573,7 +1591,7 @@ Redo()@end format
 @end cartouche
 
 Redo recent``undo''operations.
-@c ./../src/action.c 5278
+@c ./../src/action.c 5385
 
 This routine allows you to recover from the last undo command.  You
 might want to do this if you thought that undo was going to revert
@@ -1596,7 +1614,7 @@ RemoveSelected()@end format
 @end cartouche
 
 Removes any selected objects.
-@c ./../src/action.c 2720
+@c ./../src/action.c 2729
 
 
 @node Renumber Action
@@ -1610,7 +1628,7 @@ Renumber()
 
 Renumber all elements.  The changes will be recorded to filename
 for use in backannotating these changes to the schematic.
-@c ./../src/action.c 2738
+@c ./../src/action.c 2747
 
 
 @node Report Action
@@ -1668,7 +1686,7 @@ RipUp(All|Selected|Element)@end format
 @end cartouche
 
 Ripup auto-routed tracks, or convert an element to parts.
-@c ./../src/action.c 3090
+@c ./../src/action.c 3099
 
 @table @code
 
@@ -1717,7 +1735,7 @@ RouteStyle(1|2|3|4)@end format
 @end cartouche
 
 Copies the indicated routing style into the current sizes.
-@c ./../src/action.c 5344
+@c ./../src/action.c 5451
 
 
 @node s Action
@@ -1749,7 +1767,7 @@ SaveSettings()
 @end cartouche
 
 Saves settings.
-@c ./../src/action.c 4823
+@c ./../src/action.c 4930
 
 If you pass no arguments, the settings are stored in
 @code{$HOME/.pcb/settings}.  If you pass the word @code{local} they're
@@ -1767,7 +1785,7 @@ SaveTo(PasteBuffer,filename)@end format
 @end cartouche
 
 Saves data to a file.
-@c ./../src/action.c 4733
+@c ./../src/action.c 4840
 
 @table @code
 
@@ -1807,7 +1825,7 @@ Select(TextByName|ViaByName, Name)
 @end cartouche
 
 Toggles or sets the selection
-@c ./../src/action.c 4469
+@c ./../src/action.c 4576
 
 @table @code
 
@@ -1856,7 +1874,7 @@ flag = square | octagon | thermal | join@end format
 @end cartouche
 
 Sets flags on objects.
-@c ./../src/action.c 5527
+@c ./../src/action.c 5634
 
 Turns the given flag on, regardless of its previous setting.  See
 @code{ChangeFlag}.
@@ -1875,7 +1893,7 @@ SetOctagon(Object|ToggleObject|SelectedElements|Selected)@end format
 @end cartouche
 
 Sets the octagon-flag of objects.
-@c ./../src/action.c 4269
+@c ./../src/action.c 4376
 
 @pinshapes
 
@@ -1889,7 +1907,7 @@ SetSame()@end format
 @end cartouche
 
 Sets current layer and sizes to match indicated item.
-@c ./../src/action.c 5459
+@c ./../src/action.c 5566
 
 When invoked over any line, arc, polygon, or via, this changes the
 current layer to be the layer that item is on, and changes the current
@@ -1905,7 +1923,7 @@ SetSquare(ToggleObject|SelectedElements|SelectedPins)@end format
 @end cartouche
 
 sets the square-flag of objects.
-@c ./../src/action.c 4105
+@c ./../src/action.c 4212
 
 Note that @code{Pins} means pins and pads.
 
@@ -1927,7 +1945,7 @@ Style = 2 has horizontal and vertical fingers with sharp edges.
 Style = 3 is a solid connection to the plane.Style = 4 has diagonal fingers with rounded edges.
 Style = 5 has horizontal and vertical fingers with rounded edges.
 
-@c ./../src/action.c 1797
+@c ./../src/action.c 1799
 
 This changes how/whether pins or vias connect to any rectangle or polygon
 on the current layer. The first argument can specify one object, or all
@@ -1953,7 +1971,7 @@ SetValue(Grid|Line|LineSize|Text|TextScale|ViaDrillingHole|Via|ViaSize, delta)@e
 @end cartouche
 
 Change various board-wide values and sizes.
-@c ./../src/action.c 1916
+@c ./../src/action.c 1918
 
 @table @code
 
@@ -1987,7 +2005,7 @@ ToggleHideName(Object|SelectedElements)@end format
 @end cartouche
 
 Toggles the visibility of element names.
-@c ./../src/action.c 3932
+@c ./../src/action.c 4039
 
 If names are hidden you won't see them on the screen and they will not
 appear on the silk layer when you print the layout.
@@ -2025,7 +2043,7 @@ Undo()
 @end cartouche
 
 Undo recent changes.
-@c ./../src/action.c 5117
+@c ./../src/action.c 5224
 
 The unlimited undo feature of @code{Pcb} allows you to recover from
 most operations that materially affect you work.  Calling
@@ -2069,7 +2087,7 @@ Unselect(TextByName|ViaByName)
 @end cartouche
 
 unselects the object at the pointer location or the specified objects
-@c ./../src/action.c 4619
+@c ./../src/action.c 4726
 
 @table @code
 
@@ -2256,7 +2274,7 @@ About()@end format
 @end cartouche
 
 Tell the user about this version of PCB.
-@c ./../src/hid/gtk/gtkhid-main.c 1615
+@c ./../src/hid/gtk/gtkhid-main.c 1614
 
 This just pops up a dialog telling the user which version of
 @code{pcb} they're running.
@@ -2287,7 +2305,7 @@ Center()
 @end cartouche
 
 Moves the pointer to the center of the window.
-@c ./../src/hid/gtk/gtkhid-main.c 2073
+@c ./../src/hid/gtk/gtkhid-main.c 2072
 
 Move the pointer to the center of the window, but only if it's
 currently within the window already.
@@ -2302,7 +2320,7 @@ Cursor(Type,DeltaUp,DeltaRight,Units)@end format
 @end cartouche
 
 Move the cursor.
-@c ./../src/hid/gtk/gtkhid-main.c 2172
+@c ./../src/hid/gtk/gtkhid-main.c 2171
 
 This action moves the mouse cursor.  Unlike other actions which take
 coordinates, this action's coordinates are always relative to the
@@ -2346,7 +2364,7 @@ DoWindows(Layout|Library|Log|Netlist|Preferences)@end format
 @end cartouche
 
 Open various GUI windows.
-@c ./../src/hid/gtk/gtkhid-main.c 2230
+@c ./../src/hid/gtk/gtkhid-main.c 2229
 
 @table @code
 
@@ -2400,7 +2418,7 @@ GetXY()@end format
 @end cartouche
 
 Get a coordinate.
-@c ./../src/hid/gtk/gtkhid-main.c 1630
+@c ./../src/hid/gtk/gtkhid-main.c 1629
 
 Prompts the user for a coordinate, if one is not already selected.
 
@@ -2416,7 +2434,7 @@ Popup(MenuName, [Button])@end format
 Bring up the popup menu specified by @code{MenuName}.
 If called by a mouse event then the mouse button number
 must be specified as the optional second argument.
-@c ./../src/hid/gtk/gtkhid-main.c 2297
+@c ./../src/hid/gtk/gtkhid-main.c 2296
 
 This just pops up the specified menu.  The menu must have been defined
 as a named subresource of the Popups resource in the menu resource
@@ -2433,7 +2451,7 @@ Print()@end format
 @end cartouche
 
 Print the layout.
-@c ./../src/hid/gtk/gtkhid-main.c 1948
+@c ./../src/hid/gtk/gtkhid-main.c 1947
 
 This will find the default printing HID, prompt the user for its
 options, and print the layout.
@@ -2448,7 +2466,7 @@ PrintCalibrate()@end format
 @end cartouche
 
 Calibrate the printer.
-@c ./../src/hid/gtk/gtkhid-main.c 1999
+@c ./../src/hid/gtk/gtkhid-main.c 1998
 
 This will print a calibration page, which you would measure and type
 the measurements in, so that future printouts will be more precise.
@@ -2466,7 +2484,7 @@ Save(PasteBuffer)@end format
 @end cartouche
 
 Save layout and/or element data to a user-selected file.
-@c ./../src/hid/gtk/gtkhid-main.c 1774
+@c ./../src/hid/gtk/gtkhid-main.c 1773
 
 This action is a GUI front-end to the core's @code{SaveTo} action
 (@pxref{SaveTo Action}).  If you happen to pass a filename, like
@@ -2499,7 +2517,7 @@ SetUnits(mm|mil)@end format
 @end cartouche
 
 Set the default measurement units.
-@c ./../src/hid/gtk/gtkhid-main.c 2269
+@c ./../src/hid/gtk/gtkhid-main.c 2268
 
 @table @code
 
@@ -2521,7 +2539,7 @@ SwapSides(|v|h|r)@end format
 @end cartouche
 
 Swaps the side of the board you're looking at.
-@c ./../src/hid/gtk/gtkhid-main.c 1856
+@c ./../src/hid/gtk/gtkhid-main.c 1855
 
 This action changes the way you view the board.
 
@@ -2663,7 +2681,7 @@ About()@end format
 @end cartouche
 
 Tell the user about this version of PCB.
-@c ./../src/hid/lesstif/dialogs.c 851
+@c ./../src/hid/lesstif/dialogs.c 870
 
 This just pops up a dialog telling the user which version of
 @code{pcb} they're running.
@@ -2678,7 +2696,7 @@ AdjustSizes()@end format
 @end cartouche
 
 Let the user change the board size, DRC parameters, etc
-@c ./../src/hid/lesstif/dialogs.c 1135
+@c ./../src/hid/lesstif/dialogs.c 1154
 
 Displays a dialog box that lets the user change the board
 size, DRC parameters, and text scale.
@@ -2842,7 +2860,7 @@ DoWindows(Layout|Library|Log|Netlist)@end format
 @end cartouche
 
 Open various GUI windows.
-@c ./../src/hid/lesstif/dialogs.c 815
+@c ./../src/hid/lesstif/dialogs.c 834
 
 @table @code
 
@@ -2895,7 +2913,7 @@ EditLayerGroups()@end format
 @end cartouche
 
 Let the user change the layer groupings
-@c ./../src/hid/lesstif/dialogs.c 1447
+@c ./../src/hid/lesstif/dialogs.c 1466
 
 Displays a dialog that lets the user view and change the layer
 groupings.  Each layer (row) can be a member of any one layer group
@@ -2915,7 +2933,7 @@ Export()@end format
 @end cartouche
 
 Export the layout.
-@c ./../src/hid/lesstif/dialogs.c 941
+@c ./../src/hid/lesstif/dialogs.c 960
 
 Prompts the user for an exporter to use.  Then, prompts the user for
 that exporter's options, and exports the layout.
@@ -3003,7 +3021,7 @@ Print()@end format
 @end cartouche
 
 Print the layout.
-@c ./../src/hid/lesstif/dialogs.c 878
+@c ./../src/hid/lesstif/dialogs.c 897
 
 This will find the default printing HID, prompt the user for its
 options, and print the layout.
@@ -3018,7 +3036,7 @@ PrintCalibrate()@end format
 @end cartouche
 
 Calibrate the printer.
-@c ./../src/hid/lesstif/dialogs.c 921
+@c ./../src/hid/lesstif/dialogs.c 940
 
 This will print a calibration page, which you would measure and type
 the measurements in, so that future printouts will be more precise.
diff --git a/doc/pcbfile.texi b/doc/pcbfile.texi
index 7dd6be8..70dc33a 100644
--- a/doc/pcbfile.texi
+++ b/doc/pcbfile.texi
@@ -926,4 +926,12 @@ Move items orthogonally.
 Draw autoroute paths real-time.
 @item 0x20000
 New polygons are full ones.
+@item 0x40000
+Names are locked, the mouse cannot select them.
+@item 0x80000
+Everything but names are locked, the mouse cannot select anything else.
+@item 0x100000
+New polygons are full polygons.
+@item 0x200000
+When set, element names are not drawn.
 @end table
diff --git a/src/Makefile.am b/src/Makefile.am
index 8109894..a337e16 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -146,13 +146,17 @@ PCB_SRCS = \
 	hid/hidint.h 
 pcb_SOURCES = ${PCB_SRCS} core_lists.h
 
-EXTRA_pcb_SOURCES = ${DBUS_SRCS}
+EXTRA_pcb_SOURCES = ${DBUS_SRCS} ${GL_SRCS}
 DBUS_SRCS= \
 	dbus-pcbmain.c \
 	dbus-pcbmain.h \
 	dbus.h \
 	dbus.c
 
+GL_SRCS= \
+	hid/common/hidgl.c \
+	hid/common/hidgl.h
+
 BUILT_SOURCES = \
 	core_lists.h \
 	gpcb-menu.h \
@@ -267,6 +271,11 @@ BUILT_SOURCES+=	dbus-introspect.h
 
 endif
 
+# If we are building with GL support, we need some extra files
+if USE_GL
+PCB_SRCS+=	${GL_SRCS}
+endif
+
 # If we are building on win32, then compile in some icons for the
 # desktop and application toolbar
 if WIN32
diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
new file mode 100644
index 0000000..c95cc7f
--- /dev/null
+++ b/src/hid/common/hidgl.c
@@ -0,0 +1,717 @@
+/* $Id: */
+
+#if 1 /* DISABLE EVERYTHING! */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+#include <math.h>
+#include <time.h>
+#include <assert.h>
+
+#include "action.h"
+#include "crosshair.h"
+#include "data.h"
+#include "draw.h"
+#include "error.h"
+#include "global.h"
+#include "mymem.h"
+#include "draw.h"
+#include "clip.h"
+
+#include "hid.h"
+#include "hidgl.h"
+
+
+#include <GL/gl.h>
+#include <GL/glut.h>
+
+#ifdef HAVE_LIBDMALLOC
+#include <dmalloc.h>
+#endif
+
+#define PIXELS_PER_CIRCLINE 5.
+
+RCSID ("$Id: $");
+
+#define USE_GC(x)
+
+#define TRIANGLE_ARRAY_SIZE 5000
+static GLfloat triangle_array [2 * 3 * TRIANGLE_ARRAY_SIZE];
+static unsigned int triangle_count;
+static int coord_comp_count;
+
+void
+hidgl_init_triangle_array (void)
+{
+  glEnableClientState (GL_VERTEX_ARRAY);
+  glVertexPointer (2, GL_FLOAT, 0, &triangle_array);
+  triangle_count = 0;
+  coord_comp_count = 0;
+}
+
+void
+hidgl_flush_triangles ()
+{
+  if (triangle_count == 0)
+    return;
+
+  glDrawArrays (GL_TRIANGLES, 0, triangle_count * 3);
+  triangle_count = 0;
+  coord_comp_count = 0;
+}
+
+static void
+ensure_triangle_space (int count)
+{
+  if (count > TRIANGLE_ARRAY_SIZE)
+    {
+      fprintf (stderr, "Not enough space in vertex buffer\n");
+      fprintf (stderr, "Requested %i triangles, %i available\n", count, TRIANGLE_ARRAY_SIZE);
+      exit (1);
+    }
+  if (count > TRIANGLE_ARRAY_SIZE - triangle_count)
+    hidgl_flush_triangles ();
+}
+
+static inline void
+add_triangle (GLfloat x1, GLfloat y1,
+              GLfloat x2, GLfloat y2,
+              GLfloat x3, GLfloat y3)
+{
+  triangle_array [coord_comp_count++] = x1;
+  triangle_array [coord_comp_count++] = y1;
+  triangle_array [coord_comp_count++] = x2;
+  triangle_array [coord_comp_count++] = y2;
+  triangle_array [coord_comp_count++] = x3;
+  triangle_array [coord_comp_count++] = y3;
+  triangle_count++;
+}
+
+//static int cur_mask = -1;
+
+
+/* ------------------------------------------------------------ */
+#if 0
+/*static*/ void
+draw_grid ()
+{
+  static GLfloat *points = 0;
+  static int npoints = 0;
+  int x1, y1, x2, y2, n, i;
+  double x, y;
+
+  if (!Settings.DrawGrid)
+    return;
+  if (Vz (PCB->Grid) < MIN_GRID_DISTANCE)
+    return;
+
+  if (gdk_color_parse (Settings.GridColor, &gport->grid_color))
+    {
+      gport->grid_color.red ^= gport->bg_color.red;
+      gport->grid_color.green ^= gport->bg_color.green;
+      gport->grid_color.blue ^= gport->bg_color.blue;
+    }
+
+  hidgl_flush_triangles ();
+
+  glEnable (GL_COLOR_LOGIC_OP);
+  glLogicOp (GL_XOR);
+
+  glColor3f (gport->grid_color.red / 65535.,
+             gport->grid_color.green / 65535.,
+             gport->grid_color.blue / 65535.);
+
+  x1 = GRIDFIT_X (SIDE_X (gport->view_x0), PCB->Grid);
+  y1 = GRIDFIT_Y (SIDE_Y (gport->view_y0), PCB->Grid);
+  x2 = GRIDFIT_X (SIDE_X (gport->view_x0 + gport->view_width - 1), PCB->Grid);
+  y2 = GRIDFIT_Y (SIDE_Y (gport->view_y0 + gport->view_height - 1), PCB->Grid);
+  if (x1 > x2)
+    {
+      int tmp = x1;
+      x1 = x2;
+      x2 = tmp;
+    }
+  if (y1 > y2)
+    {
+      int tmp = y1;
+      y1 = y2;
+      y2 = tmp;
+    }
+  if (Vx (x1) < 0)
+    x1 += PCB->Grid;
+  if (Vy (y1) < 0)
+    y1 += PCB->Grid;
+  if (Vx (x2) >= gport->width)
+    x2 -= PCB->Grid;
+  if (Vy (y2) >= gport->height)
+    y2 -= PCB->Grid;
+  n = (int) ((x2 - x1) / PCB->Grid + 0.5) + 1;
+  if (n > npoints)
+    {
+      npoints = n + 10;
+      points =
+	MyRealloc (points, npoints * 2 * sizeof (GLfloat), "gtk_draw_grid");
+    }
+
+  glEnableClientState (GL_VERTEX_ARRAY);
+  glVertexPointer (2, GL_FLOAT, 0, points);
+
+  n = 0;
+  for (x = x1; x <= x2; x += PCB->Grid)
+    {
+      points[2 * n] = Vx (x);
+      n++;
+    }
+  for (y = y1; y <= y2; y += PCB->Grid)
+    {
+      int vy = Vy (y);
+      for (i = 0; i < n; i++)
+	points[2 * i + 1] = vy;
+      glDrawArrays (GL_POINTS, 0, n);
+    }
+
+  glDisableClientState (GL_VERTEX_ARRAY);
+  glDisable (GL_COLOR_LOGIC_OP);
+  glFlush ();
+}
+
+#endif
+/* ------------------------------------------------------------ */
+
+#if 0
+int
+hidgl_set_layer (const char *name, int group, int empty)
+{
+  int idx = (group >= 0
+	     && group <
+	     max_layer) ? PCB->LayerGroups.Entries[group][0] : group;
+
+  if (idx >= 0 && idx < max_layer + 2) {
+    gport->trans_lines = TRUE;
+    return /*pinout ? 1 : */ PCB->Data->Layer[idx].On;
+  }
+  if (idx < 0)
+    {
+      switch (SL_TYPE (idx))
+	{
+	case SL_INVISIBLE:
+	  return /* pinout ? 0 : */ PCB->InvisibleObjectsOn;
+	case SL_MASK:
+	  if (SL_MYSIDE (idx) /*&& !pinout */ )
+	    return TEST_FLAG (SHOWMASKFLAG, PCB);
+	  return 0;
+	case SL_SILK:
+//          gport->trans_lines = TRUE;
+          gport->trans_lines = FALSE;
+	  if (SL_MYSIDE (idx) /*|| pinout */ )
+	    return PCB->ElementOn;
+	  return 0;
+	case SL_ASSY:
+	  return 0;
+	case SL_RATS:
+	  gport->trans_lines = TRUE;
+	  return 1;
+	case SL_PDRILL:
+	case SL_UDRILL:
+	  return 1;
+	}
+    }
+  return 0;
+}
+
+void
+hidgl_use_mask (int use_it)
+{
+  if (use_it == cur_mask)
+    return;
+
+  hidgl_flush_triangles ();
+
+  switch (use_it)
+    {
+    case HID_MASK_BEFORE:
+      /* Write '1' to the stencil buffer where the solder-mask is drawn. */
+      glColorMask (0, 0, 0, 0);                   // Disable writting in color buffer
+      glEnable (GL_STENCIL_TEST);                 // Enable Stencil test
+      glStencilFunc (GL_ALWAYS, 1, 1);            // Test always passes, value written 1
+      glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value (with 1)
+      break;
+
+    case HID_MASK_CLEAR:
+      /* Drawing operations clear the stencil buffer to '0' */
+      glStencilFunc (GL_ALWAYS, 0, 1);            // Test always passes, value written 0
+      glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value (with 0)
+      break;
+
+    case HID_MASK_AFTER:
+      /* Drawing operations as masked to areas where the stencil buffer is '1' */
+      glColorMask (1, 1, 1, 1);                   // Enable drawing of r, g, b & a
+      glStencilFunc (GL_EQUAL, 1, 1);             // Draw only where stencil buffer is 1
+      glStencilOp (GL_KEEP, GL_KEEP, GL_KEEP);    // Stencil buffer read only
+      break;
+
+    case HID_MASK_OFF:
+      /* Disable stenciling */
+      glDisable (GL_STENCIL_TEST);                // Disable Stencil test
+      break;
+    }
+  cur_mask = use_it;
+}
+#endif
+
+
+typedef struct
+{
+  int color_set;
+//  GdkColor color;
+  int xor_set;
+//  GdkColor xor_color;
+  double red;
+  double green;
+  double blue;
+} ColorCache;
+
+
+void
+hidgl_set_draw_xor (hidGC gc, int xor)
+{
+  // printf ("hidgl_set_draw_xor (%p, %d) -- not implemented\n", gc, xor);
+  /* NOT IMPLEMENTED */
+
+  /* Only presently called when setting up a crosshair GC.
+   * We manage our own drawing model for that anyway. */
+}
+
+void
+hidgl_set_draw_faded (hidGC gc, int faded)
+{
+  printf ("hidgl_set_draw_faded(%p,%d) -- not implemented\n", gc, faded);
+}
+
+void
+hidgl_set_line_cap_angle (hidGC gc, int x1, int y1, int x2, int y2)
+{
+  printf ("hidgl_set_line_cap_angle() -- not implemented\n");
+}
+
+#if 0
+static void
+use_gc (hidGC gc)
+{
+  static hidGC current_gc = NULL;
+
+  if (current_gc == gc)
+    return;
+
+  current_gc = gc;
+
+  hidgl_set_color (gc, gc->colorname);
+}
+#endif
+
+void
+errorCallback(GLenum errorCode)
+{
+   const GLubyte *estring;
+
+   estring = gluErrorString(errorCode);
+   fprintf(stderr, "Quadric Error: %s\n", estring);
+//   exit(0);
+}
+
+
+void
+hidgl_draw_line (hidGC gc, int cap, double width, int x1, int y1, int x2, int y2)
+{
+#define TRIANGLES_PER_CAP 15
+#define MIN_TRIANGLES_PER_CAP 3
+#define MAX_TRIANGLES_PER_CAP 1000
+  double angle;
+  float deltax, deltay, length;
+  float wdx, wdy;
+  int slices;
+  int circular_caps = 0;
+
+#if 0
+  if (! ClipLine (0, 0, gport->width, gport->height,
+  if (! ClipLine (0, 0, gport->width, gport->height,
+                  &dx1, &dy1, &dx2, &dy2, gc->width / gport->zoom))
+    return;
+#endif
+
+  USE_GC (gc);
+
+  if (width == 0.0)
+    width = 1.0;
+
+  deltax = x2 - x1;
+  deltay = y2 - y1;
+
+  length = sqrt (deltax * deltax + deltay * deltay);
+
+  if (length == 0) {
+    angle = 0;
+    wdx = -width / 2.;
+    wdy = 0;
+  } else {
+    wdy = deltax * width / 2. / length;
+    wdx = -deltay * width / 2. / length;
+
+    if (deltay == 0.)
+      angle = (deltax < 0) ? 270. : 90.;
+    else
+      angle = 180. / M_PI * atanl (deltax / deltay);
+
+    if (deltay < 0)
+      angle += 180.;
+  }
+
+  slices = M_PI * width / PIXELS_PER_CIRCLINE;
+
+  if (slices < MIN_TRIANGLES_PER_CAP)
+    slices = MIN_TRIANGLES_PER_CAP;
+
+  if (slices > MAX_TRIANGLES_PER_CAP)
+    slices = MAX_TRIANGLES_PER_CAP;
+
+//  slices = TRIANGLES_PER_CAP;
+
+  switch (cap) {
+    case Trace_Cap:
+    case Round_Cap:
+      circular_caps = 1;
+      break;
+
+    case Square_Cap:
+    case Beveled_Cap:
+      x1 -= deltax * width / 2. / length;
+      y1 -= deltay * width / 2. / length;
+      x2 += deltax * width / 2. / length;
+      y2 += deltay * width / 2. / length;
+      break;
+  }
+
+  ensure_triangle_space (2);
+  add_triangle (x1 - wdx, y1 - wdy, x2 - wdx, y2 - wdy, x2 + wdx, y2 + wdy);
+  add_triangle (x1 - wdx, y1 - wdy, x2 + wdx, y2 + wdy, x1 + wdx, y1 + wdy);
+
+  if (circular_caps) {
+    int i;
+    float last_capx, last_capy;
+
+    ensure_triangle_space (2 * slices);
+
+    last_capx = ((float)width) / 2. * cos (angle * M_PI / 180.) + x1;
+    last_capy = -((float)width) / 2. * sin (angle * M_PI / 180.) + y1;
+    for (i = 0; i < slices; i++) {
+      float capx, capy;
+      capx = ((float)width) / 2. * cos (angle * M_PI / 180. + ((float)(i + 1)) * M_PI / (float)slices) + x1;
+      capy = -((float)width) / 2. * sin (angle * M_PI / 180. + ((float)(i + 1)) * M_PI / (float)slices) + y1;
+      add_triangle (last_capx, last_capy, capx, capy, x1, y1);
+      last_capx = capx;
+      last_capy = capy;
+    }
+    last_capx = -((float)width) / 2. * cos (angle * M_PI / 180.) + x2;
+    last_capy = ((float)width) / 2. * sin (angle * M_PI / 180.) + y2;
+    for (i = 0; i < slices; i++) {
+      float capx, capy;
+      capx = -((float)width) / 2. * cos (angle * M_PI / 180. + ((float)(i + 1)) * M_PI / (float)slices) + x2;
+      capy = ((float)width) / 2. * sin (angle * M_PI / 180. + ((float)(i + 1)) * M_PI / (float)slices) + y2;
+      add_triangle (last_capx, last_capy, capx, capy, x2, y2);
+      last_capx = capx;
+      last_capy = capy;
+    }
+  }
+}
+
+void
+hidgl_draw_arc (hidGC gc, double width, int vx, int vy,
+               int vrx, int vry, int start_angle, int delta_angle,
+               int flip_x, int flip_y)
+{
+#define MIN_SLICES_PER_ARC 10
+  int slices;
+  GLUquadricObj *qobj;
+
+  USE_GC (gc);
+
+  if (flip_x)
+    {
+      start_angle = 180 - start_angle;
+      delta_angle = - delta_angle;
+    }
+  if (flip_y)
+    {
+      start_angle = - start_angle;
+      delta_angle = - delta_angle;					
+    }
+  /* make sure we fall in the -180 to +180 range */
+  start_angle = (start_angle + 360 + 180) % 360 - 180;
+
+  if (delta_angle < 0) {
+    start_angle += delta_angle;
+    delta_angle = - delta_angle;
+  }
+
+  slices = M_PI * (vrx + width / 2.) / PIXELS_PER_CIRCLINE;
+
+  if (slices < MIN_SLICES_PER_ARC)
+    slices = MIN_SLICES_PER_ARC;
+
+  /* TODO: CHANGE TO USING THE TRIANGLE LIST */
+  qobj = gluNewQuadric ();
+  gluQuadricCallback (qobj, GLU_ERROR, errorCallback);
+  gluQuadricDrawStyle (qobj, GLU_FILL); /* smooth shaded */
+  gluQuadricNormals (qobj, GLU_SMOOTH);
+
+  glPushMatrix ();
+  glTranslatef (vx, vx, 0.0);
+  gluPartialDisk (qobj, vrx - width / 2, vrx + width / 2, slices, 1, 270 + start_angle, delta_angle);
+  glPopMatrix ();
+
+  slices = M_PI * width / PIXELS_PER_CIRCLINE;
+
+  if (slices < MIN_TRIANGLES_PER_CAP)
+    slices = MIN_TRIANGLES_PER_CAP;
+
+  /* TODO: CHANGE TO USING THE TRIANGLE LIST */
+  glPushMatrix ();
+  glTranslatef (vx + vrx * -cos (M_PI / 180. * start_angle),
+                vy + vrx *  sin (M_PI / 180. * start_angle), 0.0);
+  gluPartialDisk (qobj, 0, width / 2, slices, 1, start_angle + 90., 180);
+  glPopMatrix ();
+
+  /* TODO: CHANGE TO USING THE TRIANGLE LIST */
+  glPushMatrix ();
+  glTranslatef (vx + vrx * -cos (M_PI / 180. * (start_angle + delta_angle)),
+                vy + vrx *  sin (M_PI / 180. * (start_angle + delta_angle)), 0.0);
+  gluPartialDisk (qobj, 0, width / 2, slices, 1, start_angle + delta_angle + 270., 180);
+  glPopMatrix ();
+
+  gluDeleteQuadric (qobj);
+}
+
+void
+hidgl_draw_rect (hidGC gc, int x1, int y1, int x2, int y2)
+{
+  USE_GC (gc);
+  glBegin (GL_LINE_LOOP);
+  glVertex2f (x1, y1);
+  glVertex2f (x1, y2);
+  glVertex2f (x2, y2);
+  glVertex2f (x2, y1);
+  glEnd ();
+}
+
+
+void
+hidgl_fill_circle (hidGC gc, int vx, int vy, int vr)
+{
+#define TRIANGLES_PER_CIRCLE 30
+#define MIN_TRIANGLES_PER_CIRCLE 6
+#define MAX_TRIANGLES_PER_CIRCLE 2000
+  float last_x, last_y;
+  int slices;
+  int i;
+
+  USE_GC (gc);
+
+  slices = M_PI * 2 * vr / PIXELS_PER_CIRCLINE;
+
+  if (slices < MIN_TRIANGLES_PER_CIRCLE)
+    slices = MIN_TRIANGLES_PER_CIRCLE;
+
+  if (slices > MAX_TRIANGLES_PER_CIRCLE)
+    slices = MAX_TRIANGLES_PER_CIRCLE;
+
+//  slices = TRIANGLES_PER_CIRCLE;
+
+  ensure_triangle_space (slices);
+
+  last_x = vx + vr;
+  last_y = vy;
+
+  for (i = 0; i < slices; i++) {
+    float x, y;
+    x = ((float)vr) * cos (((float)(i + 1)) * 2. * M_PI / (float)slices) + vx;
+    y = ((float)vr) * sin (((float)(i + 1)) * 2. * M_PI / (float)slices) + vy;
+    add_triangle (vx, vy, last_x, last_y, x, y);
+    last_x = x;
+    last_y = y;
+  }
+}
+
+#define MAX_COMBINED_MALLOCS 2500
+static void *combined_to_free [MAX_COMBINED_MALLOCS];
+static int combined_num_to_free = 0;
+
+static GLenum tessVertexType;
+static int stashed_vertices;
+static int triangle_comp_idx;
+
+
+static void
+myError (GLenum errno)
+{
+  printf ("gluTess error: %s\n", gluErrorString (errno));
+}
+
+static void
+myFreeCombined ()
+{
+  while (combined_num_to_free)
+    free (combined_to_free [-- combined_num_to_free]);
+}
+
+static void
+myCombine ( GLdouble coords[3], void *vertex_data[4], GLfloat weight[4], void **dataOut )
+{
+#define MAX_COMBINED_VERTICES 2500
+  static GLdouble combined_vertices [3 * MAX_COMBINED_VERTICES];
+  static int num_combined_vertices = 0;
+
+  GLdouble *new_vertex;
+
+  if (num_combined_vertices < MAX_COMBINED_VERTICES)
+    {
+      new_vertex = &combined_vertices [3 * num_combined_vertices];
+      num_combined_vertices ++;
+    }
+  else
+    {
+      new_vertex = malloc (3 * sizeof (GLdouble));
+
+      if (combined_num_to_free < MAX_COMBINED_MALLOCS)
+        combined_to_free [combined_num_to_free ++] = new_vertex;
+      else
+        printf ("myCombine leaking %i bytes of memory\n", 3 * sizeof (GLdouble));
+    }
+
+  new_vertex[0] = coords[0];
+  new_vertex[1] = coords[1];
+  new_vertex[2] = coords[2];
+
+  *dataOut = new_vertex;
+}
+
+static void
+myBegin (GLenum type)
+{
+  tessVertexType = type;
+  stashed_vertices = 0;
+  triangle_comp_idx = 0;
+}
+
+void
+myVertex (GLdouble *vertex_data)
+{
+  static GLfloat triangle_vertices [2 * 3];
+
+  if (tessVertexType == GL_TRIANGLE_STRIP ||
+      tessVertexType == GL_TRIANGLE_FAN)
+    {
+      if (stashed_vertices < 2)
+        {
+          triangle_vertices [triangle_comp_idx ++] = vertex_data [0];
+          triangle_vertices [triangle_comp_idx ++] = vertex_data [1];
+          stashed_vertices ++;
+        }
+      else
+        {
+          ensure_triangle_space (1);
+          add_triangle (triangle_vertices [0], triangle_vertices [1],
+                        triangle_vertices [2], triangle_vertices [3],
+                        vertex_data [0], vertex_data [1]);
+
+          if (tessVertexType == GL_TRIANGLE_STRIP)
+            {
+              /* STRIP saves the last two vertices for re-use in the next triangle */
+              triangle_vertices [0] = triangle_vertices [2];
+              triangle_vertices [1] = triangle_vertices [3];
+            }
+          /* Both FAN and STRIP save the last vertex for re-use in the next triangle */
+          triangle_vertices [2] = vertex_data [0];
+          triangle_vertices [3] = vertex_data [1];
+        }
+    }
+  else if (tessVertexType == GL_TRIANGLES)
+    {
+      triangle_vertices [triangle_comp_idx ++] = vertex_data [0];
+      triangle_vertices [triangle_comp_idx ++] = vertex_data [1];
+      stashed_vertices ++;
+      if (stashed_vertices == 3)
+        {
+          ensure_triangle_space (1);
+          add_triangle (triangle_vertices [0], triangle_vertices [1],
+                        triangle_vertices [2], triangle_vertices [3],
+                        triangle_vertices [4], triangle_vertices [5]);
+          triangle_comp_idx = 0;
+          stashed_vertices = 0;
+        }
+    }
+  else
+    printf ("Vertex recieved with unknown type\n");
+}
+
+void
+hidgl_fill_polygon (hidGC gc, int n_coords, int *x, int *y)
+{
+  int i;
+
+  GLUtesselator *tobj;
+  GLdouble *vertices;
+
+  USE_GC (gc);
+
+  assert (n_coords > 0);
+
+  vertices = malloc (sizeof(GLdouble) * n_coords * 3);
+
+  tobj = gluNewTess ();
+  gluTessCallback(tobj, GLU_TESS_BEGIN, myBegin);
+  gluTessCallback(tobj, GLU_TESS_VERTEX, myVertex);
+  gluTessCallback(tobj, GLU_TESS_COMBINE, myCombine);
+  gluTessCallback(tobj, GLU_TESS_ERROR, myError);
+
+  gluTessBeginPolygon (tobj, NULL);
+  gluTessBeginContour (tobj);
+
+  for (i = 0; i < n_coords; i++)
+    {
+      vertices [0 + i * 3] = x[i];
+      vertices [1 + i * 3] = y[i];
+      vertices [2 + i * 3] = 0.;
+      gluTessVertex (tobj, &vertices [i * 3], &vertices [i * 3]);
+    }
+
+  gluTessEndContour (tobj);
+  gluTessEndPolygon (tobj);
+  gluDeleteTess (tobj);
+
+  myFreeCombined ();
+  free (vertices);
+}
+
+void
+hidgl_fill_rect (hidGC gc, int x1, int y1, int x2, int y2)
+{
+  USE_GC (gc);
+  glBegin (GL_QUADS);
+  glVertex2f (x1, y1);
+  glVertex2f (x1, y2);
+  glVertex2f (x2, y2);
+  glVertex2f (x2, y1);
+  glEnd ();
+}
+
+/* ---------------------------------------------------------------------- */
+
+#endif /* DISABLE EVERYTHING! */
+
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
new file mode 100644
index 0000000..9709c6a
--- /dev/null
+++ b/src/hid/common/hidgl.h
@@ -0,0 +1,37 @@
+/* $Id: gui.h,v 1.25 2008-04-13 14:15:38 petercjclifton Exp $ */
+
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 1994,1995,1996 Thomas Nau
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifndef __HIDGL_INCLUDED__
+#define __HIDGL_INCLUDED__
+
+//#include <GL/gl.h>
+//#include <GL/glu.h>
+////#include <GL/glut.h>
+
+int trans_lines;
+
+void hidgl_init_triangle_array ();
+void hidgl_flush_triangles ();
+
+#endif /* __HIDGL_INCLUDED__  */

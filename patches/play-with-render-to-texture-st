Bottom: 29da79daaf759e58be84795e6752db2b35c964c8
Top:    d7edc2e9cba7e2defcbba3320d6caf288b1610d7
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-10-25 20:59:51 +0100

Play with render to texture stuff


---

diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index e1b30f5..b404b35 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -70,6 +70,15 @@ static int global_view_2d = 1;
 typedef struct render_priv {
   GdkGLConfig *glconfig;
   bool trans_lines;
+  int no_layers;
+  GLuint *layer_texture;
+  bool *layer_rendered;
+  GLuint depth_stencil_buffer;
+  GLuint fbo_no_stencil;
+  GLuint fbo_with_stencil;
+  int fbo_width;
+  int fbo_height;
+  int textures_ok;
 } render_priv;
 
 
@@ -156,6 +165,7 @@ ghid_set_layer (const char *name, int group, int empty)
 {
   render_priv *priv = gport->render_priv;
   static int stencil_bit = 0;
+  bool group_visible = false;
   int idx = group;
   if (idx >= 0 && idx < max_group)
     {
@@ -175,52 +185,56 @@ ghid_set_layer (const char *name, int group, int empty)
 
   hidgl_set_depth (compute_depth (group));
 
-  glEnable (GL_STENCIL_TEST);                   // Enable Stencil test
-  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);   // Stencil pass => replace stencil value (with 1)
-  hidgl_return_stencil_bit (stencil_bit);       // Relinquish any bitplane we previously used
-  if (SL_TYPE (idx) != SL_FINISHED) {
-    stencil_bit = hidgl_assign_clear_stencil_bit();       // Get a new (clean) bitplane to stencil with
-    glStencilMask (stencil_bit);                          // Only write to our subcompositing stencil bitplane
-    glStencilFunc (GL_GREATER, stencil_bit, stencil_bit); // Pass stencil test if our assigned bit is clear
-  } else {
-    stencil_bit = 0;
-    glStencilMask (0);
-    glStencilFunc (GL_ALWAYS, 0, 0);  // Always pass stencil test
-  }
-
   if (idx >= 0 && idx < max_copper_layer + 2)
     {
       priv->trans_lines = true;
-      return PCB->Data->Layer[idx].On;
+      group_visible = PCB->Data->Layer[idx].On;
     }
-
-  if (idx < 0)
+  else if (idx < 0)
     {
       switch (SL_TYPE (idx))
 	{
 	case SL_INVISIBLE:
-	  return PCB->InvisibleObjectsOn;
+	  group_visible = PCB->InvisibleObjectsOn;
+          break;
 	case SL_MASK:
 	  if (SL_MYSIDE (idx))
-	    return TEST_FLAG (SHOWMASKFLAG, PCB);
-	  return 0;
+	    group_visible = TEST_FLAG (SHOWMASKFLAG, PCB);
+          break;
 	case SL_SILK:
 	  priv->trans_lines = true;
 	  if (SL_MYSIDE (idx))
-	    return PCB->ElementOn;
-	  return 0;
+	    group_visible = PCB->ElementOn;
+	  break;
 	case SL_ASSY:
-	  return 0;
+	  break;
 	case SL_PDRILL:
 	case SL_UDRILL:
-	  return 1;
+	  group_visible = true;
+          break;
 	case SL_RATS:
 	  if (PCB->RatOn)
 	    priv->trans_lines = true;
-	  return PCB->RatOn;
+	  group_visible = PCB->RatOn;
+          break;
 	}
     }
-  return 0;
+
+  glEnable (GL_STENCIL_TEST);                   // Enable Stencil test
+  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);   // Stencil pass => replace stencil value (with 1)
+  hidgl_return_stencil_bit (stencil_bit);       // Relinquish any bitplane we previously used
+//  if (SL_TYPE (idx) != SL_FINISHED) {
+  if (group_visible) {
+    stencil_bit = hidgl_assign_clear_stencil_bit();       // Get a new (clean) bitplane to stencil with
+    glStencilMask (stencil_bit);                          // Only write to our subcompositing stencil bitplane
+    glStencilFunc (GL_GREATER, stencil_bit, stencil_bit); // Pass stencil test if our assigned bit is clear
+  } else {
+    stencil_bit = 0;
+    glStencilMask (0);
+    glStencilFunc (GL_ALWAYS, 0, 0);  // Always pass stencil test
+  }
+
+  return group_visible;
 }
 
 void
@@ -1708,9 +1722,160 @@ ghid_draw_packages (BoxTypePtr drawn_area)
 
 }
 
+static void
+setup_fbo (GHidPort *port, int width, int height, int no_layers)
+{
+  render_priv *priv = port->render_priv;
+  int layer;
+
+  priv->fbo_width = width;
+  priv->fbo_height = height;
+  priv->no_layers = no_layers;
+
+  /* Setup an FBO to render into (without depth / stencil) */
+  glGenFramebuffersEXT (1, &priv->fbo_no_stencil);
+  glBindFramebufferEXT (GL_FRAMEBUFFER_EXT, priv->fbo_no_stencil);
+
+  /* Setup an FBO to render into (with depth / stencil) */
+  glGenFramebuffersEXT (1, &priv->fbo_with_stencil);
+  glBindFramebufferEXT (GL_FRAMEBUFFER_EXT, priv->fbo_with_stencil);
+
+  /* Create and bind a paked depth / stencil renderbuffer */
+  glGenRenderbuffersEXT (1, &priv->depth_stencil_buffer);
+  glBindRenderbufferEXT (GL_RENDERBUFFER_EXT, priv->depth_stencil_buffer);
+
+  /* Allocate space for the depth / stencil renderbuffer */
+  glRenderbufferStorageEXT (GL_RENDERBUFFER_EXT, GL_DEPTH24_STENCIL8_EXT,
+                            priv->fbo_width, priv->fbo_height);
+
+  /* Attach the depth / stencil renderbuffer to the FBO */
+  glFramebufferRenderbufferEXT (GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT,
+                                GL_RENDERBUFFER_EXT, priv->depth_stencil_buffer);
+  glFramebufferRenderbufferEXT (GL_FRAMEBUFFER_EXT, GL_STENCIL_ATTACHMENT_EXT,
+                                GL_RENDERBUFFER_EXT, priv->depth_stencil_buffer);
+
+  /* Create some textures to render our layers into */
+  priv->layer_rendered = malloc (priv->no_layers * sizeof (bool));
+  priv->layer_texture = malloc (priv->no_layers * sizeof (GLuint));
+  for (layer = 0; layer < priv->no_layers; layer++) {
+    glGenTextures (1, &priv->layer_texture[layer]);
+    glBindTexture (GL_TEXTURE_2D, priv->layer_texture[layer]);
+
+    glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
+    glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
+    glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+    glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR_MIPMAP_LINEAR);
+
+    /* Allocate storage for each texture. The texels are undefined. */
+    glTexImage2D (GL_TEXTURE_2D, 0, GL_RGBA8,
+                  priv->fbo_width, priv->fbo_height, 0,
+                  GL_RGBA, GL_UNSIGNED_BYTE, NULL);
+  }
+  /* For sake of cleanliness, unbind the texture we last used */
+  glBindTexture (GL_TEXTURE_2D, 0);
+
+  /* Unbind the FBO for now */
+  glBindFramebufferEXT (GL_FRAMEBUFFER_EXT, 0);
+
+  /* Mark textures as needing rendering */
+  priv->textures_ok = 0;
+}
+
+
+static void
+cleanup_fbo (GHidPort *port)
+{
+  int layer;
+  render_priv *priv = port->render_priv;
+
+  glDeleteFramebuffersEXT (1, &priv->fbo_no_stencil);
+
+  glDeleteFramebuffersEXT (1, &priv->fbo_with_stencil);
+  glDeleteRenderbuffersEXT (1, &priv->depth_stencil_buffer);
+
+  for (layer = 0; layer < priv->no_layers; layer++) {
+    glDeleteTextures (1, &priv->layer_texture[layer]);
+  }
+
+  free (priv->layer_texture);
+  priv->layer_texture = NULL;
+  priv->textures_ok = 0;
+}
+
+
+static void
+setup_fbo_layer (GHidPort *port, int layer, int with_stencil)
+{
+  render_priv *priv = port->render_priv;
+  GLenum status;
+  GLuint fbo = with_stencil ? priv->fbo_with_stencil : priv->fbo_no_stencil;
+
+  /* Bind the FBO into active usage */
+  glBindFramebufferEXT (GL_FRAMEBUFFER_EXT, fbo);
+
+  /* Bind one of the textures to the FBO for rendering into */
+  glFramebufferTexture2DEXT (GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D,
+                             priv->layer_texture[layer], 0);
+
+  /* Check the OpenGL driver is happy with our FBO setup */
+  status = glCheckFramebufferStatusEXT (GL_FRAMEBUFFER_EXT);
+
+  if (status != GL_FRAMEBUFFER_COMPLETE_EXT) {
+    fprintf (stderr, "Oppos, couldn't create a complete FBO, quitting\n");
+    fprintf (stderr, "Width: %i, height: %i\n", priv->fbo_width, priv->fbo_height);
+    exit (-1);
+  }
+
+  glPushAttrib (GL_VIEWPORT_BIT);
+  glViewport (0, 0, priv->fbo_width, priv->fbo_height);
+  glMatrixMode (GL_PROJECTION);
+  glPushMatrix ();
+  glLoadIdentity ();
+  glOrtho (0, priv->fbo_width, priv->fbo_height, 0, -100000, 100000);
+  glMatrixMode (GL_MODELVIEW);
+  glPushMatrix ();
+  glLoadIdentity ();
+
+  glScalef ( 1. / port->zoom,
+            -1. / port->zoom,
+             1.);
+  glTranslatef (0., -PCB->MaxHeight, 0.);
+//  glTranslatef (-port->view_x0, port->view_y0 - PCB->MaxHeight, 0.);
+
+  glClearColor (0., 0., 0., 0.);
+  if (with_stencil) {
+    glStencilMask (~0);
+    glClearStencil (0);
+    glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
+  } else {
+    glClear (GL_COLOR_BUFFER_BIT);
+  }
+  hidgl_reset_stencil_usage (); /* FIXME: This state is "global", not specific to the FBO! */
+  glDisable (GL_BLEND);
+}
+
+
+static void
+cleanup_fbo_layer (GHidPort *port)
+{
+  glMatrixMode (GL_MODELVIEW);
+  glPopMatrix ();
+  glMatrixMode (GL_PROJECTION);
+  glPopMatrix ();
+  glMatrixMode (GL_MODELVIEW);
+  glPopAttrib ();
+  glBindFramebufferEXT (GL_FRAMEBUFFER_EXT, 0);
+  /* Ubind the texture from the FBO */
+  glFramebufferTexture2DEXT (GL_FRAMEBUFFER_EXT,
+                             GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, 0, 0);
+  glEnable (GL_BLEND);
+}
+
+
 void
 ghid_draw_everything (BoxTypePtr drawn_area)
 {
+  render_priv *priv = gport->render_priv;
   int i, ngroups;
   /* This is the list of layer groups we will draw.  */
   int do_group[MAX_LAYER];
@@ -1777,11 +1942,11 @@ ghid_draw_everything (BoxTypePtr drawn_area)
    */
   if (!TEST_FLAG (CHECKPLANESFLAG, PCB) &&
       gui->set_layer ("invisible", SL (INVISIBLE, 0), 0)) {
+#if 1
     if (PCB->ElementOn) {
       r_search (PCB->Data->name_tree[NAME_INDEX (PCB)], drawn_area, NULL, backN_callback, NULL);
       DrawLayer (&(PCB->Data->BACKSILKLAYER), drawn_area);
     }
-#if 1
     if (!global_view_2d) {
       /* Draw the solder mask if turned on */
       if (gui->set_layer ("soldermask", SL (MASK, BOTTOM), 0)) {
@@ -1814,11 +1979,60 @@ ghid_draw_everything (BoxTypePtr drawn_area)
     gui->set_layer (NULL, SL (FINISHED, 0), 0);
   }
 
+  if (!priv->textures_ok)
+    printf ("Going to have to re-render layers, they are out of date\n");
+
   /* draw all layers in layerstack order */
   for (i = ngroups - 1; i >= 0; i--) {
-    DrawLayerGroup (drawn_groups [i], drawn_area);
+    int depth = compute_depth (i);
+    int layer_visible;
+
+    /* TODO: Cache these textures between frames to avoid the overhead of recomputing */
+    if (!priv->textures_ok) {
+      /* Draw the layer into a texture */
+      setup_fbo_layer (gport, drawn_groups [i], TRUE); /* TRUE is for yes, we want a stencil buffer */
+      DrawLayerGroup (drawn_groups [i], drawn_area);
+      cleanup_fbo_layer (gport);
+      priv->layer_rendered[i] = TRUE;
+    }
 
-#if 1
+    hidgl_set_depth (0);
+
+    {
+      int group = drawn_groups [i];
+      int idx;
+      for (idx = 0; idx < PCB->LayerGroups.Number[group] - 1; idx ++)
+        {
+          int ni = PCB->LayerGroups.Entries[group][idx];
+          if (ni >= 0 && ni < max_copper_layer + 2
+              && PCB->Data->Layer[ni].On)
+            break;
+        }
+      idx = PCB->LayerGroups.Entries[group][idx];
+      if (idx >= 0 && idx < max_copper_layer)
+        layer_visible = PCB->Data->Layer[idx].On;
+      else
+        layer_visible = 0;
+    }
+
+    if (priv->layer_rendered[i] && layer_visible) {
+      /* Now render from the textures */
+      glUseProgram (0);
+      glColor4f (1., 1., 1., 1.);
+      glEnable (GL_TEXTURE_2D);
+
+      glBindTexture (GL_TEXTURE_2D, priv->layer_texture[drawn_groups [i]]);
+      glBegin (GL_QUADS);
+      glTexCoord2d (0.0, 0.0); glVertex3i (0,             0,              depth);
+      glTexCoord2d (1.0, 0.0); glVertex3i (PCB->MaxWidth, 0,              depth);
+      glTexCoord2d (1.0, 1.0); glVertex3i (PCB->MaxWidth, PCB->MaxHeight, depth);
+      glTexCoord2d (0.0, 1.0); glVertex3i (0,             PCB->MaxHeight, depth);
+      glEnd ();
+      glBindTexture (GL_TEXTURE_2D, 0);
+      glDisable (GL_TEXTURE_2D);
+    }
+
+#if 0
     if (!global_view_2d && i > 0 &&
         drawn_groups[i] >= min_phys_group &&
         drawn_groups[i] <= max_phys_group &&
@@ -1905,6 +2119,7 @@ ghid_draw_everything (BoxTypePtr drawn_area)
   Gathering = true;
 
   Settings.ShowSolderSide = save_show_solder;
+  priv->textures_ok = 1;
 }
 
 #define Z_NEAR 3.0
@@ -1929,12 +2144,36 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
                      0, 0, 1, 0,
                      0, 0, 0, 1};
   bool horizon_problem = false;
+  int fbo_width;
+  int fbo_height;
+  int no_layers;
+  static int old_fbo_width = -1;
+  static int old_fbo_height = -1;
+  static int old_no_layers = -1;
 
   buffer.total_triangles = 0;
   buffer.total_vertices = 0;
 
   ghid_start_drawing (port);
 
+  /* Compute the size we're going to use for the layer textures */
+  fbo_width  = PCB->MaxWidth  / gport->zoom;
+  fbo_height = PCB->MaxHeight / gport->zoom;
+
+  /* Work out how many layers are going to be rendered */
+  no_layers = MAX (max_copper_layer, max_group); /* FIXME: HACK */
+
+  if (old_fbo_width != fbo_width ||
+      old_fbo_height != fbo_height ||
+      old_no_layers != no_layers) {
+    /* Setup the FBO for rending to textures */
+    cleanup_fbo (port);
+    setup_fbo (port, fbo_width, fbo_height, no_layers);
+    old_fbo_width = fbo_width;
+    old_fbo_height = fbo_height;
+    old_no_layers = no_layers;
+  }
+
   hidgl_in_context (true);
   hidgl_init ();
   check_gl_drawing_ok_hack = true;
@@ -2278,6 +2517,8 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   hidgl_flush_triangles (&buffer);
   hidgl_finish_triangle_array (&buffer);
 
+//  cleanup_fbo (port);
+
   check_gl_drawing_ok_hack = false;
   hidgl_in_context (false);
   ghid_end_drawing (port);

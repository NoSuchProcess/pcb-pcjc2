Bottom: 6058f1320f501081eb5bd8809eab13548bdcbe64
Top:    48f35e9cacd9881b12fdf1c2216f071e99167436
Author: Andrew Poelstra <asp11@sfu.ca>
Date:   2011-08-29 14:17:55 -0700

Link GHidLayerSelector and GHidMainMenu

Layer visibility-toggle and selection menu items now appear
in the main menu. Accelerators work correctly and are reassigned
on deletion/addition of layers to simulate the old behavior.


---

diff --git a/src/hid/gtk/ghid-layer-selector.c b/src/hid/gtk/ghid-layer-selector.c
index 684f061..582fe67 100644
--- a/src/hid/gtk/ghid-layer-selector.c
+++ b/src/hid/gtk/ghid-layer-selector.c
@@ -56,10 +56,13 @@ struct _GHidLayerSelector
   GtkTreeViewColumn *visibility_column;
 
   GtkActionGroup *action_group;
+  GtkAccelGroup *accel_group;
 
   GSList *radio_group;
   int n_actions;
 
+  gboolean accel_available[20];
+
   gboolean last_activatable;
   gboolean prevent_recursion;
 };
@@ -74,6 +77,9 @@ struct _GHidLayerSelectorClass
 
 struct _layer
 {
+  gint accel_index;   /* Index into ls->accel_available */
+  GtkWidget *pick_item;
+  GtkWidget *view_item;
   GtkToggleAction *view_action;
   GtkRadioAction  *pick_action;
   GtkTreeRowReference *rref;
@@ -102,6 +108,8 @@ free_ldata (GHidLayerSelector *ls, struct _layer *ldata)
       g_object_unref (G_OBJECT (ldata->view_action));
     }
   gtk_tree_row_reference_free (ldata->rref);
+  if (ldata->accel_index >= 0)
+    ls->accel_available[ldata->accel_index] = TRUE;
   g_free (ldata);
 
 }
@@ -278,6 +286,7 @@ ghid_layer_selector_finalize (GObject *object)
   GtkTreeIter iter;
   GHidLayerSelector *ls = (GHidLayerSelector *) object;
 
+  g_object_unref (ls->accel_group);
   g_object_unref (ls->action_group);
 
   gtk_tree_model_get_iter_first (GTK_TREE_MODEL (ls->list_store), &iter);
@@ -334,6 +343,7 @@ ghid_layer_selector_get_type (void)
 GtkWidget *
 ghid_layer_selector_new (void)
 {
+  int i;
   GtkCellRenderer *renderer1 = ghid_cell_renderer_visibility_new ();
   GtkCellRenderer *renderer2 = gtk_cell_renderer_text_new ();
   GtkTreeViewColumn *opacity_col =
@@ -361,9 +371,12 @@ ghid_layer_selector_new (void)
   ls->last_activatable = TRUE;
   ls->visibility_column = opacity_col;
   ls->selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (ls));
+  ls->accel_group = gtk_accel_group_new ();
   ls->action_group = gtk_action_group_new ("LayerSelector");
   ls->prevent_recursion = FALSE;
   ls->n_actions = 0;
+  for (i = 0; i < 20; ++i)
+    ls->accel_available[i] = TRUE;
 
   gtk_tree_view_set_row_separator_func (GTK_TREE_VIEW (ls),
                                         tree_view_separator_func,
@@ -378,7 +391,7 @@ ghid_layer_selector_new (void)
   g_signal_connect (ls->selection, "changed",
                     G_CALLBACK (selection_changed_cb), ls);
 
-  g_object_ref (ls->action_group);
+  g_object_ref (ls->accel_group);
 
   return GTK_WIDGET (ls);
 }
@@ -409,11 +422,12 @@ ghid_layer_selector_add_layer (GHidLayerSelector *ls,
                                gboolean activatable)
 {
   struct _layer *new_layer = NULL;
-  gchar *pname, *vname, *paccel, *vaccel;
+  gchar *pname, *vname;
   gboolean new_iter = TRUE;
   gboolean last_activatable = TRUE;
   GtkTreePath *path;
   GtkTreeIter iter;
+  int i;
 
   /* Look for existing layer with this ID */
   if (gtk_tree_model_get_iter_first (GTK_TREE_MODEL (ls->list_store), &iter))
@@ -484,24 +498,6 @@ ghid_layer_selector_add_layer (GHidLayerSelector *ls,
   /* -- Setup new actions -- */
   vname = g_strdup_printf ("LayerView%d", ls->n_actions);
   pname = g_strdup_printf ("LayerPick%d", ls->n_actions);
-  vaccel = NULL;
-  paccel = NULL;
-
-  /* Determine keyboard accelerators */
-  if (ls->n_actions < 10)
-    {
-      /* Map 1-0 to actions 1-10 (with '0' meaning 10) */
-      int i = (ls->n_actions + 1) % 10;
-      vaccel = g_strdup_printf ("<Ctrl>%d", i);
-      paccel = g_strdup_printf ("%d", i);
-    }
-  else
-    {
-      /* Map 1-0 to actions 11-20 (with '0' meaning 10) */
-      int i = (ls->n_actions + 1) % 10;
-      vaccel = g_strdup_printf ("<Alt><Ctrl>%d", i);
-      paccel = g_strdup_printf ("<Alt>%d", i);
-    }
 
   /* Create row reference for actions */
   path = gtk_tree_model_get_path (GTK_TREE_MODEL (ls->list_store), &iter);
@@ -516,12 +512,6 @@ ghid_layer_selector_add_layer (GHidLayerSelector *ls,
         = gtk_radio_action_new (pname, name, NULL, NULL, user_id);
       gtk_radio_action_set_group (new_layer->pick_action, ls->radio_group);
       ls->radio_group = gtk_radio_action_get_group (new_layer->pick_action);
-      gtk_action_group_add_action_with_accel
-        (ls->action_group,
-         GTK_ACTION (new_layer->pick_action),
-         paccel);
-      g_signal_connect (new_layer->pick_action, "toggled",
-                        G_CALLBACK (menu_pick_cb), new_layer);
     }
   else
     new_layer->pick_action = NULL;
@@ -530,112 +520,148 @@ ghid_layer_selector_add_layer (GHidLayerSelector *ls,
   new_layer->view_action = gtk_toggle_action_new (vname, name, NULL, NULL);
   gtk_toggle_action_set_active (new_layer->view_action, visible);
 
-  gtk_action_group_add_action_with_accel
-    (ls->action_group,
-     GTK_ACTION (new_layer->view_action),
-     vaccel);
-  g_signal_connect (new_layer->view_action, "toggled",
-                    G_CALLBACK (menu_view_cb), new_layer->rref);
-
-
   /* Select new layer, if we need */
   if (activatable
       && !gtk_tree_selection_get_selected (ls->selection, NULL, NULL))
     gtk_tree_selection_select_iter (ls->selection, &iter);
 
-  /* cleanup */
-  if (vaccel)
+  /* Determine keyboard accelerators */
+  for (i = 0; i < 20; ++i)
+    if (ls->accel_available[i])
+      break;
+  if (i < 20)
     {
-      g_free (vaccel);
-      g_free (paccel); 
+      /* Map 1-0 to actions 1-10 (with '0' meaning 10) */
+      gchar *accel1 = g_strdup_printf ("%s%d",
+                                       i < 10 ? "" : "<Alt>",
+                                       (i + 1) % 10);
+      gchar *accel2 = g_strdup_printf ("<Ctrl>%s%d",
+                                       i < 10 ? "" : "<Alt>",
+                                       (i + 1) % 10);
+
+      if (activatable)
+        {
+          GtkAction *action = GTK_ACTION (new_layer->pick_action);
+          gtk_action_set_accel_group (action, ls->accel_group);
+          gtk_action_group_add_action_with_accel (ls->action_group,
+                                                  action,
+                                                  accel1);
+          gtk_action_connect_accelerator (action);
+          g_signal_connect (G_OBJECT (action), "activate",
+                            G_CALLBACK (menu_pick_cb), new_layer);
+        }
+      gtk_action_set_accel_group (GTK_ACTION (new_layer->view_action),
+                                  ls->accel_group);
+      gtk_action_group_add_action_with_accel
+          (ls->action_group, GTK_ACTION (new_layer->view_action), accel2);
+      gtk_action_connect_accelerator (GTK_ACTION (new_layer->view_action));
+      g_signal_connect (G_OBJECT (new_layer->view_action), "activate",
+                        G_CALLBACK (menu_view_cb), new_layer);
+
+      ls->accel_available[i] = FALSE;
+      new_layer->accel_index = i;
+      g_free (accel2);
+      g_free (accel1);
     }
+  else
+    {
+      new_layer->accel_index = -1;
+    }
+  /* finalize new layer struct */
+  new_layer->pick_item = new_layer->view_item = NULL;
+
+  /* cleanup */
   g_free (vname);
   g_free (pname);
 
   ls->n_actions++;
 }
 
-/*! \brief used internally */
-static gboolean
-pick_xml_foreach_func (GtkTreeModel *model, GtkTreePath *path,
-                       GtkTreeIter *iter, gpointer data)
-{
-  struct _layer *ldata;
-  GString *str = data;
-  
-  gtk_tree_model_get (model, iter, STRUCT_COL, &ldata, -1);
-  if (ldata && ldata->pick_action)
-    g_string_append_printf (str, "<menuitem action=\"%s\" />\n",
-                     gtk_action_get_name (GTK_ACTION (ldata->pick_action)));
-  return FALSE;
-}
-/*! \brief used internally */
-static gboolean
-view_xml_foreach_func (GtkTreeModel *model, GtkTreePath *path,
-                       GtkTreeIter *iter, gpointer data)
-{
-  struct _layer *ldata;
-  GString *str = data;
-  
-  gtk_tree_model_get (model, iter, STRUCT_COL, &ldata, -1);
-  if (ldata && ldata->view_action)
-    g_string_append_printf (str, "<menuitem action=\"%s\" />\n",
-                     gtk_action_get_name (GTK_ACTION (ldata->view_action)));
-  return FALSE;
-}
- 
-/*! \brief Get the "Current Layer" menu description of a layer selector
+/*! \brief Install the "Current Layer" menu items for a layer selector
  *  \par Function Description
- *  Returns the XML content used by Gtk in building the layer-selection
- *  part of the menu. This is a radio-button list describing which layer
- *  is active.
+ *  Takes a menu shell and installs menu items for layer selection in
+ *  the shell, at the given position.
  *
- *  \param [in] ls            The selector to be acted on
+ *  \param [in] ls      The selector to be acted on
+ *  \param [in] shell   The menu to install the items in
+ *  \param [in] pos     The position in the menu to install items
  *
- *  \return the requested XML
+ *  \return the number of items installed
  */
-gchar *
-ghid_layer_selector_get_pick_xml (GHidLayerSelector *ls)
+gint
+ghid_layer_selector_install_pick_items (GHidLayerSelector *ls,
+                                        GtkMenuShell *shell, gint pos)
 {
-  GString *str = g_string_new ("");
-  gtk_tree_model_foreach (GTK_TREE_MODEL (ls->list_store),
-                          pick_xml_foreach_func, str);
-  return g_string_free (str, FALSE);
+  GtkTreeIter iter;
+  int n = 0;
+
+  gtk_tree_model_get_iter_first (GTK_TREE_MODEL (ls->list_store), &iter);
+  do
+    {
+      struct _layer *ldata;
+      gtk_tree_model_get (GTK_TREE_MODEL (ls->list_store),
+                          &iter, STRUCT_COL, &ldata, -1);
+      if (ldata && ldata->pick_action)
+        {
+          GtkAction *action = GTK_ACTION (ldata->pick_action);
+          ldata->pick_item = gtk_action_create_menu_item (action);
+          gtk_menu_shell_insert (shell, ldata->pick_item, pos + n);
+          ++n;
+        }
+    }
+  while (gtk_tree_model_iter_next (GTK_TREE_MODEL (ls->list_store), &iter));
+
+  return n;
 }
 
-/*! \brief Get the "Shown Layers" menu description of a layer selector
+/*! \brief Install the "Shown Layers" menu items for a layer selector
  *  \par Function Description
- *  Returns the XML content used by Gtk in building the layer-selection
- *  part of the menu. This is a toggle-button list describing which layer(s)
- *  are visible.
+ *  Takes a menu shell and installs menu items for layer selection in
+ *  the shell, at the given position.
  *
- *  \param [in] ls            The selector to be acted on
+ *  \param [in] ls      The selector to be acted on
+ *  \param [in] shell   The menu to install the items in
+ *  \param [in] pos     The position in the menu to install items
  *
- *  \return the requested XML
+ *  \return the number of items installed
  */
-gchar *
-ghid_layer_selector_get_view_xml (GHidLayerSelector *ls)
+gint
+ghid_layer_selector_install_view_items (GHidLayerSelector *ls,
+                                        GtkMenuShell *shell, gint pos)
 {
-  GString *str = g_string_new ("");
-  gtk_tree_model_foreach (GTK_TREE_MODEL (ls->list_store),
-                          view_xml_foreach_func, str);
-  return g_string_free (str, FALSE);
+  GtkTreeIter iter;
+  int n = 0;
+
+  gtk_tree_model_get_iter_first (GTK_TREE_MODEL (ls->list_store), &iter);
+  do
+    {
+      struct _layer *ldata;
+      gtk_tree_model_get (GTK_TREE_MODEL (ls->list_store),
+                          &iter, STRUCT_COL, &ldata, -1);
+      if (ldata && ldata->view_action)
+        {
+          GtkAction *action = GTK_ACTION (ldata->view_action);
+          ldata->view_item = gtk_action_create_menu_item (action);
+          gtk_menu_shell_insert (shell, ldata->view_item, pos + n);
+          ++n;
+        }
+    }
+  while (gtk_tree_model_iter_next (GTK_TREE_MODEL (ls->list_store), &iter));
+
+  return n;
 }
 
-/*! \brief Get the GtkActionGroup containing accelerators, etc, of a layer selector
+/*! \brief Returns the GtkAccelGroup of a layer selector
  *  \par Function Description
- *  Returns the GtkActionGroup containing the toggle and radio buttons used
- *  in the menu. Also contains the accelerators. This action group should be
- *  added to the main UI. See Gtk docs for details.
  *
  *  \param [in] ls            The selector to be acted on
  *
- *  \return the action group of the selector
+ *  \return the accel group of the selector
  */
-GtkActionGroup *
-ghid_layer_selector_get_action_group (GHidLayerSelector *ls)
+GtkAccelGroup *
+ghid_layer_selector_get_accel_group (GHidLayerSelector *ls)
 {
-  return ls->action_group;
+  return ls->accel_group;
 }
 
 /*! \brief used internally */
diff --git a/src/hid/gtk/ghid-layer-selector.h b/src/hid/gtk/ghid-layer-selector.h
index bfeffe9..10355a7 100644
--- a/src/hid/gtk/ghid-layer-selector.h
+++ b/src/hid/gtk/ghid-layer-selector.h
@@ -26,9 +26,13 @@ void ghid_layer_selector_add_layer (GHidLayerSelector *ls,
                                     gboolean visible,
                                     gboolean activatable);
 GtkAccelGroup *ghid_layer_selector_get_accel_group (GHidLayerSelector *ls);
-gchar *ghid_layer_selector_get_pick_xml (GHidLayerSelector *ls);
-gchar *ghid_layer_selector_get_view_xml (GHidLayerSelector *ls);
-GtkActionGroup *ghid_layer_selector_get_action_group (GHidLayerSelector *ls);
+
+gint ghid_layer_selector_install_pick_items (GHidLayerSelector *ls,
+                                             GtkMenuShell *shell, gint pos);
+gint ghid_layer_selector_install_view_items (GHidLayerSelector *ls,
+                                             GtkMenuShell *shell, gint pos);
+
+GtkAccelGroup *ghid_layer_selector_get_accel_group (GHidLayerSelector *ls);
 
 void ghid_layer_selector_toggle_layer (GHidLayerSelector *ls, 
                                        gint user_id);
diff --git a/src/hid/gtk/ghid-main-menu.c b/src/hid/gtk/ghid-main-menu.c
index 945b522..5693c56 100644
--- a/src/hid/gtk/ghid-main-menu.c
+++ b/src/hid/gtk/ghid-main-menu.c
@@ -13,6 +13,7 @@
 #include "pcb-printf.h"
 
 #include "ghid-main-menu.h"
+#include "ghid-layer-selector.h"
 
 void Message (const char *, ...);
 
@@ -36,10 +37,13 @@ struct _GHidMainMenu
   GList *actions;
   GHashTable *popup_table;
 
+  gint n_layer_views;
+  gint n_layer_picks;
+  gint n_route_styles;
+
   GCallback action_cb;
   void (*special_key_cb) (const char *accel, GtkAction *action,
                           const Resource *node);
-
 };
 
 struct _GHidMainMenuClass
@@ -433,6 +437,9 @@ ghid_main_menu_new (GCallback action_cb,
   mm->layer_view_pos = 0;
   mm->layer_pick_pos = 0;
   mm->route_style_pos = 0;
+  mm->n_layer_views = 0;
+  mm->n_layer_picks = 0;
+  mm->n_route_styles = 0;
   mm->layer_view_shell = NULL;
   mm->layer_pick_shell = NULL;
   mm->route_style_shell = NULL;
@@ -499,6 +506,50 @@ ghid_main_menu_update_toggle_state (GHidMainMenu *menu,
     }
 }
 
+/*! \brief Installs or updates layer selector items */
+void
+ghid_main_menu_install_layer_selector (GHidMainMenu *mm,
+                                       GHidLayerSelector *ls)
+{
+  GList *children;
+
+  /* @layerview */
+  if (mm->layer_view_shell)
+    {
+      /* Remove old children */
+      children = gtk_container_get_children
+                   (GTK_CONTAINER (mm->layer_view_shell));
+      children = g_list_nth (children, mm->layer_view_pos);
+      while (children && mm->n_layer_views--)
+        {
+          gtk_container_remove (GTK_CONTAINER (mm->layer_view_shell),
+                                children->data);
+          children = g_list_next (children);
+        }
+      /* Install new ones */
+      mm->n_layer_views = ghid_layer_selector_install_view_items
+                            (ls, mm->layer_view_shell, mm->layer_view_pos);
+    }
+
+  /* @layerpick */
+  if (mm->layer_pick_shell)
+    {
+      /* Remove old children */
+      children = gtk_container_get_children
+                   (GTK_CONTAINER (mm->layer_pick_shell));
+      children = g_list_nth (children, mm->layer_pick_pos);
+      while (children && mm->n_layer_picks--)
+        {
+          gtk_container_remove (GTK_CONTAINER (mm->layer_pick_shell),
+                                children->data);
+          children = g_list_next (children);
+        }
+      /* Install new ones */
+      mm->n_layer_picks = ghid_layer_selector_install_pick_items
+                            (ls, mm->layer_pick_shell, mm->layer_pick_pos);
+    }
+}
+
 /*! \brief Returns the menu bar's accelerator group */
 GtkAccelGroup *
 ghid_main_menu_get_accel_group (GHidMainMenu *menu)
diff --git a/src/hid/gtk/ghid-main-menu.h b/src/hid/gtk/ghid-main-menu.h
index 3b8c728..d667e34 100644
--- a/src/hid/gtk/ghid-main-menu.h
+++ b/src/hid/gtk/ghid-main-menu.h
@@ -1,12 +1,13 @@
 #ifndef GHID_MAIN_MENU_H__
 #define GHID_MAIN_MENU_H__
 
-#include "resource.h"
-
 #include <glib.h>
 #include <glib-object.h>
 #include <gtk/gtk.h>
 
+#include "ghid-layer-selector.h"
+#include "resource.h"
+
 G_BEGIN_DECLS  /* keep c++ happy */
 
 #define GHID_MAIN_MENU_TYPE            (ghid_main_menu_get_type ())
@@ -34,5 +35,8 @@ void ghid_main_menu_add_popup_resource (GHidMainMenu *menu, const char *name,
                                         const Resource *res);
 GtkMenu *ghid_main_menu_get_popup (GHidMainMenu *menu, const char *name);
 
+void ghid_main_menu_install_layer_selector (GHidMainMenu *mm,
+                                            GHidLayerSelector *ls);
+
 G_END_DECLS  /* keep c++ happy */
 #endif
diff --git a/src/hid/gtk/gui-top-window.c b/src/hid/gtk/gui-top-window.c
index b2d9c22..c292660 100644
--- a/src/hid/gtk/gui-top-window.c
+++ b/src/hid/gtk/gui-top-window.c
@@ -598,7 +598,6 @@ make_top_menubar (GtkWidget *menu_bar, GtkWidget * hbox, GHidPort * port)
 {
   GtkWidget *frame;
   GtkActionGroup *actions;
-  GtkActionGroup *layer_actions;
 
   frame = gtk_frame_new (NULL);
   gtk_box_pack_start (GTK_BOX (hbox), frame, FALSE, TRUE, 0);
@@ -609,12 +608,13 @@ make_top_menubar (GtkWidget *menu_bar, GtkWidget * hbox, GHidPort * port)
   ghidgui->main_actions = actions;
 
   make_menu_actions (actions, port);
-  layer_actions = ghid_layer_selector_get_action_group
-          (GHID_LAYER_SELECTOR (ghidgui->layer_selector));
  
   gtk_window_add_accel_group (GTK_WINDOW (gport->top_window),
 			      ghid_main_menu_get_accel_group
                                 (GHID_MAIN_MENU (ghidgui->menu_bar)));
+  gtk_window_add_accel_group (GTK_WINDOW (gport->top_window),
+			      ghid_layer_selector_get_accel_group
+                                (GHID_LAYER_SELECTOR (ghidgui->layer_selector)));
 
   gtk_container_add (GTK_CONTAINER (frame), menu_bar);
 
@@ -842,6 +842,9 @@ ghid_layer_buttons_update (void)
      get_layer_delete);
   make_layer_buttons (ghidgui->layer_selector);
   make_virtual_layer_buttons (ghidgui->layer_selector);
+  ghid_main_menu_install_layer_selector
+      (GHID_MAIN_MENU (ghidgui->menu_bar),
+       GHID_LAYER_SELECTOR (ghidgui->layer_selector));
 
   /* Sync selected layer with PCB's state */
   if (PCB->RatDraw)

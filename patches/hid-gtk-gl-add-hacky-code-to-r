Bottom: 95b03438c3308b444926ef3b08a55a7f8f57af71
Top:    d9b5704292a9e877765563591a60248778d997ef
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2013-06-05 12:07:57 +0100

hid/gtk (GL): Add hacky code to render outline of board, and mask cutout geometry


---

diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index a4fd1e2..5985318 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -1551,12 +1551,111 @@ clearPad_callback_solid (const BoxType * b, void *cl)
 }
 
 static void
+ensure_board_outline (void)
+{
+  if (!PCB->Data->outline_valid) {
+
+    if (PCB->Data->outline != NULL)
+      poly_Free (&PCB->Data->outline);
+
+    PCB->Data->outline = board_outline_poly ();
+    PCB->Data->outline_valid = true;
+  }
+}
+
+static void
+fill_board_outline (hidGC gc, const BoxType *drawn_area)
+{
+  PolygonType polygon;
+
+  ensure_board_outline ();
+
+  polygon.Clipped = PCB->Data->outline;
+  polygon.NoHoles = NULL;
+  polygon.NoHolesValid = 0;
+  if (drawn_area)
+    polygon.BoundingBox = *drawn_area;
+  polygon.Flags = NoFlags ();
+  SET_FLAG (FULLPOLYFLAG, &polygon);
+  gui->graphics->fill_pcb_polygon (gc, &polygon, drawn_area);
+  poly_FreeContours (&polygon.NoHoles);
+}
+
+struct outline_info {
+  hidGC gc;
+  float z1;
+  float z2;
+};
+
+static int
+fill_outline_hole_cb (PLINE *pl, void *user_data)
+{
+  struct outline_info *info = (struct outline_info *)user_data;
+  PolygonType polygon;
+  PLINE *pl_copy = NULL;
+
+  poly_CopyContour (&pl_copy, pl);
+  poly_InvContour (pl_copy);
+  polygon.Clipped = poly_Create ();
+  poly_InclContour (polygon.Clipped, pl_copy);
+
+//  if (polygon.Clipped->contours == NULL)
+//    return 0;
+
+  polygon.NoHoles = NULL;
+  polygon.NoHolesValid = 0;
+  polygon.Flags = NoFlags ();
+  SET_FLAG (FULLPOLYFLAG, &polygon);
+
+  /* XXX: For some reason, common_fill_pcb_polygon doesn't work for all contours here.. not sure why */
+//  common_fill_pcb_polygon (info->gc, &polygon, NULL);
+  gui->graphics->fill_pcb_polygon (info->gc, &polygon, NULL);
+
+  poly_FreeContours (&polygon.NoHoles);
+
+  poly_Free (&polygon.Clipped);
+
+  return 0;
+}
+
+static void
+fill_board_outline_holes (hidGC gc, const BoxType *drawn_area)
+{
+  PolygonType polygon, p;
+  struct outline_info info;
+
+  ensure_board_outline ();
+
+  polygon.Clipped = PCB->Data->outline;
+  polygon.NoHoles = NULL;
+  polygon.NoHolesValid = 0;
+  if (drawn_area)
+    polygon.BoundingBox = *drawn_area;
+  polygon.Flags = NoFlags ();
+  SET_FLAG (FULLPOLYFLAG, &polygon);
+
+  info.gc = gc;
+
+  PolygonHoles (&polygon, drawn_area, fill_outline_hole_cb, &info);
+
+  p = polygon;
+  for (p.Clipped = polygon.Clipped->f;
+       p.Clipped != polygon.Clipped;
+       p.Clipped = p.Clipped->f) {
+    PolygonHoles (&p, drawn_area, fill_outline_hole_cb, &info);
+  }
+
+//  poly_FreeContours (&polygon.NoHoles);
+
+  hidgl_flush_triangles (&buffer);
+}
+
+static void
 GhidDrawMask (int side, BoxType * screen)
 {
   static bool first_run = true;
   static GLuint texture;
   int thin = TEST_FLAG(THINDRAWFLAG, PCB) || TEST_FLAG(THINDRAWPOLYFLAG, PCB);
-  PolygonType polygon;
 
   OutputType *out = &Output;
 
@@ -1609,14 +1708,8 @@ GhidDrawMask (int side, BoxType * screen)
   glEnable (GL_TEXTURE_2D);
 #endif
 
-  if (!PCB->Data->outline_valid) {
-
-    if (PCB->Data->outline != NULL)
-      poly_Free (&PCB->Data->outline);
-
-    PCB->Data->outline = board_outline_poly ();
-    PCB->Data->outline_valid = true;
-  }
+#if 0
+  ensure_board_outline ();
 
   polygon.Clipped = PCB->Data->outline;
   polygon.NoHoles = NULL;
@@ -1627,8 +1720,12 @@ GhidDrawMask (int side, BoxType * screen)
   SET_FLAG (FULLPOLYFLAG, &polygon);
   gui->graphics->fill_pcb_polygon (out->fgGC, &polygon, screen);
   poly_FreeContours (&polygon.NoHoles);
+#endif
+
+  fill_board_outline (out->fgGC, screen);
+
   ghid_set_alpha_mult (out->fgGC, 1.0);
-  hidgl_flush_triangles (&buffer);
+//  hidgl_flush_triangles (&buffer);
 #if 0
   glDisable (GL_TEXTURE_GEN_S);
   glDisable (GL_TEXTURE_GEN_T);
@@ -1642,6 +1739,84 @@ GhidDrawMask (int side, BoxType * screen)
   first_run = false;
 }
 
+static void
+draw_outline_contour (hidGC gc, PLINE *pl, float z1, float z2)
+{
+  VNODE *v;
+  GLfloat x, y;
+
+  hidgl_ensure_vertex_space (&buffer, 2 * pl->Count + 2 + 2);
+
+  /* NB: Repeated first virtex to separate from other tri-strip */
+
+  x = pl->head.point[0];
+  y = pl->head.point[1];
+
+  hidgl_add_vertex_3D_tex (&buffer, x, y, z1, 0.0, 0.0);
+  hidgl_add_vertex_3D_tex (&buffer, x, y, z1, 0.0, 0.0);
+  hidgl_add_vertex_3D_tex (&buffer, x, y, z2, 0.0, 0.0);
+
+  v = pl->head.next;
+
+  do
+    {
+      x = v->point[0];
+      y = v->point[1];
+
+      hidgl_add_vertex_3D_tex (&buffer, x, y, z1, 0.0, 0.0);
+      hidgl_add_vertex_3D_tex (&buffer, x, y, z2, 0.0, 0.0);
+    }
+  while ((v = v->next) != pl->head.next);
+
+  /* NB: Repeated last virtex to separate from other tri-strip */
+  hidgl_add_vertex_3D_tex (&buffer, x, y, z2, 0.0, 0.0);
+}
+
+static int
+outline_hole_cb (PLINE *pl, void *user_data)
+{
+  struct outline_info *info = (struct outline_info *)user_data;
+
+  draw_outline_contour (info->gc, pl, info->z1, info->z2);
+  return 0;
+}
+
+static void
+ghid_draw_outline_between_layers (int from_layer, int to_layer, BoxType *drawn_area)
+{
+  PolygonType polygon, p;
+  struct outline_info info;
+
+  ensure_board_outline ();
+
+  polygon.Clipped = PCB->Data->outline;
+  polygon.NoHoles = NULL;
+  polygon.NoHolesValid = 0;
+  if (drawn_area)
+    polygon.BoundingBox = *drawn_area;
+  polygon.Flags = NoFlags ();
+  SET_FLAG (FULLPOLYFLAG, &polygon);
+
+  info.gc = Output.fgGC;
+  info.z1 = compute_depth (from_layer);
+  info.z2 = compute_depth (to_layer);
+
+  draw_outline_contour (info.gc, polygon.Clipped->contours, info.z1, info.z2);
+  PolygonHoles (&polygon, drawn_area, outline_hole_cb, &info);
+
+  p = polygon;
+  for (p.Clipped = polygon.Clipped->f;
+       p.Clipped != polygon.Clipped;
+       p.Clipped = p.Clipped->f) {
+    draw_outline_contour (info.gc, p.Clipped->contours, info.z1, info.z2);
+    PolygonHoles (&p, drawn_area, outline_hole_cb, &info);
+  }
+
+  poly_FreeContours (&polygon.NoHoles);
+
+  hidgl_flush_triangles (&buffer);
+}
+
 static int
 GhidDrawLayerGroup (int group, const BoxType * screen)
 {
@@ -1684,6 +1859,7 @@ GhidDrawLayerGroup (int group, const BoxType * screen)
         gui->graphics->set_color (Output.bgGC, PCB->MaskColor);
         if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
         if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
+        fill_board_outline_holes (Output.bgGC, screen);
         hidgl_flush_triangles (&buffer);
         glPopAttrib ();
       }
@@ -1708,6 +1884,7 @@ GhidDrawLayerGroup (int group, const BoxType * screen)
           /* Mask out drilled holes on this layer */
           if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
           if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
+          fill_board_outline_holes (Output.bgGC, screen);
           hidgl_flush_triangles (&buffer);
           glPopAttrib ();
         }
@@ -1994,6 +2171,7 @@ ghid_draw_everything (BoxType *drawn_area)
       cyl_info.scale = gport->view.coord_per_px;
       gui->graphics->set_color (Output.fgGC, "drill");
       ghid_set_alpha_mult (Output.fgGC, alpha_mult * 0.75);
+      ghid_draw_outline_between_layers (cyl_info.from_layer, cyl_info.to_layer, drawn_area);
       if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_hole_cyl_callback, &cyl_info);
       if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, via_hole_cyl_callback, &cyl_info);
     }
@@ -2020,6 +2198,7 @@ ghid_draw_everything (BoxType *drawn_area)
       glDepthMask (GL_FALSE);
       if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, hole_callback, NULL);
       if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, hole_callback, NULL);
+      fill_board_outline_holes (Output.bgGC, drawn_area);
       hidgl_flush_triangles (&buffer);
       glPopAttrib ();
     }

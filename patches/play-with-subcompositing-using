Bottom: e967874b10da2ccdea14f9b96428c275e28cfe4e
Top:    4020010c3346fe6f9c152e6ec332123c9c5015bc
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-02-21 02:37:50 +0000

Play with subcompositing using the stencil buffer




---

diff --git a/src/draw.c b/src/draw.c
index 30362f4..9d8c621 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -949,6 +949,9 @@ DrawLayerGroup (int group, const BoxType * screen)
 	      info.arg = False;
 	    }
 
+          /* Reset the compositing HACK */
+          gui->set_layer (0, group, 0);
+
 	  if (TEST_FLAG (CHECKPLANESFLAG, PCB))
 	    continue;
 
@@ -967,6 +970,8 @@ DrawLayerGroup (int group, const BoxType * screen)
           gui->fill_rect (Output.fgGC, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
           gui->use_mask (HID_MASK_OFF);
 #endif
+          /* Reset the compositing HACK */
+          gui->set_layer (0, group, 0);
 	}
     }
   if (n_entries > 1)
diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index 11d5595..14a974a 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -729,25 +729,27 @@ hidgl_fill_pcb_polygon (PolygonType *poly, BoxType *clip_box, double scale)
   gluTessCallback(info.tobj, GLU_TESS_COMBINE, myCombine);
   gluTessCallback(info.tobj, GLU_TESS_ERROR, myError);
 
-  glClearStencil (0);
-  glClear (GL_STENCIL_BUFFER_BIT);
+  glStencilFunc (GL_ALWAYS, 2, 2);            // Always pass stencil test, reference value is 2
+
+//  glClear (GL_STENCIL_BUFFER_BIT);
   glColorMask (0, 0, 0, 0);                   // Disable writting in color buffer
-  glEnable (GL_STENCIL_TEST);
+//  glEnable (GL_STENCIL_TEST);
 
   i = 0;
   cc = 1;
 
   /* Drawing operations set the stencil buffer to '1' */
-  glStencilFunc (GL_ALWAYS, 1, 1);            // Test always passes, value written 1
-  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value (with 1)
+//  glStencilFunc (GL_ALWAYS, 1, 1);            // Test always passes, value written 1
+//  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value (with 1)
 
   r_search (poly->Clipped->contour_tree, clip_box, NULL, do_hole, &info);
   hidgl_flush_triangles (&buffer);
 
-  /* Drawing operations as masked to areas where the stencil buffer is '1' */
+  /* Drawing operations as masked to areas where the stencil buffer is '0' */
   glColorMask (1, 1, 1, 1);                   // Enable drawing of r, g, b & a
-  glStencilFunc (GL_EQUAL, 0, 1);             // Draw only where stencil buffer is 0
-  glStencilOp (GL_KEEP, GL_KEEP, GL_KEEP);    // Stencil buffer read only
+//  glStencilFunc (GL_EQUAL, 0, 1);             // Draw only where stencil buffer is 0
+//  glStencilOp (GL_KEEP, GL_KEEP, GL_KEEP);    // Stencil buffer read only
+  glStencilFunc (GL_GREATER, 1, 3);                // Pass stencil test if all bits clear, reference value is 1
 
   /* Draw the polygon outer */
   gluTessBeginPolygon (info.tobj, NULL);
@@ -755,8 +757,14 @@ hidgl_fill_pcb_polygon (PolygonType *poly, BoxType *clip_box, double scale)
   gluTessEndPolygon (info.tobj);
   hidgl_flush_triangles (&buffer);
 
+//  glClear (GL_STENCIL_BUFFER_BIT);
+//  glDisable (GL_STENCIL_TEST);                // Disable Stencil test
+  glStencilFunc (GL_GREATER, 1, 1);                // Pass stencil test stencil buffer bit 1 is 0, reference value is 1
+
+  /* Clear the second stencil buffer bits */
+  glStencilMask (2);
   glClear (GL_STENCIL_BUFFER_BIT);
-  glDisable (GL_STENCIL_TEST);                // Disable Stencil test
+  glStencilMask (~0);
 
   gluDeleteTess (info.tobj);
   myFreeCombined ();
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 96585ad..0821758 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -579,6 +579,10 @@ ghid_set_layer (const char *name, int group, int empty)
 	     && group <
 	     max_layer) ? PCB->LayerGroups.Entries[group][0] : group;
 
+  /* Reset stencil buffer so we can paint anywhere */
+  hidgl_flush_triangles (&buffer);
+  glClear (GL_STENCIL_BUFFER_BIT);
+
   if (idx >= 0 && idx < max_layer + 2) {
     gport->trans_lines = TRUE;
     return /*pinout ? 1 : */ PCB->Data->Layer[idx].On;
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index 4de2492..93f295c 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -987,11 +987,12 @@ ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
   glLoadIdentity ();
   glTranslatef (0.0f, 0.0f, -Z_NEAR);
 
+  glEnable (GL_STENCIL_TEST);
   glClearColor (gport->bg_color.red / 65535.,
                 gport->bg_color.green / 65535.,
                 gport->bg_color.blue / 65535.,
                 1.);
-
+  glClearStencil (0);
   glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
 
   region.X1 = MIN (Px (ev->area.x), Px (ev->area.x + ev->area.width + 1));
@@ -1067,6 +1068,13 @@ ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
   hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
 
+  /* Setup stenciling */
+  /* Drawing operations set the stencil buffer to '1' */
+//  glStencilFunc (GL_ALWAYS, 1, 1);            // Test always passes, value written 1
+  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value (with 1)
+  /* Drawing operations as masked to areas where the stencil buffer is '0' */
+  glStencilFunc (GL_GREATER, 1, 1);             // Draw only where stencil buffer is 0
+
   glPushMatrix ();
   glScalef ((ghid_flip_x ? -1. : 1.) / gport->zoom,
             (ghid_flip_y ? -1. : 1.) / gport->zoom, 1);
diff --git a/src/hid/gtk/gui-pinout-preview.c b/src/hid/gtk/gui-pinout-preview.c
index f59f22b..935e435 100644
--- a/src/hid/gtk/gui-pinout-preview.c
+++ b/src/hid/gtk/gui-pinout-preview.c
@@ -219,7 +219,7 @@ ghid_pinout_preview_expose (GtkWidget * widget, GdkEventExpose * ev)
                 gport->bg_color.green / 65535.,
                 gport->bg_color.blue / 65535.,
                 1.);
-
+  glClearStencil (0);
   glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
 
   /* call the drawing routine */

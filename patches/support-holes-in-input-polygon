Bottom: b8f623e816d9de7dd542f66b2e052ebc45a781ea
Top:    2451e6090da9ab68b1a32fa9b03ef136f8d1651c
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-06-05 13:09:31 +0100

Support holes in input polygons (incl. file-format addition)


---

diff --git a/src/action.c b/src/action.c
index 46f45a0..9d96edb 100644
--- a/src/action.c
+++ b/src/action.c
@@ -1641,9 +1641,8 @@ NotifyMode (void)
 			GetLowestDistancePolygonPoint (fake.poly, Note.X,
 						       Note.Y);
 		      fake.line.Point1 = fake.poly->Points[polyIndex];
-		      fake.line.Point2 = (polyIndex) ?
-			fake.poly->Points[polyIndex - 1]
-			: fake.poly->Points[fake.poly->PointN - 1];
+		      fake.line.Point2 = fake.poly->Points[
+			  prev_contour_point (fake.poly, polyIndex)];
 		      Crosshair.AttachedObject.Ptr2 = &fake.line;
 
 		    }
diff --git a/src/autoroute.c b/src/autoroute.c
index b6bf91d..7fb7443 100644
--- a/src/autoroute.c
+++ b/src/autoroute.c
@@ -768,6 +768,7 @@ AddPolygon (PointerListType layergroupboxes[], Cardinal layer,
 			     polygon->BoundingBox.Y2,
 			     layergroup, polygon, style);
   if (polygon->PointN == 4 &&
+      polygon->HoleIndexN == 0 &&
       (polygon->Points[0].X == polygon->Points[1].X ||
        polygon->Points[0].Y == polygon->Points[1].Y) &&
       (polygon->Points[1].X == polygon->Points[2].X ||
diff --git a/src/buffer.c b/src/buffer.c
index e04ae2a..b776aac 100644
--- a/src/buffer.c
+++ b/src/buffer.c
@@ -1001,7 +1001,7 @@ polygon_is_rectangle (PolygonTypePtr poly)
 {
   int i, best;
   PointType temp[4];
-  if (poly->PointN != 4)
+  if (poly->PointN != 4 || poly->HoleIndexN != 0)
     return 0;
   best = 0;
   for (i=1; i<4; i++)
diff --git a/src/copy.c b/src/copy.c
index ffa0ed3..ee594f3 100644
--- a/src/copy.c
+++ b/src/copy.c
@@ -95,6 +95,7 @@ static ObjectFunctionType CopyFunctions = {
 PolygonTypePtr
 CopyPolygonLowLevel (PolygonTypePtr Dest, PolygonTypePtr Src)
 {
+#warning FIXME FOR HOLES
   /* copy all data */
   POLYGONPOINT_LOOP (Src);
   {
diff --git a/src/create.c b/src/create.c
index d1bb3fb..cb0fb2c 100644
--- a/src/create.c
+++ b/src/create.c
@@ -637,6 +637,17 @@ CreateNewPointInPolygon (PolygonTypePtr Polygon, LocationType X,
   return (point);
 }
 
+/* ---------------------------------------------------------------------------
+ * creates a new hole in a polygon
+ */
+PolygonType *
+CreateNewHoleInPolygon (PolygonType *Polygon)
+{
+  Cardinal *holeindex = GetHoleIndexMemoryInPolygon (Polygon);
+  *holeindex = Polygon->PointN;
+  return Polygon;
+}
+
 static char *refdes_map_file = "refdes.map";
 static GHashTable *refdes_map_table = NULL;
 
diff --git a/src/create.h b/src/create.h
index 5c50151..da95919 100644
--- a/src/create.h
+++ b/src/create.h
@@ -62,6 +62,7 @@ TextTypePtr CreateNewText (LayerTypePtr, FontTypePtr, LocationType,
 PolygonTypePtr CreateNewPolygon (LayerTypePtr, FlagType);
 PointTypePtr CreateNewPointInPolygon (PolygonTypePtr,
 				      LocationType, LocationType);
+PolygonType *CreateNewHoleInPolygon (PolygonType *polygon);
 void RefdesMapInit (void);
 ElementTypePtr CreateNewElement (DataTypePtr, ElementTypePtr,
 				 FontTypePtr, FlagType, char *, char *,
diff --git a/src/crosshair.c b/src/crosshair.c
index 9d85373..d1aa847 100644
--- a/src/crosshair.c
+++ b/src/crosshair.c
@@ -48,6 +48,7 @@
 #include "misc.h"
 #include "mymem.h"
 #include "search.h"
+#include "polygon.h"
 
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
@@ -93,15 +94,16 @@ static void
 XORPolygon (PolygonTypePtr polygon, LocationType dx, LocationType dy)
 {
   int i;
-  for (i = 0; i < polygon->PointN - 1; i++)
-    gui->draw_line (Crosshair.GC,
-		    polygon->Points[i].X + dx, polygon->Points[i].Y + dy,
-		    polygon->Points[i + 1].X + dx,
-		    polygon->Points[i + 1].Y + dy);
-  if (i > 1)
-    gui->draw_line (Crosshair.GC,
-		    polygon->Points[i].X + dx, polygon->Points[i].Y + dy,
-		    polygon->Points[0].X + dx, polygon->Points[0].Y + dy);
+  int next;
+  for (i = 0; i < polygon->PointN; i++)
+    {
+      next = next_contour_point (polygon, i);
+      gui->draw_line (Crosshair.GC,
+                      polygon->Points[i].X + dx,
+                      polygon->Points[i].Y + dy,
+                      polygon->Points[next].X + dx,
+                      polygon->Points[next].Y + dy);
+    }
 }
 
 /*-----------------------------------------------------------
@@ -473,35 +475,27 @@ XORDrawMoveOrCopyObject (void)
     case POLYGONPOINT_TYPE:
       {
 	PolygonTypePtr polygon;
-	PointTypePtr point, previous, following;
+	PointTypePtr point;
+	int point_idx, prev, next;
 
 	polygon = (PolygonTypePtr) Crosshair.AttachedObject.Ptr2;
 	point = (PointTypePtr) Crosshair.AttachedObject.Ptr3;
+        point_idx = polygon_point_idx (polygon, point);
 
 	/* get previous and following point */
-	if (point == polygon->Points)
-	  {
-	    previous = &polygon->Points[polygon->PointN - 1];
-	    following = point + 1;
-	  }
-	else if (point == &polygon->Points[polygon->PointN - 1])
-	  {
-	    previous = point - 1;
-	    following = &polygon->Points[0];
-	  }
-	else
-	  {
-	    previous = point - 1;
-	    following = point + 1;
-	  }
+	prev = prev_contour_point (polygon, point_idx);
+	next = next_contour_point (polygon, point_idx);
 
 	/* draw the two segments */
 	gui->draw_line (Crosshair.GC,
-			previous->X,
-			previous->Y, point->X + dx, point->Y + dy);
+			polygon->Points[prev].X,
+			polygon->Points[prev].Y,
+			point->X + dx, point->Y + dy);
 	gui->draw_line (Crosshair.GC,
 			point->X + dx,
-			point->Y + dy, following->X, following->Y);
+			point->Y + dy,
+			polygon->Points[next].X,
+			polygon->Points[next].Y);
 	break;
       }
 
diff --git a/src/file.c b/src/file.c
index 390ca5e..79a28da 100644
--- a/src/file.c
+++ b/src/file.c
@@ -828,14 +828,32 @@ WriteLayerData (FILE * FP, Cardinal Number, LayerTypePtr layer)
 	{
 	  PolygonTypePtr polygon = &layer->Polygon[n];
 	  int p, i = 0;
+	  int hole = 0;
 	  fprintf (FP, "\tPolygon(%s)\n\t(", F2S (polygon, POLYGON_TYPE));
 	  for (p = 0; p < polygon->PointN; p++)
 	    {
 	      PointTypePtr point = &polygon->Points[p];
+
+	      if (hole < polygon->HoleIndexN &&
+		  p == polygon->HoleIndex[hole])
+		{
+		  if (hole > 0)
+		    fputs ("\n\t\t)", FP);
+		  fputs ("\n\t\tHole (", FP);
+		  hole++;
+		  i = 0;
+		}
+
 	      if (i++ % 5 == 0)
-		fputs ("\n\t\t", FP);
+		{
+		  fputs ("\n\t\t", FP);
+		  if (hole)
+		    fputs ("\t", FP);
+		}
 	      fprintf (FP, "[%i %i] ", (int) point->X, (int) point->Y);
 	    }
+	  if (hole > 0)
+	    fputs ("\n\t\t)", FP);
 	  fputs ("\n\t)\n", FP);
 	}
       fputs (")\n", FP);
diff --git a/src/file.h b/src/file.h
index 5791dda..e124c4d 100644
--- a/src/file.h
+++ b/src/file.h
@@ -56,7 +56,7 @@ void sort_netlist (void);
  * guidance to the user as to what the minimum version of pcb required
  * is.
  */
-#define PCB_FILE_VERSION 20070407
+#define PCB_FILE_VERSION 20100603
 
 
 #ifndef HAS_ATEXIT
diff --git a/src/global.h b/src/global.h
index 62be07f..cf983eb 100644
--- a/src/global.h
+++ b/src/global.h
@@ -260,6 +260,10 @@ struct polygon_st			/* holds information about a polygon */
   PLINE *NoHoles;		/* the polygon broken into hole-less regions */
   int NoHolesValid;		/* Is the NoHoles polygon up to date? */
   PointTypePtr Points;		/* data */
+  Cardinal *HoleIndex;		/* Index of hole data within the Points array */
+  Cardinal HoleIndexN;		/* number of holes in polygon */
+  Cardinal HoleIndexMax;	/* max number from malloc() */
+
 };
 
 typedef struct			/* holds information about arcs */
diff --git a/src/insert.c b/src/insert.c
index b4bcfe7..094e567 100644
--- a/src/insert.c
+++ b/src/insert.c
@@ -174,10 +174,7 @@ InsertPointIntoPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
        * first make sure adding the point is sensible
        */
       line.Thickness = 0;
-      if (InsertAt == 0)
-	line.Point1 = Polygon->Points[Polygon->PointN - 1];
-      else
-	line.Point1 = Polygon->Points[InsertAt - 1];
+      line.Point1 = Polygon->Points[prev_contour_point (Polygon, InsertAt)];
       line.Point2 = Polygon->Points[InsertAt];
       if (IsPointOnLine ((float) InsertX, (float) InsertY, 0.0, &line))
 	return (NULL);
@@ -190,10 +187,17 @@ InsertPointIntoPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
   save = *CreateNewPointInPolygon (Polygon, InsertX, InsertY);
   for (n = Polygon->PointN - 1; n > InsertAt; n--)
     Polygon->Points[n] = Polygon->Points[n - 1];
+
+  /* Shift up indices of any holes */
+  for (n = 0; n < Polygon->HoleIndexN; n++)
+    if (Polygon->HoleIndex[n] > InsertAt)
+      Polygon->HoleIndex[n]++;
+
   Polygon->Points[InsertAt] = save;
   SetChangedFlag (true);
   AddObjectToInsertPointUndoList (POLYGONPOINT_TYPE, Layer, Polygon,
 				  &Polygon->Points[InsertAt]);
+
   SetPolygonBoundingBox (Polygon);
   r_insert_entry (Layer->polygon_tree, (BoxType *) Polygon, 0);
   InitClip (PCB->Data, Layer, Polygon);
diff --git a/src/mymem.c b/src/mymem.c
index 46714bb..bed0f9b 100644
--- a/src/mymem.c
+++ b/src/mymem.c
@@ -459,6 +459,28 @@ GetPointMemoryInPolygon (PolygonTypePtr Polygon)
 }
 
 /* ---------------------------------------------------------------------------
+ * gets the next slot for a point in a polygon struct, allocates memory
+ * if necessary
+ */
+Cardinal *
+GetHoleIndexMemoryInPolygon (PolygonTypePtr Polygon)
+{
+  Cardinal *holeindex = Polygon->HoleIndex;
+
+  /* realloc new memory if necessary and clear it */
+  if (Polygon->HoleIndexN >= Polygon->HoleIndexMax)
+    {
+      Polygon->HoleIndexMax += STEP_POLYGONHOLEINDEX;
+      holeindex = MyRealloc (holeindex, Polygon->HoleIndexMax * sizeof (int),
+			     "GetHoleIndexMemoryInPolygon()");
+      Polygon->HoleIndex = holeindex;
+      memset (holeindex + Polygon->HoleIndexN, 0,
+	      STEP_POLYGONHOLEINDEX * sizeof (int));
+    }
+  return (holeindex + Polygon->HoleIndexN++);
+}
+
+/* ---------------------------------------------------------------------------
  * get next slot for an element, allocates memory if necessary
  */
 ElementTypePtr
@@ -734,6 +756,7 @@ FreePolygonMemory (PolygonTypePtr Polygon)
   if (Polygon)
     {
       MYFREE (Polygon->Points);
+      MYFREE (Polygon->HoleIndex);
       if (Polygon->Clipped)
 	poly_Free (&Polygon->Clipped);
       poly_FreeContours (&Polygon->NoHoles);
diff --git a/src/mymem.h b/src/mymem.h
index b9d4de1..81dff7a 100644
--- a/src/mymem.h
+++ b/src/mymem.h
@@ -58,6 +58,7 @@
 #define	STEP_UNDOLIST		500
 #define	STEP_POLYGON		10
 #define	STEP_POLYGONPOINT	10
+#define	STEP_POLYGONHOLEINDEX	10
 #define	STEP_LIBRARYMENU	10
 #define	STEP_LIBRARYENTRY	20
 #define	STEP_RUBBERBAND		100
@@ -82,6 +83,7 @@ RatTypePtr GetRatMemory (DataTypePtr);
 TextTypePtr GetTextMemory (LayerTypePtr);
 PolygonTypePtr GetPolygonMemory (LayerTypePtr);
 PointTypePtr GetPointMemoryInPolygon (PolygonTypePtr);
+Cardinal *GetHoleIndexMemoryInPolygon (PolygonTypePtr);
 ElementTypePtr GetElementMemory (DataTypePtr);
 BoxTypePtr GetBoxMemory (BoxListTypePtr);
 ConnectionTypePtr GetConnectionMemory (NetTypePtr);
diff --git a/src/parse_l.l b/src/parse_l.l
index 0f3b72e..8aa754c 100644
--- a/src/parse_l.l
+++ b/src/parse_l.l
@@ -129,6 +129,7 @@ Mark		{ return(T_MARK); }
 Groups		{ return(T_GROUPS); }
 Styles		{ return(T_STYLES); }
 Polygon		{ return(T_POLYGON); }
+Hole		{ return(T_POLYGON_HOLE); }
 Arc		{ return(T_ARC); }
 NetList		{ return(T_NETLIST); }
 Net		{ return(T_NET); }
diff --git a/src/parse_y.y b/src/parse_y.y
index 1d64fe8..cc31358 100644
--- a/src/parse_y.y
+++ b/src/parse_y.y
@@ -65,6 +65,7 @@ RCSID("$Id$");
 
 static	LayerTypePtr	Layer;
 static	PolygonTypePtr	Polygon;
+static	PolygonTypePtr	Hole;
 static	SymbolTypePtr	Symbol;
 static	int		pin_num;
 static	LibraryMenuTypePtr	Menu;
@@ -102,9 +103,8 @@ static int check_file_version (int);
 
 %token	T_FILEVERSION T_PCB T_LAYER T_VIA T_RAT T_LINE T_ARC T_RECTANGLE T_TEXT T_ELEMENTLINE
 %token	T_ELEMENT T_PIN T_PAD T_GRID T_FLAGS T_SYMBOL T_SYMBOLLINE T_CURSOR
-%token	T_ELEMENTARC T_MARK T_GROUPS T_STYLES T_POLYGON T_NETLIST T_NET T_CONN
+%token	T_ELEMENTARC T_MARK T_GROUPS T_STYLES T_POLYGON T_POLYGON_HOLE T_NETLIST T_NET T_CONN
 %token	T_AREA T_THERMAL T_DRC T_ATTRIBUTE
-
 %type	<number>	symbolid
 %type	<string>	opt_string
 %type	<flagtype>	flags
@@ -895,31 +895,7 @@ layerdefinition
 		| text_newformat
 		| text_oldformat
 		| { attr_list = & Layer->Attributes; } attributes
-			/* flags are passed in */
-		| T_POLYGON '(' flags ')' '('
-			{
-				Polygon = CreateNewPolygon(Layer, $3);
-			}
-		  polygonpoints ')'
-		  	{
-					/* ignore junk */
-				if (Polygon->PointN >= 3)
-				  {
-				    SetPolygonBoundingBox (Polygon);
-				    if (!Layer->polygon_tree)
-				      Layer->polygon_tree = r_create_tree (NULL, 0, 0);
-				    r_insert_entry (Layer->polygon_tree, (BoxType *) Polygon, 0);
-				  }
-				else
-				{
-					Message("WARNING parsing file '%s'\n"
-						"    line:        %i\n"
-						"    description: 'ignored polygon (< 3 points)'\n",
-						yyfilename, yylineno);
-					DestroyObject(yyData, POLYGON_TYPE, Layer, Polygon, Polygon);
-				}
-			}
-		;
+		| polygon_format
 
 /* %start-doc pcbfile Line
 
@@ -1124,6 +1100,11 @@ text_hi_format
 Polygon (SFlags) (
 @ @ @ @dots{} (X Y) @dots{}
 @ @ @ @dots{} [X Y] @dots{}
+@ @ @ Hole (
+@ @ @ @ @ @ @dots{} (X Y) @dots{}
+@ @ @ @ @ @ @dots{} [X Y] @dots{}
+@ @ @ )
+@ @ @ @dots{}
 )
 @end syntax
 
@@ -1132,10 +1113,54 @@ Polygon (SFlags) (
 Symbolic or numeric flags.
 @item X Y
 Coordinates of each vertex.  You must list at least three coordinates.
+@item Hole (...)
+Defines a hole within the polygon's outer contour. There may be zero or more such sections.
 @end table
 
 %end-doc */
 
+polygon_format
+		: /* flags are passed in */
+		T_POLYGON '(' flags ')' '('
+			{
+				Polygon = CreateNewPolygon(Layer, $3);
+			}
+		  polygonpoints
+		  polygonholes ')'
+			{
+					/* ignore junk */
+				if (Polygon->PointN >= 3)
+				  {
+				    SetPolygonBoundingBox (Polygon);
+				    if (!Layer->polygon_tree)
+				      Layer->polygon_tree = r_create_tree (NULL, 0, 0);
+				    r_insert_entry (Layer->polygon_tree, (BoxType *) Polygon, 0);
+				  }
+				else
+				{
+					Message("WARNING parsing file '%s'\n"
+						"    line:        %i\n"
+						"    description: 'ignored polygon (< 3 points)'\n",
+						yyfilename, yylineno);
+					DestroyObject(yyData, POLYGON_TYPE, Layer, Polygon, Polygon);
+				}
+			}
+		;
+
+polygonholes
+		: /* empty */
+		| polygonhole
+		| polygonholes polygonhole
+		;
+
+polygonhole
+		: T_POLYGON_HOLE '('
+			{
+				Hole = CreateNewHoleInPolygon (Polygon);
+			}
+		  polygonpoints ')'
+		;
+
 polygonpoints
 		: polygonpoint
 		| polygonpoints polygonpoint
diff --git a/src/polygon.c b/src/polygon.c
index 234d1d8..0b34842 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -124,6 +124,74 @@ static double circleVerticies[] = {
   0.98768834059513777, 0.15643446504023087,
 };
 
+Cardinal
+polygon_point_idx (PolygonTypePtr polygon, PointTypePtr point)
+{
+  assert (point >= polygon->Points);
+  assert (point <= polygon->Points + polygon->PointN);
+  return ((char *)point - (char *)polygon->Points) / sizeof (PointType);
+}
+
+Cardinal
+next_contour_point (PolygonTypePtr polygon, Cardinal point)
+{
+  int hole; /* Must be a signed type */
+  Cardinal this_contour_start;
+  Cardinal next_contour_start;
+
+  /* Find which contour / hole the specified point is in */
+  for (hole = polygon->HoleIndexN - 1; hole >= 0; hole--)
+    if (point >= polygon->HoleIndex[hole])
+      break;
+  hole++;
+
+  /* hole = 0 for an outer contour point */
+  /* hole = 1 for the first contour etc. */
+
+  this_contour_start = (hole == 0) ? 0 :
+                                     polygon->HoleIndex[hole - 1];
+  next_contour_start =
+    (hole == polygon->HoleIndexN) ? polygon->PointN :
+                                    polygon->HoleIndex[hole];
+
+  /* Wrap back to the start of the contour we're in if we pass the end */
+  if (++point == next_contour_start)
+    point = this_contour_start;
+
+  return point;
+}
+
+Cardinal
+prev_contour_point (PolygonTypePtr polygon, Cardinal point)
+{
+  int hole; /* Must be a signed type */
+  Cardinal prev_contour_end;
+  Cardinal this_contour_end;
+
+  /* Find which contour / hole the specified point is in */
+  for (hole = polygon->HoleIndexN - 1; hole >= 0; hole--)
+    if (point >= polygon->HoleIndex[hole])
+      break;
+  hole++;
+
+  /* hole = 0 for an outer contour point */
+  /* hole = 1 for the first contour etc. */
+
+  prev_contour_end = (hole == 0) ? 0 :
+                                   polygon->HoleIndex[hole - 1];
+  this_contour_end =
+    (hole == polygon->HoleIndexN) ? polygon->PointN - 1:
+                                    polygon->HoleIndex[hole] - 1;
+
+  /* Wrap back to the start of the contour we're in if we pass the end */
+  if (point == prev_contour_end)
+    point = this_contour_end;
+  else
+    point--;
+
+  return point;
+}
+
 static void
 add_noholes_polyarea (PLINE *pline, void *user_data)
 {
@@ -213,33 +281,49 @@ original_poly (PolygonType * p)
 {
   PLINE *contour = NULL;
   POLYAREA *np = NULL;
+  Cardinal n;
   Vector v;
+  int hole = 0;
 
-  /* first make initial polygon contour */
-  POLYGONPOINT_LOOP (p);
-  {
-    v[0] = point->X;
-    v[1] = point->Y;
-    if (contour == NULL)
-      {
-        if ((contour = poly_NewContour (v)) == NULL)
-          return NULL;
-      }
-    else
-      {
-        poly_InclVertex (contour->head.prev, poly_CreateNode (v));
-      }
-  }
-  END_LOOP;
-  poly_PreContour (contour, TRUE);
-  /* make sure it is a positive contour */
-  if ((contour->Flags.orient) != PLF_DIR)
-    poly_InvContour (contour);
-  assert ((contour->Flags.orient) == PLF_DIR);
   if ((np = poly_Create ()) == NULL)
     return NULL;
-  poly_InclContour (np, contour);
-  assert (poly_Valid (np));
+
+  /* first make initial polygon contour */
+  for (n = 0; n < p->PointN; n++)
+    {
+      /* No current contour? Make a new one starting at point */
+      /*   (or) Add point to existing contour */
+
+      v[0] = p->Points[n].X;
+      v[1] = p->Points[n].Y;
+      if (contour == NULL)
+        {
+          if ((contour = poly_NewContour (v)) == NULL)
+            return NULL;
+        }
+      else
+        {
+          poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+        }
+
+      /* Is current point last in contour? If so process it. */
+      if (n == p->PointN - 1 ||
+          (hole < p->HoleIndexN && n == p->HoleIndex[hole] - 1))
+        {
+          poly_PreContour (contour, TRUE);
+
+          /* make sure it is a positive contour (outer) or negative (hole) */
+          if (contour->Flags.orient != (hole ? PLF_INV : PLF_DIR))
+            poly_InvContour (contour);
+          assert (contour->Flags.orient == (hole ? PLF_INV : PLF_DIR));
+
+          poly_InclContour (np, contour);
+          contour = NULL;
+          assert (poly_Valid (np));
+
+          hole++;
+        }
+  }
   return biggest (np);
 }
 
@@ -1145,6 +1229,7 @@ RemoveExcessPolygonPoints (LayerTypePtr Layer, PolygonTypePtr Polygon)
   LineType line;
   bool changed = false;
 
+#warning NEED TO TAKE HOLES INTO ACCOUNT
   if (Undoing ())
     return (false);
   /* there are always at least three points in a polygon */
@@ -1181,8 +1266,7 @@ GetLowestDistancePolygonPoint (PolygonTypePtr Polygon, LocationType X,
                                LocationType Y)
 {
   double mindistance = (double) MAX_COORD * MAX_COORD;
-  PointTypePtr ptr1 = &Polygon->Points[Polygon->PointN - 1],
-    ptr2 = &Polygon->Points[0];
+  PointTypePtr ptr1, ptr2;
   Cardinal n, result = 0;
 
   /* we calculate the distance to each segment and choose the
@@ -1192,9 +1276,12 @@ GetLowestDistancePolygonPoint (PolygonTypePtr Polygon, LocationType X,
    * to the segment end point.
    */
 
-  for (n = 0; n < Polygon->PointN; n++, ptr2++)
+  for (n = 0; n < Polygon->PointN; n++)
     {
       register double u, dx, dy;
+      ptr1 = &Polygon->Points[prev_contour_point (Polygon, n)];
+      ptr2 = &Polygon->Points[n];
+
       dx = ptr2->X - ptr1->X;
       dy = ptr2->Y - ptr1->Y;
       if (dx != 0.0 || dy != 0.0)
@@ -1221,7 +1308,6 @@ GetLowestDistancePolygonPoint (PolygonTypePtr Polygon, LocationType X,
               result = n;
             }
         }
-      ptr1 = ptr2;
     }
   return (result);
 }
@@ -1248,6 +1334,7 @@ GoToPreviousPoint (void)
       /* back-up one point */
     default:
       {
+#warning Any implication for holes?
         PointTypePtr points = Crosshair.AttachedPolygon.Points;
         Cardinal n = Crosshair.AttachedPolygon.PointN - 2;
 
@@ -1267,6 +1354,7 @@ ClosePolygon (void)
 {
   Cardinal n = Crosshair.AttachedPolygon.PointN;
 
+#warning Any implication for holes?
   /* check number of points */
   if (n >= 3)
     {
@@ -1795,6 +1883,7 @@ debug_polygon (PolygonType *p)
 {
   int i;
   POLYAREA *pa;
+#warning Augment to display hole contours properly
   fprintf (stderr, "POLYGON %p  %d pts\n", p, p->PointN);
   for (i=0; i<p->PointN; i++)
     fprintf(stderr, "\t%d: %d, %d\n", i, p->Points[i].X, p->Points[i].Y);
diff --git a/src/polygon.h b/src/polygon.h
index 5fc0cd5..38777b1 100644
--- a/src/polygon.h
+++ b/src/polygon.h
@@ -33,6 +33,9 @@
 
 #include "global.h"
 
+Cardinal polygon_point_idx (PolygonTypePtr polygon, PointTypePtr point);
+Cardinal prev_contour_point (PolygonTypePtr polygon, Cardinal point);
+Cardinal next_contour_point (PolygonTypePtr polygon, Cardinal point);
 Cardinal GetLowestDistancePolygonPoint (PolygonTypePtr,
 					LocationType, LocationType);
 bool RemoveExcessPolygonPoints (LayerTypePtr, PolygonTypePtr);
diff --git a/src/remove.c b/src/remove.c
index a537bc0..1964dfb 100644
--- a/src/remove.c
+++ b/src/remove.c
@@ -205,6 +205,7 @@ DestroyPolygonPoint (LayerTypePtr Layer,
 {
   PointTypePtr ptr;
 
+#warning Need to shift hole indices down
   if (Polygon->PointN <= 3)
     return RemovePolygon (Layer, Polygon);
   r_delete_entry (Layer->polygon_tree, (BoxType *) Polygon);
@@ -489,20 +490,13 @@ RemovePolygonPoint (LayerTypePtr Layer,
 {
   PointTypePtr ptr;
   Cardinal index = 0;
+#warning Need to shift hole indices down
   if (Polygon->PointN <= 3)
     return RemovePolygon (Layer, Polygon);
   if (Layer->On)
     ErasePolygon (Polygon);
   /* insert the polygon-point into the undo list */
-  POLYGONPOINT_LOOP (Polygon);
-  {
-    if (point == Point)
-      {
-	index = n;
-	break;
-      }
-  }
-  END_LOOP;
+  index = polygon_point_idx (Polygon, Point);
   AddObjectToRemovePointUndoList (POLYGONPOINT_TYPE, Layer, Polygon, index);
   r_delete_entry (Layer->polygon_tree, (BoxType *) Polygon);
   /* remove point from list, keep point order */
diff --git a/src/report.c b/src/report.c
index 6a1c47b..bf43f21 100644
--- a/src/report.c
+++ b/src/report.c
@@ -321,6 +321,7 @@ ReportDialog (int argc, char **argv, int x, int y)
 #endif
 	Polygon = (PolygonTypePtr) ptr2;
 
+#warning Report about holes as well?
 	sprintf (&report[0], "POLYGON ID# %ld   Flags:%s\n"
 		 "Its bounding box is (%d,%d) (%d,%d)\n"
 		 "It has %d points and could store %d more\n"
diff --git a/src/undo.c b/src/undo.c
index 50c6de5..1117c7d 100644
--- a/src/undo.c
+++ b/src/undo.c
@@ -778,15 +778,8 @@ UndoInsertPoint (UndoListTypePtr Entry)
 	Entry->ID = polygon->ID;
 	Entry->Kind = POLYGON_TYPE;
 	Entry->Type = UNDO_REMOVE_POINT;
-	POLYGONPOINT_LOOP (polygon);
-	{
-	  if (pnt == point)
-	    {
-	      Entry->Data.RemovedPoint.Index = n;
-	      break;
-	    }
-	}
-	END_LOOP;
+#warning Any implication for holes? Do we need to store which contour the insert was in?
+	Entry->Data.RemovedPoint.Index = polygon_point_idx (polygon, pnt);
 	DestroyObject (PCB->Data, POLYGONPOINT_TYPE, layer, polygon, pnt);
 	if (andDraw && layer->On)
 	  DrawPolygon (layer, polygon, 0);

Bottom: 05a0eb32edc286b12f857deab71e245408f68cb0
Top:    6d304d06ead6d0390d8b24ad865c256ced3ddff9
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-08-24 20:44:30 +0100

Try to make GDK and GL versions coexist a little more!


---

diff --git a/src/Makefile.am b/src/Makefile.am
index f66cca7..bb52a45 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -273,7 +273,6 @@ LIBGTK_SRCS = \
 	hid/gtk/gui-pinout-preview.c \
 	hid/gtk/gui-pinout-preview.h \
 	hid/gtk/gui-pinout-window.c \
-	hid/gtk/gui-render-pixmap.c \
 	hid/gtk/gui-top-window.c \
 	hid/gtk/gui-utils.c
 libgtk_a_SOURCES = ${LIBGTK_SRCS} hid/gtk/gtk_lists.h
diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index 957e2aa..ea2c783 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -21,15 +21,258 @@ RCSID ("$Id$");
 
 extern HID ghid_hid;
 
-/* Sets gport->u_gc to the "right" GC to use (wrt mask or window)
+/* Sets priv->u_gc to the "right" GC to use (wrt mask or window)
 */
 #define USE_GC(gc) if (!use_gc(gc)) return
 
 static int cur_mask = -1;
 static int mask_seq = 0;
 
+struct render_priv {
+  GdkGC *bg_gc;
+  GdkGC *offlimits_gc;
+  GdkGC *mask_gc;
+  GdkGC *u_gc;
+  GdkGC *grid_gc;
+};
+
 /* ------------------------------------------------------------ */
 
+void
+ghid_init_renderer (int *argc, char ***argv, GHidPort *port)
+{
+  /* Init any GC's required */
+  port->render_priv = g_new0 (struct render_priv, 1);
+}
+
+GtkWidget *
+ghid_drawing_area_new (GHidPort *port)
+{
+  return gtk_drawing_area_new ();
+}
+
+gboolean
+ghid_start_drawing (GHidPort *port)
+{
+  return TRUE;
+}
+
+void
+ghid_end_drawing (GHidPort *port)
+{
+}
+
+void
+ghid_drawing_area_configure_hook (GHidPort *port)
+{
+  static int done_once = 0;
+  struct render_priv *priv = port->render_priv;
+
+  if (!done_once)
+    {
+      priv->bg_gc = gdk_gc_new (port->drawable);
+      gdk_gc_set_foreground (priv->bg_gc, &port->bg_color);
+
+      priv->offlimits_gc = gdk_gc_new (port->drawable);
+      gdk_gc_set_foreground (priv->offlimits_gc, &port->offlimits_color);
+      done_once = 1;
+    }
+
+  if (port->mask)
+    {
+      gdk_pixmap_unref (port->mask);
+      port->mask = gdk_pixmap_new (0, port->width, port->height, 1);
+    }
+}
+
+void
+ghid_screen_update (void)
+{
+  struct render_priv *priv = gport->render_priv;
+
+  ghid_show_crosshair (FALSE);
+  gdk_draw_drawable (gport->drawing_area->window, priv->bg_gc, gport->pixmap,
+		     0, 0, 0, 0, gport->width, gport->height);
+  ghid_show_crosshair (TRUE);
+}
+
+gboolean
+ghid_drawing_area_expose_cb (GtkWidget *widget,
+                             GdkEventExpose *ev,
+                             GHidPort *port)
+{
+  struct render_priv *priv = port->render_priv;
+
+  ghid_show_crosshair (FALSE);
+  gdk_draw_drawable (widget->window, priv->bg_gc, port->pixmap,
+                    ev->area.x, ev->area.y, ev->area.x, ev->area.y,
+                    ev->area.width, ev->area.height);
+  ghid_show_crosshair (TRUE);
+  return FALSE;
+}
+
+void
+ghid_pinout_preview_init (GhidPinoutPreview *preview)
+{
+}
+
+gboolean
+ghid_pinout_preview_expose (GtkWidget *widget,
+                            GdkEventExpose *ev)
+{
+  extern HID ghid_hid;
+  GhidPinoutPreview *pinout = GHID_PINOUT_PREVIEW (widget);
+  GdkDrawable *save_drawable;
+  double save_zoom;
+  int da_w, da_h;
+  int save_left, save_top;
+  int save_width, save_height;
+  int save_view_width, save_view_height;
+  double xz, yz;
+  struct render_priv *priv = gport->render_priv;
+
+  save_zoom = gport->zoom;
+  save_width = gport->width;
+  save_height = gport->height;
+  save_left = gport->view_x0;
+  save_top = gport->view_y0;
+  save_view_width = gport->view_width;
+  save_view_height = gport->view_height;
+
+  /* Setup drawable and zoom factor for drawing routines
+   */
+  save_drawable = gport->drawable;
+
+  gdk_window_get_geometry (widget->window, 0, 0, &da_w, &da_h, 0);
+  xz = (double) pinout->x_max / da_w;
+  yz = (double) pinout->y_max / da_h;
+  if (xz > yz)
+    gport->zoom = xz;
+  else
+    gport->zoom = yz;
+
+  gport->drawable = widget->window;
+  gport->width = da_w;
+  gport->height = da_h;
+  gport->view_width = da_w * gport->zoom;
+  gport->view_height = da_h * gport->zoom;
+  gport->view_x0 = (pinout->x_max - gport->view_width) / 2;
+  gport->view_y0 = (pinout->y_max - gport->view_height) / 2;
+
+  /* clear background */
+  gdk_draw_rectangle (widget->window, priv->bg_gc, TRUE, 0, 0, da_w, da_h);
+
+  /* call the drawing routine */
+  hid_expose_callback (&ghid_hid, NULL, &pinout->element);
+
+  gport->drawable = save_drawable;
+  gport->zoom = save_zoom;
+  gport->width = save_width;
+  gport->height = save_height;
+  gport->view_x0 = save_left;
+  gport->view_y0 = save_top;
+  save_top = gport->view_y0;
+  save_view_width = gport->view_width;
+  save_view_height = gport->view_height;
+
+  /* Setup drawable and zoom factor for drawing routines
+   */
+  save_drawable = gport->drawable;
+
+  gdk_window_get_geometry (widget->window, 0, 0, &da_w, &da_h, 0);
+  xz = (double) pinout->x_max / da_w;
+  yz = (double) pinout->y_max / da_h;
+  if (xz > yz)
+    gport->zoom = xz;
+  else
+    gport->zoom = yz;
+
+  gport->drawable = widget->window;
+  gport->width = da_w;
+  gport->height = da_h;
+  gport->view_width = da_w * gport->zoom;
+  gport->view_height = da_h * gport->zoom;
+  gport->view_x0 = (pinout->x_max - gport->view_width) / 2;
+  gport->view_y0 = (pinout->y_max - gport->view_height) / 2;
+
+  /* clear background */
+  gdk_draw_rectangle (widget->window, priv->bg_gc, TRUE, 0, 0, da_w, da_h);
+
+  /* call the drawing routine */
+  hid_expose_callback (&ghid_hid, NULL, &pinout->element);
+
+  gport->drawable = save_drawable;
+  gport->zoom = save_zoom;
+  gport->width = save_width;
+  gport->height = save_height;
+  gport->view_x0 = save_left;
+  gport->view_y0 = save_top;
+  gport->view_width = save_view_width;
+  gport->view_height = save_view_height;
+
+  return FALSE;
+}
+
+GdkPixmap *
+ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int depth)
+{
+  extern HID ghid_hid;
+  GdkPixmap *pixmap;
+  GdkDrawable *save_drawable;
+  double save_zoom;
+  int save_left, save_top;
+  int save_width, save_height;
+  int save_view_width, save_view_height;
+  BoxType region;
+  struct render_priv *priv = gport->render_priv;
+
+  save_drawable = gport->drawable;
+  save_zoom = gport->zoom;
+  save_width = gport->width;
+  save_height = gport->height;
+  save_left = gport->view_x0;
+  save_top = gport->view_y0;
+  save_view_width = gport->view_width;
+  save_view_height = gport->view_height;
+
+  pixmap = gdk_pixmap_new (NULL, width, height, depth);
+
+  /* Setup drawable and zoom factor for drawing routines
+   */
+
+  gport->drawable = pixmap;
+  gport->zoom = zoom;
+  gport->width = width;
+  gport->height = height;
+  gport->view_width = width * gport->zoom;
+  gport->view_height = height * gport->zoom;
+  gport->view_x0 = ghid_flip_x ? PCB->MaxWidth - cx : cx;
+  gport->view_x0 -= gport->view_height / 2;
+  gport->view_y0 = ghid_flip_y ? PCB->MaxHeight - cy : cy;
+  gport->view_y0 -= gport->view_width  / 2;
+
+  /* clear background */
+  gdk_draw_rectangle (pixmap, priv->bg_gc, TRUE, 0, 0, width, height);
+
+  /* call the drawing routine */
+  region.X1 = MIN(Px(0), Px(gport->width + 1));
+  region.Y1 = MIN(Py(0), Py(gport->height + 1));
+  region.X2 = MAX(Px(0), Px(gport->width + 1));
+  region.Y2 = MAX(Py(0), Py(gport->height + 1));
+  hid_expose_callback (&ghid_hid, &region, NULL);
+
+  gport->drawable = save_drawable;
+  gport->zoom = save_zoom;
+  gport->width = save_width;
+  gport->height = save_height;
+  gport->view_x0 = save_left;
+  gport->view_y0 = save_top;
+  gport->view_width = save_view_width;
+  gport->view_height = save_view_height;
+
+  return pixmap;
+}
+
 static inline int
 Vx2 (int x)
 {
@@ -85,12 +328,13 @@ ghid_draw_grid (void)
   static int npoints = 0;
   int x1, y1, x2, y2, n, i;
   double x, y;
+  struct render_priv *priv = gport->render_priv;
 
   if (!Settings.DrawGrid)
     return;
   if (Vz (PCB->Grid) < MIN_GRID_DISTANCE)
     return;
-  if (!gport->grid_gc)
+  if (!priv->grid_gc)
     {
       if (gdk_color_parse (Settings.GridColor, &gport->grid_color))
 	{
@@ -99,9 +343,9 @@ ghid_draw_grid (void)
 	  gport->grid_color.blue ^= gport->bg_color.blue;
 	  gdk_color_alloc (gport->colormap, &gport->grid_color);
 	}
-      gport->grid_gc = gdk_gc_new (gport->drawable);
-      gdk_gc_set_function (gport->grid_gc, GDK_XOR);
-      gdk_gc_set_foreground (gport->grid_gc, &gport->grid_color);
+      priv->grid_gc = gdk_gc_new (gport->drawable);
+      gdk_gc_set_function (priv->grid_gc, GDK_XOR);
+      gdk_gc_set_foreground (priv->grid_gc, &gport->grid_color);
     }
   x1 = GRIDFIT_X (SIDE_X (gport->view_x0), PCB->Grid);
   y1 = GRIDFIT_Y (SIDE_Y (gport->view_y0), PCB->Grid);
@@ -148,7 +392,7 @@ ghid_draw_grid (void)
       int vy = Vy (y);
       for (i = 0; i < n; i++)
 	points[i].y = vy;
-      gdk_draw_points (gport->drawable, gport->grid_gc, points, n);
+      gdk_draw_points (gport->drawable, priv->grid_gc, points, n);
     }
 }
 
@@ -160,6 +404,7 @@ ghid_draw_bg_image (void)
   GdkInterpType interp_type;
   gint x, y, w, h, w_src, h_src;
   static gint w_scaled, h_scaled;
+  struct render_priv *priv = gport->render_priv;
 
   if (!ghidgui->bg_pixbuf)
     return;
@@ -187,12 +432,12 @@ ghid_draw_bg_image (void)
       h_scaled = h;
     }
   if (pixbuf)
-    gdk_pixbuf_render_to_drawable (pixbuf, gport->drawable, gport->bg_gc,
+    gdk_pixbuf_render_to_drawable (pixbuf, gport->drawable, priv->bg_gc,
 				   x, y, 0, 0,
 				   w - x, h - y, GDK_RGB_DITHER_NORMAL, 0, 0);
 }
 
-#define WHICH_GC(gc) (cur_mask == HID_MASK_CLEAR ? gport->mask_gc : (gc)->gc)
+#define WHICH_GC(gc) (cur_mask == HID_MASK_CLEAR ? priv->mask_gc : (gc)->gc)
 
 void
 ghid_use_mask (int use_it)
@@ -200,6 +445,7 @@ ghid_use_mask (int use_it)
   static int mask_seq_id = 0;
   static GdkDrawable *old;
   GdkColor color;
+  struct render_priv *priv = gport->render_priv;
 
   if (use_it == HID_FLUSH_DRAW_Q)
     {
@@ -238,16 +484,16 @@ ghid_use_mask (int use_it)
 	gport->mask = gdk_pixmap_new (0, gport->width, gport->height, 1);
       gport->drawable = gport->mask;
       mask_seq = 0;
-      if (!gport->mask_gc)
+      if (!priv->mask_gc)
 	{
-	  gport->mask_gc = gdk_gc_new (gport->drawable);
+	  priv->mask_gc = gdk_gc_new (gport->drawable);
 	}
       color.pixel = 1;
-      gdk_gc_set_foreground (gport->mask_gc, &color);
-      gdk_draw_rectangle (gport->drawable, gport->mask_gc, TRUE, 0, 0,
+      gdk_gc_set_foreground (priv->mask_gc, &color);
+      gdk_draw_rectangle (gport->drawable, priv->mask_gc, TRUE, 0, 0,
 			  gport->width, gport->height);
       color.pixel = 0;
-      gdk_gc_set_foreground (gport->mask_gc, &color);
+      gdk_gc_set_foreground (priv->mask_gc, &color);
       break;
 
     case HID_MASK_AFTER:
@@ -279,33 +525,37 @@ typedef struct
 static void
 set_special_grid_color (void)
 {
+  struct render_priv *priv = gport->render_priv;
+
   if (!gport->colormap)
     return;
   gport->grid_color.red ^= gport->bg_color.red;
   gport->grid_color.green ^= gport->bg_color.green;
   gport->grid_color.blue ^= gport->bg_color.blue;
   gdk_color_alloc (gport->colormap, &gport->grid_color);
-  if (gport->grid_gc)
-    gdk_gc_set_foreground (gport->grid_gc, &gport->grid_color);
+  if (priv->grid_gc)
+    gdk_gc_set_foreground (priv->grid_gc, &gport->grid_color);
 }
 
 void
 ghid_set_special_colors (HID_Attribute * ha)
 {
+  struct render_priv *priv = gport->render_priv;
+
   if (!ha->name || !ha->value)
     return;
-  if (!strcmp (ha->name, "background-color") && gport->bg_gc)
+  if (!strcmp (ha->name, "background-color") && priv->bg_gc)
     {
       ghid_map_color_string (*(char **) ha->value, &gport->bg_color);
-      gdk_gc_set_foreground (gport->bg_gc, &gport->bg_color);
+      gdk_gc_set_foreground (priv->bg_gc, &gport->bg_color);
       set_special_grid_color ();
     }
-  else if (!strcmp (ha->name, "off-limit-color") && gport->offlimits_gc)
+  else if (!strcmp (ha->name, "off-limit-color") && priv->offlimits_gc)
     {
       ghid_map_color_string (*(char **) ha->value, &gport->offlimits_color);
-      gdk_gc_set_foreground (gport->offlimits_gc, &gport->offlimits_color);
+      gdk_gc_set_foreground (priv->offlimits_gc, &gport->offlimits_color);
     }
-  else if (!strcmp (ha->name, "grid-color") && gport->grid_gc)
+  else if (!strcmp (ha->name, "grid-color") && priv->grid_gc)
     {
       ghid_map_color_string (*(char **) ha->value, &gport->grid_color);
       set_special_grid_color ();
@@ -386,6 +636,7 @@ ghid_set_color (hidGC gc, const char *name)
 void
 ghid_set_line_cap (hidGC gc, EndCapStyle style)
 {
+  struct render_priv *priv = gport->render_priv;
 
   switch (style)
     {
@@ -409,6 +660,7 @@ ghid_set_line_cap (hidGC gc, EndCapStyle style)
 void
 ghid_set_line_width (hidGC gc, int width)
 {
+  struct render_priv *priv = gport->render_priv;
 
   gc->width = width;
   if (gc->gc)
@@ -442,6 +694,7 @@ ghid_set_line_cap_angle (hidGC gc, int x1, int y1, int x2, int y2)
 static int
 use_gc (hidGC gc)
 {
+  struct render_priv *priv = gport->render_priv;
 
   if (gc->me_pointer != &ghid_hid)
     {
@@ -467,7 +720,7 @@ use_gc (hidGC gc)
 	gdk_gc_set_clip_mask (gc->gc, NULL);
       gc->mask_seq = mask_seq;
     }
-  gport->u_gc = WHICH_GC (gc);
+  priv->u_gc = WHICH_GC (gc);
   return 1;
 }
 
@@ -475,6 +728,7 @@ void
 ghid_draw_line (hidGC gc, int x1, int y1, int x2, int y2)
 {
   double dx1, dy1, dx2, dy2;
+  struct render_priv *priv = gport->render_priv;
 
   dx1 = Vx ((double) x1);
   dy1 = Vy ((double) y1);
@@ -486,7 +740,7 @@ ghid_draw_line (hidGC gc, int x1, int y1, int x2, int y2)
     return;
 
   USE_GC (gc);
-  gdk_draw_line (gport->drawable, gport->u_gc, dx1, dy1, dx2, dy2);
+  gdk_draw_line (gport->drawable, priv->u_gc, dx1, dy1, dx2, dy2);
 }
 
 void
@@ -495,6 +749,7 @@ ghid_draw_arc (hidGC gc, int cx, int cy,
 {
   gint vrx, vry;
   gint w, h, radius;
+  struct render_priv *priv = gport->render_priv;
 
   w = gport->width * gport->zoom;
   h = gport->height * gport->zoom;
@@ -522,7 +777,7 @@ ghid_draw_arc (hidGC gc, int cx, int cy,
   /* make sure we fall in the -180 to +180 range */
   start_angle = (start_angle + 360 + 180) % 360 - 180;
 
-  gdk_draw_arc (gport->drawable, gport->u_gc, 0,
+  gdk_draw_arc (gport->drawable, priv->u_gc, 0,
 		Vx (cx) - vrx, Vy (cy) - vry,
 		vrx * 2, vry * 2, (start_angle + 180) * 64, delta_angle * 64);
 }
@@ -531,6 +786,7 @@ void
 ghid_draw_rect (hidGC gc, int x1, int y1, int x2, int y2)
 {
   gint w, h, lw;
+  struct render_priv *priv = gport->render_priv;
 
   lw = gc->width;
   w = gport->width * gport->zoom;
@@ -565,7 +821,7 @@ ghid_draw_rect (hidGC gc, int x1, int y1, int x2, int y2)
     }
 
   USE_GC (gc);
-  gdk_draw_rectangle (gport->drawable, gport->u_gc, FALSE,
+  gdk_draw_rectangle (gport->drawable, priv->u_gc, FALSE,
 		      x1, y1, x2 - x1 + 1, y2 - y1 + 1);
 }
 
@@ -574,6 +830,7 @@ void
 ghid_fill_circle (hidGC gc, int cx, int cy, int radius)
 {
   gint w, h, vr;
+  struct render_priv *priv = gport->render_priv;
 
   w = gport->width * gport->zoom;
   h = gport->height * gport->zoom;
@@ -585,7 +842,7 @@ ghid_fill_circle (hidGC gc, int cx, int cy, int radius)
 
   USE_GC (gc);
   vr = Vz (radius);
-  gdk_draw_arc (gport->drawable, gport->u_gc, TRUE,
+  gdk_draw_arc (gport->drawable, priv->u_gc, TRUE,
 		Vx (cx) - vr, Vy (cy) - vr, vr * 2, vr * 2, 0, 360 * 64);
 }
 
@@ -595,6 +852,7 @@ ghid_fill_polygon (hidGC gc, int n_coords, int *x, int *y)
   static GdkPoint *points = 0;
   static int npoints = 0;
   int i;
+  struct render_priv *priv = gport->render_priv;
   USE_GC (gc);
 
   if (npoints < n_coords)
@@ -608,13 +866,14 @@ ghid_fill_polygon (hidGC gc, int n_coords, int *x, int *y)
       points[i].x = Vx (x[i]);
       points[i].y = Vy (y[i]);
     }
-  gdk_draw_polygon (gport->drawable, gport->u_gc, 1, points, n_coords);
+  gdk_draw_polygon (gport->drawable, priv->u_gc, 1, points, n_coords);
 }
 
 void
 ghid_fill_rect (hidGC gc, int x1, int y1, int x2, int y2)
 {
   gint w, h, lw, xx, yy;
+  struct render_priv *priv = gport->render_priv;
 
   lw = gc->width;
   w = gport->width * gport->zoom;
@@ -647,7 +906,7 @@ ghid_fill_rect (hidGC gc, int x1, int y1, int x2, int y2)
       y2 = yy;
     }
   USE_GC (gc);
-  gdk_draw_rectangle (gport->drawable, gport->u_gc, TRUE,
+  gdk_draw_rectangle (gport->drawable, priv->u_gc, TRUE,
 		      x1, y1, x2 - x1 + 1, y2 - y1 + 1);
 }
 
@@ -662,6 +921,7 @@ ghid_invalidate_all ()
 {
   int eleft, eright, etop, ebottom;
   BoxType region;
+  struct render_priv *priv = gport->render_priv;
 
   if (!gport->pixmap)
     return;
@@ -689,28 +949,28 @@ ghid_invalidate_all ()
     }
 
   if (eleft > 0)
-    gdk_draw_rectangle (gport->drawable, gport->offlimits_gc,
+    gdk_draw_rectangle (gport->drawable, priv->offlimits_gc,
 			1, 0, 0, eleft, gport->height);
   else
     eleft = 0;
   if (eright < gport->width)
-    gdk_draw_rectangle (gport->drawable, gport->offlimits_gc,
+    gdk_draw_rectangle (gport->drawable, priv->offlimits_gc,
 			1, eright, 0, gport->width - eright, gport->height);
   else
     eright = gport->width;
   if (etop > 0)
-    gdk_draw_rectangle (gport->drawable, gport->offlimits_gc,
+    gdk_draw_rectangle (gport->drawable, priv->offlimits_gc,
 			1, eleft, 0, eright - eleft + 1, etop);
   else
     etop = 0;
   if (ebottom < gport->height)
-    gdk_draw_rectangle (gport->drawable, gport->offlimits_gc,
+    gdk_draw_rectangle (gport->drawable, priv->offlimits_gc,
 			1, eleft, ebottom, eright - eleft + 1,
 			gport->height - ebottom);
   else
     ebottom = gport->height;
 
-  gdk_draw_rectangle (gport->drawable, gport->bg_gc, 1,
+  gdk_draw_rectangle (gport->drawable, priv->bg_gc, 1,
 		      eleft, etop, eright - eleft + 1, ebottom - etop + 1);
 
   ghid_draw_bg_image();
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index df90d8c..14030a9 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -10,6 +10,7 @@
 #include "clip.h"
 #include "../hidint.h"
 #include "gui.h"
+#include "gui-pinout-preview.h"
 
 #ifdef HAVE_LIBDMALLOC
 #include <dmalloc.h>
@@ -31,6 +32,417 @@ static hidGC current_gc = NULL;
 static int cur_mask = -1;
 
 
+struct render_priv {
+  GdkGLConfig *glconfig;
+};
+
+void
+ghid_init_renderer (int *argc, char ***argv, GHidPort *port)
+{
+  struct render_priv *priv;
+
+  port->render_priv = priv = g_new0 (struct render_priv, 1);
+
+  gtk_gl_init(argc, argv);
+
+  /* setup GL-context */
+  priv->glconfig = gdk_gl_config_new_by_mode (GDK_GL_MODE_RGBA    |
+                                              GDK_GL_MODE_STENCIL |
+                                           // GDK_GL_MODE_DEPTH   |
+                                              GDK_GL_MODE_DOUBLE);
+  if (!priv->glconfig)
+    {
+      printf ("Could not setup GL-context!\n");
+      return; /* Should we abort? */
+    }
+}
+
+GtkWidget *
+ghid_drawing_area_new (GHidPort *port)
+{
+  GtkWidget *drawing_area;
+  struct render_priv *priv = port->render_priv;
+
+  drawing_area = gtk_drawing_area_new ();
+  gtk_widget_set_gl_capability (drawing_area,
+                                priv->glconfig,
+                                NULL,
+                                TRUE,
+                                GDK_GL_RGBA_TYPE);
+  return drawing_area;
+}
+
+gboolean
+ghid_start_drawing (GHidPort *port)
+{
+  GtkWidget *widget = port->drawing_area;
+  GdkGLContext *pGlContext = gtk_widget_get_gl_context (widget);
+  GdkGLDrawable *pGlDrawable = gtk_widget_get_gl_drawable (widget);
+
+  /* make GL-context "current" */
+  if (!gdk_gl_drawable_gl_begin (pGlDrawable, pGlContext))
+    return FALSE;
+
+  return TRUE;
+}
+
+void
+ghid_end_drawing (GHidPort *port)
+{
+  GtkWidget *widget = port->drawing_area;
+  GdkGLDrawable *pGlDrawable = gtk_widget_get_gl_drawable (widget);
+
+  if (gdk_gl_drawable_is_double_buffered (pGlDrawable))
+    gdk_gl_drawable_swap_buffers (pGlDrawable);
+  else
+    glFlush ();
+
+  /* end drawing to current GL-context */
+  gdk_gl_drawable_gl_end (pGlDrawable);
+}
+
+void
+ghid_drawing_area_configure_hook (GHidPort *port)
+{
+}
+
+void
+ghid_screen_update (void)
+{
+}
+
+void DrawAttached (bool);
+
+#define Z_NEAR 3.0
+gboolean
+ghid_drawing_area_expose_cb (GtkWidget *widget,
+                             GdkEventExpose *ev,
+                             GHidPort *port)
+{
+  BoxType region;
+  int eleft, eright, etop, ebottom;
+  extern HID ghid_hid;
+
+  ghid_start_drawing (port);
+
+  ghid_show_crosshair (FALSE);
+
+  glEnable (GL_BLEND);
+  glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+
+  glViewport (0, 0, widget->allocation.width, widget->allocation.height);
+
+  glEnable (GL_SCISSOR_TEST);
+  glScissor (ev->area.x,
+             widget->allocation.height - ev->area.height - ev->area.y,
+             ev->area.width, ev->area.height);
+
+  glMatrixMode (GL_PROJECTION);
+  glLoadIdentity ();
+  glOrtho (0, widget->allocation.width, widget->allocation.height, 0, 0, 100);
+  glMatrixMode (GL_MODELVIEW);
+  glLoadIdentity ();
+  glTranslatef (0.0f, 0.0f, -Z_NEAR);
+
+  glClearColor (gport->offlimits_color.red / 65535.,
+                gport->offlimits_color.green / 65535.,
+                gport->offlimits_color.blue / 65535.,
+                1.);
+
+  glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
+
+  region.X1 = MIN (Px (ev->area.x), Px (ev->area.x + ev->area.width + 1));
+  region.X2 = MAX (Px (ev->area.x), Px (ev->area.x + ev->area.width + 1));
+  region.Y1 = MIN (Py (ev->area.y), Py (ev->area.y + ev->area.height + 1));
+  region.Y2 = MAX (Py (ev->area.y), Py (ev->area.y + ev->area.height + 1));
+
+  eleft = Vx (0);  eright  = Vx (PCB->MaxWidth);
+  etop  = Vy (0);  ebottom = Vy (PCB->MaxHeight);
+
+  glColor3f (gport->bg_color.red / 65535.,
+             gport->bg_color.green / 65535.,
+             gport->bg_color.blue / 65535.);
+
+  glBegin (GL_QUADS);
+  glVertex3i (eleft,  etop,    0);
+  glVertex3i (eright, etop,    0);
+  glVertex3i (eright, ebottom, 0);
+  glVertex3i (eleft,  ebottom, 0);
+  glEnd ();
+
+  /* TODO: Background image */
+
+  hidgl_init_triangle_array (&buffer);
+  ghid_invalidate_current_gc ();
+
+  glPushMatrix ();
+  glScalef ((ghid_flip_x ? -1. : 1.) / gport->zoom,
+            (ghid_flip_y ? -1. : 1.) / gport->zoom,
+            (ghid_flip_x == ghid_flip_y) ? 1. : -1.);
+  glTranslatef (ghid_flip_x ? gport->view_x0 - PCB->MaxWidth  :
+                             -gport->view_x0,
+                ghid_flip_y ? gport->view_y0 - PCB->MaxHeight :
+                             -gport->view_y0, 0);
+  hid_expose_callback (&ghid_hid, &region, 0);
+  hidgl_flush_triangles (&buffer);
+  glPopMatrix ();
+
+  ghid_draw_grid ();
+
+  hidgl_init_triangle_array (&buffer);
+  ghid_invalidate_current_gc ();
+  glPushMatrix ();
+  glScalef ((ghid_flip_x ? -1. : 1.) / gport->zoom,
+            (ghid_flip_y ? -1. : 1.) / gport->zoom, 1);
+  glTranslatef (ghid_flip_x ? gport->view_x0 - PCB->MaxWidth  :
+                             -gport->view_x0,
+                ghid_flip_y ? gport->view_y0 - PCB->MaxHeight :
+                             -gport->view_y0, 0);
+  DrawAttached (TRUE);
+  DrawMark (TRUE);
+  hidgl_flush_triangles (&buffer);
+  glPopMatrix ();
+
+  ghid_show_crosshair (TRUE);
+
+  hidgl_flush_triangles (&buffer);
+
+  ghid_end_drawing (port);
+
+  return FALSE;
+}
+
+void
+ghid_pinout_preview_init (GhidPinoutPreview *preview)
+{
+  struct render_priv *priv = gport->render_priv;
+
+  gtk_widget_set_gl_capability (GTK_WIDGET (preview),
+                                priv->glconfig,
+                                NULL,
+                                TRUE,
+                                GDK_GL_RGBA_TYPE);
+}
+
+gboolean
+ghid_pinout_preview_expose (GtkWidget *widget,
+                            GdkEventExpose *ev)
+{
+  extern HID ghid_hid;
+  GdkGLContext* pGlContext = gtk_widget_get_gl_context (widget);
+  GdkGLDrawable* pGlDrawable = gtk_widget_get_gl_drawable (widget);
+  GhidPinoutPreview *pinout = GHID_PINOUT_PREVIEW (widget);
+  double save_zoom;
+  int da_w, da_h;
+  int save_left, save_top;
+  int save_width, save_height;
+  int save_view_width, save_view_height;
+  double xz, yz;
+
+  save_zoom = gport->zoom;
+  save_width = gport->width;
+  save_height = gport->height;
+  save_left = gport->view_x0;
+  save_top = gport->view_y0;
+  save_view_width = gport->view_width;
+  save_view_height = gport->view_height;
+
+  /* Setup zoom factor for drawing routines */
+
+  gdk_window_get_geometry (widget->window, 0, 0, &da_w, &da_h, 0);
+  xz = (double) pinout->x_max / da_w;
+  yz = (double) pinout->y_max / da_h;
+  if (xz > yz)
+    gport->zoom = xz;
+  else
+    gport->zoom = yz;
+
+  gport->width = da_w;
+  gport->height = da_h;
+  gport->view_width = da_w * gport->zoom;
+  gport->view_height = da_h * gport->zoom;
+  gport->view_x0 = (pinout->x_max - gport->view_width) / 2;
+  gport->view_y0 = (pinout->y_max - gport->view_height) / 2;
+
+  /* make GL-context "current" */
+  if (!gdk_gl_drawable_gl_begin (pGlDrawable, pGlContext)) {
+    return FALSE;
+  }
+
+  glEnable (GL_BLEND);
+  glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+
+  glViewport (0, 0, widget->allocation.width, widget->allocation.height);
+
+  glEnable (GL_SCISSOR_TEST);
+  glScissor (ev->area.x,
+             widget->allocation.height - ev->area.height - ev->area.y,
+             ev->area.width, ev->area.height);
+
+  glMatrixMode (GL_PROJECTION);
+  glLoadIdentity ();
+  glOrtho (0, widget->allocation.width, widget->allocation.height, 0, 0, 100);
+  glMatrixMode (GL_MODELVIEW);
+  glLoadIdentity ();
+  glTranslatef (0.0f, 0.0f, -Z_NEAR);
+
+  glClearColor (gport->bg_color.red / 65535.,
+                gport->bg_color.green / 65535.,
+                gport->bg_color.blue / 65535.,
+                1.);
+
+  glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
+
+  /* call the drawing routine */
+  hidgl_init_triangle_array (&buffer);
+  ghid_invalidate_current_gc ();
+  glPushMatrix ();
+  glScalef ((ghid_flip_x ? -1. : 1.) / gport->zoom,
+            (ghid_flip_y ? -1. : 1.) / gport->zoom, 1);
+  glTranslatef (ghid_flip_x ? gport->view_x0 - PCB->MaxWidth  :
+                             -gport->view_x0,
+                ghid_flip_y ? gport->view_y0 - PCB->MaxHeight :
+                             -gport->view_y0, 0);
+  hid_expose_callback (&ghid_hid, NULL, &pinout->element);
+  hidgl_flush_triangles (&buffer);
+  glPopMatrix ();
+
+  if (gdk_gl_drawable_is_double_buffered (pGlDrawable))
+    gdk_gl_drawable_swap_buffers (pGlDrawable);
+  else
+    glFlush ();
+
+  /* end drawing to current GL-context */
+  gdk_gl_drawable_gl_end (pGlDrawable);
+
+  gport->zoom = save_zoom;
+  gport->width = save_width;
+  gport->height = save_height;
+  gport->view_x0 = save_left;
+  gport->view_y0 = save_top;
+  gport->view_width = save_view_width;
+  gport->view_height = save_view_height;
+
+  return FALSE;
+}
+
+
+GdkPixmap *
+ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int depth)
+{
+  extern HID ghid_hid;
+  GdkGLConfig *glconfig;
+  GdkPixmap *pixmap;
+  GdkGLPixmap *glpixmap;
+  GdkGLContext* glcontext;
+  GdkGLDrawable* gldrawable;
+  double save_zoom;
+  int save_left, save_top;
+  int save_width, save_height;
+  int save_view_width, save_view_height;
+  BoxType region;
+
+  save_zoom = gport->zoom;
+  save_width = gport->width;
+  save_height = gport->height;
+  save_left = gport->view_x0;
+  save_top = gport->view_y0;
+  save_view_width = gport->view_width;
+  save_view_height = gport->view_height;
+
+  /* Setup rendering context for drawing routines
+   */
+
+  glconfig = gdk_gl_config_new_by_mode (GDK_GL_MODE_RGB     |
+                                        GDK_GL_MODE_STENCIL |
+//                                        GDK_GL_MODE_DEPTH   |
+                                        GDK_GL_MODE_SINGLE);
+
+  pixmap = gdk_pixmap_new (NULL, width, height, depth);
+  glpixmap = gdk_pixmap_set_gl_capability (pixmap, glconfig, NULL);
+  gldrawable = GDK_GL_DRAWABLE (glpixmap);
+  glcontext = gdk_gl_context_new (gldrawable, NULL, FALSE, GDK_GL_RGBA_TYPE);
+
+  /* Setup zoom factor for drawing routines */
+
+  gport->zoom = zoom;
+  gport->width = width;
+  gport->height = height;
+  gport->view_width = width * gport->zoom;
+  gport->view_height = height * gport->zoom;
+  gport->view_x0 = ghid_flip_x ? PCB->MaxWidth - cx : cx;
+  gport->view_x0 -= gport->view_height / 2;
+  gport->view_y0 = ghid_flip_y ? PCB->MaxHeight - cy : cy;
+  gport->view_y0 -= gport->view_width  / 2;
+
+  /* make GL-context "current" */
+  if (!gdk_gl_drawable_gl_begin (gldrawable, glcontext)) {
+    return NULL;
+  }
+
+  glEnable (GL_BLEND);
+  glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+
+  glViewport (0, 0, width, height);
+
+  glEnable (GL_SCISSOR_TEST);
+  glScissor (0, 0, width, height);
+
+  glMatrixMode (GL_PROJECTION);
+  glLoadIdentity ();
+  glOrtho (0, width, height, 0, 0, 100);
+  glMatrixMode (GL_MODELVIEW);
+  glLoadIdentity ();
+  glTranslatef (0.0f, 0.0f, -Z_NEAR);
+
+  glClearColor (gport->bg_color.red / 65535.,
+                gport->bg_color.green / 65535.,
+                gport->bg_color.blue / 65535.,
+                1.);
+  glClearStencil (0);
+  glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
+
+  /* call the drawing routine */
+  hidgl_init_triangle_array (&buffer);
+  ghid_invalidate_current_gc ();
+  glPushMatrix ();
+  glScalef ((ghid_flip_x ? -1. : 1.) / gport->zoom,
+            (ghid_flip_y ? -1. : 1.) / gport->zoom, 1);
+  glTranslatef (ghid_flip_x ? gport->view_x0 - PCB->MaxWidth  :
+                             -gport->view_x0,
+                ghid_flip_y ? gport->view_y0 - PCB->MaxHeight :
+                             -gport->view_y0, 0);
+  region.X1 = MIN(Px(0), Px(gport->width + 1));
+  region.Y1 = MIN(Py(0), Py(gport->height + 1));
+  region.X2 = MAX(Px(0), Px(gport->width + 1));
+  region.Y2 = MAX(Py(0), Py(gport->height + 1));
+  hid_expose_callback (&ghid_hid, &region, NULL);
+  hidgl_flush_triangles (&buffer);
+  glPopMatrix ();
+
+  glFlush ();
+
+  /* end drawing to current GL-context */
+  gdk_gl_drawable_gl_end (gldrawable);
+//  gdk_gl_context_destroy (glcontext);
+
+  gdk_pixmap_unset_gl_capability (pixmap);
+
+  g_object_unref (glconfig);
+  g_object_unref (glcontext);
+
+  gport->zoom = save_zoom;
+  gport->width = save_width;
+  gport->height = save_height;
+  gport->view_x0 = save_left;
+  gport->view_y0 = save_top;
+  gport->view_width = save_view_width;
+  gport->view_height = save_view_height;
+
+  return pixmap;
+}
+
+
 typedef struct hid_gc_struct
 {
   HID *me_pointer;
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 01d3f46..3041491 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -17,15 +17,9 @@
 #include "crosshair.h"
 #include "error.h"
 #include "../hidint.h"
+#include "gui.h"
 #include "hid/common/draw_helpers.h"
 
-#ifdef ENABLE_GL
-#  include <gtk/gtkgl.h>
-#  include <GL/gl.h>
-#  include "hid/common/hidgl.h"
-#endif
-
-#include "gui.h"
 
 #if !GTK_CHECK_VERSION(2,8,0) && defined(HAVE_GDK_GDKX_H)
 #include <gdk/gdkx.h>
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index 6f54d82..0952462 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -543,143 +543,20 @@ ghid_port_drawing_area_configure_event_cb (GtkWidget * widget,
       else
 	gdk_color_white (gport->colormap, &gport->offlimits_color);
       first_time_done = TRUE;
+      ghid_drawing_area_configure_hook (out);
       PCBChanged (0, NULL, 0, 0);
     }
-//  if (gport->mask)
-//    {
-//      gdk_pixmap_unref (gport->mask);
-//      gport->mask = gdk_pixmap_new (0, gport->width, gport->height, 1);
-//    }
+  else
+    {
+      ghid_drawing_area_configure_hook (out);
+    }
+
   ghid_port_ranges_scale (FALSE);
   ghid_invalidate_all ();
   RestoreCrosshair (TRUE);
   return 0;
 }
 
-void
-ghid_screen_update (void)
-{
-#if 0
-  ghid_show_crosshair (FALSE);
-  gdk_draw_drawable (gport->drawing_area->window, gport->bg_gc, gport->pixmap,
-		     0, 0, 0, 0, gport->width, gport->height);
-  ghid_show_crosshair (TRUE);
-#endif
-}
-
-void DrawAttached (bool);
-
-#define Z_NEAR 3.0
-gboolean
-ghid_port_drawing_area_expose_event_cb (GtkWidget * widget,
-					GdkEventExpose * ev, GHidPort * port)
-{
-  BoxType region;
-  int eleft, eright, etop, ebottom;
-  extern HID ghid_hid;
-  GdkGLContext* pGlContext = gtk_widget_get_gl_context (widget);
-  GdkGLDrawable* pGlDrawable = gtk_widget_get_gl_drawable (widget);
-
-  /* make GL-context "current" */
-  if (!gdk_gl_drawable_gl_begin (pGlDrawable, pGlContext)) {
-    return FALSE;
-  }
-
-  ghid_show_crosshair (FALSE);
-
-  glEnable (GL_BLEND);
-  glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-
-//  glEnable(GL_POLYGON_SMOOTH);
-//  glHint(GL_POLYGON_SMOOTH_HINT, [GL_FASTEST, GL_NICEST, or GL_DONT_CARE]);
-
-  glViewport (0, 0, widget->allocation.width, widget->allocation.height);
-
-  glEnable (GL_SCISSOR_TEST);
-  glScissor (ev->area.x,
-             widget->allocation.height - ev->area.height - ev->area.y,
-             ev->area.width, ev->area.height);
-
-  glMatrixMode (GL_PROJECTION);
-  glLoadIdentity ();
-  glOrtho (0, widget->allocation.width, widget->allocation.height, 0, 0, 100);
-  glMatrixMode (GL_MODELVIEW);
-  glLoadIdentity ();
-  glTranslatef (0.0f, 0.0f, -Z_NEAR);
-
-  glClearColor (gport->offlimits_color.red / 65535.,
-                gport->offlimits_color.green / 65535.,
-                gport->offlimits_color.blue / 65535.,
-                1.);
-
-  glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
-
-  region.X1 = MIN (Px (ev->area.x), Px (ev->area.x + ev->area.width + 1));
-  region.X2 = MAX (Px (ev->area.x), Px (ev->area.x + ev->area.width + 1));
-  region.Y1 = MIN (Py (ev->area.y), Py (ev->area.y + ev->area.height + 1));
-  region.Y2 = MAX (Py (ev->area.y), Py (ev->area.y + ev->area.height + 1));
-
-  eleft = Vx (0);  eright  = Vx (PCB->MaxWidth);
-  etop  = Vy (0);  ebottom = Vy (PCB->MaxHeight);
-
-  glColor3f (gport->bg_color.red / 65535.,
-             gport->bg_color.green / 65535.,
-             gport->bg_color.blue / 65535.);
-
-  glBegin (GL_QUADS);
-  glVertex3i (eleft,  etop,    0);
-  glVertex3i (eright, etop,    0);
-  glVertex3i (eright, ebottom, 0);
-  glVertex3i (eleft,  ebottom, 0);
-  glEnd ();
-
-  /* TODO: Background image */
-
-  hidgl_init_triangle_array (&buffer);
-  ghid_invalidate_current_gc ();
-
-  glPushMatrix ();
-  glScalef ((ghid_flip_x ? -1. : 1.) / gport->zoom,
-            (ghid_flip_y ? -1. : 1.) / gport->zoom,
-            (ghid_flip_x == ghid_flip_y) ? 1. : -1.);
-  glTranslatef (ghid_flip_x ? gport->view_x0 - PCB->MaxWidth  :
-                             -gport->view_x0,
-                ghid_flip_y ? gport->view_y0 - PCB->MaxHeight :
-                             -gport->view_y0, 0);
-  hid_expose_callback (&ghid_hid, &region, 0);
-  hidgl_flush_triangles (&buffer);
-  glPopMatrix ();
-
-  ghid_draw_grid ();
-
-  hidgl_init_triangle_array (&buffer);
-  ghid_invalidate_current_gc ();
-  glPushMatrix ();
-  glScalef ((ghid_flip_x ? -1. : 1.) / gport->zoom,
-            (ghid_flip_y ? -1. : 1.) / gport->zoom, 1);
-  glTranslatef (ghid_flip_x ? gport->view_x0 - PCB->MaxWidth  :
-                             -gport->view_x0,
-                ghid_flip_y ? gport->view_y0 - PCB->MaxHeight :
-                             -gport->view_y0, 0);
-  DrawAttached (TRUE);
-  DrawMark (TRUE);
-  hidgl_flush_triangles (&buffer);
-  glPopMatrix ();
-
-  ghid_show_crosshair (TRUE);
-
-  hidgl_flush_triangles (&buffer);
-
-  if (gdk_gl_drawable_is_double_buffered (pGlDrawable))
-    gdk_gl_drawable_swap_buffers (pGlDrawable);
-  else
-    glFlush ();
-
-  /* end drawing to current GL-context */
-  gdk_gl_drawable_gl_end (pGlDrawable);
-
-  return FALSE;
-}
 
 #if GTK_CHECK_VERSION(2,12,0)
 # define ENABLE_TOOLTIPS 1
@@ -810,14 +687,9 @@ ghid_port_window_motion_cb (GtkWidget * widget,
   gdouble dx, dy;
   static gint x_prev = -1, y_prev = -1;
   gboolean moved;
-  GdkGLContext* pGlContext = gtk_widget_get_gl_context (widget);
-  GdkGLDrawable* pGlDrawable = gtk_widget_get_gl_drawable (widget);
 
-  /* make GL-context "current" */
-  if (!gdk_gl_drawable_gl_begin (pGlDrawable, pGlContext)) {
-    printf ("GL THingy returned\n");
+  if (!ghid_start_drawing (out))
     return FALSE;
-  }
 
   if (out->panning)
     {
@@ -842,13 +714,7 @@ ghid_port_window_motion_cb (GtkWidget * widget,
   if (moved && have_crosshair_attachments ())
     ghid_draw_area_update (gport, NULL);
 
-  if (gdk_gl_drawable_is_double_buffered (pGlDrawable))
-    gdk_gl_drawable_swap_buffers (pGlDrawable);
-  else
-    glFlush ();
-
-  /* end drawing to current GL-context */
-  gdk_gl_drawable_gl_end (pGlDrawable);
+  ghid_end_drawing (out);
   return FALSE;
 }
 
diff --git a/src/hid/gtk/gui-pinout-preview.c b/src/hid/gtk/gui-pinout-preview.c
index b9d57da..7e2fb89 100644
--- a/src/hid/gtk/gui-pinout-preview.c
+++ b/src/hid/gtk/gui-pinout-preview.c
@@ -150,110 +150,6 @@ pinout_set_data (GhidPinoutPreview * pinout, ElementType * element)
 }
 
 
-#define Z_NEAR 3.0
-
-static gboolean
-ghid_pinout_preview_expose (GtkWidget * widget, GdkEventExpose * ev)
-{
-  extern HID ghid_hid;
-  GdkGLContext* pGlContext = gtk_widget_get_gl_context (widget);
-  GdkGLDrawable* pGlDrawable = gtk_widget_get_gl_drawable (widget);
-  GhidPinoutPreview *pinout = GHID_PINOUT_PREVIEW (widget);
-  double save_zoom;
-  int da_w, da_h;
-  int save_left, save_top;
-  int save_width, save_height;
-  int save_view_width, save_view_height;
-  double xz, yz;
-
-  save_zoom = gport->zoom;
-  save_width = gport->width;
-  save_height = gport->height;
-  save_left = gport->view_x0;
-  save_top = gport->view_y0;
-  save_view_width = gport->view_width;
-  save_view_height = gport->view_height;
-
-  /* Setup zoom factor for drawing routines */
-
-  gdk_window_get_geometry (widget->window, 0, 0, &da_w, &da_h, 0);
-  xz = (double) pinout->x_max / da_w;
-  yz = (double) pinout->y_max / da_h;
-  if (xz > yz)
-    gport->zoom = xz;
-  else
-    gport->zoom = yz;
-
-  gport->width = da_w;
-  gport->height = da_h;
-  gport->view_width = da_w * gport->zoom;
-  gport->view_height = da_h * gport->zoom;
-  gport->view_x0 = (pinout->x_max - gport->view_width) / 2;
-  gport->view_y0 = (pinout->y_max - gport->view_height) / 2;
-
-  /* make GL-context "current" */
-  if (!gdk_gl_drawable_gl_begin (pGlDrawable, pGlContext)) {
-    return FALSE;
-  }
-
-  glEnable (GL_BLEND);
-  glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-
-  glViewport (0, 0, widget->allocation.width, widget->allocation.height);
-
-  glEnable (GL_SCISSOR_TEST);
-  glScissor (ev->area.x,
-             widget->allocation.height - ev->area.height - ev->area.y,
-             ev->area.width, ev->area.height);
-
-  glMatrixMode (GL_PROJECTION);
-  glLoadIdentity ();
-  glOrtho (0, widget->allocation.width, widget->allocation.height, 0, 0, 100);
-  glMatrixMode (GL_MODELVIEW);
-  glLoadIdentity ();
-  glTranslatef (0.0f, 0.0f, -Z_NEAR);
-
-  glClearColor (gport->bg_color.red / 65535.,
-                gport->bg_color.green / 65535.,
-                gport->bg_color.blue / 65535.,
-                1.);
-
-  glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
-
-  /* call the drawing routine */
-  hidgl_init_triangle_array (&buffer);
-  ghid_invalidate_current_gc ();
-  glPushMatrix ();
-  glScalef ((ghid_flip_x ? -1. : 1.) / gport->zoom,
-            (ghid_flip_y ? -1. : 1.) / gport->zoom, 1);
-  glTranslatef (ghid_flip_x ? gport->view_x0 - PCB->MaxWidth  :
-                             -gport->view_x0,
-                ghid_flip_y ? gport->view_y0 - PCB->MaxHeight :
-                             -gport->view_y0, 0);
-  hid_expose_callback (&ghid_hid, NULL, &pinout->element);
-  hidgl_flush_triangles (&buffer);
-  glPopMatrix ();
-
-  if (gdk_gl_drawable_is_double_buffered (pGlDrawable))
-    gdk_gl_drawable_swap_buffers (pGlDrawable);
-  else
-    glFlush ();
-
-  /* end drawing to current GL-context */
-  gdk_gl_drawable_gl_end (pGlDrawable);
-
-  gport->zoom = save_zoom;
-  gport->width = save_width;
-  gport->height = save_height;
-  gport->view_x0 = save_left;
-  gport->view_y0 = save_top;
-  gport->view_width = save_view_width;
-  gport->view_height = save_view_height;
-
-  return FALSE;
-}
-
-
 enum
 {
   PROP_ELEMENT_DATA = 1,
@@ -286,11 +182,7 @@ ghid_pinout_preview_constructor (GType type,
   object = G_OBJECT_CLASS (ghid_pinout_preview_parent_class)->
     constructor (type, n_construct_properties, construct_properties);
 
-  gtk_widget_set_gl_capability (GTK_WIDGET (object),
-                                gport->glconfig,
-                                NULL,
-                                TRUE,
-                                GDK_GL_RGBA_TYPE);
+  ghid_pinout_preview_init (GHID_PINOUT_PREVIEW (object));
 
   return object;
 }
diff --git a/src/hid/gtk/gui-render-pixmap.c b/src/hid/gtk/gui-render-pixmap.c
index 4caddf2..b24e6c9 100644
--- a/src/hid/gtk/gui-render-pixmap.c
+++ b/src/hid/gtk/gui-render-pixmap.c
@@ -39,24 +39,19 @@
 RCSID ("$Id$");
 
 
-#define Z_NEAR 3.0
-
-
 GdkPixmap *
 ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int depth)
 {
   extern HID ghid_hid;
-  GdkGLConfig *glconfig;
   GdkPixmap *pixmap;
-  GdkGLPixmap *glpixmap;
-  GdkGLContext* glcontext;
-  GdkGLDrawable* gldrawable;
+  GdkDrawable *save_drawable;
   double save_zoom;
   int save_left, save_top;
   int save_width, save_height;
   int save_view_width, save_view_height;
   BoxType region;
 
+  save_drawable = gport->drawable;
   save_zoom = gport->zoom;
   save_width = gport->width;
   save_height = gport->height;
@@ -65,21 +60,12 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   save_view_width = gport->view_width;
   save_view_height = gport->view_height;
 
-  /* Setup rendering context for drawing routines
-   */
-
-  glconfig = gdk_gl_config_new_by_mode (GDK_GL_MODE_RGB     |
-                                        GDK_GL_MODE_STENCIL |
-//                                        GDK_GL_MODE_DEPTH   |
-                                        GDK_GL_MODE_SINGLE);
-
   pixmap = gdk_pixmap_new (NULL, width, height, depth);
-  glpixmap = gdk_pixmap_set_gl_capability (pixmap, glconfig, NULL);
-  gldrawable = GDK_GL_DRAWABLE (glpixmap);
-  glcontext = gdk_gl_context_new (gldrawable, NULL, FALSE, GDK_GL_RGBA_TYPE);
 
-  /* Setup zoom factor for drawing routines */
+  /* Setup drawable and zoom factor for drawing routines
+   */
 
+  gport->drawable = pixmap;
   gport->zoom = zoom;
   gport->width = width;
   gport->height = height;
@@ -90,62 +76,17 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   gport->view_y0 = ghid_flip_y ? PCB->MaxHeight - cy : cy;
   gport->view_y0 -= gport->view_width  / 2;
 
-  /* make GL-context "current" */
-  if (!gdk_gl_drawable_gl_begin (gldrawable, glcontext)) {
-    return NULL;
-  }
-
-  glEnable (GL_BLEND);
-  glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-
-  glViewport (0, 0, width, height);
-
-  glEnable (GL_SCISSOR_TEST);
-  glScissor (0, 0, width, height);
-
-  glMatrixMode (GL_PROJECTION);
-  glLoadIdentity ();
-  glOrtho (0, width, height, 0, 0, 100);
-  glMatrixMode (GL_MODELVIEW);
-  glLoadIdentity ();
-  glTranslatef (0.0f, 0.0f, -Z_NEAR);
-
-  glClearColor (gport->bg_color.red / 65535.,
-                gport->bg_color.green / 65535.,
-                gport->bg_color.blue / 65535.,
-                1.);
-  glClearStencil (0);
-  glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
+  /* clear background */
+  gdk_draw_rectangle (pixmap, gport->bg_gc, TRUE, 0, 0, width, height);
 
   /* call the drawing routine */
-  hidgl_init_triangle_array (&buffer);
-  ghid_invalidate_current_gc ();
-  glPushMatrix ();
-  glScalef ((ghid_flip_x ? -1. : 1.) / gport->zoom,
-            (ghid_flip_y ? -1. : 1.) / gport->zoom, 1);
-  glTranslatef (ghid_flip_x ? gport->view_x0 - PCB->MaxWidth  :
-                             -gport->view_x0,
-                ghid_flip_y ? gport->view_y0 - PCB->MaxHeight :
-                             -gport->view_y0, 0);
   region.X1 = MIN(Px(0), Px(gport->width + 1));
   region.Y1 = MIN(Py(0), Py(gport->height + 1));
   region.X2 = MAX(Px(0), Px(gport->width + 1));
   region.Y2 = MAX(Py(0), Py(gport->height + 1));
   hid_expose_callback (&ghid_hid, &region, NULL);
-  hidgl_flush_triangles (&buffer);
-  glPopMatrix ();
-
-  glFlush ();
-
-  /* end drawing to current GL-context */
-  gdk_gl_drawable_gl_end (gldrawable);
-//  gdk_gl_context_destroy (glcontext);
-
-  gdk_pixmap_unset_gl_capability (pixmap);
-
-  g_object_unref (glconfig);
-  g_object_unref (glcontext);
 
+  gport->drawable = save_drawable;
   gport->zoom = save_zoom;
   gport->width = save_width;
   gport->height = save_height;
diff --git a/src/hid/gtk/gui-top-window.c b/src/hid/gtk/gui-top-window.c
index 197e886..68090b7 100644
--- a/src/hid/gtk/gui-top-window.c
+++ b/src/hid/gtk/gui-top-window.c
@@ -2296,12 +2296,7 @@ ghid_build_pcb_top_window (void)
   gtk_viewport_set_shadow_type (GTK_VIEWPORT (viewport), GTK_SHADOW_IN);
   gtk_box_pack_start (GTK_BOX (hbox), viewport, TRUE, TRUE, 0);
 
-  gport->drawing_area = gtk_drawing_area_new ();
-  gtk_widget_set_gl_capability (gport->drawing_area,
-                                gport->glconfig,
-                                NULL,
-                                TRUE,
-                                GDK_GL_RGBA_TYPE);
+  gport->drawing_area = ghid_drawing_area_new (port);
 
   gtk_widget_add_events (gport->drawing_area, GDK_EXPOSURE_MASK
 			 | GDK_LEAVE_NOTIFY_MASK | GDK_ENTER_NOTIFY_MASK
@@ -2358,7 +2353,7 @@ ghid_build_pcb_top_window (void)
    */
 
   g_signal_connect (G_OBJECT (gport->drawing_area), "expose_event",
-		    G_CALLBACK (ghid_port_drawing_area_expose_event_cb),
+		    G_CALLBACK (ghid_drawing_area_expose_cb),
 		    port);
   g_signal_connect (G_OBJECT (gport->top_window), "configure_event",
 		    G_CALLBACK (top_window_configure_event_cb), port);
@@ -2677,21 +2672,12 @@ ghid_parse_arguments (int *argc, char ***argv)
   gtk_disable_setlocale ();
 
   gtk_init (argc, argv);
-  gtk_gl_init(argc, argv);
 
   gport = &ghid_port;
   gport->zoom = 300.0;
   pixel_slop = 300;
 
-  /* setup GL-context */
-  gport->glconfig = gdk_gl_config_new_by_mode (GDK_GL_MODE_RGBA    |
-                                               GDK_GL_MODE_STENCIL |
-//                                               GDK_GL_MODE_DEPTH   |
-                                               GDK_GL_MODE_DOUBLE);
-  if (!gport->glconfig) {
-    printf("Could not setup GL-context!\n");
-    return; /* Should we abort? */
-  }
+  ghid_init_renderer (argc, argv, gport);
 
   ghid_config_files_read (argc, argv);
 
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index 680d74a..6838743 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -36,6 +36,7 @@
 #include <sys/stat.h>
 
 #include <gtk/gtk.h>
+#include "gui-pinout-preview.h"
 
 /* The Linux OpenGL ABI 1.0 spec requires that we define
  * GL_GLEXT_PROTOTYPES before including gl.h or glx.h for extensions
@@ -175,13 +176,9 @@ typedef struct
   GdkDrawable *drawable;	/* Current drawable for drawing routines */
   gint width, height;
 
-#ifdef ENABLE_GL
-  GdkGLConfig *glconfig;
-#endif
-
   gint trans_lines;
 
-//  GdkGC *bg_gc, *offlimits_gc, *mask_gc, *u_gc, *grid_gc;
+  struct render_priv *render_priv;
 
   GdkColor bg_color, offlimits_color, grid_color;
 
@@ -496,15 +493,17 @@ void ghid_logv (const char *fmt, va_list args);
 /* gui-pinout-window.c */
 void ghid_pinout_window_show (GHidPort * out, ElementTypePtr Element);
 
-/* gui-render-pixmap.c */
-GdkPixmap *ghid_render_pixmap (int cx,
-			       int cy,
-			       double zoom,
-			       int width,
-			       int height,
-			       int depth);
-
 /* gtkhid-gdk.c OR gtkhid-gl.c */
+void ghid_init_renderer (int *, char ***, GHidPort *);
+GtkWidget *ghid_drawing_area_new (GHidPort *port);
+gboolean ghid_start_drawing (GHidPort *port);
+void ghid_end_drawing (GHidPort *port);
+void ghid_drawing_area_configure_hook (GHidPort *port);
+void ghid_screen_update (void);
+gboolean ghid_drawing_area_expose_cb (GtkWidget *, GdkEventExpose *, GHidPort *);
+void ghid_pinout_preview_init (GhidPinoutPreview *preview);
+gboolean ghid_pinout_preview_expose (GtkWidget * widget, GdkEventExpose * ev);
+GdkPixmap *ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int depth);
 hidGC ghid_make_gc (void);
 void ghid_destroy_gc (hidGC);
 void ghid_draw_grid (void);

Bottom: f2d74cea0683c58d2875549a78ffc5b513e1a84f
Top:    404a347e35e2f5d42d0c27b225421316ecfdbdc6
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-08-30 20:48:12 +0100

Major re-write to drawing routines

FIXME: FULLY OF NASTY API HACKS TO draw.c

Notes from squashed patches:
  Pin and via hole cores are drawn in the appropriate colour
  Playing with stack rendering order
  Fix mask display in 3D (Allow both side masks to display at once)
  Fix rendering depths for silk and mask layers
  Fixup depth for layers and element marks
  Move more rendering to world coordinates
  Fix get_coords function


---

diff --git a/src/draw.c b/src/draw.c
index 5dd4091..326be24 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -84,8 +84,8 @@ static bool doing_assy = false;
  */
 static void DrawEverything (const BoxType *);
 static void AddPart (void *);
-static void DrawEMark (ElementTypePtr, Coord, Coord, bool);
-static void DrawRats (const BoxType *);
+/* static */ void DrawEMark (ElementTypePtr, Coord, Coord, bool);
+/* static */ void DrawRats (const BoxType *);
 
 
 /*---------------------------------------------------------------------------
@@ -455,7 +455,7 @@ DrawEverything (const BoxType *drawn_area)
     }
 }
 
-static void
+/* static */ void
 DrawEMark (ElementTypePtr e, Coord X, Coord Y, bool invisible)
 {
   Coord mark_size = EMARK_SIZE;
@@ -626,7 +626,7 @@ DrawPaste (int side, const BoxType *drawn_area)
   ENDALL_LOOP;
 }
 
-static void
+/* static */ void
 DrawRats (const BoxType *drawn_area)
 {
   /*
diff --git a/src/draw.h b/src/draw.h
index cec3a16..f6dc31f 100644
--- a/src/draw.h
+++ b/src/draw.h
@@ -77,4 +77,15 @@ void DrawMask (int side, const BoxType *drawn_area);
 void DrawHoles (bool draw_plated, bool draw_unplated, const BoxType *drawn_area);
 void PrintAssembly (int side, const BoxType *drawn_area);
 
+/* TEMPORARY */
+void ClearPad (PadTypePtr, bool);
+void DrawPinOrViaLowLevel (PinTypePtr, bool);
+void DrawPlainPin (PinTypePtr, bool);
+void DrawPlainVia (PinTypePtr, bool);
+void DrawRegularText (LayerTypePtr, TextTypePtr);
+void DrawEMark (ElementTypePtr, Coord, Coord, bool);
+void DrawHole (PinTypePtr);
+void DrawRats (const BoxType *);
+/* TEMPORARY */
+
 #endif
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 07d2135..4c62846 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -10,6 +10,9 @@
 #include "clip.h"
 #include "../hidint.h"
 #include "gui.h"
+#include "draw.h"
+#include "draw_funcs.h"
+#include "rtree.h"
 #include "gui-pinout-preview.h"
 
 /* The Linux OpenGL ABI 1.0 spec requires that we define
@@ -235,14 +238,10 @@ ghid_set_layer (const char *name, int group, int empty)
 	case SL_INVISIBLE:
 	  return PCB->InvisibleObjectsOn;
 	case SL_MASK:
-	  if (SL_MYSIDE (idx))
-	    return TEST_FLAG (SHOWMASKFLAG, PCB);
-	  return 0;
+	  return TEST_FLAG (SHOWMASKFLAG, PCB);
 	case SL_SILK:
 	  priv->trans_lines = true;
-	  if (SL_MYSIDE (idx))
-	    return PCB->ElementOn;
-	  return 0;
+	  return PCB->ElementOn;
 	case SL_ASSY:
 	  return 0;
 	case SL_PDRILL:
@@ -294,6 +293,7 @@ ghid_draw_grid (BoxTypePtr drawn_area)
       gport->grid_color.blue ^= gport->bg_color.blue;
     }
 
+  glDisable (GL_STENCIL_TEST);
   glEnable (GL_COLOR_LOGIC_OP);
   glLogicOp (GL_XOR);
 
@@ -304,6 +304,7 @@ ghid_draw_grid (BoxTypePtr drawn_area)
   hidgl_draw_grid (drawn_area);
 
   glDisable (GL_COLOR_LOGIC_OP);
+  glEnable (GL_STENCIL_TEST);
 }
 
 static void
@@ -971,6 +972,10 @@ ghid_start_drawing (GHidPort *port)
 
   port->render_priv->in_context = true;
 
+  Output.fgGC = gui->make_gc ();
+  Output.bgGC = gui->make_gc ();
+  Output.pmGC = gui->make_gc ();
+
   return TRUE;
 }
 
@@ -989,6 +994,14 @@ ghid_end_drawing (GHidPort *port)
 
   /* end drawing to current GL-context */
   gdk_gl_drawable_gl_end (pGlDrawable);
+
+  gui->destroy_gc (Output.fgGC);
+  gui->destroy_gc (Output.bgGC);
+  gui->destroy_gc (Output.pmGC);
+
+  Output.fgGC = NULL;
+  Output.bgGC = NULL;
+  Output.pmGC = NULL;
 }
 
 void
@@ -996,6 +1009,854 @@ ghid_screen_update (void)
 {
 }
 
+static int
+EMark_callback (const BoxType * b, void *cl)
+{
+  ElementTypePtr element = (ElementTypePtr) b;
+
+  DrawEMark (element, element->MarkX, element->MarkY, !FRONT (element));
+  return 1;
+}
+
+static void
+SetPVColor (PinTypePtr Pin, int Type)
+{
+  char *color;
+
+  if (Type == VIA_TYPE)
+    {
+      if (TEST_FLAG (WARNFLAG | SELECTEDFLAG | FOUNDFLAG, Pin))
+	{
+	  if (TEST_FLAG (WARNFLAG, Pin))
+	    color = PCB->WarnColor;
+	  else if (TEST_FLAG (SELECTEDFLAG, Pin))
+	    color = PCB->ViaSelectedColor;
+	  else
+	    color = PCB->ConnectedColor;
+	}
+      else
+	color = PCB->ViaColor;
+    }
+  else
+    {
+      if (TEST_FLAG (WARNFLAG | SELECTEDFLAG | FOUNDFLAG, Pin))
+	{
+	  if (TEST_FLAG (WARNFLAG, Pin))
+	    color = PCB->WarnColor;
+	  else if (TEST_FLAG (SELECTEDFLAG, Pin))
+	    color = PCB->PinSelectedColor;
+	  else
+	    color = PCB->ConnectedColor;
+	}
+      else
+	color = PCB->PinColor;
+    }
+
+  gui->set_color (Output.fgGC, color);
+}
+
+static void
+SetPVColor_inlayer (PinTypePtr Pin, LayerTypePtr Layer, int Type)
+{
+  char *color;
+
+  if (TEST_FLAG (WARNFLAG, Pin))
+    color = PCB->WarnColor;
+  else if (TEST_FLAG (SELECTEDFLAG, Pin))
+    color = (Type == VIA_TYPE) ? PCB->ViaSelectedColor : PCB->PinSelectedColor;
+  else if (TEST_FLAG (FOUNDFLAG, Pin))
+    color = PCB->ConnectedColor;
+  else
+    {
+      int component_group = GetLayerGroupNumberByNumber (component_silk_layer);
+      int solder_group    = GetLayerGroupNumberByNumber (solder_silk_layer);
+      int this_group      = GetLayerGroupNumberByPointer (Layer);
+
+      if (this_group == component_group || this_group == solder_group)
+        color = (SWAP_IDENT == (this_group == solder_group))
+                  ? PCB->ViaColor : PCB->InvisibleObjectsColor;
+      else
+        color = Layer->Color;
+    }
+
+  gui->set_color (Output.fgGC, color);
+}
+
+static void
+_draw_pv_name (PinType *pv)
+{
+  BoxType box;
+  bool vert;
+  TextType text;
+
+  if (!pv->Name || !pv->Name[0])
+    text.TextString = EMPTY (pv->Number);
+  else
+    text.TextString = EMPTY (TEST_FLAG (SHOWNUMBERFLAG, PCB) ? pv->Number : pv->Name);
+
+  vert = TEST_FLAG (EDGE2FLAG, pv);
+
+  if (vert)
+    {
+      box.X1 = pv->X - pv->Thickness    / 2 + Settings.PinoutTextOffsetY;
+      box.Y1 = pv->Y - pv->DrillingHole / 2 - Settings.PinoutTextOffsetX;
+    }
+  else
+    {
+      box.X1 = pv->X + pv->DrillingHole / 2 + Settings.PinoutTextOffsetX;
+      box.Y1 = pv->Y - pv->Thickness    / 2 + Settings.PinoutTextOffsetY;
+    }
+
+  gui->set_color (Output.fgGC, PCB->PinNameColor);
+
+  text.Flags = NoFlags ();
+  text.Scale = pv->Thickness / 80;
+  text.X = box.X1;
+  text.Y = box.Y1;
+  text.Direction = vert ? 1 : 0;
+
+  DrawTextLowLevel (&text, 0);
+}
+
+static void
+_draw_pv (PinTypePtr pv, bool draw_hole)
+{
+  if (TEST_FLAG (THINDRAWFLAG, PCB))
+    gui->thindraw_pcb_pv (Output.fgGC, Output.fgGC, pv, draw_hole, false);
+  else
+    gui->fill_pcb_pv (Output.fgGC, Output.bgGC, pv, draw_hole, false);
+
+  if (!TEST_FLAG (HOLEFLAG, pv) && TEST_FLAG (DISPLAYNAMEFLAG, pv))
+    _draw_pv_name (pv);
+}
+
+static void
+draw_pin (PinTypePtr pin, bool draw_hole)
+{
+  SetPVColor (pin, PIN_TYPE);
+  _draw_pv (pin, draw_hole);
+}
+
+static int
+pin_callback (const BoxType * b, void *cl)
+{
+  draw_pin ((PinType *)b, false);
+  return 1;
+}
+
+static int
+pin_inlayer_callback (const BoxType * b, void *cl)
+{
+  SetPVColor_inlayer ((PinTypePtr) b, cl, PIN_TYPE);
+  _draw_pv ((PinType *) b, false);
+  return 1;
+}
+
+static void
+draw_via (PinTypePtr via, bool draw_hole)
+{
+  SetPVColor (via, VIA_TYPE);
+  _draw_pv (via, draw_hole);
+}
+
+static int
+via_callback (const BoxType * b, void *cl)
+{
+  draw_via ((PinType *)b, TEST_FLAG (THINDRAWFLAG, PCB));
+  return 1;
+}
+
+static int
+via_inlayer_callback (const BoxType * b, void *cl)
+{
+  SetPVColor_inlayer ((PinTypePtr) b, cl, VIA_TYPE);
+  _draw_pv ((PinType *) b, TEST_FLAG (THINDRAWFLAG, PCB));
+  return 1;
+}
+
+static void
+draw_pad_name (PadType *pad)
+{
+  BoxType box;
+  bool vert;
+  TextType text;
+
+  if (!pad->Name || !pad->Name[0])
+    text.TextString = EMPTY (pad->Number);
+  else
+    text.TextString = EMPTY (TEST_FLAG (SHOWNUMBERFLAG, PCB) ? pad->Number : pad->Name);
+
+  /* should text be vertical ? */
+  vert = (pad->Point1.X == pad->Point2.X);
+
+  if (vert)
+    {
+      box.X1 = pad->Point1.X                      - pad->Thickness / 2;
+      box.Y1 = MAX (pad->Point1.Y, pad->Point2.Y) + pad->Thickness / 2;
+      box.X1 += Settings.PinoutTextOffsetY;
+      box.Y1 -= Settings.PinoutTextOffsetX;
+    }
+  else
+    {
+      box.X1 = MIN (pad->Point1.X, pad->Point2.X) - pad->Thickness / 2;
+      box.Y1 = pad->Point1.Y                      - pad->Thickness / 2;
+      box.X1 += Settings.PinoutTextOffsetX;
+      box.Y1 += Settings.PinoutTextOffsetY;
+    }
+
+  gui->set_color (Output.fgGC, PCB->PinNameColor);
+
+  text.Flags = NoFlags ();
+  text.Scale = pad->Thickness / 50;
+  text.X = box.X1;
+  text.Y = box.Y1;
+  text.Direction = vert ? 1 : 0;
+
+  DrawTextLowLevel (&text, 0);
+}
+
+static void
+_draw_pad (hidGC gc, PadType *pad, bool clear, bool mask)
+{
+  if (clear && !mask && pad->Clearance <= 0)
+    return;
+
+  if (TEST_FLAG (THINDRAWFLAG, PCB) ||
+      (clear && TEST_FLAG (THINDRAWPOLYFLAG, PCB)))
+    gui->thindraw_pcb_pad (gc, pad, clear, mask);
+  else
+    gui->fill_pcb_pad (gc, pad, clear, mask);
+}
+
+static void
+draw_pad (PadType *pad)
+{
+  if (TEST_FLAG (WARNFLAG | SELECTEDFLAG | FOUNDFLAG, pad))
+   {
+     if (TEST_FLAG (WARNFLAG, pad))
+       gui->set_color (Output.fgGC, PCB->WarnColor);
+     else if (TEST_FLAG (SELECTEDFLAG, pad))
+       gui->set_color (Output.fgGC, PCB->PinSelectedColor);
+     else
+       gui->set_color (Output.fgGC, PCB->ConnectedColor);
+   }
+  else if (FRONT (pad))
+   gui->set_color (Output.fgGC, PCB->PinColor);
+  else
+   gui->set_color (Output.fgGC, PCB->InvisibleObjectsColor);
+
+  _draw_pad (Output.fgGC, pad, false, false);
+
+  if (TEST_FLAG (DISPLAYNAMEFLAG, pad))
+    draw_pad_name (pad);
+}
+
+static int
+pad_callback (const BoxType * b, void *cl)
+{
+  PadTypePtr pad = (PadTypePtr) b;
+  int *side = cl;
+
+  if (ON_SIDE (pad, *side))
+    draw_pad (pad);
+  return 1;
+}
+
+
+static int
+hole_callback (const BoxType * b, void *cl)
+{
+  PinTypePtr pv = (PinTypePtr) b;
+  int plated = cl ? *(int *) cl : -1;
+
+  if ((plated == 0 && !TEST_FLAG (HOLEFLAG, pv)) ||
+      (plated == 1 &&  TEST_FLAG (HOLEFLAG, pv)))
+    return 1;
+
+  if (TEST_FLAG (THINDRAWFLAG, PCB))
+    {
+      if (!TEST_FLAG (HOLEFLAG, pv))
+        {
+          gui->set_line_cap (Output.fgGC, Round_Cap);
+          gui->set_line_width (Output.fgGC, 0);
+          gui->draw_arc (Output.fgGC,
+                         pv->X, pv->Y, pv->DrillingHole / 2,
+                         pv->DrillingHole / 2, 0, 360);
+        }
+    }
+  else
+    gui->fill_circle (Output.bgGC, pv->X, pv->Y, pv->DrillingHole / 2);
+
+  if (TEST_FLAG (HOLEFLAG, pv))
+    {
+      if (TEST_FLAG (WARNFLAG, pv))
+        gui->set_color (Output.fgGC, PCB->WarnColor);
+      else if (TEST_FLAG (SELECTEDFLAG, pv))
+        gui->set_color (Output.fgGC, PCB->ViaSelectedColor);
+      else
+        gui->set_color (Output.fgGC, Settings.BlackColor);
+
+      gui->set_line_cap (Output.fgGC, Round_Cap);
+      gui->set_line_width (Output.fgGC, 0);
+      gui->draw_arc (Output.fgGC,
+                     pv->X, pv->Y, pv->DrillingHole / 2,
+                     pv->DrillingHole / 2, 0, 360);
+    }
+  return 1;
+}
+
+static void
+_draw_line (LineType *line)
+{
+  gui->set_line_cap (Output.fgGC, Trace_Cap);
+  if (TEST_FLAG (THINDRAWFLAG, PCB))
+    gui->set_line_width (Output.fgGC, 0);
+  else
+    gui->set_line_width (Output.fgGC, line->Thickness);
+
+  gui->draw_line (Output.fgGC,
+		  line->Point1.X, line->Point1.Y,
+		  line->Point2.X, line->Point2.Y);
+}
+
+static void
+draw_line (LayerType *layer, LineType *line)
+{
+  if (TEST_FLAG (SELECTEDFLAG | FOUNDFLAG, line))
+    {
+      if (TEST_FLAG (SELECTEDFLAG, line))
+        gui->set_color (Output.fgGC, layer->SelectedColor);
+      else
+        gui->set_color (Output.fgGC, PCB->ConnectedColor);
+    }
+  else
+    gui->set_color (Output.fgGC, layer->Color);
+  _draw_line (line);
+}
+
+static int
+line_callback (const BoxType * b, void *cl)
+{
+  draw_line ((LayerType *) cl, (LineType *) b);
+  return 1;
+}
+
+static void
+_draw_arc (ArcType *arc)
+{
+  if (!arc->Thickness)
+    return;
+
+  if (TEST_FLAG (THINDRAWFLAG, PCB))
+    gui->set_line_width (Output.fgGC, 0);
+  else
+    gui->set_line_width (Output.fgGC, arc->Thickness);
+  gui->set_line_cap (Output.fgGC, Trace_Cap);
+
+  gui->draw_arc (Output.fgGC, arc->X, arc->Y, arc->Width,
+                 arc->Height, arc->StartAngle, arc->Delta);
+}
+
+static void
+draw_arc (LayerType *layer, ArcType *arc)
+{
+  if (TEST_FLAG (SELECTEDFLAG | FOUNDFLAG, arc))
+    {
+      if (TEST_FLAG (SELECTEDFLAG, arc))
+        gui->set_color (Output.fgGC, layer->SelectedColor);
+      else
+        gui->set_color (Output.fgGC, PCB->ConnectedColor);
+    }
+  else
+    gui->set_color (Output.fgGC, layer->Color);
+
+  _draw_arc (arc);
+}
+
+static int
+arc_callback (const BoxType * b, void *cl)
+{
+  draw_arc ((LayerTypePtr) cl, (ArcTypePtr) b);
+  return 1;
+}
+
+static int
+text_callback (const BoxType * b, void *cl)
+{
+  LayerType *layer = cl;
+  TextType *text = (TextType *)b;
+  int min_silk_line;
+
+  if (TEST_FLAG (SELECTEDFLAG, text))
+    gui->set_color (Output.fgGC, layer->SelectedColor);
+  else
+    gui->set_color (Output.fgGC, layer->Color);
+  if (layer == &PCB->Data->SILKLAYER ||
+      layer == &PCB->Data->BACKSILKLAYER)
+    min_silk_line = PCB->minSlk;
+  else
+    min_silk_line = PCB->minWid;
+  DrawTextLowLevel (text, min_silk_line);
+  return 1;
+}
+
+static void
+DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon, const BoxType *drawn_area)
+{
+  static char *color;
+
+  if (!Polygon->Clipped)
+    return;
+
+  if (TEST_FLAG (SELECTEDFLAG, Polygon))
+    color = Layer->SelectedColor;
+  else if (TEST_FLAG (FOUNDFLAG, Polygon))
+    color = PCB->ConnectedColor;
+  else
+    color = Layer->Color;
+  gui->set_color (Output.fgGC, color);
+
+  if (gui->thindraw_pcb_polygon != NULL &&
+      (TEST_FLAG (THINDRAWFLAG, PCB) ||
+       TEST_FLAG (THINDRAWPOLYFLAG, PCB)))
+    gui->thindraw_pcb_polygon (Output.fgGC, Polygon, drawn_area);
+  else
+    gui->fill_pcb_polygon (Output.fgGC, Polygon, drawn_area);
+
+  /* If checking planes, thin-draw any pieces which have been clipped away */
+  if (gui->thindraw_pcb_polygon != NULL &&
+      TEST_FLAG (CHECKPLANESFLAG, PCB) &&
+      !TEST_FLAG (FULLPOLYFLAG, Polygon))
+    {
+      PolygonType poly = *Polygon;
+
+      for (poly.Clipped = Polygon->Clipped->f;
+           poly.Clipped != Polygon->Clipped;
+           poly.Clipped = poly.Clipped->f)
+        gui->thindraw_pcb_polygon (Output.fgGC, &poly, drawn_area);
+    }
+}
+
+struct poly_info
+{
+  LayerTypePtr Layer;
+  const BoxType *drawn_area;
+};
+
+static int
+poly_callback (const BoxType * b, void *cl)
+{
+  struct poly_info *i = (struct poly_info *) cl;
+
+  DrawPlainPolygon (i->Layer, (PolygonTypePtr) b, i->drawn_area);
+  return 1;
+}
+
+static int
+clearPin_callback (const BoxType * b, void *cl)
+{
+  PinType *pin = (PinTypePtr) b;
+  if (TEST_FLAG (THINDRAWFLAG, PCB) || TEST_FLAG (THINDRAWPOLYFLAG, PCB))
+    gui->thindraw_pcb_pv (Output.pmGC, Output.pmGC, pin, false, true);
+  else
+    gui->fill_pcb_pv (Output.pmGC, Output.pmGC, pin, false, true);
+  return 1;
+}
+
+static int
+clearPad_callback (const BoxType * b, void *cl)
+{
+  PadTypePtr pad = (PadTypePtr) b;
+  int *side = cl;
+  if (ON_SIDE (pad, *side) && pad->Mask)
+    _draw_pad (Output.pmGC, pad, true, true);
+  return 1;
+}
+
+static int
+clearPin_callback_solid (const BoxType * b, void *cl)
+{
+  PinTypePtr pin = (PinTypePtr) b;
+  gui->fill_pcb_pv (Output.pmGC, Output.pmGC, pin, false, true);
+  return 1;
+}
+
+static int
+clearPad_callback_solid (const BoxType * b, void *cl)
+{
+  PadTypePtr pad = (PadTypePtr) b;
+  int *side = cl;
+  if (ON_SIDE (pad, *side) && pad->Mask)
+    gui->fill_pcb_pad (Output.pmGC, pad, true, true);
+  return 1;
+}
+
+static void
+GhidDrawMask (int side, BoxType * screen)
+{
+  int thin = TEST_FLAG(THINDRAWFLAG, PCB) || TEST_FLAG(THINDRAWPOLYFLAG, PCB);
+
+  OutputType *out = &Output;
+
+  if (thin)
+    {
+      gui->set_line_width (Output.pmGC, 0);
+      gui->set_color (Output.pmGC, PCB->MaskColor);
+      r_search (PCB->Data->pin_tree, screen, NULL, clearPin_callback, NULL);
+      r_search (PCB->Data->via_tree, screen, NULL, clearPin_callback, NULL);
+      r_search (PCB->Data->pad_tree, screen, NULL, clearPad_callback, &side);
+      gui->set_color (Output.pmGC, "erase");
+    }
+
+  gui->use_mask (HID_MASK_CLEAR);
+  r_search (PCB->Data->pin_tree, screen, NULL, clearPin_callback_solid, NULL);
+  r_search (PCB->Data->via_tree, screen, NULL, clearPin_callback_solid, NULL);
+  r_search (PCB->Data->pad_tree, screen, NULL, clearPad_callback_solid, &side);
+
+  gui->use_mask (HID_MASK_AFTER);
+  gui->set_color (out->fgGC, PCB->MaskColor);
+  ghid_set_alpha_mult (out->fgGC, thin ? 0.35 : 1.0);
+  gui->fill_rect (out->fgGC, 0, 0, PCB->MaxWidth, PCB->MaxHeight);
+  ghid_set_alpha_mult (out->fgGC, 1.0);
+
+  gui->use_mask (HID_MASK_OFF);
+}
+
+static int
+GhidDrawLayerGroup (int group, const BoxType * screen)
+{
+  int i, rv = 1;
+  int layernum;
+  int side;
+  struct poly_info info;
+  LayerTypePtr Layer;
+  int n_entries = PCB->LayerGroups.Number[group];
+  Cardinal *layers = PCB->LayerGroups.Entries[group];
+  int first_run = 1;
+  int component_group = GetLayerGroupNumberByNumber (component_silk_layer);
+  int solder_group    = GetLayerGroupNumberByNumber (solder_silk_layer);
+
+  if (!gui->set_layer (0, group, 0))
+    return 0;
+
+  /* HACK: Subcomposite each layer in a layer group separately */
+  for (i = n_entries - 1; i >= 0; i--) {
+    layernum = layers[i];
+    Layer = PCB->Data->Layer + layers[i];
+
+    if (strcmp (Layer->Name, "outline") == 0 ||
+        strcmp (Layer->Name, "route") == 0)
+      rv = 0;
+
+    if (layernum < max_copper_layer /*&& Layer->On*/) {
+
+      if (!first_run)
+        gui->set_layer (0, group, 0);
+
+      first_run = 0;
+
+      if (rv && !TEST_FLAG (THINDRAWFLAG, PCB)) {
+        /* Mask out drilled holes on this layer */
+        hidgl_flush_triangles (&buffer);
+        glPushAttrib (GL_COLOR_BUFFER_BIT);
+        glColorMask (0, 0, 0, 0);
+        gui->set_color (Output.bgGC, PCB->MaskColor);
+        if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
+        if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
+        hidgl_flush_triangles (&buffer);
+        glPopAttrib ();
+      }
+
+      /* draw all polygons on this layer */
+      if (Layer->PolygonN) {
+        info.Layer = Layer;
+        info.drawn_area = screen;
+        r_search (Layer->polygon_tree, screen, NULL, poly_callback, &info);
+
+        /* HACK: Subcomposite polygons separately from other layer primitives */
+        /* Reset the compositing */
+        gui->end_layer ();
+        gui->set_layer (0, group, 0);
+
+        if (rv && !TEST_FLAG (THINDRAWFLAG, PCB)) {
+          hidgl_flush_triangles (&buffer);
+          glPushAttrib (GL_COLOR_BUFFER_BIT);
+          glColorMask (0, 0, 0, 0);
+          /* Mask out drilled holes on this layer */
+          if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, hole_callback, NULL);
+          if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, hole_callback, NULL);
+          hidgl_flush_triangles (&buffer);
+          glPopAttrib ();
+        }
+      }
+
+      /* Draw pins, vias and pads on this layer */
+      if (!global_view_2d && rv) {
+        if (PCB->PinOn) r_search (PCB->Data->pin_tree, screen, NULL, pin_inlayer_callback, Layer);
+        if (PCB->ViaOn) r_search (PCB->Data->via_tree, screen, NULL, via_inlayer_callback, Layer);
+        if (PCB->PinOn && group == component_group)
+          {
+            side = COMPONENT_LAYER;
+            r_search (PCB->Data->pad_tree, screen, NULL, pad_callback, &side);
+          }
+        if (PCB->PinOn && group == solder_group)
+          {
+            side = SOLDER_LAYER;
+            r_search (PCB->Data->pad_tree, screen, NULL, pad_callback, &side);
+          }
+      }
+
+      if (TEST_FLAG (CHECKPLANESFLAG, PCB))
+        continue;
+
+      r_search (Layer->line_tree, screen, NULL, line_callback, Layer);
+      r_search (Layer->arc_tree, screen, NULL, arc_callback, Layer);
+      r_search (Layer->text_tree, screen, NULL, text_callback, Layer);
+    }
+  }
+
+  gui->end_layer ();
+
+  return (n_entries > 1);
+}
+
+static void
+DrawDrillChannel (int vx, int vy, int vr, int from_layer, int to_layer, double scale)
+{
+#define PIXELS_PER_CIRCLINE 5.
+#define MIN_FACES_PER_CYL 6
+#define MAX_FACES_PER_CYL 360
+  float radius = vr;
+  float x1, y1;
+  float x2, y2;
+  float z1, z2;
+  int i;
+  int slices;
+
+  slices = M_PI * 2 * vr / scale / PIXELS_PER_CIRCLINE;
+
+  if (slices < MIN_FACES_PER_CYL)
+    slices = MIN_FACES_PER_CYL;
+
+  if (slices > MAX_FACES_PER_CYL)
+    slices = MAX_FACES_PER_CYL;
+
+  z1 = compute_depth (from_layer);
+  z2 = compute_depth (to_layer);
+
+  x1 = vx + vr;
+  y1 = vy;
+
+  hidgl_ensure_triangle_space (&buffer, 2 * slices);
+  for (i = 0; i < slices; i++)
+    {
+      x2 = radius * cosf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vx;
+      y2 = radius * sinf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vy;
+      hidgl_add_triangle_3D (&buffer, x1, y1, z1,  x2, y2, z1,  x1, y1, z2);
+      hidgl_add_triangle_3D (&buffer, x2, y2, z1,  x1, y1, z2,  x2, y2, z2);
+      x1 = x2;
+      y1 = y2;
+    }
+}
+
+struct cyl_info {
+  int from_layer;
+  int to_layer;
+  double scale;
+};
+
+static int
+draw_hole_cyl (PinType *Pin, struct cyl_info *info, int Type)
+{
+  char *color;
+
+  if (TEST_FLAG (WARNFLAG, Pin))
+    color = PCB->WarnColor;
+  else if (TEST_FLAG (SELECTEDFLAG, Pin))
+    color = (Type == VIA_TYPE) ? PCB->ViaSelectedColor : PCB->PinSelectedColor;
+  else if (TEST_FLAG (FOUNDFLAG, Pin))
+    color = PCB->ConnectedColor;
+  else
+    color = "drill";
+
+  gui->set_color (Output.fgGC, color);
+  DrawDrillChannel (Pin->X, Pin->Y, Pin->DrillingHole / 2, info->from_layer, info->to_layer, info->scale);
+  return 0;
+}
+
+static int
+pin_hole_cyl_callback (const BoxType * b, void *cl)
+{
+  return draw_hole_cyl ((PinType *)b, (struct cyl_info *)cl, PIN_TYPE);
+}
+
+static int
+via_hole_cyl_callback (const BoxType * b, void *cl)
+{
+  return draw_hole_cyl ((PinType *)b, (struct cyl_info *)cl, VIA_TYPE);
+}
+
+void
+ghid_draw_everything (BoxTypePtr drawn_area)
+{
+  render_priv *priv = gport->render_priv;
+  int i, ngroups;
+  int side;
+  /* This is the list of layer groups we will draw.  */
+  int do_group[MAX_LAYER];
+  /* This is the reverse of the order in which we draw them.  */
+  int drawn_groups[MAX_LAYER];
+  struct cyl_info cyl_info;
+  int reverse_layers;
+  int save_show_solder;
+  int solder_group;
+  int component_group;
+  int min_phys_group;
+  int max_phys_group;
+
+  priv->current_colorname = NULL;
+
+  /* Test direction of rendering */
+  /* Look at sign of eye coordinate system z-coord when projecting a
+     world vector along +ve Z axis, (0, 0, 1). */
+  /* XXX: This isn't strictly correct, as I've ignored the matrix
+          elements for homogeneous coordinates. */
+  /* NB: last_modelview_matrix is transposed in memory! */
+  reverse_layers = (last_modelview_matrix[2][2] < 0);
+
+  save_show_solder = Settings.ShowSolderSide;
+  Settings.ShowSolderSide = reverse_layers;
+
+  PCB->Data->SILKLAYER.Color = PCB->ElementColor;
+  PCB->Data->BACKSILKLAYER.Color = PCB->InvisibleObjectsColor;
+
+  solder_group = GetLayerGroupNumberByNumber (solder_silk_layer);
+  component_group = GetLayerGroupNumberByNumber (component_silk_layer);
+
+  min_phys_group = MIN (solder_group, component_group);
+  max_phys_group = MAX (solder_group, component_group);
+
+  memset (do_group, 0, sizeof (do_group));
+  if (global_view_2d) {
+    /* Draw in layer stack order when in 2D view */
+    for (ngroups = 0, i = 0; i < max_copper_layer; i++) {
+      int group = GetLayerGroupNumberByNumber (LayerStack[i]);
+
+      if (!do_group[group]) {
+        do_group[group] = 1;
+        drawn_groups[ngroups++] = group;
+      }
+    }
+  } else {
+    /* Draw in group order when in 3D view */
+    for (ngroups = 0, i = 0; i < max_group; i++) {
+      int group = reverse_layers ? max_group - 1 - i : i;
+
+      if (!do_group[group]) {
+        do_group[group] = 1;
+        drawn_groups[ngroups++] = group;
+      }
+    }
+  }
+
+  /*
+   * first draw all 'invisible' stuff
+   */
+  side = SWAP_IDENT ? COMPONENT_LAYER : SOLDER_LAYER;
+
+  if (!TEST_FLAG (CHECKPLANESFLAG, PCB) &&
+      gui->set_layer ("invisible", SL (INVISIBLE, 0), 0)) {
+    DrawSilk (side, drawn_area);
+
+    if (global_view_2d)
+      r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, &side);
+
+    gui->end_layer ();
+
+    /* Draw the reverse-side solder mask if turned on */
+    if (!global_view_2d &&
+        gui->set_layer (SWAP_IDENT ? "componentmask" : "soldermask",
+                        SWAP_IDENT ? SL (MASK, TOP) : SL (MASK, BOTTOM), 0)) {
+        GhidDrawMask (side, drawn_area);
+        gui->end_layer ();
+      }
+  }
+
+  /* draw all layers in layerstack order */
+  for (i = ngroups - 1; i >= 0; i--) {
+    GhidDrawLayerGroup (drawn_groups [i], drawn_area);
+
+#if 1
+    if (!global_view_2d && i > 0 &&
+        drawn_groups[i] >= min_phys_group &&
+        drawn_groups[i] <= max_phys_group &&
+        drawn_groups[i - 1] >= min_phys_group &&
+        drawn_groups[i - 1] <= max_phys_group) {
+      cyl_info.from_layer = drawn_groups[i];
+      cyl_info.to_layer = drawn_groups[i - 1];
+      cyl_info.scale = gport->view.coord_per_px;
+      gui->set_color (Output.fgGC, "drill");
+      ghid_set_alpha_mult (Output.fgGC, 0.75);
+      if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_hole_cyl_callback, &cyl_info);
+      if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, via_hole_cyl_callback, &cyl_info);
+      ghid_set_alpha_mult (Output.fgGC, 1.0);
+    }
+#endif
+  }
+
+  if (TEST_FLAG (CHECKPLANESFLAG, PCB))
+    return;
+
+  side = SWAP_IDENT ? SOLDER_LAYER : COMPONENT_LAYER;
+
+  /* Draw pins, pads, vias below silk */
+  if (global_view_2d) {
+    gui->set_layer (NULL, SWAP_IDENT ? solder_group : component_group, 0);
+
+    if (!TEST_FLAG (THINDRAWFLAG, PCB)) {
+      /* Mask out drilled holes */
+      hidgl_flush_triangles (&buffer);
+      glPushAttrib (GL_COLOR_BUFFER_BIT);
+      glColorMask (0, 0, 0, 0);
+      if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, hole_callback, NULL);
+      if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, hole_callback, NULL);
+      hidgl_flush_triangles (&buffer);
+      glPopAttrib ();
+    }
+
+    if (PCB->PinOn) r_search (PCB->Data->pad_tree, drawn_area, NULL, pad_callback, &side);
+    if (PCB->PinOn) r_search (PCB->Data->pin_tree, drawn_area, NULL, pin_callback, NULL);
+    if (PCB->ViaOn) r_search (PCB->Data->via_tree, drawn_area, NULL, via_callback, NULL);
+
+    gui->end_layer ();
+  }
+
+  /* Draw the solder mask if turned on */
+  if (gui->set_layer (SWAP_IDENT ? "soldermask" : "componentmask",
+                      SWAP_IDENT ? SL (MASK, BOTTOM) : SL (MASK, TOP), 0)) {
+    GhidDrawMask (side, drawn_area);
+    gui->end_layer ();
+  }
+
+  if (gui->set_layer (SWAP_IDENT ? "bottomsilk" : "topsilk",
+                      SWAP_IDENT ? SL (SILK, BOTTOM) : SL (SILK, TOP), 0)) {
+      DrawSilk (side, drawn_area);
+      gui->end_layer ();
+  }
+
+  /* Draw element Marks */
+  if (PCB->PinOn)
+    r_search (PCB->Data->element_tree, drawn_area, NULL, EMark_callback, NULL);
+
+  /* Draw rat lines on top */
+  if (PCB->RatOn && gui->set_layer ("rats", SL (RATS, 0), 0)) {
+    DrawRats(drawn_area);
+    gui->end_layer ();
+  }
+
+  Settings.ShowSolderSide = save_show_solder;
+}
+
 #define Z_NEAR 3.0
 gboolean
 ghid_drawing_area_expose_cb (GtkWidget *widget,
@@ -1063,8 +1924,8 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glStencilFunc (GL_ALWAYS, 0, 0);
 
   /* Test the 8 corners of a cube spanning the event */
-  min_depth = -50; /* FIXME */
-  max_depth =  0;  /* FIXME */
+  min_depth = -50 + compute_depth (0);                    /* FIXME: NEED TO USE PHYSICAL GROUPS */
+  max_depth =  50 + compute_depth (max_copper_layer - 1); /* FIXME: NEED TO USE PHYSICAL GROUPS */
 
   ghid_unproject_to_z_plane (ev->area.x,
                              ev->area.y,
@@ -1130,18 +1991,50 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
              port->bg_color.green / 65535.,
              port->bg_color.blue / 65535.);
 
-  glBegin (GL_QUADS);
-  glVertex3i (0,             0,              -50);
-  glVertex3i (PCB->MaxWidth, 0,              -50);
-  glVertex3i (PCB->MaxWidth, PCB->MaxHeight, -50);
-  glVertex3i (0,             PCB->MaxHeight, -50);
-  glEnd ();
+  hidgl_init_triangle_array (&buffer);
+  ghid_invalidate_current_gc ();
+
+  /* Setup stenciling */
+  /* Drawing operations set the stencil buffer to '1' */
+  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); /* Stencil pass => replace stencil value (with 1) */
+  /* Drawing operations as masked to areas where the stencil buffer is '0' */
+  /* glStencilFunc (GL_GREATER, 1, 1); */           /* Draw only where stencil buffer is 0 */
+
+  if (global_view_2d) {
+    glBegin (GL_QUADS);
+    glVertex3i (0,             0,              0);
+    glVertex3i (PCB->MaxWidth, 0,              0);
+    glVertex3i (PCB->MaxWidth, PCB->MaxHeight, 0);
+    glVertex3i (0,             PCB->MaxHeight, 0);
+    glEnd ();
+  } else {
+    int solder_group;
+    int component_group;
+    int min_phys_group;
+    int max_phys_group;
+    int i;
+
+    solder_group = GetLayerGroupNumberByNumber (solder_silk_layer);
+    component_group = GetLayerGroupNumberByNumber (component_silk_layer);
+
+    min_phys_group = MIN (solder_group, component_group);
+    max_phys_group = MAX (solder_group, component_group);
+
+    glBegin (GL_QUADS);
+    for (i = min_phys_group; i <= max_phys_group; i++) {
+      int depth = compute_depth (i);
+      glVertex3i (0,             0,              depth);
+      glVertex3i (PCB->MaxWidth, 0,              depth);
+      glVertex3i (PCB->MaxWidth, PCB->MaxHeight, depth);
+      glVertex3i (0,             PCB->MaxHeight, depth);
+    }
+    glEnd ();
+  }
 
   ghid_draw_bg_image ();
 
-  hidgl_init_triangle_array (&buffer);
-  ghid_invalidate_current_gc ();
-  hid_expose_callback (&ghid_hid, &region, 0);
+  /* hid_expose_callback (&ghid_hid, &region, 0); */
+  ghid_draw_everything (&region);
   hidgl_flush_triangles (&buffer);
 
   /* Set the current depth to the right value for the layer we are editing */

Bottom: d490b61853c8dd2ac03f2a3ee29c558dc2f591bd
Top:    7c0ffc76b155f21648ceb9edc620cb14de86e557
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2014-06-29 20:15:31 +0100

Tag the from vertex with the circular information, not the to vertex.

This fits more closely with the other data tagged against these structures,
so avoids the need to mess too much with gather / jump.


---

diff --git a/src/hid/common/draw_helpers.c b/src/hid/common/draw_helpers.c
index 4343e82..12d0541 100644
--- a/src/hid/common/draw_helpers.c
+++ b/src/hid/common/draw_helpers.c
@@ -173,18 +173,18 @@ thindraw_contour (hidGC gc, PLINE *pl)
       this_x = v->point[0];
       this_y = v->point[1];
 
-      if (v->is_round)
+      if (v->prev->is_round)
         {
           Angle start_angle, end_angle, delta_angle;
 
-          start_angle = 180. - TO_DEGREES (atan2 ((v->prev->point[1] - v->cy), (v->prev->point[0] - v->cx)));
-          end_angle   = 180. - TO_DEGREES (atan2 ((      v->point[1] - v->cy), (      v->point[0] - v->cx)));
+          start_angle = 180. - TO_DEGREES (atan2 ((v->prev->point[1] - v->prev->cy), (v->prev->point[0] - v->prev->cx)));
+          end_angle   = 180. - TO_DEGREES (atan2 ((      v->point[1] - v->prev->cy), (      v->point[0] - v->prev->cx)));
           delta_angle = end_angle - start_angle;
 
           if (delta_angle > 180.) delta_angle -= 360.;
           if (delta_angle < -180.) delta_angle += 360.;
 
-          gui->graphics->draw_arc (gc, v->cx, v->cy, v->radius, v->radius, start_angle, delta_angle);
+          gui->graphics->draw_arc (gc, v->prev->cx, v->prev->cy, v->prev->radius, v->prev->radius, start_angle, delta_angle);
 
           /* Fill the head vertex */
           if (v == &pl->head)
diff --git a/src/polygon.c b/src/polygon.c
index 87470b5..efbd051 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -290,6 +290,7 @@ degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Vector v /* First po
   double radius = sqrt ((v[0] - X) * (v[0] - X) + (v[1] - Y) * (v[1] - Y));
 
 //  poly_InclVertex (c->head.prev, poly_CreateNode (v));
+  poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
 
   /* move vector to origin */
   e1 = (v[0] - X) * POLY_CIRC_RADIUS_ADJ;
@@ -299,7 +300,7 @@ degree_circle (PLINE * c, Coord X, Coord Y /* <- Center */, Vector v /* First po
     {
       /* NB: the caller added the first vertex, and will add the last vertex, hence the -1 */
       range = POLY_CIRC_SEGS * sweep / 360 - 1;
-      for (i = 0; i < range; i++)
+      for (i = 0; i < range - 1; i++)
         {
           /* rotate the vector */
           t1 = rotate_circle_seg[0] * e1 + rotate_circle_seg[1] * e2;
@@ -541,14 +542,14 @@ frac_circle (PLINE * c, Coord X, Coord Y, Vector v, int fraction)
   /* XXX: Circle already has the first node added */
 //  if (fraction > 1)
 //    poly_InclVertex (c->head.prev, poly_CreateNode (v));
-//    poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
+  poly_InclVertex (c->head.prev, poly_CreateNodeArcApproximation (v, X, Y, radius));
   /* move vector to origin */
   e1 = (v[0] - X) * POLY_CIRC_RADIUS_ADJ;
   e2 = (v[1] - Y) * POLY_CIRC_RADIUS_ADJ;
 
   /* XXX */ /* NB: the caller adds the last vertex, hence the -1 */
   range = POLY_CIRC_SEGS / fraction;
-  for (i = 0; i < range; i++)
+  for (i = 0; i < range - 1; i++)
     {
       /* rotate the vector */
       t1 = rotate_circle_seg[0] * e1 + rotate_circle_seg[1] * e2;
@@ -753,34 +754,34 @@ LinePoly (LineType * L, Coord thick)
       l->Point2.Y -= dx;
     }
 
+  v[0] = l->Point1.X - dx;
+  v[1] = l->Point1.Y - dy;
+  if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
+    return 0;
 
   v[0] = l->Point2.X - dx;
   v[1] = l->Point2.Y - dy;
-  if ((contour = poly_NewContour (poly_CreateNode (v))) == NULL)
-    return 0;
 
   if (TEST_FLAG (SQUAREFLAG,l))
-    {
-      v[0] = l->Point2.X + dx;
-      v[1] = l->Point2.Y + dy;
-      poly_InclVertex (contour->head.prev, poly_CreateNode (v));
-    }
+    poly_InclVertex (contour->head.prev, poly_CreateNode (v));
   else
     frac_circle (contour, l->Point2.X, l->Point2.Y, v, 2);
 
+  v[0] = l->Point2.X + dx;
+  v[1] = l->Point2.Y + dy;
+  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
+
   v[0] = l->Point1.X + dx;
   v[1] = l->Point1.Y + dy;
-  poly_InclVertex (contour->head.prev, poly_CreateNode (v));
 
   if (TEST_FLAG (SQUAREFLAG,l))
-    {
-      v[0] = l->Point1.X - dx;
-      v[1] = l->Point1.Y - dy;
-      poly_InclVertex (contour->head.prev, poly_CreateNode (v));
-    }
+    poly_InclVertex (contour->head.prev, poly_CreateNode (v));
   else
     frac_circle (contour, l->Point1.X, l->Point1.Y, v, 2);
 
+//  v[0] = l->Point1.X - dx;
+//  v[1] = l->Point1.Y - dy;
+
   /* now we have the line contour */
   if (!(np = ContourToPoly (contour)))
     return NULL;
diff --git a/src/polygon1.c b/src/polygon1.c
index 694a161..cce3302 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -914,8 +914,8 @@ intersect_impl (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
       insert_node_task *next = task->next;
 
       /* XXX: If a node was inserted due to an intersection, don't assume we're on the a round contour any more */
-//      task->node_seg->v->is_round = false;
-      task->node_seg->v->next->is_round = false;
+      task->node_seg->v->is_round = false;
+//      task->node_seg->v->next->is_round = false;
 
       /* Do insersion */
       task->new_node->prev = task->node_seg->v;
@@ -1657,19 +1657,16 @@ Gather (VNODE * start, PLINE ** result, J_Rule v_rule, DIRECTION initdir)
   assert (*result == NULL);
   do
     {
-      VNODE *jump_cur_temp;
-      DIRECTION jump_dir_temp;
-
-      jump_cur_temp = cur;
-      jump_dir_temp = dir;
+#if 0
+      VNODE *jump_cur_temp = cur;
+      DIRECTION jump_dir_temp = dir;
 
-#if 1
       /* see where to go next */
       if (!jump (&jump_cur_temp, &jump_dir_temp, v_rule))
 	break;
 #endif
 
-#if 0
+#if 1
       /* see where to go next */
       if (!jump (&cur, &dir, v_rule))
 	break;
@@ -1695,7 +1692,7 @@ Gather (VNODE * start, PLINE ** result, J_Rule v_rule, DIRECTION initdir)
 #ifdef DEBUG_GATHER
       DEBUGP ("gather vertex at %mm, %mm, Dir=%i\n", cur->point[0], cur->point[1], dir);
 #endif
-#if 1
+#if 0
       cur = jump_cur_temp;
       dir = jump_dir_temp;
 #endif

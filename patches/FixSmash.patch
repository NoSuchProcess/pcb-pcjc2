Bottom: 9fa5f34eb56abc934a4e38545687fa773c0fadc5
Top:    dc32ff99131de5431b04110b924f7a2e24730430
Author: Stephen Ecob <silicon.on.inspiration@gmail.com>
Date:   2010-12-09 09:32:28 +1100

Fix SmashBufferElement(), broken by fixing a memory leak in FreeDataMemory()

Commit 466b0183758ef3ca44623c43de60a233b175d2ad broke SmashBufferElement()
by changing FreeDataMemory() (which SmashBufferElement() calls via
ClearBuffer()).  SmashBufferElement() depended on the memory leak of
Data->Element in FreeDataMemory().

This patch removes the dependence on the leak.

Commit-message-reformatted-by: Peter Clifton <pcjc2@cam.ac.uk>


---

diff --git a/src/buffer.c b/src/buffer.c
index 1b2d27c..bec918f 100644
--- a/src/buffer.c
+++ b/src/buffer.c
@@ -933,7 +933,17 @@ SmashBufferElement (BufferTypePtr Buffer)
       Message (_("Error!  Buffer doesn't contain a single element\n"));
       return (false);
     }
+  /*
+   * At this point the buffer should contain just a single element.
+   * Now we detach the single element from the buffer and then clear the
+   * buffer, ready to receive the smashed elements.  As a result of detaching
+   * it the single element is orphaned from the buffer and thus will not be
+   * free()'d by FreeDataMemory (called via ClearBuffer).  This leaves it
+   * around for us to smash bits off it.  It then becomes our responsibility,
+   * however, to free the single element when we're finished with it.
+   */
   element = &Buffer->Data->Element[0];
+  Buffer->Data->Element = NULL;
   Buffer->Data->ElementN = 0;
   ClearBuffer (Buffer);
   ELEMENTLINE_LOOP (element);

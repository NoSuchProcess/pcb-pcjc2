Bottom: eefa43641cda28f17197c794311125103b11ff0a
Top:    d68ad2ed8140164da5d0c7f8a2cd210d4d0c65af
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2012-01-20 19:31:28 +0000

Fiddle with line snapping


---

diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index f3133ec..71754a5 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -68,7 +68,6 @@ typedef struct hid_gc_struct
   double alpha_mult;
   Coord width;
   gint cap, join;
-  gchar xor;
 }
 hid_gc_struct;
 
@@ -356,8 +355,6 @@ typedef struct
 {
   int color_set;
   GdkColor color;
-  int xor_set;
-  GdkColor xor_color;
   double red;
   double green;
   double blue;
@@ -420,20 +417,6 @@ set_gl_color_for_gc (hidGC gc)
           cc->blue  = cc->color.blue  / 65535.;
           cc->color_set = 1;
         }
-      if (gc->xor)
-        {
-          if (!cc->xor_set)
-            {
-              cc->xor_color.red = cc->color.red ^ gport->bg_color.red;
-              cc->xor_color.green = cc->color.green ^ gport->bg_color.green;
-              cc->xor_color.blue = cc->color.blue ^ gport->bg_color.blue;
-              gdk_color_alloc (gport->colormap, &cc->xor_color);
-              cc->red   = cc->color.red   / 65535.;
-              cc->green = cc->color.green / 65535.;
-              cc->blue  = cc->color.blue  / 65535.;
-              cc->xor_set = 1;
-            }
-        }
       r = cc->red;
       g = cc->green;
       b = cc->blue;
@@ -488,16 +471,6 @@ ghid_set_line_width (hidGC gc, Coord width)
   gc->width = width;
 }
 
-
-void
-ghid_set_draw_xor (hidGC gc, int xor)
-{
-  /* NOT IMPLEMENTED */
-
-  /* Only presently called when setting up a crosshair GC.
-   * We manage our own drawing model for that anyway. */
-}
-
 void
 ghid_set_draw_faded (hidGC gc, int faded)
 {
diff --git a/src/line.c b/src/line.c
index 8898238..47e3125 100644
--- a/src/line.c
+++ b/src/line.c
@@ -82,16 +82,16 @@ AdjustAttachedLine (void)
  *
  * directions:
  *
- *           0
- *          7 1
- *         6   2
- *          5 3
  *           4
+ *          5 3
+ *         6   2
+ *          7 1
+ *           0
  */
 void
 FortyFiveLine (AttachedLineType *Line)
 {
-  Coord dx, dy, min;
+  Coord dx, dy, min, max;
   unsigned direction = 0;
   double m;
 
@@ -99,22 +99,20 @@ FortyFiveLine (AttachedLineType *Line)
   dx = Crosshair.X - Line->Point1.X;
   dy = Crosshair.Y - Line->Point1.Y;
 
-  if (!dx)
-    {
-      if (!dy)
-	/* zero length line, don't draw anything */
-	return;
-      else
-	direction = dy > 0 ? 0 : 4;
-    }
+  /* zero length line, don't draw anything */
+  if (dx == 0 && dy == 0)
+    return;
+
+  if (dx == 0)
+    direction = dy > 0 ? 0 : 4;
   else
     {
-      m = (double) dy / dx;
+      m = (double)dy / (double)dx;
       direction = 2;
       if (m > TAN_30_DEGREE)
-	direction = m > TAN_60_DEGREE ? 0 : 1;
+        direction = m > TAN_60_DEGREE ? 0 : 1;
       else if (m < -TAN_30_DEGREE)
-	direction = m < -TAN_60_DEGREE ? 0 : 3;
+        direction = m < -TAN_60_DEGREE ? 4 : 3;
     }
   if (dx < 0)
     direction += 4;
@@ -122,19 +120,28 @@ FortyFiveLine (AttachedLineType *Line)
   dx = abs (dx);
   dy = abs (dy);
   min = MIN (dx, dy);
+  max = MAX (dx, dy);
 
   /* now set up the second pair of coordinates */
   switch (direction)
     {
     case 0:
+      Line->Point2.X = Line->Point1.X;
+      Line->Point2.Y = Line->Point1.Y + max;
+      break;
+
     case 4:
       Line->Point2.X = Line->Point1.X;
-      Line->Point2.Y = Crosshair.Y;
+      Line->Point2.Y = Line->Point1.Y - max;
       break;
 
     case 2:
+      Line->Point2.X = Line->Point1.X + max;
+      Line->Point2.Y = Line->Point1.Y;
+      break;
+
     case 6:
-      Line->Point2.X = Crosshair.X;
+      Line->Point2.X = Line->Point1.X - max;
       Line->Point2.Y = Line->Point1.Y;
       break;
 
@@ -500,24 +507,14 @@ EnforceLineDRC (void)
   if (XOR (r1 > r2, shift))
     {
       if (PCB->Clipping)
-	{
-	  if (shift)
-	    PCB->Clipping = 2;
-	  else
-	    PCB->Clipping = 1;
-	}
+	PCB->Clipping = shift ? 2 : 1;
       Crosshair.X = rs.X;
       Crosshair.Y = rs.Y;
     }
   else
     {
       if (PCB->Clipping)
-	{
-	  if (shift)
-	    PCB->Clipping = 1;
-	  else
-	    PCB->Clipping = 2;
-	}
+	PCB->Clipping = shift ? 1 : 2;
       Crosshair.X = r45.X;
       Crosshair.Y = r45.Y;
     }

Bottom: 7ce4b43ed17a0d66c4208c1e0246058e33376e9a
Top:    4a5a236cf06f393af533de7f7a186580166de7d9
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2009-11-03 22:03:04 +0000

Tmp


---

diff --git a/src/cairo/cairo-bentley-ottmann.c b/src/cairo/cairo-bentley-ottmann.c
index 71997c7..ee68cda 100644
--- a/src/cairo/cairo-bentley-ottmann.c
+++ b/src/cairo/cairo-bentley-ottmann.c
@@ -57,16 +57,6 @@
 
 typedef cairo_point_t cairo_bo_point32_t;
 
-typedef struct _cairo_bo_intersect_ordinate {
-    int32_t ordinate;
-    enum { EXACT, INEXACT } exactness;
-} cairo_bo_intersect_ordinate_t;
-
-typedef struct _cairo_bo_intersect_point {
-    cairo_bo_intersect_ordinate_t x;
-    cairo_bo_intersect_ordinate_t y;
-} cairo_bo_intersect_point_t;
-
 typedef struct _cairo_bo_edge cairo_bo_edge_t;
 typedef struct _cairo_bo_trap cairo_bo_trap_t;
 
@@ -92,7 +82,6 @@ struct _cairo_bo_edge {
 
 typedef enum {
     CAIRO_BO_EVENT_TYPE_STOP,
-    CAIRO_BO_EVENT_TYPE_INTERSECTION,
     CAIRO_BO_EVENT_TYPE_START
 } cairo_bo_event_type_t;
 
@@ -134,75 +123,6 @@ typedef struct _cairo_bo_sweep_line {
     cairo_bo_edge_t *current_edge;
 } cairo_bo_sweep_line_t;
 
-#if DEBUG_TRAPS
-static void
-dump_traps (cairo_traps_t *traps, const char *filename)
-{
-    FILE *file;
-    int n;
-
-    if (getenv ("CAIRO_DEBUG_TRAPS") == NULL)
-        return;
-
-    if (traps->has_limits) {
-        printf ("%s: limits=(%d, %d, %d, %d)\n",
-                filename,
-                traps->limits.p1.x, traps->limits.p1.y,
-                traps->limits.p2.x, traps->limits.p2.y);
-    }
-    printf ("%s: extents=(%d, %d, %d, %d)\n",
-            filename,
-            traps->extents.p1.x, traps->extents.p1.y,
-            traps->extents.p2.x, traps->extents.p2.y);
-
-    file = fopen (filename, "a");
-    if (file != NULL) {
-        for (n = 0; n < traps->num_traps; n++) {
-            fprintf (file, "%d %d L:(%d, %d), (%d, %d) R:(%d, %d), (%d, %d)\n",
-                     traps->traps[n].top,
-                     traps->traps[n].bottom,
-                     traps->traps[n].left.p1.x,
-                     traps->traps[n].left.p1.y,
-                     traps->traps[n].left.p2.x,
-                     traps->traps[n].left.p2.y,
-                     traps->traps[n].right.p1.x,
-                     traps->traps[n].right.p1.y,
-                     traps->traps[n].right.p2.x,
-                     traps->traps[n].right.p2.y);
-        }
-        fprintf (file, "\n");
-        fclose (file);
-    }
-}
-
-static void
-dump_edges (cairo_bo_start_event_t *events,
-            int num_edges,
-            const char *filename)
-{
-    FILE *file;
-    int n;
-
-    if (getenv ("CAIRO_DEBUG_TRAPS") == NULL)
-        return;
-
-    file = fopen (filename, "a");
-    if (file != NULL) {
-        for (n = 0; n < num_edges; n++) {
-            fprintf (file, "(%d, %d), (%d, %d) %d %d %d\n",
-                     events[n].edge.edge.line.p1.x,
-                     events[n].edge.edge.line.p1.y,
-                     events[n].edge.edge.line.p2.x,
-                     events[n].edge.edge.line.p2.y,
-                     events[n].edge.edge.top,
-                     events[n].edge.edge.bottom,
-                     events[n].edge.edge.dir);
-        }
-        fprintf (file, "\n");
-        fclose (file);
-    }
-}
-#endif
 
 static cairo_fixed_t
 _line_compute_intersection_x_for_y (const cairo_line_t *line,
@@ -610,262 +530,6 @@ det64x32_128 (cairo_int64_t a, int32_t       b,
                               _cairo_int64x32_128_mul (c, b));
 }
 
-/* Compute the intersection of two lines as defined by two edges. The
- * result is provided as a coordinate pair of 128-bit integers.
- *
- * Returns %CAIRO_BO_STATUS_INTERSECTION if there is an intersection or
- * %CAIRO_BO_STATUS_PARALLEL if the two lines are exactly parallel.
- */
-static cairo_bool_t
-intersect_lines (cairo_bo_edge_t                *a,
-                 cairo_bo_edge_t                *b,
-                 cairo_bo_intersect_point_t        *intersection)
-{
-    cairo_int64_t a_det, b_det;
-
-    /* XXX: We're assuming here that dx and dy will still fit in 32
-     * bits. That's not true in general as there could be overflow. We
-     * should prevent that before the tessellation algorithm begins.
-     * What we're doing to mitigate this is to perform clamping in
-     * cairo_bo_tessellate_polygon().
-     */
-    int32_t dx1 = a->edge.line.p1.x - a->edge.line.p2.x;
-    int32_t dy1 = a->edge.line.p1.y - a->edge.line.p2.y;
-
-    int32_t dx2 = b->edge.line.p1.x - b->edge.line.p2.x;
-    int32_t dy2 = b->edge.line.p1.y - b->edge.line.p2.y;
-
-    cairo_int64_t den_det;
-    cairo_int64_t R;
-    cairo_quorem64_t qr;
-
-    den_det = det32_64 (dx1, dy1, dx2, dy2);
-
-     /* Q: Can we determine that the lines do not intersect (within range)
-      * much more cheaply than computing the intersection point i.e. by
-      * avoiding the division?
-      *
-      *   X = ax + t * adx = bx + s * bdx;
-      *   Y = ay + t * ady = by + s * bdy;
-      *   âˆ´ t * (ady*bdx - bdy*adx) = bdx * (by - ay) + bdy * (ax - bx)
-      *   => t * L = R
-      *
-      * Therefore we can reject any intersection (under the criteria for
-      * valid intersection events) if:
-      *   L^R < 0 => t < 0, or
-      *   L<R => t > 1
-      *
-      * (where top/bottom must at least extend to the line endpoints).
-      *
-      * A similar substitution can be performed for s, yielding:
-      *   s * (ady*bdx - bdy*adx) = ady * (ax - bx) - adx * (ay - by)
-      */
-    R = det32_64 (dx2, dy2,
-                  b->edge.line.p1.x - a->edge.line.p1.x,
-                  b->edge.line.p1.y - a->edge.line.p1.y);
-    if (_cairo_int64_negative (den_det)) {
-        if (_cairo_int64_ge (den_det, R))
-            return FALSE;
-    } else {
-        if (_cairo_int64_le (den_det, R))
-            return FALSE;
-    }
-
-    R = det32_64 (dy1, dx1,
-                  a->edge.line.p1.y - b->edge.line.p1.y,
-                  a->edge.line.p1.x - b->edge.line.p1.x);
-    if (_cairo_int64_negative (den_det)) {
-        if (_cairo_int64_ge (den_det, R))
-            return FALSE;
-    } else {
-        if (_cairo_int64_le (den_det, R))
-            return FALSE;
-    }
-
-    /* We now know that the two lines should intersect within range. */
-
-    a_det = det32_64 (a->edge.line.p1.x, a->edge.line.p1.y,
-                      a->edge.line.p2.x, a->edge.line.p2.y);
-    b_det = det32_64 (b->edge.line.p1.x, b->edge.line.p1.y,
-                      b->edge.line.p2.x, b->edge.line.p2.y);
-
-    /* x = det (a_det, dx1, b_det, dx2) / den_det */
-    qr = _cairo_int_96by64_32x64_divrem (det64x32_128 (a_det, dx1,
-                                                       b_det, dx2),
-                                         den_det);
-    if (_cairo_int64_eq (qr.rem, den_det))
-        return FALSE;
-#if 0
-    intersection->x.exactness = _cairo_int64_is_zero (qr.rem) ? EXACT : INEXACT;
-#else
-    intersection->x.exactness = EXACT;
-    if (! _cairo_int64_is_zero (qr.rem)) {
-        if (_cairo_int64_negative (den_det) ^ _cairo_int64_negative (qr.rem))
-            qr.rem = _cairo_int64_negate (qr.rem);
-        qr.rem = _cairo_int64_mul (qr.rem, _cairo_int32_to_int64 (2));
-        if (_cairo_int64_ge (qr.rem, den_det)) {
-            qr.quo = _cairo_int64_add (qr.quo,
-                                       _cairo_int32_to_int64 (_cairo_int64_negative (qr.quo) ? -1 : 1));
-        } else
-            intersection->x.exactness = INEXACT;
-    }
-#endif
-    intersection->x.ordinate = _cairo_int64_to_int32 (qr.quo);
-
-    /* y = det (a_det, dy1, b_det, dy2) / den_det */
-    qr = _cairo_int_96by64_32x64_divrem (det64x32_128 (a_det, dy1,
-                                                       b_det, dy2),
-                                         den_det);
-    if (_cairo_int64_eq (qr.rem, den_det))
-        return FALSE;
-#if 0
-    intersection->y.exactness = _cairo_int64_is_zero (qr.rem) ? EXACT : INEXACT;
-#else
-    intersection->y.exactness = EXACT;
-    if (! _cairo_int64_is_zero (qr.rem)) {
-        if (_cairo_int64_negative (den_det) ^ _cairo_int64_negative (qr.rem))
-            qr.rem = _cairo_int64_negate (qr.rem);
-        qr.rem = _cairo_int64_mul (qr.rem, _cairo_int32_to_int64 (2));
-        if (_cairo_int64_ge (qr.rem, den_det)) {
-            qr.quo = _cairo_int64_add (qr.quo,
-                                       _cairo_int32_to_int64 (_cairo_int64_negative (qr.quo) ? -1 : 1));
-        } else
-            intersection->y.exactness = INEXACT;
-    }
-#endif
-    intersection->y.ordinate = _cairo_int64_to_int32 (qr.quo);
-
-    return TRUE;
-}
-
-static int
-_cairo_bo_intersect_ordinate_32_compare (cairo_bo_intersect_ordinate_t        a,
-                                         int32_t                        b)
-{
-    /* First compare the quotient */
-    if (a.ordinate > b)
-        return +1;
-    if (a.ordinate < b)
-        return -1;
-    /* With quotient identical, if remainder is 0 then compare equal */
-    /* Otherwise, the non-zero remainder makes a > b */
-    return INEXACT == a.exactness;
-}
-
-/* Does the given edge contain the given point. The point must already
- * be known to be contained within the line determined by the edge,
- * (most likely the point results from an intersection of this edge
- * with another).
- *
- * If we had exact arithmetic, then this function would simply be a
- * matter of examining whether the y value of the point lies within
- * the range of y values of the edge. But since intersection points
- * are not exact due to being rounded to the nearest integer within
- * the available precision, we must also examine the x value of the
- * point.
- *
- * The definition of "contains" here is that the given intersection
- * point will be seen by the sweep line after the start event for the
- * given edge and before the stop event for the edge. See the comments
- * in the implementation for more details.
- */
-static cairo_bool_t
-_cairo_bo_edge_contains_intersect_point (cairo_bo_edge_t                *edge,
-                                         cairo_bo_intersect_point_t        *point)
-{
-    int cmp_top, cmp_bottom;
-
-    /* XXX: When running the actual algorithm, we don't actually need to
-     * compare against edge->top at all here, since any intersection above
-     * top is eliminated early via a slope comparison. We're leaving these
-     * here for now only for the sake of the quadratic-time intersection
-     * finder which needs them.
-     */
-
-    cmp_top = _cairo_bo_intersect_ordinate_32_compare (point->y,
-                                                       edge->edge.top);
-    cmp_bottom = _cairo_bo_intersect_ordinate_32_compare (point->y,
-                                                          edge->edge.bottom);
-
-    if (cmp_top < 0 || cmp_bottom > 0)
-    {
-        return FALSE;
-    }
-
-    if (cmp_top > 0 && cmp_bottom < 0)
-    {
-        return TRUE;
-    }
-
-    /* At this stage, the point lies on the same y value as either
-     * edge->top or edge->bottom, so we have to examine the x value in
-     * order to properly determine containment. */
-
-    /* If the y value of the point is the same as the y value of the
-     * top of the edge, then the x value of the point must be greater
-     * to be considered as inside the edge. Similarly, if the y value
-     * of the point is the same as the y value of the bottom of the
-     * edge, then the x value of the point must be less to be
-     * considered as inside. */
-
-    if (cmp_top == 0) {
-        cairo_fixed_t top_x;
-
-        top_x = _line_compute_intersection_x_for_y (&edge->edge.line,
-                                                    edge->edge.top);
-        return _cairo_bo_intersect_ordinate_32_compare (point->x, top_x) > 0;
-    } else { /* cmp_bottom == 0 */
-        cairo_fixed_t bot_x;
-
-        bot_x = _line_compute_intersection_x_for_y (&edge->edge.line,
-                                                    edge->edge.bottom);
-        return _cairo_bo_intersect_ordinate_32_compare (point->x, bot_x) < 0;
-    }
-}
-
-/* Compute the intersection of two edges. The result is provided as a
- * coordinate pair of 128-bit integers.
- *
- * Returns %CAIRO_BO_STATUS_INTERSECTION if there is an intersection
- * that is within both edges, %CAIRO_BO_STATUS_NO_INTERSECTION if the
- * intersection of the lines defined by the edges occurs outside of
- * one or both edges, and %CAIRO_BO_STATUS_PARALLEL if the two edges
- * are exactly parallel.
- *
- * Note that when determining if a candidate intersection is "inside"
- * an edge, we consider both the infinitesimal shortening and the
- * infinitesimal tilt rules described by John Hobby. Specifically, if
- * the intersection is exactly the same as an edge point, it is
- * effectively outside (no intersection is returned). Also, if the
- * intersection point has the same
- */
-static cairo_bool_t
-_cairo_bo_edge_intersect (cairo_bo_edge_t        *a,
-                          cairo_bo_edge_t        *b,
-                          cairo_bo_point32_t        *intersection)
-{
-    cairo_bo_intersect_point_t quorem;
-
-    if (! intersect_lines (a, b, &quorem))
-        return FALSE;
-
-    if (! _cairo_bo_edge_contains_intersect_point (a, &quorem))
-        return FALSE;
-
-    if (! _cairo_bo_edge_contains_intersect_point (b, &quorem))
-        return FALSE;
-
-    /* Now that we've correctly compared the intersection point and
-     * determined that it lies within the edge, then we know that we
-     * no longer need any more bits of storage for the intersection
-     * than we do for our edge coordinates. We also no longer need the
-     * remainder from the division. */
-    intersection->x = quorem.x.ordinate;
-    intersection->y = quorem.y.ordinate;
-
-    return TRUE;
-}
-
 static inline int
 cairo_bo_event_compare (const cairo_bo_event_t *a,
                         const cairo_bo_event_t *b)
@@ -1078,33 +742,6 @@ _cairo_bo_event_queue_fini (cairo_bo_event_queue_t *event_queue)
     _cairo_freepool_fini (&event_queue->pool);
 }
 
-static inline cairo_status_t
-_cairo_bo_event_queue_insert_if_intersect_below_current_y (cairo_bo_event_queue_t        *event_queue,
-                                                           cairo_bo_edge_t        *left,
-                                                           cairo_bo_edge_t *right)
-{
-    cairo_bo_point32_t intersection;
-
-    if (_line_equal (&left->edge.line, &right->edge.line))
-        return CAIRO_STATUS_SUCCESS;
-
-    /* The names "left" and "right" here are correct descriptions of
-     * the order of the two edges within the active edge list. So if a
-     * slope comparison also puts left less than right, then we know
-     * that the intersection of these two segments has already
-     * occurred before the current sweep line position. */
-    if (_slope_compare (left, right) <= 0)
-        return CAIRO_STATUS_SUCCESS;
-
-    if (! _cairo_bo_edge_intersect (left, right, &intersection))
-        return CAIRO_STATUS_SUCCESS;
-
-    return _cairo_bo_event_queue_insert (event_queue,
-                                         CAIRO_BO_EVENT_TYPE_INTERSECTION,
-                                         left, right,
-                                         &intersection);
-}
-
 static void
 _cairo_bo_sweep_line_init (cairo_bo_sweep_line_t *sweep_line)
 {
@@ -1190,26 +827,6 @@ _cairo_bo_sweep_line_delete (cairo_bo_sweep_line_t        *sweep_line,
         sweep_line->current_edge = edge->prev ? edge->prev : edge->next;
 }
 
-static void
-_cairo_bo_sweep_line_swap (cairo_bo_sweep_line_t        *sweep_line,
-                           cairo_bo_edge_t                *left,
-                           cairo_bo_edge_t                *right)
-{
-    if (left->prev != NULL)
-        left->prev->next = right;
-    else
-        sweep_line->head = right;
-
-    if (right->next != NULL)
-        right->next->prev = left;
-
-    left->next = right->next;
-    right->next = left;
-
-    right->prev = left->prev;
-    left->prev = right;
-}
-
 #if DEBUG_PRINT_STATE
 static void
 _cairo_bo_edge_print (cairo_bo_edge_t *edge)
@@ -1229,16 +846,9 @@ _cairo_bo_event_print (cairo_bo_event_t *event)
     case CAIRO_BO_EVENT_TYPE_STOP:
         printf ("Stop: ");
         break;
-    case CAIRO_BO_EVENT_TYPE_INTERSECTION:
-        printf ("Intersection: ");
-        break;
     }
     printf ("(%d, %d)\t", event->point.x, event->point.y);
     _cairo_bo_edge_print (((cairo_bo_queue_event_t *)event)->e1);
-    if (event->type == CAIRO_BO_EVENT_TYPE_INTERSECTION) {
-        printf (" X ");
-        _cairo_bo_edge_print (((cairo_bo_queue_event_t *)event)->e2);
-    }
     printf ("\n");
 }
 
@@ -1540,7 +1150,7 @@ _cairo_bentley_ottmann_tessellate_bo_edges (cairo_bo_event_t   **start_events,
     cairo_bo_sweep_line_t sweep_line;
     cairo_bo_event_t *event;
     cairo_bo_edge_t *left, *right;
-    cairo_bo_edge_t *e1, *e2;
+    cairo_bo_edge_t *e1;
 
 #if DEBUG_EVENTS
     {
@@ -1631,18 +1241,6 @@ _cairo_bentley_ottmann_tessellate_bo_edges (cairo_bo_event_t   **start_events,
             left = e1->prev;
             right = e1->next;
 
-            if (left != NULL) {
-                status = _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue, left, e1);
-                if (unlikely (status))
-                    goto unwind;
-            }
-
-            if (right != NULL) {
-                status = _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue, e1, right);
-                if (unlikely (status))
-                    goto unwind;
-            }
-
             break;
 
         case CAIRO_BO_EVENT_TYPE_STOP:
@@ -1663,47 +1261,8 @@ _cairo_bentley_ottmann_tessellate_bo_edges (cairo_bo_event_t   **start_events,
                 e1->prev = NULL;
             }
 
-            if (left != NULL && right != NULL) {
-                status = _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue, left, right);
-                if (unlikely (status))
-                    goto unwind;
-            }
-
             break;
 
-        case CAIRO_BO_EVENT_TYPE_INTERSECTION:
-            break;
-            printf ("Intersection event\n");
-            e1 = ((cairo_bo_queue_event_t *) event)->e1;
-            e2 = ((cairo_bo_queue_event_t *) event)->e2;
-            _cairo_bo_event_queue_delete (&event_queue, event);
-
-            /* skip this intersection if its edges are not adjacent */
-            if (e2 != e1->next)
-                break;
-
-            intersection_count++;
-
-            left = e1->prev;
-            right = e2->next;
-
-            _cairo_bo_sweep_line_swap (&sweep_line, e1, e2);
-
-            /* after the swap e2 is left of e1 */
-
-            if (left != NULL) {
-                status = _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue, left, e2);
-                if (unlikely (status))
-                    goto unwind;
-            }
-
-            if (right != NULL) {
-                status = _cairo_bo_event_queue_insert_if_intersect_below_current_y (&event_queue, e1, right);
-                if (unlikely (status))
-                    goto unwind;
-            }
-
-            break;
         }
     }
 
@@ -1725,86 +1284,74 @@ _cairo_bentley_ottmann_tessellate_bo_edges (cairo_bo_event_t   **start_events,
     return status;
 }
 
-cairo_status_t
-_cairo_bentley_ottmann_tessellate_polygon (cairo_traps_t         *traps,
-                                           const cairo_polygon_t *polygon)
+static void
+contour_to_start_events (PLINE                   *contour,
+                         cairo_bo_start_event_t  *events,
+                         cairo_bo_event_t       **event_ptrs,
+                         int                     *counter)
 {
-    int intersections;
-    cairo_status_t status;
-    cairo_bo_start_event_t stack_events[CAIRO_STACK_ARRAY_LENGTH (cairo_bo_start_event_t)];
-    cairo_bo_start_event_t *events;
-    cairo_bo_event_t *stack_event_ptrs[ARRAY_LENGTH (stack_events) + 1];
-    cairo_bo_event_t **event_ptrs;
-    int num_events;
-    int i;
-
-    num_events = polygon->num_edges;
-    if (unlikely (0 == num_events))
-        return CAIRO_STATUS_SUCCESS;
-
-    events = stack_events;
-    event_ptrs = stack_event_ptrs;
-    if (num_events > ARRAY_LENGTH (stack_events)) {
-        events = _cairo_malloc_ab_plus_c (num_events,
-                                          sizeof (cairo_bo_start_event_t) +
-                                          sizeof (cairo_bo_event_t *),
-                                          sizeof (cairo_bo_event_t *));
-        if (unlikely (events == NULL))
-            return _cairo_error (CAIRO_STATUS_NO_MEMORY);
+    int i = *counter;
+    int outer_contour;
+    VNODE *bv;
 
-        event_ptrs = (cairo_bo_event_t **) (events + num_events);
-    }
+    outer_contour = 1;
+    /* Loop over nodes, adding edges */
+    bv = &contour->head;
+    do {
+      int x1, y1, x2, y2;
+      cairo_edge_t cairo_edge;
+      /* Node is between bv->point[0,1] and bv->next->point[0,1] */
 
-    for (i = 0; i < num_events; i++) {
-        event_ptrs[i] = (cairo_bo_event_t *) &events[i];
+      if (bv->point[1] == bv->next->point[1]) {
+          if (bv->point[0] < bv->next->point[0]) {
+            x1 = bv->point[0];
+            y1 = bv->point[1];
+            x2 = bv->next->point[0];
+            y2 = bv->next->point[1];
+          } else {
+            x1 = bv->next->point[0];
+            y1 = bv->next->point[1];
+            x2 = bv->point[0];
+            y2 = bv->point[1];
+          }
+      } else if (bv->point[1] < bv->next->point[1]) {
+        x1 = bv->point[0];
+        y1 = bv->point[1];
+        x2 = bv->next->point[0];
+        y2 = bv->next->point[1];
+      } else {
+        x1 = bv->next->point[0];
+        y1 = bv->next->point[1];
+        x2 = bv->point[0];
+        y2 = bv->point[1];
+      }
 
-        events[i].type = CAIRO_BO_EVENT_TYPE_START;
-        events[i].point.y = polygon->edges[i].top;
-        events[i].point.x =
-            _line_compute_intersection_x_for_y (&polygon->edges[i].line,
-                                                events[i].point.y);
+      cairo_edge.line.p1.x = x1;
+      cairo_edge.line.p1.y = y1;
+      cairo_edge.line.p2.x = x2;
+      cairo_edge.line.p2.y = y2;
+      cairo_edge.top = y1;
+      cairo_edge.bottom = y2;
+      cairo_edge.dir = outer_contour ? 1 : -1;
 
-        events[i].edge.edge = polygon->edges[i];
-        events[i].edge.deferred_trap.right = NULL;
-        events[i].edge.prev = NULL;
-        events[i].edge.next = NULL;
-    }
+      event_ptrs[i] = (cairo_bo_event_t *) &events[i];
 
-#if DEBUG_TRAPS
-    dump_edges (events, num_events, "bo-polygon-edges.txt");
-#endif
+      events[i].type = CAIRO_BO_EVENT_TYPE_START;
+      events[i].point.y = cairo_edge.line.p1.y;
+      events[i].point.x = cairo_edge.line.p1.x;
 
-    /* XXX: This would be the convenient place to throw in multiple
-     * passes of the Bentley-Ottmann algorithm. It would merely
-     * require storing the results of each pass into a temporary
-     * cairo_traps_t. */
-    status = _cairo_bentley_ottmann_tessellate_bo_edges (event_ptrs,
-                                                         num_events,
-                                                         traps,
-                                                         &intersections);
-#if DEBUG_TRAPS
-    dump_traps (traps, "bo-polygon-out.txt");
-#endif
+      events[i].edge.edge = cairo_edge;
+      events[i].edge.deferred_trap.right = NULL;
+      events[i].edge.prev = NULL;
+      events[i].edge.next = NULL;
+      i++;
 
-    if (events != stack_events)
-        free (events);
+    } while ((bv = bv->next) != &contour->head);
 
-    return status;
+    *counter = i;
 }
 
 
-typedef struct {
-  int x;
-  int y;
-} bos_point;
-
-typedef struct {
-  bos_point a;
-  bos_point b;
-  int num;
-} bos_line;
-
-
 static void
 poly_area_to_start_events (POLYAREA                *poly,
                            cairo_bo_start_event_t  *events,
@@ -1882,7 +1429,6 @@ poly_area_to_start_events (POLYAREA                *poly,
     *counter = i;
 }
 
-
 cairo_traps_t *
 bo_poly_to_traps (POLYAREA *poly)
 {
@@ -1938,8 +1484,6 @@ bo_poly_to_traps (POLYAREA *poly)
                                                        traps,
                                                        &intersections);
 
-//  printf ("Number of traps: %i\n", traps->num_traps);
-
   for (n = 0; n < traps->num_traps; n++) {
     int x1, y1, x2, y2, x3, y3, x4, y4;
 
@@ -1952,16 +1496,114 @@ bo_poly_to_traps (POLYAREA *poly)
     x4 = _line_compute_intersection_x_for_y (&traps->traps[n].left, traps->traps[n].bottom);
     y4 = traps->traps[n].bottom;
 
+#if 1
+    if (x1 == x2) {
+      hidgl_ensure_triangle_space (&buffer, 1);
+      hidgl_add_triangle (&buffer, x1, y1, x3, y3, x4, y4);
+    } else if (x3 == x4) {
+      hidgl_ensure_triangle_space (&buffer, 1);
+      hidgl_add_triangle (&buffer, x1, y1, x2, y2, x3, y3);
+    } else {
+      hidgl_ensure_triangle_space (&buffer, 2);
+      hidgl_add_triangle (&buffer, x1, y1, x2, y2, x3, y3);
+      hidgl_add_triangle (&buffer, x3, y3, x4, y4, x1, y1);
+    }
+#else
+    glBegin (GL_LINES);
+    glVertex2i (x1, y1); glVertex2i (x2, y2);
+    glVertex2i (x2, y2); glVertex2i (x3, y3);
+     glVertex2i (x3, y3); glVertex2i (x1, y1);
+    glVertex2i (x3, y3); glVertex2i (x4, y4);
+    glVertex2i (x4, y4); glVertex2i (x1, y1);
+     glVertex2i (x1, y1); glVertex2i (x3, y3);
+    glEnd ();
+#endif
+
 #if 0
-    x1 = traps->traps[n].left.p1.x;
-    y1 = traps->traps[n].left.p1.y;
-    x2 = traps->traps[n].right.p1.x;
-    y2 = traps->traps[n].right.p1.y;
-    x3 = traps->traps[n].right.p2.x;
-    y3 = traps->traps[n].right.p2.y;
-    x4 = traps->traps[n].left.p2.x;
-    y4 = traps->traps[n].left.p2.y;
+    printf ("%d %d L:(%d, %d), (%d, %d) R:(%d, %d), (%d, %d)\n",
+             traps->traps[n].top,
+             traps->traps[n].bottom,
+             traps->traps[n].left.p1.x,
+             traps->traps[n].left.p1.y,
+             traps->traps[n].left.p2.x,
+             traps->traps[n].left.p2.y,
+             traps->traps[n].right.p1.x,
+             traps->traps[n].right.p1.y,
+             traps->traps[n].right.p2.x,
+             traps->traps[n].right.p2.y);
 #endif
+  }
+
+#if DEBUG_TRAPS
+  dump_traps (traps, "bo-polygon-out.txt");
+#endif
+
+  if (events != stack_events)
+      free (events);
+
+  return traps;
+}
+
+
+cairo_traps_t *
+bo_contour_to_traps (PLINE *contour)
+{
+  int intersections;
+  cairo_status_t status;
+  cairo_bo_start_event_t stack_events[CAIRO_STACK_ARRAY_LENGTH (cairo_bo_start_event_t)];
+  cairo_bo_start_event_t *events;
+  cairo_bo_event_t *stack_event_ptrs[ARRAY_LENGTH (stack_events) + 1];
+  cairo_bo_event_t **event_ptrs;
+  int num_events = 0;
+  int i;
+  int n;
+  cairo_traps_t int_traps;
+  cairo_traps_t *traps = &int_traps;
+
+  _cairo_traps_init (traps);
+
+  num_events = contour->Count;
+
+  if (unlikely (0 == num_events))
+      return CAIRO_STATUS_SUCCESS;
+
+  events = stack_events;
+  event_ptrs = stack_event_ptrs;
+  if (num_events > ARRAY_LENGTH (stack_events)) {
+      events = _cairo_malloc_ab_plus_c (num_events,
+                                        sizeof (cairo_bo_start_event_t) +
+                                        sizeof (cairo_bo_event_t *),
+                                        sizeof (cairo_bo_event_t *));
+      if (unlikely (events == NULL))
+          return NULL;
+
+      event_ptrs = (cairo_bo_event_t **) (events + num_events);
+  }
+
+  i = 0;
+
+  contour_to_start_events (contour, events, event_ptrs, &i);
+
+  /* XXX: This would be the convenient place to throw in multiple
+   * passes of the Bentley-Ottmann algorithm. It would merely
+   * require storing the results of each pass into a temporary
+   * cairo_traps_t. */
+  status = _cairo_bentley_ottmann_tessellate_bo_edges (event_ptrs,
+                                                       num_events,
+                                                       traps,
+                                                       &intersections);
+
+  for (n = 0; n < traps->num_traps; n++) {
+    int x1, y1, x2, y2, x3, y3, x4, y4;
+
+    x1 = _line_compute_intersection_x_for_y (&traps->traps[n].left, traps->traps[n].top);
+    y1 = traps->traps[n].top;
+    x2 = _line_compute_intersection_x_for_y (&traps->traps[n].right, traps->traps[n].top);
+    y2 = traps->traps[n].top;
+    x3 = _line_compute_intersection_x_for_y (&traps->traps[n].right, traps->traps[n].bottom);
+    y3 = traps->traps[n].bottom;
+    x4 = _line_compute_intersection_x_for_y (&traps->traps[n].left, traps->traps[n].bottom);
+    y4 = traps->traps[n].bottom;
 
 #if 1
     if (x1 == x2) {
diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index a103491..0e3d01c 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -221,8 +221,7 @@ hidgl_draw_line (int cap, double width, int x1, int y1, int x2, int y2, double s
   int hairline = 0;
 
   if (width == 0.0)
-    return;
-//    hairline = 1;
+    hairline = 1;
 
   if (width < scale)
     width = scale;
@@ -305,8 +304,7 @@ hidgl_draw_arc (double width, int x, int y, int rx, int ry,
   int hairline = 0;
 
   if (width == 0.0)
-    return;
-//    hairline = 1;
+    hairline = 1;
 
   if (width < scale)
     width = scale;
@@ -579,11 +577,12 @@ hidgl_fill_polygon (int n_coords, int *x, int *y)
   free (vertices);
 }
 
-void tesselate_contour (GLUtesselator *tobj, VNODE *vnode, GLdouble *vertices, int *vertex_offset)
+void tesselate_contour (GLUtesselator *tobj, VNODE *vnode, GLdouble *vertices)
 {
   VNODE *vn = vnode;
-  int offset = *vertex_offset;;
+  int offset = 0;
 
+  gluTessBeginPolygon (tobj, NULL);
   gluTessBeginContour (tobj);
   do {
     vertices [0 + offset] = vn->point[0];
@@ -593,25 +592,43 @@ void tesselate_contour (GLUtesselator *tobj, VNODE *vnode, GLdouble *vertices, i
     offset += 3;
   } while ((vn = vn->next) != vnode);
   gluTessEndContour (tobj);
-  *vertex_offset = offset;
+  gluTessEndPolygon (tobj);
 }
 
-struct do_hole_info {
-  GLUtesselator *tobj;
-  GLdouble *vertices;
-  int vertex_offset;
+struct hole_info {
+  double scale;
 };
 
 static int
 do_hole (const BoxType *b, void *cl)
 {
-  struct do_hole_info *info = cl;
+  cairo_traps_t *traps;
+
   PLINE *curc = (PLINE *) b;
+  struct hole_info *info = cl;
+
   /* Ignore the outer contour - we draw it first explicitly*/
   if (curc->Flags.orient == PLF_DIR) {
     return 0;
   }
-  tesselate_contour (info->tobj, &curc->head, info->vertices, &info->vertex_offset);
+
+  if (curc->is_round) {
+//    double slices;
+
+//    slices = M_PI * 2 * curc->radius / info->scale / PIXELS_PER_CIRCLINE;
+
+    /* If hidgl_fill_circle would use less slices than we have vertices,
+     * then call hidgl_fill_circle to draw this contour.
+     */
+//    if (slices < curc->Count) {
+      hidgl_fill_circle (curc->cx, curc->cy, curc->radius, info->scale);
+      return 1;
+//    }
+  }
+
+  traps = bo_contour_to_traps (curc);
+  _cairo_traps_fini (traps);
+
   return 1;
 }
 
@@ -619,21 +636,19 @@ static GLint stencil_bits;
 static int dirty_bits = 0;
 static int assigned_bits = 0;
 
-struct polygon_cache {
-  int fill_display_list;
-};
-
 /* FIXME: JUST DRAWS THE FIRST PIECE.. TODO: SUPPORT FOR FULLPOLY POLYGONS */
 void
-hidgl_fill_pcb_polygon_nocache (PolygonType *poly, const BoxType *clip_box, double scale)
+hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale)
 {
-  int vertex_count = 0;
-  PLINE *contour;
-  struct do_hole_info info;
+  int stencil_bit;
+  cairo_traps_t *traps;
+  struct hole_info info;
+
+  info.scale = scale;
 
-  bo_poly_to_traps (poly->Clipped);
+//  bo_poly_to_traps (poly->Clipped);
 
-  return;
+//  return;
 
   global_scale = scale;
 
@@ -643,71 +658,53 @@ hidgl_fill_pcb_polygon_nocache (PolygonType *poly, const BoxType *clip_box, doub
       return;
     }
 
-  /* Walk the polygon structure, counting vertices */
-  /* This gives an upper bound on the amount of storage required */
-  vertex_count = 0;
-  for (contour = poly->Clipped->contours;
-       contour != NULL; contour = contour->next)
-    vertex_count +=contour->Count;
-//    vertex_count = MAX (vertex_count, contour->Count);
-
-  info.vertices = malloc (sizeof(GLdouble) * vertex_count * 3);
-  info.vertex_offset = 0;
-  info.tobj = gluNewTess ();
-  gluTessCallback(info.tobj, GLU_TESS_BEGIN, myBegin);
-  gluTessCallback(info.tobj, GLU_TESS_VERTEX, myVertex);
-  gluTessCallback(info.tobj, GLU_TESS_COMBINE, myCombine);
-  gluTessCallback(info.tobj, GLU_TESS_ERROR, myError);
-  global_triangle_count = 0;
-
-  gluTessBeginPolygon (info.tobj, NULL);
+  stencil_bit = hidgl_assign_clear_stencil_bit ();
+  if (!stencil_bit)
+    {
+      printf ("hidgl_fill_pcb_polygon: No free stencil bits, aborting polygon\n");
+      return;
+    }
 
-  /* Draw the polygon outer */
-  tesselate_contour (info.tobj, &poly->Clipped->contours->head, info.vertices, &info.vertex_offset);
+  /* Flush out any existing geoemtry to be rendered */
+  hidgl_flush_triangles (&buffer);
 
-  /* Draw the polygon holes */
-  r_search (poly->Clipped->contour_tree, clip_box, NULL, do_hole, &info);
+  glPushAttrib (GL_STENCIL_BUFFER_BIT);                   // Save the write mask etc.. for final restore
+  glPushAttrib (GL_STENCIL_BUFFER_BIT |                   // Resave the stencil write-mask etc.., and
+                GL_COLOR_BUFFER_BIT);                     // the colour buffer write mask etc.. for part way restore
+  glStencilMask (stencil_bit);                            // Only write to our stencil bit
+  glStencilFunc (GL_ALWAYS, stencil_bit, stencil_bit);    // Always pass stencil test, ref value is our bit
+  glColorMask (0, 0, 0, 0);                               // Disable writting in color buffer
 
-  gluTessEndPolygon (info.tobj);
-  gluDeleteTess (info.tobj);
-  myFreeCombined ();
+  /* It will already be setup like this (so avoid prodding the state-machine):
+   * glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE); // Stencil pass => replace stencil value
+   */
+  /* Drawing operations now set our reference bit in the stencil buffer */
 
-//  printf ("global triangle count = %i\n", global_triangle_count);
-  free (info.vertices);
-}
+  r_search (poly->Clipped->contour_tree, clip_box, NULL, do_hole, &info);
+  hidgl_flush_triangles (&buffer);
 
-void
-hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale)
-{
-  struct polygon_cache *cache;
-  int new_cache = 0;
+  /* Drawing operations as masked to areas where the stencil buffer is '0' */
 
-  if (poly->gui_cache == NULL) {
-    poly->gui_cache = malloc (sizeof (struct polygon_cache));
-    new_cache = 1;
-  }
+  glPopAttrib ();                                             // Restore the colour and stencil buffer write-mask etc..
 
-  cache = poly->gui_cache;
+  glStencilOp (GL_KEEP, GL_KEEP, GL_INVERT); // This allows us to toggle the bit on the subcompositing bitplane
+                                             // If the stencil test has passed, we know that bit is 0, so we're
+                                             // effectively just setting it to 1.
+  glStencilFunc (GL_GEQUAL, 0, assigned_bits);
+//  glStencilFunc (GL_GREATER, assigned_bits, assigned_bits);   // Pass stencil test if all assigned bits clear,
+                                                              // reference is all assigned bits so we set
+                                                              // any bits permitted by the stencil writemask
 
-#if 0
-  if (!poly->gui_cache_valid) {
-    if (!new_cache)
-      glDeleteLists (cache->fill_display_list, 1);
-
-    cache->fill_display_list = glGenLists (1);
-    hidgl_flush_triangles (&buffer);
-    glNewList (cache->fill_display_list, GL_COMPILE);
-    hidgl_fill_pcb_polygon_nocache (poly, NULL /* clip_box */, scale);
-    hidgl_flush_triangles (&buffer);
-    glEndList ();
-    poly->gui_cache_valid = 1;
-  }
+  /* Draw the polygon outer */
+//  tesselate_contour (info.tobj, &poly->Clipped->contours->head, info.vertices);
+  traps = bo_contour_to_traps (poly->Clipped->contours);
+  _cairo_traps_fini (traps);
+  hidgl_flush_triangles (&buffer);
 
-  glCallList (cache->fill_display_list);
+  /* Unassign our stencil buffer bit */
+  hidgl_return_stencil_bit (stencil_bit);
 
-#else
-  hidgl_fill_pcb_polygon_nocache (poly, clip_box, scale);
-#endif
+  glPopAttrib ();                                             // Restore the stencil buffer write-mask etc..
 }
 
 void
diff --git a/src/polyarea.h b/src/polyarea.h
index 50dda4a..ce427ad 100644
--- a/src/polyarea.h
+++ b/src/polyarea.h
@@ -99,6 +99,10 @@ struct PLINE
     unsigned int Count;
     double area;
     rtree_t *tree;
+    int is_round;
+    int cx;
+    int cy;
+    int radius;
     struct {
       unsigned int status:3;
       unsigned int orient:1;
diff --git a/src/polygon.c b/src/polygon.c
index 061309d..3324781 100644
--- a/src/polygon.c
+++ b/src/polygon.c
@@ -320,6 +320,9 @@ frac_circle (PLINE * c, LocationType X, LocationType Y, Vector v, int range)
   e1 = v[0] - X;
   e2 = v[1] - Y;
 
+  /* -1 for the range != 1 case is due to the fact that the
+   * routines calling this function will add the missing vertex.
+   */
   range = (range == 1) ? CIRC_SEGS : (CIRC_SEGS / range) - 1;
   for (i = 0; i < range; i++)
     {
@@ -348,6 +351,10 @@ CirclePoly (LocationType x, LocationType y, BDimension radius)
   if ((contour = poly_NewContour (v)) == NULL)
     return NULL;
   frac_circle (contour, x, y, v, 1);
+  contour->cx = x;
+  contour->cy = y;
+  contour->is_round = TRUE;
+  contour->radius = radius;
   return ContourToPoly (contour);
 }
 
diff --git a/src/polygon1.c b/src/polygon1.c
index 1a46ea4..ee9c82a 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -2402,6 +2402,10 @@ poly_IniContour (PLINE * c)
   c->head.next = c->head.prev = &c->head;
   c->xmin = c->ymin = 0x7fffffff;
   c->xmax = c->ymax = 0x80000000;
+  c->is_round = FALSE;
+  c->cx = 0;
+  c->cy = 0;
+  c->radius = 0;
 }
 
 PLINE *

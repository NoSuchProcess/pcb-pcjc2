Bottom: 3ec6892cc5c9e99b224e4f9ed107706de4aad1b9
Top:    e997ea6dcfa34b4d6001170a343a856fd2cc7ec3
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-07-24 17:44:29 +0100

hid/gtk: Fixup Zoom() and zoom_by() so they don't ignore passed coordinates.

The Zoom() action was passing bogus coordinates (in pixels), and
zoom_by() was ignoring the passed coordinates and just using the mouse
pointer location last recorded in gport->pcb_x and gport->pcb_y.

Fix zoom_by() to use the passed coordinates, fix Zoom() to not mangle
the passed board coordinates into screen space.. zoom_by() wants
board coords.

Finally, remove a special case from the Zoom() action where if the passed
coordinates were both zero, we would pass the PCB coordinates of the board
center. I'm hopeful that things will "just work" without this.


---

diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index a92937f..c917e43 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -134,18 +134,6 @@ Zoom (int argc, char **argv, int x, int y)
   if (argc > 1)
     AFAIL (zoom);
 
-  if (x == 0 && y == 0)
-    {
-      x = gport->view_width / 2;
-      y = gport->view_height / 2;
-    }
-  else
-    {
-      /* Px converts view->pcb, Vx converts pcb->view */
-      x = Vx (x);
-      y = Vy (y);
-    }
-
   if (argc < 1)
     {
       zoom_fit ();
@@ -204,15 +192,15 @@ zoom_to (double new_zoom, int x, int y)
   if (gport->zoom == new_zoom)
     return;
 
-  xtmp = (SIDE_X (gport->pcb_x) - gport->view_x0) / (double)gport->view_width;
-  ytmp = (SIDE_Y (gport->pcb_y) - gport->view_y0) / (double)gport->view_height;
+  xtmp = (SIDE_X (x) - gport->view_x0) / (double)gport->view_width;
+  ytmp = (SIDE_Y (y) - gport->view_y0) / (double)gport->view_height;
 
   gport->zoom = new_zoom;
   pixel_slop = new_zoom;
   ghid_port_ranges_scale (FALSE);
 
-  gport->view_x0 = MAX (0, SIDE_X (gport->pcb_x) - xtmp * gport->view_width);
-  gport->view_y0 = MAX (0, SIDE_Y (gport->pcb_y) - ytmp * gport->view_height);
+  gport->view_x0 = MAX (0, SIDE_X (x) - xtmp * gport->view_width);
+  gport->view_y0 = MAX (0, SIDE_Y (y) - ytmp * gport->view_height);
 
   ghidgui->adjustment_changed_holdoff = TRUE;
   gtk_range_set_value (GTK_RANGE (ghidgui->h_range), gport->view_x0);

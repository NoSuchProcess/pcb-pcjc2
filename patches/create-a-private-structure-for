Bottom: c4715bf7a78287f0e38bee9076fe11b5f6a6c7ed
Top:    997db8f3e0432cfc5df80bdbbea2379b7af9c4a5
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-03-08 18:28:19 +0000

Create a private structure for the render to isolate some of its internals

Also create a hook for configure events on the main drawing area to
allow the renderer to reconfigure its-self as necessary as the area
changes in size.


---

diff --git a/src/hid/gtk/gtkhid-gdk.c b/src/hid/gtk/gtkhid-gdk.c
index 5988a58..c8bac31 100644
--- a/src/hid/gtk/gtkhid-gdk.c
+++ b/src/hid/gtk/gtkhid-gdk.c
@@ -21,13 +21,21 @@ RCSID ("$Id$");
 
 extern HID ghid_hid;
 
-/* Sets gport->u_gc to the "right" GC to use (wrt mask or window)
+/* Sets priv->u_gc to the "right" GC to use (wrt mask or window)
 */
 #define USE_GC(gc) if (!use_gc(gc)) return
 
 static int cur_mask = -1;
 static int mask_seq = 0;
 
+typedef struct render_priv {
+  GdkGC *bg_gc;
+  GdkGC *offlimits_gc;
+  GdkGC *mask_gc;
+  GdkGC *u_gc;
+  GdkGC *grid_gc;
+} render_priv;
+
 
 typedef struct hid_gc_struct
 {
@@ -70,12 +78,13 @@ ghid_draw_grid (void)
   static int npoints = 0;
   int x1, y1, x2, y2, n, i;
   double x, y;
+  render_priv *priv = gport->render_priv;
 
   if (!Settings.DrawGrid)
     return;
   if (Vz (PCB->Grid) < MIN_GRID_DISTANCE)
     return;
-  if (!gport->grid_gc)
+  if (!priv->grid_gc)
     {
       if (gdk_color_parse (Settings.GridColor, &gport->grid_color))
 	{
@@ -84,9 +93,9 @@ ghid_draw_grid (void)
 	  gport->grid_color.blue ^= gport->bg_color.blue;
 	  gdk_color_alloc (gport->colormap, &gport->grid_color);
 	}
-      gport->grid_gc = gdk_gc_new (gport->drawable);
-      gdk_gc_set_function (gport->grid_gc, GDK_XOR);
-      gdk_gc_set_foreground (gport->grid_gc, &gport->grid_color);
+      priv->grid_gc = gdk_gc_new (gport->drawable);
+      gdk_gc_set_function (priv->grid_gc, GDK_XOR);
+      gdk_gc_set_foreground (priv->grid_gc, &gport->grid_color);
     }
   x1 = GRIDFIT_X (SIDE_X (gport->view_x0), PCB->Grid);
   y1 = GRIDFIT_Y (SIDE_Y (gport->view_y0), PCB->Grid);
@@ -132,7 +141,7 @@ ghid_draw_grid (void)
       int vy = Vy (y);
       for (i = 0; i < n; i++)
 	points[i].y = vy;
-      gdk_draw_points (gport->drawable, gport->grid_gc, points, n);
+      gdk_draw_points (gport->drawable, priv->grid_gc, points, n);
     }
 }
 
@@ -144,6 +153,7 @@ ghid_draw_bg_image (void)
   GdkInterpType interp_type;
   gint x, y, w, h, w_src, h_src;
   static gint w_scaled, h_scaled;
+  render_priv *priv = gport->render_priv;
 
   if (!ghidgui->bg_pixbuf)
     return;
@@ -171,12 +181,12 @@ ghid_draw_bg_image (void)
       h_scaled = h;
     }
   if (pixbuf)
-    gdk_pixbuf_render_to_drawable (pixbuf, gport->drawable, gport->bg_gc,
+    gdk_pixbuf_render_to_drawable (pixbuf, gport->drawable, priv->bg_gc,
 				   x, y, 0, 0,
 				   w - x, h - y, GDK_RGB_DITHER_NORMAL, 0, 0);
 }
 
-#define WHICH_GC(gc) (cur_mask == HID_MASK_CLEAR ? gport->mask_gc : (gc)->gc)
+#define WHICH_GC(gc) (cur_mask == HID_MASK_CLEAR ? priv->mask_gc : (gc)->gc)
 
 void
 ghid_use_mask (int use_it)
@@ -184,6 +194,7 @@ ghid_use_mask (int use_it)
   static int mask_seq_id = 0;
   static GdkDrawable *old;
   GdkColor color;
+  render_priv *priv = gport->render_priv;
 
   if (use_it == HID_FLUSH_DRAW_Q)
     {
@@ -222,16 +233,16 @@ ghid_use_mask (int use_it)
 	gport->mask = gdk_pixmap_new (0, gport->width, gport->height, 1);
       gport->drawable = gport->mask;
       mask_seq = 0;
-      if (!gport->mask_gc)
+      if (!priv->mask_gc)
 	{
-	  gport->mask_gc = gdk_gc_new (gport->drawable);
+	  priv->mask_gc = gdk_gc_new (gport->drawable);
 	}
       color.pixel = 1;
-      gdk_gc_set_foreground (gport->mask_gc, &color);
-      gdk_draw_rectangle (gport->drawable, gport->mask_gc, TRUE, 0, 0,
+      gdk_gc_set_foreground (priv->mask_gc, &color);
+      gdk_draw_rectangle (gport->drawable, priv->mask_gc, TRUE, 0, 0,
 			  gport->width, gport->height);
       color.pixel = 0;
-      gdk_gc_set_foreground (gport->mask_gc, &color);
+      gdk_gc_set_foreground (priv->mask_gc, &color);
       break;
 
     case HID_MASK_AFTER:
@@ -263,33 +274,37 @@ typedef struct
 static void
 set_special_grid_color (void)
 {
+  render_priv *priv = gport->render_priv;
+
   if (!gport->colormap)
     return;
   gport->grid_color.red ^= gport->bg_color.red;
   gport->grid_color.green ^= gport->bg_color.green;
   gport->grid_color.blue ^= gport->bg_color.blue;
   gdk_color_alloc (gport->colormap, &gport->grid_color);
-  if (gport->grid_gc)
-    gdk_gc_set_foreground (gport->grid_gc, &gport->grid_color);
+  if (priv->grid_gc)
+    gdk_gc_set_foreground (priv->grid_gc, &gport->grid_color);
 }
 
 void
 ghid_set_special_colors (HID_Attribute * ha)
 {
+  render_priv *priv = gport->render_priv;
+
   if (!ha->name || !ha->value)
     return;
-  if (!strcmp (ha->name, "background-color") && gport->bg_gc)
+  if (!strcmp (ha->name, "background-color") && priv->bg_gc)
     {
       ghid_map_color_string (*(char **) ha->value, &gport->bg_color);
-      gdk_gc_set_foreground (gport->bg_gc, &gport->bg_color);
+      gdk_gc_set_foreground (priv->bg_gc, &gport->bg_color);
       set_special_grid_color ();
     }
-  else if (!strcmp (ha->name, "off-limit-color") && gport->offlimits_gc)
+  else if (!strcmp (ha->name, "off-limit-color") && priv->offlimits_gc)
     {
       ghid_map_color_string (*(char **) ha->value, &gport->offlimits_color);
-      gdk_gc_set_foreground (gport->offlimits_gc, &gport->offlimits_color);
+      gdk_gc_set_foreground (priv->offlimits_gc, &gport->offlimits_color);
     }
-  else if (!strcmp (ha->name, "grid-color") && gport->grid_gc)
+  else if (!strcmp (ha->name, "grid-color") && priv->grid_gc)
     {
       ghid_map_color_string (*(char **) ha->value, &gport->grid_color);
       set_special_grid_color ();
@@ -370,6 +385,7 @@ ghid_set_color (hidGC gc, const char *name)
 void
 ghid_set_line_cap (hidGC gc, EndCapStyle style)
 {
+  render_priv *priv = gport->render_priv;
 
   switch (style)
     {
@@ -393,6 +409,7 @@ ghid_set_line_cap (hidGC gc, EndCapStyle style)
 void
 ghid_set_line_width (hidGC gc, int width)
 {
+  render_priv *priv = gport->render_priv;
 
   gc->width = width;
   if (gc->gc)
@@ -426,6 +443,7 @@ ghid_set_line_cap_angle (hidGC gc, int x1, int y1, int x2, int y2)
 static int
 use_gc (hidGC gc)
 {
+  render_priv *priv = gport->render_priv;
 
   if (gc->me_pointer != &ghid_hid)
     {
@@ -451,7 +469,7 @@ use_gc (hidGC gc)
 	gdk_gc_set_clip_mask (gc->gc, NULL);
       gc->mask_seq = mask_seq;
     }
-  gport->u_gc = WHICH_GC (gc);
+  priv->u_gc = WHICH_GC (gc);
   return 1;
 }
 
@@ -459,6 +477,7 @@ void
 ghid_draw_line (hidGC gc, int x1, int y1, int x2, int y2)
 {
   double dx1, dy1, dx2, dy2;
+  render_priv *priv = gport->render_priv;
 
   dx1 = Vx ((double) x1);
   dy1 = Vy ((double) y1);
@@ -470,7 +489,7 @@ ghid_draw_line (hidGC gc, int x1, int y1, int x2, int y2)
     return;
 
   USE_GC (gc);
-  gdk_draw_line (gport->drawable, gport->u_gc, dx1, dy1, dx2, dy2);
+  gdk_draw_line (gport->drawable, priv->u_gc, dx1, dy1, dx2, dy2);
 }
 
 void
@@ -479,6 +498,7 @@ ghid_draw_arc (hidGC gc, int cx, int cy,
 {
   gint vrx, vry;
   gint w, h, radius;
+  render_priv *priv = gport->render_priv;
 
   w = gport->width * gport->zoom;
   h = gport->height * gport->zoom;
@@ -506,7 +526,7 @@ ghid_draw_arc (hidGC gc, int cx, int cy,
   /* make sure we fall in the -180 to +180 range */
   start_angle = (start_angle + 360 + 180) % 360 - 180;
 
-  gdk_draw_arc (gport->drawable, gport->u_gc, 0,
+  gdk_draw_arc (gport->drawable, priv->u_gc, 0,
 		Vx (cx) - vrx, Vy (cy) - vry,
 		vrx * 2, vry * 2, (start_angle + 180) * 64, delta_angle * 64);
 }
@@ -515,6 +535,7 @@ void
 ghid_draw_rect (hidGC gc, int x1, int y1, int x2, int y2)
 {
   gint w, h, lw;
+  render_priv *priv = gport->render_priv;
 
   lw = gc->width;
   w = gport->width * gport->zoom;
@@ -549,7 +570,7 @@ ghid_draw_rect (hidGC gc, int x1, int y1, int x2, int y2)
     }
 
   USE_GC (gc);
-  gdk_draw_rectangle (gport->drawable, gport->u_gc, FALSE,
+  gdk_draw_rectangle (gport->drawable, priv->u_gc, FALSE,
 		      x1, y1, x2 - x1 + 1, y2 - y1 + 1);
 }
 
@@ -558,6 +579,7 @@ void
 ghid_fill_circle (hidGC gc, int cx, int cy, int radius)
 {
   gint w, h, vr;
+  render_priv *priv = gport->render_priv;
 
   w = gport->width * gport->zoom;
   h = gport->height * gport->zoom;
@@ -569,7 +591,7 @@ ghid_fill_circle (hidGC gc, int cx, int cy, int radius)
 
   USE_GC (gc);
   vr = Vz (radius);
-  gdk_draw_arc (gport->drawable, gport->u_gc, TRUE,
+  gdk_draw_arc (gport->drawable, priv->u_gc, TRUE,
 		Vx (cx) - vr, Vy (cy) - vr, vr * 2, vr * 2, 0, 360 * 64);
 }
 
@@ -579,6 +601,7 @@ ghid_fill_polygon (hidGC gc, int n_coords, int *x, int *y)
   static GdkPoint *points = 0;
   static int npoints = 0;
   int i;
+  render_priv *priv = gport->render_priv;
   USE_GC (gc);
 
   if (npoints < n_coords)
@@ -591,13 +614,14 @@ ghid_fill_polygon (hidGC gc, int n_coords, int *x, int *y)
       points[i].x = Vx (x[i]);
       points[i].y = Vy (y[i]);
     }
-  gdk_draw_polygon (gport->drawable, gport->u_gc, 1, points, n_coords);
+  gdk_draw_polygon (gport->drawable, priv->u_gc, 1, points, n_coords);
 }
 
 void
 ghid_fill_rect (hidGC gc, int x1, int y1, int x2, int y2)
 {
   gint w, h, lw, xx, yy;
+  render_priv *priv = gport->render_priv;
 
   lw = gc->width;
   w = gport->width * gport->zoom;
@@ -630,7 +654,7 @@ ghid_fill_rect (hidGC gc, int x1, int y1, int x2, int y2)
       y2 = yy;
     }
   USE_GC (gc);
-  gdk_draw_rectangle (gport->drawable, gport->u_gc, TRUE,
+  gdk_draw_rectangle (gport->drawable, priv->u_gc, TRUE,
 		      x1, y1, x2 - x1 + 1, y2 - y1 + 1);
 }
 
@@ -645,6 +669,7 @@ ghid_invalidate_all ()
 {
   int eleft, eright, etop, ebottom;
   BoxType region;
+  render_priv *priv = gport->render_priv;
 
   if (!gport->pixmap)
     return;
@@ -672,28 +697,28 @@ ghid_invalidate_all ()
     }
 
   if (eleft > 0)
-    gdk_draw_rectangle (gport->drawable, gport->offlimits_gc,
+    gdk_draw_rectangle (gport->drawable, priv->offlimits_gc,
 			1, 0, 0, eleft, gport->height);
   else
     eleft = 0;
   if (eright < gport->width)
-    gdk_draw_rectangle (gport->drawable, gport->offlimits_gc,
+    gdk_draw_rectangle (gport->drawable, priv->offlimits_gc,
 			1, eright, 0, gport->width - eright, gport->height);
   else
     eright = gport->width;
   if (etop > 0)
-    gdk_draw_rectangle (gport->drawable, gport->offlimits_gc,
+    gdk_draw_rectangle (gport->drawable, priv->offlimits_gc,
 			1, eleft, 0, eright - eleft + 1, etop);
   else
     etop = 0;
   if (ebottom < gport->height)
-    gdk_draw_rectangle (gport->drawable, gport->offlimits_gc,
+    gdk_draw_rectangle (gport->drawable, priv->offlimits_gc,
 			1, eleft, ebottom, eright - eleft + 1,
 			gport->height - ebottom);
   else
     ebottom = gport->height;
 
-  gdk_draw_rectangle (gport->drawable, gport->bg_gc, 1,
+  gdk_draw_rectangle (gport->drawable, priv->bg_gc, 1,
 		      eleft, etop, eright - eleft + 1, ebottom - etop + 1);
 
   ghid_draw_bg_image();
@@ -870,10 +895,42 @@ ghid_show_crosshair (gboolean show)
 }
 
 void
+ghid_init_renderer (int *argc, char ***argv, GHidPort *port)
+{
+  /* Init any GC's required */
+  port->render_priv = g_new0 (render_priv, 1);
+}
+
+void
+ghid_drawing_area_configure_hook (GHidPort *port)
+{
+  static int done_once = 0;
+  render_priv *priv = port->render_priv;
+
+  if (!done_once)
+    {
+      priv->bg_gc = gdk_gc_new (port->drawable);
+      gdk_gc_set_foreground (priv->bg_gc, &port->bg_color);
+
+      priv->offlimits_gc = gdk_gc_new (port->drawable);
+      gdk_gc_set_foreground (priv->offlimits_gc, &port->offlimits_color);
+      done_once = 1;
+    }
+
+  if (port->mask)
+    {
+      gdk_pixmap_unref (port->mask);
+      port->mask = gdk_pixmap_new (0, port->width, port->height, 1);
+    }
+}
+
+void
 ghid_screen_update (void)
 {
+  render_priv *priv = gport->render_priv;
+
   ghid_show_crosshair (FALSE);
-  gdk_draw_drawable (gport->drawing_area->window, gport->bg_gc, gport->pixmap,
+  gdk_draw_drawable (gport->drawing_area->window, priv->bg_gc, gport->pixmap,
 		     0, 0, 0, 0, gport->width, gport->height);
   ghid_show_crosshair (TRUE);
 }
@@ -883,8 +940,10 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
                              GdkEventExpose *ev,
                              GHidPort *port)
 {
+  render_priv *priv = port->render_priv;
+
   ghid_show_crosshair (FALSE);
-  gdk_draw_drawable (widget->window, port->bg_gc, port->pixmap,
+  gdk_draw_drawable (widget->window, priv->bg_gc, port->pixmap,
                     ev->area.x, ev->area.y, ev->area.x, ev->area.y,
                     ev->area.width, ev->area.height);
   ghid_show_crosshair (TRUE);
@@ -903,6 +962,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   int save_width, save_height;
   int save_view_width, save_view_height;
   double xz, yz;
+  render_priv *priv = gport->render_priv;
 
   save_zoom = gport->zoom;
   save_width = gport->width;
@@ -933,7 +993,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   gport->view_y0 = (pinout->y_max - gport->view_height) / 2;
 
   /* clear background */
-  gdk_draw_rectangle (widget->window, gport->bg_gc, TRUE, 0, 0, da_w, da_h);
+  gdk_draw_rectangle (widget->window, priv->bg_gc, TRUE, 0, 0, da_w, da_h);
 
   /* call the drawing routine */
   hid_expose_callback (&ghid_hid, NULL, &pinout->element);
@@ -969,7 +1029,7 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   gport->view_y0 = (pinout->y_max - gport->view_height) / 2;
 
   /* clear background */
-  gdk_draw_rectangle (widget->window, gport->bg_gc, TRUE, 0, 0, da_w, da_h);
+  gdk_draw_rectangle (widget->window, priv->bg_gc, TRUE, 0, 0, da_w, da_h);
 
   /* call the drawing routine */
   hid_expose_callback (&ghid_hid, NULL, &pinout->element);
@@ -996,6 +1056,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   int save_width, save_height;
   int save_view_width, save_view_height;
   BoxType region;
+  render_priv *priv = gport->render_priv;
 
   save_drawable = gport->drawable;
   save_zoom = gport->zoom;
@@ -1023,7 +1084,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   gport->view_y0 -= gport->view_width  / 2;
 
   /* clear background */
-  gdk_draw_rectangle (pixmap, gport->bg_gc, TRUE, 0, 0, width, height);
+  gdk_draw_rectangle (pixmap, priv->bg_gc, TRUE, 0, 0, width, height);
 
   /* call the drawing routine */
   region.X1 = MIN(Px(0), Px(gport->width + 1));
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index 6929c8a..10dd85b 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -516,27 +516,24 @@ ghid_port_drawing_area_configure_event_cb (GtkWidget * widget,
   if (!first_time_done)
     {
       gport->colormap = gtk_widget_get_colormap (gport->top_window);
-      gport->bg_gc = gdk_gc_new (gport->drawable);
       if (gdk_color_parse (Settings.BackgroundColor, &gport->bg_color))
 	gdk_color_alloc (gport->colormap, &gport->bg_color);
       else
 	gdk_color_white (gport->colormap, &gport->bg_color);
-      gdk_gc_set_foreground (gport->bg_gc, &gport->bg_color);
 
-      gport->offlimits_gc = gdk_gc_new (gport->drawable);
       if (gdk_color_parse (Settings.OffLimitColor, &gport->offlimits_color))
 	gdk_color_alloc (gport->colormap, &gport->offlimits_color);
       else
 	gdk_color_white (gport->colormap, &gport->offlimits_color);
-      gdk_gc_set_foreground (gport->offlimits_gc, &gport->offlimits_color);
       first_time_done = TRUE;
+      ghid_drawing_area_configure_hook (out);
       PCBChanged (0, NULL, 0, 0);
     }
-  if (gport->mask)
+  else
     {
-      gdk_pixmap_unref (gport->mask);
-      gport->mask = gdk_pixmap_new (0, gport->width, gport->height, 1);
+      ghid_drawing_area_configure_hook (out);
     }
+
   ghid_port_ranges_scale (FALSE);
   ghid_invalidate_all ();
   RestoreCrosshair (TRUE);
diff --git a/src/hid/gtk/gui-top-window.c b/src/hid/gtk/gui-top-window.c
index dd97d01..ff6dfc0 100644
--- a/src/hid/gtk/gui-top-window.c
+++ b/src/hid/gtk/gui-top-window.c
@@ -2693,6 +2693,8 @@ ghid_parse_arguments (int *argc, char ***argv)
   gport->zoom = 300.0;
   pixel_slop = 300;
 
+  ghid_init_renderer (argc, argv, gport);
+
   ghid_config_files_read (argc, argv);
 
   Settings.AutoPlace = 0;
diff --git a/src/hid/gtk/gui.h b/src/hid/gtk/gui.h
index cf45adf..332239b 100644
--- a/src/hid/gtk/gui.h
+++ b/src/hid/gtk/gui.h
@@ -162,7 +162,7 @@ typedef struct
   GdkDrawable *drawable;	/* Current drawable for drawing routines */
   gint width, height;
 
-  GdkGC *bg_gc, *offlimits_gc, *mask_gc, *u_gc, *grid_gc;
+  struct render_priv *render_priv;
 
   GdkColor bg_color, offlimits_color, grid_color;
 
@@ -494,6 +494,8 @@ void ghid_fill_rect (hidGC gc, int x1, int y1, int x2, int y2);
 void ghid_invalidate_lr (int left, int right, int top, int bottom);
 void ghid_invalidate_all ();
 void ghid_show_crosshair (gboolean show);
+void ghid_init_renderer (int *, char ***, GHidPort *);
+void ghid_drawing_area_configure_hook (GHidPort *port);
 void ghid_screen_update (void);
 gboolean ghid_drawing_area_expose_cb (GtkWidget *, GdkEventExpose *,
                                       GHidPort *);

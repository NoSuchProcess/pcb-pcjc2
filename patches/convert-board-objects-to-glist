Bottom: 7918641981ba21627467828a2bb3942aa2ec2f70
Top:    462e3a8f71a09ee2127e8c38da946434c0fd02bd
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-04-30 15:20:39 +0100

Convert board objects to GLists of g_slice allocated memory

This enables pointers for these objects to be immutable during their
lifetime, which is a _huge_ benefit for some operations.


---

diff --git a/src/action.c b/src/action.c
index ed087c1..ae6b87e 100644
--- a/src/action.c
+++ b/src/action.c
@@ -6388,7 +6388,7 @@ ActionRedo (int argc, char **argv, int x, int y)
       if (Settings.Mode == LINE_MODE &&
 	  Crosshair.AttachedLine.State != STATE_FIRST)
 	{
-	  LineTypePtr line = &CURRENT->Line[CURRENT->LineN - 1];
+	  LineType *line = g_list_last (CURRENT->Line)->data;
 	  Crosshair.AttachedLine.Point1.X =
 	    Crosshair.AttachedLine.Point2.X = line->Point2.X;
 	  Crosshair.AttachedLine.Point1.Y =
@@ -7136,7 +7136,7 @@ ActionElementList (int argc, char **argv, int x, int y)
 	return 1;
 
       er = ElementOrientation (e);
-      pe = & PASTEBUFFER->Data->Element[0];
+      pe = PASTEBUFFER->Data->Element->data;
       pr = ElementOrientation (pe);
 
       mx = e->MarkX;
diff --git a/src/autoroute.c b/src/autoroute.c
index b58600f..27dba28 100644
--- a/src/autoroute.c
+++ b/src/autoroute.c
@@ -166,6 +166,7 @@ static hidGC ar_gc = 0;
 
 #define LIST_LOOP(init, which, x) do {\
      routebox_t *__next_one__ = (init);\
+   GList *__copy = NULL; /* DUMMY */\
    x = NULL;\
    if (!__next_one__)\
      assert(__next_one__);\
diff --git a/src/buffer.c b/src/buffer.c
index ec7f538..8793f50 100644
--- a/src/buffer.c
+++ b/src/buffer.c
@@ -236,76 +236,64 @@ AddElementToBuffer (ElementTypePtr Element)
  * moves a via to paste buffer without allocating memory for the name
  */
 static void *
-MoveViaToBuffer (PinTypePtr Via)
+MoveViaToBuffer (PinType *via)
 {
-  PinTypePtr via;
+  RestoreToPolygon (Source, VIA_TYPE, via, via);
+
+  r_delete_entry (Source->via_tree, (BoxType *) via);
+  Source->Via = g_list_remove (Source->Via, via);
+  Source->ViaN --;
+  Dest->Via = g_list_append (Dest->Via, via);
+  Dest->ViaN ++;
 
-  RestoreToPolygon (Source, VIA_TYPE, Via, Via);
-  r_delete_entry (Source->via_tree, (BoxType *)Via);
-  via = GetViaMemory (Dest);
-  *via = *Via;
   CLEAR_FLAG (WARNFLAG | FOUNDFLAG, via);
-  if (Via != &Source->Via[--Source->ViaN])
-  {
-  *Via = Source->Via[Source->ViaN];
-  r_substitute (Source->via_tree, (BoxType *) & Source->Via[Source->ViaN],
-		(BoxType *) Via);
-  }
-  memset (&Source->Via[Source->ViaN], 0, sizeof (PinType));
+
   if (!Dest->via_tree)
     Dest->via_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (Dest->via_tree, (BoxType *)via, 0);
   ClearFromPolygon (Dest, VIA_TYPE, via, via);
-  return (via);
+  return via;
 }
 
 /* ---------------------------------------------------------------------------
  * moves a rat-line to paste buffer
  */
 static void *
-MoveRatToBuffer (RatTypePtr Rat)
+MoveRatToBuffer (RatType *rat)
 {
-  RatTypePtr rat;
+  r_delete_entry (Source->rat_tree, (BoxType *)rat);
+
+  Source->Rat = g_list_remove (Source->Rat, rat);
+  Source->RatN --;
+  Dest->Rat = g_list_append (Dest->Rat, rat);
+  Dest->RatN ++;
 
-  r_delete_entry (Source->rat_tree, (BoxType *)Rat);
-  rat = GetRatMemory (Dest);
-  *rat = *Rat;
   CLEAR_FLAG (FOUNDFLAG, rat);
-  if (Rat != &Source->Rat[--Source->RatN])
-  {
-  *Rat = Source->Rat[Source->RatN];
-  r_substitute (Source->rat_tree, &Source->Rat[Source->RatN].BoundingBox,
-		&Rat->BoundingBox);
-  }
-  memset (&Source->Rat[Source->RatN], 0, sizeof (RatType));
+
   if (!Dest->rat_tree)
     Dest->rat_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (Dest->rat_tree, (BoxType *)rat, 0);
-  return (rat);
+  return rat;
 }
 
 /* ---------------------------------------------------------------------------
  * moves a line to buffer  
  */
 static void *
-MoveLineToBuffer (LayerType *layer, LineType *Line)
+MoveLineToBuffer (LayerType *layer, LineType *line)
 {
-  LayerType *lay = &Dest->Layer[GetLayerNumber (Source, layer)];
-  LineTypePtr line;
+  LayerTypePtr lay = &Dest->Layer[GetLayerNumber (Source, layer)];
+
+  RestoreToPolygon (Source, LINE_TYPE, layer, line);
+  r_delete_entry (layer->line_tree, (BoxType *)line);
+
+  layer->Line = g_list_remove (layer->Line, line);
+  layer->LineN --;
+  lay->Line = g_list_append (lay->Line, line);
+  lay->LineN ++;
 
-  RestoreToPolygon (Source, LINE_TYPE, layer, Line);
-  r_delete_entry (layer->line_tree, (BoxType *)Line);
-  line = GetLineMemory (lay);
-  *line = *Line;
   CLEAR_FLAG (FOUNDFLAG, line);
-  /* line pointers being shuffled */
-  if (Line != &layer->Line[--layer->LineN])
-  {
-  *Line = layer->Line[layer->LineN];
-  r_substitute (layer->line_tree, (BoxTypePtr) & layer->Line[layer->LineN],
-		(BoxTypePtr) Line);
-  }
-  memset (&layer->Line[layer->LineN], 0, sizeof (LineType));
+
   if (!lay->line_tree)
     lay->line_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (lay->line_tree, (BoxType *)line, 0);
@@ -317,24 +305,20 @@ MoveLineToBuffer (LayerType *layer, LineType *Line)
  * moves an arc to buffer  
  */
 static void *
-MoveArcToBuffer (LayerType *layer, ArcType *Arc)
+MoveArcToBuffer (LayerType *layer, ArcType *arc)
 {
   LayerType *lay = &Dest->Layer[GetLayerNumber (Source, layer)];
-  ArcTypePtr arc;
 
-  RestoreToPolygon (Source, ARC_TYPE, layer, Arc);
-  r_delete_entry (layer->arc_tree, (BoxType *)Arc);
-  arc = GetArcMemory (lay);
-  *arc = *Arc;
+  RestoreToPolygon (Source, ARC_TYPE, layer, arc);
+  r_delete_entry (layer->arc_tree, (BoxType *)arc);
+
+  layer->Arc = g_list_remove (layer->Arc, arc);
+  layer->ArcN --;
+  lay->Arc = g_list_append (lay->Arc, arc);
+  lay->ArcN ++;
+
   CLEAR_FLAG (FOUNDFLAG, arc);
-  /* arc pointers being shuffled */
-  if (Arc != &layer->Arc[--layer->ArcN])
-  {
-  *Arc = layer->Arc[layer->ArcN];
-  r_substitute (layer->arc_tree, (BoxTypePtr) & layer->Arc[layer->ArcN],
-		(BoxTypePtr) Arc);
-  }
-  memset (&layer->Arc[layer->ArcN], 0, sizeof (ArcType));
+
   if (!lay->arc_tree)
     lay->arc_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (lay->arc_tree, (BoxType *)arc, 0);
@@ -346,22 +330,18 @@ MoveArcToBuffer (LayerType *layer, ArcType *Arc)
  * moves a text to buffer without allocating memory for the name
  */
 static void *
-MoveTextToBuffer (LayerType *layer, TextType *Text)
+MoveTextToBuffer (LayerType *layer, TextType *text)
 {
   LayerType *lay = &Dest->Layer[GetLayerNumber (Source, layer)];
-  TextTypePtr text;
 
-  r_delete_entry (layer->text_tree, (BoxType *)Text);
-  RestoreToPolygon (Source, TEXT_TYPE, layer, Text);
-  text = GetTextMemory (lay);
-  *text = *Text;
-  if (Text != &layer->Text[--layer->TextN])
-  {
-  *Text = layer->Text[layer->TextN];
-  r_substitute (layer->text_tree, (BoxTypePtr) & layer->Text[layer->TextN],
-		(BoxTypePtr) Text);
-  }
-  memset (&layer->Text[layer->TextN], 0, sizeof (TextType));
+  r_delete_entry (layer->text_tree, (BoxType *)text);
+  RestoreToPolygon (Source, TEXT_TYPE, layer, text);
+
+  layer->Text = g_list_remove (layer->Text, text);
+  layer->TextN --;
+  lay->Text = g_list_append (lay->Text, text);
+  lay->TextN ++;
+
   if (!lay->text_tree)
     lay->text_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (lay->text_tree, (BoxType *)text, 0);
@@ -373,23 +353,19 @@ MoveTextToBuffer (LayerType *layer, TextType *Text)
  * moves a polygon to buffer. Doesn't allocate memory for the points
  */
 static void *
-MovePolygonToBuffer (LayerType *layer, PolygonType *Polygon)
+MovePolygonToBuffer (LayerType *layer, PolygonType *polygon)
 {
   LayerType *lay = &Dest->Layer[GetLayerNumber (Source, layer)];
-  PolygonTypePtr polygon;
 
-  r_delete_entry (layer->polygon_tree, (BoxType *)Polygon);
-  polygon = GetPolygonMemory (lay);
-  *polygon = *Polygon;
+  r_delete_entry (layer->polygon_tree, (BoxType *)polygon);
+
+  layer->Polygon = g_list_remove (layer->Polygon, polygon);
+  layer->PolygonN --;
+  lay->Polygon = g_list_append (lay->Polygon, polygon);
+  lay->PolygonN ++;
+
   CLEAR_FLAG (FOUNDFLAG, polygon);
-  if (Polygon != &layer->Polygon[--layer->PolygonN])
-  {
-  *Polygon = layer->Polygon[layer->PolygonN];
-  r_substitute (layer->polygon_tree,
-		(BoxTypePtr) & layer->Polygon[layer->PolygonN],
-		(BoxTypePtr) Polygon);
-  }
-  memset (&layer->Polygon[layer->PolygonN], 0, sizeof (PolygonType));
+
   if (!lay->polygon_tree)
     lay->polygon_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (lay->polygon_tree, (BoxType *)polygon, 0);
@@ -400,36 +376,29 @@ MovePolygonToBuffer (LayerType *layer, PolygonType *Polygon)
  * moves a element to buffer without allocating memory for pins/names
  */
 static void *
-MoveElementToBuffer (ElementType *Element)
+MoveElementToBuffer (ElementType *element)
 {
-  ElementTypePtr element;
-  int i;
-
   /*
-   * Two steps at once:  Delete the element from the source (remove it
-   * from trees, restore to polygons) and simultaneously adjust its
-   * component pointers to the new storage in Dest
+   * Delete the element from the source (remove it from trees,
+   * restore to polygons)
    */
-  r_delete_element (Source, Element);
-  element = GetElementMemory (Dest);
-  *element = *Element;
+  r_delete_element (Source, element);
+
+  Source->Element = g_list_remove (Source->Element, element);
+  Source->ElementN --;
+  Dest->Element = g_list_append (Dest->Element, element);
+  Dest->ElementN ++;
+
   PIN_LOOP (element);
   {
-    RestoreToPolygon(Source, PIN_TYPE, Element, pin);
+    RestoreToPolygon(Source, PIN_TYPE, element, pin);
     CLEAR_FLAG (WARNFLAG | FOUNDFLAG, pin);
-    pin->Element = element;
   }
   END_LOOP;
   PAD_LOOP (element);
   {
-    RestoreToPolygon(Source, PAD_TYPE, Element, pad);
+    RestoreToPolygon(Source, PAD_TYPE, element, pad);
     CLEAR_FLAG (WARNFLAG | FOUNDFLAG, pad);
-    pad->Element = element;
-  }
-  END_LOOP;
-  ELEMENTTEXT_LOOP (element);
-  {
-    text->Element = element;
   }
   END_LOOP;
   SetElementBoundingBox (Dest, element, &PCB->Font);
@@ -447,41 +416,7 @@ MoveElementToBuffer (ElementType *Element)
   }
   END_LOOP;
 
-  /*
-   * Now compact the Source's Element array by moving the last element
-   * to the hole created by the removal above.  Then make a pass adjusting
-   * *its* component pointers.  Confusingly, this element (which is of no
-   * particular relation to this removal) becomes `Element' while the
-   * original Element is now in `element'.
-   */
-  if (Element != &Source->Element[--Source->ElementN])
-    {
-  *Element = Source->Element[Source->ElementN];
-  r_substitute (Source->element_tree,
-		(BoxType *) & Source->Element[Source->ElementN],
-		(BoxType *) Element);
-  for (i = 0; i < MAX_ELEMENTNAMES; i++)
-    r_substitute (Source->name_tree[i],
-		  (BoxType *) & Source->Element[Source->ElementN].Name[i],
-		  (BoxType *) & Element->Name[i]);
-  ELEMENTTEXT_LOOP (Element);
-  {
-    text->Element = Element;
-  }
-  END_LOOP;
-  PIN_LOOP (Element);
-  {
-    pin->Element = Element;
-  }
-  END_LOOP;
-  PAD_LOOP (Element);
-  {
-    pad->Element = Element;
-  }
-  END_LOOP;
-  }
-  memset (&Source->Element[Source->ElementN], 0, sizeof (ElementType));
-  return (element);
+  return element;
 }
 
 /* ---------------------------------------------------------------------------
@@ -563,7 +498,7 @@ LoadElementToBuffer (BufferTypePtr Buffer, char *Name, bool FromFile)
 	  SetBufferBoundingBox (Buffer);
 	  if (Buffer->Data->ElementN)
 	    {
-	      element = &(Buffer->Data->Element[0]);
+	      element = Buffer->Data->Element->data;
 	      Buffer->X = element->MarkX;
 	      Buffer->Y = element->MarkY;
 	    }
@@ -580,7 +515,7 @@ LoadElementToBuffer (BufferTypePtr Buffer, char *Name, bool FromFile)
       if (!ParseLibraryEntry (Buffer->Data, Name)
 	  && Buffer->Data->ElementN != 0)
 	{
-	  element = &(Buffer->Data->Element[0]);
+	  element = Buffer->Data->Element->data;
 
 	  /* always add elements using top-side coordinates */
 	  if (Settings.ShowSolderSide)
@@ -896,7 +831,7 @@ LoadFootprint (int argc, char **argv, int x, int y)
       return 1;
     }
 
-  e = & PASTEBUFFER->Data->Element[0];
+  e = PASTEBUFFER->Data->Element->data;
 
   if (e->Name[0].TextString)
     free (e->Name[0].TextString);
@@ -938,7 +873,7 @@ SmashBufferElement (BufferTypePtr Buffer)
    * around for us to smash bits off it.  It then becomes our responsibility,
    * however, to free the single element when we're finished with it.
    */
-  element = &Buffer->Data->Element[0];
+  element = Buffer->Data->Element->data;
   Buffer->Data->Element = NULL;
   Buffer->Data->ElementN = 0;
   ClearBuffer (Buffer);
diff --git a/src/create.c b/src/create.c
index 6409139..e4eeb0b 100644
--- a/src/create.c
+++ b/src/create.c
@@ -713,16 +713,11 @@ CreateNewArcInElement (ElementTypePtr Element,
 		       BDimension Width, BDimension Height,
 		       int Angle, int Delta, BDimension Thickness)
 {
-  ArcTypePtr arc = Element->Arc;
+  ArcType *arc;
 
-  /* realloc new memory if necessary and clear it */
-  if (Element->ArcN >= Element->ArcMax)
-    {
-      Element->ArcMax += STEP_ELEMENTARC;
-      arc = (ArcTypePtr)realloc (arc, Element->ArcMax * sizeof (ArcType));
-      Element->Arc = arc;
-      memset (arc + Element->ArcN, 0, STEP_ELEMENTARC * sizeof (ArcType));
-    }
+  arc = g_slice_new0 (ArcType);
+  Element->Arc = g_list_append (Element->Arc, arc);
+  Element->ArcN ++;
 
   /* set Delta (0,360], StartAngle in [0,360) */
   if ((Delta = Delta % 360) == 0)
@@ -736,7 +731,6 @@ CreateNewArcInElement (ElementTypePtr Element,
     Angle += 360;
 
   /* copy values */
-  arc = arc + Element->ArcN++;
   arc->X = X;
   arc->Y = Y;
   arc->Width = Width;
@@ -745,7 +739,7 @@ CreateNewArcInElement (ElementTypePtr Element,
   arc->Delta = Delta;
   arc->Thickness = Thickness;
   arc->ID = ID++;
-  return (arc);
+  return arc;
 }
 
 /* ---------------------------------------------------------------------------
@@ -757,21 +751,16 @@ CreateNewLineInElement (ElementTypePtr Element,
 			LocationType X2, LocationType Y2,
 			BDimension Thickness)
 {
-  LineTypePtr line = Element->Line;
+  LineType *line;
 
   if (Thickness == 0)
-    return (NULL);
-  /* realloc new memory if necessary and clear it */
-  if (Element->LineN >= Element->LineMax)
-    {
-      Element->LineMax += STEP_ELEMENTLINE;
-      line = (LineTypePtr)realloc (line, Element->LineMax * sizeof (LineType));
-      Element->Line = line;
-      memset (line + Element->LineN, 0, STEP_ELEMENTLINE * sizeof (LineType));
-    }
+    return NULL;
+
+  line = g_slice_new0 (LineType);
+  Element->Line = g_list_append (Element->Line, line);
+  Element->LineN ++;
 
   /* copy values */
-  line = line + Element->LineN++;
   line->Point1.X = X1;
   line->Point1.Y = Y1;
   line->Point2.X = X2;
@@ -779,7 +768,7 @@ CreateNewLineInElement (ElementTypePtr Element,
   line->Thickness = Thickness;
   line->Flags = NoFlags ();
   line->ID = ID++;
-  return (line);
+  return line;
 }
 
 /* ---------------------------------------------------------------------------
diff --git a/src/djopt.c b/src/djopt.c
index 842ed47..185d7e8 100644
--- a/src/djopt.c
+++ b/src/djopt.c
@@ -760,28 +760,14 @@ static void
 remove_line (line_s * l)
 {
   int i, j;
-  line_s *l2;
-  LineType *from = 0, *to = 0;
   LayerType *layer = &(PCB->Data->Layer[l->layer]);
 
   check (0, 0);
 
   if (l->line)
-    {
-      /* compensate for having line pointers rearranged */
-      from = &(layer->Line[layer->LineN - 1]);
-      to = l->line;
-      RemoveLine (layer, l->line);
-    }
+    RemoveLine (layer, l->line);
 
   DELETE (l);
-  for (l2 = lines; l2; l2 = l2->next)
-    {
-      if (DELETED (l2))
-	continue;
-      if (l2->line == from)
-	l2->line = to;
-    }
 
   for (i = 0, j = 0; i < l->s->n_lines; i++)
     if (l->s->lines[i] != l)
@@ -798,52 +784,20 @@ remove_line (line_s * l)
 static void
 move_line_to_layer (line_s * l, int layer)
 {
-  line_s *l2;
   LayerType *ls, *ld;
-  LineType *from = 0, *to = 0;
-  LineType *oldbase = 0, *newbase = 0, *oldend;
-  LineType *newline;
 
   ls = LAYER_PTR (l->layer);
-  from = &(ls->Line[ls->LineN - 1]);
-  to = l->line;
-
   ld = LAYER_PTR (layer);
-  oldbase = ld->Line;
-  oldend = oldbase + ld->LineN;
-
-  newline = (LineType *) MoveObjectToLayer (LINE_TYPE, ls, l->line, 0, ld, 0);
-  newbase = ld->Line;
 
-  for (l2 = lines; l2; l2 = l2->next)
-    {
-      if (DELETED (l2))
-	continue;
-      if (l2->line == from)
-	l2->line = to;
-      if (l2->line >= oldbase && l2->line < oldend)
-	l2->line += newbase - oldbase;
-    }
-
-  l->line = newline;
+  MoveObjectToLayer (LINE_TYPE, ls, l->line, 0, ld, 0);
   l->layer = layer;
 }
 
 static void
 remove_via_at (corner_s * c)
 {
-  corner_s *cc;
-  PinType *from = PCB->Data->Via + PCB->Data->ViaN - 1;
-  PinType *to = c->via;
   RemoveObject (VIA_TYPE, c->via, 0, 0);
   c->via = 0;
-  for (cc = corners; cc; cc = cc->next)
-    {
-      if (DELETED (cc))
-	continue;
-      if (cc->via == from)
-	cc->via = to;
-    }
 }
 
 static void
diff --git a/src/draw.c b/src/draw.c
index 5409249..e1ae2dc 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -774,15 +774,15 @@ DrawEMark (ElementTypePtr e, LocationType X, LocationType Y,
   if (!PCB->InvisibleObjectsOn && invisible)
     return;
 
-  if (e->PinN)
+  if (e->Pin != NULL)
     {
-      PinType *pin0 = &e->Pin[0];
+      PinType *pin0 = e->Pin->data;
       mark_size = MIN (mark_size, pin0->Thickness / 2);
     }
 
-  if (e->PadN)
+  if (e->Pad != NULL)
     {
-      PadType *pad0 = &e->Pad[0];
+      PadType *pad0 = e->Pad->data;
       mark_size = MIN (mark_size, pad0->Thickness / 2);
     }
 
diff --git a/src/file.c b/src/file.c
index 4c40162..973db62 100644
--- a/src/file.c
+++ b/src/file.c
@@ -452,7 +452,7 @@ PostLoadElementPCB ()
 
   CreateNewPCBPost (yyPCB, 0);
   ParseGroupString("1,c:2,s", &yyPCB->LayerGroups, yyData->LayerN);
-  e = yyPCB->Data->Element; /* we know there's only one */
+  e = yyPCB->Data->Element->data; /* we know there's only one */
   PCB = yyPCB;
   MoveElementLowLevel (yyPCB->Data,
 		       e, -e->BoundingBox.X1, -e->BoundingBox.Y1);
@@ -601,11 +601,11 @@ WritePCBFontData (FILE * FP)
 static void
 WriteViaData (FILE * FP, DataTypePtr Data)
 {
-  int n;
+  GList *iter;
   /* write information about vias */
-  for (n = 0; n < Data->ViaN; n++)
+  for (iter = Data->Via; iter != NULL; iter = g_list_next (iter))
     {
-      PinTypePtr via = &Data->Via[n];
+      PinType *via = iter->data;
       fprintf (FP, "Via[%i %i %i %i %i %i ",
 	       via->X, via->Y,
 	       via->Thickness, via->Clearance, via->Mask, via->DrillingHole);
@@ -620,11 +620,11 @@ WriteViaData (FILE * FP, DataTypePtr Data)
 static void
 WritePCBRatData (FILE * FP)
 {
-  int n;
+  GList *iter;
   /* write information about rats */
-  for (n = 0; n < PCB->Data->RatN; n++)
+  for (iter = PCB->Data->Rat; iter != NULL; iter = g_list_next (iter))
     {
-      RatTypePtr line = &PCB->Data->Rat[n];
+      RatType *line = iter->data;
       fprintf (FP, "Rat[%i %i %i %i %i %i ",
 	       (int) line->Point1.X, (int) line->Point1.Y,
 	       (int) line->group1, (int) line->Point2.X,
@@ -672,10 +672,11 @@ WritePCBNetlistData (FILE * FP)
 static void
 WriteElementData (FILE * FP, DataTypePtr Data)
 {
-  int n, p;
-  for (n = 0; n < Data->ElementN; n++)
+  GList *n, *p;
+  for (n = Data->Element; n != NULL; n = g_list_next (n))
     {
-      ElementTypePtr element = &Data->Element[n];
+      ElementType *element = n->data;
+
       /* only non empty elements */
       if (!element->LineN && !element->PinN && !element->ArcN
 	  && !element->PadN)
@@ -699,9 +700,9 @@ WriteElementData (FILE * FP, DataTypePtr Data)
 	       (int) DESCRIPTION_TEXT (element).Scale,
 	       F2S (&(DESCRIPTION_TEXT (element)), ELEMENTNAME_TYPE));
       WriteAttributeList (FP, &element->Attributes, "\t");
-      for (p = 0; p < element->PinN; p++)
+      for (p = element->Pin; p != NULL; p = g_list_next (p))
 	{
-	  PinTypePtr pin = &element->Pin[p];
+	  PinType *pin = p->data;
 	  fprintf (FP, "\tPin[%i %i %i %i %i %i ",
 		   (int) (pin->X - element->MarkX),
 		   (int) (pin->Y - element->MarkY),
@@ -712,9 +713,9 @@ WriteElementData (FILE * FP, DataTypePtr Data)
 	  PrintQuotedString (FP, (char *)EMPTY (pin->Number));
 	  fprintf (FP, " %s]\n", F2S (pin, PIN_TYPE));
 	}
-      for (p = 0; p < element->PadN; p++)
+      for (p = element->Pad; p != NULL; p = g_list_next (p))
 	{
-	  PadTypePtr pad = &element->Pad[p];
+	  PadType *pad = p->data;
 	  fprintf (FP, "\tPad[%i %i %i %i %i %i %i ",
 		   (int) (pad->Point1.X - element->MarkX),
 		   (int) (pad->Point1.Y - element->MarkY),
@@ -727,9 +728,9 @@ WriteElementData (FILE * FP, DataTypePtr Data)
 	  PrintQuotedString (FP, (char *)EMPTY (pad->Number));
 	  fprintf (FP, " %s]\n", F2S (pad, PAD_TYPE));
 	}
-      for (p = 0; p < element->LineN; p++)
+      for (p = element->Line; p != NULL; p = g_list_next (p))
 	{
-	  LineTypePtr line = &element->Line[p];
+	  LineType *line = p->data;
 	  fprintf (FP,
 		   "\tElementLine [%i %i %i %i %i]\n",
 		   (int) (line->Point1.X -
@@ -741,9 +742,9 @@ WriteElementData (FILE * FP, DataTypePtr Data)
 		   (int) (line->Point2.Y -
 			  element->MarkY), (int) line->Thickness);
 	}
-      for (p = 0; p < element->ArcN; p++)
+      for (p = element->Arc; p != NULL; p = g_list_next (p))
 	{
-	  ArcTypePtr arc = &element->Arc[p];
+	  ArcType *arc = p->data;
 	  fprintf (FP,
 		   "\tElementArc [%i %i %i %i %i %i %i]\n",
 		   (int) (arc->X - element->MarkX),
@@ -762,7 +763,7 @@ WriteElementData (FILE * FP, DataTypePtr Data)
 static void
 WriteLayerData (FILE * FP, Cardinal Number, LayerTypePtr layer)
 {
-  int n;
+  GList *n;
   /* write information about non empty layers */
   if (layer->LineN || layer->ArcN || layer->TextN || layer->PolygonN ||
       (layer->Name && *layer->Name))
@@ -772,36 +773,36 @@ WriteLayerData (FILE * FP, Cardinal Number, LayerTypePtr layer)
       fputs (")\n(\n", FP);
       WriteAttributeList (FP, &layer->Attributes, "\t");
 
-      for (n = 0; n < layer->LineN; n++)
+      for (n = layer->Line; n != NULL; n = g_list_next (n))
 	{
-	  LineTypePtr line = &layer->Line[n];
+	  LineType *line = n->data;
 	  fprintf (FP, "\tLine[%i %i %i %i %i %i %s]\n",
 		   (int) line->Point1.X, (int) line->Point1.Y,
 		   (int) line->Point2.X, (int) line->Point2.Y,
 		   (int) line->Thickness, (int) line->Clearance,
 		   F2S (line, LINE_TYPE));
 	}
-      for (n = 0; n < layer->ArcN; n++)
+      for (n = layer->Arc; n != NULL; n = g_list_next (n))
 	{
-	  ArcTypePtr arc = &layer->Arc[n];
+	  ArcType *arc = n->data;
 	  fprintf (FP, "\tArc[%i %i %i %i %i %i %i %i %s]\n",
 		   (int) arc->X, (int) arc->Y, (int) arc->Width,
 		   (int) arc->Height, (int) arc->Thickness,
 		   (int) arc->Clearance, (int) arc->StartAngle,
 		   (int) arc->Delta, F2S (arc, ARC_TYPE));
 	}
-      for (n = 0; n < layer->TextN; n++)
+      for (n = layer->Text; n != NULL; n = g_list_next (n))
 	{
-	  TextTypePtr text = &layer->Text[n];
+	  TextType *text = n->data;
 	  fprintf (FP, "\tText[%i %i %i %i ",
 		   (int) text->X, (int) text->Y,
 		   (int) text->Direction, (int) text->Scale);
 	  PrintQuotedString (FP, (char *)EMPTY (text->TextString));
 	  fprintf (FP, " %s]\n", F2S (text, TEXT_TYPE));
 	}
-      for (n = 0; n < layer->PolygonN; n++)
+      for (n = layer->Polygon; n != NULL; n = g_list_next (n))
 	{
-	  PolygonTypePtr polygon = &layer->Polygon[n];
+	  PolygonType *polygon = n->data;
 	  int p, i = 0;
 	  Cardinal hole = 0;
 	  fprintf (FP, "\tPolygon(%s)\n\t(", F2S (polygon, POLYGON_TYPE));
diff --git a/src/find.c b/src/find.c
index b740890..eb4cac2 100644
--- a/src/find.c
+++ b/src/find.c
@@ -1935,15 +1935,14 @@ LookupLOConnectionsToArc (ArcTypePtr Arc, Cardinal LayerGroup)
   /* loop over all layers of the group */
   for (entry = 0; entry < PCB->LayerGroups.Number[LayerGroup]; entry++)
     {
-      Cardinal layer, i;
+      Cardinal layer;
+      GList *i;
 
       layer = PCB->LayerGroups.Entries[LayerGroup][entry];
 
       /* handle normal layers */
       if (layer < max_copper_layer)
         {
-          PolygonTypePtr polygon;
-
           info.layer = layer;
           /* add arcs */
           if (setjmp (info.env) == 0)
@@ -1959,12 +1958,14 @@ LookupLOConnectionsToArc (ArcTypePtr Arc, Cardinal LayerGroup)
             return true;
 
           /* now check all polygons */
-          i = 0;
-          polygon = PCB->Data->Layer[layer].Polygon;
-          for (; i < PCB->Data->Layer[layer].PolygonN; i++, polygon++)
-            if (!TEST_FLAG (TheFlag, polygon) && IsArcInPolygon (Arc, polygon)
-                && ADD_POLYGON_TO_LIST (layer, polygon))
-              return true;
+          for (i = PCB->Data->Layer[layer].Polygon;
+               i != NULL; i = g_list_next (i))
+            {
+              PolygonType *polygon = i->data;
+              if (!TEST_FLAG (TheFlag, polygon) && IsArcInPolygon (Arc, polygon)
+                  && ADD_POLYGON_TO_LIST (layer, polygon))
+                return true;
+            }
         }
       else
         {
@@ -2080,8 +2081,6 @@ LookupLOConnectionsToLine (LineTypePtr Line, Cardinal LayerGroup,
       /* handle normal layers */
       if (layer < max_copper_layer)
         {
-          PolygonTypePtr polygon;
-
           info.layer = layer;
           /* add lines */
           if (setjmp (info.env) == 0)
@@ -2098,13 +2097,16 @@ LookupLOConnectionsToLine (LineTypePtr Line, Cardinal LayerGroup,
           /* now check all polygons */
           if (PolysTo)
             {
-              Cardinal i = 0;
-              polygon = PCB->Data->Layer[layer].Polygon;
-              for (; i < PCB->Data->Layer[layer].PolygonN; i++, polygon++)
-                if (!TEST_FLAG
-                    (TheFlag, polygon) && IsLineInPolygon (Line, polygon)
-                    && ADD_POLYGON_TO_LIST (layer, polygon))
-                  return true;
+              GList *i;
+              for (i = PCB->Data->Layer[layer].Polygon;
+                   i != NULL; i = g_list_next (i))
+                {
+                  PolygonType *polygon = i->data;
+                  if (!TEST_FLAG
+                      (TheFlag, polygon) && IsLineInPolygon (Line, polygon)
+                      && ADD_POLYGON_TO_LIST (layer, polygon))
+                    return true;
+                }
             }
         }
       else
@@ -2162,7 +2164,6 @@ static bool
 LOTouchesLine (LineTypePtr Line, Cardinal LayerGroup)
 {
   Cardinal entry;
-  Cardinal i;
   struct lo_info info;
 
 
@@ -2179,7 +2180,7 @@ LOTouchesLine (LineTypePtr Line, Cardinal LayerGroup)
       /* handle normal layers */
       if (layer < max_copper_layer)
         {
-          PolygonTypePtr polygon;
+          GList *i;
 
           /* find the first line that touches coordinates */
 
@@ -2195,12 +2196,14 @@ LOTouchesLine (LineTypePtr Line, Cardinal LayerGroup)
             return (true);
 
           /* now check all polygons */
-          i = 0;
-          polygon = PCB->Data->Layer[layer].Polygon;
-          for (; i < PCB->Data->Layer[layer].PolygonN; i++, polygon++)
-            if (!TEST_FLAG (TheFlag, polygon)
-                && IsLineInPolygon (Line, polygon))
-              return (true);
+          for (i = PCB->Data->Layer[layer].Polygon;
+               i != NULL; i = g_list_next (i))
+            {
+              PolygonType *polygon = i->data;
+              if (!TEST_FLAG (TheFlag, polygon)
+                  && IsLineInPolygon (Line, polygon))
+                return (true);
+            }
         }
       else
         {
@@ -2571,23 +2574,25 @@ LookupLOConnectionsToPolygon (PolygonTypePtr Polygon, Cardinal LayerGroup)
 /* loop over all layers of the group */
   for (entry = 0; entry < PCB->LayerGroups.Number[LayerGroup]; entry++)
     {
-      Cardinal layer, i;
+      Cardinal layer;
 
       layer = PCB->LayerGroups.Entries[LayerGroup][entry];
 
       /* handle normal layers */
       if (layer < max_copper_layer)
         {
-          PolygonTypePtr polygon;
+          GList *i;
 
           /* check all polygons */
-
-          polygon = PCB->Data->Layer[layer].Polygon;
-          for (i = 0; i < PCB->Data->Layer[layer].PolygonN; i++, polygon++)
-            if (!TEST_FLAG (TheFlag, polygon)
-                && IsPolygonInPolygon (polygon, Polygon)
-                && ADD_POLYGON_TO_LIST (layer, polygon))
-              return true;
+          for (i = PCB->Data->Layer[layer].Polygon;
+               i != NULL; i = g_list_next (i))
+            {
+              PolygonType *polygon = i->data;
+              if (!TEST_FLAG (TheFlag, polygon)
+                  && IsPolygonInPolygon (polygon, Polygon)
+                  && ADD_POLYGON_TO_LIST (layer, polygon))
+                return true;
+            }
 
           info.layer = layer;
           /* check all lines */
diff --git a/src/fontmode.c b/src/fontmode.c
index eae2545..69d61ea 100644
--- a/src/fontmode.c
+++ b/src/fontmode.c
@@ -173,6 +173,7 @@ FontSave (int argc, char **argv, int Ux, int Uy)
   FontTypePtr font;
   SymbolTypePtr symbol;
   int i;
+  GList *ii;
   LayerTypePtr lfont, lwidth;
 
   font = &PCB->Font;
@@ -186,9 +187,9 @@ FontSave (int argc, char **argv, int Ux, int Uy)
       font->Symbol[i].Width = 0;
     }
 
-  for (i = 0; i < lfont->LineN; i++)
+  for (ii = lfont->Line; ii != NULL; ii = g_list_next (ii))
     {
-      LineTypePtr l = &lfont->Line[i];
+      LineType *l = ii->data;
       int x1 = l->Point1.X;
       int y1 = l->Point1.Y;
       int x2 = l->Point2.X;
@@ -214,9 +215,9 @@ FontSave (int argc, char **argv, int Ux, int Uy)
       CreateNewLineInSymbol (symbol, x1, y1, x2, y2, l->Thickness);
     }
 
-  for (i = 0; i < lwidth->LineN; i++)
+  for (ii = lwidth->Line; ii != NULL; ii = g_list_next (ii))
     {
-      LineTypePtr l = &lwidth->Line[i];
+      LineType *l = ii->data;
       int x1 = l->Point1.X;
       int y1 = l->Point1.Y;
       int ox, oy, s;
diff --git a/src/global.h b/src/global.h
index cb2b92d..9ad5331 100644
--- a/src/global.h
+++ b/src/global.h
@@ -286,13 +286,11 @@ typedef struct			/* holds information about one layer */
   Cardinal LineN,		/* number of lines */
     TextN,			/* labels */
     PolygonN,			/* polygons */
-    ArcN,			/* and arcs */
-    LineMax,			/* max number from malloc() */
-    TextMax, PolygonMax, ArcMax;
-  LineTypePtr Line;		/* pointer to additional structures */
-  TextTypePtr Text;
-  PolygonTypePtr Polygon;
-  ArcTypePtr Arc;
+    ArcN;			/* and arcs */
+  GList *Line;
+  GList *Text;
+  GList *Polygon;
+  GList *Arc;
   rtree_t *line_tree, *text_tree, *polygon_tree, *arc_tree;
   bool On;			/* visible flag */
   char *Color,			/* color */
@@ -337,12 +335,14 @@ typedef struct
   /* see macro.h */
   LocationType MarkX,		/* position mark */
     MarkY;
-  Cardinal PinN,		/* number of pins, lines and arcs */
-    PinMax, PadN, PadMax, LineN, LineMax, ArcN, ArcMax;
-  PinTypePtr Pin;		/* pin description */
-  PadTypePtr Pad;		/* pad description of SMD components */
-  LineTypePtr Line;
-  ArcTypePtr Arc;
+  Cardinal PinN;		/* number of pins */
+  Cardinal PadN;		/* number of pads */
+  Cardinal LineN;		/* number of lines */
+  Cardinal ArcN;		/* number of arcs */
+  GList *Pin;
+  GList *Pad;
+  GList *Line;
+  GList *Arc;
   BoxType VBox;
   AttributeListType Attributes;
 } ElementType, *ElementTypePtr, **ElementTypeHandle;
@@ -372,15 +372,12 @@ typedef struct			/* complete set of symbols */
 typedef struct			/* holds all objects */
 {
   Cardinal ViaN,		/* number of vias */
-    ViaMax,			/* max number from malloc() */
     ElementN,			/* and elements */
-    ElementMax,			/* max number from malloc() */
-    RatN,			/* and rat-lines */
-    RatMax;
+    RatN;			/* and rat-lines */
   int LayerN;			/* number of layers in this board */
-  PinTypePtr Via;		/* pointer to object data */
-  ElementTypePtr Element;
-  RatTypePtr Rat;
+  GList *Via;
+  GList *Element;
+  GList *Rat;
   rtree_t *via_tree, *element_tree, *pin_tree, *pad_tree, *name_tree[3],	/* for element names */
    *rat_tree;
   struct PCBType *pcb;
diff --git a/src/macro.h b/src/macro.h
index 1fb6584..e990d4a 100644
--- a/src/macro.h
+++ b/src/macro.h
@@ -171,25 +171,29 @@ extern int mem_any_set (unsigned char *, int);
  * all data is relativ to an objects name 'top' which can be either
  * PCB or PasteBuffer
  */
-#define END_LOOP  }} while (0)
-
-#define STYLE_LOOP(top)  do {		\
-	Cardinal	n;			\
-	RouteStyleTypePtr	style;			\
-	for (n = 0; n < NUM_STYLES; n++)	\
-	{					\
-		style = &(top)->RouteStyle[n]
-
-#define	VIA_LOOP(top)	do { 		\
-	Cardinal	n, sn;			\
-	PinTypePtr	via;			\
-        for (sn = (top)->ViaN, n = 0; (top)->ViaN > 0 && n < (top)->ViaN ; \
-		n += 1 + (top)->ViaN - sn, sn = (top)->ViaN)   \
-	{					\
-		via = &(top)->Via[n]
+#define END_LOOP  }                                                 \
+    g_list_free (__copy);                                           \
+  } while (0)
+
+#define STYLE_LOOP(top)  do {                                       \
+        GList *__copy = NULL; /* DUMMY */                           \
+        Cardinal n;                                                 \
+        RouteStyleTypePtr style;                                    \
+        for (n = 0; n < NUM_STYLES; n++)                            \
+        {                                                           \
+                style = &(top)->RouteStyle[n]
+
+#define VIA_LOOP(top) do {                                          \
+  GList *__iter;                                                    \
+  GList *__copy = g_list_copy ((top)->Via);                         \
+  Cardinal n;                                                       \
+  for (__iter = __copy, n = 0; __iter != NULL;                      \
+       __iter = g_list_next (__iter), n++) {                        \
+    PinType *via = __iter->data;
 
 #define DRILL_LOOP(top) do             {               \
         Cardinal        n;                                      \
+        GList *__copy = NULL; /* DUMMY */                       \
         DrillTypePtr    drill;                                  \
         for (n = 0; (top)->DrillN > 0 && n < (top)->DrillN; n++)                        \
         {                                                       \
@@ -197,6 +201,7 @@ extern int mem_any_set (unsigned char *, int);
 
 #define NETLIST_LOOP(top) do   {                         \
         Cardinal        n;                                      \
+        GList *__copy = NULL; /* DUMMY */                       \
         NetListTypePtr   netlist;                               \
         for (n = (top)->NetListN-1; n != -1; n--)               \
         {                                                       \
@@ -204,6 +209,7 @@ extern int mem_any_set (unsigned char *, int);
 
 #define NET_LOOP(top) do   {                             \
         Cardinal        n;                                      \
+        GList *__copy = NULL; /* DUMMY */                       \
         NetTypePtr   net;                                       \
         for (n = (top)->NetN-1; n != -1; n--)                   \
         {                                                       \
@@ -211,100 +217,112 @@ extern int mem_any_set (unsigned char *, int);
 
 #define CONNECTION_LOOP(net) do {                         \
         Cardinal        n;                                      \
+        GList *__copy = NULL; /* DUMMY */                       \
         ConnectionTypePtr       connection;                     \
         for (n = (net)->ConnectionN-1; n != -1; n--)            \
         {                                                       \
                 connection = & (net)->Connection[n]
 
-#define	ELEMENT_LOOP(top) do	{ 		\
-	Cardinal 		n;			\
-	ElementTypePtr	element;			\
-	for (n = (top)->ElementN-1; n != -1; n--)	\
-	{						\
-		element = &(top)->Element[n]
-
-#define RAT_LOOP(top) do	{			\
-	Cardinal	n;				\
-	RatTypePtr	line;				\
-	for (n = (top)->RatN-1; n != -1; n--)		\
-	{						\
-		line = &(top)->Rat[n]
-
+#define ELEMENT_LOOP(top) do {                                      \
+  GList *__iter;                                                    \
+  GList *__copy = g_list_reverse (g_list_copy ((top)->Element));    \
+  Cardinal n;                                                       \
+  for (__iter = __copy, n = (top)->ElementN - 1; __iter != NULL;    \
+       __iter = g_list_next (__iter), n--) {                        \
+    ElementType *element = __iter->data;
+
+#define RAT_LOOP(top) do {                                          \
+  GList *__iter;                                                    \
+  GList *__copy = g_list_reverse (g_list_copy ((top)->Rat));        \
+  Cardinal n;                                                       \
+  for (__iter = __copy, n = (top)->RatN - 1; __iter != NULL;        \
+       __iter = g_list_next (__iter), n--) {                        \
+    RatType *line = __iter->data;
 
 #define	ELEMENTTEXT_LOOP(element) do { 	\
 	Cardinal	n;				\
+	GList *__copy = NULL; /* DUMMY */		\
 	TextTypePtr	text;				\
 	for (n = MAX_ELEMENTNAMES-1; n != -1; n--)	\
 	{						\
 		text = &(element)->Name[n]
 
-#define	ELEMENTNAME_LOOP(element) do	{ 		\
+
+#define	ELEMENTNAME_LOOP(element) do	{ 			\
+	GList *__copy = NULL; /* DUMMY */			\
 	Cardinal	n;					\
 	char		*textstring;				\
 	for (n = MAX_ELEMENTNAMES-1; n != -1; n--)		\
 	{							\
 		textstring = (element)->Name[n].TextString
 
-#define	PIN_LOOP(element)	do { 		\
-	Cardinal	n, sn;				\
-	PinTypePtr	pin;				\
-        for (sn = (element)->PinN, n = 0; (element)->PinN > 0 && n < (element)->PinN ; \
-		n += 1 + (element)->PinN - sn, sn = (element)->PinN)   \
-	{						\
-		pin = &(element)->Pin[n]
-
-#define	PAD_LOOP(element)	do { 		\
-	Cardinal	n, sn;				\
-	PadTypePtr	pad;				\
-        for (sn = (element)->PadN, n = 0; (element)->PadN > 0 && n < (element)->PadN ; \
-		 sn == (element)->PadN ? n++ : 0)   \
-	{						\
-		pad = &(element)->Pad[n]
-
-#define	ARC_LOOP(element)	do { 		\
-	Cardinal	n;				\
-	ArcTypePtr	arc;				\
-	for (n = (element)->ArcN-1; n != -1; n--)	\
-	{						\
-		arc = &(element)->Arc[n]
-
-#define	ELEMENTLINE_LOOP(element)	do { 	\
-	Cardinal	n;				\
-	LineTypePtr	line;				\
-	for (n = (element)->LineN-1; n != -1; n--)	\
-	{						\
-		line = &(element)->Line[n]
-
-#define	ELEMENTARC_LOOP(element)	do { 	\
-	Cardinal	n;				\
-	ArcTypePtr	arc;				\
-	for (n = (element)->ArcN-1; n != -1; n--)	\
-	{						\
-		arc = &(element)->Arc[n]
-
-#define	LINE_LOOP(layer) do {			\
-	Cardinal		n;			\
-	LineTypePtr		line;			\
-	for (n = (layer)->LineN-1; n != -1; n--)	\
-	{						\
-		line = &(layer)->Line[n]
-
-#define	TEXT_LOOP(layer) do {			\
-	Cardinal		n;			\
-	TextTypePtr		text;			\
-	for (n = (layer)->TextN-1; n != -1; n--)	\
-	{						\
-		text = &(layer)->Text[n]
-
-#define	POLYGON_LOOP(layer) do {			\
-	Cardinal		n;			\
-	PolygonTypePtr	polygon;			\
-	for (n = (layer)->PolygonN-1; n != -1; n--)	\
-	{						\
-		polygon = &(layer)->Polygon[n]
+#define PIN_LOOP(element) do {                                      \
+  GList *__iter;                                                    \
+  GList *__copy = g_list_copy ((element)->Pin);                     \
+  Cardinal n;                                                       \
+  for (__iter = __copy, n = 0; __iter != NULL;                      \
+       __iter = g_list_next (__iter), n++) {                        \
+    PinType *pin = __iter->data;
+
+#define PAD_LOOP(element) do {                                      \
+  GList *__iter;                                                    \
+  GList *__copy = g_list_copy ((element)->Pad);                     \
+  Cardinal n;                                                       \
+  for (__iter = __copy, n = 0; __iter != NULL;                      \
+       __iter = g_list_next (__iter), n++) {                        \
+    PadType *pad = __iter->data;
+
+#define ARC_LOOP(element) do {                                      \
+  GList *__iter;                                                    \
+  GList *__copy = g_list_reverse (g_list_copy ((element)->Arc));    \
+  Cardinal n;                                                       \
+  for (__iter = __copy, n = (element)->ArcN - 1; __iter != NULL;    \
+       __iter = g_list_next (__iter), n--) {                        \
+    ArcType *arc = __iter->data;
+
+#define ELEMENTLINE_LOOP(element) do {                              \
+  GList *__iter;                                                    \
+  GList *__copy = g_list_reverse (g_list_copy ((element)->Line));   \
+  Cardinal n;                                                       \
+  for (__iter = __copy, n = (element)->LineN - 1; __iter != NULL;   \
+       __iter = g_list_next (__iter), n--) {                        \
+    LineType *line = __iter->data;
+
+#define ELEMENTARC_LOOP(element) do {                               \
+  GList *__iter;                                                    \
+  GList *__copy = g_list_reverse (g_list_copy ((element)->Arc));    \
+  Cardinal n;                                                       \
+  for (__iter = __copy, n = (element)->ArcN - 1; __iter != NULL;    \
+       __iter = g_list_next (__iter), n--) {                        \
+    ArcType *line = __iter->data;
+
+#define LINE_LOOP(layer) do {                                       \
+  GList *__iter;                                                    \
+  GList *__copy = g_list_reverse (g_list_copy ((layer)->Line));     \
+  Cardinal n;                                                       \
+  for (__iter = __copy, n = (layer)->LineN - 1; __iter != NULL;     \
+       __iter = g_list_next (__iter), n--) {                        \
+    LineType *line = __iter->data;
+
+#define TEXT_LOOP(layer) do {                                       \
+  GList *__iter;                                                    \
+  GList *__copy = g_list_reverse (g_list_copy ((layer)->Text));     \
+  Cardinal n;                                                       \
+  for (__iter = __copy, n = (layer)->LineN - 1; __iter != NULL;     \
+       __iter = g_list_next (__iter), n--) {                        \
+    TextType *text = __iter->data;
+
+#define POLYGON_LOOP(layer) do {                                    \
+  GList *__iter;                                                    \
+  GList *__copy = g_list_reverse (g_list_copy ((layer)->Polygon));  \
+  Cardinal n;                                                       \
+  for (__iter = __copy, n = (layer)->PolygonN - 1; __iter != NULL;  \
+       __iter = g_list_next (__iter), n--) {                        \
+    PolygonType *polygon = __iter->data;
 
 #define	POLYGONPOINT_LOOP(polygon) do	{	\
 	Cardinal			n;		\
+	GList *__copy = NULL; /* DUMMY */		\
 	PointTypePtr	point;				\
 	for (n = (polygon)->PointN-1; n != -1; n--)	\
 	{						\
@@ -427,6 +445,7 @@ extern int mem_any_set (unsigned char *, int);
 
 #define POINTER_LOOP(top) do	{	\
 	Cardinal	n;			\
+	GList *__copy = NULL; /* DUMMY */	\
 	void	**ptr;				\
 	for (n = (top)->PtrN-1; n != -1; n--)	\
 	{					\
@@ -434,6 +453,7 @@ extern int mem_any_set (unsigned char *, int);
 
 #define MENU_LOOP(top)	do {	\
 	Cardinal	l;			\
+	GList *__copy = NULL; /* DUMMY */	\
 	LibraryMenuTypePtr menu;		\
 	for (l = (top)->MenuN-1; l != -1; l--)	\
 	{					\
@@ -441,6 +461,7 @@ extern int mem_any_set (unsigned char *, int);
 
 #define ENTRY_LOOP(top) do	{	\
 	Cardinal	n;			\
+	GList *__copy = NULL; /* DUMMY */	\
 	LibraryEntryTypePtr entry;		\
 	for (n = (top)->EntryN-1; n != -1; n--)	\
 	{					\
@@ -448,6 +469,7 @@ extern int mem_any_set (unsigned char *, int);
 
 #define GROUP_LOOP(data, group) do { 	\
 	Cardinal entry; \
+	GList *__copy = NULL; /* DUMMY */	\
         for (entry = 0; entry < ((PCBTypePtr)(data->pcb))->LayerGroups.Number[(group)]; entry++) \
         { \
 		LayerTypePtr layer;		\
@@ -459,8 +481,10 @@ extern int mem_any_set (unsigned char *, int);
 
 #define LAYER_LOOP(data, ml) do { \
         Cardinal n; \
+        GList *__copy = NULL; /* DUMMY */ \
 	for (n = 0; n < ml; n++) \
 	{ \
 	   LayerTypePtr layer = (&data->Layer[(n)]);
 
+
 #endif
diff --git a/src/move.c b/src/move.c
index ecc5928..6ce043a 100644
--- a/src/move.c
+++ b/src/move.c
@@ -436,44 +436,36 @@ MovePolygonPoint (LayerTypePtr Layer, PolygonTypePtr Polygon,
  * moves a line between layers; lowlevel routines
  */
 static void *
-MoveLineToLayerLowLevel (LayerType *Source, LineType *Line,
+MoveLineToLayerLowLevel (LayerType *Source, LineType *line,
 			 LayerType *Destination)
 {
-  LineTypePtr newone = GetLineMemory (Destination);
-
-  r_delete_entry (Source->line_tree, (BoxType *)Line);
-  /* copy the data and remove it from the former layer */
-  *newone = *Line;
-  *Line = Source->Line[--Source->LineN];
-  r_substitute (Source->line_tree, (BoxType *) & Source->Line[Source->LineN],
-		(BoxType *) Line);
-  memset (&Source->Line[Source->LineN], 0, sizeof (LineType));
+  r_delete_entry (Source->line_tree, (BoxType *)line);
+
+  Source->Line = g_list_remove (Source->Line, line);
+  Destination->Line = g_list_append (Destination->Line, line);
+
   if (!Destination->line_tree)
     Destination->line_tree = r_create_tree (NULL, 0, 0);
-  r_insert_entry (Destination->line_tree, (BoxType *)newone, 0);
-  return newone;
+  r_insert_entry (Destination->line_tree, (BoxType *)line, 0);
+  return line;
 }
 
 /* ---------------------------------------------------------------------------
  * moves an arc between layers; lowlevel routines
  */
 static void *
-MoveArcToLayerLowLevel (LayerType *Source, ArcType *Arc,
+MoveArcToLayerLowLevel (LayerType *Source, ArcType *arc,
 			LayerType *Destination)
 {
-  ArcTypePtr newone = GetArcMemory (Destination);
-
-  r_delete_entry (Source->arc_tree, (BoxType *)Arc);
-  /* copy the data and remove it from the former layer */
-  *newone = *Arc;
-  *Arc = Source->Arc[--Source->ArcN];
-  r_substitute (Source->arc_tree, (BoxType *) & Source->Arc[Source->ArcN],
-		(BoxType *) Arc);
-  memset (&Source->Arc[Source->ArcN], 0, sizeof (ArcType));
+  r_delete_entry (Source->arc_tree, (BoxType *)arc);
+
+  Source->Arc = g_list_remove (Source->Arc, arc);
+  Destination->Arc = g_list_append (Destination->Arc, arc);
+
   if (!Destination->arc_tree)
     Destination->arc_tree = r_create_tree (NULL, 0, 0);
-  r_insert_entry (Destination->arc_tree, (BoxType *)newone, 0);
-  return (newone);
+  r_insert_entry (Destination->arc_tree, (BoxType *)arc, 0);
+  return arc;
 }
 
 
@@ -641,82 +633,73 @@ MoveLineToLayer (LayerType *Layer, LineType *Line)
  * moves a text object between layers; lowlevel routines
  */
 static void *
-MoveTextToLayerLowLevel (LayerType *Source, TextType *Text,
+MoveTextToLayerLowLevel (LayerType *Source, TextType *text,
 			 LayerType *Destination)
 {
-  TextTypePtr newone = GetTextMemory (Destination);
-
-  RestoreToPolygon (PCB->Data, TEXT_TYPE, Source, Text);
-  r_delete_entry (Source->text_tree, (BoxType *)Text);
-  /* copy the data and remove it from the former layer */
-  *newone = *Text;
-  *Text = Source->Text[--Source->TextN];
-  r_substitute (Source->text_tree, (BoxType *) & Source->Text[Source->TextN],
-		(BoxType *) Text);
-  memset (&Source->Text[Source->TextN], 0, sizeof (TextType));
+  RestoreToPolygon (PCB->Data, TEXT_TYPE, Source, text);
+  r_delete_entry (Source->text_tree, (BoxType *)text);
+
+  Source->Text = g_list_remove (Source->Text, text);
+  Destination->Text = g_list_append (Destination->Text, text);
+
   if (GetLayerGroupNumberByNumber (solder_silk_layer) ==
       GetLayerGroupNumberByPointer (Destination))
-    SET_FLAG (ONSOLDERFLAG, newone);
+    SET_FLAG (ONSOLDERFLAG, text);
   else
-    CLEAR_FLAG (ONSOLDERFLAG, newone);
+    CLEAR_FLAG (ONSOLDERFLAG, text);
+
   /* re-calculate the bounding box (it could be mirrored now) */
-  SetTextBoundingBox (&PCB->Font, newone);
+  SetTextBoundingBox (&PCB->Font, text);
   if (!Destination->text_tree)
     Destination->text_tree = r_create_tree (NULL, 0, 0);
-  r_insert_entry (Destination->text_tree, (BoxType *)newone, 0);
-  ClearFromPolygon (PCB->Data, TEXT_TYPE, Destination, newone);
-  return (newone);
+  r_insert_entry (Destination->text_tree, (BoxType *)text, 0);
+  ClearFromPolygon (PCB->Data, TEXT_TYPE, Destination, text);
+
+  return text;
 }
 
 /* ---------------------------------------------------------------------------
  * moves a text object between layers
  */
 static void *
-MoveTextToLayer (LayerType *Layer, TextType *Text)
+MoveTextToLayer (LayerType *layer, TextType *text)
 {
-  TextTypePtr newone;
-
-  if (TEST_FLAG (LOCKFLAG, Text))
+  if (TEST_FLAG (LOCKFLAG, text))
     {
       Message (_("Sorry, the object is locked\n"));
       return NULL;
     }
-  if (Dest != Layer)
+  if (Dest != layer)
     {
-      AddObjectToMoveToLayerUndoList (TEXT_TYPE, Layer, Text, Text);
-      if (Layer->On)
-	EraseText (Layer, Text);
-      newone = (TextTypePtr)MoveTextToLayerLowLevel (Layer, Text, Dest);
+      AddObjectToMoveToLayerUndoList (TEXT_TYPE, layer, text, text);
+      if (layer->On)
+	EraseText (layer, text);
+      text = MoveTextToLayerLowLevel (layer, text, Dest);
       if (Dest->On)
-	DrawText (Dest, newone);
-      if (Layer->On || Dest->On)
+	DrawText (Dest, text);
+      if (layer->On || Dest->On)
 	Draw ();
-      return (newone);
     }
-  return (Text);
+  return text;
 }
 
 /* ---------------------------------------------------------------------------
  * moves a polygon between layers; lowlevel routines
  */
 static void *
-MovePolygonToLayerLowLevel (LayerType *Source, PolygonType *Polygon,
+MovePolygonToLayerLowLevel (LayerType *Source, PolygonType *polygon,
 			    LayerType *Destination)
 {
-  PolygonTypePtr newone = GetPolygonMemory (Destination);
-
-  r_delete_entry (Source->polygon_tree, (BoxType *)Polygon);
-  /* copy the data and remove it from the former layer */
-  *newone = *Polygon;
-  *Polygon = Source->Polygon[--Source->PolygonN];
-  r_substitute (Source->polygon_tree,
-		(BoxType *) & Source->Polygon[Source->PolygonN],
-		(BoxType *) Polygon);
-  memset (&Source->Polygon[Source->PolygonN], 0, sizeof (PolygonType));
+  r_delete_entry (Source->polygon_tree, (BoxType *)polygon);
+
+  Source->Polygon = g_list_remove (Source->Polygon, polygon);
+  Destination->Polygon = g_list_append (Destination->Polygon, polygon);
+
   if (!Destination->polygon_tree)
     Destination->polygon_tree = r_create_tree (NULL, 0, 0);
-  r_insert_entry (Destination->polygon_tree, (BoxType *)newone, 0);
-  return (newone);
+  r_insert_entry (Destination->polygon_tree, (BoxType *)polygon, 0);
+
+  return polygon;
 }
 
 struct mptlc
diff --git a/src/mymem.c b/src/mymem.c
index 24f20a2..77a2ce2 100644
--- a/src/mymem.c
+++ b/src/mymem.c
@@ -182,244 +182,172 @@ GetNetListMemory (NetListListTypePtr Netlistlist)
     }
   return (netlist + Netlistlist->NetListN++);
 }
-
 /* ---------------------------------------------------------------------------
  * get next slot for a pin, allocates memory if necessary
  */
-PinTypePtr
-GetPinMemory (ElementTypePtr Element)
+PinType *
+GetPinMemory (ElementType *element)
 {
-  PinTypePtr pin = Element->Pin;
-  bool onBoard = false;
+  PinType *new_obj;
 
-  /* realloc new memory if necessary and clear it */
-  if (Element->PinN >= Element->PinMax)
-    {
-      if (PCB->Data->pin_tree)
-	{
-	  PIN_LOOP (Element);
-	  {
-	    if (r_delete_entry (PCB->Data->pin_tree, (BoxType *) pin))
-	      onBoard = true;
-	  }
-	  END_LOOP;
-	}
-      Element->PinMax += STEP_PIN;
-      pin = (PinTypePtr)realloc (pin, Element->PinMax * sizeof (PinType));
-      Element->Pin = pin;
-      memset (pin + Element->PinN, 0, STEP_PIN * sizeof (PinType));
-      if (onBoard)
-	{
-	  PIN_LOOP (Element);
-	  {
-	    r_insert_entry (PCB->Data->pin_tree, (BoxType *) pin, 0);
-	  }
-	  END_LOOP;
-	}
-    }
-  return (pin + Element->PinN++);
+  new_obj = g_slice_new0 (PinType);
+  element->Pin = g_list_append (element->Pin, new_obj);
+  element->PinN ++;
+
+  return new_obj;
+}
+
+static void
+FreePin (PinType *data)
+{
+  g_slice_free (PinType, data);
 }
 
 /* ---------------------------------------------------------------------------
  * get next slot for a pad, allocates memory if necessary
  */
-PadTypePtr
-GetPadMemory (ElementTypePtr Element)
+PadType *
+GetPadMemory (ElementType *element)
 {
-  PadTypePtr pad = Element->Pad;
-  bool onBoard = false;
+  PadType *new_obj;
 
-  /* realloc new memory if necessary and clear it */
-  if (Element->PadN >= Element->PadMax)
-    {
-      if (PCB->Data->pad_tree)
-	{
-	  PAD_LOOP (Element);
-	  {
-	    if (r_delete_entry (PCB->Data->pad_tree, (BoxType *) pad))
-	      onBoard = true;
-	  }
-	  END_LOOP;
-	}
-      Element->PadMax += STEP_PAD;
-      pad = (PadTypePtr)realloc (pad, Element->PadMax * sizeof (PadType));
-      Element->Pad = pad;
-      memset (pad + Element->PadN, 0, STEP_PAD * sizeof (PadType));
-      if (onBoard)
-	{
-	  PAD_LOOP (Element);
-	  {
-	    r_insert_entry (PCB->Data->pad_tree, (BoxType *) pad, 0);
-	  }
-	  END_LOOP;
-	}
-    }
-  return (pad + Element->PadN++);
+  new_obj = g_slice_new0 (PadType);
+  element->Pad = g_list_append (element->Pad, new_obj);
+  element->PadN ++;
+
+  return new_obj;
+}
+
+static void
+FreePad (PadType *data)
+{
+  g_slice_free (PadType, data);
 }
 
 /* ---------------------------------------------------------------------------
  * get next slot for a via, allocates memory if necessary
  */
-PinTypePtr
-GetViaMemory (DataTypePtr Data)
+PinType *
+GetViaMemory (DataType *data)
 {
-  PinTypePtr via = Data->Via;
+  PinType *new_obj;
 
-  /* realloc new memory if necessary and clear it */
-  if (Data->ViaN >= Data->ViaMax)
-    {
-      Data->ViaMax += STEP_VIA;
-      if (Data->via_tree)
-	r_destroy_tree (&Data->via_tree);
-      via = (PinTypePtr)realloc (via, Data->ViaMax * sizeof (PinType));
-      Data->Via = via;
-      memset (via + Data->ViaN, 0, STEP_VIA * sizeof (PinType));
-      Data->via_tree = r_create_tree (NULL, 0, 0);
-      VIA_LOOP (Data);
-      {
-	r_insert_entry (Data->via_tree, (BoxType *) via, 0);
-      }
-      END_LOOP;
-    }
-  return (via + Data->ViaN++);
+  new_obj = g_slice_new0 (PinType);
+  data->Via = g_list_append (data->Via, new_obj);
+  data->ViaN ++;
+
+  return new_obj;
+}
+
+static void
+FreeVia (PinType *data)
+{
+  g_slice_free (PinType, data);
 }
 
 /* ---------------------------------------------------------------------------
  * get next slot for a Rat, allocates memory if necessary
  */
-RatTypePtr
-GetRatMemory (DataTypePtr Data)
+RatType *
+GetRatMemory (DataType *data)
 {
-  RatTypePtr rat = Data->Rat;
+  RatType *new_obj;
 
-  /* realloc new memory if necessary and clear it */
-  if (Data->RatN >= Data->RatMax)
-    {
-      Data->RatMax += STEP_RAT;
-      /* all of the pointers move, so rebuild the whole tree */
-      if (Data->rat_tree)
-        r_destroy_tree (&Data->rat_tree);
-      rat = (RatTypePtr)realloc (rat, Data->RatMax * sizeof (RatType));
-      Data->Rat = rat;
-      memset (rat + Data->RatN, 0, STEP_RAT * sizeof (RatType));
-      Data->rat_tree = r_create_tree (NULL, 0, 0);
-      RAT_LOOP (Data);
-      {
-        r_insert_entry (Data->rat_tree, (BoxTypePtr) line, 0);
-      }
-      END_LOOP;
-    }
-  return (rat + Data->RatN++);
+  new_obj = g_slice_new0 (RatType);
+  data->Rat = g_list_append (data->Rat, new_obj);
+  data->RatN ++;
+
+  return new_obj;
+}
+
+static void
+FreeRat (RatType *data)
+{
+  g_slice_free (RatType, data);
 }
 
 /* ---------------------------------------------------------------------------
  * get next slot for a line, allocates memory if necessary
  */
-LineTypePtr
-GetLineMemory (LayerTypePtr Layer)
+LineType *
+GetLineMemory (LayerType *layer)
 {
-  LineTypePtr line = Layer->Line;
+  LineType *new_obj;
 
-  /* realloc new memory if necessary and clear it */
-  if (Layer->LineN >= Layer->LineMax)
-    {
-      Layer->LineMax += STEP_LINE;
-      /* all of the pointers move, so rebuild the whole tree */
-      if (Layer->line_tree)
-	r_destroy_tree (&Layer->line_tree);
-      line = (LineTypePtr)realloc (line, Layer->LineMax * sizeof (LineType));
-      Layer->Line = line;
-      memset (line + Layer->LineN, 0, STEP_LINE * sizeof (LineType));
-      Layer->line_tree = r_create_tree (NULL, 0, 0);
-      LINE_LOOP (Layer);
-      {
-	r_insert_entry (Layer->line_tree, (BoxTypePtr) line, 0);
-      }
-      END_LOOP;
-    }
-  return (line + Layer->LineN++);
+  new_obj = g_slice_new0 (LineType);
+  layer->Line = g_list_append (layer->Line, new_obj);
+  layer->LineN ++;
+
+  return new_obj;
+}
+
+static void
+FreeLine (LineType *data)
+{
+  g_slice_free (LineType, data);
 }
 
 /* ---------------------------------------------------------------------------
  * get next slot for an arc, allocates memory if necessary
  */
 ArcTypePtr
-GetArcMemory (LayerTypePtr Layer)
+GetArcMemory (LayerType *layer)
 {
-  ArcTypePtr arc = Layer->Arc;
+  ArcType *new_obj;
 
-  /* realloc new memory if necessary and clear it */
-  if (Layer->ArcN >= Layer->ArcMax)
-    {
-      Layer->ArcMax += STEP_ARC;
-      if (Layer->arc_tree)
-	r_destroy_tree (&Layer->arc_tree);
-      arc = (ArcTypePtr)realloc (arc, Layer->ArcMax * sizeof (ArcType));
-      Layer->Arc = arc;
-      memset (arc + Layer->ArcN, 0, STEP_ARC * sizeof (ArcType));
-      Layer->arc_tree = r_create_tree (NULL, 0, 0);
-      ARC_LOOP (Layer);
-      {
-	r_insert_entry (Layer->arc_tree, (BoxTypePtr) arc, 0);
-      }
-      END_LOOP;
-    }
-  return (arc + Layer->ArcN++);
+  new_obj = g_slice_new0 (ArcType);
+  layer->Arc = g_list_append (layer->Arc, new_obj);
+  layer->ArcN ++;
+
+  return new_obj;
+}
+
+static void
+FreeArc (ArcType *data)
+{
+  g_slice_free (ArcType, data);
 }
 
 /* ---------------------------------------------------------------------------
  * get next slot for a text object, allocates memory if necessary
  */
 TextTypePtr
-GetTextMemory (LayerTypePtr Layer)
+GetTextMemory (LayerType *layer)
 {
-  TextTypePtr text = Layer->Text;
+  TextType *new_obj;
 
-  /* realloc new memory if necessary and clear it */
-  if (Layer->TextN >= Layer->TextMax)
-    {
-      Layer->TextMax += STEP_TEXT;
-      if (Layer->text_tree)
-	r_destroy_tree (&Layer->text_tree);
-      text = (TextTypePtr)realloc (text, Layer->TextMax * sizeof (TextType));
-      Layer->Text = text;
-      memset (text + Layer->TextN, 0, STEP_TEXT * sizeof (TextType));
-      Layer->text_tree = r_create_tree (NULL, 0, 0);
-      TEXT_LOOP (Layer);
-      {
-	r_insert_entry (Layer->text_tree, (BoxTypePtr) text, 0);
-      }
-      END_LOOP;
-    }
-  return (text + Layer->TextN++);
+  new_obj = g_slice_new0 (TextType);
+  layer->Text = g_list_append (layer->Text, new_obj);
+  layer->TextN ++;
+
+  return new_obj;
+}
+
+static void
+FreeText (TextType *data)
+{
+  g_slice_free (TextType, data);
 }
 
 /* ---------------------------------------------------------------------------
  * get next slot for a polygon object, allocates memory if necessary
  */
-PolygonTypePtr
-GetPolygonMemory (LayerTypePtr Layer)
+PolygonType *
+GetPolygonMemory (LayerType *layer)
 {
-  PolygonTypePtr polygon = Layer->Polygon;
+  PolygonType *new_obj;
 
-  /* realloc new memory if necessary and clear it */
-  if (Layer->PolygonN >= Layer->PolygonMax)
-    {
-      Layer->PolygonMax += STEP_POLYGON;
-      if (Layer->polygon_tree)
-	r_destroy_tree (&Layer->polygon_tree);
-      polygon = (PolygonTypePtr)realloc (polygon, Layer->PolygonMax * sizeof (PolygonType));
-      Layer->Polygon = polygon;
-      memset (polygon + Layer->PolygonN, 0,
-	      STEP_POLYGON * sizeof (PolygonType));
-      Layer->polygon_tree = r_create_tree (NULL, 0, 0);
-      POLYGON_LOOP (Layer);
-      {
-	r_insert_entry (Layer->polygon_tree, (BoxType *) polygon, 0);
-      }
-      END_LOOP;
-    }
-  return (polygon + Layer->PolygonN++);
+  new_obj = g_slice_new0 (PolygonType);
+  layer->Polygon = g_list_append (layer->Polygon, new_obj);
+  layer->PolygonN ++;
+
+  return new_obj;
+}
+
+static void
+FreePolygon (PolygonType *data)
+{
+  g_slice_free (PolygonType, data);
 }
 
 /* ---------------------------------------------------------------------------
@@ -467,53 +395,22 @@ GetHoleIndexMemoryInPolygon (PolygonTypePtr Polygon)
 /* ---------------------------------------------------------------------------
  * get next slot for an element, allocates memory if necessary
  */
-ElementTypePtr
-GetElementMemory (DataTypePtr Data)
+ElementType *
+GetElementMemory (DataType *data)
 {
-  ElementTypePtr element = Data->Element;
-  int i;
+  ElementType *new_obj;
 
-  /* realloc new memory if necessary and clear it */
-  if (Data->ElementN >= Data->ElementMax)
-    {
-      Data->ElementMax += STEP_ELEMENT;
-      if (Data->element_tree)
-	r_destroy_tree (&Data->element_tree);
-      element = (ElementTypePtr)realloc (element, Data->ElementMax * sizeof (ElementType));
-      Data->Element = element;
-      memset (element + Data->ElementN, 0,
-	      STEP_ELEMENT * sizeof (ElementType));
-      Data->element_tree = r_create_tree (NULL, 0, 0);
-      for (i = 0; i < MAX_ELEMENTNAMES; i++)
-	{
-	  if (Data->name_tree[i])
-	    r_destroy_tree (&Data->name_tree[i]);
-	  Data->name_tree[i] = r_create_tree (NULL, 0, 0);
-	}
-
-      ELEMENT_LOOP (Data);
-      {
-	r_insert_entry (Data->element_tree, (BoxType *) element, 0);
-	PIN_LOOP (element);
-	{
-	  pin->Element = element;
-	}
-	END_LOOP;
-	PAD_LOOP (element);
-	{
-	  pad->Element = element;
-	}
-	END_LOOP;
-	ELEMENTTEXT_LOOP (element);
-	{
-	  text->Element = element;
-	  r_insert_entry (Data->name_tree[n], (BoxType *) text, 0);
-	}
-	END_LOOP;
-      }
-      END_LOOP;
-    }
-  return (element + Data->ElementN++);
+  new_obj = g_slice_new0 (ElementType);
+  data->Element = g_list_append (data->Element, new_obj);
+  data->ElementN ++;
+
+  return new_obj;
+}
+
+static void
+FreeElement (ElementType *data)
+{
+  g_slice_free (ElementType, data);
 }
 
 /* ---------------------------------------------------------------------------
@@ -623,17 +520,19 @@ GetDrillInfoDrillMemory (DrillInfoTypePtr DrillInfo)
  * frees memory used by a polygon
  */
 void
-FreePolygonMemory (PolygonTypePtr Polygon)
+FreePolygonMemory (PolygonType *polygon)
 {
-  if (Polygon)
-    {
-      free (Polygon->Points);
-      free (Polygon->HoleIndex);
-      if (Polygon->Clipped)
-	poly_Free (&Polygon->Clipped);
-      poly_FreeContours (&Polygon->NoHoles);
-      memset (Polygon, 0, sizeof (PolygonType));
-    }
+  if (polygon == NULL)
+    return;
+
+  free (polygon->Points);
+  free (polygon->HoleIndex);
+
+  if (polygon->Clipped)
+    poly_Free (&polygon->Clipped);
+  poly_FreeContours (&polygon->NoHoles);
+
+  memset (polygon, 0, sizeof (PolygonType));
 }
 
 /* ---------------------------------------------------------------------------
@@ -719,146 +618,139 @@ FreeAttributeListMemory (AttributeListTypePtr list)
  * frees memory used by an element
  */
 void
-FreeElementMemory (ElementTypePtr Element)
+FreeElementMemory (ElementType *element)
 {
-  if (Element)
-    {
-      ELEMENTNAME_LOOP (Element);
-      {
-	free (textstring);
-      }
-      END_LOOP;
-      PIN_LOOP (Element);
-      {
-	free (pin->Name);
-	free (pin->Number);
-      }
-      END_LOOP;
-      PAD_LOOP (Element);
-      {
-	free (pad->Name);
-	free (pad->Number);
-      }
-      END_LOOP;
-      free (Element->Pin);
-      free (Element->Pad);
-      free (Element->Line);
-      free (Element->Arc);
-      FreeAttributeListMemory (&Element->Attributes);
-      memset (Element, 0, sizeof (ElementType));
-    }
+  if (element == NULL)
+    return;
+
+  ELEMENTNAME_LOOP (element);
+  {
+    free (textstring);
+  }
+  END_LOOP;
+  PIN_LOOP (element);
+  {
+    free (pin->Name);
+    free (pin->Number);
+  }
+  END_LOOP;
+  PAD_LOOP (element);
+  {
+    free (pad->Name);
+    free (pad->Number);
+  }
+  END_LOOP;
+
+  g_list_free_full (element->Pin,  (GDestroyNotify)FreePin);
+  g_list_free_full (element->Pad,  (GDestroyNotify)FreePad);
+  g_list_free_full (element->Line, (GDestroyNotify)FreeLine);
+  g_list_free_full (element->Arc,  (GDestroyNotify)FreeArc);
+
+  FreeAttributeListMemory (&element->Attributes);
+  memset (element, 0, sizeof (ElementType));
 }
 
 /* ---------------------------------------------------------------------------
  * free memory used by PCB
  */
 void
-FreePCBMemory (PCBTypePtr PCBPtr)
+FreePCBMemory (PCBType *pcb)
 {
   int i;
 
-  if (PCBPtr)
-    {
-      free (PCBPtr->Name);
-      free (PCBPtr->Filename);
-      free (PCBPtr->PrintFilename);
-      if (PCBPtr->Data)
-	FreeDataMemory (PCBPtr->Data);
-      free (PCBPtr->Data);
-      /* release font symbols */
-      for (i = 0; i <= MAX_FONTPOSITION; i++)
-	free (PCBPtr->Font.Symbol[i].Line);
-      FreeLibraryMemory (&PCBPtr->NetlistLib);
-      FreeAttributeListMemory (&PCBPtr->Attributes);
-      /* clear struct */
-      memset (PCBPtr, 0, sizeof (PCBType));
-    }
-  else
-    {
-      fprintf (stderr, "Warning:  Tried to FreePCBMemory(null)\n");
-    }
+  if (pcb == NULL)
+    return;
+
+  free (pcb->Name);
+  free (pcb->Filename);
+  free (pcb->PrintFilename);
+  FreeDataMemory (pcb->Data);
+  free (pcb->Data);
+  /* release font symbols */
+  for (i = 0; i <= MAX_FONTPOSITION; i++)
+    free (pcb->Font.Symbol[i].Line);
+  FreeLibraryMemory (&pcb->NetlistLib);
+  FreeAttributeListMemory (&pcb->Attributes);
+  /* clear struct */
+  memset (pcb, 0, sizeof (PCBType));
 }
 
 /* ---------------------------------------------------------------------------
  * free memory used by data struct
  */
 void
-FreeDataMemory (DataTypePtr Data)
+FreeDataMemory (DataType *data)
 {
   LayerTypePtr layer;
   int i;
 
-  if (Data)
+  if (data == NULL)
+    return;
+
+  VIA_LOOP (data);
+  {
+    free (via->Name);
+  }
+  END_LOOP;
+  g_list_free_full (data->Via, (GDestroyNotify)FreeVia);
+  ELEMENT_LOOP (data);
+  {
+    FreeElementMemory (element);
+  }
+  END_LOOP;
+  g_list_free_full (data->Element, (GDestroyNotify)FreeElement);
+  g_list_free_full (data->Rat, (GDestroyNotify)FreeRat);
+
+  for (layer = data->Layer, i = 0; i < MAX_LAYER + 2; layer++, i++)
     {
-      VIA_LOOP (Data);
+      FreeAttributeListMemory (&layer->Attributes);
+      TEXT_LOOP (layer);
       {
-	free (via->Name);
+        free (text->TextString);
       }
       END_LOOP;
-      free (Data->Via);
-      ELEMENT_LOOP (Data);
+      if (layer->Name)
+        free (layer->Name);
+      LINE_LOOP (layer);
       {
-	FreeElementMemory (element);
+        if (line->Number)
+          free (line->Number);
       }
       END_LOOP;
-      free (Data->Element);
-      free (Data->Rat);
-
-      for (layer = Data->Layer, i = 0; i < MAX_LAYER + 2; layer++, i++)
-	{
-	  FreeAttributeListMemory (&layer->Attributes);
-	  TEXT_LOOP (layer);
-	  {
-	    free (text->TextString);
-	  }
-	  END_LOOP;
-	  if (layer->Name)
-	    free (layer->Name);
-	  LINE_LOOP (layer);
-	  {
-	    if (line->Number)
-	      free (line->Number);
-	  }
-	  END_LOOP;
-	  free (layer->Line);
-	  free (layer->Arc);
-	  free (layer->Text);
-	  POLYGON_LOOP (layer);
-	  {
-	    FreePolygonMemory (polygon);
-	  }
-	  END_LOOP;
-	  free (layer->Polygon);
-	  if (layer->line_tree)
-	    r_destroy_tree (&layer->line_tree);
-	  if (layer->arc_tree)
-	    r_destroy_tree (&layer->arc_tree);
-	  if (layer->text_tree)
-	    r_destroy_tree (&layer->text_tree);
-	  if (layer->polygon_tree)
-	    r_destroy_tree (&layer->polygon_tree);
-	}
-
-      if (Data->element_tree)
-	r_destroy_tree (&Data->element_tree);
-      for (i = 0; i < MAX_ELEMENTNAMES; i++)
-	if (Data->name_tree[i])
-	  r_destroy_tree (&Data->name_tree[i]);
-      if (Data->via_tree)
-	r_destroy_tree (&Data->via_tree);
-      if (Data->pin_tree)
-	r_destroy_tree (&Data->pin_tree);
-      if (Data->pad_tree)
-	r_destroy_tree (&Data->pad_tree);
-      if (Data->rat_tree)
-	r_destroy_tree (&Data->rat_tree);
-      /* clear struct */
-      memset (Data, 0, sizeof (DataType));
-    }
-  else
-    {
-      fprintf (stderr, "Warning:  Tried to FreeDataMemory(null)\n");
-    }
+      g_list_free_full (layer->Line, (GDestroyNotify)FreeLine);
+      g_list_free_full (layer->Arc, (GDestroyNotify)FreeArc);
+      g_list_free_full (layer->Text, (GDestroyNotify)FreeText);
+      POLYGON_LOOP (layer);
+      {
+        FreePolygonMemory (polygon);
+      }
+      END_LOOP;
+      g_list_free_full (layer->Polygon, (GDestroyNotify)FreePolygon);
+      if (layer->line_tree)
+        r_destroy_tree (&layer->line_tree);
+      if (layer->arc_tree)
+        r_destroy_tree (&layer->arc_tree);
+      if (layer->text_tree)
+        r_destroy_tree (&layer->text_tree);
+      if (layer->polygon_tree)
+        r_destroy_tree (&layer->polygon_tree);
+    }
+
+  if (data->element_tree)
+    r_destroy_tree (&data->element_tree);
+  for (i = 0; i < MAX_ELEMENTNAMES; i++)
+    if (data->name_tree[i])
+      r_destroy_tree (&data->name_tree[i]);
+  if (data->via_tree)
+    r_destroy_tree (&data->via_tree);
+  if (data->pin_tree)
+    r_destroy_tree (&data->pin_tree);
+  if (data->pad_tree)
+    r_destroy_tree (&data->pad_tree);
+  if (data->rat_tree)
+    r_destroy_tree (&data->rat_tree);
+  /* clear struct */
+  memset (data, 0, sizeof (DataType));
 }
 
 /* ---------------------------------------------------------------------------
diff --git a/src/mymem.h b/src/mymem.h
index 4e36640..6b572d8 100644
--- a/src/mymem.h
+++ b/src/mymem.h
@@ -41,14 +41,6 @@
 /* ---------------------------------------------------------------------------
  * number of additional objects that are allocated with one system call
  */
-#define	STEP_VIA			2000	/* block size for realloc() calls */
-#define	STEP_PIN			20
-#define	STEP_PAD			20
-#define	STEP_LINE			10000
-#define STEP_ARC			1000
-#define	STEP_ELEMENTLINE	10
-#define	STEP_ELEMENTARC		5
-#define	STEP_TEXT			50
 #define	STEP_ELEMENT		50
 #define STEP_DRILL		30
 #define STEP_POINT		100
@@ -56,13 +48,11 @@
 #define	STEP_SELECTORENTRY	128
 #define	STEP_REMOVELIST		500
 #define	STEP_UNDOLIST		500
-#define	STEP_POLYGON		10
 #define	STEP_POLYGONPOINT	10
 #define	STEP_POLYGONHOLEINDEX	10
 #define	STEP_LIBRARYMENU	10
 #define	STEP_LIBRARYENTRY	20
 #define	STEP_RUBBERBAND		100
-#define STEP_RAT		2000
 
 #define STRDUP(x) (((x) != NULL) ? strdup (x) : NULL)
 
diff --git a/src/puller.c b/src/puller.c
index 8e56f0b..4ba804b 100644
--- a/src/puller.c
+++ b/src/puller.c
@@ -623,6 +623,11 @@ typedef struct Extra {
   End end;
   unsigned char found:1;
   unsigned char deleted:1;
+  int type;
+  union {
+    LineType *line;
+    ArcType *arc;
+  } parent;
 } Extra;
 
 static Extra multi_next;
@@ -640,12 +645,12 @@ static void trace_paths ();
 #endif
 static void mark_line_for_deletion (LineTypePtr);
 
-#define LINE2EXTRA(l) (lines[(l)-CURRENT->Line])
-#define ARC2EXTRA(a) (arcs[(a)-CURRENT->Arc])
-#define EXTRA2LINE(e) (CURRENT->Line[(e)-lines])
-#define EXTRA2ARC(e) (CURRENT->Arc[(e)-arcs])
-#define EXTRA_IS_LINE(e) ((unsigned)(e-lines) < nlines)
-#define EXTRA_IS_ARC(e) ((unsigned)(e-arcs) < narcs)
+#define LINE2EXTRA(l)    g_hash_table_lookup (lines, l)
+#define ARC2EXTRA(a)     g_hash_table_lookup (arcs, a)
+#define EXTRA2LINE(e)    (e->parent.line)
+#define EXTRA2ARC(e)     (e->parent.arc)
+#define EXTRA_IS_LINE(e) (e->type == LINE_TYPE)
+#define EXTRA_IS_ARC(e)  (e->type == ARC_TYPE)
 
 static void
 unlink_end (Extra *x, Extra **e)
diff --git a/src/rats.c b/src/rats.c
index a6e526c..d2aa8bb 100644
--- a/src/rats.c
+++ b/src/rats.c
@@ -123,14 +123,14 @@ static bool
 FindPad (char *ElementName, char *PinNum, ConnectionType * conn, bool Same)
 {
   ElementTypePtr element;
-  Cardinal i;
+  GList *i;
 
   if ((element = SearchElementByName (PCB->Data, ElementName)) == NULL)
     return false;
 
-  for (i = 0; i < element->PadN; i++)
+  for (i = element->Pad; i != NULL; i = g_list_next (i))
     {
-      PadType *pad = &element->Pad[i];
+      PadType *pad = i->data;
 
       if (NSTRCMP (PinNum, pad->Number) == 0 &&
           (!Same || !TEST_FLAG (DRCFLAG, pad)))
@@ -154,9 +154,9 @@ FindPad (char *ElementName, char *PinNum, ConnectionType * conn, bool Same)
         }
     }
 
-  for (i = 0; i < element->PinN; i++)
+  for (i = element->Pin; i != NULL; i = g_list_next (i))
     {
-      PinType *pin = &element->Pin[i];
+      PinType *pin = i->data;
 
       if (!TEST_FLAG (HOLEFLAG, pin) &&
           pin->Number && NSTRCMP (PinNum, pin->Number) == 0 &&
diff --git a/src/remove.c b/src/remove.c
index a0fcce8..4554597 100644
--- a/src/remove.c
+++ b/src/remove.c
@@ -131,14 +131,12 @@ DestroyVia (PinTypePtr Via)
 {
   r_delete_entry (DestroyTarget->via_tree, (BoxTypePtr) Via);
   free (Via->Name);
-  if (Via != &DestroyTarget->Via[--DestroyTarget->ViaN])
-    {
-      *Via = DestroyTarget->Via[DestroyTarget->ViaN];
-      r_substitute (DestroyTarget->via_tree, (BoxTypePtr)
-		    (BoxType *) & DestroyTarget->Via[DestroyTarget->ViaN],
-		    (BoxType *) Via);
-    }
-  memset (&DestroyTarget->Via[DestroyTarget->ViaN], 0, sizeof (PinType));
+
+  DestroyTarget->Via = g_list_remove (DestroyTarget->Via, Via);
+  DestroyTarget->ViaN --;
+
+  g_slice_free (PinType, Via);
+
   return NULL;
 }
 
@@ -150,14 +148,12 @@ DestroyLine (LayerTypePtr Layer, LineTypePtr Line)
 {
   r_delete_entry (Layer->line_tree, (BoxTypePtr) Line);
   free (Line->Number);
-  if (Line != &Layer->Line[--Layer->LineN])
-    {
-      *Line = Layer->Line[Layer->LineN];
-      /* tricky - line pointers are moved around */
-      r_substitute (Layer->line_tree, (BoxType *) & Layer->Line[Layer->LineN],
-		    (BoxType *) Line);
-    }
-  memset (&Layer->Line[Layer->LineN], 0, sizeof (LineType));
+
+  Layer->Line = g_list_remove (Layer->Line, Line);
+  Layer->LineN --;
+
+  g_slice_free (LineType, Line);
+
   return NULL;
 }
 
@@ -168,13 +164,12 @@ static void *
 DestroyArc (LayerTypePtr Layer, ArcTypePtr Arc)
 {
   r_delete_entry (Layer->arc_tree, (BoxTypePtr) Arc);
-  if (Arc != &Layer->Arc[--Layer->ArcN])
-    {
-      *Arc = Layer->Arc[Layer->ArcN];
-      r_substitute (Layer->arc_tree, (BoxType *) & Layer->Arc[Layer->ArcN],
-		    (BoxType *) Arc);
-    }
-  memset (&Layer->Arc[Layer->ArcN], 0, sizeof (ArcType));
+
+  Layer->Arc = g_list_remove (Layer->Arc, Arc);
+  Layer->ArcN --;
+
+  g_slice_free (ArcType, Arc);
+
   return NULL;
 }
 
@@ -186,14 +181,12 @@ DestroyPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
 {
   r_delete_entry (Layer->polygon_tree, (BoxTypePtr) Polygon);
   FreePolygonMemory (Polygon);
-  if (Polygon != &Layer->Polygon[--Layer->PolygonN])
-    {
-      *Polygon = Layer->Polygon[Layer->PolygonN];
-      r_substitute (Layer->polygon_tree,
-		    (BoxType *) & Layer->Polygon[Layer->PolygonN],
-		    (BoxType *) Polygon);
-    }
-  memset (&Layer->Polygon[Layer->PolygonN], 0, sizeof (PolygonType));
+
+  Layer->Polygon = g_list_remove (Layer->Polygon, Polygon);
+  Layer->PolygonN --;
+
+  g_slice_free (PolygonType, Polygon);
+
   return NULL;
 }
 
@@ -245,13 +238,12 @@ DestroyText (LayerTypePtr Layer, TextTypePtr Text)
 {
   free (Text->TextString);
   r_delete_entry (Layer->text_tree, (BoxTypePtr) Text);
-  if (Text != &Layer->Text[--Layer->TextN])
-    {
-      *Text = Layer->Text[Layer->TextN];
-      r_substitute (Layer->text_tree, (BoxType *) & Layer->Text[Layer->TextN],
-		    (BoxType *) Text);
-    }
-  memset (&Layer->Text[Layer->TextN], 0, sizeof (TextType));
+
+  Layer->Text = g_list_remove (Layer->Text, Text);
+  Layer->TextN --;
+
+  g_slice_free (TextType, Text);
+
   return NULL;
 }
 
@@ -286,36 +278,12 @@ DestroyElement (ElementTypePtr Element)
   }
   END_LOOP;
   FreeElementMemory (Element);
-  if (Element != &DestroyTarget->Element[--DestroyTarget->ElementN])
-    {
-      *Element = DestroyTarget->Element[DestroyTarget->ElementN];
-      /* deal with changed element pointer */
-      r_substitute (DestroyTarget->element_tree,
-		    (BoxType *) & DestroyTarget->Element[DestroyTarget->
-							 ElementN],
-		    (BoxType *) Element);
-    }
-  PIN_LOOP (Element);
-  {
-    pin->Element = Element;
-  }
-  END_LOOP;
-  PAD_LOOP (Element);
-  {
-    pad->Element = Element;
-  }
-  END_LOOP;
-  ELEMENTTEXT_LOOP (Element);
-  {
-    r_substitute (DestroyTarget->name_tree[n],
-		  (BoxType *) & DestroyTarget->Element[DestroyTarget->
-						       ElementN].Name[n],
-		  (BoxType *) text);
-    text->Element = Element;
-  }
-  END_LOOP;
-  memset (&DestroyTarget->Element[DestroyTarget->ElementN], 0,
-	  sizeof (ElementType));
+
+  DestroyTarget->Element = g_list_remove (DestroyTarget->Element, Element);
+  DestroyTarget->ElementN --;
+
+  g_slice_free (ElementType, Element);
+
   return NULL;
 }
 
@@ -327,14 +295,12 @@ DestroyRat (RatTypePtr Rat)
 {
   if (DestroyTarget->rat_tree)
     r_delete_entry (DestroyTarget->rat_tree, &Rat->BoundingBox);
-  if (Rat != &DestroyTarget->Rat[--DestroyTarget->RatN])
-    {
-      *Rat = DestroyTarget->Rat[DestroyTarget->RatN];
-      r_substitute (DestroyTarget->rat_tree,
-		    &DestroyTarget->Rat[DestroyTarget->RatN].BoundingBox,
-		    &Rat->BoundingBox);
-    }
-  memset (&DestroyTarget->Rat[DestroyTarget->RatN], 0, sizeof (RatType));
+
+  DestroyTarget->Rat = g_list_remove (DestroyTarget->Rat, Rat);
+  DestroyTarget->RatN --;
+
+  g_slice_free (RatType, Rat);
+
   return NULL;
 }
 
diff --git a/src/toporouter.c b/src/toporouter.c
index 74459f4..402de74 100644
--- a/src/toporouter.c
+++ b/src/toporouter.c
@@ -7987,8 +7987,8 @@ escape (int argc, char **argv, int x, int y)
       PinTypePtr via;
       LineTypePtr line;
 
-      PadType *pad0 = &element->Pad[0];
-      PadType *pad1 = &element->Pad[1];
+      PadType *pad0 = element->Pad->data;
+      PadType *pad1 = g_list_next (element->Pad)->data;
 
       pitch = sqrt (pow (abs (pad0->Point1.X - pad1->Point1.X), 2) +
                     pow (abs (pad0->Point1.Y - pad1->Point1.Y), 2) );

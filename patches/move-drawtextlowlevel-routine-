Bottom: c75f3d44f8e49071e76b920da2ec09a863a180de
Top:    dc1ca652d8bc829e31160d49ce8a3359307b8f3f
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2012-11-21 21:53:07 +0000

Move DrawTextLowlevel() routine from draw.c into the HID_DRAW API

The API is now called draw_pcb_text, and the default implementation
resides in hid/common/draw_helpers.c


---

diff --git a/src/draw.c b/src/draw.c
index 1e48602..3821990 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -178,7 +178,7 @@ _draw_pv_name (PinType *pv)
 
   if (gui->gui)
     doing_pinout++;
-  DrawTextLowLevel (Output.fgGC, &text, 0);
+  gui->graphics->draw_pcb_text (Output.fgGC, &text, 0);
   if (gui->gui)
     doing_pinout--;
 }
@@ -274,7 +274,7 @@ draw_pad_name (PadType *pad)
   text.Y = box.Y1;
   text.Direction = vert ? 1 : 0;
 
-  DrawTextLowLevel (Output.fgGC, &text, 0);
+  gui->graphics->draw_pcb_text (Output.fgGC, &text, 0);
 }
 
 static void
@@ -331,7 +331,7 @@ draw_element_name (ElementType *element)
     gui->graphics->set_color (Output.fgGC, PCB->ElementColor);
   else
     gui->graphics->set_color (Output.fgGC, PCB->InvisibleObjectsColor);
-  DrawTextLowLevel (Output.fgGC, &ELEMENT_TEXT (PCB, element), PCB->minSlk);
+  gui->graphics->draw_pcb_text (Output.fgGC, &ELEMENT_TEXT (PCB, element), PCB->minSlk);
 }
 
 static int
@@ -978,7 +978,7 @@ text_callback (const BoxType * b, void *cl)
     min_silk_line = PCB->minSlk;
   else
     min_silk_line = PCB->minWid;
-  DrawTextLowLevel (Output.fgGC, text, min_silk_line);
+  gui->graphics->draw_pcb_text (Output.fgGC, text, min_silk_line);
   return 1;
 }
 
@@ -1110,89 +1110,6 @@ GatherPadName (PadType *Pad)
 }
 
 /* ---------------------------------------------------------------------------
- * lowlevel drawing routine for text objects
- */
-void
-DrawTextLowLevel (hidGC gc, TextType *Text, Coord min_line_width)
-{
-  Coord x = 0;
-  unsigned char *string = (unsigned char *) Text->TextString;
-  Cardinal n;
-  FontType *font = &PCB->Font;
-
-  while (string && *string)
-    {
-      /* draw lines if symbol is valid and data is present */
-      if (*string <= MAX_FONTPOSITION && font->Symbol[*string].Valid)
-	{
-	  LineType *line = font->Symbol[*string].Line;
-	  LineType newline;
-
-	  for (n = font->Symbol[*string].LineN; n; n--, line++)
-	    {
-	      /* create one line, scale, move, rotate and swap it */
-	      newline = *line;
-	      newline.Point1.X = SCALE_TEXT (newline.Point1.X + x, Text->Scale);
-	      newline.Point1.Y = SCALE_TEXT (newline.Point1.Y, Text->Scale);
-	      newline.Point2.X = SCALE_TEXT (newline.Point2.X + x, Text->Scale);
-	      newline.Point2.Y = SCALE_TEXT (newline.Point2.Y, Text->Scale);
-	      newline.Thickness = SCALE_TEXT (newline.Thickness, Text->Scale / 2);
-	      if (newline.Thickness < min_line_width)
-		newline.Thickness = min_line_width;
-
-	      RotateLineLowLevel (&newline, 0, 0, Text->Direction);
-
-	      /* the labels of SMD objects on the bottom
-	       * side haven't been swapped yet, only their offset
-	       */
-	      if (TEST_FLAG (ONSOLDERFLAG, Text))
-		{
-		  newline.Point1.X = SWAP_SIGN_X (newline.Point1.X);
-		  newline.Point1.Y = SWAP_SIGN_Y (newline.Point1.Y);
-		  newline.Point2.X = SWAP_SIGN_X (newline.Point2.X);
-		  newline.Point2.Y = SWAP_SIGN_Y (newline.Point2.Y);
-		}
-	      /* add offset and draw line */
-	      newline.Point1.X += Text->X;
-	      newline.Point1.Y += Text->Y;
-	      newline.Point2.X += Text->X;
-	      newline.Point2.Y += Text->Y;
-	      gui->graphics->draw_pcb_line (gc, &newline);
-	    }
-
-	  /* move on to next cursor position */
-	  x += (font->Symbol[*string].Width + font->Symbol[*string].Delta);
-	}
-      else
-	{
-	  /* the default symbol is a filled box */
-	  BoxType defaultsymbol = PCB->Font.DefaultSymbol;
-	  Coord size = (defaultsymbol.X2 - defaultsymbol.X1) * 6 / 5;
-
-	  defaultsymbol.X1 = SCALE_TEXT (defaultsymbol.X1 + x, Text->Scale);
-	  defaultsymbol.Y1 = SCALE_TEXT (defaultsymbol.Y1, Text->Scale);
-	  defaultsymbol.X2 = SCALE_TEXT (defaultsymbol.X2 + x, Text->Scale);
-	  defaultsymbol.Y2 = SCALE_TEXT (defaultsymbol.Y2, Text->Scale);
-
-	  RotateBoxLowLevel (&defaultsymbol, 0, 0, Text->Direction);
-
-	  /* add offset and draw box */
-	  defaultsymbol.X1 += Text->X;
-	  defaultsymbol.Y1 += Text->Y;
-	  defaultsymbol.X2 += Text->X;
-	  defaultsymbol.Y2 += Text->Y;
-	  gui->graphics->fill_rect (gc,
-	                            defaultsymbol.X1, defaultsymbol.Y1,
-	                            defaultsymbol.X2, defaultsymbol.Y2);
-
-	  /* move on to next cursor position */
-	  x += size;
-	}
-      string++;
-    }
-}
-
-/* ---------------------------------------------------------------------------
  * draw a via object
  */
 void
diff --git a/src/draw.h b/src/draw.h
index 88e2349..b58e5cb 100644
--- a/src/draw.h
+++ b/src/draw.h
@@ -44,7 +44,6 @@ void DrawPadName (PadType *);
 void DrawLine (LayerType *, LineType *);
 void DrawArc (LayerType *, ArcType *);
 void DrawText (LayerType *, TextType *);
-void DrawTextLowLevel (hidGC gc, TextType *, Coord);
 void DrawPolygon (LayerType *, PolygonType *);
 void DrawElement (ElementType *);
 void DrawElementName (ElementType *);
diff --git a/src/hid/common/draw_helpers.c b/src/hid/common/draw_helpers.c
index 774c10a..f6fbe71 100644
--- a/src/hid/common/draw_helpers.c
+++ b/src/hid/common/draw_helpers.c
@@ -2,6 +2,7 @@
 #include "hid.h"
 #include "hid_draw.h"
 #include "data.h" /* For global "PCB" variable */
+#include "rotate.h" /* For RotateLineLowLevel() */
 #include "polygon.h"
 
 
@@ -34,6 +35,89 @@ common_draw_pcb_arc (hidGC gc, ArcType *arc)
   gui->graphics->draw_arc (gc, arc->X, arc->Y, arc->Width, arc->Height, arc->StartAngle, arc->Delta);
 }
 
+/* ---------------------------------------------------------------------------
+ * drawing routine for text objects
+ */
+static void
+common_draw_pcb_text (hidGC gc, TextType *Text, Coord min_line_width)
+{
+  Coord x = 0;
+  unsigned char *string = (unsigned char *) Text->TextString;
+  Cardinal n;
+  FontType *font = &PCB->Font;
+
+  while (string && *string)
+    {
+      /* draw lines if symbol is valid and data is present */
+      if (*string <= MAX_FONTPOSITION && font->Symbol[*string].Valid)
+        {
+          LineType *line = font->Symbol[*string].Line;
+          LineType newline;
+
+          for (n = font->Symbol[*string].LineN; n; n--, line++)
+            {
+              /* create one line, scale, move, rotate and swap it */
+              newline = *line;
+              newline.Point1.X = SCALE_TEXT (newline.Point1.X + x, Text->Scale);
+              newline.Point1.Y = SCALE_TEXT (newline.Point1.Y, Text->Scale);
+              newline.Point2.X = SCALE_TEXT (newline.Point2.X + x, Text->Scale);
+              newline.Point2.Y = SCALE_TEXT (newline.Point2.Y, Text->Scale);
+              newline.Thickness = SCALE_TEXT (newline.Thickness, Text->Scale / 2);
+              if (newline.Thickness < min_line_width)
+                newline.Thickness = min_line_width;
+
+              RotateLineLowLevel (&newline, 0, 0, Text->Direction);
+
+              /* the labels of SMD objects on the bottom
+               * side haven't been swapped yet, only their offset
+               */
+              if (TEST_FLAG (ONSOLDERFLAG, Text))
+                {
+                  newline.Point1.X = SWAP_SIGN_X (newline.Point1.X);
+                  newline.Point1.Y = SWAP_SIGN_Y (newline.Point1.Y);
+                  newline.Point2.X = SWAP_SIGN_X (newline.Point2.X);
+                  newline.Point2.Y = SWAP_SIGN_Y (newline.Point2.Y);
+                }
+              /* add offset and draw line */
+              newline.Point1.X += Text->X;
+              newline.Point1.Y += Text->Y;
+              newline.Point2.X += Text->X;
+              newline.Point2.Y += Text->Y;
+              gui->graphics->draw_pcb_line (gc, &newline);
+            }
+
+          /* move on to next cursor position */
+          x += (font->Symbol[*string].Width + font->Symbol[*string].Delta);
+        }
+      else
+        {
+          /* the default symbol is a filled box */
+          BoxType defaultsymbol = PCB->Font.DefaultSymbol;
+          Coord size = (defaultsymbol.X2 - defaultsymbol.X1) * 6 / 5;
+
+          defaultsymbol.X1 = SCALE_TEXT (defaultsymbol.X1 + x, Text->Scale);
+          defaultsymbol.Y1 = SCALE_TEXT (defaultsymbol.Y1, Text->Scale);
+          defaultsymbol.X2 = SCALE_TEXT (defaultsymbol.X2 + x, Text->Scale);
+          defaultsymbol.Y2 = SCALE_TEXT (defaultsymbol.Y2, Text->Scale);
+
+          RotateBoxLowLevel (&defaultsymbol, 0, 0, Text->Direction);
+
+          /* add offset and draw box */
+          defaultsymbol.X1 += Text->X;
+          defaultsymbol.Y1 += Text->Y;
+          defaultsymbol.X2 += Text->X;
+          defaultsymbol.Y2 += Text->Y;
+          gui->graphics->fill_rect (gc,
+                                    defaultsymbol.X1, defaultsymbol.Y1,
+                                    defaultsymbol.X2, defaultsymbol.Y2);
+
+          /* move on to next cursor position */
+          x += size;
+        }
+      string++;
+    }
+}
+
 static void
 fill_contour (hidGC gc, PLINE *pl)
 {
@@ -503,6 +587,7 @@ common_draw_helpers_init (HID_DRAW *graphics)
 {
   graphics->draw_pcb_line        = common_draw_pcb_line;
   graphics->draw_pcb_arc         = common_draw_pcb_arc;
+  graphics->draw_pcb_text        = common_draw_pcb_text;
 
   graphics->fill_pcb_polygon     = common_fill_pcb_polygon;
   graphics->thindraw_pcb_polygon = common_thindraw_pcb_polygon;
diff --git a/src/hid_draw.h b/src/hid_draw.h
index b5081b2..c5fab7d 100644
--- a/src/hid_draw.h
+++ b/src/hid_draw.h
@@ -53,6 +53,7 @@ struct hid_draw_st
 
   void (*draw_pcb_line) (hidGC gc, LineType *line);
   void (*draw_pcb_arc) (hidGC gc, ArcType *arc);
+  void (*draw_pcb_text) (hidGC gc, TextType *, Coord);
 
   void (*fill_pcb_polygon) (hidGC gc, PolygonType *poly, const BoxType *clip_box);
   void (*thindraw_pcb_polygon) (hidGC gc, PolygonType *poly, const BoxType *clip_box);
diff --git a/src/print.c b/src/print.c
index fc6f9ff..69328e7 100644
--- a/src/print.c
+++ b/src/print.c
@@ -112,7 +112,7 @@ text_at (hidGC gc, int x, int y, int align, char *fmt, ...)
   t.X -= w * (align & 3) / 2;
   if (t.X < 0)
     t.X = 0;
-  DrawTextLowLevel (gc, &t, 0);
+  gui->graphics->draw_pcb_text (gc, &t, 0);
   if (align & 8)
     fab_line (gc, t.X,
               t.Y + SCALE_TEXT (font->MaxHeight, t.Scale) + MIL_TO_COORD(10),
@@ -347,7 +347,7 @@ PrintFab (hidGC gc)
       END_LOOP;
       TEXT_LOOP (layer);
       {
-	DrawTextLowLevel (gc, text, 0);
+	gui->graphics->draw_pcb_text (gc, text, 0);
       }
       END_LOOP;
       gui->graphics->set_line_width (gc, FAB_LINE_W);

Bottom: 660793628ca46db91ce4f7ac1ec08c6425692ed5
Top:    3f4d353c7d1fb68ba50c99f0a593c08a1f3a830f
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2014-06-05 20:47:12 +0100

Continue tinkering with 3D games


---

diff --git a/src/hid/gtk/face3d.c b/src/hid/gtk/face3d.c
index 0df8f23..3e1f4a6 100644
--- a/src/hid/gtk/face3d.c
+++ b/src/hid/gtk/face3d.c
@@ -55,3 +55,9 @@ face3d_set_cylindrical (face3d *face, float cx, float cy, float cz, float ax, fl
   face->az = az;
   face->radius = radius;
 }
+
+void
+face3d_set_flip_orientation (face3d *face)
+{
+  face->flip_orientation = true;
+}
diff --git a/src/hid/gtk/face3d.h b/src/hid/gtk/face3d.h
index ed60d6d..ed84990 100644
--- a/src/hid/gtk/face3d.h
+++ b/src/hid/gtk/face3d.h
@@ -8,6 +8,9 @@ typedef struct {
   float ax, ay, az; /* Direction of the axis */
   float radius;
 
+  /* HACK.. need to determine this from the face CW/CCW orientation */
+  bool flip_orientation;
+
   appearance *appear;
 
   /* STEP crap - to hell with encapsulation */
@@ -23,3 +26,4 @@ void face3d_add_contour (face3d *face, contour3d *contour);
 void face3d_set_appearance (face3d *face, appearance *appear);
 void face3d_set_normal (face3d *face, float nx, float ny, float nz);
 void face3d_set_cylindrical (face3d *face, float cx, float cy, float cz, float ax, float ay, float az, float radius);
+void face3d_set_flip_orientation (face3d *face);
diff --git a/src/hid/gtk/object3d.c b/src/hid/gtk/object3d.c
index 49462ca..15fe179 100644
--- a/src/hid/gtk/object3d.c
+++ b/src/hid/gtk/object3d.c
@@ -215,8 +215,8 @@ draw_quad_edge (edge_ref e, void *data)
 
   if (UNDIR_DATA(e) != NULL) {
     edge_info *info = UNDIR_DATA(e);
-    if (info->is_stitch)
-      return;
+//    if (info->is_stitch)
+//      return;
     if (info->is_round) {
       int i;
       glBegin (GL_LINES);
@@ -245,7 +245,8 @@ object3d_draw_debug (void)
 {
   g_return_if_fail (object3d_test_object->edges != NULL);
 
-  quad_enum ((edge_ref)object3d_test_object->edges->data, draw_quad_edge, NULL);
+//  quad_enum ((edge_ref)object3d_test_object->edges->data, draw_quad_edge, NULL);
+  g_list_foreach (object3d_test_object->edges, (GFunc)draw_quad_edge, NULL);
 }
 
 /*********************************************************************************************************/
@@ -420,7 +421,7 @@ object3d_export_to_step (object3d *object, char *filename)
                    next_step_identifier + 3, next_step_identifier, next_step_identifier + 1, next_step_identifier + 2,
                    next_step_identifier + 4, next_step_identifier + 3, face->radius);
 
-          face->plane_orientation_reversed = true;
+          face->plane_orientation_reversed = !face->flip_orientation; /* XXX: SHOULD WORK THIS OUT FROM THE EDGE CONTOUR */
           face->plane_identifier = next_step_identifier + 4;
           next_step_identifier = next_step_identifier + 5;
         }
@@ -483,7 +484,8 @@ object3d_export_to_step (object3d *object, char *filename)
                       "#%i = AXIS2_PLACEMENT_3D ( 'NONE', #%i,  #%i,  #%i ) ; "
                       "#%i = CIRCLE ( 'NONE', #%i, %f ) ;\n",
                    next_step_identifier,     /* Center of the circle   */ info->cx, info->cy, info->cz, // <--- Center of coordinate placement
-                   next_step_identifier + 1, /* Normal of circle?      */ 0.0, 0.0, -1.0, // <--- Z-axis direction of placement             /* XXX: PULL FROM FACE DATA */
+                   next_step_identifier + 1, /* Normal of circle?      */ info->nx, info->ny, info->nz, // <--- Z-axis direction of placement             /* XXX: PULL FROM FACE DATA */
+//                   next_step_identifier + 1, /* Normal of circle?      */ 0.0, 0.0, -1.0, // <--- Z-axis direction of placement             /* XXX: PULL FROM FACE DATA */
                    next_step_identifier + 2, /* ??????                 */ -1.0, 0.0, 0.0, // <--- Approximate X-axis direction of placement /* XXX: PULL FROM FACE DATA */
                    next_step_identifier + 3, next_step_identifier, next_step_identifier + 1, next_step_identifier + 2,
                    next_step_identifier + 4, next_step_identifier + 3, info->radius);
@@ -740,16 +742,12 @@ object3d_from_board_outline (void)
   }
 
   faces[npoints] = make_face3d (); /* bottom_face */
-  faces[npoints]->nx =  0.;
-  faces[npoints]->ny =  0.;
-  faces[npoints]->nz = -1.;
+  face3d_set_normal (faces[npoints], 0., 0., -1.);
   face3d_set_appearance (faces[npoints], top_bot_appearance);
   object3d_add_face (board_object, faces[npoints]);
 
   faces[npoints + 1] = make_face3d (); /* top_face */
-  faces[npoints + 1]->nx = 0.;
-  faces[npoints + 1]->ny = 0.;
-  faces[npoints + 1]->nz = 1.;
+  face3d_set_normal (faces[npoints + 1], 0., 0., 1.);
   face3d_set_appearance (faces[npoints + 1], top_bot_appearance);
   object3d_add_face (board_object, faces[npoints + 1]);
 
@@ -783,9 +781,8 @@ object3d_from_board_outline (void)
 
     /* Setup the face normals for the edges along the contour extrusion (top and bottom are handled separaetely) */
     /* Define the (non-normalized) face normal to point to the outside of the contour */
-    faces[i]->nx = vertices[next_i_around_ct]->y - vertices[i]->y;
-    faces[i]->ny = vertices[i]->x - vertices[next_i_around_ct]->x;
-    faces[i]->nz = 0.;
+    face3d_set_normal (faces[i], (vertices[next_i_around_ct]->y - vertices[i]->y),
+                                -(vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
 
     /* Assign the appropriate vertex geometric data to each edge end */
     ODATA (edges[              i]) = vertices[0 * npoints + i];
@@ -826,7 +823,7 @@ object3d_from_board_outline (void)
 
       edge_info_set_round (UNDIR_DATA (edges[i]),
                            COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), -COORD_TO_MM (HACK_BOARD_THICKNESS), /* Center of circle */
-                           0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius));
+                           0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius)); /* NORMAL POINTING TO -VE Z MAKES CIRCLE CLOCKWISE (??) */
       edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
                            COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* Center of circle */
                            0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius));
@@ -835,6 +832,92 @@ object3d_from_board_outline (void)
 
   }
 
+  if (1) {
+    /* Cylinder centers on 45x45mm, stitch vertex is at 40x45mm. Radius is thus 5mm */
+
+    edge_ref cylinder_edges[3];
+    vertex3d *cylinder_vertices[2];
+    face3d *cylinder_faces[2];
+
+    /* Edge on top of board */
+    cylinder_edges[0] = make_edge ();
+    UNDIR_DATA (cylinder_edges[0]) = make_edge_info ();
+    edge_info_set_round (UNDIR_DATA (cylinder_edges[0]),
+                         45., 45., 0., /* Center of circle */
+                          0.,  0., 1., /* Normal */
+                          5.);         /* Radius */
+    object3d_add_edge (board_object, cylinder_edges[0]);
+
+    /* Edge on top of cylinder */
+    cylinder_edges[1] = make_edge ();
+    UNDIR_DATA (cylinder_edges[1]) = make_edge_info ();
+    edge_info_set_round (UNDIR_DATA (cylinder_edges[1]),
+                         45., 45., 10., /* Center of circle */
+                          0.,  0., 1.,  /* Normal */
+                          5.);          /* Radius */
+    object3d_add_edge (board_object, cylinder_edges[1]);
+
+    /* Edge stitching cylinder */
+    cylinder_edges[2] = make_edge ();
+    UNDIR_DATA (cylinder_edges[2]) = make_edge_info ();
+    edge_info_set_stitch (UNDIR_DATA (cylinder_edges[2]));
+    object3d_add_edge (board_object, cylinder_edges[2]);
+
+    /* Vertex on board top surface */
+    cylinder_vertices[0] = make_vertex3d (40., 45., 0.); /* Bottom */
+    object3d_add_vertex (board_object, cylinder_vertices[0]);
+
+    /* Vertex on cylinder top surface */
+    cylinder_vertices[1] = make_vertex3d (40., 45., 10.); /* Top */
+    object3d_add_vertex (board_object, cylinder_vertices[1]);
+
+    /* Cylindrical face */
+    cylinder_faces[0] = make_face3d ();
+    face3d_set_cylindrical (cylinder_faces[0], 45., 45., 0., /* A point on the axis of the cylinder */
+                                      0., 0., 1.,            /* Direction of the cylindrical axis */
+                                      5.);                   /* Radius of cylinder */
+    face3d_set_flip_orientation (cylinder_faces[0]); /* XXX: HACK TO IDENTIFY THIS AS AN OUTSIDE CYLINDRICAL SURFACE, NOT INTERNAL AS ASSUMED OTHERWISE */
+    face3d_set_normal (cylinder_faces[0], 1., 0., 0.);       /* A normal to the axis direction */
+                                 /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
+    face3d_set_appearance (cylinder_faces[0], top_bot_appearance);
+    object3d_add_face (board_object, cylinder_faces[0]);
+    face3d_add_contour (cylinder_faces[0], make_contour3d (cylinder_edges[0]));
+
+    /* Top face of cylinder */
+    cylinder_faces[1] = make_face3d (); /* top face of cylinder */
+    face3d_set_normal (cylinder_faces[1], 0., 0., 1.);
+    face3d_set_appearance (cylinder_faces[1], top_bot_appearance);
+    object3d_add_face (board_object, cylinder_faces[1]);
+    face3d_add_contour (cylinder_faces[1], make_contour3d (cylinder_edges[1]));
+
+    /* Splice onto board */
+    face3d_add_contour (faces[npoints + 1], make_contour3d (SYM(cylinder_edges[0])));
+
+    /* Assign the appropriate vertex geometric data to each edge end */
+    ODATA (cylinder_edges[0]) = cylinder_vertices[0];
+    DDATA (cylinder_edges[0]) = cylinder_vertices[0];
+    ODATA (cylinder_edges[1]) = cylinder_vertices[1];
+    DDATA (cylinder_edges[1]) = cylinder_vertices[1];
+    ODATA (cylinder_edges[2]) = cylinder_vertices[0];
+    DDATA (cylinder_edges[2]) = cylinder_vertices[1];
+    LDATA (cylinder_edges[0]) = cylinder_faces[0];
+    RDATA (cylinder_edges[0]) = faces[npoints + 1]; /* TOP OF BOARD FACE */
+    LDATA (cylinder_edges[1]) = cylinder_faces[1];
+    RDATA (cylinder_edges[1]) = cylinder_faces[0];
+    LDATA (cylinder_edges[2]) = cylinder_faces[0];
+    RDATA (cylinder_edges[2]) = cylinder_faces[0];
+
+    /* Splice things together.... */
+
+    /* Link edges orbiting the cylinder bottom vertex */
+    splice (cylinder_edges[0], cylinder_edges[2]);
+    splice (cylinder_edges[2], SYM(cylinder_edges[0]));
+
+    /* Link edges orbiting the cylinder top vertex */
+    splice (SYM(cylinder_edges[2]), cylinder_edges[1]);
+    splice (cylinder_edges[1], SYM(cylinder_edges[1]));
+  }
+
   poly_Free (&outline);
 
   return board_object;
@@ -849,183 +932,3 @@ object3d_test_board_outline (void)
   object3d_export_to_step (board_outline, "object3d_test.step");
   destroy_object3d (board_outline);
 }
-
-object3d *
-object3d_from_tracking (void)
-{
-  object3d *board_object;
-  appearance *board_appearance;
-  appearance *top_bot_appearance;
-  POLYAREA *outline;
-  PLINE *contour;
-  PLINE *ct;
-  int ncontours;
-  int npoints;
-  int i;
-  vertex3d **vertices;
-  edge_ref *edges;
-  face3d **faces;
-  int start_of_ct;
-  int offset_in_ct;
-  int ct_npoints;
-
-  outline = board_outline_poly (true);
-  ncontours = 0;
-  npoints = 0;
-
-  /* XXX: There can be more than one contour, but for now we restrict ourselves to the first one */
-  contour = outline->contours;
-
-  ct = contour;
-  while (ct != NULL) {
-    ncontours ++;
-    npoints += get_contour_npoints (ct);
-    ct = ct->next;
-  }
-
-  board_object = make_object3d (PCB->Name);
-  board_appearance = make_appearance ();
-  top_bot_appearance = make_appearance ();
-  appearance_set_color (board_appearance,   1.0, 1.0, 0.6);
-  appearance_set_color (top_bot_appearance, 0.2, 0.8, 0.2);
-
-  object3d_set_appearance (board_object, board_appearance);
-
-  vertices = malloc (sizeof (vertex3d *) * 2 * npoints);
-  edges    = malloc (sizeof (edge_ref  ) * 3 * npoints);
-  faces    = malloc (sizeof (face3d *) * (2 + npoints));
-
-  /* Define the vertices */
-  ct = contour;
-  start_of_ct = 0;
-  offset_in_ct = 0;
-  ct_npoints = get_contour_npoints (ct);
-
-  for (i = 0; i < npoints; i++, offset_in_ct++) {
-    double x1, y1;
-
-    /* Update which contour we're looking at */
-    if (offset_in_ct == ct_npoints) {
-      offset_in_ct = 0;
-      ct = ct->next;
-      ct_npoints = get_contour_npoints (ct);
-    }
-
-    get_contour_coord_n_in_mm (ct, offset_in_ct, &x1, &y1);
-    vertices[i]           = make_vertex3d (x1, y1, -COORD_TO_MM (HACK_BOARD_THICKNESS)); /* Bottom */
-    vertices[npoints + i] = make_vertex3d (x1, y1, 0);                                   /* Top */
-
-    object3d_add_vertex (board_object, vertices[i]);
-    object3d_add_vertex (board_object, vertices[npoints + i]);
-  }
-
-  /* Define the edges */
-  for (i = 0; i < 3 * npoints; i++) {
-    edges[i] = make_edge ();
-    UNDIR_DATA (edges[i]) = make_edge_info ();
-    object3d_add_edge (board_object, edges[i]);
-  }
-
-  /* Define the faces */
-  for (i = 0; i < npoints; i++) {
-    faces[i] = make_face3d ();
-
-    object3d_add_face (board_object, faces[i]);
-    /* Pick one of the upright edges which is within this face outer contour loop, and link it to the face */
-    face3d_add_contour (faces[i], make_contour3d (SYM(edges[2 * npoints + i])));
-  }
-
-  faces[npoints] = make_face3d (); /* bottom_face */
-  face3d_set_normal (faces[npoints], 0., 0., -1.);
-  face3d_set_appearance (faces[npoints], top_bot_appearance);
-  object3d_add_face (board_object, faces[npoints]);
-
-  faces[npoints + 1] = make_face3d (); /* top_face */
-  face3d_set_normal (faces[npoints + 1], 0., 0., 1.);
-  face3d_set_appearance (faces[npoints + 1], top_bot_appearance);
-  object3d_add_face (board_object, faces[npoints + 1]);
-
-  /* Pick the first bottom / top edge within the bottom / top face outer contour loop, and link it to the face */
-  face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[0])));
-  face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints]));
-
-  ct = contour;
-  start_of_ct = 0;
-  offset_in_ct = 0;
-  ct_npoints = get_contour_npoints (ct);
-
-  for (i = 0; i < npoints; i++, offset_in_ct++) {
-    int next_i_around_ct;
-    int prev_i_around_ct;
-
-    /* Update which contour we're looking at */
-    if (offset_in_ct == ct_npoints) {
-      start_of_ct = i;
-      offset_in_ct = 0;
-      ct = ct->next;
-      ct_npoints = get_contour_npoints (ct);
-
-      /* If there is more than one contour, it will be an inner contour of the bottom and top faces. Refer to it here */
-      face3d_add_contour (faces[npoints], make_contour3d (SYM(edges[i])));
-      face3d_add_contour (faces[npoints + 1], make_contour3d (edges[npoints + i]));
-    }
-
-    next_i_around_ct = start_of_ct + (offset_in_ct + 1) % ct_npoints;
-    prev_i_around_ct = start_of_ct + (offset_in_ct + ct_npoints - 1) % ct_npoints;
-
-    /* Setup the face normals for the edges along the contour extrusion (top and bottom are handled separaetely) */
-    /* Define the (non-normalized) face normal to point to the outside of the contour */
-    face3d_set_normal (faces[i], (vertices[next_i_around_ct]->y - vertices[i]->y),
-                                -(vertices[next_i_around_ct]->x - vertices[i]->x), 0.);
-
-    /* Assign the appropriate vertex geometric data to each edge end */
-    ODATA (edges[              i]) = vertices[0 * npoints + i];
-    DDATA (edges[              i]) = vertices[0 * npoints + next_i_around_ct];
-    ODATA (edges[1 * npoints + i]) = vertices[1 * npoints + i];
-    DDATA (edges[1 * npoints + i]) = vertices[1 * npoints + next_i_around_ct];
-    ODATA (edges[2 * npoints + i]) = vertices[0 * npoints + i];
-    DDATA (edges[2 * npoints + i]) = vertices[1 * npoints + i];
-    LDATA (edges[              i]) = faces[i];
-    RDATA (edges[              i]) = faces[npoints];
-    LDATA (edges[1 * npoints + i]) = faces[npoints + 1];
-    RDATA (edges[1 * npoints + i]) = faces[i];
-    LDATA (edges[2 * npoints + i]) = faces[prev_i_around_ct];
-    RDATA (edges[2 * npoints + i]) = faces[i];
-
-    /* NB: Contours are counter clockwise in XY plane.
-     *     edges[          0-npoints-1] are the base of the extrusion, following in the counter clockwise order
-     *     edges[1*npoints-2*npoints-1] are the top  of the extrusion, following in the counter clockwise order
-     *     edges[2*npoints-3*npoints-1] are the upright edges, oriented from bottom to top
-     */
-
-    /* Link edges orbiting around each bottom vertex i (0 <= i < npoints) */
-    splice (edges[i], edges[2 * npoints + i]);
-    splice (edges[2 * npoints + i], SYM(edges[prev_i_around_ct]));
-
-    /* Link edges orbiting around each top vertex (npoints + i) (0 <= i < npoints) */
-    splice (SYM(edges[2 * npoints + i]), edges[npoints + i]);
-    splice (edges[npoints + i], SYM(edges[npoints + prev_i_around_ct]));
-
-    if (ct->is_round) {
-
-      face3d_set_cylindrical (faces[i], COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* A point on the axis of the cylinder */
-                                        0., 0., 1.,                                     /* Direction of the cylindrical axis */
-                                        COORD_TO_MM (ct->radius));
-      face3d_set_normal (faces[i], 1., 0., 0.);  /* A normal to the axis direction */
-                                /* XXX: ^^^ Could line this up with the direction to the vertex in the corresponding circle edge */
-
-      edge_info_set_round (UNDIR_DATA (edges[i]),
-                           COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), -COORD_TO_MM (HACK_BOARD_THICKNESS), /* Center of circle */
-                           0., 0., 1., /* Normal */ COORD_TO_MM (ct->radius));
-      edge_info_set_round (UNDIR_DATA (edges[npoints + i]),
-                           COORD_TO_MM (ct->cx), COORD_TO_MM (ct->cy), 0., /* Center of circle */
-                           0., 0., -1., /* Normal */ COORD_TO_MM (ct->radius));
-      edge_info_set_stitch (UNDIR_DATA (edges[2 * npoints + i]));
-    }
-
-  }
-
-  poly_Free (&outline);
-
-  return board_object;
-}

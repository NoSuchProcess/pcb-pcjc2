Bottom: 1f774a9e46f8195b8496310e5e420d17f8b1802e
Top:    5a2664571c24911339079f5181580621d1a1c95a
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-05-05 21:05:59 +0100

Hack to avoid GL calls when we're out of context


---

diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index cb3012d..d93fb60 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -44,6 +44,7 @@ static hidGC current_gc = NULL;
 static char *current_color = NULL;
 static double global_alpha_mult = 1.0;
 static int alpha_changed = 0;
+static bool check_gl_drawing_ok_hack = false;
 
 
 /* Sets gport->u_gc to the "right" GC to use (wrt mask or window)
@@ -466,6 +467,12 @@ ghid_set_color (hidGC gc, const char *name)
 
   gc->colorname = (char *) name;
 
+  if (!check_gl_drawing_ok_hack)
+    {
+      current_color = NULL;
+      return;
+    }
+
   if (gport->colormap == NULL)
     gport->colormap = gtk_widget_get_colormap (gport->top_window);
   if (strcmp (name, "erase") == 0)
@@ -844,6 +851,9 @@ ghid_show_crosshair (gboolean paint_new_location)
   if (!paint_new_location)
     return;
 
+  if (!check_gl_drawing_ok_hack)
+    return;
+
   if (!done_once)
     {
       done_once = 1;
@@ -1914,6 +1924,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   ghid_start_drawing (port);
 
   hidgl_init ();
+  check_gl_drawing_ok_hack = true;
 
   /* If we don't have any stencil bits available,
      we can't use the hidgl polygon drawing routine */
@@ -2088,6 +2099,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   hidgl_flush_triangles (&buffer);
 
+  check_gl_drawing_ok_hack = false;
   ghid_end_drawing (port);
 
   g_timer_start (priv->time_since_expose);
@@ -2158,6 +2170,8 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   }
   gport->render_priv->in_context = true;
 
+  check_gl_drawing_ok_hack = true;
+
   glEnable (GL_BLEND);
   glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
 
@@ -2204,6 +2218,8 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   else
     glFlush ();
 
+  check_gl_drawing_ok_hack = false;
+
   /* end drawing to current GL-context */
   gport->render_priv->in_context = false;
   gdk_gl_drawable_gl_end (pGlDrawable);
@@ -2233,6 +2249,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   int save_width, save_height;
   int save_view_width, save_view_height;
   BoxType region;
+  bool save_check_gl_drawing_ok_hack;
 
   save_zoom = gport->zoom;
   save_width = gport->width;
@@ -2272,6 +2289,9 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   }
   gport->render_priv->in_context = true;
 
+  save_check_gl_drawing_ok_hack = check_gl_drawing_ok_hack;
+  check_gl_drawing_ok_hack = true;
+
   glEnable (GL_BLEND);
   glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
 
@@ -2316,6 +2336,8 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
 
   glFlush ();
 
+  check_gl_drawing_ok_hack = save_check_gl_drawing_ok_hack;
+
   /* end drawing to current GL-context */
   gport->render_priv->in_context = false;
   gdk_gl_drawable_gl_end (gldrawable);

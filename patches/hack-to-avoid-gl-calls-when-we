Bottom: 130dc60e1f4e5d50648c339e13090957997e4239
Top:    ef93c010d4431934fa66456d8560cdf7399cd2bf
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-08-15 12:30:58 +0100

Hack to avoid GL calls when we're out of context


---

diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 4a23691..8973854 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -39,6 +39,7 @@ RCSID ("$Id$");
 extern HID ghid_hid;
 
 static hidGC current_gc = NULL;
+static bool check_gl_drawing_ok_hack = false;
 
 /* Sets gport->u_gc to the "right" GC to use (wrt mask or window)
 */
@@ -495,6 +496,15 @@ set_gl_color_for_gc (hidGC gc)
     return;
 
   free (priv->current_colorname);
+  priv->current_colorname = NULL;
+
+  /* If we can't set the GL colour right now, quit with
+   * current_colorname set to NULL, so we don't NOOP the
+   * next set_gl_color_for_gc call.
+   */
+  if (!check_gl_drawing_ok_hack)
+    return;
+
   priv->current_colorname = strdup (gc->colorname);
   priv->current_alpha_mult = gc->alpha_mult;
 
@@ -880,6 +890,9 @@ ghid_show_crosshair (gboolean paint_new_location)
   if (!paint_new_location)
     return;
 
+  if (!check_gl_drawing_ok_hack)
+    return;
+
   if (!done_once)
     {
       done_once = 1;
@@ -1949,6 +1962,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   ghid_start_drawing (port);
 
   hidgl_init ();
+  check_gl_drawing_ok_hack = true;
 
   /* If we don't have any stencil bits available,
      we can't use the hidgl polygon drawing routine */
@@ -2124,6 +2138,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   draw_lead_user (priv);
 
+  check_gl_drawing_ok_hack = false;
   ghid_end_drawing (port);
 
   g_timer_start (priv->time_since_expose);
@@ -2195,6 +2210,8 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   }
   gport->render_priv->in_context = true;
 
+  check_gl_drawing_ok_hack = true;
+
   glEnable (GL_BLEND);
   glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
 
@@ -2241,6 +2258,8 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   else
     glFlush ();
 
+  check_gl_drawing_ok_hack = false;
+
   /* end drawing to current GL-context */
   gport->render_priv->in_context = false;
   gdk_gl_drawable_gl_end (pGlDrawable);
@@ -2271,6 +2290,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   int save_width, save_height;
   int save_view_width, save_view_height;
   BoxType region;
+  bool save_check_gl_drawing_ok_hack;
 
   save_zoom = gport->zoom;
   save_width = gport->width;
@@ -2310,6 +2330,9 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   }
   gport->render_priv->in_context = true;
 
+  save_check_gl_drawing_ok_hack = check_gl_drawing_ok_hack;
+  check_gl_drawing_ok_hack = true;
+
   glEnable (GL_BLEND);
   glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
 
@@ -2354,6 +2377,8 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
 
   glFlush ();
 
+  check_gl_drawing_ok_hack = save_check_gl_drawing_ok_hack;
+
   /* end drawing to current GL-context */
   gport->render_priv->in_context = false;
   gdk_gl_drawable_gl_end (gldrawable);

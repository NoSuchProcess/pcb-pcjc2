Bottom: 6eeae37caf6f04367653ca9b6cd9dd96039bf17a
Top:    b241a5ef5e77a1bb6b561aef90bedd62d58cb806
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-09-12 17:01:51 +0100

Hack to avoid GL calls when we're out of context


---

diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 1ebc109..864440b 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -39,6 +39,7 @@ RCSID ("$Id$");
 extern HID ghid_hid;
 
 static hidGC current_gc = NULL;
+static bool check_gl_drawing_ok_hack = false;
 
 /* Sets gport->u_gc to the "right" GC to use (wrt mask or window)
 */
@@ -487,6 +488,15 @@ set_gl_color_for_gc (hidGC gc)
     return;
 
   free (priv->current_colorname);
+  priv->current_colorname = NULL;
+
+  /* If we can't set the GL colour right now, quit with
+   * current_colorname set to NULL, so we don't NOOP the
+   * next set_gl_color_for_gc call.
+   */
+  if (!check_gl_drawing_ok_hack)
+    return;
+
   priv->current_colorname = strdup (gc->colorname);
   priv->current_alpha_mult = gc->alpha_mult;
 
@@ -865,6 +875,9 @@ ghid_show_crosshair (gboolean paint_new_location)
   if (!paint_new_location)
     return;
 
+  if (!check_gl_drawing_ok_hack)
+    return;
+
   if (!done_once)
     {
       done_once = 1;
@@ -1908,6 +1921,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   ghid_start_drawing (port);
 
   hidgl_init ();
+  check_gl_drawing_ok_hack = true;
 
   /* If we don't have any stencil bits available,
      we can't use the hidgl polygon drawing routine */
@@ -2088,6 +2102,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   draw_lead_user (priv);
 
+  check_gl_drawing_ok_hack = false;
   ghid_end_drawing (port);
 
   g_timer_start (priv->time_since_expose);
@@ -2152,6 +2167,8 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   }
   gport->render_priv->in_context = true;
 
+  check_gl_drawing_ok_hack = true;
+
   glEnable (GL_BLEND);
   glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
 
@@ -2198,6 +2215,8 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   else
     glFlush ();
 
+  check_gl_drawing_ok_hack = false;
+
   /* end drawing to current GL-context */
   gport->render_priv->in_context = false;
   gdk_gl_drawable_gl_end (pGlDrawable);
@@ -2221,6 +2240,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   view_data save_view;
   int save_width, save_height;
   BoxType region;
+  bool save_check_gl_drawing_ok_hack;
 
   save_view = gport->view;
   save_width = gport->width;
@@ -2256,6 +2276,9 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   }
   gport->render_priv->in_context = true;
 
+  save_check_gl_drawing_ok_hack = check_gl_drawing_ok_hack;
+  check_gl_drawing_ok_hack = true;
+
   glEnable (GL_BLEND);
   glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
 
@@ -2307,6 +2330,8 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
 
   glFlush ();
 
+  check_gl_drawing_ok_hack = save_check_gl_drawing_ok_hack;
+
   /* end drawing to current GL-context */
   gport->render_priv->in_context = false;
   gdk_gl_drawable_gl_end (gldrawable);

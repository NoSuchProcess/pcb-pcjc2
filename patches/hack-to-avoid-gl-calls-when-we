Bottom: b9e65f26534752eadaddbbe64d5a14c94346e709
Top:    fbb23b7a56da4cabe4d0a433f595c83034b4c899
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-09-05 00:36:13 +0100

Hack to avoid GL calls when we're out of context


---

diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 33a7b2e..7201a8c 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -39,6 +39,7 @@ RCSID ("$Id$");
 extern HID ghid_hid;
 
 static hidGC current_gc = NULL;
+static bool check_gl_drawing_ok_hack = false;
 
 /* Sets gport->u_gc to the "right" GC to use (wrt mask or window)
 */
@@ -469,6 +470,15 @@ set_gl_color_for_gc (hidGC gc)
     return;
 
   free (priv->current_colorname);
+  priv->current_colorname = NULL;
+
+  /* If we can't set the GL colour right now, quit with
+   * current_colorname set to NULL, so we don't NOOP the
+   * next set_gl_color_for_gc call.
+   */
+  if (!check_gl_drawing_ok_hack)
+    return;
+
   priv->current_colorname = strdup (gc->colorname);
   priv->current_alpha_mult = gc->alpha_mult;
 
@@ -853,6 +863,9 @@ ghid_show_crosshair (gboolean paint_new_location)
   if (!paint_new_location)
     return;
 
+  if (!check_gl_drawing_ok_hack)
+    return;
+
   if (!done_once)
     {
       done_once = 1;
@@ -1925,6 +1938,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   ghid_start_drawing (port);
 
   hidgl_init ();
+  check_gl_drawing_ok_hack = true;
 
   /* If we don't have any stencil bits available,
      we can't use the hidgl polygon drawing routine */
@@ -2105,6 +2119,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   draw_lead_user (priv);
 
+  check_gl_drawing_ok_hack = false;
   ghid_end_drawing (port);
 
   g_timer_start (priv->time_since_expose);
@@ -2169,6 +2184,8 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   }
   gport->render_priv->in_context = true;
 
+  check_gl_drawing_ok_hack = true;
+
   glEnable (GL_BLEND);
   glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
 
@@ -2215,6 +2232,8 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   else
     glFlush ();
 
+  check_gl_drawing_ok_hack = false;
+
   /* end drawing to current GL-context */
   gport->render_priv->in_context = false;
   gdk_gl_drawable_gl_end (pGlDrawable);
@@ -2238,6 +2257,7 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   view_data save_view;
   int save_width, save_height;
   BoxType region;
+  bool save_check_gl_drawing_ok_hack;
 
   save_view = gport->view;
   save_width = gport->width;
@@ -2273,6 +2293,9 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
   }
   gport->render_priv->in_context = true;
 
+  save_check_gl_drawing_ok_hack = check_gl_drawing_ok_hack;
+  check_gl_drawing_ok_hack = true;
+
   glEnable (GL_BLEND);
   glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
 
@@ -2324,6 +2347,8 @@ ghid_render_pixmap (int cx, int cy, double zoom, int width, int height, int dept
 
   glFlush ();
 
+  check_gl_drawing_ok_hack = save_check_gl_drawing_ok_hack;
+
   /* end drawing to current GL-context */
   gport->render_priv->in_context = false;
   gdk_gl_drawable_gl_end (gldrawable);

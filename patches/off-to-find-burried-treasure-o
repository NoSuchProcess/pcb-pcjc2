Bottom: 7215dbe6aec64b81b93731a363479afaac007c5c
Top:    76e3c92a33e92902a80ffcd9a049f9a292263e70
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2008-10-13 20:42:50 +0100

Off to find burried treasure on polygon island

Add feature to remove islanded areas











---

diff --git a/src/buffer.c b/src/buffer.c
index fe1ee5e..ec35974 100644
--- a/src/buffer.c
+++ b/src/buffer.c
@@ -373,7 +373,7 @@ MovePourToBuffer (LayerTypePtr Layer, PourTypePtr Pour)
   LayerTypePtr lay;
   PourTypePtr pour;
 
-  RestoreToPours (Source, POLYGON_TYPE, Layer, Pour);
+  RestoreToPours (Source, POUR_TYPE, Layer, Pour);
   r_delete_entry (Layer->pour_tree, (BoxTypePtr) Pour);
   lay = &Dest->Layer[GetLayerNumber (Source, Layer)];
   pour = GetPourMemory (lay);
@@ -387,7 +387,7 @@ MovePourToBuffer (LayerTypePtr Layer, PourTypePtr Pour)
   if (!lay->pour_tree)
     lay->pour_tree = r_create_tree (NULL, 0, 0);
   r_insert_entry (lay->pour_tree, (BoxTypePtr) pour, 0);
-  ClearFromPours (Source, POLYGON_TYPE, Layer, Pour);
+  ClearFromPours (Dest, POUR_TYPE, lay, Pour);
   return (pour);
 }
 
diff --git a/src/change.c b/src/change.c
index 669a100..f3a6af5 100644
--- a/src/change.c
+++ b/src/change.c
@@ -1107,10 +1107,12 @@ ChangeLineJoin (LayerTypePtr Layer, LineTypePtr Line)
   AddObjectToFlagUndoList (LINE_TYPE, Layer, Line, Line);
   TOGGLE_FLAG (CLEARLINEFLAG, Line);
   if (TEST_FLAG(CLEARLINEFLAG, Line))
-  {
-  AddObjectToClearPourUndoList (LINE_TYPE, Layer, Line, Line, True);
-  ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
-  }
+    {
+      AddObjectToClearPourUndoList (LINE_TYPE, Layer, Line, Line, True);
+      ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
+    }
+  else
+    MarkPourIslands (PCB->Data, LINE_TYPE, Layer, Line);
   DrawLine (Layer, Line, 0);
   return (Line);
 }
@@ -1155,9 +1157,11 @@ ChangeArcJoin (LayerTypePtr Layer, ArcTypePtr Arc)
   TOGGLE_FLAG (CLEARLINEFLAG, Arc);
   if (TEST_FLAG (CLEARLINEFLAG, Arc))
     {
-      ClearFromPours (PCB->Data, ARC_TYPE, Layer, Arc);
       AddObjectToClearPourUndoList (ARC_TYPE, Layer, Arc, Arc, True);
+      ClearFromPours (PCB->Data, ARC_TYPE, Layer, Arc);
     }
+  else
+    MarkPourIslands (PCB->Data, ARC_TYPE, Layer, Arc);
   DrawArc (Layer, Arc, 0);
   return (Arc);
 }
@@ -1201,10 +1205,12 @@ ChangeTextJoin (LayerTypePtr Layer, TextTypePtr Text)
   AddObjectToFlagUndoList (LINE_TYPE, Layer, Text, Text);
   TOGGLE_FLAG (CLEARLINEFLAG, Text);
   if (TEST_FLAG(CLEARLINEFLAG, Text))
-  {
-  AddObjectToClearPourUndoList (TEXT_TYPE, Layer, Text, Text, True);
-  ClearFromPours (PCB->Data, TEXT_TYPE, Layer, Text);
-  }
+    {
+      AddObjectToClearPourUndoList (TEXT_TYPE, Layer, Text, Text, True);
+      ClearFromPours (PCB->Data, TEXT_TYPE, Layer, Text);
+    }
+  else
+    MarkPourIslands (PCB->Data, TEXT_TYPE, Layer, Text);
   DrawText (Layer, Text, 0);
   return (Text);
 }
@@ -1226,10 +1232,12 @@ ChangePourJoin (LayerTypePtr Layer, PourTypePtr pour)
   AddObjectToFlagUndoList (LINE_TYPE, Layer, pour, pour);
   TOGGLE_FLAG (CLEARLINEFLAG, pour);
   if (TEST_FLAG(CLEARLINEFLAG, pour))
-  {
-  AddObjectToClearPourUndoList (POUR_TYPE, Layer, pour, pour, True);
-  ClearFromPours (PCB->Data, POUR_TYPE, Layer, pour);
-  }
+    {
+      AddObjectToClearPourUndoList (POUR_TYPE, Layer, pour, pour, True);
+      ClearFromPours (PCB->Data, POUR_TYPE, Layer, pour);
+    }
+  else
+    MarkPourIslands (PCB->Data, POUR_TYPE, Layer, pour);
   DrawPour (Layer, pour, 0);
   return (pour);
 }
@@ -1602,6 +1610,8 @@ ChangeHole (PinTypePtr Via)
     {
       AddObjectTo2ndSizeUndoList (VIA_TYPE, Via, Via, Via);
       Via->DrillingHole = Via->Thickness - MIN_PINORVIACOPPER;
+#warning FIXME Later: Come back to check this
+      MarkPourIslands (PCB->Data, VIA_TYPE, Via, Via);
     }
   DrawVia (Via, 0);
   Draw ();
diff --git a/src/draw.c b/src/draw.c
index 92a2e21..189554d 100644
--- a/src/draw.c
+++ b/src/draw.c
@@ -2251,6 +2251,10 @@ thin_callback (PLINE * pl, LayerTypePtr lay, PolygonTypePtr poly)
 static void
 DrawPlainPolygon (LayerTypePtr Layer, PolygonTypePtr Polygon)
 {
+  // Re-use HOLEFLAG to cut out islands
+  if (TEST_FLAG (HOLEFLAG, Polygon))
+    return;
+
   if (TEST_FLAG (SELECTEDFLAG | FOUNDFLAG, Polygon))
     {
       if (TEST_FLAG (SELECTEDFLAG, Polygon))
diff --git a/src/find.c b/src/find.c
index 2ff7d64..5ed1074 100644
--- a/src/find.c
+++ b/src/find.c
@@ -2480,6 +2480,7 @@ LookupLOConnectionsToPolygon (PolygonTypePtr Polygon, Cardinal LayerGroup)
 
   if (!Polygon->Clipped)
     return False;
+
   info.polygon = *Polygon;
   EXPAND_BOUNDS (&info.polygon);
   info.layer = LayerGroup;
@@ -3783,6 +3784,70 @@ doIsBad:
 }
 
 /*-----------------------------------------------------------------------------
+ * Check for islanding of a polygon
+ * by determining if any non-polygon objects are connected to it.
+ */
+int
+IsPolygonAnIsland (LayerType *layer, PolygonType *polygon)
+{
+  int connected_count = 0;
+  int any_more;
+  int i;
+
+  InitConnectionLookup ();
+
+  /* Need to ensure we don't set the SELECTED flag as we find
+   * things, otherwise we don't get our quick escape due to the
+   * "drc" magic.
+   *
+   * (The connection scanning code doesn't stop on objects which are
+   *  SELECTED, even if "drc" is true).
+   *
+   * Ideally we'd clear the SELECTED flag on all objects before we
+   * start, ensuring we exit when we first find connectivity, but
+   * that causes all manner of breakage. I upsets other logic in
+   * PCB if we change the selection during certain operations we're
+   * called during.
+   */
+  TheFlag = FOUNDFLAG | DRCFLAG;
+
+  ResetConnections (False);
+
+  /* Let the search stop if we find something we haven't yet seen */
+  drc = True;
+  User = False;
+
+  ListStart (POLYGON_TYPE, layer, polygon, polygon);
+
+  do
+    {
+      any_more = DoIt (False, False);
+
+      /* Check if we got any useful hits */
+      connected_count = 0;
+      for (i = 0; i < max_layer; i++)
+        {
+          connected_count += LineList[ i ].Number;
+          /* No need to search all layers when one will do */
+          if (connected_count)
+            break;
+        }
+      connected_count += PadList[ COMPONENT_LAYER ].Number;
+      connected_count += PadList[ SOLDER_LAYER ].Number;
+      connected_count += PVList.Number;
+      if (connected_count)
+        break;
+    }
+  while (any_more);
+
+  drc = False;
+  ResetConnections (False);
+  FreeConnectionLookupMemory ();
+
+  return (connected_count == 0);
+}
+
+/*-----------------------------------------------------------------------------
  * Check for DRC violations
  * see if the connectivity changes when everything is bloated, or shrunk
  */
diff --git a/src/find.h b/src/find.h
index aae9d89..ade7f5e 100644
--- a/src/find.h
+++ b/src/find.h
@@ -65,6 +65,7 @@ void FreeLayoutLookupMemory (void);
 void RatFindHook (int, void *, void *, void *, Boolean, Boolean);
 void SaveFindFlag (int);
 void RestoreFindFlag (void);
+int IsPolygonAnIsland (LayerTypePtr, PolygonTypePtr);
 int DRCAll (void);
 Boolean lineClear (LineTypePtr, Cardinal);
 Boolean IsLineInPolygon (LineTypePtr, PolygonTypePtr);
diff --git a/src/move.c b/src/move.c
index 699a8a3..d853d3f 100644
--- a/src/move.c
+++ b/src/move.c
@@ -366,12 +366,12 @@ MovePour (LayerTypePtr Layer, PourTypePtr Pour)
     {
       ErasePour (Pour);
     }
-  RestoreToPours (PCB->Data, POLYGON_TYPE, Layer, Pour);
+  RestoreToPours (PCB->Data, POUR_TYPE, Layer, Pour);
   r_delete_entry (Layer->pour_tree, (BoxType *) Pour);
   MovePourLowLevel (Pour, DeltaX, DeltaY);
   r_insert_entry (Layer->pour_tree, (BoxType *) Pour, 0);
   InitPourClip (PCB->Data, Layer, Pour);
-  ClearFromPours (PCB->Data, POLYGON_TYPE, Layer, Pour);
+  ClearFromPours (PCB->Data, POUR_TYPE, Layer, Pour);
   if (Layer->On)
     {
       DrawPour (Layer, Pour, 0);
@@ -395,7 +395,10 @@ MoveLinePoint (LayerTypePtr Layer, LineTypePtr Line, PointTypePtr Point)
       MOVE (Point->X, Point->Y, DeltaX, DeltaY);
       SetLineBoundingBox (Line);
       r_insert_entry (Layer->line_tree, &Line->BoundingBox, 0);
-      ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
+      if (TEST_FLAG (CLEARLINEFLAG, Line))
+        ClearFromPours (PCB->Data, LINE_TYPE, Layer, Line);
+      else
+        MarkPourIslands (PCB->Data, LINE_TYPE, Layer, Line);
       if (Layer->On)
 	{
 	  DrawLine (Layer, Line, 0);
@@ -430,14 +433,17 @@ MovePourPoint (LayerTypePtr Layer, PourTypePtr Pour, PointTypePtr Point)
     {
       ErasePour (Pour);
     }
-  RestoreToPours (PCB->Data, POLYGON_TYPE, Layer, Pour);
+  RestoreToPours (PCB->Data, POUR_TYPE, Layer, Pour);
   r_delete_entry (Layer->pour_tree, (BoxType *) Pour);
   MOVE (Point->X, Point->Y, DeltaX, DeltaY);
   SetPourBoundingBox (Pour);
   r_insert_entry (Layer->pour_tree, (BoxType *) Pour, 0);
   RemoveExcessPourPoints (Layer, Pour);
   InitPourClip (PCB->Data, Layer, Pour);
-  ClearFromPours (PCB->Data, POLYGON_TYPE, Layer, Pour);
+  if (!TEST_FLAG (CLEARPOLYFLAG, Pour))
+    ClearFromPours (PCB->Data, POUR_TYPE, Layer, Pour);
+  else
+    MarkPourIslands (PCB->Data, POUR_TYPE, Layer, Pour);
   if (Layer->On)
     {
       DrawPour (Layer, Pour, 0);
diff --git a/src/pour.c b/src/pour.c
index 17116ff..5fe398e 100644
--- a/src/pour.c
+++ b/src/pour.c
@@ -66,7 +66,7 @@ RCSID ("$Id$");
 
 #define ROUND(x) ((long)(((x) >= 0 ? (x) + 0.5  : (x) - 0.5)))
 
-#define UNSUBTRACT_BLOAT 100
+#define UNSUBTRACT_BLOAT 10
 
 /* ---------------------------------------------------------------------------
  * local prototypes
@@ -657,7 +657,36 @@ ClearPour (DataTypePtr Data, LayerTypePtr Layer, PourType * pour,
 }
 
 static int
-subtract_plow (DataTypePtr Data, LayerTypePtr Layer, PourTypePtr pour,
+check_polygon_island_cb (const BoxType * b, void *cl)
+{
+  PolygonTypePtr polygon = (PolygonTypePtr) b;
+  struct cpInfo *info = (struct cpInfo *) cl;
+
+  ASSIGN_FLAG (HOLEFLAG, IsPolygonAnIsland (info->layer, polygon), polygon);
+  return 1;
+}
+
+static int
+mark_islands (DataTypePtr Data, LayerTypePtr layer, PourTypePtr pour,
+              int type, void *ptr1, void *ptr2)
+{
+  struct cpInfo info;
+  BoxType region = ((PinTypePtr) ptr2)->BoundingBox;
+
+  region.X1 -= UNSUBTRACT_BLOAT;
+  region.Y1 -= UNSUBTRACT_BLOAT;
+  region.X2 += UNSUBTRACT_BLOAT;
+  region.Y2 += UNSUBTRACT_BLOAT;
+
+  info.region = &region;
+  info.layer = layer;
+
+  return r_search (pour->polygon_tree, info.region, NULL,
+                   check_polygon_island_cb, &info);
+}
+
+static int
+subtract_plow (DataTypePtr Data, LayerTypePtr layer, PourTypePtr pour,
               int type, void *ptr1, void *ptr2)
 {
   POLYAREA *np = NULL, *pg = NULL, *start_pg, *tmp;
@@ -667,7 +696,7 @@ subtract_plow (DataTypePtr Data, LayerTypePtr Layer, PourTypePtr pour,
     {
     case PIN_TYPE:
     case VIA_TYPE:
-      np = get_subtract_pin_poly (Data, (PinTypePtr) ptr2, Layer, pour);
+      np = get_subtract_pin_poly (Data, (PinTypePtr) ptr2, layer, pour);
       break;
     case LINE_TYPE:
       np = get_subtract_line_poly ((LineTypePtr) ptr2, pour);
@@ -681,6 +710,10 @@ subtract_plow (DataTypePtr Data, LayerTypePtr Layer, PourTypePtr pour,
     case POLYGON_TYPE:
       np = get_subtract_polygon_poly ((PolygonTypePtr) ptr2, pour);
       break;
+    case POUR_TYPE:
+#warning FIXME Later: Need to produce a function for this
+      np = NULL;
+      break;
     case TEXT_TYPE:
       np = get_subtract_text_poly ((TextTypePtr) ptr2, pour);
       break;
@@ -798,6 +831,8 @@ subtract_plow (DataTypePtr Data, LayerTypePtr Layer, PourTypePtr pour,
     }
   while ((pg = tmp) != start_pg);
 
+  mark_islands (Data, layer, pour, type, ptr1, ptr2);
+
   return 0;
 }
 
@@ -900,7 +935,7 @@ original_pour_poly (PourType * p)
 }
 
 static int
-add_plow (DataTypePtr Data, LayerTypePtr Layer, PourTypePtr pour,
+add_plow (DataTypePtr Data, LayerTypePtr layer, PourTypePtr pour,
           int type, void *ptr1, void *ptr2)
 {
   POLYAREA *np = NULL, *pg = NULL, *tmp, *start_pg;
@@ -910,22 +945,26 @@ add_plow (DataTypePtr Data, LayerTypePtr Layer, PourTypePtr pour,
     {
     case PIN_TYPE:
     case VIA_TYPE:
-      np = get_unsubtract_pin_poly ((PinTypePtr) ptr2, Layer, pour);
+      np = get_unsubtract_pin_poly ((PinTypePtr) ptr2, layer, pour);
       break;
     case LINE_TYPE:
-      np = get_unsubtract_line_poly ((LineTypePtr) ptr2, Layer, pour);
+      np = get_unsubtract_line_poly ((LineTypePtr) ptr2, layer, pour);
       break;
     case ARC_TYPE:
-      np = get_unsubtract_arc_poly ((ArcTypePtr) ptr2, Layer, pour);
+      np = get_unsubtract_arc_poly ((ArcTypePtr) ptr2, layer, pour);
       break;
     case PAD_TYPE:
-      np = get_unsubtract_pad_poly ((PadTypePtr) ptr2, Layer, pour);
+      np = get_unsubtract_pad_poly ((PadTypePtr) ptr2, layer, pour);
       break;
     case POLYGON_TYPE:
-      np = get_unsubtract_polygon_poly ((PolygonTypePtr) ptr2, Layer, pour);
+      np = get_unsubtract_polygon_poly ((PolygonTypePtr) ptr2, layer, pour);
+      break;
+    case POUR_TYPE:
+#warning FIXME Later: Need to produce a function for this
+      np = NULL;
       break;
     case TEXT_TYPE:
-      np = get_unsubtract_text_poly ((TextTypePtr) ptr2, Layer, pour);
+      np = get_unsubtract_text_poly ((TextTypePtr) ptr2, layer, pour);
       break;
     }
 
@@ -1006,7 +1045,7 @@ add_plow (DataTypePtr Data, LayerTypePtr Layer, PourTypePtr pour,
   printf ("After unsubtract, counted %i polygon pieces\n", count);
 #endif
 
-  ClearPour (PCB->Data, Layer, pour, &pg, (const BoxType *) ptr2, 2 * UNSUBTRACT_BLOAT);
+  ClearPour (PCB->Data, layer, pour, &pg, (const BoxType *) ptr2, 2 * UNSUBTRACT_BLOAT);
 
   if (pg == NULL)
     {
@@ -1047,6 +1086,8 @@ add_plow (DataTypePtr Data, LayerTypePtr Layer, PourTypePtr pour,
     }
   while ((pg = tmp) != start_pg);
 
+  mark_islands (Data, layer, pour, type, ptr1, ptr2);
+
 //  printf ("ClearPour counted %i polygon pieces, and added the biggest %i\n", count_all, count_added);
 
   return 0;
@@ -1118,6 +1159,12 @@ InitPourClip (DataTypePtr Data, LayerTypePtr layer, PourType * pour)
     }
   while ((pg = tmp) != start_pg);
 
+  POURPOLYGON_LOOP (pour);
+  {
+    ASSIGN_FLAG (HOLEFLAG, IsPolygonAnIsland (layer, polygon), polygon);
+  }
+  END_LOOP;
+
   return 1;
 }
 
@@ -1147,7 +1194,8 @@ int
 PlowPours (DataType * Data, int type, void *ptr1, void *ptr2,
            int (*call_back) (DataTypePtr data, LayerTypePtr lay,
                              PourTypePtr poly, int type,
-                             void *ptr1, void *ptr2))
+                             void *ptr1, void *ptr2),
+           int ignore_clearflags)
 {
   BoxType sb = ((PinTypePtr) ptr2)->BoundingBox;
   int r = 0;
@@ -1187,8 +1235,10 @@ PlowPours (DataType * Data, int type, void *ptr1, void *ptr2,
     case ARC_TYPE:
     case TEXT_TYPE:
     case POLYGON_TYPE:
+    case POUR_TYPE:
       /* the cast works equally well for lines and arcs */
-      if (!TEST_FLAG (CLEARLINEFLAG, (LineTypePtr) ptr2))
+      if (!ignore_clearflags &&
+          !TEST_FLAG (CLEARLINEFLAG, (LineTypePtr) ptr2))
         return 0;
       /* silk doesn't plow */
       if (GetLayerNumber (Data, ptr1) >= max_layer)
@@ -1220,12 +1270,12 @@ PlowPours (DataType * Data, int type, void *ptr1, void *ptr2,
       {
         PIN_LOOP ((ElementType *) ptr1);
         {
-          PlowPours (Data, PIN_TYPE, ptr1, pin, call_back);
+          PlowPours (Data, PIN_TYPE, ptr1, pin, call_back, ignore_clearflags);
         }
         END_LOOP;
         PAD_LOOP ((ElementType *) ptr1);
         {
-          PlowPours (Data, PAD_TYPE, ptr1, pad, call_back);
+          PlowPours (Data, PAD_TYPE, ptr1, pad, call_back, ignore_clearflags);
         }
         END_LOOP;
       }
@@ -1245,7 +1295,7 @@ RestoreToPours (DataType * Data, int type, void *ptr1, void *ptr2)
 //      printf ("Calling InitPourClip from RestoreToPour\n");
       InitPourClip (PCB->Data, (LayerTypePtr) ptr1, (PourTypePtr) ptr2);
     }
-  PlowPours (Data, type, ptr1, ptr2, add_plow);
+  PlowPours (Data, type, ptr1, ptr2, add_plow, False);
 }
 
 void
@@ -1259,6 +1309,14 @@ ClearFromPours (DataType * Data, int type, void *ptr1, void *ptr2)
 //      printf ("Calling InitPourClip from ClearFromPour\n");
       InitPourClip (PCB->Data, (LayerTypePtr) ptr1, (PourTypePtr) ptr2);
     }
-  PlowPours (Data, type, ptr1, ptr2, subtract_plow);
+  PlowPours (Data, type, ptr1, ptr2, subtract_plow, False);
 }
 
+#warning FIXME Later: We could perhaps reduce un-necessary computation by using this function
+void
+MarkPourIslands (DataType * Data, int type, void *ptr1, void *ptr2)
+{
+  if (!Data->ClipPours)
+    return;
+  PlowPours (Data, type, ptr1, ptr2, mark_islands, True);
+}
diff --git a/src/pour.h b/src/pour.h
index f04e342..559f20e 100644
--- a/src/pour.h
+++ b/src/pour.h
@@ -43,5 +43,6 @@ void CopyAttachedPourToLayer (void);
 int InitPourClip(DataType *d, LayerType *l, PourType *p);
 void RestoreToPours(DataType *, int, void *, void *);
 void ClearFromPours(DataType *, int, void *, void *);
+void MarkPourIslands(DataType *, int, void *, void *);
 
 #endif /* __POUR_INCLUDED__ */
diff --git a/src/search.c b/src/search.c
index cfe648a..fe75969 100644
--- a/src/search.c
+++ b/src/search.c
@@ -466,7 +466,7 @@ SearchPolygonByLocation (int locked, LayerTypePtr * Layer,
   return (True);
 }
 
-#warning FIXME Later: For now, can only select a pour if you're hitting its child polygons
+#warning FIXME Later: For now, can only select a pour if youre hitting its child polygons
 #if 0
 static int
 pour_callback (const BoxType * box, void *cl)
@@ -500,7 +500,7 @@ SearchPourByLocation (int locked, LayerTypePtr * Layer,
   info.ptr3 = (void **) Dummy;
   info.locked = (locked & LOCKED_TYPE) ? 0 : LOCKFLAG;
 
-#warning FIXME Later: For now, can only select a pour if you're hitting its child polygons
+#warning FIXME Later: For now, can only select a pour if youre hitting its child polygons
   if (setjmp (info.env) == 0)
     {
       r_search (SearchLayer->pour_tree, &SearchBox, NULL, pour_polygon_callback, &info);
diff --git a/src/undo.c b/src/undo.c
index 5bcc2d9..a767867 100644
--- a/src/undo.c
+++ b/src/undo.c
@@ -1156,8 +1156,8 @@ AddObjectToClearPourUndoList (int Type, void *Ptr1, void *Ptr2, void *Ptr3,
   if (!Locked)
     {
       undo = GetUndoSlot (UNDO_CLEAR, OBJECT_ID (Ptr3), Type);
-      undo->Data.ClearPoly.Clear = clear;
-      undo->Data.ClearPoly.Layer = (LayerTypePtr) Ptr1;
+      undo->Data.ClearPour.Clear = clear;
+      undo->Data.ClearPour.Layer = (LayerTypePtr) Ptr1;
     }
 }

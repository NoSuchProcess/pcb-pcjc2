Bottom: 731444a98f6ce16245b94298956a861253e6d508
Top:    0d792631996eae6df3908d4fd510d479dae7462f
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-04-26 21:10:01 +0100

Rename HideCrosshair() and RestoreCrosshair()

Whist this is a tedious rename which will probably have implications
for some plugins, it is important to clarify what is going on with
the crosshair across forthcoming patches which put it under the control
of the GUIs.


---

diff --git a/src/action.c b/src/action.c
index 5dc544e..eddbbbd 100644
--- a/src/action.c
+++ b/src/action.c
@@ -607,7 +607,7 @@ click_cb (hidval hv)
 {
   if (Note.Click)
     {
-      HideCrosshair ();
+      notify_crosshair_change (false);
       Note.Click = false;
       if (Note.Moving && !gui->shift_is_pressed ())
 	{
@@ -650,7 +650,7 @@ click_cb (hidval hv)
 	  Crosshair.AttachedBox.Point1.X = Note.X;
 	  Crosshair.AttachedBox.Point1.Y = Note.Y;
 	}
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
     }
 }
 
@@ -945,7 +945,7 @@ NotifyLine (void)
 static void
 NotifyBlock (void)
 {
-  HideCrosshair ();
+  notify_crosshair_change (false);
   switch (Crosshair.AttachedBox.State)
     {
     case STATE_FIRST:		/* setup first point */
@@ -960,7 +960,7 @@ NotifyBlock (void)
       Crosshair.AttachedBox.State = STATE_THIRD;
       break;
     }
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
 }
 
 
@@ -2122,11 +2122,11 @@ ActionMovePointer (char *deltax, char *deltay)
   /* restore crosshair for erasure */
   Crosshair.X = x;
   Crosshair.Y = y;
-  HideCrosshair ();
+  notify_crosshair_change (false);
   MoveCrosshairRelative (TO_SCREEN_SIGN_X (dx), TO_SCREEN_SIGN_Y (dy));
   /* update object position and cursor location */
   AdjustAttachedObjects ();
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
 }
 
 /* ---------------------------------------------------------------------------
@@ -2152,10 +2152,9 @@ EventMoveCrosshair (int ev_x, int ev_y)
     {
       if (MoveCrosshairAbsolute (ev_x, ev_y))
 	{
-
 	  /* update object position and cursor location */
 	  AdjustAttachedObjects ();
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	}
     }
   else
@@ -2720,7 +2719,7 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 	  break;
 
 	case F_CycleClip:
-	  HideCrosshair ();
+	  notify_crosshair_change (false);
 	  if TEST_FLAG
 	    (ALLDIRECTIONFLAG, PCB)
 	    {
@@ -2730,27 +2729,27 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 	  else
 	    PCB->Clipping = (PCB->Clipping + 1) % 3;
 	  AdjustAttachedObjects ();
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  break;
 
 	case F_CycleCrosshair:
-	  HideCrosshair ();
+	  notify_crosshair_change (false);
 	  Crosshair.shape = CrosshairShapeIncrement(Crosshair.shape);
 	  if (Crosshair_Shapes_Number == Crosshair.shape)
 	    Crosshair.shape = Basic_Crosshair_Shape;
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  break;
 
 	case F_ToggleRubberBandMode:
-	  HideCrosshair ();
+	  notify_crosshair_change (false);
 	  TOGGLE_FLAG (RUBBERBANDFLAG, PCB);
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  break;
 
 	case F_ToggleStartDirection:
-	  HideCrosshair ();
+	  notify_crosshair_change (false);
 	  TOGGLE_FLAG (SWAPSTARTDIRFLAG, PCB);
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  break;
 
 	case F_ToggleUniqueNames:
@@ -2758,9 +2757,9 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 	  break;
 
 	case F_ToggleSnapPin:
-	  HideCrosshair ();
+	  notify_crosshair_change (false);
 	  TOGGLE_FLAG (SNAPPINFLAG, PCB);
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  break;
 
 	case F_ToggleLocalRef:
@@ -2801,7 +2800,7 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 	  break;
 
 	case F_ToggleAutoDRC:
-	  HideCrosshair ();
+	  notify_crosshair_change (false);
 	  TOGGLE_FLAG (AUTODRCFLAG, PCB);
 	  if (TEST_FLAG (AUTODRCFLAG, PCB) && Settings.Mode == LINE_MODE)
 	    {
@@ -2815,7 +2814,7 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 				  Crosshair.AttachedLine.Point1.Y, true, 1,
 				  FOUNDFLAG);
 	    }
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  break;
 
 	case F_ToggleCheckPlanes:
@@ -2853,7 +2852,7 @@ ActionDisplay (int argc, char **argv, int childX, int childY)
 	    oldGrid = PCB->Grid;
 	    PCB->Grid = 1.0;
 	    if (MoveCrosshairAbsolute (Crosshair.X, Crosshair.Y))
-	      RestoreCrosshair ();	/* was hidden by MoveCrosshairAbs */
+	      notify_crosshair_change (true);	/* first notify was in MoveCrosshairAbs */
 	    SetGrid (oldGrid, true);
 	  }
 	  break;
@@ -3057,7 +3056,7 @@ ActionMode (int argc, char **argv, int x, int y)
     {
       Note.X = Crosshair.X;
       Note.Y = Crosshair.Y;
-      HideCrosshair ();
+      notify_crosshair_change (false);
       switch (GetFunctionID (function))
 	{
 	case F_Arc:
@@ -3253,7 +3252,7 @@ ActionMode (int argc, char **argv, int x, int y)
 	  SaveMode ();
 	  break;
 	}
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
       return 0;
     }
 
@@ -5439,7 +5438,7 @@ ActionSelect (int argc, char **argv, int x, int y)
 			  Crosshair.AttachedBox.Point2.X);
 	    box.Y2 = MAX (Crosshair.AttachedBox.Point1.Y,
 			  Crosshair.AttachedBox.Point2.Y);
-	    HideCrosshair ();
+	    notify_crosshair_change (false);
 	    NotifyBlock ();
 	    if (Crosshair.AttachedBox.State == STATE_THIRD &&
 		SelectBlock (&box, true))
@@ -5447,7 +5446,7 @@ ActionSelect (int argc, char **argv, int x, int y)
 		SetChangedFlag (true);
 		Crosshair.AttachedBox.State = STATE_FIRST;
 	      }
-	    RestoreCrosshair ();
+	    notify_crosshair_change (true);
 	    break;
 	  }
 
@@ -5618,7 +5617,7 @@ ActionUnselect (int argc, char **argv, int x, int y)
 			  Crosshair.AttachedBox.Point2.X);
 	    box.Y2 = MAX (Crosshair.AttachedBox.Point1.Y,
 			  Crosshair.AttachedBox.Point2.Y);
-	    HideCrosshair ();
+	    notify_crosshair_change (false);
 	    NotifyBlock ();
 	    if (Crosshair.AttachedBox.State == STATE_THIRD &&
 		SelectBlock (&box, false))
@@ -5626,7 +5625,7 @@ ActionUnselect (int argc, char **argv, int x, int y)
 		SetChangedFlag (true);
 		Crosshair.AttachedBox.State = STATE_FIRST;
 	      }
-	    RestoreCrosshair ();
+	    notify_crosshair_change (true);
 	    break;
 	  }
 
@@ -5857,18 +5856,18 @@ ActionLoadFrom (int argc, char **argv, int x, int y)
 
   if (strcasecmp (function, "ElementToBuffer") == 0)
     {
-      HideCrosshair ();
+      notify_crosshair_change (false);
       if (LoadElementToBuffer (PASTEBUFFER, name, true))
 	SetMode (PASTEBUFFER_MODE);
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
     }
 
   else if (strcasecmp (function, "LayoutToBuffer") == 0)
     {
-      HideCrosshair ();
+      notify_crosshair_change (false);
       if (LoadLayoutToBuffer (PASTEBUFFER, name))
 	SetMode (PASTEBUFFER_MODE);
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
     }
 
   else if (strcasecmp (function, "Layout") == 0)
@@ -5925,7 +5924,7 @@ ActionNew (int argc, char **argv, int x, int y)
       if (!name)
         return 1;
 
-      HideCrosshair ();
+      notify_crosshair_change (false);
       /* do emergency saving
        * clear the old struct and allocate memory for the new one
        */
@@ -5947,7 +5946,7 @@ ActionNew (int argc, char **argv, int x, int y)
       Redraw ();
 
       hid_action ("PCBChanged");
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
       return 0;
     }
   return 1;
@@ -6034,7 +6033,7 @@ ActionPasteBuffer (int argc, char **argv, int x, int y)
   static char *default_file = NULL;
   int free_name = 0;
 
-  HideCrosshair ();
+  notify_crosshair_change (true);
   if (function)
     {
       switch (GetFunctionID (function))
@@ -6141,7 +6140,7 @@ ActionPasteBuffer (int argc, char **argv, int x, int y)
 	      }
 	    else
 	      {
-		RestoreCrosshair ();
+		notify_crosshair_change (false);
 		AFAIL (pastebuffer);
 	      }
 
@@ -6164,7 +6163,7 @@ ActionPasteBuffer (int argc, char **argv, int x, int y)
 	}
     }
 
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   return 0;
 }
 
@@ -6205,13 +6204,13 @@ ActionUndo (int argc, char **argv, int x, int y)
 	return 1;
       /* undo the last operation */
 
-      HideCrosshair ();
+      notify_crosshair_change (false);
       if ((Settings.Mode == POLYGON_MODE ||
            Settings.Mode == POLYGONHOLE_MODE) &&
           Crosshair.AttachedPolygon.PointN)
 	{
 	  GoToPreviousPoint ();
-	  RestoreCrosshair ();
+	  notify_crosshair_change (true);
 	  return 0;
 	}
       /* move anchor point if undoing during line creation */
@@ -6223,7 +6222,7 @@ ActionUndo (int argc, char **argv, int x, int y)
 		Undo (true);	/* undo the connection find */
 	      Crosshair.AttachedLine.State = STATE_FIRST;
 	      SetLocalRef (0, 0, false);
-	      RestoreCrosshair ();
+	      notify_crosshair_change (true);
 	      return 0;
 	    }
 	  if (Crosshair.AttachedLine.State == STATE_THIRD)
@@ -6251,7 +6250,7 @@ ActionUndo (int argc, char **argv, int x, int y)
 		    Crosshair.AttachedLine.Point1.X;
 		  Crosshair.AttachedLine.Point2.Y =
 		    Crosshair.AttachedLine.Point1.Y;
-		  RestoreCrosshair ();
+		  notify_crosshair_change (true);
 		  return 0;
 		}
 	      /* move to new anchor */
@@ -6298,7 +6297,7 @@ ActionUndo (int argc, char **argv, int x, int y)
 		  ptr2 = (LineTypePtr) ptrtmp;
 		  lastLayer = (LayerTypePtr) ptr1;
 		}
-	      RestoreCrosshair ();
+	      notify_crosshair_change (true);
 	      return 0;
 	    }
 	}
@@ -6307,7 +6306,7 @@ ActionUndo (int argc, char **argv, int x, int y)
 	  if (Crosshair.AttachedBox.State == STATE_SECOND)
 	    {
 	      Crosshair.AttachedBox.State = STATE_FIRST;
-	      RestoreCrosshair ();
+	      notify_crosshair_change (true);
 	      return 0;
 	    }
 	  if (Crosshair.AttachedBox.State == STATE_THIRD)
@@ -6342,7 +6341,7 @@ ActionUndo (int argc, char **argv, int x, int y)
 	  break;
 	}
     }
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   return 0;
 }
 
@@ -6375,7 +6374,7 @@ ActionRedo (int argc, char **argv, int x, int y)
        Crosshair.AttachedPolygon.PointN) ||
       Crosshair.AttachedLine.State == STATE_SECOND)
     return 1;
-  HideCrosshair ();
+  notify_crosshair_change (false);
   if (Redo (true))
     {
       SetChangedFlag (true);
@@ -6390,7 +6389,7 @@ ActionRedo (int argc, char **argv, int x, int y)
 	  addedLines++;
 	}
     }
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   return 0;
 }
 
@@ -6424,7 +6423,7 @@ ActionPolygon (int argc, char **argv, int x, int y)
   char *function = ARG (0);
   if (function && Settings.Mode == POLYGON_MODE)
     {
-      HideCrosshair ();
+      notify_crosshair_change (false);
       switch (GetFunctionID (function))
 	{
 	  /* close open polygon if possible */
@@ -6437,7 +6436,7 @@ ActionPolygon (int argc, char **argv, int x, int y)
 	  GoToPreviousPoint ();
 	  break;
 	}
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
     }
   return 0;
 }
@@ -6601,24 +6600,24 @@ ActionSetSame (int argc, char **argv, int x, int y)
   switch (type)
     {
     case LINE_TYPE:
-      HideCrosshair ();
+      notify_crosshair_change (false);
       Settings.LineThickness = ((LineTypePtr) ptr2)->Thickness;
       Settings.Keepaway = ((LineTypePtr) ptr2)->Clearance / 2;
       layer = (LayerTypePtr) ptr1;
       if (Settings.Mode != LINE_MODE)
 	SetMode (LINE_MODE);
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
       hid_action ("RouteStylesChanged");
       break;
 
     case ARC_TYPE:
-      HideCrosshair ();
+      notify_crosshair_change (false);
       Settings.LineThickness = ((ArcTypePtr) ptr2)->Thickness;
       Settings.Keepaway = ((ArcTypePtr) ptr2)->Clearance / 2;
       layer = (LayerTypePtr) ptr1;
       if (Settings.Mode != ARC_MODE)
 	SetMode (ARC_MODE);
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
       hid_action ("RouteStylesChanged");
       break;
 
@@ -6627,13 +6626,13 @@ ActionSetSame (int argc, char **argv, int x, int y)
       break;
 
     case VIA_TYPE:
-      HideCrosshair ();
+      notify_crosshair_change (false);
       Settings.ViaThickness = ((PinTypePtr) ptr2)->Thickness;
       Settings.ViaDrillingHole = ((PinTypePtr) ptr2)->DrillingHole;
       Settings.Keepaway = ((PinTypePtr) ptr2)->Clearance / 2;
       if (Settings.Mode != VIA_MODE)
 	SetMode (VIA_MODE);
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
       hid_action ("RouteStylesChanged");
       break;
 
diff --git a/src/buffer.c b/src/buffer.c
index 43d5c2b..4f746e9 100644
--- a/src/buffer.c
+++ b/src/buffer.c
@@ -526,7 +526,7 @@ AddSelectedToBuffer (BufferTypePtr Buffer, LocationType X, LocationType Y,
    */
   if (!LeaveSelected)
     ExtraFlag = SELECTEDFLAG;
-  HideCrosshair ();
+  notify_crosshair_change (false);
   Source = PCB->Data;
   Dest = Buffer->Data;
   SelectedOperation (&AddBufferFunctions, false, ALL_TYPES);
@@ -542,7 +542,7 @@ AddSelectedToBuffer (BufferTypePtr Buffer, LocationType X, LocationType Y,
       Buffer->X = Crosshair.X;
       Buffer->Y = Crosshair.Y;
     }
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   ExtraFlag = 0;
 }
 
@@ -1457,9 +1457,9 @@ ActionFreeRotateBuffer(int argc, char **argv, int x, int y)
   else
     angle_s = argv[0];
 
-  HideCrosshair ();
+  notify_crosshair_change (false);
   FreeRotateBuffer(PASTEBUFFER, strtod(angle_s, 0));
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   return 0;
 }
 
diff --git a/src/crosshair.c b/src/crosshair.c
index 054610b..b304093 100644
--- a/src/crosshair.c
+++ b/src/crosshair.c
@@ -706,6 +706,51 @@ DrawMark (void)
 
 
 /* ---------------------------------------------------------------------------
+ * notify the GUI that data relating to the crosshair is being changed.
+ *
+ * The argument passed is false to notify "changes are about to happen",
+ * and true to notify "changes have finished".
+ *
+ * Each call with a 'false' parameter must be matched with a following one
+ * with a 'true' parameter. Unmatched 'true' calls are currently not permitted,
+ * but might be allowed in the future.
+ *
+ * GUIs should not complain if they receive extra calls with 'true' as parameter.
+ * They should initiate a redraw of the crosshair attached objects - which may
+ * (if necessary) mean repainting the whole screen if the GUI hasn't tracked the
+ * location of existing attached drawing.
+ */
+void
+notify_crosshair_change (bool changes_complete)
+{
+  if (gui->notify_crosshair_change)
+    gui->notify_crosshair_change (changes_complete);
+}
+
+
+/* ---------------------------------------------------------------------------
+ * notify the GUI that data relating to the mark is being changed.
+ *
+ * The argument passed is false to notify "changes are about to happen",
+ * and true to notify "changes have finished".
+ *
+ * Each call with a 'false' parameter must be matched with a following one
+ * with a 'true' parameter. Unmatched 'true' calls are currently not permitted,
+ * but might be allowed in the future.
+ *
+ * GUIs should not complain if they receive extra calls with 'true' as parameter.
+ * They should initiate a redraw of the mark - which may (if necessary) mean
+ * repainting the whole screen if the GUI hasn't tracked the mark's location.
+ */
+void
+notify_mark_change (bool changes_complete)
+{
+  if (gui->notify_mark_change)
+    gui->notify_mark_change (changes_complete);
+}
+
+
+/* ---------------------------------------------------------------------------
  * switches crosshair on
  */
 void
@@ -717,6 +762,12 @@ CrosshairOn (void)
       DrawAttached ();
       DrawMark ();
     }
+xxxxxxx
+xxxxxxxxxxxxxxxxxxxxxx
+
+xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+xxxxxxxxxxxxxxxxxxxx
+xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
 }
 
 /* ---------------------------------------------------------------------------
@@ -731,48 +782,57 @@ CrosshairOff (void)
       DrawMark ();
       Crosshair.On = false;
     }
+
+xxxxxxxxxxxxxxxxxxxxxxx
+
+xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+xxxxxxxxxxxxxxxxxxxx
+xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
 }
 
 /* ---------------------------------------------------------------------------
- * saves crosshair state (on/off) and hides him
+ * Convenience for plugins using the old {Hide,Restore}Crosshair API.
+ * This links up to notify the GUI of the expected changes using the new APIs.
+ *
+ * Use of this old API is deprecated, as the names don't necessarily reflect
+ * what all GUIs may do in response to the notifications. Keeping these APIs
+ * is aimed at easing transition to the newer API, they will emit a harmless
+ * warning at the time of their first use.
+ *
  */
 void
-HideCrosshair ()
+HideCrosshair (void)
 {
-  /* fprintf(stderr, "HideCrosshair stack %d\n", CrosshairStackLocation); */
-  if (CrosshairStackLocation >= MAX_CROSSHAIRSTACK_DEPTH)
+  static bool warned_old_api = false;
+  if (!warned_old_api)
     {
-      fprintf(stderr, "Error: CrosshairStackLocation overflow\n");
-      return;
+      Message (_("WARNING: A plugin is using the deprecated API HideCrosshair().\n"
+                 "         This API may be removed in a future release of PCB.\n"));
+      warned_old_api = true;
     }
 
-  CrosshairStack[CrosshairStackLocation] = Crosshair.On;
-  CrosshairStackLocation++;
-
-  CrosshairOff ();
+  notify_crosshair_change (false);
+  notify_mark_change (false);
 }
 
-/* ---------------------------------------------------------------------------
- * restores last crosshair state
- */
 void
 RestoreCrosshair (void)
 {
-  /* fprintf(stderr, "RestoreCrosshair stack %d\n", CrosshairStackLocation); */
-  if (CrosshairStackLocation <= 0)
+  static bool warned_old_api = false;
+  if (!warned_old_api)
     {
-      fprintf(stderr, "Error: CrosshairStackLocation underflow\n");
-      return;
+      Message (_("WARNING: A plugin is using the deprecated API RestoreCrosshair().\n"
+                 "         This API may be removed in a future release of PCB.\n"));
+      warned_old_api = true;
     }
 
-  CrosshairStackLocation--;
-
-  if (CrosshairStack[CrosshairStackLocation])
-    CrosshairOn ();
-  else
-    CrosshairOff ();
+  notify_crosshair_change (true);
+  notify_mark_change (true);
 }
 
+/* ---------------------------------------------------------------------------
+ * Returns the square of the given number
+ */
 static double
 square (double x)
 {
@@ -1064,8 +1124,8 @@ MoveCrosshairRelative (LocationType DeltaX, LocationType DeltaY)
 }
 
 /* ---------------------------------------------------------------------------
- * move crosshair absolute switched off if it moved
- * return true if it switched off
+ * move crosshair absolute
+ * return true if the crosshair was moved from its existing position
  */
 bool
 MoveCrosshairAbsolute (LocationType X, LocationType Y)
@@ -1076,13 +1136,14 @@ MoveCrosshairAbsolute (LocationType X, LocationType Y)
   FitCrosshairIntoGrid (X, Y);
   if (Crosshair.X != x || Crosshair.Y != y)
     {
-      /* back up to old position and erase crosshair */
+      /* back up to old position to notify the GUI
+       * (which might want to erase the old crosshair) */
       z = Crosshair.X;
       Crosshair.X = x;
       x = z;
       z = Crosshair.Y;
       Crosshair.Y = y;
-      HideCrosshair ();
+      notify_crosshair_change (false); /* Our caller notifies when it has done */
       /* now move forward again */
       Crosshair.X = x;
       Crosshair.Y = z;
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 5af6ed6..5037ff0 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -1838,11 +1838,11 @@ ScrollAction (int argc, char **argv, int x, int y)
   else
     AFAIL (scroll);
 
-  HideCrosshair ();
+  notify_crosshair_change (false);
   ghid_port_ranges_pan (dx, dy, TRUE);
   MoveCrosshairRelative (dx, dy);
   AdjustAttachedObjects ();
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
 
   return 0;
 }
diff --git a/src/hid/gtk/gui-misc.c b/src/hid/gtk/gui-misc.c
index 8bda96d..75ba763 100644
--- a/src/hid/gtk/gui-misc.c
+++ b/src/hid/gtk/gui-misc.c
@@ -403,12 +403,12 @@ run_get_location_loop (const gchar * message)
   oldObjState = Crosshair.AttachedObject.State;
   oldLineState = Crosshair.AttachedLine.State;
   oldBoxState = Crosshair.AttachedBox.State;
-  HideCrosshair ();
+  notify_crosshair_change (false);
   Crosshair.AttachedObject.State = STATE_FIRST;
   Crosshair.AttachedLine.State = STATE_FIRST;
   Crosshair.AttachedBox.State = STATE_FIRST;
   ghid_hand_cursor ();
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
 
   /* Stop the top level GMainLoop from getting user input from keyboard
      |  and mouse so we can install our own handlers here.  Also set the
@@ -439,11 +439,11 @@ run_get_location_loop (const gchar * message)
   ghid_interface_input_signals_connect ();	/* return to normal */
   ghid_interface_set_sensitive (TRUE);
 
-  HideCrosshair ();
+  notify_crosshair_change (false);
   Crosshair.AttachedObject.State = oldObjState;
   Crosshair.AttachedLine.State = oldLineState;
   Crosshair.AttachedBox.State = oldBoxState;
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   ghid_restore_cursor ();
 
   ghid_set_status_line_label ();
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index b62ecf0..a0e8eb3 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -232,7 +232,7 @@ ghid_note_event_location (GdkEventButton * ev)
   if (moved)
     {
       AdjustAttachedObjects ();
-      RestoreCrosshair ();
+      notify_crosshair_change (true);
     }
   ghid_set_cursor_position_labels ();
   return moved;
diff --git a/src/hid/lesstif/main.c b/src/hid/lesstif/main.c
index c1b12d3..75c295e 100644
--- a/src/hid/lesstif/main.c
+++ b/src/hid/lesstif/main.c
@@ -1310,12 +1310,12 @@ mod_changed (XKeyEvent * e, int set)
       return;
     }
   in_move_event = 1;
-  HideCrosshair ();
+  notify_crosshair_change (false);
   if (panning)
     Pan (2, e->x, e->y);
   EventMoveCrosshair (Px (e->x), Py (e->y));
   AdjustAttachedObjects ();
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
   in_move_event = 0;
 }
 
@@ -1351,7 +1351,7 @@ work_area_input (Widget w, XtPointer v, XEvent * e, Boolean * ctd)
 	}
         ignore_release = 0;
 
-        HideCrosshair ();
+        notify_crosshair_change (false);
         pressed_button = e->xbutton.button;
         mods = ((e->xbutton.state & ShiftMask) ? M_Shift : 0)
           + ((e->xbutton.state & ControlMask) ? M_Ctrl : 0)
@@ -1361,7 +1361,7 @@ work_area_input (Widget w, XtPointer v, XEvent * e, Boolean * ctd)
           + ((e->xbutton.state & Mod1Mask) ? M_Alt : 0);
 #endif
         do_mouse_action(e->xbutton.button, mods);
-        RestoreCrosshair ();
+        notify_crosshair_change (true);
         break;
       }
 
@@ -1371,7 +1371,7 @@ work_area_input (Widget w, XtPointer v, XEvent * e, Boolean * ctd)
         if (e->xbutton.button != pressed_button)
           return;
         lesstif_button_event (w, e);
-        HideCrosshair ();
+        notify_crosshair_change (false);
         pressed_button = 0;
         mods = ((e->xbutton.state & ShiftMask) ? M_Shift : 0)
           + ((e->xbutton.state & ControlMask) ? M_Ctrl : 0)
@@ -1382,7 +1382,7 @@ work_area_input (Widget w, XtPointer v, XEvent * e, Boolean * ctd)
 #endif
           + M_Release;
         do_mouse_action (e->xbutton.button, mods);
-        RestoreCrosshair ();
+        notify_crosshair_change (true);
         break;
       }
 
diff --git a/src/misc.c b/src/misc.c
index d63aef1..5bea138 100644
--- a/src/misc.c
+++ b/src/misc.c
@@ -705,15 +705,11 @@ CenterDisplay (LocationType X, LocationType Y, bool Delta)
   double save_grid = PCB->Grid;
   PCB->Grid = 1;
   if (Delta)
-    {
-      MoveCrosshairRelative (X, Y);
-    }
+    MoveCrosshairRelative (X, Y);
   else
     {
       if (MoveCrosshairAbsolute (X, Y))
-        {
-          RestoreCrosshair ();
-        }
+        notify_crosshair_change (true);
     }
   gui->set_crosshair (Crosshair.X, Crosshair.Y, HID_SC_WARP_POINTER);
   PCB->Grid = save_grid;
diff --git a/src/set.c b/src/set.c
index 90db719..c77129e 100644
--- a/src/set.c
+++ b/src/set.c
@@ -244,7 +244,7 @@ SetMode (int Mode)
   if (recursing)
     return;
   recursing = true;
-  HideCrosshair ();
+  notify_crosshair_change (false);
   addedLines = 0;
   Crosshair.AttachedObject.Type = NO_TYPE;
   Crosshair.AttachedObject.State = STATE_FIRST;
@@ -314,7 +314,7 @@ SetMode (int Mode)
    * may have changed
    */
   MoveCrosshairRelative (0, 0);
-  RestoreCrosshair ();
+  notify_crosshair_change (true);
 }
 
 void
@@ -342,20 +342,20 @@ SetLocalRef (LocationType X, LocationType Y, bool Showing)
 
   if (Showing)
     {
-      HideCrosshair ();
+      notify_mark_change (false);
       if (count == 0)
 	old = Marked;
       Marked.X = X;
       Marked.Y = Y;
       Marked.status = true;
       count++;
-      RestoreCrosshair ();
+      notify_mark_change (true);
     }
   else if (count > 0)
     {
-      HideCrosshair ();
+      notify_mark_change (false);
       count = 0;
       Marked = old;
-      RestoreCrosshair ();
+      notify_mark_change (true);
     }
 }

Bottom: e6a7a8ce46a2bf56ca46f1eb755e60e99ee9b51c
Top:    e6a7a8ce46a2bf56ca46f1eb755e60e99ee9b51c
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-09-29 17:37:07 +0100

Play with GLSL shader for rendering line caps and circles

And of course.. typically, a million other little fixes:

 - Primitive rendering object changed from GL_TRIANGLES to GL_TRIANGLE_STRIP
 - Cache of tristrip data per contour (HACK: in the core)
 - Rendering using mapped VBOs rather than just arrays
 - Updated layer depth code, so we render with "z" in world coordinates
 - Space navigator joystick support fixes against later kernels

Bugs:
 - Layer depths will be wrong for reversed layer group numbering
 - Pixel shader ought to be switched off for polygon fill?
 - hidgl_draw_rect stubbed out (for benchmarking)
 - Draw Element mark stubbed out (for benchmarking)
 - Draw crosshair stubbed out (for benchmarking)
 - Draw crosshair not updated to render in world coordinates

Notes:
 - Apparently it can be better to do glVertexPointer last (so we do):
    From: http://sdickinson.com/wordpress/?p=122
    ""
    Make sure you put glVertexPointer at the end as there is a lot of work that
    goes on behind the scenes with it, and if it's set at the start, it has to
    do all that work for each gl*Pointer call, rather than once at the end.
    ""

 - We set up the array pointers before calling glEnableClientState():
    I'm not sure, but if we do this the other way around, it might cause
    the driver to hang onto our old buffers longer, or perform state setup,
    only to have to discard that work shortly after.

 - DARN: Seems that using VBOs is not a win, even on Intel 965:
    Certainly seems to fail miserably (v. low FPS) on my NVidia card.

    On Intel, sysprof shows a huge amount of time spent clflushing
    buffers, or copying to the graphics card (uncached).

    Set to use glBufferSubData by default for now.


---



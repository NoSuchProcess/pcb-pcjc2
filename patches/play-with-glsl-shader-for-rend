Bottom: 1bd01662a27e7b2c8a942fb11a48b501532e989f
Top:    96d771394d5a5cee532a8d1fdda011206e8be409
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-12-10 03:42:12 +0000

Play with GLSL shader for rendering line caps and circles

And of course.. typically, a million other little fixes:

 - Primitive rendering object changed from GL_TRIANGLES to GL_TRIANGLE_STRIP
 - Cache of tristrip data per contour (HACK: in the core)
 - Rendering using mapped VBOs rather than just arrays
 - Updated layer depth code, so we render with "z" in world coordinates
 - Space navigator joystick support fixes against later kernels

Bugs:
 - Layer depths will be wrong for reversed layer group numbering
 - Pixel shader ought to be switched off for polygon fill?
 - hidgl_draw_rect stubbed out (for benchmarking)
 - Draw Element mark stubbed out (for benchmarking)
 - Draw crosshair stubbed out (for benchmarking)
 - Draw crosshair not updated to render in world coordinates

Notes:
 - Apparently it can be better to do glVertexPointer last (so we do):
    From: http://sdickinson.com/wordpress/?p=122
    ""
    Make sure you put glVertexPointer at the end as there is a lot of work that
    goes on behind the scenes with it, and if it's set at the start, it has to
    do all that work for each gl*Pointer call, rather than once at the end.
    ""

 - We set up the array pointers before calling glEnableClientState():
    I'm not sure, but if we do this the other way around, it might cause
    the driver to hang onto our old buffers longer, or perform state setup,
    only to have to discard that work shortly after.

 - DARN: Seems that using VBOs is not a win, even on Intel 965:
    Certainly seems to fail miserably (v. low FPS) on my NVidia card.

    On Intel, sysprof shows a huge amount of time spent clflushing
    buffers, or copying to the graphics card (uncached).

    Set to use glBufferSubData by default for now.


---

diff --git a/src/Makefile.am b/src/Makefile.am
index b7857bd..2efb5e6 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -187,6 +187,8 @@ LIBGTK_GL_SRCS= \
 GL_SRCS= \
 	hid/common/hidgl.c \
 	hid/common/hidgl.h \
+	hid/common/hidgl_shaders.c \
+	hid/common/hidgl_shaders.h \
 	hid/common/trackball.c \
 	hid/common/trackball.h
 
diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index bdcf491..6a4791a 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -47,6 +47,7 @@ RCSID ("$Id: $");
 
 triangle_buffer buffer;
 float global_depth = 0;
+hidgl_shader *circular_program = NULL;
 
 static bool in_context = false;
 
@@ -75,43 +76,150 @@ hidgl_new_triangle_array (void)
 }
 #endif
 
+#define BUFFER_STRIDE (5 * sizeof (GLfloat))
+#define BUFFER_SIZE (BUFFER_STRIDE * 3 * TRIANGLE_ARRAY_SIZE)
+
+/* NB: If using VBOs, the caller must ensure the VBO is bound to the GL_ARRAY_BUFFER */
+static void
+hidgl_reset_triangle_array (triangle_buffer *buffer)
+{
+  if (buffer->use_map) {
+    /* Hint to the driver that we're done with the previous buffer contents */
+    glBufferData (GL_ARRAY_BUFFER, BUFFER_SIZE, NULL, GL_STREAM_DRAW);
+    /* Map the new memory to upload vertices into. */
+    buffer->triangle_array = glMapBuffer (GL_ARRAY_BUFFER, GL_WRITE_ONLY);
+  }
+
+  /* If mapping the VBO fails (or if we aren't using VBOs) fall back to
+   * local storage.
+   */
+  if (buffer->triangle_array == NULL) {
+    buffer->triangle_array = malloc (BUFFER_SIZE);
+    buffer->use_map = false;
+  }
+
+  /* Don't want this bound for now */
+  glBindBuffer (GL_ARRAY_BUFFER, 0);
+
+  buffer->triangle_count = 0;
+  buffer->coord_comp_count = 0;
+  buffer->vertex_count = 0;
+}
+
 void
 hidgl_init_triangle_array (triangle_buffer *buffer)
 {
   CHECK_IS_IN_CONTEXT ();
-  glEnableClientState (GL_VERTEX_ARRAY);
-  glVertexPointer (3, GL_FLOAT, 0, buffer->triangle_array);
-  buffer->triangle_count = 0;
-  buffer->coord_comp_count = 0;
+
+  buffer->use_vbo = true;
+  // buffer->use_vbo = false;
+
+  if (buffer->use_vbo) {
+    glGenBuffers (1, &buffer->vbo_id);
+    glBindBuffer (GL_ARRAY_BUFFER, buffer->vbo_id);
+  }
+
+  if (buffer->vbo_id == 0)
+    buffer->use_vbo = false;
+
+  buffer->use_map = buffer->use_vbo;
+
+  /* NB: Mapping the whole buffer can be expensive since we ask the driver
+   *     to discard previous data and give us a "new" buffer to write into
+   *     each time. If it is still rendering from previous buffer, we end
+   *     up causing a lot of unnecessary allocation in the driver this way.
+   *
+   *     On intel drivers at least, glBufferSubData does not block. It uploads
+   *     into a temporary buffer and queues a GPU copy of the uploaded data
+   *     for when the "main" buffer has finished rendering.
+   */
+  buffer->use_map = false;
+
+  /* If using VBOs (but not mapping), we only need to this once */
+  if (buffer->use_vbo && !buffer->use_map)
+    glBufferData (GL_ARRAY_BUFFER, BUFFER_SIZE, NULL, GL_STREAM_DRAW);
+
+  buffer->triangle_array = NULL;
+  hidgl_reset_triangle_array (buffer);
+}
+
+void
+hidgl_finish_triangle_array (triangle_buffer *buffer)
+{
+  if (buffer->use_map) {
+    glBindBuffer (GL_ARRAY_BUFFER, buffer->vbo_id);
+    glUnmapBuffer (GL_ARRAY_BUFFER);
+    glBindBuffer (GL_ARRAY_BUFFER, 0);
+  } else {
+    free (buffer->triangle_array);
+  }
+
+  if (buffer->use_vbo) {
+    glDeleteBuffers (1, &buffer->vbo_id);
+    buffer->vbo_id = 0;
+  }
 }
 
 void
 hidgl_flush_triangles (triangle_buffer *buffer)
 {
+  GLfloat *data_pointer = NULL;
+
   CHECK_IS_IN_CONTEXT ();
-  if (buffer->triangle_count == 0)
+  if (buffer->vertex_count == 0)
     return;
 
-  glDrawArrays (GL_TRIANGLES, 0, buffer->triangle_count * 3);
-  buffer->triangle_count = 0;
-  buffer->coord_comp_count = 0;
+  if (buffer->use_vbo) {
+    glBindBuffer (GL_ARRAY_BUFFER, buffer->vbo_id);
+
+    if (buffer->use_map) {
+      glUnmapBuffer (GL_ARRAY_BUFFER);
+      buffer->triangle_array = NULL;
+    } else {
+      /* NB: We only upload the portion of the buffer we've used */
+      glBufferSubData (GL_ARRAY_BUFFER, 0,
+                       BUFFER_STRIDE * buffer->vertex_count,
+                       buffer->triangle_array);
+    }
+  } else {
+    data_pointer = buffer->triangle_array;
+  }
+
+  glTexCoordPointer (2, GL_FLOAT, BUFFER_STRIDE, data_pointer + 3);
+  glVertexPointer   (3, GL_FLOAT, BUFFER_STRIDE, data_pointer + 0);
+
+  glEnableClientState (GL_TEXTURE_COORD_ARRAY);
+  glEnableClientState (GL_VERTEX_ARRAY);
+  glDrawArrays (GL_TRIANGLE_STRIP, 0, buffer->vertex_count);
+  glDisableClientState (GL_VERTEX_ARRAY);
+  glDisableClientState (GL_TEXTURE_COORD_ARRAY);
+
+  hidgl_reset_triangle_array (buffer);
 }
 
 void
-hidgl_ensure_triangle_space (triangle_buffer *buffer, int count)
+hidgl_ensure_vertex_space (triangle_buffer *buffer, int count)
 {
   CHECK_IS_IN_CONTEXT ();
-  if (count > TRIANGLE_ARRAY_SIZE)
+  if (count > 3 * TRIANGLE_ARRAY_SIZE)
     {
       fprintf (stderr, "Not enough space in vertex buffer\n");
-      fprintf (stderr, "Requested %i triangles, %i available\n",
-                       count, TRIANGLE_ARRAY_SIZE);
+      fprintf (stderr, "Requested %i vertices, %i available\n",
+                       count, 3 * TRIANGLE_ARRAY_SIZE);
       exit (1);
     }
-  if (count > TRIANGLE_ARRAY_SIZE - buffer->triangle_count)
+  if (count > 3 * TRIANGLE_ARRAY_SIZE - buffer->vertex_count)
     hidgl_flush_triangles (buffer);
 }
 
+void
+hidgl_ensure_triangle_space (triangle_buffer *buffer, int count)
+{
+  CHECK_IS_IN_CONTEXT ();
+  /* NB: 5 = 3 + 2 extra vertices to separate from other triangle strips */
+  hidgl_ensure_vertex_space (buffer, count * 5);
+}
+
 //static int cur_mask = -1;
 
 
@@ -214,42 +322,34 @@ int calc_slices (float pix_radius, float sweep_angle)
   return (int)ceilf (slices);
 }
 
-#define MIN_TRIANGLES_PER_CAP 3
-#define MAX_TRIANGLES_PER_CAP 90
-static void draw_cap (double width, int x, int y, double angle, double scale)
+static void draw_cap (double width, int x, int y, double angle)
 {
-  float last_capx, last_capy;
-  float capx, capy;
   float radius = width / 2.;
-  int slices = calc_slices (radius / scale, M_PI);
-  int i;
 
   CHECK_IS_IN_CONTEXT ();
-  if (slices < MIN_TRIANGLES_PER_CAP)
-    slices = MIN_TRIANGLES_PER_CAP;
-
-  if (slices > MAX_TRIANGLES_PER_CAP)
-    slices = MAX_TRIANGLES_PER_CAP;
-
-  hidgl_ensure_triangle_space (&buffer, slices);
-
-  last_capx =  radius * cosf (angle * M_PI / 180.) + x;
-  last_capy = -radius * sinf (angle * M_PI / 180.) + y;
-  for (i = 0; i < slices; i++) {
-    capx =  radius * cosf (angle * M_PI / 180. + ((float)(i + 1)) * M_PI / (float)slices) + x;
-    capy = -radius * sinf (angle * M_PI / 180. + ((float)(i + 1)) * M_PI / (float)slices) + y;
-    hidgl_add_triangle (&buffer, last_capx, last_capy, capx, capy, x, y);
-    last_capx = capx;
-    last_capy = capy;
-  }
+
+  hidgl_ensure_vertex_space (&buffer, 6);
+
+  /* FIXME: Should draw an offset rectangle at the appropriate angle,
+   *        avoiding relying on the subcompositing between layers to
+   *        stop us creatign an artaefact by drawing a full circle.
+   */
+  /* NB: Repeated first virtex to separate from other tri-strip */
+  hidgl_add_vertex_tex (&buffer, x - radius, y - radius, -1.0, -1.0);
+  hidgl_add_vertex_tex (&buffer, x - radius, y - radius, -1.0, -1.0);
+  hidgl_add_vertex_tex (&buffer, x - radius, y + radius, -1.0,  1.0);
+  hidgl_add_vertex_tex (&buffer, x + radius, y - radius,  1.0, -1.0);
+  hidgl_add_vertex_tex (&buffer, x + radius, y + radius,  1.0,  1.0);
+  hidgl_add_vertex_tex (&buffer, x + radius, y + radius,  1.0,  1.0);
+  /* NB: Repeated last virtex to separate from other tri-strip */
 }
 
 void
 hidgl_draw_line (int cap, double width, int x1, int y1, int x2, int y2, double scale)
 {
-  double angle;
   float deltax, deltay, length;
   float wdx, wdy;
+  float cosine, sine;
   int circular_caps = 0;
   int hairline = 0;
 
@@ -262,30 +362,20 @@ hidgl_draw_line (int cap, double width, int x1, int y1, int x2, int y2, double s
 
   deltax = x2 - x1;
   deltay = y2 - y1;
-
   length = sqrt (deltax * deltax + deltay * deltay);
 
   if (length == 0) {
     /* Assume the orientation of the line is horizontal */
-    angle = 0;
-    wdx = -width / 2.;
-    wdy = 0;
-    length = 1.;
-    deltax = 1.;
-    deltay = 0.;
+    cosine = 1.0;
+    sine   = 0.0;
   } else {
-    wdy = deltax * width / 2. / length;
-    wdx = -deltay * width / 2. / length;
-
-    if (deltay == 0.)
-      angle = (deltax < 0) ? 270. : 90.;
-    else
-      angle = 180. / M_PI * atanl (deltax / deltay);
-
-    if (deltay < 0)
-      angle += 180.;
+    cosine = deltax / length;
+    sine   = deltay / length;
   }
 
+  wdy =  width / 2. * cosine;
+  wdx = -width / 2. * sine;
+
   switch (cap) {
     case Trace_Cap:
     case Round_Cap:
@@ -294,26 +384,50 @@ hidgl_draw_line (int cap, double width, int x1, int y1, int x2, int y2, double s
 
     case Square_Cap:
     case Beveled_Cap:
-      x1 -= deltax * width / 2. / length;
-      y1 -= deltay * width / 2. / length;
-      x2 += deltax * width / 2. / length;
-      y2 += deltay * width / 2. / length;
+      /* Use wdx and wdy (which already have the correct numbers), just in
+       * case the compiler doesn't spot it can avoid recomputing these. */
+      x1 -= wdy; /* x1 -= width / 2. * cosine;   */
+      y1 += wdx; /* y1 -= width / 2. * sine;     */
+      x2 += wdy; /* x2 += width / 2. * cosine;   */
+      y2 -= wdx; /* y2 += width / 2. / sine;     */
       break;
   }
 
-  hidgl_ensure_triangle_space (&buffer, 2);
-  hidgl_add_triangle (&buffer, x1 - wdx, y1 - wdy,
-                               x2 - wdx, y2 - wdy,
-                               x2 + wdx, y2 + wdy);
-  hidgl_add_triangle (&buffer, x1 - wdx, y1 - wdy,
-                               x2 + wdx, y2 + wdy,
-                               x1 + wdx, y1 + wdy);
-
   /* Don't bother capping hairlines */
   if (circular_caps && !hairline)
     {
-      draw_cap (width, x1, y1, angle, scale);
-      draw_cap (width, x2, y2, angle + 180., scale);
+      float capx = deltax * width / 2. / length;
+      float capy = deltay * width / 2. / length;
+
+      hidgl_ensure_vertex_space (&buffer, 10);
+
+      /* NB: Repeated first virtex to separate from other tri-strip */
+      hidgl_add_vertex_tex (&buffer, x1 - wdx - capx, y1 - wdy - capy, -1.0, -1.0);
+      hidgl_add_vertex_tex (&buffer, x1 - wdx - capx, y1 - wdy - capy, -1.0, -1.0);
+      hidgl_add_vertex_tex (&buffer, x1 + wdx - capx, y1 + wdy - capy, -1.0,  1.0);
+      hidgl_add_vertex_tex (&buffer, x1 - wdx,        y1 - wdy,         0.0, -1.0);
+      hidgl_add_vertex_tex (&buffer, x1 + wdx,        y1 + wdy,         0.0,  1.0);
+
+      hidgl_add_vertex_tex (&buffer, x2 - wdx,        y2 - wdy,         0.0, -1.0);
+      hidgl_add_vertex_tex (&buffer, x2 + wdx,        y2 + wdy,         0.0,  1.0);
+      hidgl_add_vertex_tex (&buffer, x2 - wdx + capx, y2 - wdy + capy,  1.0, -1.0);
+      hidgl_add_vertex_tex (&buffer, x2 + wdx + capx, y2 + wdy + capy,  1.0,  1.0);
+      hidgl_add_vertex_tex (&buffer, x2 + wdx + capx, y2 + wdy + capy,  1.0,  1.0);
+      /* NB: Repeated last virtex to separate from other tri-strip */
+    }
+  else
+    {
+      hidgl_ensure_vertex_space (&buffer, 6);
+
+      /* NB: Repeated first virtex to separate from other tri-strip */
+      hidgl_add_vertex_tex (&buffer, x1 - wdx, y1 - wdy, 0.0, -1.0);
+      hidgl_add_vertex_tex (&buffer, x1 - wdx, y1 - wdy, 0.0, -1.0);
+      hidgl_add_vertex_tex (&buffer, x1 + wdx, y1 + wdy, 0.0,  1.0);
+
+      hidgl_add_vertex_tex (&buffer, x2 - wdx, y2 - wdy, 0.0, -1.0);
+      hidgl_add_vertex_tex (&buffer, x2 + wdx, y2 + wdy, 0.0,  1.0);
+      hidgl_add_vertex_tex (&buffer, x2 + wdx, y2 + wdy, 0.0,  1.0);
+      /* NB: Repeated last virtex to separate from other tri-strip */
     }
 }
 
@@ -392,15 +506,16 @@ hidgl_draw_arc (double width, int x, int y, int rx, int ry,
 
   draw_cap (width, x + rx * -cosf (start_angle_rad),
                    y + rx *  sinf (start_angle_rad),
-                   start_angle, scale);
+                   start_angle);
   draw_cap (width, x + rx * -cosf (start_angle_rad + delta_angle_rad),
                    y + rx *  sinf (start_angle_rad + delta_angle_rad),
-                   start_angle + delta_angle + 180., scale);
+                   start_angle + delta_angle + 180.);
 }
 
 void
 hidgl_draw_rect (int x1, int y1, int x2, int y2)
 {
+  return;
   CHECK_IS_IN_CONTEXT ();
   glBegin (GL_LINE_LOOP);
   glVertex3f (x1, y1, global_depth);
@@ -412,37 +527,20 @@ hidgl_draw_rect (int x1, int y1, int x2, int y2)
 
 
 void
-hidgl_fill_circle (int vx, int vy, int vr, double scale)
+hidgl_fill_circle (int x, int y, int radius)
 {
-#define MIN_TRIANGLES_PER_CIRCLE 6
-#define MAX_TRIANGLES_PER_CIRCLE 360
-  float last_x, last_y;
-  float radius = vr;
-  int slices;
-  int i;
-
   CHECK_IS_IN_CONTEXT ();
-  slices = calc_slices (vr / scale, 2 * M_PI);
-
-  if (slices < MIN_TRIANGLES_PER_CIRCLE)
-    slices = MIN_TRIANGLES_PER_CIRCLE;
-
-  if (slices > MAX_TRIANGLES_PER_CIRCLE)
-    slices = MAX_TRIANGLES_PER_CIRCLE;
 
-  hidgl_ensure_triangle_space (&buffer, slices);
+  hidgl_ensure_vertex_space (&buffer, 6);
 
-  last_x = vx + vr;
-  last_y = vy;
-
-  for (i = 0; i < slices; i++) {
-    float x, y;
-    x = radius * cosf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vx;
-    y = radius * sinf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vy;
-    hidgl_add_triangle (&buffer, vx, vy, last_x, last_y, x, y);
-    last_x = x;
-    last_y = y;
-  }
+  /* NB: Repeated first virtex to separate from other tri-strip */
+  hidgl_add_vertex_tex (&buffer, x - radius, y - radius, -1.0, -1.0);
+  hidgl_add_vertex_tex (&buffer, x - radius, y - radius, -1.0, -1.0);
+  hidgl_add_vertex_tex (&buffer, x - radius, y + radius, -1.0,  1.0);
+  hidgl_add_vertex_tex (&buffer, x + radius, y - radius,  1.0, -1.0);
+  hidgl_add_vertex_tex (&buffer, x + radius, y + radius,  1.0,  1.0);
+  hidgl_add_vertex_tex (&buffer, x + radius, y + radius,  1.0,  1.0);
+  /* NB: Repeated last virtex to separate from other tri-strip */
 }
 
 #define MAX_COMBINED_MALLOCS 2500
@@ -506,8 +604,6 @@ myBegin (GLenum type)
   triangle_comp_idx = 0;
 }
 
-static double global_scale;
-
 static void
 myVertex (GLdouble *vertex_data)
 {
@@ -601,20 +697,14 @@ hidgl_fill_polygon (int n_coords, int *x, int *y)
 }
 
 static void
-fill_contour (PLINE *contour, double scale)
+fill_contour (PLINE *contour)
 {
   cairo_traps_t traps;
 
-  /* If the contour is round, and hidgl_fill_circle would use
-   * less slices than we have vertices to draw it, then call
-   * hidgl_fill_circle to draw this contour.
-   */
+  /* If the contour is round, then call hidgl_fill_circle to draw it. */
   if (contour->is_round) {
-    double slices = calc_slices (contour->radius / scale, 2 * M_PI);
-    if (slices < contour->Count) {
-      hidgl_fill_circle (contour->cx, contour->cy, contour->radius, scale);
-      return;
-    }
+    hidgl_fill_circle (contour->cx, contour->cy, contour->radius);
+    return;
   }
 
   _cairo_traps_init (&traps);
@@ -622,14 +712,9 @@ fill_contour (PLINE *contour, double scale)
   _cairo_traps_fini (&traps);
 }
 
-struct do_hole_info {
-  double scale;
-};
-
 static int
 do_hole (const BoxType *b, void *cl)
 {
-  struct do_hole_info *info = cl;
   PLINE *curc = (PLINE *) b;
 
   /* Ignore the outer contour - we draw it first explicitly*/
@@ -637,7 +722,7 @@ do_hole (const BoxType *b, void *cl)
     return 0;
   }
 
-  fill_contour (curc, info->scale);
+  fill_contour (curc);
   return 1;
 }
 
@@ -647,14 +732,11 @@ static int assigned_bits = 0;
 
 /* FIXME: JUST DRAWS THE FIRST PIECE.. TODO: SUPPORT FOR FULLPOLY POLYGONS */
 void
-hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale)
+hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box)
 {
-  struct do_hole_info info;
   int stencil_bit;
 
   CHECK_IS_IN_CONTEXT ();
-  info.scale = scale;
-  global_scale = scale;
 
   if (poly->Clipped == NULL)
     {
@@ -684,7 +766,7 @@ hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale
    */
   /* Drawing operations now set our reference bit in the stencil buffer */
 
-  r_search (poly->Clipped->contour_tree, clip_box, NULL, do_hole, &info);
+  r_search (poly->Clipped->contour_tree, clip_box, NULL, do_hole, NULL);
   hidgl_flush_triangles (&buffer);
 
   /* Drawing operations as masked to areas where the stencil buffer is '0' */
@@ -700,7 +782,7 @@ hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale
                                                               // any bits permitted by the stencil writemask
 
   /* Draw the polygon outer */
-  fill_contour (poly->Clipped->contours, scale);
+  fill_contour (poly->Clipped->contours);
   hidgl_flush_triangles (&buffer);
 
   /* Unassign our stencil buffer bit */
@@ -713,14 +795,44 @@ void
 hidgl_fill_rect (int x1, int y1, int x2, int y2)
 {
   CHECK_IS_IN_CONTEXT ();
-  hidgl_ensure_triangle_space (&buffer, 2);
-  hidgl_add_triangle (&buffer, x1, y1, x1, y2, x2, y2);
-  hidgl_add_triangle (&buffer, x2, y1, x2, y2, x1, y1);
+  hidgl_ensure_vertex_space (&buffer, 6);
+
+  /* NB: Repeated first virtex to separate from other tri-strip */
+  hidgl_add_vertex_tex (&buffer, x1, y1, 0.0, 0.0);
+  hidgl_add_vertex_tex (&buffer, x1, y1, 0.0, 0.0);
+  hidgl_add_vertex_tex (&buffer, x1, y2, 0.0, 0.0);
+  hidgl_add_vertex_tex (&buffer, x2, y1, 0.0, 0.0);
+  hidgl_add_vertex_tex (&buffer, x2, y2, 0.0, 0.0);
+  hidgl_add_vertex_tex (&buffer, x2, y2, 0.0, 0.0);
+  /* NB: Repeated last virtex to separate from other tri-strip */
+}
+
+static void
+load_built_in_shaders (void)
+{
+  char *circular_fs_source =
+          "void main()\n"
+          "{\n"
+          "  float sqdist;\n"
+          "  sqdist = dot (gl_TexCoord[0].st, gl_TexCoord[0].st);\n"
+          "  if (sqdist > 1.0)\n"
+          "    discard;\n"
+          "  gl_FragColor = gl_Color;\n"
+          "}\n";
+
+  circular_program = hidgl_shader_new ("circular_rendering", NULL, circular_fs_source);
+
+  hidgl_shader_activate (circular_program);
 }
 
 void
 hidgl_init (void)
 {
+  static bool done_once = false;
+
+  if (done_once)
+    return;
+
   CHECK_IS_IN_CONTEXT ();
   glGetIntegerv (GL_STENCIL_BITS, &stencil_bits);
 
@@ -736,6 +848,16 @@ hidgl_init (void)
               "Cannot use stencil buffer to sub-composite layers.\n");
       /* Do we need to disable that somewhere? */
     }
+
+  if (!hidgl_shader_init_shaders ()) {
+    printf ("Failed to initialise shader support\n");
+    goto done;
+  }
+
+  load_built_in_shaders ();
+
+done:
+  done_once = true;
 }
 
 int
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index 1ed8eb3..c6bc7de 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -23,37 +23,93 @@
 #ifndef __HIDGL_INCLUDED__
 #define __HIDGL_INCLUDED__
 
-#define TRIANGLE_ARRAY_SIZE 5461
+#include "hidgl_shaders.h"
+
+#define TRIANGLE_ARRAY_SIZE 30000
 typedef struct {
-  GLfloat triangle_array [3 * 3 * TRIANGLE_ARRAY_SIZE];
+  GLfloat *triangle_array;
   unsigned int triangle_count;
   unsigned int coord_comp_count;
+  unsigned int vertex_count;
+  unsigned int total_triangles;
+  unsigned int total_vertices;
+  GLuint vbo_id;
+  bool use_vbo;
+  bool use_map;
 } triangle_buffer;
 
 extern triangle_buffer buffer;
 extern float global_depth;
 
+extern hidgl_shader *circular_program;
+
 void hidgl_in_context (bool is_in_context);
 void hidgl_init_triangle_array (triangle_buffer *buffer);
+void hidgl_finish_triangle_array (triangle_buffer *buffer);
 void hidgl_flush_triangles (triangle_buffer *buffer);
+void hidgl_ensure_vertex_space (triangle_buffer *buffer, int count);
 void hidgl_ensure_triangle_space (triangle_buffer *buffer, int count);
 
+inline void
+hidgl_add_vertex_3D_tex (triangle_buffer *buffer,
+                         GLfloat x, GLfloat y, GLfloat z,
+                         GLfloat s, GLfloat t)
+{
+  buffer->triangle_array [buffer->coord_comp_count++] = x;
+  buffer->triangle_array [buffer->coord_comp_count++] = y;
+  buffer->triangle_array [buffer->coord_comp_count++] = z;
+  buffer->triangle_array [buffer->coord_comp_count++] = s;
+  buffer->triangle_array [buffer->coord_comp_count++] = t;
+  buffer->vertex_count++;
+  buffer->total_vertices++;
+}
+
+inline void
+hidgl_add_vertex_tex (triangle_buffer *buffer,
+                      GLfloat x, GLfloat y,
+                      GLfloat s, GLfloat t)
+{
+  hidgl_add_vertex_3D_tex (buffer, x, y, global_depth, s, t);
+}
+
+
+static inline void
+hidgl_add_triangle_3D_tex (triangle_buffer *buffer,
+                           GLfloat x1, GLfloat y1, GLfloat z1, GLfloat s1, GLfloat t1,
+                           GLfloat x2, GLfloat y2, GLfloat z2, GLfloat s2, GLfloat t2,
+                           GLfloat x3, GLfloat y3, GLfloat z3, GLfloat s3, GLfloat t3)
+{
+  /* NB: Repeated first virtex to separate from other tri-strip */
+  hidgl_add_vertex_3D_tex (buffer, x1, y1, z1, s1, t1);
+  hidgl_add_vertex_3D_tex (buffer, x1, y1, z1, s1, t1);
+  hidgl_add_vertex_3D_tex (buffer, x2, y2, z2, s2, t2);
+  hidgl_add_vertex_3D_tex (buffer, x3, y3, z3, s3, t3);
+  hidgl_add_vertex_3D_tex (buffer, x3, y3, z3, s3, t3);
+  /* NB: Repeated last virtex to separate from other tri-strip */
+  buffer->triangle_count++;
+  buffer->total_triangles++;
+}
+
 static inline void
 hidgl_add_triangle_3D (triangle_buffer *buffer,
                        GLfloat x1, GLfloat y1, GLfloat z1,
                        GLfloat x2, GLfloat y2, GLfloat z2,
                        GLfloat x3, GLfloat y3, GLfloat z3)
 {
-  buffer->triangle_array [buffer->coord_comp_count++] = x1;
-  buffer->triangle_array [buffer->coord_comp_count++] = y1;
-  buffer->triangle_array [buffer->coord_comp_count++] = z1;
-  buffer->triangle_array [buffer->coord_comp_count++] = x2;
-  buffer->triangle_array [buffer->coord_comp_count++] = y2;
-  buffer->triangle_array [buffer->coord_comp_count++] = z2;
-  buffer->triangle_array [buffer->coord_comp_count++] = x3;
-  buffer->triangle_array [buffer->coord_comp_count++] = y3;
-  buffer->triangle_array [buffer->coord_comp_count++] = z3;
-  buffer->triangle_count++;
+  hidgl_add_triangle_3D_tex (buffer, x1, y1, z1, 0., 0.,
+                                     x2, y2, z2, 0., 0.,
+                                     x3, y3, z3, 0., 0.);
+}
+
+static inline void
+hidgl_add_triangle_tex (triangle_buffer *buffer,
+                        GLfloat x1, GLfloat y1, GLfloat s1, GLfloat t1,
+                        GLfloat x2, GLfloat y2, GLfloat s2, GLfloat t2,
+                        GLfloat x3, GLfloat y3, GLfloat s3, GLfloat t3)
+{
+  hidgl_add_triangle_3D_tex (buffer, x1, y1, global_depth, s1, t1,
+                                     x2, y2, global_depth, s2, t2,
+                                     x3, y3, global_depth, s3, t3);
 }
 
 static inline void
@@ -71,9 +127,9 @@ hidgl_add_triangle (triangle_buffer *buffer,
 void hidgl_draw_line (int cap, double width, int x1, int y1, int x2, int y2, double scale);
 void hidgl_draw_arc (double width, int vx, int vy, int vrx, int vry, int start_angle, int delta_angle, double scale);
 void hidgl_draw_rect (int x1, int y1, int x2, int y2);
-void hidgl_fill_circle (int vx, int vy, int vr, double scale);
+void hidgl_fill_circle (int vx, int vy, int vr);
 void hidgl_fill_polygon (int n_coords, int *x, int *y);
-void hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale);
+void hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box);
 void hidgl_fill_rect (int x1, int y1, int x2, int y2);
 
 void hidgl_init (void);
diff --git a/src/hid/common/hidgl_shaders.c b/src/hid/common/hidgl_shaders.c
new file mode 100644
index 0000000..8609afe
--- /dev/null
+++ b/src/hid/common/hidgl_shaders.c
@@ -0,0 +1,165 @@
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 2010 PCB Contributors (See ChangeLog for details).
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdbool.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+
+/* The Linux OpenGL ABI 1.0 spec requires that we define
+ * GL_GLEXT_PROTOTYPES before including gl.h or glx.h for extensions
+ * in order to get prototypes:
+ *   http://www.opengl.org/registry/ABI/
+ */
+#define GL_GLEXT_PROTOTYPES 1
+#include <GL/gl.h>
+#include <GL/glu.h>
+#include "hidgl_shaders.h"
+
+#ifdef HAVE_LIBDMALLOC
+#include <dmalloc.h>
+#endif
+
+/* Opaque data-structure keeping a shader object */
+struct _hidgl_shader {
+  char *name;
+  GLuint program;
+  GLuint vs;
+  GLuint fs;
+};
+
+bool
+hidgl_shader_init_shaders (void)
+{
+  /* XXX: Check for required functionality in the GL driver */
+  return true;
+}
+
+/* From http://gpwiki.org/index.php/OpenGL:Codes:Simple_GLSL_example */
+static void
+print_log (GLuint obj)
+{
+  int infologLength = 0;
+  int maxLength;
+  char *infoLog;
+
+  if (glIsShader (obj))
+    glGetShaderiv (obj, GL_INFO_LOG_LENGTH, &maxLength);
+  else
+    glGetProgramiv (obj, GL_INFO_LOG_LENGTH, &maxLength);
+
+  infoLog = malloc (maxLength);
+
+  if (glIsShader (obj))
+    glGetShaderInfoLog (obj, maxLength, &infologLength, infoLog);
+  else
+    glGetProgramInfoLog (obj, maxLength, &infologLength, infoLog);
+
+  if (infologLength > 0)
+    printf ("%s\n", infoLog);
+
+  free (infoLog);
+}
+
+
+/* If either vs or fs is NULL, used the fixed function pipeline for that */
+hidgl_shader *
+hidgl_shader_new (char *name, char *vs_source, char *fs_source)
+{
+  hidgl_shader *shader;
+  const char *source;
+  int source_len;
+
+  shader = malloc (sizeof (hidgl_shader));
+
+  if (shader == NULL)
+    return NULL;
+
+  shader->name = strdup (name);
+  shader->program = 0;
+  shader->vs = 0;
+  shader->fs = 0;
+
+  if (fs_source == NULL && vs_source == NULL)
+    return shader;
+
+  shader->program = glCreateProgram ();
+
+  if (vs_source != NULL) {
+    source = vs_source;
+    source_len = -1; /* The string is '\0' terminated */
+    shader->vs = glCreateShader (GL_VERTEX_SHADER);
+    glShaderSource (shader->vs, 1, &source, &source_len);
+    glCompileShader (shader->vs);
+    print_log (shader->vs);
+    glAttachShader (shader->program, shader->vs);
+  }
+
+  if (fs_source != NULL) {
+    source = fs_source;
+    source_len = -1; /* The string is '\0' terminated */
+    shader->fs = glCreateShader (GL_FRAGMENT_SHADER);
+    glShaderSource (shader->fs, 1, &source, &source_len);
+    glCompileShader (shader->fs);
+    print_log (shader->fs);
+    glAttachShader (shader->program, shader->fs);
+  }
+
+  glLinkProgram (shader->program);
+  print_log (shader->program);
+  return shader;
+}
+
+
+GLuint
+hidgl_shader_get_program (hidgl_shader *shader)
+{
+  return shader->program;
+}
+
+
+/* Delete the passed shader. */
+void
+hidgl_shader_free (hidgl_shader *shader)
+{
+  /* NB: These calls all silently ignore 0 or NULL arguments */
+  glDeleteShader (shader->vs);
+  glDeleteShader (shader->fs);
+  glDeleteProgram (shader->program);
+  free (shader->name);
+  free (shader);
+}
+
+
+/* Activate the given shader program, or deactivate if NULL passed */
+void
+hidgl_shader_activate (hidgl_shader *shader)
+{
+  if (shader == NULL)
+    glUseProgram (0);
+  else
+    glUseProgram (shader->program);
+}
diff --git a/src/hid/common/hidgl_shaders.h b/src/hid/common/hidgl_shaders.h
new file mode 100644
index 0000000..9812b4b
--- /dev/null
+++ b/src/hid/common/hidgl_shaders.h
@@ -0,0 +1,35 @@
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 2010 PCB Contributors (See ChangeLog for details).
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifndef __HIDGL_SHADERS_INCLUDED__
+#define __HIDGL_SHADERS_INCLUDED__
+
+typedef struct _hidgl_shader hidgl_shader;
+
+bool hidgl_shader_init_shaders (void);
+
+hidgl_shader *hidgl_shader_new (char *name, char *vs_source, char *fs_source);
+GLuint hidgl_shader_get_program (hidgl_shader *shader);
+void hidgl_shader_free (hidgl_shader *shader);
+void hidgl_shader_activate (hidgl_shader *shader);
+
+#endif /* __HIDGL_SHADERS_INCLUDED__  */
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 7d81d23..ef524ef 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -32,6 +32,8 @@
 #include <dmalloc.h>
 #endif
 
+#undef ONE_SHOT
+//#define ONE_SHOT
 
 RCSID ("$Id$");
 
@@ -710,7 +712,7 @@ ghid_fill_circle (hidGC gc, int cx, int cy, int radius)
 {
   USE_GC (gc);
 
-  hidgl_fill_circle (cx, cy, radius, gport->zoom);
+  hidgl_fill_circle (cx, cy, radius);
 }
 
 
@@ -727,7 +729,7 @@ ghid_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
 {
   USE_GC (gc);
 
-  hidgl_fill_pcb_polygon (poly, clip_box, gport->zoom);
+  hidgl_fill_pcb_polygon (poly, clip_box);
 }
 
 void
@@ -1536,9 +1538,7 @@ DrawDrillChannel (int vx, int vy, int vr, int from_layer, int to_layer, double s
 #define MIN_FACES_PER_CYL 6
 #define MAX_FACES_PER_CYL 360
   float radius = vr;
-  float x1, y1;
-  float x2, y2;
-  float z1, z2;
+  float x, y, z1, z2;
   int i;
   int slices;
 
@@ -1553,19 +1553,27 @@ DrawDrillChannel (int vx, int vy, int vr, int from_layer, int to_layer, double s
   z1 = compute_depth (from_layer);
   z2 = compute_depth (to_layer);
 
-  x1 = vx + vr;
-  y1 = vy;
+  x = vx + vr;
+  y = vy;
+
+  hidgl_ensure_vertex_space (&buffer, 2 * slices + 2 + 2);
+
+  /* NB: Repeated first virtex to separate from other tri-strip */
+  hidgl_add_vertex_3D_tex (&buffer, x, y, z1, 0.0, 0.0);
+  hidgl_add_vertex_3D_tex (&buffer, x, y, z1, 0.0, 0.0);
+  hidgl_add_vertex_3D_tex (&buffer, x, y, z2, 0.0, 0.0);
 
-  hidgl_ensure_triangle_space (&buffer, 2 * slices);
   for (i = 0; i < slices; i++)
     {
-      x2 = radius * cosf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vx;
-      y2 = radius * sinf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vy;
-      hidgl_add_triangle_3D (&buffer, x1, y1, z1,  x2, y2, z1,  x1, y1, z2);
-      hidgl_add_triangle_3D (&buffer, x2, y2, z1,  x1, y1, z2,  x2, y2, z2);
-      x1 = x2;
-      y1 = y2;
+      x = radius * cosf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vx;
+      y = radius * sinf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vy;
+
+      hidgl_add_vertex_3D_tex (&buffer, x, y, z1, 0.0, 0.0);
+      hidgl_add_vertex_3D_tex (&buffer, x, y, z2, 0.0, 0.0);
     }
+
+  /* NB: Repeated last virtex to separate from other tri-strip */
+  hidgl_add_vertex_3D_tex (&buffer, x, y, z2, 0.0, 0.0);
 }
 
 struct cyl_info {
@@ -1809,7 +1817,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
                              GdkEventExpose *ev,
                              GHidPort *port)
 {
-#if 0
+#ifdef ONE_SHOT
   static int one_shot = 1;
   static int display_list;
 #endif
@@ -1820,6 +1828,9 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   int min_depth;
   int max_depth;
 
+  buffer.total_triangles = 0;
+  buffer.total_vertices = 0;
+
   ghid_start_drawing (port);
 
   hidgl_in_context (true);
@@ -1865,7 +1876,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
                              -port->view_y0, 0);
   glGetFloatv (GL_MODELVIEW_MATRIX, (GLfloat *)last_modelview_matrix);
 
-#if 0
+#ifdef ONE_SHOT
   if (one_shot) {
 
     display_list = glGenLists(1);
@@ -1991,7 +2002,6 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
     glEnd ();
   }
 
-
   // hid_expose_callback (&ghid_hid, &region, 0);
   ghid_draw_everything (&region);
   hidgl_flush_triangles (&buffer);
@@ -2001,29 +2011,31 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   hidgl_set_depth (compute_depth (GetLayerGroupNumberByNumber (INDEXOFCURRENT)));
   ghid_draw_grid (&region);
 
-  hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
   DrawAttached (TRUE);
   DrawMark (TRUE);
   hidgl_flush_triangles (&buffer);
 
-#if 0
+#ifdef ONE_SHOT
     glEndList ();
     one_shot = 0;
-  } else {
-    /* Second and subsequent times */
-    glCallList (display_list);
   }
+
+  glCallList (display_list);
 #endif
 
   ghid_show_crosshair (TRUE);
 
   hidgl_flush_triangles (&buffer);
+  hidgl_finish_triangle_array (&buffer);
 
   check_gl_drawing_ok_hack = false;
   hidgl_in_context (false);
   ghid_end_drawing (port);
 
+//  printf ("Triangle count was %i\n", buffer.total_triangles);
+//  printf ("Vertex count was %i\n", buffer.total_vertices);
+
   return FALSE;
 }
 
@@ -2113,7 +2125,6 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   glStencilMask (~0);
   glClearStencil (0);
   glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
-
   hidgl_reset_stencil_usage ();
 
   /* call the drawing routine */
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index 4306bde..51cc402 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -1604,7 +1604,8 @@ Benchmark (int argc, char **argv, int x, int y)
     {
       gdk_window_invalidate_rect (gport->drawing_area->window, NULL, 1);
       gdk_window_process_updates (gport->drawing_area->window, FALSE);
-      gdk_display_sync (display);
+//      gdk_display_sync (display);
+//      usleep (100000);
       time (&end);
       i++;
     }

Bottom: d6b824a879c66b6fa07d532e342cce2042ac015e
Top:    64afe10812f2173654a14893191aa01af0de2256
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-12-06 20:44:26 +0000

Play with GLSL shader for rendering line caps and circles

And of course.. typically, a million other little fixes:

 - Primitive rendering object changed from GL_TRIANGLES to GL_TRIANGLE_STRIP
 - Cache of tristrip data per contour (HACK: in the core)
 - Rendering using mapped VBOs rather than just arrays
 - Updated layer depth code, so we render with "z" in world coordinates
 - Space navigator joystick support fixes against later kernels

Bugs:
 - Layer depths will be wrong for reversed layer group numbering
 - Pixel shader ought to be switched off for polygon fill?
 - hidgl_draw_rect stubbed out (for benchmarking)
 - Draw Element mark stubbed out (for benchmarking)
 - Draw crosshair stubbed out (for benchmarking)
 - Draw crosshair not updated to render in world coordinates

Notes:
 - Apparently it can be better to do glVertexPointer last (so we do):
    From: http://sdickinson.com/wordpress/?p=122
    ""
    Make sure you put glVertexPointer at the end as there is a lot of work that
    goes on behind the scenes with it, and if it's set at the start, it has to
    do all that work for each gl*Pointer call, rather than once at the end.
    ""

 - We set up the array pointers before calling glEnableClientState():
    I'm not sure, but if we do this the other way around, it might cause
    the driver to hang onto our old buffers longer, or perform state setup,
    only to have to discard that work shortly after.

 - DARN: Seems that using VBOs is not a win, even on Intel 965:
    Certainly seems to fail miserably (v. low FPS) on my NVidia card.

    On Intel, sysprof shows a huge amount of time spent clflushing
    buffers, or copying to the graphics card (uncached).

    Set to use glBufferSubData by default for now.


---

diff --git a/src/Makefile.am b/src/Makefile.am
index 3f3c291..70e759d 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -185,6 +185,8 @@ LIBGTK_GL_SRCS= \
 GL_SRCS= \
 	hid/common/hidgl.c \
 	hid/common/hidgl.h \
+	hid/common/hidgl_shaders.c \
+	hid/common/hidgl_shaders.h \
 	hid/common/trackball.c \
 	hid/common/trackball.h
 
diff --git a/src/cairo/cairo-bentley-ottmann.c b/src/cairo/cairo-bentley-ottmann.c
index fcc0e66..9c9d43e 100644
--- a/src/cairo/cairo-bentley-ottmann.c
+++ b/src/cairo/cairo-bentley-ottmann.c
@@ -126,7 +126,7 @@ typedef struct _cairo_bo_sweep_line {
 } cairo_bo_sweep_line_t;
 
 
-static cairo_fixed_t
+/*static*/ cairo_fixed_t
 _line_compute_intersection_x_for_y (const cairo_line_t *line,
                                     cairo_fixed_t y)
 {
@@ -1451,9 +1451,21 @@ bo_poly_to_traps (POLYAREA *poly, cairo_traps_t *traps)
       hidgl_ensure_triangle_space (&buffer, 1);
       hidgl_add_triangle (&buffer, x1, y1, x2, y2, x3, y3);
     } else {
+#if 0
       hidgl_ensure_triangle_space (&buffer, 2);
       hidgl_add_triangle (&buffer, x1, y1, x2, y2, x3, y3);
       hidgl_add_triangle (&buffer, x3, y3, x4, y4, x1, y1);
+#endif
+      hidgl_ensure_vertex_space (&buffer, 6);
+
+      /* NB: Repeated first virtex to separate from other tri-strip */
+      hidgl_add_vertex_tex (&buffer, x2, y2, 0.0, 0.0);
+      hidgl_add_vertex_tex (&buffer, x2, y2, 0.0, 0.0);
+      hidgl_add_vertex_tex (&buffer, x1, y1, 0.0, 0.0);
+      hidgl_add_vertex_tex (&buffer, x3, y3, 0.0, 0.0);
+      hidgl_add_vertex_tex (&buffer, x4, y4, 0.0, 0.0);
+      hidgl_add_vertex_tex (&buffer, x4, y4, 0.0, 0.0);
+      /* NB: Repeated last virtex to separate from other tri-strip */
     }
 #else
     glBegin (GL_LINES);
@@ -1477,7 +1489,6 @@ bo_poly_to_traps (POLYAREA *poly, cairo_traps_t *traps)
   return CAIRO_STATUS_SUCCESS;
 }
 
-
 cairo_status_t
 bo_contour_to_traps (PLINE *contour, cairo_traps_t *traps)
 {
@@ -1567,3 +1578,57 @@ bo_contour_to_traps (PLINE *contour, cairo_traps_t *traps)
 
   return CAIRO_STATUS_SUCCESS;
 }
+
+
+cairo_status_t
+bo_contour_to_traps_no_draw (PLINE *contour, cairo_traps_t *traps)
+{
+  int intersections;
+  cairo_status_t status;
+  cairo_bo_start_event_t stack_events[CAIRO_STACK_ARRAY_LENGTH (cairo_bo_start_event_t)];
+  cairo_bo_start_event_t *events;
+  cairo_bo_event_t *stack_event_ptrs[ARRAY_LENGTH (stack_events) + 1];
+  cairo_bo_event_t **event_ptrs;
+  int num_events = 0;
+  int i;
+
+  num_events = contour->Count;
+
+  if (unlikely (0 == num_events))
+      return CAIRO_STATUS_SUCCESS;
+
+  events = stack_events;
+  event_ptrs = stack_event_ptrs;
+  if (num_events > ARRAY_LENGTH (stack_events)) {
+      events = _cairo_malloc_ab_plus_c (num_events,
+                                        sizeof (cairo_bo_start_event_t) +
+                                        sizeof (cairo_bo_event_t *),
+                                        sizeof (cairo_bo_event_t *));
+      if (unlikely (events == NULL))
+          return CAIRO_STATUS_NO_MEMORY;
+
+      event_ptrs = (cairo_bo_event_t **) (events + num_events);
+  }
+
+  i = 0;
+
+  contour_to_start_events (contour, events, event_ptrs, &i, 1);
+
+  /* XXX: This would be the convenient place to throw in multiple
+   * passes of the Bentley-Ottmann algorithm. It would merely
+   * require storing the results of each pass into a temporary
+   * cairo_traps_t. */
+  status = _cairo_bentley_ottmann_tessellate_bo_edges (event_ptrs,
+                                                       num_events,
+                                                       traps,
+                                                       &intersections);
+
+#if DEBUG_TRAPS
+  dump_traps (traps, "bo-polygon-out.txt");
+#endif
+
+  if (events != stack_events)
+      free (events);
+
+  return CAIRO_STATUS_SUCCESS;
+}
diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index 238e61d..3448565 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -47,6 +47,7 @@ RCSID ("$Id: $");
 
 triangle_buffer buffer;
 float global_depth = 0;
+hidgl_shader *circular_program = NULL;
 
 static bool in_context = false;
 
@@ -75,43 +76,150 @@ hidgl_new_triangle_array (void)
 }
 #endif
 
+#define BUFFER_STRIDE (5 * sizeof (GLfloat))
+#define BUFFER_SIZE (BUFFER_STRIDE * 3 * TRIANGLE_ARRAY_SIZE)
+
+/* NB: If using VBOs, the caller must ensure the VBO is bound to the GL_ARRAY_BUFFER */
+static void
+hidgl_reset_triangle_array (triangle_buffer *buffer)
+{
+  if (buffer->use_map) {
+    /* Hint to the driver that we're done with the previous buffer contents */
+    glBufferData (GL_ARRAY_BUFFER, BUFFER_SIZE, NULL, GL_STREAM_DRAW);
+    /* Map the new memory to upload vertices into. */
+    buffer->triangle_array = glMapBuffer (GL_ARRAY_BUFFER, GL_WRITE_ONLY);
+  }
+
+  /* If mapping the VBO fails (or if we aren't using VBOs) fall back to
+   * local storage.
+   */
+  if (buffer->triangle_array == NULL) {
+    buffer->triangle_array = malloc (BUFFER_SIZE);
+    buffer->use_map = false;
+  }
+
+  /* Don't want this bound for now */
+  glBindBuffer (GL_ARRAY_BUFFER, 0);
+
+  buffer->triangle_count = 0;
+  buffer->coord_comp_count = 0;
+  buffer->vertex_count = 0;
+}
+
 void
 hidgl_init_triangle_array (triangle_buffer *buffer)
 {
   CHECK_IS_IN_CONTEXT ();
-  glEnableClientState (GL_VERTEX_ARRAY);
-  glVertexPointer (3, GL_FLOAT, 0, buffer->triangle_array);
-  buffer->triangle_count = 0;
-  buffer->coord_comp_count = 0;
+
+  buffer->use_vbo = true;
+  // buffer->use_vbo = false;
+
+  if (buffer->use_vbo) {
+    glGenBuffers (1, &buffer->vbo_id);
+    glBindBuffer (GL_ARRAY_BUFFER, buffer->vbo_id);
+  }
+
+  if (buffer->vbo_id == 0)
+    buffer->use_vbo = false;
+
+  buffer->use_map = buffer->use_vbo;
+
+  /* NB: Mapping the whole buffer can be expensive since we ask the driver
+   *     to discard previous data and give us a "new" buffer to write into
+   *     each time. If it is still rendering from previous buffer, we end
+   *     up causing a lot of unnecessary allocation in the driver this way.
+   *
+   *     On intel drivers at least, glBufferSubData does not block. It uploads
+   *     into a temporary buffer and queues a GPU copy of the uploaded data
+   *     for when the "main" buffer has finished rendering.
+   */
+  buffer->use_map = false;
+
+  /* If using VBOs (but not mapping), we only need to this once */
+  if (buffer->use_vbo && !buffer->use_map)
+    glBufferData (GL_ARRAY_BUFFER, BUFFER_SIZE, NULL, GL_STREAM_DRAW);
+
+  buffer->triangle_array = NULL;
+  hidgl_reset_triangle_array (buffer);
+}
+
+void
+hidgl_finish_triangle_array (triangle_buffer *buffer)
+{
+  if (buffer->use_map) {
+    glBindBuffer (GL_ARRAY_BUFFER, buffer->vbo_id);
+    glUnmapBuffer (GL_ARRAY_BUFFER);
+    glBindBuffer (GL_ARRAY_BUFFER, 0);
+  } else {
+    free (buffer->triangle_array);
+  }
+
+  if (buffer->use_vbo) {
+    glDeleteBuffers (1, &buffer->vbo_id);
+    buffer->vbo_id = 0;
+  }
 }
 
 void
 hidgl_flush_triangles (triangle_buffer *buffer)
 {
+  GLfloat *data_pointer = NULL;
+
   CHECK_IS_IN_CONTEXT ();
-  if (buffer->triangle_count == 0)
+  if (buffer->vertex_count == 0)
     return;
 
-  glDrawArrays (GL_TRIANGLES, 0, buffer->triangle_count * 3);
-  buffer->triangle_count = 0;
-  buffer->coord_comp_count = 0;
+  if (buffer->use_vbo) {
+    glBindBuffer (GL_ARRAY_BUFFER, buffer->vbo_id);
+
+    if (buffer->use_map) {
+      glUnmapBuffer (GL_ARRAY_BUFFER);
+      buffer->triangle_array = NULL;
+    } else {
+      /* NB: We only upload the portion of the buffer we've used */
+      glBufferSubData (GL_ARRAY_BUFFER, 0,
+                       BUFFER_STRIDE * buffer->vertex_count,
+                       buffer->triangle_array);
+    }
+  } else {
+    data_pointer = buffer->triangle_array;
+  }
+
+  glTexCoordPointer (2, GL_FLOAT, BUFFER_STRIDE, data_pointer + 3);
+  glVertexPointer   (3, GL_FLOAT, BUFFER_STRIDE, data_pointer + 0);
+
+  glEnableClientState (GL_TEXTURE_COORD_ARRAY);
+  glEnableClientState (GL_VERTEX_ARRAY);
+  glDrawArrays (GL_TRIANGLE_STRIP, 0, buffer->vertex_count);
+  glDisableClientState (GL_VERTEX_ARRAY);
+  glDisableClientState (GL_TEXTURE_COORD_ARRAY);
+
+  hidgl_reset_triangle_array (buffer);
 }
 
 void
-hidgl_ensure_triangle_space (triangle_buffer *buffer, int count)
+hidgl_ensure_vertex_space (triangle_buffer *buffer, int count)
 {
   CHECK_IS_IN_CONTEXT ();
-  if (count > TRIANGLE_ARRAY_SIZE)
+  if (count > 3 * TRIANGLE_ARRAY_SIZE)
     {
       fprintf (stderr, "Not enough space in vertex buffer\n");
-      fprintf (stderr, "Requested %i triangles, %i available\n",
-                       count, TRIANGLE_ARRAY_SIZE);
+      fprintf (stderr, "Requested %i vertices, %i available\n",
+                       count, 3 * TRIANGLE_ARRAY_SIZE);
       exit (1);
     }
-  if (count > TRIANGLE_ARRAY_SIZE - buffer->triangle_count)
+  if (count > 3 * TRIANGLE_ARRAY_SIZE - buffer->vertex_count)
     hidgl_flush_triangles (buffer);
 }
 
+void
+hidgl_ensure_triangle_space (triangle_buffer *buffer, int count)
+{
+  CHECK_IS_IN_CONTEXT ();
+  /* NB: 5 = 3 + 2 extra vertices to separate from other triangle strips */
+  hidgl_ensure_vertex_space (buffer, count * 5);
+}
+
 //static int cur_mask = -1;
 
 
@@ -215,42 +323,34 @@ int calc_slices (float pix_radius, float sweep_angle)
   return (int)ceilf (slices);
 }
 
-#define MIN_TRIANGLES_PER_CAP 3
-#define MAX_TRIANGLES_PER_CAP 90
-static void draw_cap (double width, int x, int y, double angle, double scale)
+static void draw_cap (double width, int x, int y, double angle)
 {
-  float last_capx, last_capy;
-  float capx, capy;
   float radius = width / 2.;
-  int slices = calc_slices (radius / scale, M_PI);
-  int i;
 
   CHECK_IS_IN_CONTEXT ();
-  if (slices < MIN_TRIANGLES_PER_CAP)
-    slices = MIN_TRIANGLES_PER_CAP;
-
-  if (slices > MAX_TRIANGLES_PER_CAP)
-    slices = MAX_TRIANGLES_PER_CAP;
-
-  hidgl_ensure_triangle_space (&buffer, slices);
-
-  last_capx =  radius * cosf (angle * M_PI / 180.) + x;
-  last_capy = -radius * sinf (angle * M_PI / 180.) + y;
-  for (i = 0; i < slices; i++) {
-    capx =  radius * cosf (angle * M_PI / 180. + ((float)(i + 1)) * M_PI / (float)slices) + x;
-    capy = -radius * sinf (angle * M_PI / 180. + ((float)(i + 1)) * M_PI / (float)slices) + y;
-    hidgl_add_triangle (&buffer, last_capx, last_capy, capx, capy, x, y);
-    last_capx = capx;
-    last_capy = capy;
-  }
+
+  hidgl_ensure_vertex_space (&buffer, 6);
+
+  /* FIXME: Should draw an offset rectangle at the appropriate angle,
+   *        avoiding relying on the subcompositing between layers to
+   *        stop us creatign an artaefact by drawing a full circle.
+   */
+  /* NB: Repeated first virtex to separate from other tri-strip */
+  hidgl_add_vertex_tex (&buffer, x - radius, y - radius, -1.0, -1.0);
+  hidgl_add_vertex_tex (&buffer, x - radius, y - radius, -1.0, -1.0);
+  hidgl_add_vertex_tex (&buffer, x - radius, y + radius, -1.0,  1.0);
+  hidgl_add_vertex_tex (&buffer, x + radius, y - radius,  1.0, -1.0);
+  hidgl_add_vertex_tex (&buffer, x + radius, y + radius,  1.0,  1.0);
+  hidgl_add_vertex_tex (&buffer, x + radius, y + radius,  1.0,  1.0);
+  /* NB: Repeated last virtex to separate from other tri-strip */
 }
 
 void
 hidgl_draw_line (int cap, double width, int x1, int y1, int x2, int y2, double scale)
 {
-  double angle;
   float deltax, deltay, length;
   float wdx, wdy;
+  float cosine, sine;
   int circular_caps = 0;
   int hairline = 0;
 
@@ -263,30 +363,20 @@ hidgl_draw_line (int cap, double width, int x1, int y1, int x2, int y2, double s
 
   deltax = x2 - x1;
   deltay = y2 - y1;
-
   length = sqrt (deltax * deltax + deltay * deltay);
 
   if (length == 0) {
     /* Assume the orientation of the line is horizontal */
-    angle = 0;
-    wdx = -width / 2.;
-    wdy = 0;
-    length = 1.;
-    deltax = 1.;
-    deltay = 0.;
+    cosine = 1.0;
+    sine   = 0.0;
   } else {
-    wdy = deltax * width / 2. / length;
-    wdx = -deltay * width / 2. / length;
-
-    if (deltay == 0.)
-      angle = (deltax < 0) ? 270. : 90.;
-    else
-      angle = 180. / M_PI * atanl (deltax / deltay);
-
-    if (deltay < 0)
-      angle += 180.;
+    cosine = deltax / length;
+    sine   = deltay / length;
   }
 
+  wdy =  width / 2. * cosine;
+  wdx = -width / 2. * sine;
+
   switch (cap) {
     case Trace_Cap:
     case Round_Cap:
@@ -295,26 +385,50 @@ hidgl_draw_line (int cap, double width, int x1, int y1, int x2, int y2, double s
 
     case Square_Cap:
     case Beveled_Cap:
-      x1 -= deltax * width / 2. / length;
-      y1 -= deltay * width / 2. / length;
-      x2 += deltax * width / 2. / length;
-      y2 += deltay * width / 2. / length;
+      /* Use wdx and wdy (which already have the correct numbers), just in
+       * case the compiler doesn't spot it can avoid recomputing these. */
+      x1 -= wdy; /* x1 -= width / 2. * cosine;   */
+      y1 += wdx; /* y1 -= width / 2. * sine;     */
+      x2 += wdy; /* x2 += width / 2. * cosine;   */
+      y2 -= wdx; /* y2 += width / 2. / sine;     */
       break;
   }
 
-  hidgl_ensure_triangle_space (&buffer, 2);
-  hidgl_add_triangle (&buffer, x1 - wdx, y1 - wdy,
-                               x2 - wdx, y2 - wdy,
-                               x2 + wdx, y2 + wdy);
-  hidgl_add_triangle (&buffer, x1 - wdx, y1 - wdy,
-                               x2 + wdx, y2 + wdy,
-                               x1 + wdx, y1 + wdy);
-
   /* Don't bother capping hairlines */
   if (circular_caps && !hairline)
     {
-      draw_cap (width, x1, y1, angle, scale);
-      draw_cap (width, x2, y2, angle + 180., scale);
+      float capx = deltax * width / 2. / length;
+      float capy = deltay * width / 2. / length;
+
+      hidgl_ensure_vertex_space (&buffer, 10);
+
+      /* NB: Repeated first virtex to separate from other tri-strip */
+      hidgl_add_vertex_tex (&buffer, x1 - wdx - capx, y1 - wdy - capy, -1.0, -1.0);
+      hidgl_add_vertex_tex (&buffer, x1 - wdx - capx, y1 - wdy - capy, -1.0, -1.0);
+      hidgl_add_vertex_tex (&buffer, x1 + wdx - capx, y1 + wdy - capy, -1.0,  1.0);
+      hidgl_add_vertex_tex (&buffer, x1 - wdx,        y1 - wdy,         0.0, -1.0);
+      hidgl_add_vertex_tex (&buffer, x1 + wdx,        y1 + wdy,         0.0,  1.0);
+
+      hidgl_add_vertex_tex (&buffer, x2 - wdx,        y2 - wdy,         0.0, -1.0);
+      hidgl_add_vertex_tex (&buffer, x2 + wdx,        y2 + wdy,         0.0,  1.0);
+      hidgl_add_vertex_tex (&buffer, x2 - wdx + capx, y2 - wdy + capy,  1.0, -1.0);
+      hidgl_add_vertex_tex (&buffer, x2 + wdx + capx, y2 + wdy + capy,  1.0,  1.0);
+      hidgl_add_vertex_tex (&buffer, x2 + wdx + capx, y2 + wdy + capy,  1.0,  1.0);
+      /* NB: Repeated last virtex to separate from other tri-strip */
+    }
+  else
+    {
+      hidgl_ensure_vertex_space (&buffer, 6);
+
+      /* NB: Repeated first virtex to separate from other tri-strip */
+      hidgl_add_vertex_tex (&buffer, x1 - wdx, y1 - wdy, 0.0, -1.0);
+      hidgl_add_vertex_tex (&buffer, x1 - wdx, y1 - wdy, 0.0, -1.0);
+      hidgl_add_vertex_tex (&buffer, x1 + wdx, y1 + wdy, 0.0,  1.0);
+
+      hidgl_add_vertex_tex (&buffer, x2 - wdx, y2 - wdy, 0.0, -1.0);
+      hidgl_add_vertex_tex (&buffer, x2 + wdx, y2 + wdy, 0.0,  1.0);
+      hidgl_add_vertex_tex (&buffer, x2 + wdx, y2 + wdy, 0.0,  1.0);
+      /* NB: Repeated last virtex to separate from other tri-strip */
     }
 }
 
@@ -393,15 +507,16 @@ hidgl_draw_arc (double width, int x, int y, int rx, int ry,
 
   draw_cap (width, x + rx * -cosf (start_angle_rad),
                    y + rx *  sinf (start_angle_rad),
-                   start_angle, scale);
+                   start_angle);
   draw_cap (width, x + rx * -cosf (start_angle_rad + delta_angle_rad),
                    y + rx *  sinf (start_angle_rad + delta_angle_rad),
-                   start_angle + delta_angle + 180., scale);
+                   start_angle + delta_angle + 180.);
 }
 
 void
 hidgl_draw_rect (int x1, int y1, int x2, int y2)
 {
+  return;
   CHECK_IS_IN_CONTEXT ();
   glBegin (GL_LINE_LOOP);
   glVertex3f (x1, y1, global_depth);
@@ -413,37 +528,20 @@ hidgl_draw_rect (int x1, int y1, int x2, int y2)
 
 
 void
-hidgl_fill_circle (int vx, int vy, int vr, double scale)
+hidgl_fill_circle (int x, int y, int radius)
 {
-#define MIN_TRIANGLES_PER_CIRCLE 6
-#define MAX_TRIANGLES_PER_CIRCLE 360
-  float last_x, last_y;
-  float radius = vr;
-  int slices;
-  int i;
-
   CHECK_IS_IN_CONTEXT ();
-  slices = calc_slices (vr / scale, 2 * M_PI);
-
-  if (slices < MIN_TRIANGLES_PER_CIRCLE)
-    slices = MIN_TRIANGLES_PER_CIRCLE;
-
-  if (slices > MAX_TRIANGLES_PER_CIRCLE)
-    slices = MAX_TRIANGLES_PER_CIRCLE;
 
-  hidgl_ensure_triangle_space (&buffer, slices);
+  hidgl_ensure_vertex_space (&buffer, 6);
 
-  last_x = vx + vr;
-  last_y = vy;
-
-  for (i = 0; i < slices; i++) {
-    float x, y;
-    x = radius * cosf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vx;
-    y = radius * sinf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vy;
-    hidgl_add_triangle (&buffer, vx, vy, last_x, last_y, x, y);
-    last_x = x;
-    last_y = y;
-  }
+  /* NB: Repeated first virtex to separate from other tri-strip */
+  hidgl_add_vertex_tex (&buffer, x - radius, y - radius, -1.0, -1.0);
+  hidgl_add_vertex_tex (&buffer, x - radius, y - radius, -1.0, -1.0);
+  hidgl_add_vertex_tex (&buffer, x - radius, y + radius, -1.0,  1.0);
+  hidgl_add_vertex_tex (&buffer, x + radius, y - radius,  1.0, -1.0);
+  hidgl_add_vertex_tex (&buffer, x + radius, y + radius,  1.0,  1.0);
+  hidgl_add_vertex_tex (&buffer, x + radius, y + radius,  1.0,  1.0);
+  /* NB: Repeated last virtex to separate from other tri-strip */
 }
 
 #define MAX_COMBINED_MALLOCS 2500
@@ -507,8 +605,6 @@ myBegin (GLenum type)
   triangle_comp_idx = 0;
 }
 
-static double global_scale;
-
 static void
 myVertex (GLdouble *vertex_data)
 {
@@ -525,23 +621,11 @@ myVertex (GLdouble *vertex_data)
         }
       else
         {
-#if 1
           hidgl_ensure_triangle_space (&buffer, 1);
           hidgl_add_triangle (&buffer,
                               triangle_vertices [0], triangle_vertices [1],
                               triangle_vertices [2], triangle_vertices [3],
                               vertex_data [0], vertex_data [1]);
-#else
-          hidgl_draw_line (Square_Cap, global_scale,
-                           triangle_vertices [0], triangle_vertices [1],
-                           triangle_vertices [2], triangle_vertices [3], global_scale);
-          hidgl_draw_line (Square_Cap, global_scale,
-                           triangle_vertices [2], triangle_vertices [3],
-                           vertex_data [0],       vertex_data [1],       global_scale);
-          hidgl_draw_line (Square_Cap, global_scale,
-                           vertex_data [0],       vertex_data [1],
-                           triangle_vertices [0], triangle_vertices [1], global_scale);
-#endif
 
           if (tessVertexType == GL_TRIANGLE_STRIP)
             {
@@ -613,38 +697,148 @@ hidgl_fill_polygon (int n_coords, int *x, int *y)
   free (vertices);
 }
 
-struct do_hole_info {
-  double scale;
-};
+static inline void
+stash_vertex (PLINE *contour, int *vertex_comp,
+              float x, float y, float z, float r, float s)
+{
+  contour->tristrip_vertices[(*vertex_comp)++] = x;
+  contour->tristrip_vertices[(*vertex_comp)++] = y;
+#if MEMCPY_VERTEX_DATA
+  contour->tristrip_vertices[(*vertex_comp)++] = z;
+  contour->tristrip_vertices[(*vertex_comp)++] = r;
+  contour->tristrip_vertices[(*vertex_comp)++] = s;
+#endif
+  contour->tristrip_num_vertices ++;
+}
+
+static void
+fill_contour (PLINE *contour)
+{
+  int i;
+  int vertex_comp;
+  cairo_traps_t traps;
+
+  /* If the contour is round, then call hidgl_fill_circle to draw it. */
+  if (contour->is_round) {
+    hidgl_fill_circle (contour->cx, contour->cy, contour->radius);
+    return;
+  }
+
+  /* If we don't have a cached set of tri-strips, compute them */
+  if (contour->tristrip_vertices == NULL) {
+    int tristrip_space;
+    int x1, x2, x3, x4, y_top, y_bot;
+
+    _cairo_traps_init (&traps);
+    bo_contour_to_traps_no_draw (contour, &traps);
+
+    tristrip_space = 0;
+
+    for (i = 0; i < traps.num_traps; i++) {
+      y_top = traps.traps[i].top;
+      y_bot = traps.traps[i].bottom;
+
+      x1 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_top);
+      x2 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_top);
+      x3 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_bot);
+      x4 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_bot);
+
+      if ((x1 == x2) || (x3 == x4)) {
+        tristrip_space += 5; /* Three vertices + repeated start and end */
+      } else {
+        tristrip_space += 6; /* Four vertices + repeated start and end */
+      }
+    }
+
+    if (tristrip_space == 0) {
+      printf ("Strange, contour didn't tesselate\n");
+      return;
+    }
+
+#if MEMCPY_VERTEX_DATA
+    /* NB: MEMCPY of vertex data causes a problem with depth being cached at the wrong level! */
+    contour->tristrip_vertices = malloc (sizeof (float) * 5 * tristrip_space);
+#else
+    contour->tristrip_vertices = malloc (sizeof (float) * 2 * tristrip_space);
+#endif
+    contour->tristrip_num_vertices = 0;
+
+    vertex_comp = 0;
+    for (i = 0; i < traps.num_traps; i++) {
+      y_top = traps.traps[i].top;
+      y_bot = traps.traps[i].bottom;
+
+      x1 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_top);
+      x2 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_top);
+      x3 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_bot);
+      x4 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_bot);
+
+      if (x1 == x2) {
+        /* NB: Repeated first virtex to separate from other tri-strip */
+        stash_vertex (contour, &vertex_comp, x1, y_top, global_depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x1, y_top, global_depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x3, y_bot, global_depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x4, y_bot, global_depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x4, y_bot, global_depth, 0.0, 0.0);
+        /* NB: Repeated last virtex to separate from other tri-strip */
+      } else if (x3 == x4) {
+        /* NB: Repeated first virtex to separate from other tri-strip */
+        stash_vertex (contour, &vertex_comp, x1, y_top, global_depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x1, y_top, global_depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x2, y_top, global_depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x3, y_bot, global_depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x3, y_bot, global_depth, 0.0, 0.0);
+        /* NB: Repeated last virtex to separate from other tri-strip */
+      } else {
+        /* NB: Repeated first virtex to separate from other tri-strip */
+        stash_vertex (contour, &vertex_comp, x2, y_top, global_depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x2, y_top, global_depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x3, y_bot, global_depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x1, y_top, global_depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x4, y_bot, global_depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x4, y_bot, global_depth, 0.0, 0.0);
+        /* NB: Repeated last virtex to separate from other tri-strip */
+      }
+    }
+
+    _cairo_traps_fini (&traps);
+  }
+
+  if (contour->tristrip_num_vertices == 0)
+    return;
+
+  hidgl_ensure_vertex_space (&buffer, contour->tristrip_num_vertices);
+
+#if MEMCPY_VERTEX_DATA
+  memcpy (&buffer.triangle_array[buffer.coord_comp_count],
+          contour->tristrip_vertices,
+          sizeof (float) * 5 * contour->tristrip_num_vertices);
+  buffer.coord_comp_count += 5 * contour->tristrip_num_vertices;
+  buffer.vertex_count += contour->tristrip_num_vertices;
+
+#else
+  vertex_comp = 0;
+  for (i = 0; i < contour->tristrip_num_vertices; i++) {
+    int x, y;
+    x = contour->tristrip_vertices[vertex_comp++];
+    y = contour->tristrip_vertices[vertex_comp++];
+    hidgl_add_vertex_tex (&buffer, x, y, 0.0, 0.0);
+  }
+#endif
+
+}
 
 static int
 do_hole (const BoxType *b, void *cl)
 {
-  struct do_hole_info *info = cl;
   PLINE *curc = (PLINE *) b;
-  cairo_traps_t traps;
 
   /* Ignore the outer contour - we draw it first explicitly*/
   if (curc->Flags.orient == PLF_DIR) {
     return 0;
   }
 
-  /* If the contour is round, and hidgl_fill_circle would use
-   * less slices than we have vertices to draw it, then call
-   * hidgl_fill_circle to draw this contour.
-   */
-  if (curc->is_round) {
-    double slices = calc_slices (curc->radius / info->scale, 2 * M_PI);
-    if (slices < curc->Count) {
-      hidgl_fill_circle (curc->cx, curc->cy, curc->radius, info->scale);
-      return 1;
-    }
-  }
-
-  _cairo_traps_init (&traps);
-  bo_contour_to_traps (curc, &traps);
-  _cairo_traps_fini (&traps);
-
+  fill_contour (curc);
   return 1;
 }
 
@@ -654,15 +848,11 @@ static int assigned_bits = 0;
 
 /* FIXME: JUST DRAWS THE FIRST PIECE.. TODO: SUPPORT FOR FULLPOLY POLYGONS */
 void
-hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale)
+hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box)
 {
-  struct do_hole_info info;
   int stencil_bit;
-  cairo_traps_t traps;
 
   CHECK_IS_IN_CONTEXT ();
-  info.scale = scale;
-  global_scale = scale;
 
   if (poly->Clipped == NULL)
     {
@@ -692,7 +882,7 @@ hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale
    */
   /* Drawing operations now set our reference bit in the stencil buffer */
 
-  r_search (poly->Clipped->contour_tree, clip_box, NULL, do_hole, &info);
+  r_search (poly->Clipped->contour_tree, clip_box, NULL, do_hole, NULL);
   hidgl_flush_triangles (&buffer);
 
   /* Drawing operations as masked to areas where the stencil buffer is '0' */
@@ -708,9 +898,7 @@ hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale
                                                               // any bits permitted by the stencil writemask
 
   /* Draw the polygon outer */
-  _cairo_traps_init (&traps);
-  bo_contour_to_traps (poly->Clipped->contours, &traps);
-  _cairo_traps_fini (&traps);
+  fill_contour (poly->Clipped->contours);
   hidgl_flush_triangles (&buffer);
 
   /* Unassign our stencil buffer bit */
@@ -723,14 +911,44 @@ void
 hidgl_fill_rect (int x1, int y1, int x2, int y2)
 {
   CHECK_IS_IN_CONTEXT ();
-  hidgl_ensure_triangle_space (&buffer, 2);
-  hidgl_add_triangle (&buffer, x1, y1, x1, y2, x2, y2);
-  hidgl_add_triangle (&buffer, x2, y1, x2, y2, x1, y1);
+  hidgl_ensure_vertex_space (&buffer, 6);
+
+  /* NB: Repeated first virtex to separate from other tri-strip */
+  hidgl_add_vertex_tex (&buffer, x1, y1, 0.0, 0.0);
+  hidgl_add_vertex_tex (&buffer, x1, y1, 0.0, 0.0);
+  hidgl_add_vertex_tex (&buffer, x1, y2, 0.0, 0.0);
+  hidgl_add_vertex_tex (&buffer, x2, y1, 0.0, 0.0);
+  hidgl_add_vertex_tex (&buffer, x2, y2, 0.0, 0.0);
+  hidgl_add_vertex_tex (&buffer, x2, y2, 0.0, 0.0);
+  /* NB: Repeated last virtex to separate from other tri-strip */
+}
+
+static void
+load_built_in_shaders (void)
+{
+  char *circular_fs_source =
+          "void main()\n"
+          "{\n"
+          "  float sqdist;\n"
+          "  sqdist = dot (gl_TexCoord[0].st, gl_TexCoord[0].st);\n"
+          "  if (sqdist > 1.0)\n"
+          "    discard;\n"
+          "  gl_FragColor = gl_Color;\n"
+          "}\n";
+
+  circular_program = hidgl_shader_new ("circular_rendering", NULL, circular_fs_source);
+
+  hidgl_shader_activate (circular_program);
 }
 
 void
 hidgl_init (void)
 {
+  static bool done_once = false;
+
+  if (done_once)
+    return;
+
   CHECK_IS_IN_CONTEXT ();
   glGetIntegerv (GL_STENCIL_BITS, &stencil_bits);
 
@@ -746,6 +964,16 @@ hidgl_init (void)
               "Cannot use stencil buffer to sub-composite layers.\n");
       /* Do we need to disable that somewhere? */
     }
+
+  if (!hidgl_shader_init_shaders ()) {
+    printf ("Failed to initialise shader support\n");
+    goto done;
+  }
+
+  load_built_in_shaders ();
+
+done:
+  done_once = true;
 }
 
 int
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index 1ed8eb3..c6bc7de 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -23,37 +23,93 @@
 #ifndef __HIDGL_INCLUDED__
 #define __HIDGL_INCLUDED__
 
-#define TRIANGLE_ARRAY_SIZE 5461
+#include "hidgl_shaders.h"
+
+#define TRIANGLE_ARRAY_SIZE 30000
 typedef struct {
-  GLfloat triangle_array [3 * 3 * TRIANGLE_ARRAY_SIZE];
+  GLfloat *triangle_array;
   unsigned int triangle_count;
   unsigned int coord_comp_count;
+  unsigned int vertex_count;
+  unsigned int total_triangles;
+  unsigned int total_vertices;
+  GLuint vbo_id;
+  bool use_vbo;
+  bool use_map;
 } triangle_buffer;
 
 extern triangle_buffer buffer;
 extern float global_depth;
 
+extern hidgl_shader *circular_program;
+
 void hidgl_in_context (bool is_in_context);
 void hidgl_init_triangle_array (triangle_buffer *buffer);
+void hidgl_finish_triangle_array (triangle_buffer *buffer);
 void hidgl_flush_triangles (triangle_buffer *buffer);
+void hidgl_ensure_vertex_space (triangle_buffer *buffer, int count);
 void hidgl_ensure_triangle_space (triangle_buffer *buffer, int count);
 
+inline void
+hidgl_add_vertex_3D_tex (triangle_buffer *buffer,
+                         GLfloat x, GLfloat y, GLfloat z,
+                         GLfloat s, GLfloat t)
+{
+  buffer->triangle_array [buffer->coord_comp_count++] = x;
+  buffer->triangle_array [buffer->coord_comp_count++] = y;
+  buffer->triangle_array [buffer->coord_comp_count++] = z;
+  buffer->triangle_array [buffer->coord_comp_count++] = s;
+  buffer->triangle_array [buffer->coord_comp_count++] = t;
+  buffer->vertex_count++;
+  buffer->total_vertices++;
+}
+
+inline void
+hidgl_add_vertex_tex (triangle_buffer *buffer,
+                      GLfloat x, GLfloat y,
+                      GLfloat s, GLfloat t)
+{
+  hidgl_add_vertex_3D_tex (buffer, x, y, global_depth, s, t);
+}
+
+
+static inline void
+hidgl_add_triangle_3D_tex (triangle_buffer *buffer,
+                           GLfloat x1, GLfloat y1, GLfloat z1, GLfloat s1, GLfloat t1,
+                           GLfloat x2, GLfloat y2, GLfloat z2, GLfloat s2, GLfloat t2,
+                           GLfloat x3, GLfloat y3, GLfloat z3, GLfloat s3, GLfloat t3)
+{
+  /* NB: Repeated first virtex to separate from other tri-strip */
+  hidgl_add_vertex_3D_tex (buffer, x1, y1, z1, s1, t1);
+  hidgl_add_vertex_3D_tex (buffer, x1, y1, z1, s1, t1);
+  hidgl_add_vertex_3D_tex (buffer, x2, y2, z2, s2, t2);
+  hidgl_add_vertex_3D_tex (buffer, x3, y3, z3, s3, t3);
+  hidgl_add_vertex_3D_tex (buffer, x3, y3, z3, s3, t3);
+  /* NB: Repeated last virtex to separate from other tri-strip */
+  buffer->triangle_count++;
+  buffer->total_triangles++;
+}
+
 static inline void
 hidgl_add_triangle_3D (triangle_buffer *buffer,
                        GLfloat x1, GLfloat y1, GLfloat z1,
                        GLfloat x2, GLfloat y2, GLfloat z2,
                        GLfloat x3, GLfloat y3, GLfloat z3)
 {
-  buffer->triangle_array [buffer->coord_comp_count++] = x1;
-  buffer->triangle_array [buffer->coord_comp_count++] = y1;
-  buffer->triangle_array [buffer->coord_comp_count++] = z1;
-  buffer->triangle_array [buffer->coord_comp_count++] = x2;
-  buffer->triangle_array [buffer->coord_comp_count++] = y2;
-  buffer->triangle_array [buffer->coord_comp_count++] = z2;
-  buffer->triangle_array [buffer->coord_comp_count++] = x3;
-  buffer->triangle_array [buffer->coord_comp_count++] = y3;
-  buffer->triangle_array [buffer->coord_comp_count++] = z3;
-  buffer->triangle_count++;
+  hidgl_add_triangle_3D_tex (buffer, x1, y1, z1, 0., 0.,
+                                     x2, y2, z2, 0., 0.,
+                                     x3, y3, z3, 0., 0.);
+}
+
+static inline void
+hidgl_add_triangle_tex (triangle_buffer *buffer,
+                        GLfloat x1, GLfloat y1, GLfloat s1, GLfloat t1,
+                        GLfloat x2, GLfloat y2, GLfloat s2, GLfloat t2,
+                        GLfloat x3, GLfloat y3, GLfloat s3, GLfloat t3)
+{
+  hidgl_add_triangle_3D_tex (buffer, x1, y1, global_depth, s1, t1,
+                                     x2, y2, global_depth, s2, t2,
+                                     x3, y3, global_depth, s3, t3);
 }
 
 static inline void
@@ -71,9 +127,9 @@ hidgl_add_triangle (triangle_buffer *buffer,
 void hidgl_draw_line (int cap, double width, int x1, int y1, int x2, int y2, double scale);
 void hidgl_draw_arc (double width, int vx, int vy, int vrx, int vry, int start_angle, int delta_angle, double scale);
 void hidgl_draw_rect (int x1, int y1, int x2, int y2);
-void hidgl_fill_circle (int vx, int vy, int vr, double scale);
+void hidgl_fill_circle (int vx, int vy, int vr);
 void hidgl_fill_polygon (int n_coords, int *x, int *y);
-void hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale);
+void hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box);
 void hidgl_fill_rect (int x1, int y1, int x2, int y2);
 
 void hidgl_init (void);
diff --git a/src/hid/common/hidgl_shaders.c b/src/hid/common/hidgl_shaders.c
new file mode 100644
index 0000000..8609afe
--- /dev/null
+++ b/src/hid/common/hidgl_shaders.c
@@ -0,0 +1,165 @@
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 2010 PCB Contributors (See ChangeLog for details).
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdbool.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+
+/* The Linux OpenGL ABI 1.0 spec requires that we define
+ * GL_GLEXT_PROTOTYPES before including gl.h or glx.h for extensions
+ * in order to get prototypes:
+ *   http://www.opengl.org/registry/ABI/
+ */
+#define GL_GLEXT_PROTOTYPES 1
+#include <GL/gl.h>
+#include <GL/glu.h>
+#include "hidgl_shaders.h"
+
+#ifdef HAVE_LIBDMALLOC
+#include <dmalloc.h>
+#endif
+
+/* Opaque data-structure keeping a shader object */
+struct _hidgl_shader {
+  char *name;
+  GLuint program;
+  GLuint vs;
+  GLuint fs;
+};
+
+bool
+hidgl_shader_init_shaders (void)
+{
+  /* XXX: Check for required functionality in the GL driver */
+  return true;
+}
+
+/* From http://gpwiki.org/index.php/OpenGL:Codes:Simple_GLSL_example */
+static void
+print_log (GLuint obj)
+{
+  int infologLength = 0;
+  int maxLength;
+  char *infoLog;
+
+  if (glIsShader (obj))
+    glGetShaderiv (obj, GL_INFO_LOG_LENGTH, &maxLength);
+  else
+    glGetProgramiv (obj, GL_INFO_LOG_LENGTH, &maxLength);
+
+  infoLog = malloc (maxLength);
+
+  if (glIsShader (obj))
+    glGetShaderInfoLog (obj, maxLength, &infologLength, infoLog);
+  else
+    glGetProgramInfoLog (obj, maxLength, &infologLength, infoLog);
+
+  if (infologLength > 0)
+    printf ("%s\n", infoLog);
+
+  free (infoLog);
+}
+
+
+/* If either vs or fs is NULL, used the fixed function pipeline for that */
+hidgl_shader *
+hidgl_shader_new (char *name, char *vs_source, char *fs_source)
+{
+  hidgl_shader *shader;
+  const char *source;
+  int source_len;
+
+  shader = malloc (sizeof (hidgl_shader));
+
+  if (shader == NULL)
+    return NULL;
+
+  shader->name = strdup (name);
+  shader->program = 0;
+  shader->vs = 0;
+  shader->fs = 0;
+
+  if (fs_source == NULL && vs_source == NULL)
+    return shader;
+
+  shader->program = glCreateProgram ();
+
+  if (vs_source != NULL) {
+    source = vs_source;
+    source_len = -1; /* The string is '\0' terminated */
+    shader->vs = glCreateShader (GL_VERTEX_SHADER);
+    glShaderSource (shader->vs, 1, &source, &source_len);
+    glCompileShader (shader->vs);
+    print_log (shader->vs);
+    glAttachShader (shader->program, shader->vs);
+  }
+
+  if (fs_source != NULL) {
+    source = fs_source;
+    source_len = -1; /* The string is '\0' terminated */
+    shader->fs = glCreateShader (GL_FRAGMENT_SHADER);
+    glShaderSource (shader->fs, 1, &source, &source_len);
+    glCompileShader (shader->fs);
+    print_log (shader->fs);
+    glAttachShader (shader->program, shader->fs);
+  }
+
+  glLinkProgram (shader->program);
+  print_log (shader->program);
+  return shader;
+}
+
+
+GLuint
+hidgl_shader_get_program (hidgl_shader *shader)
+{
+  return shader->program;
+}
+
+
+/* Delete the passed shader. */
+void
+hidgl_shader_free (hidgl_shader *shader)
+{
+  /* NB: These calls all silently ignore 0 or NULL arguments */
+  glDeleteShader (shader->vs);
+  glDeleteShader (shader->fs);
+  glDeleteProgram (shader->program);
+  free (shader->name);
+  free (shader);
+}
+
+
+/* Activate the given shader program, or deactivate if NULL passed */
+void
+hidgl_shader_activate (hidgl_shader *shader)
+{
+  if (shader == NULL)
+    glUseProgram (0);
+  else
+    glUseProgram (shader->program);
+}
diff --git a/src/hid/common/hidgl_shaders.h b/src/hid/common/hidgl_shaders.h
new file mode 100644
index 0000000..9812b4b
--- /dev/null
+++ b/src/hid/common/hidgl_shaders.h
@@ -0,0 +1,35 @@
+/*
+ *                            COPYRIGHT
+ *
+ *  PCB, interactive printed circuit board design
+ *  Copyright (C) 2010 PCB Contributors (See ChangeLog for details).
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifndef __HIDGL_SHADERS_INCLUDED__
+#define __HIDGL_SHADERS_INCLUDED__
+
+typedef struct _hidgl_shader hidgl_shader;
+
+bool hidgl_shader_init_shaders (void);
+
+hidgl_shader *hidgl_shader_new (char *name, char *vs_source, char *fs_source);
+GLuint hidgl_shader_get_program (hidgl_shader *shader);
+void hidgl_shader_free (hidgl_shader *shader);
+void hidgl_shader_activate (hidgl_shader *shader);
+
+#endif /* __HIDGL_SHADERS_INCLUDED__  */
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 453ddd0..fdfb2a9 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -32,6 +32,8 @@
 #include <dmalloc.h>
 #endif
 
+#undef ONE_SHOT
+//#define ONE_SHOT
 
 RCSID ("$Id$");
 
@@ -711,7 +713,7 @@ ghid_fill_circle (hidGC gc, int cx, int cy, int radius)
 {
   USE_GC (gc);
 
-  hidgl_fill_circle (cx, cy, radius, gport->zoom);
+  hidgl_fill_circle (cx, cy, radius);
 }
 
 
@@ -728,7 +730,7 @@ ghid_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
 {
   USE_GC (gc);
 
-  hidgl_fill_pcb_polygon (poly, clip_box, gport->zoom);
+  hidgl_fill_pcb_polygon (poly, clip_box);
 }
 
 void
@@ -1098,7 +1100,7 @@ EMark_callback (const BoxType * b, void *cl)
 {
   ElementTypePtr element = (ElementTypePtr) b;
 
-  DrawEMark (element, element->MarkX, element->MarkY, !FRONT (element));
+//  DrawEMark (element, element->MarkX, element->MarkY, !FRONT (element));
   return 1;
 }
 
@@ -1537,9 +1539,7 @@ DrawDrillChannel (int vx, int vy, int vr, int from_layer, int to_layer, double s
 #define MIN_FACES_PER_CYL 6
 #define MAX_FACES_PER_CYL 360
   float radius = vr;
-  float x1, y1;
-  float x2, y2;
-  float z1, z2;
+  float x, y, z1, z2;
   int i;
   int slices;
 
@@ -1554,19 +1554,27 @@ DrawDrillChannel (int vx, int vy, int vr, int from_layer, int to_layer, double s
   z1 = compute_depth (from_layer);
   z2 = compute_depth (to_layer);
 
-  x1 = vx + vr;
-  y1 = vy;
+  x = vx + vr;
+  y = vy;
+
+  hidgl_ensure_vertex_space (&buffer, 2 * slices + 2 + 2);
+
+  /* NB: Repeated first virtex to separate from other tri-strip */
+  hidgl_add_vertex_3D_tex (&buffer, x, y, z1, 0.0, 0.0);
+  hidgl_add_vertex_3D_tex (&buffer, x, y, z1, 0.0, 0.0);
+  hidgl_add_vertex_3D_tex (&buffer, x, y, z2, 0.0, 0.0);
 
-  hidgl_ensure_triangle_space (&buffer, 2 * slices);
   for (i = 0; i < slices; i++)
     {
-      x2 = radius * cosf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vx;
-      y2 = radius * sinf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vy;
-      hidgl_add_triangle_3D (&buffer, x1, y1, z1,  x2, y2, z1,  x1, y1, z2);
-      hidgl_add_triangle_3D (&buffer, x2, y2, z1,  x1, y1, z2,  x2, y2, z2);
-      x1 = x2;
-      y1 = y2;
+      x = radius * cosf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vx;
+      y = radius * sinf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vy;
+
+      hidgl_add_vertex_3D_tex (&buffer, x, y, z1, 0.0, 0.0);
+      hidgl_add_vertex_3D_tex (&buffer, x, y, z2, 0.0, 0.0);
     }
+
+  /* NB: Repeated last virtex to separate from other tri-strip */
+  hidgl_add_vertex_3D_tex (&buffer, x, y, z2, 0.0, 0.0);
 }
 
 struct cyl_info {
@@ -1809,16 +1817,20 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
                              GdkEventExpose *ev,
                              GHidPort *port)
 {
+#ifdef ONE_SHOT
   static int one_shot = 1;
   static int display_list;
+#endif
   BoxType region;
-  int eleft, eright, etop, ebottom;
   int min_x, min_y;
   int max_x, max_y;
   int new_x, new_y;
   int min_depth;
   int max_depth;
 
+  buffer.total_triangles = 0;
+  buffer.total_vertices = 0;
+
   ghid_start_drawing (port);
 
   hidgl_in_context (true);
@@ -1864,7 +1876,7 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
                              -port->view_y0, 0);
   glGetFloatv (GL_MODELVIEW_MATRIX, (GLfloat *)last_modelview_matrix);
 
-#if 0
+#ifdef ONE_SHOT
   if (one_shot) {
 
     display_list = glGenLists(1);
@@ -1990,7 +2002,6 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
     glEnd ();
   }
 
-
   // hid_expose_callback (&ghid_hid, &region, 0);
   ghid_draw_everything (&region);
   hidgl_flush_triangles (&buffer);
@@ -2000,29 +2011,31 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   hidgl_set_depth (compute_depth (GetLayerGroupNumberByNumber (INDEXOFCURRENT)));
   ghid_draw_grid (&region);
 
-  hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
   DrawAttached (TRUE);
   DrawMark (TRUE);
   hidgl_flush_triangles (&buffer);
 
-#if 0
+#ifdef ONE_SHOT
     glEndList ();
     one_shot = 0;
-  } else {
-    /* Second and subsequent times */
-    glCallList (display_list);
   }
+
+  glCallList (display_list);
 #endif
 
   ghid_show_crosshair (TRUE);
 
   hidgl_flush_triangles (&buffer);
+  hidgl_finish_triangle_array (&buffer);
 
   check_gl_drawing_ok_hack = false;
   hidgl_in_context (false);
   ghid_end_drawing (port);
 
+//  printf ("Triangle count was %i\n", buffer.total_triangles);
+//  printf ("Vertex count was %i\n", buffer.total_vertices);
+
   return FALSE;
 }
 
@@ -2112,7 +2125,6 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   glStencilMask (~0);
   glClearStencil (0);
   glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
-
   hidgl_reset_stencil_usage ();
 
   /* call the drawing routine */
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index e5418af..1a14478 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -1604,7 +1604,8 @@ Benchmark (int argc, char **argv, int x, int y)
     {
       gdk_window_invalidate_rect (gport->drawing_area->window, NULL, 1);
       gdk_window_process_updates (gport->drawing_area->window, FALSE);
-      gdk_display_sync (display);
+//      gdk_display_sync (display);
+//      usleep (100000);
       time (&end);
       i++;
     }
diff --git a/src/hid/gtk/snavi.c b/src/hid/gtk/snavi.c
index 618be32..7d3f961 100644
--- a/src/hid/gtk/snavi.c
+++ b/src/hid/gtk/snavi.c
@@ -51,16 +51,20 @@ int snavi_set_led (GIOChannel *snavi, int led_state)
   GError      *error = NULL;
   gsize        bytes_written;
 
+  event.time.tv_sec = 0;
+  event.time.tv_usec = 0;
   event.type  = EV_LED;
   event.code  = LED_MISC;
   event.value = led_state;
 
+#if 0
   g_io_channel_seek_position (snavi, 0, G_SEEK_END, &error);
   if (error) {
     g_printerr ("Error: %s\n", error->message);
     /* FIXME: FREE THE ERROR??? */
     return FALSE;
   }
+#endif
 
   g_io_channel_write_chars (snavi,
                             (gchar *) &event,
@@ -74,6 +78,7 @@ int snavi_set_led (GIOChannel *snavi, int led_state)
     return FALSE;
   }
 
+#if 0
   g_io_channel_flush (snavi, &error);
 
   if (error) {
@@ -81,6 +86,7 @@ int snavi_set_led (GIOChannel *snavi, int led_state)
     /* FIXME: FREE THE ERROR??? */
     return FALSE;
   }
+#endif
 
   return bytes_written < sizeof (struct input_event);
 }
@@ -114,6 +120,12 @@ gboolean snavi_event (GIOChannel   *source,
 
   switch (event.type)
     {
+      case EV_ABS:
+        if (event.code <= ABS_RZ)
+          axes[event.code - ABS_X] = event.value;
+        break;
+
+        /* I'm not sure, but previously the SpaceNavigator reported as relative events */
       case EV_REL:
         if (event.code <= REL_RZ)
           axes[event.code - REL_X] = event.value;
@@ -140,12 +152,12 @@ gboolean snavi_event (GIOChannel   *source,
             axes[i] = 0;
         }
 
-        update_pan_cb (axes[0] / 100.0,
-                       axes[2] / 100.0,
-                       axes[1] / 100.0, cb_userdata);
-        update_roll_cb (axes[5] / 100.0,
-                        axes[3] / 100.0,
-                        axes[4] / 100.0, cb_userdata);
+        update_pan_cb (axes[0] / 70.0,
+                       axes[2] / 70.0,
+                       axes[1] / 70.0, cb_userdata);
+        update_roll_cb (axes[5] / 60.0,
+                        axes[3] / 60.0,
+                        axes[4] / 60.0, cb_userdata);
         update_done_cb (cb_userdata);
 
         axes[0] = axes[1] = axes[2] = axes[3] = axes[4] = axes[5] = 0;
@@ -175,11 +187,22 @@ setup_snavi (void (*update_pan)(int, int, int, gpointer),
   update_done_cb = update_done;
   button_cb = button;
   cb_userdata = data;
+#if 0
+  int fd;
+  int grab = 1;
 
+  fd = open("/dev/input/spacenavigator", O_RDWR);
+  ioctl (fd, EVIOCGRAB, &grab);
+
+  snavi = g_io_channel_unix_new (fd);
+#else
   snavi = g_io_channel_new_file ("/dev/input/spacenavigator", "r+", NULL);
+#endif
+
   if (snavi)
     {
       g_io_channel_set_encoding (snavi, NULL, NULL);
+      g_io_channel_set_buffered (snavi, FALSE);
       event_id = g_io_add_watch (snavi, G_IO_IN, snavi_event, NULL);
     }
 
diff --git a/src/polyarea.h b/src/polyarea.h
index ce427ad..62a1125 100644
--- a/src/polyarea.h
+++ b/src/polyarea.h
@@ -107,6 +107,8 @@ struct PLINE
       unsigned int status:3;
       unsigned int orient:1;
     } Flags;
+    int tristrip_num_vertices;
+    float *tristrip_vertices;
 };
 
 PLINE *poly_NewContour(Vector v);
diff --git a/src/polygon1.c b/src/polygon1.c
index 468c139..5419863 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -2553,6 +2553,9 @@ poly_ClrContour (PLINE * c)
       poly_ExclVertex (cur);
       free (cur);
     }
+  free (c->tristrip_vertices);
+  c->tristrip_vertices = NULL;
+  c->tristrip_num_vertices = 0;
   poly_IniContour (c);
 }
 
@@ -2584,6 +2587,7 @@ poly_DelContour (PLINE ** c)
       rtree_t *r = (*c)->tree;
       r_destroy_tree (&r);
     }
+  free ((*c)->tristrip_vertices);
   free (*c), *c = NULL;
 }
 
diff --git a/src/sweep.h b/src/sweep.h
index 257664f..92fdd71 100644
--- a/src/sweep.h
+++ b/src/sweep.h
@@ -2,3 +2,5 @@
 
 cairo_status_t bo_poly_to_traps (POLYAREA *poly, cairo_traps_t *traps);
 cairo_status_t bo_contour_to_traps (PLINE *contour, cairo_traps_t *traps);
+cairo_status_t bo_contour_to_traps_no_draw (PLINE *contour, cairo_traps_t *traps);
+cairo_fixed_t _line_compute_intersection_x_for_y (const cairo_line_t *line, cairo_fixed_t y);

Bottom: 7b871169cacfbe3939c3bf4f9b17351af8113b47
Top:    294ca3f6b98aea6df8aa88e4a8e86adbe30e523b
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2010-10-24 19:02:53 +0100

Play with GLSL shader for rendering line caps and circles

And of course.. typically, a million other little fixes:

 - Primitive rendering object changed from GL_TRIANGLES to GL_TRIANGLE_STRIP
 - Rendering using mapped VBOs rather than just arrays
 - Updated layer depth code, so we render with "z" in world coordinates
 - Space navigator joystick support fixes against later kernels

Bugs:
 - Layer depths will be wrong for reversed layer group numbering
 - Pixel shader ought to be switched off for polygon fill?
 - hidgl_draw_rect stubbed out for now (for benchmarking)


---

diff --git a/src/cairo/cairo-bentley-ottmann.c b/src/cairo/cairo-bentley-ottmann.c
index fcc0e66..9c9d43e 100644
--- a/src/cairo/cairo-bentley-ottmann.c
+++ b/src/cairo/cairo-bentley-ottmann.c
@@ -126,7 +126,7 @@ typedef struct _cairo_bo_sweep_line {
 } cairo_bo_sweep_line_t;
 
 
-static cairo_fixed_t
+/*static*/ cairo_fixed_t
 _line_compute_intersection_x_for_y (const cairo_line_t *line,
                                     cairo_fixed_t y)
 {
@@ -1451,9 +1451,21 @@ bo_poly_to_traps (POLYAREA *poly, cairo_traps_t *traps)
       hidgl_ensure_triangle_space (&buffer, 1);
       hidgl_add_triangle (&buffer, x1, y1, x2, y2, x3, y3);
     } else {
+#if 0
       hidgl_ensure_triangle_space (&buffer, 2);
       hidgl_add_triangle (&buffer, x1, y1, x2, y2, x3, y3);
       hidgl_add_triangle (&buffer, x3, y3, x4, y4, x1, y1);
+#endif
+      hidgl_ensure_vertex_space (&buffer, 6);
+
+      /* NB: Repeated first virtex to separate from other tri-strip */
+      hidgl_add_vertex_tex (&buffer, x2, y2, 0.0, 0.0);
+      hidgl_add_vertex_tex (&buffer, x2, y2, 0.0, 0.0);
+      hidgl_add_vertex_tex (&buffer, x1, y1, 0.0, 0.0);
+      hidgl_add_vertex_tex (&buffer, x3, y3, 0.0, 0.0);
+      hidgl_add_vertex_tex (&buffer, x4, y4, 0.0, 0.0);
+      hidgl_add_vertex_tex (&buffer, x4, y4, 0.0, 0.0);
+      /* NB: Repeated last virtex to separate from other tri-strip */
     }
 #else
     glBegin (GL_LINES);
@@ -1477,7 +1489,6 @@ bo_poly_to_traps (POLYAREA *poly, cairo_traps_t *traps)
   return CAIRO_STATUS_SUCCESS;
 }
 
-
 cairo_status_t
 bo_contour_to_traps (PLINE *contour, cairo_traps_t *traps)
 {
@@ -1567,3 +1578,57 @@ bo_contour_to_traps (PLINE *contour, cairo_traps_t *traps)
 
   return CAIRO_STATUS_SUCCESS;
 }
+
+
+cairo_status_t
+bo_contour_to_traps_no_draw (PLINE *contour, cairo_traps_t *traps)
+{
+  int intersections;
+  cairo_status_t status;
+  cairo_bo_start_event_t stack_events[CAIRO_STACK_ARRAY_LENGTH (cairo_bo_start_event_t)];
+  cairo_bo_start_event_t *events;
+  cairo_bo_event_t *stack_event_ptrs[ARRAY_LENGTH (stack_events) + 1];
+  cairo_bo_event_t **event_ptrs;
+  int num_events = 0;
+  int i;
+
+  num_events = contour->Count;
+
+  if (unlikely (0 == num_events))
+      return CAIRO_STATUS_SUCCESS;
+
+  events = stack_events;
+  event_ptrs = stack_event_ptrs;
+  if (num_events > ARRAY_LENGTH (stack_events)) {
+      events = _cairo_malloc_ab_plus_c (num_events,
+                                        sizeof (cairo_bo_start_event_t) +
+                                        sizeof (cairo_bo_event_t *),
+                                        sizeof (cairo_bo_event_t *));
+      if (unlikely (events == NULL))
+          return CAIRO_STATUS_NO_MEMORY;
+
+      event_ptrs = (cairo_bo_event_t **) (events + num_events);
+  }
+
+  i = 0;
+
+  contour_to_start_events (contour, events, event_ptrs, &i, 1);
+
+  /* XXX: This would be the convenient place to throw in multiple
+   * passes of the Bentley-Ottmann algorithm. It would merely
+   * require storing the results of each pass into a temporary
+   * cairo_traps_t. */
+  status = _cairo_bentley_ottmann_tessellate_bo_edges (event_ptrs,
+                                                       num_events,
+                                                       traps,
+                                                       &intersections);
+
+#if DEBUG_TRAPS
+  dump_traps (traps, "bo-polygon-out.txt");
+#endif
+
+  if (events != stack_events)
+      free (events);
+
+  return CAIRO_STATUS_SUCCESS;
+}
diff --git a/src/hid/common/hidgl.c b/src/hid/common/hidgl.c
index 238e61d..1771b93 100644
--- a/src/hid/common/hidgl.c
+++ b/src/hid/common/hidgl.c
@@ -75,43 +75,113 @@ hidgl_new_triangle_array (void)
 }
 #endif
 
+#define NUM_BUF_GLFLOATS (3 * (3 + 2) * TRIANGLE_ARRAY_SIZE)
+
+
+/* NB: Caller must ensure the desired GL_ARRAY_BUFFER is bound */
+static void
+hidgl_reset_triangle_array (triangle_buffer *buffer)
+{
+  if (!buffer->local) {
+    /* Map some new memory to upload vertices into. */
+    glBufferData (GL_ARRAY_BUFFER, NUM_BUF_GLFLOATS * sizeof (GLfloat), NULL, GL_STREAM_DRAW);
+    buffer->triangle_array = glMapBuffer (GL_ARRAY_BUFFER, GL_WRITE_ONLY);
+  }
+
+  /* If using VBOs fails, fall back to an allocated array */
+  if (buffer->triangle_array == NULL) {
+    buffer->triangle_array = malloc (NUM_BUF_GLFLOATS * sizeof (GLfloat));
+    buffer->local = true;
+  }
+
+  /* Don't want this bound for now */
+  glBindBuffer (GL_ARRAY_BUFFER, 0);
+
+  buffer->triangle_count = 0;
+  buffer->coord_comp_count = 0;
+  buffer->vertex_count = 0;
+}
+
 void
 hidgl_init_triangle_array (triangle_buffer *buffer)
 {
   CHECK_IS_IN_CONTEXT ();
-  glEnableClientState (GL_VERTEX_ARRAY);
-  glVertexPointer (3, GL_FLOAT, 0, buffer->triangle_array);
-  buffer->triangle_count = 0;
-  buffer->coord_comp_count = 0;
+
+  glGenBuffers (1, &buffer->vbo_id);
+  glBindBuffer (GL_ARRAY_BUFFER, buffer->vbo_id);
+
+  buffer->local = false;
+  hidgl_reset_triangle_array (buffer);
 }
 
 void
+hidgl_finish_triangle_array (triangle_buffer *buffer)
+{
+  if (buffer->local) {
+    free (buffer->triangle_array);
+  } else {
+    glUnmapBuffer (GL_ARRAY_BUFFER);
+  }
+  glBindBuffer (GL_ARRAY_BUFFER, 0);
+
+  glDeleteBuffers (1, &buffer->vbo_id);
+  buffer->vbo_id = 0;
+}
+
+#define BUF_OFFSET(x) (&((GLfloat *)NULL)[x])
+
+void
 hidgl_flush_triangles (triangle_buffer *buffer)
 {
   CHECK_IS_IN_CONTEXT ();
-  if (buffer->triangle_count == 0)
+  if (buffer->vertex_count == 0)
     return;
 
-  glDrawArrays (GL_TRIANGLES, 0, buffer->triangle_count * 3);
-  buffer->triangle_count = 0;
-  buffer->coord_comp_count = 0;
+  if (!buffer->local) {
+    glUnmapBuffer (GL_ARRAY_BUFFER);
+    buffer->triangle_array = NULL;
+  }
+
+  glBindBuffer (GL_ARRAY_BUFFER, buffer->vbo_id);
+
+  glEnableClientState (GL_VERTEX_ARRAY);
+  glVertexPointer (3, GL_FLOAT, 5 * sizeof (GLfloat), buffer->local ?
+                     buffer->triangle_array : BUF_OFFSET (0));
+
+  glEnableClientState (GL_TEXTURE_COORD_ARRAY);
+  glTexCoordPointer (2, GL_FLOAT, 5 * sizeof (GLfloat), buffer->local ?
+                       buffer->triangle_array + 3 : BUF_OFFSET (3));
+
+  glDrawArrays (GL_TRIANGLE_STRIP, 0, buffer->vertex_count);
+  glDisableClientState (GL_VERTEX_ARRAY);
+  glDisableClientState (GL_TEXTURE_COORD_ARRAY);
+
+  hidgl_reset_triangle_array (buffer);
 }
 
 void
-hidgl_ensure_triangle_space (triangle_buffer *buffer, int count)
+hidgl_ensure_vertex_space (triangle_buffer *buffer, int count)
 {
   CHECK_IS_IN_CONTEXT ();
-  if (count > TRIANGLE_ARRAY_SIZE)
+  if (count > 3 * TRIANGLE_ARRAY_SIZE)
     {
       fprintf (stderr, "Not enough space in vertex buffer\n");
-      fprintf (stderr, "Requested %i triangles, %i available\n",
-                       count, TRIANGLE_ARRAY_SIZE);
+      fprintf (stderr, "Requested %i vertices, %i available\n",
+                       count, 3 * TRIANGLE_ARRAY_SIZE);
       exit (1);
     }
-  if (count > TRIANGLE_ARRAY_SIZE - buffer->triangle_count)
+  if (count > 3 * TRIANGLE_ARRAY_SIZE - buffer->vertex_count)
     hidgl_flush_triangles (buffer);
 }
 
+void
+hidgl_ensure_triangle_space (triangle_buffer *buffer, int count)
+{
+  CHECK_IS_IN_CONTEXT ();
+  /* NB: 5 = 3 + 2 extra vertices to separate from other triangle strips */
+  hidgl_ensure_vertex_space (buffer, count * 5);
+}
+
 //static int cur_mask = -1;
 
 
@@ -215,42 +285,34 @@ int calc_slices (float pix_radius, float sweep_angle)
   return (int)ceilf (slices);
 }
 
-#define MIN_TRIANGLES_PER_CAP 3
-#define MAX_TRIANGLES_PER_CAP 90
-static void draw_cap (double width, int x, int y, double angle, double scale)
+static void draw_cap (double width, int x, int y, double angle)
 {
-  float last_capx, last_capy;
-  float capx, capy;
   float radius = width / 2.;
-  int slices = calc_slices (radius / scale, M_PI);
-  int i;
 
   CHECK_IS_IN_CONTEXT ();
-  if (slices < MIN_TRIANGLES_PER_CAP)
-    slices = MIN_TRIANGLES_PER_CAP;
-
-  if (slices > MAX_TRIANGLES_PER_CAP)
-    slices = MAX_TRIANGLES_PER_CAP;
-
-  hidgl_ensure_triangle_space (&buffer, slices);
-
-  last_capx =  radius * cosf (angle * M_PI / 180.) + x;
-  last_capy = -radius * sinf (angle * M_PI / 180.) + y;
-  for (i = 0; i < slices; i++) {
-    capx =  radius * cosf (angle * M_PI / 180. + ((float)(i + 1)) * M_PI / (float)slices) + x;
-    capy = -radius * sinf (angle * M_PI / 180. + ((float)(i + 1)) * M_PI / (float)slices) + y;
-    hidgl_add_triangle (&buffer, last_capx, last_capy, capx, capy, x, y);
-    last_capx = capx;
-    last_capy = capy;
-  }
+
+  hidgl_ensure_vertex_space (&buffer, 6);
+
+  /* FIXME: Should draw an offset rectangle at the appropriate angle,
+   *        avoiding relying on the subcompositing between layers to
+   *        stop us creatign an artaefact by drawing a full circle.
+   */
+  /* NB: Repeated first virtex to separate from other tri-strip */
+  hidgl_add_vertex_tex (&buffer, x - radius, y - radius, -1.0, -1.0);
+  hidgl_add_vertex_tex (&buffer, x - radius, y - radius, -1.0, -1.0);
+  hidgl_add_vertex_tex (&buffer, x - radius, y + radius, -1.0,  1.0);
+  hidgl_add_vertex_tex (&buffer, x + radius, y - radius,  1.0, -1.0);
+  hidgl_add_vertex_tex (&buffer, x + radius, y + radius,  1.0,  1.0);
+  hidgl_add_vertex_tex (&buffer, x + radius, y + radius,  1.0,  1.0);
+  /* NB: Repeated last virtex to separate from other tri-strip */
 }
 
 void
 hidgl_draw_line (int cap, double width, int x1, int y1, int x2, int y2, double scale)
 {
-  double angle;
   float deltax, deltay, length;
   float wdx, wdy;
+  float cosine, sine;
   int circular_caps = 0;
   int hairline = 0;
 
@@ -263,30 +325,20 @@ hidgl_draw_line (int cap, double width, int x1, int y1, int x2, int y2, double s
 
   deltax = x2 - x1;
   deltay = y2 - y1;
-
   length = sqrt (deltax * deltax + deltay * deltay);
 
   if (length == 0) {
     /* Assume the orientation of the line is horizontal */
-    angle = 0;
-    wdx = -width / 2.;
-    wdy = 0;
-    length = 1.;
-    deltax = 1.;
-    deltay = 0.;
+    cosine = 1.0;
+    sine   = 0.0;
   } else {
-    wdy = deltax * width / 2. / length;
-    wdx = -deltay * width / 2. / length;
-
-    if (deltay == 0.)
-      angle = (deltax < 0) ? 270. : 90.;
-    else
-      angle = 180. / M_PI * atanl (deltax / deltay);
-
-    if (deltay < 0)
-      angle += 180.;
+    cosine = deltax / length;
+    sine   = deltay / length;
   }
 
+  wdy =  width / 2. * cosine;
+  wdx = -width / 2. * sine;
+
   switch (cap) {
     case Trace_Cap:
     case Round_Cap:
@@ -295,26 +347,50 @@ hidgl_draw_line (int cap, double width, int x1, int y1, int x2, int y2, double s
 
     case Square_Cap:
     case Beveled_Cap:
-      x1 -= deltax * width / 2. / length;
-      y1 -= deltay * width / 2. / length;
-      x2 += deltax * width / 2. / length;
-      y2 += deltay * width / 2. / length;
+      /* Use wdx and wdy (which already have the correct numbers), just in
+       * case the compiler doesn't spot it can avoid recomputing these. */
+      x1 -= wdy; /* x1 -= width / 2. * cosine;   */
+      y1 += wdx; /* y1 -= width / 2. * sine;     */
+      x2 += wdy; /* x2 += width / 2. * cosine;   */
+      y2 -= wdx; /* y2 += width / 2. / sine;     */
       break;
   }
 
-  hidgl_ensure_triangle_space (&buffer, 2);
-  hidgl_add_triangle (&buffer, x1 - wdx, y1 - wdy,
-                               x2 - wdx, y2 - wdy,
-                               x2 + wdx, y2 + wdy);
-  hidgl_add_triangle (&buffer, x1 - wdx, y1 - wdy,
-                               x2 + wdx, y2 + wdy,
-                               x1 + wdx, y1 + wdy);
-
   /* Don't bother capping hairlines */
   if (circular_caps && !hairline)
     {
-      draw_cap (width, x1, y1, angle, scale);
-      draw_cap (width, x2, y2, angle + 180., scale);
+      float capx = deltax * width / 2. / length;
+      float capy = deltay * width / 2. / length;
+
+      hidgl_ensure_vertex_space (&buffer, 10);
+
+      /* NB: Repeated first virtex to separate from other tri-strip */
+      hidgl_add_vertex_tex (&buffer, x1 - wdx - capx, y1 - wdy - capy, -1.0, -1.0);
+      hidgl_add_vertex_tex (&buffer, x1 - wdx - capx, y1 - wdy - capy, -1.0, -1.0);
+      hidgl_add_vertex_tex (&buffer, x1 + wdx - capx, y1 + wdy - capy, -1.0,  1.0);
+      hidgl_add_vertex_tex (&buffer, x1 - wdx,        y1 - wdy,         0.0, -1.0);
+      hidgl_add_vertex_tex (&buffer, x1 + wdx,        y1 + wdy,         0.0,  1.0);
+
+      hidgl_add_vertex_tex (&buffer, x2 - wdx,        y2 - wdy,         0.0, -1.0);
+      hidgl_add_vertex_tex (&buffer, x2 + wdx,        y2 + wdy,         0.0,  1.0);
+      hidgl_add_vertex_tex (&buffer, x2 - wdx + capx, y2 - wdy + capy,  1.0, -1.0);
+      hidgl_add_vertex_tex (&buffer, x2 + wdx + capx, y2 + wdy + capy,  1.0,  1.0);
+      hidgl_add_vertex_tex (&buffer, x2 + wdx + capx, y2 + wdy + capy,  1.0,  1.0);
+      /* NB: Repeated last virtex to separate from other tri-strip */
+    }
+  else
+    {
+      hidgl_ensure_vertex_space (&buffer, 6);
+
+      /* NB: Repeated first virtex to separate from other tri-strip */
+      hidgl_add_vertex_tex (&buffer, x1 - wdx, y1 - wdy, 0.0, -1.0);
+      hidgl_add_vertex_tex (&buffer, x1 - wdx, y1 - wdy, 0.0, -1.0);
+      hidgl_add_vertex_tex (&buffer, x1 + wdx, y1 + wdy, 0.0,  1.0);
+
+      hidgl_add_vertex_tex (&buffer, x2 - wdx, y2 - wdy, 0.0, -1.0);
+      hidgl_add_vertex_tex (&buffer, x2 + wdx, y2 + wdy, 0.0,  1.0);
+      hidgl_add_vertex_tex (&buffer, x2 + wdx, y2 + wdy, 0.0,  1.0);
+      /* NB: Repeated last virtex to separate from other tri-strip */
     }
 }
 
@@ -393,15 +469,16 @@ hidgl_draw_arc (double width, int x, int y, int rx, int ry,
 
   draw_cap (width, x + rx * -cosf (start_angle_rad),
                    y + rx *  sinf (start_angle_rad),
-                   start_angle, scale);
+                   start_angle);
   draw_cap (width, x + rx * -cosf (start_angle_rad + delta_angle_rad),
                    y + rx *  sinf (start_angle_rad + delta_angle_rad),
-                   start_angle + delta_angle + 180., scale);
+                   start_angle + delta_angle + 180.);
 }
 
 void
 hidgl_draw_rect (int x1, int y1, int x2, int y2)
 {
+  return;
   CHECK_IS_IN_CONTEXT ();
   glBegin (GL_LINE_LOOP);
   glVertex3f (x1, y1, global_depth);
@@ -413,37 +490,20 @@ hidgl_draw_rect (int x1, int y1, int x2, int y2)
 
 
 void
-hidgl_fill_circle (int vx, int vy, int vr, double scale)
+hidgl_fill_circle (int x, int y, int radius)
 {
-#define MIN_TRIANGLES_PER_CIRCLE 6
-#define MAX_TRIANGLES_PER_CIRCLE 360
-  float last_x, last_y;
-  float radius = vr;
-  int slices;
-  int i;
-
   CHECK_IS_IN_CONTEXT ();
-  slices = calc_slices (vr / scale, 2 * M_PI);
-
-  if (slices < MIN_TRIANGLES_PER_CIRCLE)
-    slices = MIN_TRIANGLES_PER_CIRCLE;
-
-  if (slices > MAX_TRIANGLES_PER_CIRCLE)
-    slices = MAX_TRIANGLES_PER_CIRCLE;
 
-  hidgl_ensure_triangle_space (&buffer, slices);
+  hidgl_ensure_vertex_space (&buffer, 6);
 
-  last_x = vx + vr;
-  last_y = vy;
-
-  for (i = 0; i < slices; i++) {
-    float x, y;
-    x = radius * cosf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vx;
-    y = radius * sinf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vy;
-    hidgl_add_triangle (&buffer, vx, vy, last_x, last_y, x, y);
-    last_x = x;
-    last_y = y;
-  }
+  /* NB: Repeated first virtex to separate from other tri-strip */
+  hidgl_add_vertex_tex (&buffer, x - radius, y - radius, -1.0, -1.0);
+  hidgl_add_vertex_tex (&buffer, x - radius, y - radius, -1.0, -1.0);
+  hidgl_add_vertex_tex (&buffer, x - radius, y + radius, -1.0,  1.0);
+  hidgl_add_vertex_tex (&buffer, x + radius, y - radius,  1.0, -1.0);
+  hidgl_add_vertex_tex (&buffer, x + radius, y + radius,  1.0,  1.0);
+  hidgl_add_vertex_tex (&buffer, x + radius, y + radius,  1.0,  1.0);
+  /* NB: Repeated last virtex to separate from other tri-strip */
 }
 
 #define MAX_COMBINED_MALLOCS 2500
@@ -613,38 +673,148 @@ hidgl_fill_polygon (int n_coords, int *x, int *y)
   free (vertices);
 }
 
-struct do_hole_info {
-  double scale;
-};
+static inline void
+stash_vertex (PLINE *contour, int *vertex_comp,
+              float x, float y, float z, float r, float s)
+{
+  contour->tristrip_vertices[(*vertex_comp)++] = x;
+  contour->tristrip_vertices[(*vertex_comp)++] = y;
+#if MEMCPY_VERTEX_DATA
+  contour->tristrip_vertices[(*vertex_comp)++] = z;
+  contour->tristrip_vertices[(*vertex_comp)++] = r;
+  contour->tristrip_vertices[(*vertex_comp)++] = s;
+#endif
+  contour->tristrip_num_vertices ++;
+}
+
+static void
+fill_contour (PLINE *contour)
+{
+  int i;
+  int vertex_comp;
+  cairo_traps_t traps;
+
+  /* If the contour is round, then call hidgl_fill_circle to draw it. */
+  if (contour->is_round) {
+    hidgl_fill_circle (contour->cx, contour->cy, contour->radius);
+    return;
+  }
+
+  /* If we don't have a cached set of tri-strips, compute them */
+  if (contour->tristrip_vertices == NULL) {
+    int tristrip_space;
+    int x1, x2, x3, x4, y_top, y_bot;
+
+    _cairo_traps_init (&traps);
+    bo_contour_to_traps_no_draw (contour, &traps);
+
+    tristrip_space = 0;
+
+    for (i = 0; i < traps.num_traps; i++) {
+      y_top = traps.traps[i].top;
+      y_bot = traps.traps[i].bottom;
+
+      x1 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_top);
+      x2 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_top);
+      x3 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_bot);
+      x4 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_bot);
+
+      if ((x1 == x2) || (x3 == x4)) {
+        tristrip_space += 5; /* Three vertices + repeated start and end */
+      } else {
+        tristrip_space += 6; /* Four vertices + repeated start and end */
+      }
+    }
+
+    if (tristrip_space == 0) {
+      printf ("Strange, contour didn't tesselate\n");
+      return;
+    }
+
+#if MEMCPY_VERTEX_DATA
+    /* NB: MEMCPY of vertex data causes a problem with depth being cached at the wrong level! */
+    contour->tristrip_vertices = malloc (sizeof (float) * 5 * tristrip_space);
+#else
+    contour->tristrip_vertices = malloc (sizeof (float) * 2 * tristrip_space);
+#endif
+    contour->tristrip_num_vertices = 0;
+
+    vertex_comp = 0;
+    for (i = 0; i < traps.num_traps; i++) {
+      y_top = traps.traps[i].top;
+      y_bot = traps.traps[i].bottom;
+
+      x1 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_top);
+      x2 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_top);
+      x3 = _line_compute_intersection_x_for_y (&traps.traps[i].right, y_bot);
+      x4 = _line_compute_intersection_x_for_y (&traps.traps[i].left,  y_bot);
+
+      if (x1 == x2) {
+        /* NB: Repeated first virtex to separate from other tri-strip */
+        stash_vertex (contour, &vertex_comp, x1, y_top, global_depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x1, y_top, global_depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x3, y_bot, global_depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x4, y_bot, global_depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x4, y_bot, global_depth, 0.0, 0.0);
+        /* NB: Repeated last virtex to separate from other tri-strip */
+      } else if (x3 == x4) {
+        /* NB: Repeated first virtex to separate from other tri-strip */
+        stash_vertex (contour, &vertex_comp, x1, y_top, global_depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x1, y_top, global_depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x2, y_top, global_depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x3, y_bot, global_depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x3, y_bot, global_depth, 0.0, 0.0);
+        /* NB: Repeated last virtex to separate from other tri-strip */
+      } else {
+        /* NB: Repeated first virtex to separate from other tri-strip */
+        stash_vertex (contour, &vertex_comp, x2, y_top, global_depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x2, y_top, global_depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x3, y_bot, global_depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x1, y_top, global_depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x4, y_bot, global_depth, 0.0, 0.0);
+        stash_vertex (contour, &vertex_comp, x4, y_bot, global_depth, 0.0, 0.0);
+        /* NB: Repeated last virtex to separate from other tri-strip */
+      }
+    }
+
+    _cairo_traps_fini (&traps);
+  }
+
+  if (contour->tristrip_num_vertices == 0)
+    return;
+
+  hidgl_ensure_vertex_space (&buffer, contour->tristrip_num_vertices);
+
+#if MEMCPY_VERTEX_DATA
+  memcpy (&buffer.triangle_array[buffer.coord_comp_count],
+          contour->tristrip_vertices,
+          sizeof (float) * 5 * contour->tristrip_num_vertices);
+  buffer.coord_comp_count += 5 * contour->tristrip_num_vertices;
+  buffer.vertex_count += contour->tristrip_num_vertices;
+
+#else
+  vertex_comp = 0;
+  for (i = 0; i < contour->tristrip_num_vertices; i++) {
+    int x, y;
+    x = contour->tristrip_vertices[vertex_comp++];
+    y = contour->tristrip_vertices[vertex_comp++];
+    hidgl_add_vertex_tex (&buffer, x, y, 0.0, 0.0);
+  }
+#endif
+
+}
 
 static int
 do_hole (const BoxType *b, void *cl)
 {
-  struct do_hole_info *info = cl;
   PLINE *curc = (PLINE *) b;
-  cairo_traps_t traps;
 
   /* Ignore the outer contour - we draw it first explicitly*/
   if (curc->Flags.orient == PLF_DIR) {
     return 0;
   }
 
-  /* If the contour is round, and hidgl_fill_circle would use
-   * less slices than we have vertices to draw it, then call
-   * hidgl_fill_circle to draw this contour.
-   */
-  if (curc->is_round) {
-    double slices = calc_slices (curc->radius / info->scale, 2 * M_PI);
-    if (slices < curc->Count) {
-      hidgl_fill_circle (curc->cx, curc->cy, curc->radius, info->scale);
-      return 1;
-    }
-  }
-
-  _cairo_traps_init (&traps);
-  bo_contour_to_traps (curc, &traps);
-  _cairo_traps_fini (&traps);
-
+  fill_contour (curc);
   return 1;
 }
 
@@ -654,15 +824,11 @@ static int assigned_bits = 0;
 
 /* FIXME: JUST DRAWS THE FIRST PIECE.. TODO: SUPPORT FOR FULLPOLY POLYGONS */
 void
-hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale)
+hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box)
 {
-  struct do_hole_info info;
   int stencil_bit;
-  cairo_traps_t traps;
 
   CHECK_IS_IN_CONTEXT ();
-  info.scale = scale;
-  global_scale = scale;
 
   if (poly->Clipped == NULL)
     {
@@ -692,7 +858,7 @@ hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale
    */
   /* Drawing operations now set our reference bit in the stencil buffer */
 
-  r_search (poly->Clipped->contour_tree, clip_box, NULL, do_hole, &info);
+  r_search (poly->Clipped->contour_tree, clip_box, NULL, do_hole, NULL);
   hidgl_flush_triangles (&buffer);
 
   /* Drawing operations as masked to areas where the stencil buffer is '0' */
@@ -708,9 +874,7 @@ hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale
                                                               // any bits permitted by the stencil writemask
 
   /* Draw the polygon outer */
-  _cairo_traps_init (&traps);
-  bo_contour_to_traps (poly->Clipped->contours, &traps);
-  _cairo_traps_fini (&traps);
+  fill_contour (poly->Clipped->contours);
   hidgl_flush_triangles (&buffer);
 
   /* Unassign our stencil buffer bit */
@@ -723,14 +887,151 @@ void
 hidgl_fill_rect (int x1, int y1, int x2, int y2)
 {
   CHECK_IS_IN_CONTEXT ();
-  hidgl_ensure_triangle_space (&buffer, 2);
-  hidgl_add_triangle (&buffer, x1, y1, x1, y2, x2, y2);
-  hidgl_add_triangle (&buffer, x2, y1, x2, y2, x1, y1);
+  hidgl_ensure_vertex_space (&buffer, 6);
+
+  /* NB: Repeated first virtex to separate from other tri-strip */
+  hidgl_add_vertex_tex (&buffer, x1, y1, 0.0, 0.0);
+  hidgl_add_vertex_tex (&buffer, x1, y1, 0.0, 0.0);
+  hidgl_add_vertex_tex (&buffer, x1, y2, 0.0, 0.0);
+  hidgl_add_vertex_tex (&buffer, x2, y1, 0.0, 0.0);
+  hidgl_add_vertex_tex (&buffer, x2, y2, 0.0, 0.0);
+  hidgl_add_vertex_tex (&buffer, x2, y2, 0.0, 0.0);
+  /* NB: Repeated last virtex to separate from other tri-strip */
+}
+
+/* From http://gpwiki.org/index.php/OpenGL:Codes:Simple_GLSL_example */
+static void
+printLog(GLuint obj)
+{
+  return;
+  int infologLength = 0;
+  int maxLength;
+  char *infoLog;
+
+  if (glIsShader (obj))
+    glGetShaderiv (obj, GL_INFO_LOG_LENGTH, &maxLength);
+  else
+    glGetProgramiv (obj, GL_INFO_LOG_LENGTH, &maxLength);
+
+  infoLog = malloc (maxLength);
+
+  if (glIsShader (obj))
+    glGetShaderInfoLog (obj, maxLength, &infologLength, infoLog);
+  else
+    glGetProgramInfoLog (obj, maxLength, &infologLength, infoLog);
+
+  if (infologLength > 0)
+    printf ("%s\n", infoLog);
+
+  free (infoLog);
+}
+
+/* From http://gpwiki.org/index.php/OpenGL:Codes:Simple_GLSL_example */
+/* FIXED not to be completely brain-dead with memory allocation! - PCJC2*/
+char *
+file2string (const char *path)
+{
+  FILE *fd;
+  long len, r;
+  char *str;
+
+  if (!(fd = fopen (path, "r")))
+    {
+      fprintf (stderr, "Can't open file '%s' for reading\n", path);
+      return NULL;
+    }
+
+  fseek (fd, 0, SEEK_END);
+  len = ftell(fd);
+
+  printf ("File '%s' is %ld long\n", path, len);
+
+  fseek (fd, 0, SEEK_SET);
+
+  if (!(str = malloc (len * sizeof(char))))
+    {
+      fprintf (stderr, "Can't malloc space for '%s'\n", path);
+      return NULL;
+    }
+
+  r = fread (str, sizeof(char), len, fd);
+
+  str[r - 1] = '\0'; /* Shader sources have to term with null */
+
+  fclose (fd);
+
+  return str;
+}
+
+GLuint sp; /* Shader Program */
+
+void
+hidgl_load_frag_shader (void)
+{
+//  char *vs_source;
+  char *fs_source = "void main()\n"
+                    "{\n"
+                    "  float sqdist;\n"
+                    "  sqdist = dot (gl_TexCoord[0].st, gl_TexCoord[0].st);\n"
+                    "  if (sqdist > 1.0)\n"
+                    "    discard;\n"
+                    "  gl_FragColor = gl_Color;\n"
+                    "}\n";
+
+  /* Compile and load the program */
+
+//  GLuint vs; /* Vertex Shader */
+  GLuint fs; /* Fragment Shader */
+
+#if 0
+  vs_source = file2string ("circular.vert");
+  vs = glCreateShader (GL_VERTEX_SHADER);
+  glShaderSource (vs, 1, &vs_source, NULL);
+  glCompileShader (vs);
+  printLog (vs);
+  free (vs_source);
+#endif
+
+//  fs_source = file2string ("circular.frag");
+  if (fs_source == NULL)
+    return;
+  fs = glCreateShader (GL_FRAGMENT_SHADER);
+  glShaderSource (fs, 1, &fs_source, NULL);
+  glCompileShader (fs);
+  printLog (fs);
+//  free (fs_source);
+
+  sp = glCreateProgram ();
+//  glAttachShader (sp, vs);
+  glAttachShader (sp, fs);
+  glLinkProgram (sp);
+  printLog (sp);
+
+  glUseProgram (sp);
+
+  {
+  GLfloat waveTime = 0,
+          waveWidth = 0.00001,
+          waveHeight = 10;
+  GLint waveTimeLoc = glGetUniformLocation(sp, "waveTime");
+  GLint waveWidthLoc = glGetUniformLocation(sp, "waveWidth");
+  GLint waveHeightLoc = glGetUniformLocation(sp, "waveHeight");
+  /* Change time */
+  glUniform1f(waveTimeLoc, waveTime);
+  glUniform1f(waveWidthLoc, waveWidth);
+  glUniform1f(waveHeightLoc, waveHeight);
+
+  }
 }
 
 void
 hidgl_init (void)
 {
+  static bool done_once = false;
+
+  if (done_once)
+    return;
+
   CHECK_IS_IN_CONTEXT ();
   glGetIntegerv (GL_STENCIL_BITS, &stencil_bits);
 
@@ -746,6 +1047,9 @@ hidgl_init (void)
               "Cannot use stencil buffer to sub-composite layers.\n");
       /* Do we need to disable that somewhere? */
     }
+
+  hidgl_load_frag_shader ();
+  done_once = true;
 }
 
 int
@@ -760,6 +1064,9 @@ hidgl_clean_unassigned_stencil (void)
   CHECK_IS_IN_CONTEXT ();
   glPushAttrib (GL_STENCIL_BUFFER_BIT);
   glStencilMask (~assigned_bits);
+//  if (assigned_bits != 0) {
+//    printf ("Doing masked stencil clear :(\n");
+//  }
   glClearStencil (0);
   glClear (GL_STENCIL_BUFFER_BIT);
   glPopAttrib ();
diff --git a/src/hid/common/hidgl.h b/src/hid/common/hidgl.h
index 1ed8eb3..1e289dc 100644
--- a/src/hid/common/hidgl.h
+++ b/src/hid/common/hidgl.h
@@ -23,11 +23,20 @@
 #ifndef __HIDGL_INCLUDED__
 #define __HIDGL_INCLUDED__
 
-#define TRIANGLE_ARRAY_SIZE 5461
+//#define TRIANGLE_ARRAY_SIZE 5461
+//#define TRIANGLE_ARRAY_SIZE 2740
+//#define TRIANGLE_ARRAY_SIZE 8738
+#define TRIANGLE_ARRAY_SIZE 30000
 typedef struct {
-  GLfloat triangle_array [3 * 3 * TRIANGLE_ARRAY_SIZE];
+//  GLfloat triangle_array [3 * (3 + 2) * TRIANGLE_ARRAY_SIZE];
+  GLfloat *triangle_array;
   unsigned int triangle_count;
   unsigned int coord_comp_count;
+  unsigned int vertex_count;
+  unsigned int total_triangles;
+  unsigned int total_vertices;
+  GLuint vbo_id;
+  bool local;
 } triangle_buffer;
 
 extern triangle_buffer buffer;
@@ -35,25 +44,71 @@ extern float global_depth;
 
 void hidgl_in_context (bool is_in_context);
 void hidgl_init_triangle_array (triangle_buffer *buffer);
+void hidgl_finish_triangle_array (triangle_buffer *buffer);
 void hidgl_flush_triangles (triangle_buffer *buffer);
+void hidgl_ensure_vertex_space (triangle_buffer *buffer, int count);
 void hidgl_ensure_triangle_space (triangle_buffer *buffer, int count);
 
+inline void
+hidgl_add_vertex_3D_tex (triangle_buffer *buffer,
+                         GLfloat x, GLfloat y, GLfloat z,
+                         GLfloat s, GLfloat t)
+{
+  buffer->triangle_array [buffer->coord_comp_count++] = x;
+  buffer->triangle_array [buffer->coord_comp_count++] = y;
+  buffer->triangle_array [buffer->coord_comp_count++] = z;
+  buffer->triangle_array [buffer->coord_comp_count++] = s;
+  buffer->triangle_array [buffer->coord_comp_count++] = t;
+  buffer->vertex_count++;
+  buffer->total_vertices++;
+}
+
+inline void
+hidgl_add_vertex_tex (triangle_buffer *buffer,
+                      GLfloat x, GLfloat y,
+                      GLfloat s, GLfloat t)
+{
+  hidgl_add_vertex_3D_tex (buffer, x, y, global_depth, s, t);
+}
+
+
+static inline void
+hidgl_add_triangle_3D_tex (triangle_buffer *buffer,
+                           GLfloat x1, GLfloat y1, GLfloat z1, GLfloat s1, GLfloat t1,
+                           GLfloat x2, GLfloat y2, GLfloat z2, GLfloat s2, GLfloat t2,
+                           GLfloat x3, GLfloat y3, GLfloat z3, GLfloat s3, GLfloat t3)
+{
+  /* NB: Repeated first virtex to separate from other tri-strip */
+  hidgl_add_vertex_3D_tex (buffer, x1, y1, z1, s1, t1);
+  hidgl_add_vertex_3D_tex (buffer, x1, y1, z1, s1, t1);
+  hidgl_add_vertex_3D_tex (buffer, x2, y2, z2, s2, t2);
+  hidgl_add_vertex_3D_tex (buffer, x3, y3, z3, s3, t3);
+  hidgl_add_vertex_3D_tex (buffer, x3, y3, z3, s3, t3);
+  /* NB: Repeated last virtex to separate from other tri-strip */
+  buffer->triangle_count++;
+  buffer->total_triangles++;
+}
+
 static inline void
 hidgl_add_triangle_3D (triangle_buffer *buffer,
                        GLfloat x1, GLfloat y1, GLfloat z1,
                        GLfloat x2, GLfloat y2, GLfloat z2,
                        GLfloat x3, GLfloat y3, GLfloat z3)
 {
-  buffer->triangle_array [buffer->coord_comp_count++] = x1;
-  buffer->triangle_array [buffer->coord_comp_count++] = y1;
-  buffer->triangle_array [buffer->coord_comp_count++] = z1;
-  buffer->triangle_array [buffer->coord_comp_count++] = x2;
-  buffer->triangle_array [buffer->coord_comp_count++] = y2;
-  buffer->triangle_array [buffer->coord_comp_count++] = z2;
-  buffer->triangle_array [buffer->coord_comp_count++] = x3;
-  buffer->triangle_array [buffer->coord_comp_count++] = y3;
-  buffer->triangle_array [buffer->coord_comp_count++] = z3;
-  buffer->triangle_count++;
+  hidgl_add_triangle_3D_tex (buffer, x1, y1, z1, 0., 0.,
+                                     x2, y2, z2, 0., 0.,
+                                     x3, y3, z3, 0., 0.);
+}
+
+static inline void
+hidgl_add_triangle_tex (triangle_buffer *buffer,
+                        GLfloat x1, GLfloat y1, GLfloat s1, GLfloat t1,
+                        GLfloat x2, GLfloat y2, GLfloat s2, GLfloat t2,
+                        GLfloat x3, GLfloat y3, GLfloat s3, GLfloat t3)
+{
+  hidgl_add_triangle_3D_tex (buffer, x1, y1, global_depth, s1, t1,
+                                     x2, y2, global_depth, s2, t2,
+                                     x3, y3, global_depth, s3, t3);
 }
 
 static inline void
@@ -71,9 +126,9 @@ hidgl_add_triangle (triangle_buffer *buffer,
 void hidgl_draw_line (int cap, double width, int x1, int y1, int x2, int y2, double scale);
 void hidgl_draw_arc (double width, int vx, int vy, int vrx, int vry, int start_angle, int delta_angle, double scale);
 void hidgl_draw_rect (int x1, int y1, int x2, int y2);
-void hidgl_fill_circle (int vx, int vy, int vr, double scale);
+void hidgl_fill_circle (int vx, int vy, int vr);
 void hidgl_fill_polygon (int n_coords, int *x, int *y);
-void hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box, double scale);
+void hidgl_fill_pcb_polygon (PolygonType *poly, const BoxType *clip_box);
 void hidgl_fill_rect (int x1, int y1, int x2, int y2);
 
 void hidgl_init (void);
diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index c7c2ac2..d35b913 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -32,6 +32,8 @@
 #include <dmalloc.h>
 #endif
 
+#undef ONE_SHOT
+//#define ONE_SHOT
 
 RCSID ("$Id$");
 
@@ -81,7 +83,9 @@ typedef struct hid_gc_struct
 }
 hid_gc_struct;
 
-
+#define BOARD_THICKNESS 6300
+#define MASK_COPPER_SPACING 200
+#define SILK_MASK_SPACING 50
 static int
 compute_depth (int group)
 {
@@ -89,45 +93,56 @@ compute_depth (int group)
 
   int solder_group;
   int component_group;
-  int min_phys_group;
-  int max_phys_group;
-  int max_depth;
-  int depth = last_depth_computed;
-  int newgroup;
-  int idx = (group >= 0
-             && group <
-             max_group) ? PCB->LayerGroups.Entries[group][0] : group;
+  int min_copper_group;
+  int max_copper_group;
+  int num_copper_groups;
+  int middle_copper_group;
+  int depth;
 
   solder_group = GetLayerGroupNumberByNumber (solder_silk_layer);
   component_group = GetLayerGroupNumberByNumber (component_silk_layer);
 
-  min_phys_group = MIN (solder_group, component_group);
-  max_phys_group = MAX (solder_group, component_group);
-
-  max_depth = (1 + max_phys_group - min_phys_group) * 10;
+  min_copper_group = MIN (solder_group, component_group);
+  max_copper_group = MAX (solder_group, component_group);
+  num_copper_groups = max_copper_group - min_copper_group + 1;
+  middle_copper_group = min_copper_group + num_copper_groups / 2;
 
   if (group >= 0 && group < max_group) {
-    newgroup = group;
+    if (group >= min_copper_group && group <= max_copper_group) {
+      /* XXX: IS THIS INCORRECT FOR REVERSED GROUP ORDERINGS? */
+      depth = -(group - middle_copper_group) * BOARD_THICKNESS / num_copper_groups;
+    } else {
+      depth = 0;
+    }
 
-    depth = (max_depth - (newgroup - min_phys_group) * 10) * 200 / gport->zoom;
-  } else if (SL_TYPE (idx) == SL_MASK) {
-    if (SL_SIDE (idx) == SL_TOP_SIDE) {
-      depth = (max_depth + 3) * 200 / gport->zoom;
+  } else if (SL_TYPE (group) == SL_MASK) {
+    if (SL_SIDE (group) == SL_TOP_SIDE) {
+      depth = -((min_copper_group - middle_copper_group) * BOARD_THICKNESS / num_copper_groups - MASK_COPPER_SPACING);
     } else {
-      depth = (10 - 3) * 200 / gport->zoom;
+      depth = -((max_copper_group - middle_copper_group) * BOARD_THICKNESS / num_copper_groups + MASK_COPPER_SPACING);
     }
-  } else if (SL_TYPE (idx) == SL_SILK) {
-    if (SL_SIDE (idx) == SL_TOP_SIDE) {
-      depth = (max_depth + 5) * 200 / gport->zoom;
+  } else if (SL_TYPE (group) == SL_SILK) {
+    if (SL_SIDE (group) == SL_TOP_SIDE) {
+      depth = -((min_copper_group - middle_copper_group) * BOARD_THICKNESS / num_copper_groups - MASK_COPPER_SPACING - SILK_MASK_SPACING);
     } else {
-      depth = (10 - 5) * 200 / gport->zoom;
+      depth = -((max_copper_group - middle_copper_group) * BOARD_THICKNESS / num_copper_groups + MASK_COPPER_SPACING + SILK_MASK_SPACING);
     }
-  } else if (SL_TYPE (idx) == SL_INVISIBLE) {
+
+  } else if (SL_TYPE (group) == SL_INVISIBLE) {
+    /* Same as silk, but for the back-side layer */
     if (Settings.ShowSolderSide) {
-      depth = (max_depth + 5) * 200 / gport->zoom;
+      depth = -((min_copper_group - middle_copper_group) * BOARD_THICKNESS / num_copper_groups - MASK_COPPER_SPACING - SILK_MASK_SPACING);
     } else {
-      depth = (10 - 5) * 200 / gport->zoom;
+      depth = -((max_copper_group - middle_copper_group) * BOARD_THICKNESS / num_copper_groups + MASK_COPPER_SPACING + SILK_MASK_SPACING);
     }
+  } else if (SL_TYPE (group) == SL_RATS) {
+    depth = last_depth_computed;
+  } else if (SL_TYPE (group) == SL_FINISHED) {
+    depth = last_depth_computed;
+  } else {
+    /* DEFAULT CASE */
+    printf ("Unknown layer group to set depth for: %i\n", group);
+    depth = last_depth_computed;
   }
 
   last_depth_computed = depth;
@@ -158,6 +173,7 @@ ghid_set_layer (const char *name, int group, int empty)
 
   hidgl_set_depth (compute_depth (group));
 
+//  glFlush ();
   glEnable (GL_STENCIL_TEST);                   // Enable Stencil test
   glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);   // Stencil pass => replace stencil value (with 1)
   hidgl_return_stencil_bit (stencil_bit);       // Relinquish any bitplane we previously used
@@ -171,6 +187,7 @@ ghid_set_layer (const char *name, int group, int empty)
     glStencilFunc (GL_ALWAYS, 0, 0);  // Always pass stencil test
   }
 
+
   if (idx >= 0 && idx < max_copper_layer + 2)
     {
       priv->trans_lines = true;
@@ -244,15 +261,6 @@ ghid_draw_grid (BoxTypePtr drawn_area)
       gport->grid_color.blue ^= gport->bg_color.blue;
     }
 
-  hidgl_flush_triangles (&buffer);
-
-  glEnable (GL_COLOR_LOGIC_OP);
-  glLogicOp (GL_XOR);
-
-  glColor3f (gport->grid_color.red / 65535.,
-             gport->grid_color.green / 65535.,
-             gport->grid_color.blue / 65535.);
-
   x1 = GRIDFIT_X (MAX (0, drawn_area->X1), PCB->Grid);
   y1 = GRIDFIT_Y (MAX (0, drawn_area->Y1), PCB->Grid);
   x2 = GRIDFIT_X (MIN (PCB->MaxWidth, drawn_area->X2), PCB->Grid);
@@ -285,26 +293,36 @@ ghid_draw_grid (BoxTypePtr drawn_area)
 	MyRealloc (points, npoints * 3 * sizeof (GLfloat), "gtk_draw_grid");
     }
 
+  hidgl_flush_triangles (&buffer);
+
+  glColor3f (gport->grid_color.red / 65535.,
+             gport->grid_color.green / 65535.,
+             gport->grid_color.blue / 65535.);
+  glTexCoord2f (0., 0.);
+
+  glDisable (GL_STENCIL_TEST);
+  glEnable (GL_COLOR_LOGIC_OP);
+  glLogicOp (GL_XOR);
   glEnableClientState (GL_VERTEX_ARRAY);
   glVertexPointer (3, GL_FLOAT, 0, points);
 
   n = 0;
   for (x = x1; x <= x2; x += PCB->Grid)
     {
-      points[3 * n] = Vx (x);
+      points[3 * n] = x;
       points[3 * n + 2] = global_depth;
       n++;
     }
   for (y = y1; y <= y2; y += PCB->Grid)
     {
-      int vy = Vy (y);
       for (i = 0; i < n; i++)
-	points[3 * i + 1] = vy;
+	points[3 * i + 1] = y;
       glDrawArrays (GL_POINTS, 0, n);
     }
 
   glDisableClientState (GL_VERTEX_ARRAY);
   glDisable (GL_COLOR_LOGIC_OP);
+  glEnable (GL_STENCIL_TEST);
 }
 
 #if 0
@@ -697,7 +715,7 @@ ghid_fill_circle (hidGC gc, int cx, int cy, int radius)
 {
   USE_GC (gc);
 
-  hidgl_fill_circle (cx, cy, radius, gport->zoom);
+  hidgl_fill_circle (cx, cy, radius);
 }
 
 
@@ -714,7 +732,7 @@ ghid_fill_pcb_polygon (hidGC gc, PolygonType *poly, const BoxType *clip_box)
 {
   USE_GC (gc);
 
-  hidgl_fill_pcb_polygon (poly, clip_box, gport->zoom);
+  hidgl_fill_pcb_polygon (poly, clip_box);
 }
 
 void
@@ -863,6 +881,8 @@ ghid_show_crosshair (gboolean show)
   static GdkColor cross_color;
   extern float global_depth;
 
+  return;
+
   if (!check_gl_drawing_ok_hack)
     return;
 
@@ -881,8 +901,8 @@ ghid_show_crosshair (gboolean show)
   y = DRAW_Y (gport->y_crosshair);
   z = global_depth;
 
-  glEnable (GL_COLOR_LOGIC_OP);
-  glLogicOp (GL_XOR);
+//  glEnable (GL_COLOR_LOGIC_OP);
+//  glLogicOp (GL_XOR);
 
   hidgl_flush_triangles (&buffer);
 
@@ -963,7 +983,7 @@ ghid_show_crosshair (gboolean show)
       draw_markers_prev = FALSE;
     }
 
-  glDisable (GL_COLOR_LOGIC_OP);
+//  glDisable (GL_COLOR_LOGIC_OP);
 }
 
 void
@@ -1015,6 +1035,8 @@ ghid_start_drawing (GHidPort *port)
   if (!gdk_gl_drawable_gl_begin (pGlDrawable, pGlContext))
     return FALSE;
 
+//  hidgl_load_frag_shader ();
+
   return TRUE;
 }
 
@@ -1084,7 +1106,7 @@ EMark_callback (const BoxType * b, void *cl)
 {
   ElementTypePtr element = (ElementTypePtr) b;
 
-  DrawEMark (element, element->MarkX, element->MarkY, !FRONT (element));
+//  DrawEMark (element, element->MarkX, element->MarkY, !FRONT (element));
   return 1;
 }
 
@@ -1523,9 +1545,7 @@ DrawDrillChannel (int vx, int vy, int vr, int from_layer, int to_layer, double s
 #define MIN_FACES_PER_CYL 6
 #define MAX_FACES_PER_CYL 360
   float radius = vr;
-  float x1, y1;
-  float x2, y2;
-  float z1, z2;
+  float x, y, z1, z2;
   int i;
   int slices;
 
@@ -1540,19 +1560,27 @@ DrawDrillChannel (int vx, int vy, int vr, int from_layer, int to_layer, double s
   z1 = compute_depth (from_layer);
   z2 = compute_depth (to_layer);
 
-  x1 = vx + vr;
-  y1 = vy;
+  x = vx + vr;
+  y = vy;
+
+  hidgl_ensure_vertex_space (&buffer, 2 * slices + 2 + 2);
+
+  /* NB: Repeated first virtex to separate from other tri-strip */
+  hidgl_add_vertex_3D_tex (&buffer, x, y, z1, 0.0, 0.0);
+  hidgl_add_vertex_3D_tex (&buffer, x, y, z1, 0.0, 0.0);
+  hidgl_add_vertex_3D_tex (&buffer, x, y, z2, 0.0, 0.0);
 
-  hidgl_ensure_triangle_space (&buffer, 2 * slices);
   for (i = 0; i < slices; i++)
     {
-      x2 = radius * cosf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vx;
-      y2 = radius * sinf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vy;
-      hidgl_add_triangle_3D (&buffer, x1, y1, z1,  x2, y2, z1,  x1, y1, z2);
-      hidgl_add_triangle_3D (&buffer, x2, y2, z1,  x1, y1, z2,  x2, y2, z2);
-      x1 = x2;
-      y1 = y2;
+      x = radius * cosf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vx;
+      y = radius * sinf (((float)(i + 1)) * 2. * M_PI / (float)slices) + vy;
+
+      hidgl_add_vertex_3D_tex (&buffer, x, y, z1, 0.0, 0.0);
+      hidgl_add_vertex_3D_tex (&buffer, x, y, z2, 0.0, 0.0);
     }
+
+  /* NB: Repeated last virtex to separate from other tri-strip */
+  hidgl_add_vertex_3D_tex (&buffer, x, y, z2, 0.0, 0.0);
 }
 
 struct cyl_info {
@@ -1778,15 +1806,22 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
                              GdkEventExpose *ev,
                              GHidPort *port)
 {
+#ifdef ONE_SHOT
   static int one_shot = 1;
   static int display_list;
+#endif
   BoxType region;
-  int eleft, eright, etop, ebottom;
   int min_x, min_y;
   int max_x, max_y;
   int new_x, new_y;
   int min_depth;
   int max_depth;
+  static float wavetime = 0;
+  extern GLuint sp;
+  GLint waveTimeLoc = glGetUniformLocation (sp, "waveTime");
+
+  buffer.total_triangles = 0;
+  buffer.total_vertices = 0;
 
   ghid_start_drawing (port);
 
@@ -1794,6 +1829,9 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   hidgl_init ();
   check_gl_drawing_ok_hack = true;
 
+  wavetime += 0.1;
+  glUniform1f (waveTimeLoc, wavetime);
+
   /* If we don't have any stencil bits available,
      we can't use the hidgl polygon drawing routine */
   /* TODO: We could use the GLU tessellator though */
@@ -1810,10 +1848,12 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
 
   glViewport (0, 0, widget->allocation.width, widget->allocation.height);
 
+#if 1
   glEnable (GL_SCISSOR_TEST);
   glScissor (ev->area.x,
              widget->allocation.height - ev->area.height - ev->area.y,
              ev->area.width, ev->area.height);
+#endif
 
   glMatrixMode (GL_PROJECTION);
   glLoadIdentity ();
@@ -1824,21 +1864,32 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glTranslatef (widget->allocation.width / 2., widget->allocation.height / 2., 0);
   glMultMatrixf ((GLfloat *)view_matrix);
   glTranslatef (-widget->allocation.width / 2., -widget->allocation.height / 2., 0);
+  glScalef ((ghid_flip_x ? -1. : 1.) / port->zoom,
+            (ghid_flip_y ? -1. : 1.) / port->zoom,
+            ((ghid_flip_x == ghid_flip_y) ? 1. : -1.) / port->zoom);
+  glTranslatef (ghid_flip_x ? port->view_x0 - PCB->MaxWidth  :
+                             -port->view_x0,
+                ghid_flip_y ? port->view_y0 - PCB->MaxHeight :
+                             -port->view_y0, 0);
   glGetFloatv (GL_MODELVIEW_MATRIX, (GLfloat *)last_modelview_matrix);
 
-#if 0
+#ifdef ONE_SHOT
   if (one_shot) {
 
     display_list = glGenLists(1);
     glNewList (display_list, GL_COMPILE);
 #endif
 
+#if 1
   glEnable (GL_STENCIL_TEST);
-  glClearColor (port->offlimits_color.red / 65535.,
-                port->offlimits_color.green / 65535.,
-                port->offlimits_color.blue / 65535.,
+//  glClearColor (port->offlimits_color.red / 65535.,
+//                port->offlimits_color.green / 65535.,
+//                port->offlimits_color.blue / 65535.,
+//                1.);
+  glClearColor (gport->bg_color.red / 65535.,
+                gport->bg_color.green / 65535.,
+                gport->bg_color.blue / 65535.,
                 1.);
-
   glStencilMask (~0);
   glClearStencil (0);
   glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
@@ -1849,8 +1900,8 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   glStencilFunc (GL_ALWAYS, 0, 0);
 
   /* Test the 8 corners of a cube spanning the event */
-  min_depth = -50 + compute_depth (0);                /* FIXME */
-  max_depth =  50 + compute_depth (max_copper_layer); /* FIXME */
+  min_depth = -50 + compute_depth (0);                    /* FIXME: NEED TO USE PHYSICAL GROUPS */
+  max_depth =  50 + compute_depth (max_copper_layer - 1); /* FIXME: NEED TO USE PHYSICAL GROUPS */
 
   ghid_unproject_to_z_plane (ev->area.x,
                              ev->area.y,
@@ -1904,13 +1955,8 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   min_x = MIN (min_x, new_x);  max_x = MAX (max_x, new_x);
   min_y = MIN (min_y, new_y);  max_y = MAX (max_y, new_y);
 
-  region.X1 = MIN (Px (min_x), Px (max_x + 1));
-  region.X2 = MAX (Px (min_x), Px (max_x + 1));
-  region.Y1 = MIN (Py (min_y), Py (max_y + 1));
-  region.Y2 = MAX (Py (min_y), Py (max_y + 1));
-
-  eleft = Vx (0);  eright  = Vx (PCB->MaxWidth);
-  etop  = Vy (0);  ebottom = Vy (PCB->MaxHeight);
+  region.X1 = min_x;  region.X2 = max_x + 1;
+  region.Y1 = min_y;  region.Y2 = max_y + 1;
 
   glColor3f (port->bg_color.red / 65535.,
              port->bg_color.green / 65535.,
@@ -1927,23 +1973,20 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
   /* Drawing operations as masked to areas where the stencil buffer is '0' */
 //  glStencilFunc (GL_GREATER, 1, 1);             // Draw only where stencil buffer is 0
 
-  glPushMatrix ();
-  glScalef ((ghid_flip_x ? -1. : 1.) / port->zoom,
-            (ghid_flip_y ? -1. : 1.) / port->zoom,
-            (ghid_flip_x == ghid_flip_y) ? 1. : -1.);
-  glTranslatef (ghid_flip_x ? port->view_x0 - PCB->MaxWidth  :
-                             -port->view_x0,
-                ghid_flip_y ? port->view_y0 - PCB->MaxHeight :
-                             -port->view_y0, 0);
-
+#endif
+#if 0
   if (global_view_2d) {
+//    int count = 0;
     glBegin (GL_QUADS);
-    glVertex3i (0,             0,              0);
-    glVertex3i (PCB->MaxWidth, 0,              0);
-    glVertex3i (PCB->MaxWidth, PCB->MaxHeight, 0);
-    glVertex3i (0,             PCB->MaxHeight, 0);
+//    for (count = 0; count < 30; count++) {
+      glVertex3i (0,             0,              0);
+      glVertex3i (PCB->MaxWidth, 0,              0);
+      glVertex3i (PCB->MaxWidth, PCB->MaxHeight, 0);
+      glVertex3i (0,             PCB->MaxHeight, 0);
+//    }
     glEnd ();
   } else {
+#if 1
     int solder_group;
     int component_group;
     int min_phys_group;
@@ -1965,51 +2008,54 @@ ghid_drawing_area_expose_cb (GtkWidget *widget,
       glVertex3i (0,             PCB->MaxHeight, depth);
     }
     glEnd ();
+#endif
   }
+#endif
+
 
   // hid_expose_callback (&ghid_hid, &region, 0);
   ghid_draw_everything (&region);
   hidgl_flush_triangles (&buffer);
-  glPopMatrix ();
 
   /* Just prod the drawing code so the current depth gets set to
      the right value for the layer we are editing */
+#if 0
   gui->set_layer (NULL, GetLayerGroupNumberByNumber (INDEXOFCURRENT), 0);
-  gui->set_layer (NULL, SL_FINISHED, 0);
-
+  gui->set_layer (NULL, SL (FINISHED, 0), 0);
+#else
+  hidgl_set_depth (compute_depth (GetLayerGroupNumberByNumber (INDEXOFCURRENT)));
+#endif
   ghid_draw_grid (&region);
 
-  hidgl_init_triangle_array (&buffer);
+#if 1
+//  hidgl_init_triangle_array (&buffer);
   ghid_invalidate_current_gc ();
-  glPushMatrix ();
-  glScalef ((ghid_flip_x ? -1. : 1.) / port->zoom,
-            (ghid_flip_y ? -1. : 1.) / port->zoom, 1);
-  glTranslatef (ghid_flip_x ? port->view_x0 - PCB->MaxWidth  :
-                             -port->view_x0,
-                ghid_flip_y ? port->view_y0 - PCB->MaxHeight :
-                             -port->view_y0, 0);
   DrawAttached (TRUE);
   DrawMark (TRUE);
   hidgl_flush_triangles (&buffer);
-  glPopMatrix ();
+#endif
 
-#if 0
+#ifdef ONE_SHOT
     glEndList ();
     one_shot = 0;
-  } else {
-    /* Second and subsequent times */
-    glCallList (display_list);
   }
+
+  glCallList (display_list);
 #endif
 
+  /* FIXME MATRIX ?? */
   ghid_show_crosshair (TRUE);
 
   hidgl_flush_triangles (&buffer);
+  hidgl_finish_triangle_array (&buffer);
 
   check_gl_drawing_ok_hack = false;
   hidgl_in_context (false);
   ghid_end_drawing (port);
 
+//  printf ("Triangle count was %i\n", buffer.total_triangles);
+//  printf ("Vertex count was %i\n", buffer.total_vertices);
+
   return FALSE;
 }
 
@@ -2099,7 +2145,6 @@ ghid_pinout_preview_expose (GtkWidget *widget,
   glStencilMask (~0);
   glClearStencil (0);
   glClear (GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
-
   hidgl_reset_stencil_usage ();
 
   /* call the drawing routine */
diff --git a/src/hid/gtk/gtkhid-main.c b/src/hid/gtk/gtkhid-main.c
index e5418af..1a14478 100644
--- a/src/hid/gtk/gtkhid-main.c
+++ b/src/hid/gtk/gtkhid-main.c
@@ -1604,7 +1604,8 @@ Benchmark (int argc, char **argv, int x, int y)
     {
       gdk_window_invalidate_rect (gport->drawing_area->window, NULL, 1);
       gdk_window_process_updates (gport->drawing_area->window, FALSE);
-      gdk_display_sync (display);
+//      gdk_display_sync (display);
+//      usleep (100000);
       time (&end);
       i++;
     }
diff --git a/src/hid/gtk/gui-output-events.c b/src/hid/gtk/gui-output-events.c
index 476b196..490ccc4 100644
--- a/src/hid/gtk/gui-output-events.c
+++ b/src/hid/gtk/gui-output-events.c
@@ -256,11 +256,11 @@ ghid_note_event_location (GdkEventButton * ev)
 #ifdef ENABLE_GL
   /* Unproject event_x and event_y to world coordinates of the plane we are on */
   ghid_unproject_to_z_plane (event_x, event_y, global_depth,
-                             &event_x, &event_y);
-#endif
-
+                             &gport->view_x, &gport->view_y);
+#else
   gport->view_x = event_x * gport->zoom + gport->view_x0;
   gport->view_y = event_y * gport->zoom + gport->view_y0;
+#endif
 
   moved = MoveCrosshairAbsolute (SIDE_X (gport->view_x), 
 				 SIDE_Y (gport->view_y));
diff --git a/src/hid/gtk/snavi.c b/src/hid/gtk/snavi.c
index 618be32..7d3f961 100644
--- a/src/hid/gtk/snavi.c
+++ b/src/hid/gtk/snavi.c
@@ -51,16 +51,20 @@ int snavi_set_led (GIOChannel *snavi, int led_state)
   GError      *error = NULL;
   gsize        bytes_written;
 
+  event.time.tv_sec = 0;
+  event.time.tv_usec = 0;
   event.type  = EV_LED;
   event.code  = LED_MISC;
   event.value = led_state;
 
+#if 0
   g_io_channel_seek_position (snavi, 0, G_SEEK_END, &error);
   if (error) {
     g_printerr ("Error: %s\n", error->message);
     /* FIXME: FREE THE ERROR??? */
     return FALSE;
   }
+#endif
 
   g_io_channel_write_chars (snavi,
                             (gchar *) &event,
@@ -74,6 +78,7 @@ int snavi_set_led (GIOChannel *snavi, int led_state)
     return FALSE;
   }
 
+#if 0
   g_io_channel_flush (snavi, &error);
 
   if (error) {
@@ -81,6 +86,7 @@ int snavi_set_led (GIOChannel *snavi, int led_state)
     /* FIXME: FREE THE ERROR??? */
     return FALSE;
   }
+#endif
 
   return bytes_written < sizeof (struct input_event);
 }
@@ -114,6 +120,12 @@ gboolean snavi_event (GIOChannel   *source,
 
   switch (event.type)
     {
+      case EV_ABS:
+        if (event.code <= ABS_RZ)
+          axes[event.code - ABS_X] = event.value;
+        break;
+
+        /* I'm not sure, but previously the SpaceNavigator reported as relative events */
       case EV_REL:
         if (event.code <= REL_RZ)
           axes[event.code - REL_X] = event.value;
@@ -140,12 +152,12 @@ gboolean snavi_event (GIOChannel   *source,
             axes[i] = 0;
         }
 
-        update_pan_cb (axes[0] / 100.0,
-                       axes[2] / 100.0,
-                       axes[1] / 100.0, cb_userdata);
-        update_roll_cb (axes[5] / 100.0,
-                        axes[3] / 100.0,
-                        axes[4] / 100.0, cb_userdata);
+        update_pan_cb (axes[0] / 70.0,
+                       axes[2] / 70.0,
+                       axes[1] / 70.0, cb_userdata);
+        update_roll_cb (axes[5] / 60.0,
+                        axes[3] / 60.0,
+                        axes[4] / 60.0, cb_userdata);
         update_done_cb (cb_userdata);
 
         axes[0] = axes[1] = axes[2] = axes[3] = axes[4] = axes[5] = 0;
@@ -175,11 +187,22 @@ setup_snavi (void (*update_pan)(int, int, int, gpointer),
   update_done_cb = update_done;
   button_cb = button;
   cb_userdata = data;
+#if 0
+  int fd;
+  int grab = 1;
 
+  fd = open("/dev/input/spacenavigator", O_RDWR);
+  ioctl (fd, EVIOCGRAB, &grab);
+
+  snavi = g_io_channel_unix_new (fd);
+#else
   snavi = g_io_channel_new_file ("/dev/input/spacenavigator", "r+", NULL);
+#endif
+
   if (snavi)
     {
       g_io_channel_set_encoding (snavi, NULL, NULL);
+      g_io_channel_set_buffered (snavi, FALSE);
       event_id = g_io_add_watch (snavi, G_IO_IN, snavi_event, NULL);
     }
 
diff --git a/src/polyarea.h b/src/polyarea.h
index ce427ad..62a1125 100644
--- a/src/polyarea.h
+++ b/src/polyarea.h
@@ -107,6 +107,8 @@ struct PLINE
       unsigned int status:3;
       unsigned int orient:1;
     } Flags;
+    int tristrip_num_vertices;
+    float *tristrip_vertices;
 };
 
 PLINE *poly_NewContour(Vector v);
diff --git a/src/polygon1.c b/src/polygon1.c
index e7642c9..466d739 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -2583,6 +2583,9 @@ poly_ClrContour (PLINE * c)
       poly_ExclVertex (cur);
       free (cur);
     }
+  free (c->tristrip_vertices);
+  c->tristrip_vertices = NULL;
+  c->tristrip_num_vertices = 0;
   poly_IniContour (c);
 }
 
@@ -2614,6 +2617,7 @@ poly_DelContour (PLINE ** c)
       rtree_t *r = (*c)->tree;
       r_destroy_tree (&r);
     }
+  free ((*c)->tristrip_vertices);
   free (*c), *c = NULL;
 }
 
diff --git a/src/sweep.h b/src/sweep.h
index 257664f..92fdd71 100644
--- a/src/sweep.h
+++ b/src/sweep.h
@@ -2,3 +2,5 @@
 
 cairo_status_t bo_poly_to_traps (POLYAREA *poly, cairo_traps_t *traps);
 cairo_status_t bo_contour_to_traps (PLINE *contour, cairo_traps_t *traps);
+cairo_status_t bo_contour_to_traps_no_draw (PLINE *contour, cairo_traps_t *traps);
+cairo_fixed_t _line_compute_intersection_x_for_y (const cairo_line_t *line, cairo_fixed_t y);

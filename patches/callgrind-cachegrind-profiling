Bottom: 5bab8d79712a183301b7d26f7df7b05ba153da6f
Top:    ce40de69ded7d2ed2fd575fb332a3ca853016c2b
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2008-10-12 14:46:51 +0100

Callgrind / cachegrind profiling driven optimisations



---

diff --git a/src/polygon1.c b/src/polygon1.c
index b2a6bd6..49c2432 100644
--- a/src/polygon1.c
+++ b/src/polygon1.c
@@ -57,6 +57,34 @@
 #define ABS(x) ((x) < 0 ? -(x) : (x))
 #endif
 
+
+/* G_LIKELY and G_UNLIKLEY macros taken from GLib 2.16.3, LGPL */
+/*
+ * The G_LIKELY and G_UNLIKELY macros let the programmer give hints to 
+ * the compiler about the expected result of an expression. Some compilers
+ * can use this information for optimizations.
+ *
+ * The _G_BOOLEAN_EXPR macro is intended to trigger a gcc warning when
+ * putting assignments in g_return_if_fail ().  
+ */
+#if defined(__GNUC__) && (__GNUC__ > 2) && defined(__OPTIMIZE__)
+#define _G_BOOLEAN_EXPR(expr)                   \
+ __extension__ ({                               \
+   int _g_boolean_var_;                         \
+   if (expr)                                    \
+      _g_boolean_var_ = 1;                      \
+   else                                         \
+      _g_boolean_var_ = 0;                      \
+   _g_boolean_var_;                             \
+})
+#define G_LIKELY(expr) (__builtin_expect (_G_BOOLEAN_EXPR(expr), 1))
+#define G_UNLIKELY(expr) (__builtin_expect (_G_BOOLEAN_EXPR(expr), 0))
+#else
+#define G_LIKELY(expr) (expr)
+#define G_UNLIKELY(expr) (expr)
+#endif
+
+
 /*********************************************************************/
 /*              L o n g   V e c t o r   S t u f f                    */
 /*********************************************************************/
@@ -766,6 +794,8 @@ intersect (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
   {
     for (pa = a->contours; pa; pa = pa->next)
       {
+        /* Loop over the contours of POLYAREA a */
+
 	jmp_buf env;
 	/* skip the whole contour if it's bounding box doesn't intersect */
 	if (setjmp (env) == 0)
@@ -776,15 +806,20 @@ intersect (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
 	    sb.X2 = pa->xmax + 1;
 	    sb.Y1 = pa->ymin;
 	    sb.Y2 = pa->ymax + 1;
+
 	    for (pb = b->contours; pb; pb = pb->next)
 	      {
+                /* Loop over the contours of POLYAREA b */
 		/*
 		   if (sb.X1 > pb->xmax || sb.X2 < pb->xmin || sb.Y1 > pb->ymax || sb.Y2 < pb->ymin)
 		   continue;
 		 */
 		info.tree = (rtree_t *) pb->tree;
+#warning NOT SURE IF THIS IS A CANDIDATE FOR G_LIKELY OR NOT?
 		if (info.tree)
 		  r_search (info.tree, &sb, NULL, curtail, &env);
+                else
+                  printf ("No tree in intersect\n");
 	      }
 	    continue;
 	  }
@@ -793,11 +828,14 @@ intersect (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
 	    av = &pa->head;
 	    do
 	      {
+                /* Loop over the nodes in the 'a' contour polyline */
+
 		/* check this edge for any insertions */
 		double dx;
 		info.v = av;
 		/* compute the slant for region trimming */
 		dx = av->next->point[0] - av->point[0];
+#warning Is this a candidate for G_UNLIKELY?
 		if (dx == 0)
 		  info.m = 0;
 		else
@@ -821,10 +859,13 @@ intersect (jmp_buf * jb, POLYAREA * b, POLYAREA * a, int add)
 			|| pb->ymax < info.s->box.Y1)
 		      continue;
 		    info.tree = (rtree_t *) pb->tree;
-		    if (info.tree && r_search
-			(info.tree, &info.s->box, seg_in_region, seg_in_seg,
-			 &info))
-		      return err_no_memory;	/* error */
+#warning CANDIDATE FOR G_LIKELY?
+		    if (info.tree)
+                      if (G_UNLIKELY (r_search (info.tree, &info.s->box,
+                                                seg_in_region,
+                                                seg_in_seg,
+                                                &info)))
+		        return err_no_memory;	/* error */
 		  }
 	      }
 	    while ((av = av->next) != &pa->head);
@@ -841,33 +882,49 @@ M_POLYAREA_intersect2 (jmp_buf * e, POLYAREA * afst, POLYAREA * bfst, int add)
   PLINE *curcA, *curcB;
   CVCList *the_list = NULL;
 
-  if (a == NULL || b == NULL)
+  if (G_UNLIKELY (a == NULL || b == NULL))
     error (err_bad_parm);
   do
     {
+      /* Loop over b's linked list of POLYAREAs */
+
       do
 	{
+          /* Loop over a's linked list of POLYAREAS */
+
+          /* Do the coarse bounding boxes intersect? */
 	  if (a->contours->xmax >= b->contours->xmin &&
 	      a->contours->ymax >= b->contours->ymin &&
 	      a->contours->xmin <= b->contours->xmax &&
 	      a->contours->ymin <= b->contours->ymax)
 	    {
-	      if (intersect (e, a, b, add))
+              /* If so, check the POLYAREA intersection for real */
+	      if (G_UNLIKELY (intersect (e, a, b, add)))
 		error (err_no_memory);
 	    }
 	}
       while ((a = a->f) != afst);
+
+      /* Loop over the contours of the current "b" POLYAREA,
+       * finding those marked as ISECTED, and add descriptors
+       */
       for (curcB = b->contours; curcB != NULL; curcB = curcB->next)
 	if (curcB->Flags.status == ISECTED)
-	  if (!(the_list = add_descriptors (curcB, 'B', the_list)))
+	  if (G_UNLIKELY (!(the_list = add_descriptors (curcB, 'B', the_list))))
 	    error (err_no_memory);
     }
   while ((b = b->f) != bfst);
+
   do
     {
+      /* Loop over a's linked list of POLYAREAS */
+
+      /* Loop over the contours of the current "b" POLYAREA,
+       * finding those marked as ISECTED, and add descriptors
+       */
       for (curcA = a->contours; curcA != NULL; curcA = curcA->next)
 	if (curcA->Flags.status == ISECTED)
-	  if (!(the_list = add_descriptors (curcA, 'A', the_list)))
+	  if (G_UNLIKELY (!(the_list = add_descriptors (curcA, 'A', the_list))))
 	    error (err_no_memory);
     }
   while ((a = a->f) != afst);

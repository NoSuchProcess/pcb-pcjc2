Bottom: 25173c25c88a5842531bb9c5f60a1eff457ead97
Top:    5cbbc512c9827c4137410067f0db98a2cd6f95d5
Author: Peter Clifton <peter@clifton-electronics.co.uk>
Date:   2014-05-16 20:47:34 +0100

puller.c: Fix some cases where we use int rather than Coord


---

diff --git a/src/puller.c b/src/puller.c
index 666b94a..64cb52a 100644
--- a/src/puller.c
+++ b/src/puller.c
@@ -91,22 +91,22 @@ static double arc_dist;
 /* We canonicalize the arc and line such that the point to be moved is
    always Point2 for the line, and at start+delta for the arc.  */
 
-static int x, y;		/* the point we're moving */
-static int cx, cy;		/* centerpoint of the arc */
-static int ex, ey;		/* fixed end of the line */
+static Coord x, y;		/* the point we're moving */
+static Coord cx, cy;		/* centerpoint of the arc */
+static Coord ex, ey;		/* fixed end of the line */
 
 /* 0 is left (-x), 90 is down (+y), 180 is right (+x), 270 is up (-y) */
 
-static int
-within (int x1, int y1, int x2, int y2, int r)
+static Coord
+within (Coord x1, Coord y1, Coord x2, Coord y2, Coord r)
 {
   return Distance (x1, y1, x2, y2) <= r / 2;
 }
 
 static int
-arc_endpoint_is (ArcType *a, int angle, int x, int y)
+arc_endpoint_is (ArcType *a, int angle, Coord x, Coord y)
 {
-  int ax = a->X, ay = a->Y;
+  Coord ax = a->X, ay = a->Y;
 
   if (angle % 90 == 0)
     {
@@ -144,7 +144,7 @@ arc_endpoint_is (ArcType *a, int angle, int x, int y)
 
 /* Cross c->u and c->v, return the magnitute */
 static double
-cross2d (int cx, int cy, int ux, int uy, int vx, int vy)
+cross2d (Coord cx, Coord cy, Coord ux, Coord uy, Coord vx, Coord vy)
 {
   ux -= cx;
   uy -= cy;
@@ -155,7 +155,7 @@ cross2d (int cx, int cy, int ux, int uy, int vx, int vy)
 
 /* Likewise, for dot product. */
 static double
-dot2d (int cx, int cy, int ux, int uy, int vx, int vy)
+dot2d (Coord cx, Coord cy, Coord ux, Coord uy, Coord vx, Coord vy)
 {
   ux -= cx;
   uy -= cy;
@@ -167,19 +167,19 @@ dot2d (int cx, int cy, int ux, int uy, int vx, int vy)
 #if 0
 /* angle of c->v, relative to c->u, in radians.  Range is -pi..pi */
 static double
-angle2d (int cx, int cy, int ux, int uy, int vx, int vy)
+angle2d (Coord cx, Coord cy, Coord ux, Coord uy, Coord vx, Coord vy)
 {
   double cross;
   double magu, magv, sintheta;
 #if TRACE1
-  printf("angle2d %d,%d %d,%d %d,%d\n", cx, cy, ux, uy, vx, vy);
+  pcb_printf("angle2d %mD %mD %mD\n", cx, cy, ux, uy, vx, vy);
 #endif
   ux -= cx;
   uy -= cy;
   vx -= cx;
   vy -= cy;
 #if TRACE1
-  printf(" = %d,%d %d,%d\n", ux, uy, vx, vy);
+  pcb_printf(" = %mD %mD\n", ux, uy, vx, vy);
 #endif
   cross = (double)ux * vy - (double)uy * vx;
   magu = sqrt((double)ux*ux + (double)uy*uy);
@@ -221,9 +221,9 @@ det (double a, double b, double c, double d)
 /* The lines are x1y1-x2y2 and x3y3-x4y4.  Returns true if they
    intersect.  */
 static int
-intersection_of_lines (int x1, int y1, int x2, int y2,
-		       int x3, int y3, int x4, int y4,
-		       int *xr, int *yr)
+intersection_of_lines (Coord x1, Coord y1, Coord x2, Coord y2,
+                       Coord x3, Coord y3, Coord x4, Coord y4,
+                       Coord *xr, Coord *yr)
 {
   double x, y, d;
   d = det (x1 - x2, y1 - y2, x3 - x4, y3 - y4);
@@ -233,17 +233,17 @@ intersection_of_lines (int x1, int y1, int x2, int y2,
 	    det (x3, y3, x4, y4), x3 - x4) / d);
   y = (det (det (x1, y1, x2, y2), y1 - y2,
 	    det (x3, y3, x4, y4), y3 - y4) / d);
-  *xr = (int) (x + 0.5);
-  *yr = (int) (y + 0.5);
+  *xr = (Coord) (x + 0.5);
+  *yr = (Coord) (y + 0.5);
   return 1;
 }
 
 /* Same, for line segments.  Returns true if they intersect.  For this
    function, xr and yr may be NULL if you don't need the values.  */
 static int
-intersection_of_linesegs (int x1, int y1, int x2, int y2,
-			  int x3, int y3, int x4, int y4,
-			  int *xr, int *yr)
+intersection_of_linesegs (Coord x1, Coord y1, Coord x2, Coord y2,
+                          Coord x3, Coord y3, Coord x4, Coord y4,
+                          Coord *xr, Coord *yr)
 {
   double x, y, d;
   d = det (x1 - x2, y1 - y2, x3 - x4, y3 - y4);
@@ -260,15 +260,15 @@ intersection_of_linesegs (int x1, int y1, int x2, int y2,
       || MIN (y3, y4) > y || y > MAX (y3, y4))
     return 0;
   if (xr)
-    *xr = (int) (x + 0.5);
+    *xr = (Coord) (x + 0.5);
   if (yr)
-    *yr = (int) (y + 0.5);
+    *yr = (Coord) (y + 0.5);
   return 1;
 }
 
 /* distance between a line and a point */
 static double
-dist_lp (int x1, int y1, int x2, int y2, int px, int py)
+dist_lp (Coord x1, Coord y1, Coord x2, Coord y2, Coord px, Coord py)
 {
   double den = Distance (x1, y1, x2, y2);
   double rv = (fabs (((double)x2 - x1) * ((double)y1 - py)
@@ -283,7 +283,7 @@ dist_lp (int x1, int y1, int x2, int y2, int px, int py)
 
 /* distance between a line segment and a point */
 static double
-dist_lsp (int x1, int y1, int x2, int y2, int px, int py)
+dist_lsp (Coord x1, Coord y1, Coord x2, Coord y2, Coord px, Coord py)
 {
   double d;
   if (dot2d (x1, y1, x2, y2, px, py) < 0)
@@ -372,7 +372,7 @@ arc_callback (const BoxType * b, void *cl)
 }
 
 static int
-find_pair (int Px, int Py)
+find_pair (Coord Px, Coord Py)
 {
   BoxType spot;
 
@@ -605,7 +605,7 @@ typedef struct End {
   unsigned char at_pin:1;
   unsigned char is_pad:1;
   unsigned char pending:1; /* set if this may be moved later */
-  int x, y; /* arc endpoint */
+  Coord x, y; /* arc endpoint */
   /* If not NULL, points to End with pending==1 we're blocked on. */
   struct End *waiting_for;
 } End;
@@ -702,7 +702,7 @@ fix_arc_extra (ArcType *a, Extra *e)
 
 typedef struct {
   void *me;
-  int x, y;
+  Coord x, y;
   int is_arc;
   Extra **extra_ptr;
 } FindPairCallbackStruct;
@@ -778,7 +778,7 @@ find_pair_arc_callback (const BoxType * b, void *cl)
 }
 
 static void
-find_pairs_1 (void *me, Extra **e, int x, int y)
+find_pairs_1 (void *me, Extra **e, Coord x, Coord y)
 {
   FindPairCallbackStruct fpcs;
   BoxType b;
@@ -802,10 +802,10 @@ find_pairs_1 (void *me, Extra **e, int x, int y)
 }
 
 static int
-check_point_in_pin (PinType *pin, int x, int y, End *e)
+check_point_in_pin (PinType *pin, Coord x, Coord y, End *e)
 {
   int inside_p;
-  int t = (pin->Thickness+1)/2;
+  Coord t = (pin->Thickness+1)/2;
   if (TEST_FLAG (SQUAREFLAG, pin))
     inside_p = (x >= pin->X - t && x <= pin->X + t
 		&& y >= pin->Y - t && y <= pin->Y + t);
@@ -875,10 +875,10 @@ find_pair_pinarc_callback (const BoxType * b, void *cl)
 }
 
 static int
-check_point_in_pad (PadType *pad, int x, int y, End *e)
+check_point_in_pad (PadType *pad, Coord x, Coord y, End *e)
 {
   int inside_p;
-  int t;
+  Coord t;
 
   pcb_printf("pad %#mD - %#mD t %#mS  vs  %#mD\n", pad->Point1.X, pad->Point1.Y,
 	 pad->Point2.X, pad->Point2.Y, pad->Thickness, x, y);
@@ -1326,7 +1326,7 @@ static void
 reverse_line (LineType *line)
 {
   Extra *e = LINE2EXTRA (line);
-  int x, y;
+  Coord x, y;
   End etmp;
 
   x = line->Point1.X;
@@ -1370,7 +1370,7 @@ reverse_arc (ArcType *arc)
 }
 
 static void
-expand_box (BoxType *b, int x, int y, int t)
+expand_box (BoxType *b, Coord x, Coord y, Coord t)
 {
   b->X1 = MIN (b->X1, x-t);
   b->X2 = MAX (b->X2, x+t);
@@ -1390,7 +1390,7 @@ static ArcType *end_arc;
 static Extra *start_extra, *end_extra;
 static Extra *sarc_extra, *earc_extra;
 static void *start_pinpad, *end_pinpad;
-static int thickness;
+static Coord thickness;
 
 /* Pre-computed values.  Note that all values are computed according
    to CARTESIAN coordinates, not PCB coordinates.  Do an up-down board
@@ -1405,21 +1405,22 @@ static double se_sign, sa_sign, ea_sign;
 static double best_angle, start_angle, end_dist;
 /* arc radii are positive when they're on the same side as the things
    we're interested in. */
-static int sa_r, ea_r;
-static int sa_x, sa_y; /* start "arc" point */
+static Coord sa_r, ea_r;
+static Coord sa_x, sa_y; /* start "arc" point */
 
 /* what we've found so far */
-static int fx, fy, fr, fp;
+static Coord fx, fy, fr;
+static int fp;
 static End *fp_end;
 static double fa; /* relative angle */
 
 #define gp_point(x,y,t,e) gp_point_2(x,y,t,e,0,0,__FUNCTION__)
 
 static int
-gp_point_force (int x, int y, int t, End *e, int esa, int eda, int force, const char *name)
+gp_point_force (Coord x, Coord y, Coord t, End *e, int esa, int eda, int force, const char *name)
 {
   double r, a, d;
-  int scx, scy, sr;
+  Coord scx, scy, sr;
   double base_angle, rel_angle, point_angle;
 
 #if TRACE1
@@ -1585,7 +1586,7 @@ gp_point_force (int x, int y, int t, End *e, int esa, int eda, int force, const
   return 1;
 }
 static int
-gp_point_2 (int x, int y, int t, End *e, int esa, int eda, const char *func)
+gp_point_2 (Coord x, Coord y, Coord t, End *e, int esa, int eda, const char *func)
 {
   double sc, ec;
   double sd, ed;
@@ -1749,7 +1750,7 @@ static int
 gp_pin_cb (const BoxType *b, void *cb)
 {
   const PinType *p = (PinType *) b;
-  int t2 = (p->Thickness+1)/2;
+  Coord t2 = (p->Thickness+1)/2;
 
   if (p == start_pinpad || p == end_pinpad)
     return 0;
@@ -1774,7 +1775,7 @@ static int
 gp_pad_cb (const BoxType *b, void *cb)
 {
   const PadType *p = (PadType *) b;
-  int t2 = (p->Thickness+1)/2;
+  Coord t2 = (p->Thickness+1)/2;
 
   if (p == start_pinpad || p == end_pinpad)
     return 0;
@@ -1796,8 +1797,8 @@ gp_pad_cb (const BoxType *b, void *cb)
     {
       if (p->Point1.X == p->Point2.X)
 	{
-	  int y1 = MIN (p->Point1.Y, p->Point2.Y) - t2;
-	  int y2 = MAX (p->Point1.Y, p->Point2.Y) + t2;
+	  Coord y1 = MIN (p->Point1.Y, p->Point2.Y) - t2;
+	  Coord y2 = MAX (p->Point1.Y, p->Point2.Y) + t2;
 
 	  gp_point (p->Point1.X - t2, y1, 0, 0);
 	  gp_point (p->Point1.X - t2, y2, 0, 0);
@@ -1806,8 +1807,8 @@ gp_pad_cb (const BoxType *b, void *cb)
 	}
       else
 	{
-	  int x1 = MIN (p->Point1.X, p->Point2.X) - t2;
-	  int x2 = MAX (p->Point1.X, p->Point2.X) + t2;
+	  Coord x1 = MIN (p->Point1.X, p->Point2.X) - t2;
+	  Coord x2 = MAX (p->Point1.X, p->Point2.X) + t2;
 
 	  gp_point (x1, p->Point1.Y - t2, 0, 0);
 	  gp_point (x2, p->Point1.Y - t2, 0, 0);
@@ -1824,7 +1825,7 @@ gp_pad_cb (const BoxType *b, void *cb)
 }
 
 static LineType *
-create_line (LineType *sample, int x1, int y1, int x2, int y2)
+create_line (LineType *sample, Coord x1, Coord y1, Coord x2, Coord y2)
 {
 #if TRACE1
   Extra *e;
@@ -1845,7 +1846,7 @@ create_line (LineType *sample, int x1, int y1, int x2, int y2)
 }
 
 static ArcType *
-create_arc (LineType *sample, int x, int y, int r, int sa, int da)
+create_arc (LineType *sample, Coord x, Coord y, Coord r, Coord sa, Coord da)
 {
   Extra *e;
   ArcType *arc;
@@ -1997,7 +1998,7 @@ maybe_pull_1 (LineType *line)
 {
   BoxType box;
   /* Line half-thicknesses, including line space */
-  int ex, ey;
+  Coord ex, ey;
   LineType *new_line;
   Extra *new_lextra;
   ArcType *new_arc;
@@ -2301,7 +2302,7 @@ maybe_pull_1 (LineType *line)
     double oy = fy + fr * sin(oa);
 #if TRACE1
     pcb_printf("obstacle at %#mD angle %d = arc starts at %#mD\n",
-	   fx, fy, (int)r2d(oa), (int)ox, (int)oy);
+	   fx, fy, (int)r2d(oa), (Coord)ox, (Coord)oy);
 #endif
 
     if (Distance (ox, oy, end_line->Point2.X, end_line->Point2.Y)

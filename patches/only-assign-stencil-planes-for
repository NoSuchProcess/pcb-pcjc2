Bottom: a57a0af6e610ab2cc16dcd07da7b6e9913ef5216
Top:    490230df829ea3abf916451667392e2dab75e151
Author: Peter Clifton <pcjc2@cam.ac.uk>
Date:   2011-04-25 15:58:36 +0100

Only assign stencil planes for visible layers

NB: Split out of the FBO patch


---

diff --git a/src/hid/gtk/gtkhid-gl.c b/src/hid/gtk/gtkhid-gl.c
index 67f9654..81ec8e7 100644
--- a/src/hid/gtk/gtkhid-gl.c
+++ b/src/hid/gtk/gtkhid-gl.c
@@ -156,6 +156,7 @@ ghid_set_layer (const char *name, int group, int empty)
 {
   render_priv *priv = gport->render_priv;
   static int stencil_bit = 0;
+  bool group_visible = false;
   int idx = group;
   if (idx >= 0 && idx < max_group)
     {
@@ -175,48 +176,53 @@ ghid_set_layer (const char *name, int group, int empty)
 
   hidgl_set_depth (compute_depth (group));
 
-  glEnable (GL_STENCIL_TEST);                   // Enable Stencil test
-  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);   // Stencil pass => replace stencil value (with 1)
-  hidgl_return_stencil_bit (stencil_bit);       // Relinquish any bitplane we previously used
-  if (SL_TYPE (idx) != SL_FINISHED) {
-    stencil_bit = hidgl_assign_clear_stencil_bit();       // Get a new (clean) bitplane to stencil with
-    glStencilMask (stencil_bit);                          // Only write to our subcompositing stencil bitplane
-    glStencilFunc (GL_GREATER, stencil_bit, stencil_bit); // Pass stencil test if our assigned bit is clear
-  } else {
-    stencil_bit = 0;
-    glStencilMask (0);
-    glStencilFunc (GL_ALWAYS, 0, 0);  // Always pass stencil test
-  }
-
   if (idx >= 0 && idx < max_copper_layer + 2)
     {
       priv->trans_lines = true;
-      return PCB->Data->Layer[idx].On;
+      group_visible = PCB->Data->Layer[idx].On;
     }
-
-  if (idx < 0)
+  else if (idx < 0)
     {
       switch (SL_TYPE (idx))
 	{
 	case SL_INVISIBLE:
-	  return PCB->InvisibleObjectsOn;
+	  group_visible = PCB->InvisibleObjectsOn;
+	  break;
 	case SL_MASK:
-	  return TEST_FLAG (SHOWMASKFLAG, PCB);
+	  group_visible = TEST_FLAG (SHOWMASKFLAG, PCB);
+	  break;
 	case SL_SILK:
 	  priv->trans_lines = true;
-	  return PCB->ElementOn;
+	  group_visible = PCB->ElementOn;
+	  break;
 	case SL_ASSY:
-	  return 0;
+	  break;
 	case SL_PDRILL:
 	case SL_UDRILL:
-	  return 1;
+	  group_visible = true;
+	  break;
 	case SL_RATS:
 	  if (PCB->RatOn)
 	    priv->trans_lines = true;
-	  return PCB->RatOn;
+	  group_visible = PCB->RatOn;
+	  break;
 	}
     }
-  return 0;
+
+  glEnable (GL_STENCIL_TEST);                   // Enable Stencil test
+  glStencilOp (GL_KEEP, GL_KEEP, GL_REPLACE);   // Stencil pass => replace stencil value (with 1)
+  hidgl_return_stencil_bit (stencil_bit);       // Relinquish any bitplane we previously used
+  if (group_visible) {
+    stencil_bit = hidgl_assign_clear_stencil_bit();       // Get a new (clean) bitplane to stencil with
+    glStencilMask (stencil_bit);                          // Only write to our subcompositing stencil bitplane
+    glStencilFunc (GL_GREATER, stencil_bit, stencil_bit); // Pass stencil test if our assigned bit is clear
+  } else {
+    stencil_bit = 0;
+    glStencilMask (0);
+    glStencilFunc (GL_ALWAYS, 0, 0);  // Always pass stencil test
+  }
+
+  return group_visible;
 }
 
 void
